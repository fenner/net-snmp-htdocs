<!--#set var="section" value="documentation" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
    <h1>The Net-SNMP library</h1>Section: net-snmp (3)<br />
    Updated: 28 Dec 2005<br />
    <a href="#index">Index</a> <a href="../index.html">Return to Main Contents</a>
    <hr />
    <a name="lbAB" id="lbAB"> </a>

    <h2>NAME</h2>The Net-SNMP library - <a name="lbAC" id="lbAC"> </a>

    <h3>Modules</h3>

    <p><br />
    group <b>asn1 parsing and datatype manipulation routines.</b><br />
    <br />
    group <b>A generic callback mechanism</b><br />
    <br />
    group <b>generic linked-list data handling with a string as a key.</b><br />
    <br />
    group <b>storage space for defaults</b><br />
    <i>The purpose of the default storage is three-fold:.</i></p>

    <p><br />
    group <b>mib parsing and datatype manipulation routines.</b><br />
    <br />
    group <b>Store and retrieve data referenced by an OID.</b><br />
    <i>This is essentially a way of storing data associated with a given OID.</i></p>

    <p><br />
    group <b>parsing various configuration files at run time</b><br />
    <i>The read_config related functions are a fairly extensible system of parsing various configuration files at the run
    time.</i></p>

    <p><br />
    group <b>generic library based alarm timers for various parts of an application</b><br />
    <br />
    group <b>various PDU processing routines</b><br />
    <br />
    group <b>generic logging for net-snmp</b><br />
    <br />
    group <b>Memory Utility Routines</b><br />
    <a name="lbAD" id="lbAD"> </a></p>

    <h3>Data Structures</h3>

    <p><br />
    struct <b>snmp_internal_session</b><br />
    <br />
    struct <b>session_list</b><br />
    <a name="lbAE" id="lbAE"> </a></p>

    <h3>Defines</h3>

    <p><br />
    #define <b>MIN</b>(a, b) (((a) &lt; (b)) ? (a) : (b))<br />
    <br />
    #define <b>MIB_CLIENTS_ARE_EVIL</b> 1<br />
    <br />
    #define <b>_init_agent_callback_transport</b>()<br />
    <br />
    #define <b>SNMP_NEED_REQUEST_LIST</b><br />
    <br />
    #define <b>timercmp</b>(tvp, uvp, cmp)<br />
    <br />
    #define <b>timerclear</b>(tvp) (tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0<br />
    <br />
    #define <b>MAX_PACKET_LENGTH</b> (0x7fffffff)<br />
    <br />
    #define <b>NETSNMP_STREAM_QUEUE_LEN</b> 5<br />
    <br />
    #define <b>BSD4_2</b><br />
    <br />
    #define <b>NFDBITS</b> (sizeof(fd_mask) * NBBY)<br />
    <br />
    #define <b>FD_SET</b>(n, p) ((p)-&gt;fds_bits[(n)/NFDBITS] |= (1 &lt;&lt; ((n) % NFDBITS)))<br />
    <br />
    #define <b>FD_CLR</b>(n, p) ((p)-&gt;fds_bits[(n)/NFDBITS] &amp;= ~(1 &lt;&lt; ((n) % NFDBITS)))<br />
    <br />
    #define <b>FD_ISSET</b>(n, p) ((p)-&gt;fds_bits[(n)/NFDBITS] &amp; (1 &lt;&lt; ((n) % NFDBITS)))<br />
    <br />
    #define <b>FD_ZERO</b>(p) memset((p), 0, sizeof(*(p)))<br />
    <br />
    #define <b>DEFAULT_COMMUNITY</b> 'public'<br />
    <br />
    #define <b>DEFAULT_RETRIES</b> 5<br />
    <br />
    #define <b>DEFAULT_TIMEOUT</b> 1000000L<br />
    <br />
    #define <b>DEFAULT_REMPORT</b> SNMP_PORT<br />
    <br />
    #define <b>DEFAULT_ENTERPRISE</b> default_enterprise<br />
    <br />
    #define <b>DEFAULT_TIME</b> 0<br />
    <br />
    #define <b>MAXIMUM_PACKET_SIZE</b> 0x7fffffff<br />
    <br />
    #define <b>DEBUGPRINTPDUTYPE</b>(token, type) DEBUGDUMPSECTION(token, snmp_pdu_type(type))<br />
    <br />
    #define <b>ERROR_STAT_LENGTH</b> 11<br />
    <a name="lbAF" id="lbAF"> </a></p>

    <h3>Typedefs</h3>

    <p><br />
    typedef long <b>fd_mask</b><br />
    <a name="lbAG" id="lbAG"> </a></p>

    <h3>Functions</h3>

    <p><br />
    int <b>init_agent</b> (const char *app)<br />
    <i>Initialize the agent.</i><br />
    void <b>shutdown_agent</b> (void)<br />
    <br />
    void <b>add_to_init_list</b> (char *module_list)<br />
    <br />
    int <b>should_init</b> (const char *module_name)<br />
    <br />
    int <b>snmp_build</b> (u_char **pkt, size_t *pkt_len, size_t *offset, <b>netsnmp_session</b> *pss, <b>netsnmp_pdu</b>
    *pdu)<br />
    <br />
    int <b>snmp_get_errno</b> (void)<br />
    <br />
    void <b>snmp_synch_reset</b> (<b>netsnmp_session</b> *notused)<br />
    <br />
    void <b>snmp_synch_setup</b> (<b>netsnmp_session</b> *notused)<br />
    <br />
    const char * <b>strerror</b> (int err)<br />
    <br />
    const char * <b>snmp_pdu_type</b> (int type)<br />
    <br />
    long <b>snmp_get_next_reqid</b> (void)<br />
    <br />
    long <b>snmp_get_next_msgid</b> (void)<br />
    <br />
    long <b>snmp_get_next_sessid</b> (void)<br />
    <br />
    long <b>snmp_get_next_transid</b> (void)<br />
    <br />
    void <b>snmp_perror</b> (const char *prog_string)<br />
    <br />
    void <b>snmp_set_detail</b> (const char *detail_string)<br />
    <br />
    const char * <b>snmp_api_errstring</b> (int snmp_errnumber)<br />
    <br />
    void <b>snmp_error</b> (<b>netsnmp_session</b> *psess, int *p_errno, int *p_snmp_errno, char **p_str)<br />
    <br />
    void <b>snmp_sess_error</b> (void *sessp, int *p_errno, int *p_snmp_errno, char **p_str)<br />
    <br />
    void <b>netsnmp_sess_log_error</b> (int priority, const char *prog_string, <b>netsnmp_session</b> *ss)<br />
    <br />
    void <b>snmp_sess_perror</b> (const char *prog_string, <b>netsnmp_session</b> *ss)<br />
    <br />
    void <b>snmp_sess_init</b> (<b>netsnmp_session</b> *session)<br />
    <br />
    void <b>init_snmp_enums</b> (void)<br />
    <br />
    void <b>init_snmp</b> (const char *type)<br />
    <i>Calls the functions to do config file loading and mib module parsing in the correct order.</i><br />
    void <b>snmp_store</b> (const char *type)<br />
    <br />
    void <b>snmp_shutdown</b> (const char *type)<br />
    <i>Shuts down the application, saving any needed persistent storage, and appropriate clean up.</i><br />
    <b>netsnmp_session</b> * <b>snmp_open</b> (<b>netsnmp_session</b> *session)<br />
    <br />
    <b>netsnmp_session</b> * <b>snmp_open_ex</b> (<b>netsnmp_session</b> *session, int(*fpre_parse)(<b>netsnmp_session</b> *,
    netsnmp_transport *, void *, int), int(*fparse)(<b>netsnmp_session</b> *, <b>netsnmp_pdu</b> *, u_char *, size_t),
    int(*fpost_parse)(<b>netsnmp_session</b> *, <b>netsnmp_pdu</b> *, int), int(*fbuild)(<b>netsnmp_session</b> *,
    <b>netsnmp_pdu</b> *, u_char *, size_t *), int(*frbuild)(<b>netsnmp_session</b> *, <b>netsnmp_pdu</b> *, u_char **, size_t *,
    size_t *), int(*fcheck)(u_char *, size_t))<br />
    <br />
    int <b>snmpv3_engineID_probe</b> (struct session_list *slp, <b>netsnmp_session</b> *in_session)<br />
    <i>probe for peer engineID</i><br />
    <b>netsnmp_session</b> * <b>snmp_add</b> (<b>netsnmp_session</b> *in_session, netsnmp_transport *transport,
    int(*fpre_parse)(<b>netsnmp_session</b> *, netsnmp_transport *, void *, int), int(*fpost_parse)(<b>netsnmp_session</b> *,
    <b>netsnmp_pdu</b> *, int))<br />
    <br />
    <b>netsnmp_session</b> * <b>snmp_add_full</b> (<b>netsnmp_session</b> *in_session, netsnmp_transport *transport,
    int(*fpre_parse)(<b>netsnmp_session</b> *, netsnmp_transport *, void *, int), int(*fparse)(<b>netsnmp_session</b> *,
    <b>netsnmp_pdu</b> *, u_char *, size_t), int(*fpost_parse)(<b>netsnmp_session</b> *, <b>netsnmp_pdu</b> *, int),
    int(*fbuild)(<b>netsnmp_session</b> *, <b>netsnmp_pdu</b> *, u_char *, size_t *), int(*frbuild)(<b>netsnmp_session</b> *,
    <b>netsnmp_pdu</b> *, u_char **, size_t *, size_t *), int(*fcheck)(u_char *, size_t), <b>netsnmp_pdu</b>
    *(*fcreate_pdu)(netsnmp_transport *, void *, size_t))<br />
    <br />
    void * <b>snmp_sess_add_ex</b> (<b>netsnmp_session</b> *in_session, netsnmp_transport *transport,
    int(*fpre_parse)(<b>netsnmp_session</b> *, netsnmp_transport *, void *, int), int(*fparse)(<b>netsnmp_session</b> *,
    <b>netsnmp_pdu</b> *, u_char *, size_t), int(*fpost_parse)(<b>netsnmp_session</b> *, <b>netsnmp_pdu</b> *, int),
    int(*fbuild)(<b>netsnmp_session</b> *, <b>netsnmp_pdu</b> *, u_char *, size_t *), int(*frbuild)(<b>netsnmp_session</b> *,
    <b>netsnmp_pdu</b> *, u_char **, size_t *, size_t *), int(*fcheck)(u_char *, size_t), <b>netsnmp_pdu</b>
    *(*fcreate_pdu)(netsnmp_transport *, void *, size_t))<br />
    <br />
    void * <b>snmp_sess_add</b> (<b>netsnmp_session</b> *in_session, netsnmp_transport *transport,
    int(*fpre_parse)(<b>netsnmp_session</b> *, netsnmp_transport *, void *, int), int(*fpost_parse)(<b>netsnmp_session</b> *,
    <b>netsnmp_pdu</b> *, int))<br />
    <br />
    void * <b>snmp_sess_open</b> (<b>netsnmp_session</b> *pss)<br />
    <br />
    int <b>create_user_from_session</b> (<b>netsnmp_session</b> *session)<br />
    <br />
    int <b>snmp_sess_close</b> (void *sessp)<br />
    <br />
    int <b>snmp_close</b> (<b>netsnmp_session</b> *session)<br />
    <br />
    int <b>snmp_close_sessions</b> (void)<br />
    <br />
    int <b>snmpv3_packet_build</b> (<b>netsnmp_session</b> *session, <b>netsnmp_pdu</b> *pdu, u_char *packet, size_t *out_length,
    u_char *pdu_data, size_t pdu_data_len)<br />
    <br />
    u_char * <b>snmp_pdu_build</b> (<b>netsnmp_pdu</b> *pdu, u_char *cp, size_t *out_length)<br />
    <br />
    int <b>snmpv3_parse</b> (<b>netsnmp_pdu</b> *pdu, u_char *data, size_t *length, u_char **after_header, <b>netsnmp_session</b>
    *sess)<br />
    <br />
    int <b>snmpv3_make_report</b> (<b>netsnmp_pdu</b> *pdu, int error)<br />
    <br />
    int <b>snmpv3_get_report_type</b> (<b>netsnmp_pdu</b> *pdu)<br />
    <br />
    int <b>snmp_pdu_parse</b> (<b>netsnmp_pdu</b> *pdu, u_char *data, size_t *length)<br />
    <br />
    u_char * <b>snmpv3_scopedPDU_parse</b> (<b>netsnmp_pdu</b> *pdu, u_char *cp, size_t *length)<br />
    <br />
    int <b>snmp_send</b> (<b>netsnmp_session</b> *session, <b>netsnmp_pdu</b> *pdu)<br />
    <br />
    int <b>snmp_sess_send</b> (void *sessp, <b>netsnmp_pdu</b> *pdu)<br />
    <br />
    int <b>snmp_async_send</b> (<b>netsnmp_session</b> *session, <b>netsnmp_pdu</b> *pdu, snmp_callback callback, void
    *cb_data)<br />
    <br />
    int <b>snmp_sess_async_send</b> (void *sessp, <b>netsnmp_pdu</b> *pdu, snmp_callback callback, void *cb_data)<br />
    <br />
    void <b>snmp_free_var</b> (<b>netsnmp_variable_list</b> *var)<br />
    <br />
    void <b>snmp_free_varbind</b> (<b>netsnmp_variable_list</b> *var)<br />
    <br />
    void <b>snmp_free_pdu</b> (<b>netsnmp_pdu</b> *pdu)<br />
    <br />
    <b>netsnmp_pdu</b> * <b>snmp_create_sess_pdu</b> (netsnmp_transport *transport, void *opaque, size_t olength)<br />
    <br />
    void <b>snmp_read</b> (fd_set *fdset)<br />
    <br />
    int <b>_sess_read</b> (void *sessp, fd_set *fdset)<br />
    <br />
    int <b>snmp_sess_read</b> (void *sessp, fd_set *fdset)<br />
    <br />
    int <b>snmp_select_info</b> (int *numfds, fd_set *fdset, struct timeval *timeout, int *block)<br />
    <br />
    int <b>snmp_sess_select_info</b> (void *sessp, int *numfds, fd_set *fdset, struct timeval *timeout, int *block)<br />
    <br />
    void <b>snmp_timeout</b> (void)<br />
    <br />
    void <b>snmp_sess_timeout</b> (void *sessp)<br />
    <br />
    int <b>snmp_oid_ncompare</b> (const oid *in_name1, size_t len1, const oid *in_name2, size_t len2, size_t max_len)<br />
    <br />
    int <b>snmp_oid_compare</b> (const oid *in_name1, size_t len1, const oid *in_name2, size_t len2)<br />
    <i>lexicographical compare two object identifiers.</i><br />
    int <b>netsnmp_oid_compare_ll</b> (const oid *in_name1, size_t len1, const oid *in_name2, size_t len2, size_t *offpt)<br />
    <i>lexicographical compare two object identifiers and return the point where they differ</i><br />
    int <b>snmp_oidtree_compare</b> (const oid *in_name1, size_t len1, const oid *in_name2, size_t len2)<br />
    <i>Compares 2 OIDs to determine if they are equal up until the shortest length.</i><br />
    int <b>netsnmp_oid_equals</b> (const oid *in_name1, size_t len1, const oid *in_name2, size_t len2)<br />
    <i>Compares 2 OIDs to determine if they are exactly equal.</i><br />
    int <b>netsnmp_oid_is_subtree</b> (const oid *in_name1, size_t len1, const oid *in_name2, size_t len2)<br />
    <i>Identical to netsnmp_oid_equals, except only the length up to len1 is compared.</i><br />
    int <b>netsnmp_oid_find_prefix</b> (const oid *in_name1, size_t len1, const oid *in_name2, size_t len2)<br />
    <i>Given two OIDs, determine the common prefix to them both.</i><br />
    <b>netsnmp_variable_list</b> * <b>snmp_pdu_add_variable</b> (<b>netsnmp_pdu</b> *pdu, const oid *name, size_t name_length,
    u_char type, const u_char *value, size_t len)<br />
    <br />
    <b>netsnmp_variable_list</b> * <b>snmp_varlist_add_variable</b> (<b>netsnmp_variable_list</b> **varlist, const oid *name,
    size_t name_length, u_char type, const u_char *value, size_t len)<br />
    <br />
    int <b>snmp_add_var</b> (<b>netsnmp_pdu</b> *pdu, const oid *name, size_t name_length, char type, const char *value)<br />
    <br />
    void * <b>snmp_sess_pointer</b> (<b>netsnmp_session</b> *session)<br />
    <br />
    <b>netsnmp_session</b> * <b>snmp_sess_session</b> (void *sessp)<br />
    <br />
    netsnmp_transport * <b>snmp_sess_transport</b> (void *sessp)<br />
    <br />
    void <b>snmp_sess_transport_set</b> (void *sp, netsnmp_transport *t)<br />
    <br />
    oid * <b>snmp_duplicate_objid</b> (const oid *objToCopy, size_t objToCopyLen)<br />
    <br />
    u_int <b>snmp_increment_statistic</b> (int which)<br />
    <br />
    u_int <b>snmp_increment_statistic_by</b> (int which, int count)<br />
    <br />
    u_int <b>snmp_get_statistic</b> (int which)<br />
    <br />
    void <b>snmp_init_statistics</b> (void)<br />
    <a name="lbAH" id="lbAH"> </a></p>

    <h3>Variables</h3>

    <p><br />
    module_init_list * <b>initlist</b> = NULL<br />
    <br />
    module_init_list * <b>noinitlist</b> = NULL<br />
    <br />
    netsnmp_subtree * <b>subtrees</b><br />
    <br />
    long <b>long_return</b><br />
    <br />
    u_char <b>return_buf</b> [258]<br />
    <br />
    timeval <b>starttime</b><br />
    <br />
    int <b>callback_master_num</b> = -1<br />
    <br />
    oid <b>nullOid</b> [] = { 0, 0 }<br />
    <br />
    int <b>nullOidLen</b> = sizeof(nullOid)<br />
    <br />
    session_list * <b>Sessions</b> = NULL<br />
    <br />
    int <b>snmp_errno</b> = 0<br />
    <a name="lbAI" id="lbAI"> </a></p>

    <h2>Define Documentation</h2>

    <p><a name="lbAJ" id="lbAJ"> </a></p>

    <h3>#define timercmp(tvp, uvp, cmp)</h3>

    <p><b>Value:</b></p>
    <pre>
/* CSTYLED */         ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec ||         ((tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec &amp;&amp;         /* CSTYLED */         (tvp)-&gt;tv_usec cmp (uvp)-&gt;tv_usec))
</pre>

    <p>Definition at line 147 of file snmp_api.c. <a name="lbAK" id="lbAK"> </a></p>

    <h2>Function Documentation</h2>

    <p><a name="lbAL" id="lbAL"> </a></p>

    <h3>int _sess_read (void * sessp, fd_set * fdset)</h3>

    <p>XXX-rks: why no SNMP_FREE(isp-&gt;packet); ??</p>

    <p>XXX-rks: why no SNMP_FREE(isp-&gt;packet); ??</p>

    <p>Definition at line 5398 of file snmp_api.c.</p>

    <p>References snmp_session::callback, snmp_session::callback_magic, snmp_session::flags, snmp_session::next,
    snmp_session::s_errno, snmp_session::s_snmp_errno, SNMP_FREE, and snmp_log(). <a name="lbAM" id="lbAM"> </a></p>

    <h3>int init_agent (const char * app)</h3>

    <p>Initialize the agent.</p>

    <p>Calls into init_agent_read_config to set tha app's configuration file in the appropriate default storage space,
    NETSNMP_DS_LIB_APPTYPE. Need to call init_agent before calling init_snmp.</p>

    <p><b>Parameters:</b></p>

    <dl compact="compact">
      <dd><i>app</i> the configuration file to be read in, gets stored in default storage</dd>
    </dl>

    <p><b>Returns:</b></p>

    <dl compact="compact">
      <dd>Returns non-zero on failure and zero on success.</dd>
    </dl>

    <p><b>See also:</b></p>

    <dl compact="compact">
      <dd><b>init_snmp</b></dd>
    </dl>

    <p>Definition at line 270 of file snmp_vars.c.</p>

    <p>References netsnmp_ds_set_boolean(), netsnmp_init_helpers(), and snmp_log(). <a name="lbAN" id="lbAN"> </a></p>

    <h3>void init_snmp (const char * type)</h3>

    <p>Calls the functions to do config file loading and mib module parsing in the correct order.</p>

    <p><b>Parameters:</b></p>

    <dl compact="compact">
      <dd><i>type</i> label for the config file 'type'</dd>
    </dl>

    <p><b>Returns:</b></p>

    <dl compact="compact">
      <dd>void</dd>
    </dl>

    <p><b>See also:</b></p>

    <dl compact="compact">
      <dd><b>init_agent</b></dd>
    </dl>

    <p>Definition at line 793 of file snmp_api.c.</p>

    <p>References init_mib(). <a name="lbAO" id="lbAO"> </a></p>

    <h3>int netsnmp_oid_compare_ll (const oid * in_name1, size_t len1, const oid * in_name2, size_t len2, size_t * offpt)</h3>

    <p>lexicographical compare two object identifiers and return the point where they differ</p>

    <p>Caution: this method is called often by command responder applications (ie, agent).</p>

    <p><b>Returns:</b></p>

    <dl compact="compact">
      <dd>-1 if name1 &lt; name2, 0 if name1 = name2, 1 if name1 &gt; name2 and offpt = len where name1 != name2</dd>
    </dl>

    <p>Definition at line 6333 of file snmp_api.c. <a name="lbAP" id="lbAP"> </a></p>

    <h3>int netsnmp_oid_equals (const oid * in_name1, size_t len1, const oid * in_name2, size_t len2)</h3>

    <p>Compares 2 OIDs to determine if they are exactly equal.</p>

    <p>This should be faster than doing a snmp_oid_compare for different length OIDs, since the length is checked first and if !=
    returns immediately. Might be very slighly faster if lengths are ==.</p>

    <p><b>Parameters:</b></p>

    <dl compact="compact">
      <dd><i>in_name1</i> A pointer to the first oid.<br />
      <i>len1</i> length of the first OID (in segments, not bytes)<br />
      <i>in_name2</i> A pointer to the second oid.<br />
      <i>len2</i> length of the second OID (in segments, not bytes)</dd>
    </dl>

    <p><b>Returns:</b></p>

    <dl compact="compact">
      <dd>0 if they are equal, 1 if they are not.</dd>
    </dl>

    <p>Definition at line 6405 of file snmp_api.c.</p>

    <p>Referenced by netsnmp_cache_find_by_oid(), netsnmp_old_api_helper(), and unregister_mib_context(). <a name="lbAQ" id=
    "lbAQ"> </a></p>

    <h3>int netsnmp_oid_find_prefix (const oid * in_name1, size_t len1, const oid * in_name2, size_t len2)</h3>

    <p>Given two OIDs, determine the common prefix to them both.</p>

    <p><b>Parameters:</b></p>

    <dl compact="compact">
      <dd><i>in_name1</i> A pointer to the first oid.<br />
      <i>len1</i> Length of the first oid.<br />
      <i>in_name2</i> A pointer to the second oid.<br />
      <i>len2</i> Length of the second oid.</dd>
    </dl>

    <p><b>Returns:</b></p>

    <dl compact="compact">
      <dd>length of largest common index of commonality. 1 = first, 0 if none * or -1 on error.</dd>
    </dl>

    <p>Definition at line 6461 of file snmp_api.c.</p>

    <p>References SNMP_MIN.</p>

    <p>Referenced by netsnmp_add_varbind_to_cache(). <a name="lbAR" id="lbAR"> </a></p>

    <h3>int netsnmp_oid_is_subtree (const oid * in_name1, size_t len1, const oid * in_name2, size_t len2)</h3>

    <p>Identical to netsnmp_oid_equals, except only the length up to len1 is compared.</p>

    <p>Functionally, this determines if in_name2 is equal or a subtree of in_name1</p>

    <p><b>Parameters:</b></p>

    <dl compact="compact">
      <dd><i>in_name1</i> A pointer to the first oid.<br />
      <i>len1</i> length of the first OID (in segments, not bytes)<br />
      <i>in_name2</i> A pointer to the second oid.<br />
      <i>len2</i> length of the second OID (in segments, not bytes)</dd>
    </dl>

    <p><b>Returns:</b></p>

    <dl compact="compact">
      <dd>0 if one is a common prefix of the other.</dd>
    </dl>

    <p>Definition at line 6441 of file snmp_api.c. <a name="lbAS" id="lbAS"> </a></p>

    <h3>int snmp_oid_compare (const oid * in_name1, size_t len1, const oid * in_name2, size_t len2)</h3>

    <p>lexicographical compare two object identifiers.</p>

    <p>Caution: this method is called often by command responder applications (ie, agent).</p>

    <p><b>Returns:</b></p>

    <dl compact="compact">
      <dd>-1 if name1 &lt; name2, 0 if name1 = name2, 1 if name1 &gt; name2</dd>
    </dl>

    <p>Definition at line 6284 of file snmp_api.c.</p>

    <p>Referenced by check_getnext_results(), netsnmp_check_getnext_reply(), netsnmp_container_table_row_insert(),
    netsnmp_insert_iterator_context(), netsnmp_insert_table_row(), netsnmp_row_merge_helper_handler(),
    netsnmp_table_data_add_row(), netsnmp_table_data_get_from_oid(), netsnmp_tdata_compare_oid(), snmp_oidtree_compare(), and
    table_helper_handler(). <a name="lbAT" id="lbAT"> </a></p>

    <h3>int snmp_oidtree_compare (const oid * in_name1, size_t len1, const oid * in_name2, size_t len2)</h3>

    <p>Compares 2 OIDs to determine if they are equal up until the shortest length.</p>

    <p><b>Parameters:</b></p>

    <dl compact="compact">
      <dd><i>in_name1</i> A pointer to the first oid.<br />
      <i>len1</i> length of the first OID (in segments, not bytes)<br />
      <i>in_name2</i> A pointer to the second oid.<br />
      <i>len2</i> length of the second OID (in segments, not bytes)</dd>
    </dl>

    <p><b>Returns:</b></p>

    <dl compact="compact">
      <dd>0 if they are equal, 1 if in_name1 is &gt; in_name2, or -1 if &lt;.</dd>
    </dl>

    <p>Definition at line 6386 of file snmp_api.c.</p>

    <p>References snmp_oid_compare().</p>

    <p>Referenced by snmp_set_var_value(). <a name="lbAU" id="lbAU"> </a></p>

    <h3>void snmp_shutdown (const char * type)</h3>

    <p>Shuts down the application, saving any needed persistent storage, and appropriate clean up.</p>

    <p><b>Parameters:</b></p>

    <dl compact="compact">
      <dd><i>type</i> Label for the config file 'type' used</dd>
    </dl>

    <p><b>Returns:</b></p>

    <dl compact="compact">
      <dd>void</dd>
    </dl>

    <p>Definition at line 862 of file snmp_api.c.</p>

    <p>References shutdown_mib(), snmp_alarm_unregister_all(), and snmp_call_callbacks(). <a name="lbAV" id="lbAV"> </a></p>

    <h3>int snmpv3_engineID_probe (struct session_list * slp, <b>netsnmp_session</b> * in_session)</h3>

    <p>probe for peer engineID</p>

    <p><b>Parameters:</b></p>

    <dl compact="compact">
      <dd><i>slp</i> session list pointer.<br />
      <i>in_session</i> session for errors</dd>
    </dl>

    <p><b>Note:</b></p>

    <dl compact="compact">
      <dd>
        <dl compact="compact">
          <dt>*</dt>

          <dd>called by _sess_open(), snmp_sess_add_ex()</dd>

          <dt>*</dt>

          <dd>in_session is the user supplied session provided to those functions.</dd>

          <dt>*</dt>

          <dd>the first session in slp should the internal allocated copy of in_session</dd>
        </dl>
      </dd>
    </dl>

    <p><b>Returns:</b></p>

    <dl compact="compact">
      <dd>
        0 : error

        <p>1 : ok</p>
      </dd>
    </dl>

    <p>Definition at line 1278 of file snmp_api.c.</p>

    <p>References snmp_session::engineBoots, snmp_session::engineTime, snmp_session::flags, snmp_session::s_snmp_errno,
    snmp_session::securityEngineID, snmp_session::securityEngineIDLen, and snmp_session::version.</p>
    <hr />
    <a name="index" id="index"> </a>

    <h2>Index</h2>

    <dl>
      <dt><a href="#lbAB">NAME</a></dt>

      <dd>
        <dl>
          <dt><a href="#lbAC">Modules</a></dt>

          <dt><a href="#lbAD">Data Structures</a></dt>

          <dt><a href="#lbAE">Defines</a></dt>

          <dt><a href="#lbAF">Typedefs</a></dt>

          <dt><a href="#lbAG">Functions</a></dt>

          <dt><a href="#lbAH">Variables</a></dt>
        </dl>
      </dd>

      <dt><a href="#lbAI">Define Documentation</a></dt>

      <dd>
        <dl>
          <dt><a href="#lbAJ">#define timercmp(tvp, uvp, cmp)</a></dt>
        </dl>
      </dd>

      <dt><a href="#lbAK">Function Documentation</a></dt>

      <dd>
        <dl>
          <dt><a href="#lbAL">int _sess_read (void * sessp, fd_set * fdset)</a></dt>

          <dt><a href="#lbAM">int init_agent (const char * app)</a></dt>

          <dt><a href="#lbAN">void init_snmp (const char * type)</a></dt>

          <dt><a href="#lbAO">int netsnmp_oid_compare_ll (const oid * in_name1, size_t len1, const oid * in_name2, size_t len2,
          size_t * offpt)</a></dt>

          <dt><a href="#lbAP">int netsnmp_oid_equals (const oid * in_name1, size_t len1, const oid * in_name2, size_t
          len2)</a></dt>

          <dt><a href="#lbAQ">int netsnmp_oid_find_prefix (const oid * in_name1, size_t len1, const oid * in_name2, size_t
          len2)</a></dt>

          <dt><a href="#lbAR">int netsnmp_oid_is_subtree (const oid * in_name1, size_t len1, const oid * in_name2, size_t
          len2)</a></dt>

          <dt><a href="#lbAS">int snmp_oid_compare (const oid * in_name1, size_t len1, const oid * in_name2, size_t
          len2)</a></dt>

          <dt><a href="#lbAT">int snmp_oidtree_compare (const oid * in_name1, size_t len1, const oid * in_name2, size_t
          len2)</a></dt>

          <dt><a href="#lbAU">void snmp_shutdown (const char * type)</a></dt>

          <dt><a href="#lbAV">int snmpv3_engineID_probe (struct session_list * slp, <b>netsnmp_session</b> * in_session)</a></dt>
        </dl>
      </dd>
    </dl>
    <hr />
    This document was created by <a href="http://localhost/cgi-bin/man/man2html">man2html</a>, using the manual pages.<br />
    Time: 17:34:33 GMT, December 30, 2005
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

