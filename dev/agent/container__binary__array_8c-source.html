<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>container_binary_array.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * container_binary_array.c</span>
00003 <span class="comment"> * $Id$</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * see comments in header file.</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> */</span>
00008 
00009 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00010 
00011 <span class="preprocessor">#if HAVE_IO_H</span>
00012 <span class="preprocessor">#include &lt;io.h&gt;</span>
00013 <span class="preprocessor">#endif</span>
00014 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00015 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00016 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00017 <span class="preprocessor">#endif</span>
00018 <span class="preprocessor">#if HAVE_MALLOC_H</span>
00019 <span class="preprocessor">#include &lt;malloc.h&gt;</span>
00020 <span class="preprocessor">#endif</span>
00021 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00022 <span class="preprocessor">#if HAVE_STRING_H</span>
00023 <span class="preprocessor">#include &lt;string.h&gt;</span>
00024 <span class="preprocessor">#else</span>
00025 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00026 <span class="preprocessor">#endif</span>
00027 
00028 <span class="preprocessor">#include &lt;net-snmp/net-snmp-includes.h&gt;</span>
00029 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00030 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00031 <span class="preprocessor">#include &lt;net-snmp/library/container.h&gt;</span>
00032 <span class="preprocessor">#include &lt;net-snmp/library/container_binary_array.h&gt;</span>
00033 <span class="preprocessor">#include &lt;net-snmp/library/tools.h&gt;</span>
00034 <span class="preprocessor">#include &lt;net-snmp/library/snmp_assert.h&gt;</span>
00035 
00036 <span class="keyword">typedef</span> <span class="keyword">struct </span>binary_array_table_s {
00037     size_t                     max_size;   <span class="comment">/* Size of the current data table */</span>
00038     size_t                     count;      <span class="comment">/* Index of the next free entry */</span>
00039     u_int                      flags;      <span class="comment">/* flags */</span>
00040     <span class="keywordtype">int</span>                        dirty;
00041     <span class="keywordtype">int</span>                        data_size;  <span class=
"comment">/* Size of an individual entry */</span>
00042     <span class="keywordtype">void</span>                     **data;       <span class=
"comment">/* The table itself */</span>
00043 } binary_array_table;
00044 
00045 <span class="keyword">typedef</span> <span class="keyword">struct </span>binary_array_iterator_s {
00046     netsnmp_iterator base;
00047 
00048     size_t           pos;
00049 } binary_array_iterator;
00050 
00051 <span class="keyword">static</span> netsnmp_iterator *_ba_iterator_get(netsnmp_container *c);
00052 
00053 <span class="comment">/**********************************************************************</span>
00054 <span class="comment"> *</span>
00055 <span class="comment"> * </span>
00056 <span class="comment"> *</span>
00057 <span class="comment"> */</span>
00058 <span class="keyword">static</span> <span class="keywordtype">void</span>
00059 array_qsort(<span class="keywordtype">void</span> **data, <span class="keywordtype">int</span> first, <span class=
"keywordtype">int</span> last, netsnmp_container_compare *f)
00060 {
00061     <span class="keywordtype">int</span> i, j;
00062     <span class="keywordtype">void</span> *mid, *tmp;
00063     
00064     i = first;
00065     j = last;
00066     mid = data[(first+last)/2];
00067     
00068     <span class="keywordflow">do</span> {
00069         <span class="keywordflow">while</span> ( ((*f)(data[i], mid) &lt; 0) &amp;&amp; (i &lt; last))
00070             ++i;
00071         <span class="keywordflow">while</span> ( ((*f)(mid, data[j]) &lt; 0) &amp;&amp; (j &gt; first))
00072             --j;
00073 
00074         <span class="keywordflow">if</span>(i &lt; j) {
00075             tmp = data[i];
00076             data[i] = data[j];
00077             data[j] = tmp;
00078             ++i;
00079             --j;
00080         }
00081         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == j) {
00082             ++i;
00083             --j;
00084             <span class="keywordflow">break</span>;
00085         }
00086     } <span class="keywordflow">while</span>(i &lt;= j);
00087 
00088     <span class="keywordflow">if</span> (j &gt; first)
00089         array_qsort(data, first, j, f);
00090     
00091     <span class="keywordflow">if</span> (i &lt; last)
00092         array_qsort(data, i, last, f);
00093 }
00094 
00095 <span class="keyword">static</span> <span class="keywordtype">int</span>
00096 Sort_Array(netsnmp_container *c)
00097 {
00098     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00099     netsnmp_assert(t!=NULL);
00100     netsnmp_assert(c-&gt;compare!=NULL);
00101 
00102     <span class="keywordflow">if</span> (t-&gt;flags &amp; CONTAINER_KEY_UNSORTED)
00103         <span class="keywordflow">return</span> 0;
00104 
00105     <span class="keywordflow">if</span> (t-&gt;dirty) {
00106         <span class="comment">/*</span>
00107 <span class="comment">         * Sort the table </span>
00108 <span class="comment">         */</span>
00109         <span class="keywordflow">if</span> (t-&gt;count &gt; 1)
00110             array_qsort(t-&gt;data, 0, t-&gt;count - 1, c-&gt;compare);
00111         t-&gt;dirty = 0;
00112 
00113         ++c-&gt;sync;
00114     }
00115 
00116     <span class="keywordflow">return</span> 1;
00117 }
00118 
00119 <span class="keyword">static</span> <span class="keywordtype">int</span>
00120 binary_search(<span class="keyword">const</span> <span class=
"keywordtype">void</span> *val, netsnmp_container *c, <span class="keywordtype">int</span> exact)
00121 {
00122     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00123     size_t             len = t-&gt;count;
00124     size_t             half;
00125     size_t             middle = 0;
00126     size_t             first = 0;
00127     <span class="keywordtype">int</span>                result = 0;
00128 
00129     <span class="keywordflow">if</span> (!len)
00130         <span class="keywordflow">return</span> -1;
00131 
00132     <span class="keywordflow">if</span> (t-&gt;dirty)
00133         Sort_Array(c);
00134 
00135     <span class="keywordflow">while</span> (len &gt; 0) {
00136         half = len &gt;&gt; 1;
00137         middle = first;
00138         middle += half;
00139         <span class="keywordflow">if</span> ((result =
00140              c-&gt;compare(t-&gt;data[middle], val)) &lt; 0) {
00141             first = middle;
00142             ++first;
00143             len = len - half - 1;
00144         } <span class="keywordflow">else</span> {
00145             <span class="keywordflow">if</span>(result == 0) {
00146                 first = middle;
00147                 <span class="keywordflow">break</span>;
00148             }
00149             len = half;
00150         }
00151     }
00152 
00153     <span class="keywordflow">if</span> (first &gt;= t-&gt;count)
00154         <span class="keywordflow">return</span> -1;
00155 
00156     <span class="keywordflow">if</span>(first != middle) {
00157         <span class="comment">/* last compare wasn't against first, so get actual result */</span>
00158         result = c-&gt;compare(t-&gt;data[first], val);
00159     }
00160 
00161     <span class="keywordflow">if</span>(result == 0) {
00162         <span class="keywordflow">if</span> (!exact) {
00163             <span class="keywordflow">if</span> (++first == t-&gt;count)
00164                first = -1;
00165         }
00166     }
00167     <span class="keywordflow">else</span> {
00168         <span class="keywordflow">if</span>(exact)
00169             first = -1;
00170     }
00171 
00172     <span class="keywordflow">return</span> first;
00173 }
00174 
00175 NETSNMP_STATIC_INLINE binary_array_table *
00176 netsnmp_binary_array_initialize(<span class="keywordtype">void</span>)
00177 {
00178     binary_array_table *t;
00179 
00180     t = <a class="code" href="group__util.html#ga39">SNMP_MALLOC_TYPEDEF</a>(binary_array_table);
00181     <span class="keywordflow">if</span> (t == NULL)
00182         <span class="keywordflow">return</span> NULL;
00183 
00184     t-&gt;max_size = 0;
00185     t-&gt;count = 0;
00186     t-&gt;dirty = 0;
00187     t-&gt;data_size = <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*);
00188     t-&gt;data = NULL;
00189 
00190     <span class="keywordflow">return</span> t;
00191 }
00192 
00193 <span class="keywordtype">void</span>
00194 netsnmp_binary_array_release(netsnmp_container *c)
00195 {
00196     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00197     <span class="keywordflow">if</span> (t-&gt;data != NULL) {
00198         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(t-&gt;data);
00199     }
00200     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(t);
00201     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(c);
00202 }
00203 
00204 <span class="keywordtype">int</span>
00205 netsnmp_binary_array_options_set(netsnmp_container *c, <span class="keywordtype">int</span> set, u_int flags)
00206 {
00207     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00208     <span class="keywordflow">if</span> (set)
00209         t-&gt;flags = flags;
00210     <span class="keywordflow">else</span>
00211         <span class="keywordflow">return</span> ((t-&gt;flags &amp; flags) == flags);
00212     <span class="keywordflow">return</span> flags;
00213 }
00214 
00215 NETSNMP_STATIC_INLINE size_t
00216 netsnmp_binary_array_count(netsnmp_container *c)
00217 {
00218     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00219     <span class="comment">/*</span>
00220 <span class="comment">     * return count</span>
00221 <span class="comment">     */</span>
00222     <span class="keywordflow">return</span> t ? t-&gt;count : 0;
00223 }
00224 
00225 NETSNMP_STATIC_INLINE <span class="keywordtype">void</span>           *
00226 netsnmp_binary_array_get(netsnmp_container *c, <span class="keyword">const</span> <span class=
"keywordtype">void</span> *key, <span class="keywordtype">int</span> exact)
00227 {
00228     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00229     <span class="keywordtype">int</span>             index = 0;
00230 
00231     <span class="comment">/*</span>
00232 <span class="comment">     * if there is no data, return NULL;</span>
00233 <span class="comment">     */</span>
00234     <span class="keywordflow">if</span> (!t-&gt;count)
00235         <span class="keywordflow">return</span> 0;
00236 
00237     <span class="comment">/*</span>
00238 <span class="comment">     * if the table is dirty, sort it.</span>
00239 <span class="comment">     */</span>
00240     <span class="keywordflow">if</span> (t-&gt;dirty)
00241         Sort_Array(c);
00242 
00243     <span class="comment">/*</span>
00244 <span class="comment">     * if there is a key, search. Otherwise default is 0;</span>
00245 <span class="comment">     */</span>
00246     <span class="keywordflow">if</span> (key) {
00247         <span class="keywordflow">if</span> ((index = binary_search(key, c, exact)) == -1)
00248             <span class="keywordflow">return</span> 0;
00249     }
00250 
00251     <span class="keywordflow">return</span> t-&gt;data[index];
00252 }
00253 
00254 NETSNMP_STATIC_INLINE <span class="keywordtype">int</span>
00255 netsnmp_binary_array_replace(netsnmp_container *c, <span class="keywordtype">void</span> *entry)
00256 {
00257     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00258     <span class="keywordtype">int</span>             index = 0;
00259 
00260     <span class="comment">/*</span>
00261 <span class="comment">     * if there is no data, return NULL;</span>
00262 <span class="comment">     */</span>
00263     <span class="keywordflow">if</span> (!t-&gt;count)
00264         <span class="keywordflow">return</span> 0;
00265 
00266     <span class="comment">/*</span>
00267 <span class="comment">     * if the table is dirty, sort it.</span>
00268 <span class="comment">     */</span>
00269     <span class="keywordflow">if</span> (t-&gt;dirty)
00270         Sort_Array(c);
00271 
00272     <span class="comment">/*</span>
00273 <span class="comment">     * search</span>
00274 <span class="comment">     */</span>
00275     <span class="keywordflow">if</span> ((index = binary_search(entry, c, 1)) == -1)
00276         <span class="keywordflow">return</span> 0;
00277 
00278     t-&gt;data[index] = entry;
00279 
00280     <span class="keywordflow">return</span> 0;
00281 }
00282 
00283 <span class="keywordtype">int</span>
00284 netsnmp_binary_array_remove(netsnmp_container *c, <span class="keyword">const</span> <span class=
"keywordtype">void</span> *key, <span class="keywordtype">void</span> **save)
00285 {
00286     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00287     size_t             index = 0;
00288 
00289     <span class="keywordflow">if</span> (save)
00290         *save = NULL;
00291     
00292     <span class="comment">/*</span>
00293 <span class="comment">     * if there is no data, return NULL;</span>
00294 <span class="comment">     */</span>
00295     <span class="keywordflow">if</span> (!t-&gt;count)
00296         <span class="keywordflow">return</span> 0;
00297 
00298     <span class="comment">/*</span>
00299 <span class="comment">     * if the table is dirty, sort it.</span>
00300 <span class="comment">     */</span>
00301     <span class="keywordflow">if</span> (t-&gt;dirty)
00302         Sort_Array(c);
00303 
00304     <span class="comment">/*</span>
00305 <span class="comment">     * search</span>
00306 <span class="comment">     */</span>
00307     <span class="keywordflow">if</span> ((index = binary_search(key, c, 1)) == -1)
00308         <span class="keywordflow">return</span> -1;
00309 
00310     <span class="comment">/*</span>
00311 <span class="comment">     * find old data and save it, if ptr provided</span>
00312 <span class="comment">     */</span>
00313     <span class="keywordflow">if</span> (save)
00314         *save = t-&gt;data[index];
00315 
00316     <span class="comment">/*</span>
00317 <span class="comment">     * if entry was last item, just decrement count</span>
00318 <span class="comment">     */</span>
00319     --t-&gt;count;
00320     <span class="keywordflow">if</span> (index != t-&gt;count) {
00321         <span class="comment">/*</span>
00322 <span class="comment">         * otherwise, shift array down</span>
00323 <span class="comment">         */</span>
00324         memmove(&amp;t-&gt;data[index], &amp;t-&gt;data[index+1], t-&gt;data_size * (t-&gt;count - index));
00325     }
00326 
00327     <span class="keywordflow">return</span> 0;
00328 }
00329 
00330 NETSNMP_STATIC_INLINE <span class="keywordtype">void</span>
00331 netsnmp_binary_array_for_each(netsnmp_container *c,
00332                               netsnmp_container_obj_func *fe,
00333                               <span class="keywordtype">void</span> *context, <span class="keywordtype">int</span> sort)
00334 {
00335     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00336     size_t             i;
00337 
00338     <span class="keywordflow">if</span> (sort &amp;&amp; t-&gt;dirty)
00339         Sort_Array(c);
00340 
00341     <span class="keywordflow">for</span> (i = 0; i &lt; t-&gt;count; ++i)
00342         (*fe) (t-&gt;data[i], context);
00343 }
00344 
00345 NETSNMP_STATIC_INLINE <span class="keywordtype">void</span>
00346 netsnmp_binary_array_clear(netsnmp_container *c,
00347                            netsnmp_container_obj_func *fe,
00348                            <span class="keywordtype">void</span> *context)
00349 {
00350     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00351 
00352     <span class="keywordflow">if</span>( NULL != fe ) {
00353         size_t             i;
00354 
00355         <span class="keywordflow">for</span> (i = 0; i &lt; t-&gt;count; ++i)
00356             (*fe) (t-&gt;data[i], context);
00357     }
00358 
00359     t-&gt;count = 0;
00360     t-&gt;dirty = 0;
00361     ++c-&gt;sync;
00362 }
00363 
00364 NETSNMP_STATIC_INLINE <span class="keywordtype">int</span>
00365 netsnmp_binary_array_insert(netsnmp_container *c, <span class="keyword">const</span> <span class=
"keywordtype">void</span> *entry)
00366 {
00367     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00368     <span class="keywordtype">int</span>             new_max;
00369     <span class="keywordtype">void</span>           *new_data;   <span class=
"comment">/* Used for * a) extending the data table</span>
00370 <span class="comment">                                 * * b) the next entry to use */</span>
00371     <span class="comment">/*</span>
00372 <span class="comment">     * check for duplicates</span>
00373 <span class="comment">     */</span>
00374     <span class="keywordflow">if</span> (! (t-&gt;flags &amp; CONTAINER_KEY_ALLOW_DUPLICATES)) {
00375         new_data = netsnmp_binary_array_get(c, entry, 1);
00376         <span class="keywordflow">if</span> (NULL != new_data) {
00377             DEBUGMSGTL((<span class="stringliteral">"container"</span>,<span class=
"stringliteral">"not inserting duplicate key\n"</span>));
00378             <span class="keywordflow">return</span> -1;
00379         }
00380     }
00381     
00382     <span class="comment">/*</span>
00383 <span class="comment">     * check if we need to resize the array</span>
00384 <span class="comment">     */</span>
00385     <span class="keywordflow">if</span> (t-&gt;max_size &lt;= t-&gt;count) {
00386         <span class="comment">/*</span>
00387 <span class="comment">         * Table is full, so extend it to double the size</span>
00388 <span class="comment">         */</span>
00389         new_max = 2 * t-&gt;max_size;
00390         <span class="keywordflow">if</span> (new_max == 0)
00391             new_max = 10;       <span class="comment">/* Start with 10 entries */</span>
00392 
00393         new_data = (<span class="keywordtype">void</span> *) calloc(new_max, t-&gt;data_size);
00394         <span class="keywordflow">if</span> (new_data == NULL)
00395             <span class="keywordflow">return</span> -1;
00396 
00397         <span class="keywordflow">if</span> (t-&gt;data) {
00398             memcpy(new_data, t-&gt;data, t-&gt;max_size * t-&gt;data_size);
00399             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(t-&gt;data);
00400         }
00401         t-&gt;data = new_data;
00402         t-&gt;max_size = new_max;
00403     }
00404 
00405     <span class="comment">/*</span>
00406 <span class="comment">     * Insert the new entry into the data array</span>
00407 <span class="comment">     */</span>
00408     t-&gt;data[t-&gt;count++] = entry;
00409     t-&gt;dirty = 1;
00410     <span class="keywordflow">return</span> 0;
00411 }
00412 
00413 NETSNMP_STATIC_INLINE <span class="keywordtype">void</span>           *
00414 netsnmp_binary_array_retrieve(netsnmp_container *c, <span class="keywordtype">int</span> *max_oids, <span class=
"keywordtype">int</span> sort)
00415 {
00416     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00417     <span class="keywordflow">if</span> (sort &amp;&amp; t-&gt;dirty)
00418         Sort_Array(c);
00419 
00420     *max_oids = t-&gt;count;
00421     <span class="keywordflow">return</span> t-&gt;data;
00422 }
00423 
00424 <span class="comment">/**********************************************************************</span>
00425 <span class="comment"> *</span>
00426 <span class="comment"> * Special case support for subsets</span>
00427 <span class="comment"> *</span>
00428 <span class="comment"> */</span>
00429 <span class="keyword">static</span> <span class="keywordtype">int</span>
00430 binary_search_for_start(netsnmp_index *val, netsnmp_container *c)
00431 {
00432     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00433     size_t             len = t-&gt;count;
00434     size_t             half;
00435     size_t             middle;
00436     size_t             first = 0;
00437     <span class="keywordtype">int</span>                result = 0;
00438 
00439     <span class="keywordflow">if</span> (!len)
00440         <span class="keywordflow">return</span> -1;
00441 
00442     <span class="keywordflow">if</span> (t-&gt;dirty)
00443         Sort_Array(c);
00444 
00445     <span class="keywordflow">while</span> (len &gt; 0) {
00446         half = len &gt;&gt; 1;
00447         middle = first;
00448         middle += half;
00449         <span class="keywordflow">if</span> ((result = c-&gt;ncompare(t-&gt;data[middle], val)) &lt; 0) {
00450             first = middle;
00451             ++first;
00452             len = len - half - 1;
00453         } <span class="keywordflow">else</span>
00454             len = half;
00455     }
00456 
00457     <span class="keywordflow">if</span> ((first &gt;= t-&gt;count) ||
00458         c-&gt;ncompare(t-&gt;data[first], val) != 0)
00459         <span class="keywordflow">return</span> -1;
00460 
00461     <span class="keywordflow">return</span> first;
00462 }
00463 
00464 <span class="keywordtype">void</span>          **
00465 netsnmp_binary_array_get_subset(netsnmp_container *c, <span class="keywordtype">void</span> *key, <span class=
"keywordtype">int</span> *len)
00466 {
00467     binary_array_table *t = (binary_array_table*)c-&gt;container_data;
00468     <span class="keywordtype">void</span>          **subset;
00469     <span class="keywordtype">int</span>             start, end;
00470     size_t          i;
00471 
00472     <span class="comment">/*</span>
00473 <span class="comment">     * if there is no data, return NULL;</span>
00474 <span class="comment">     */</span>
00475     <span class="keywordflow">if</span> (!t-&gt;count || !key)
00476         <span class="keywordflow">return</span> 0;
00477 
00478     <span class="comment">/*</span>
00479 <span class="comment">     * if the table is dirty, sort it.</span>
00480 <span class="comment">     */</span>
00481     <span class="keywordflow">if</span> (t-&gt;dirty)
00482         Sort_Array(c);
00483 
00484     <span class="comment">/*</span>
00485 <span class="comment">     * find matching items</span>
00486 <span class="comment">     */</span>
00487     start = end = binary_search_for_start(key, c);
00488     <span class="keywordflow">if</span> (start == -1)
00489         <span class="keywordflow">return</span> 0;
00490 
00491     <span class="keywordflow">for</span> (i = start + 1; i &lt; t-&gt;count; ++i) {
00492         <span class="keywordflow">if</span> (0 != c-&gt;ncompare(t-&gt;data[i], key))
00493             <span class="keywordflow">break</span>;
00494         ++end;
00495     }
00496 
00497     *len = end - start + 1;
00498     subset = malloc((*len) * t-&gt;data_size);
00499     <span class="keywordflow">if</span> (subset)
00500         memcpy(subset, &amp;t-&gt;data[start], t-&gt;data_size * (*len));
00501 
00502     <span class="keywordflow">return</span> subset;
00503 }
00504 
00505 <span class="comment">/**********************************************************************</span>
00506 <span class="comment"> *</span>
00507 <span class="comment"> * container</span>
00508 <span class="comment"> *</span>
00509 <span class="comment"> */</span>
00510 <span class="keyword">static</span> <span class="keywordtype">void</span> *
00511 _ba_find(netsnmp_container *container, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)
00512 {
00513     <span class="keywordflow">return</span> netsnmp_binary_array_get(container, data, 1);
00514 }
00515 
00516 <span class="keyword">static</span> <span class="keywordtype">void</span> *
00517 _ba_find_next(netsnmp_container *container, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)
00518 {
00519     <span class="keywordflow">return</span> netsnmp_binary_array_get(container, data, 0);
00520 }
00521 
00522 <span class="keyword">static</span> <span class="keywordtype">int</span>
00523 _ba_insert(netsnmp_container *container, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)
00524 {
00525     <span class="keywordflow">return</span> netsnmp_binary_array_insert(container, data);
00526 }
00527 
00528 <span class="keyword">static</span> <span class="keywordtype">int</span>
00529 _ba_remove(netsnmp_container *container, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)
00530 {
00531     <span class="keywordflow">return</span> netsnmp_binary_array_remove(container,data, NULL);
00532 }
00533 
00534 <span class="keyword">static</span> <span class="keywordtype">int</span>
00535 _ba_free(netsnmp_container *container)
00536 {
00537     netsnmp_binary_array_release(container);
00538     <span class="keywordflow">return</span> 0;
00539 }
00540 
00541 <span class="keyword">static</span> size_t
00542 _ba_size(netsnmp_container *container)
00543 {
00544     <span class="keywordflow">return</span> netsnmp_binary_array_count(container);
00545 }
00546 
00547 <span class="keyword">static</span> <span class="keywordtype">void</span>
00548 _ba_for_each(netsnmp_container *container, netsnmp_container_obj_func *f,
00549              <span class="keywordtype">void</span> *context)
00550 {
00551     netsnmp_binary_array_for_each(container, f, context, 1);
00552 }
00553 
00554 <span class="keyword">static</span> <span class="keywordtype">void</span>
00555 _ba_clear(netsnmp_container *container, netsnmp_container_obj_func *f,
00556              <span class="keywordtype">void</span> *context)
00557 {
00558     netsnmp_binary_array_clear(container, f, context);
00559 }
00560 
00561 <span class="keyword">static</span> netsnmp_void_array *
00562 _ba_get_subset(netsnmp_container *container, <span class="keywordtype">void</span> *data)
00563 {
00564     netsnmp_void_array * va;
00565     <span class="keywordtype">void</span> ** rtn;
00566     <span class="keywordtype">int</span> len;
00567 
00568     rtn = netsnmp_binary_array_get_subset(container, data, &amp;len);
00569     <span class="keywordflow">if</span> ((NULL==rtn) || (len &lt;=0))
00570         <span class="keywordflow">return</span> NULL;
00571     
00572     va = <a class="code" href="group__util.html#ga39">SNMP_MALLOC_TYPEDEF</a>(netsnmp_void_array);
00573     <span class="keywordflow">if</span> (NULL==va)
00574         <span class="keywordflow">return</span> NULL;
00575 
00576     va-&gt;size = len;
00577     va-&gt;array = rtn;
00578 
00579     <span class="keywordflow">return</span> va;
00580 }
00581 
00582 netsnmp_container *
00583 netsnmp_container_get_binary_array(<span class="keywordtype">void</span>)
00584 {
00585     <span class="comment">/*</span>
00586 <span class="comment">     * allocate memory</span>
00587 <span class="comment">     */</span>
00588     netsnmp_container *c = <a class="code" href="group__util.html#ga39">SNMP_MALLOC_TYPEDEF</a>(netsnmp_container);
00589     <span class="keywordflow">if</span> (NULL==c) {
00590         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"couldn't allocate memory\n"</span>);
00591         <span class="keywordflow">return</span> NULL;
00592     }
00593 
00594     c-&gt;container_data = netsnmp_binary_array_initialize();
00595         
00596     c-&gt;get_size = _ba_size;
00597     c-&gt;init = NULL;
00598     c-&gt;cfree = _ba_free;
00599     c-&gt;insert = _ba_insert;
00600     c-&gt;remove = _ba_remove;
00601     c-&gt;find = _ba_find;
00602     c-&gt;find_next = _ba_find_next;
00603     c-&gt;get_subset = _ba_get_subset;
00604     c-&gt;get_iterator = _ba_iterator_get;
00605     c-&gt;for_each = _ba_for_each;
00606     c-&gt;clear = _ba_clear;
00607         
00608     <span class="keywordflow">return</span> c;
00609 }
00610 
00611 netsnmp_factory *
00612 netsnmp_container_get_binary_array_factory(<span class="keywordtype">void</span>)
00613 {
00614     <span class="keyword">static</span> netsnmp_factory f = { <span class="stringliteral">"binary_array"</span>,
00615                                  (netsnmp_factory_produce_f*)
00616                                  netsnmp_container_get_binary_array };
00617     
00618     <span class="keywordflow">return</span> &amp;f;
00619 }
00620 
00621 <span class="keywordtype">void</span>
00622 netsnmp_container_binary_array_init(<span class="keywordtype">void</span>)
00623 {
00624     netsnmp_container_register(<span class="stringliteral">"binary_array"</span>,
00625                                netsnmp_container_get_binary_array_factory());
00626 }
00627 
00628 <span class="comment">/**********************************************************************</span>
00629 <span class="comment"> *</span>
00630 <span class="comment"> * iterator</span>
00631 <span class="comment"> *</span>
00632 <span class="comment"> */</span>
00633 NETSNMP_STATIC_INLINE binary_array_table *
00634 _ba_it2cont(binary_array_iterator *it)
00635 {
00636     <span class="keywordflow">if</span>(NULL == it) {
00637         netsnmp_assert(NULL != it);
00638         <span class="keywordflow">return</span> NULL;
00639     }
00640     <span class="keywordflow">if</span>(NULL == it-&gt;base.container) {
00641         netsnmp_assert(NULL != it-&gt;base.container);
00642         <span class="keywordflow">return</span> NULL;
00643     }
00644     <span class="keywordflow">if</span>(NULL == it-&gt;base.container-&gt;container_data) {
00645         netsnmp_assert(NULL != it-&gt;base.container-&gt;container_data);
00646         <span class="keywordflow">return</span> NULL;
00647     }
00648 
00649     <span class="keywordflow">return</span> (binary_array_table*)(it-&gt;base.container-&gt;container_data);
00650 }
00651 
00652 NETSNMP_STATIC_INLINE <span class="keywordtype">void</span> *
00653 _ba_iterator_position(binary_array_iterator *it, size_t pos)
00654 {
00655     binary_array_table *t = _ba_it2cont(it);
00656     <span class="keywordflow">if</span> (NULL == t)
00657         <span class="keywordflow">return</span> t; <span class="comment">/* msg already logged */</span>
00658 
00659     <span class="keywordflow">if</span>(it-&gt;base.container-&gt;sync != it-&gt;base.sync) {
00660         DEBUGMSGTL((<span class="stringliteral">"container:iterator"</span>, <span class=
"stringliteral">"out of sync\n"</span>));
00661         <span class="keywordflow">return</span> NULL;
00662     }
00663     
00664     <span class="keywordflow">if</span>(0 == t-&gt;count) {
00665         DEBUGMSGTL((<span class="stringliteral">"container:iterator"</span>, <span class=
"stringliteral">"empty\n"</span>));
00666         <span class="keywordflow">return</span> NULL;
00667     }
00668     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pos &gt;= t-&gt;count) {
00669         DEBUGMSGTL((<span class="stringliteral">"container:iterator"</span>, <span class=
"stringliteral">"end of containter\n"</span>));
00670         <span class="keywordflow">return</span> NULL;
00671     }
00672 
00673     <span class="keywordflow">return</span> t-&gt;data[ pos ];
00674 }
00675 
00676 <span class="keyword">static</span> <span class="keywordtype">void</span> *
00677 _ba_iterator_curr(binary_array_iterator *it)
00678 {
00679     <span class="keywordflow">if</span>(NULL == it) {
00680         netsnmp_assert(NULL != it);
00681         <span class="keywordflow">return</span> NULL;
00682     }
00683 
00684     <span class="keywordflow">return</span> _ba_iterator_position(it, it-&gt;pos);
00685 }
00686 
00687 <span class="keyword">static</span> <span class="keywordtype">void</span> *
00688 _ba_iterator_first(binary_array_iterator *it)
00689 {
00690     <span class="keywordflow">return</span> _ba_iterator_position(it, 0);
00691 }
00692 
00693 <span class="keyword">static</span> <span class="keywordtype">void</span> *
00694 _ba_iterator_next(binary_array_iterator *it)
00695 {
00696     <span class="keywordflow">if</span>(NULL == it) {
00697         netsnmp_assert(NULL != it);
00698         <span class="keywordflow">return</span> NULL;
00699     }
00700 
00701     ++it-&gt;pos;
00702 
00703     <span class="keywordflow">return</span> _ba_iterator_position(it, it-&gt;pos);
00704 }
00705 
00706 <span class="keyword">static</span> <span class="keywordtype">void</span> *
00707 _ba_iterator_last(binary_array_iterator *it)
00708 {
00709     binary_array_table* t = _ba_it2cont(it);
00710     <span class="keywordflow">if</span>(NULL == t) {
00711         netsnmp_assert(NULL != t);
00712         <span class="keywordflow">return</span> NULL;
00713     }
00714     
00715     <span class="keywordflow">return</span> _ba_iterator_position(it, t-&gt;count - 1 );
00716 }
00717 
00718 <span class="keyword">static</span> <span class="keywordtype">int</span>
00719 _ba_iterator_reset(binary_array_iterator *it)
00720 {
00721     binary_array_table* t = _ba_it2cont(it);
00722     <span class="keywordflow">if</span>(NULL == t) {
00723         netsnmp_assert(NULL != t);
00724         <span class="keywordflow">return</span> -1;
00725     }
00726 
00727     <span class="keywordflow">if</span> (t-&gt;dirty)
00728         Sort_Array(it-&gt;base.container);
00729 
00730     <span class="comment">/*</span>
00731 <span class="comment">     * save sync count, to make sure container doesn't change while</span>
00732 <span class="comment">     * iterator is in use.</span>
00733 <span class="comment">     */</span>
00734     it-&gt;base.sync = it-&gt;base.container-&gt;sync;
00735 
00736     it-&gt;pos = 0;
00737 
00738     <span class="keywordflow">return</span> 0;
00739 }
00740 
00741 <span class="keyword">static</span> <span class="keywordtype">int</span>
00742 _ba_iterator_release(netsnmp_iterator *it)
00743 {
00744     free(it);
00745 
00746     <span class="keywordflow">return</span> 0;
00747 }
00748 
00749 <span class="keyword">static</span> netsnmp_iterator *
00750 _ba_iterator_get(netsnmp_container *c)
00751 {
00752     binary_array_iterator* it;
00753 
00754     <span class="keywordflow">if</span>(NULL == c)
00755         <span class="keywordflow">return</span> NULL;
00756 
00757     it = <a class="code" href="group__util.html#ga39">SNMP_MALLOC_TYPEDEF</a>(binary_array_iterator);
00758     <span class="keywordflow">if</span>(NULL == it)
00759         <span class="keywordflow">return</span> NULL;
00760 
00761     it-&gt;base.container = c;
00762     
00763     it-&gt;base.first = (netsnmp_iterator_rtn*)_ba_iterator_first;
00764     it-&gt;base.next = (netsnmp_iterator_rtn*)_ba_iterator_next;
00765     it-&gt;base.curr = (netsnmp_iterator_rtn*)_ba_iterator_curr;
00766     it-&gt;base.last = (netsnmp_iterator_rtn*)_ba_iterator_last;
00767     it-&gt;base.reset = (netsnmp_iterator_rc*)_ba_iterator_reset;
00768     it-&gt;base.release = (netsnmp_iterator_rc*)_ba_iterator_release;
00769 
00770     (void)_ba_iterator_reset(it);
00771 
00772     <span class="keywordflow">return</span> (netsnmp_iterator *)it;
00773 }
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small>Generated on Fri Dec 30 13:47:44 2005 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

