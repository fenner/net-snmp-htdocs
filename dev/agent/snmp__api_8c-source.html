<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>snmp_api.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
00002 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00003 <span class="comment"> * that may apply:</span>
00004 <span class="comment"> */</span>
00005 <span class="comment">/******************************************************************</span>
00006 <span class="comment">        Copyright 1989, 1991, 1992 by Carnegie Mellon University</span>
00007 
00008 <span class="comment">                      All Rights Reserved</span>
00009 
00010 <span class="comment">Permission to use, copy, modify, and distribute this software and its</span>
00011 <span class="comment">documentation for any purpose and without fee is hereby granted,</span>
00012 <span class="comment">provided that the above copyright notice appear in all copies and that</span>
00013 <span class="comment">both that copyright notice and this permission notice appear in</span>
00014 <span class="comment">supporting documentation, and that the name of CMU not be</span>
00015 <span class="comment">used in advertising or publicity pertaining to distribution of the</span>
00016 <span class="comment">software without specific, written prior permission.</span>
00017 
00018 <span class="comment">CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING</span>
00019 <span class="comment">ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL</span>
00020 <span class="comment">CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR</span>
00021 <span class="comment">ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</span>
00022 <span class="comment">WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,</span>
00023 <span class="comment">ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS</span>
00024 <span class="comment">SOFTWARE.</span>
00025 <span class="comment">******************************************************************/</span>
00026 <span class="comment">/*</span>
00027 <span class="comment"> * Portions of this file are copyrighted by:</span>
00028 <span class="comment"> * Copyright Copyright 2003 Sun Microsystems, Inc. All rights reserved.</span>
00029 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00030 <span class="comment"> * distributed with the Net-SNMP package.</span>
00031 <span class="comment"> */</span>
00032 
00036 <span class="comment">/*</span>
00037 <span class="comment"> * snmp_api.c - API for access to snmp.</span>
00038 <span class="comment"> */</span>
00039 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00040 
00041 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00042 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00043 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00044 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00045 <span class="preprocessor">#endif</span>
00046 <span class="preprocessor">#if HAVE_STRING_H</span>
00047 <span class="preprocessor">#include &lt;string.h&gt;</span>
00048 <span class="preprocessor">#else</span>
00049 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00050 <span class="preprocessor">#endif</span>
00051 <span class="preprocessor">#if HAVE_UNISTD_H</span>
00052 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00053 <span class="preprocessor">#endif</span>
00054 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00055 <span class="preprocessor">#if HAVE_SYS_PARAM_H</span>
00056 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00057 <span class="preprocessor">#endif</span>
00058 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00059 <span class="preprocessor"># ifdef WIN32</span>
00060 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00061 <span class="preprocessor"># else</span>
00062 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00063 <span class="preprocessor"># endif</span>
00064 <span class="preprocessor"># include &lt;time.h&gt;</span>
00065 <span class="preprocessor">#else</span>
00066 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00067 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00068 <span class="preprocessor"># else</span>
00069 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00070 <span class="preprocessor"># endif</span>
00071 <span class="preprocessor">#endif</span>
00072 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00073 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00074 <span class="preprocessor">#endif</span>
00075 <span class="preprocessor">#if HAVE_ARPA_INET_H</span>
00076 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
00077 <span class="preprocessor">#endif</span>
00078 <span class="preprocessor">#if HAVE_SYS_SELECT_H</span>
00079 <span class="preprocessor">#include &lt;sys/select.h&gt;</span>
00080 <span class="preprocessor">#endif</span>
00081 <span class="preprocessor">#if HAVE_IO_H</span>
00082 <span class="preprocessor">#include &lt;io.h&gt;</span>
00083 <span class="preprocessor">#endif</span>
00084 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00085 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00086 <span class="preprocessor">#endif</span>
00087 <span class="preprocessor">#if HAVE_SYS_SOCKET_H</span>
00088 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00089 <span class="preprocessor">#endif</span>
00090 <span class="preprocessor">#if HAVE_SYS_UN_H</span>
00091 <span class="preprocessor">#include &lt;sys/un.h&gt;</span>
00092 <span class="preprocessor">#endif</span>
00093 <span class="preprocessor">#if HAVE_NETDB_H</span>
00094 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00095 <span class="preprocessor">#endif</span>
00096 <span class="preprocessor">#if HAVE_NET_IF_DL_H</span>
00097 <span class="preprocessor">#ifndef dynix</span>
00098 <span class="preprocessor">#include &lt;net/if_dl.h&gt;</span>
00099 <span class="preprocessor">#else</span>
00100 <span class="preprocessor">#include &lt;sys/net/if_dl.h&gt;</span>
00101 <span class="preprocessor">#endif</span>
00102 <span class="preprocessor">#endif</span>
00103 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00104 
00105 <span class="preprocessor">#if HAVE_LOCALE_H</span>
00106 <span class="preprocessor">#include &lt;locale.h&gt;</span>
00107 <span class="preprocessor">#endif</span>
00108 
00109 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00110 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00111 <span class="preprocessor">#endif</span>
00112 
00113 <span class="preprocessor">#define SNMP_NEED_REQUEST_LIST</span>
00114 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00115 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00116 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00117 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00118 
00119 <span class="preprocessor">#include &lt;net-snmp/library/asn1.h&gt;</span>
00120 <span class="preprocessor">#include &lt;net-snmp/library/snmp.h&gt;</span>      <span class=
"comment">/* for xdump &amp; {build,parse}_var_op */</span>
00121 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00122 <span class="preprocessor">#include &lt;net-snmp/library/snmp_client.h&gt;</span>
00123 <span class="preprocessor">#include &lt;net-snmp/library/parse.h&gt;</span>
00124 <span class="preprocessor">#include &lt;net-snmp/library/mib.h&gt;</span>
00125 <span class="preprocessor">#include &lt;net-snmp/library/int64.h&gt;</span>
00126 <span class="preprocessor">#include &lt;net-snmp/library/snmpv3.h&gt;</span>
00127 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
00128 <span class="preprocessor">#include &lt;net-snmp/library/container.h&gt;</span>
00129 <span class="preprocessor">#include &lt;net-snmp/library/snmp_secmod.h&gt;</span>
00130 <span class="preprocessor">#ifdef SNMP_SECMOD_USM</span>
00131 <span class="preprocessor">#include &lt;net-snmp/library/snmpusm.h&gt;</span>
00132 <span class="preprocessor">#endif</span>
00133 <span class="preprocessor">#ifdef SNMP_SECMOD_KSM</span>
00134 <span class="preprocessor">#include &lt;net-snmp/library/snmpksm.h&gt;</span>
00135 <span class="preprocessor">#endif</span>
00136 <span class="preprocessor">#include &lt;net-snmp/library/keytools.h&gt;</span>
00137 <span class="preprocessor">#include &lt;net-snmp/library/lcd_time.h&gt;</span>
00138 <span class="preprocessor">#include &lt;net-snmp/library/snmp_alarm.h&gt;</span>
00139 <span class="preprocessor">#include &lt;net-snmp/library/snmp_transport.h&gt;</span>
00140 
00141 <span class="keyword">static</span> <span class="keywordtype">void</span>     _init_snmp(<span class=
"keywordtype">void</span>);
00142 
00143 <span class="preprocessor">#include &lt;net-snmp/library/transform_oids.h&gt;</span>
00144 <span class="preprocessor">#ifndef timercmp</span>
00145 <span class="preprocessor">#define timercmp(tvp, uvp, cmp) \</span>
00146 <span class="preprocessor">        </span><span class="comment">/* CSTYLED */</span> \
00147         ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec || \
00148         ((tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec &amp;&amp; \
00149         <span class="comment">/* CSTYLED */</span> \
00150         (tvp)-&gt;tv_usec cmp (uvp)-&gt;tv_usec))
00151 <span class="preprocessor">#endif</span>
00152 <span class="preprocessor">#ifndef timerclear</span>
00153 <span class="preprocessor">#define timerclear(tvp)         (tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0</span>
00154 <span class="preprocessor">#endif</span>
00155 
00156 <span class="comment">/*</span>
00157 <span class="comment"> * Globals.</span>
00158 <span class="comment"> */</span>
00159 <span class="preprocessor">#define MAX_PACKET_LENGTH       (0x7fffffff)</span>
00160 <span class="preprocessor">#ifndef NETSNMP_STREAM_QUEUE_LEN</span>
00161 <span class="preprocessor">#define NETSNMP_STREAM_QUEUE_LEN  5</span>
00162 <span class="preprocessor">#endif</span>
00163 
00164 <span class="preprocessor">#ifndef BSD4_3</span>
00165 <span class="preprocessor">#define BSD4_2</span>
00166 <span class="preprocessor">#endif</span>
00167 
00168 <span class="preprocessor">#ifndef FD_SET</span>
00169 
00170 <span class="keyword">typedef</span> <span class="keywordtype">long</span>    fd_mask;
00171 <span class="preprocessor">#define NFDBITS (sizeof(fd_mask) * NBBY)        </span><span class=
"comment">/* bits per mask */</span>
00172 
00173 <span class="preprocessor">#define FD_SET(n, p)    ((p)-&gt;fds_bits[(n)/NFDBITS] |= (1 &lt;&lt; ((n) % NFDBITS)))</span>
00174 <span class=
"preprocessor">#define FD_CLR(n, p)    ((p)-&gt;fds_bits[(n)/NFDBITS] &amp;= ~(1 &lt;&lt; ((n) % NFDBITS)))</span>
00175 <span class=
"preprocessor">#define FD_ISSET(n, p)  ((p)-&gt;fds_bits[(n)/NFDBITS] &amp; (1 &lt;&lt; ((n) % NFDBITS)))</span>
00176 <span class="preprocessor">#define FD_ZERO(p)      memset((p), 0, sizeof(*(p)))</span>
00177 <span class="preprocessor">#endif</span>
00178 
00179 <span class="keyword">static</span> oid      default_enterprise[] = { 1, 3, 6, 1, 4, 1, 3, 1, 1 };
00180 <span class="comment">/*</span>
00181 <span class="comment"> * enterprises.cmu.systems.cmuSNMP </span>
00182 <span class="comment"> */</span>
00183 
00184 <span class="preprocessor">#define DEFAULT_COMMUNITY   "public"</span>
00185 <span class="preprocessor">#define DEFAULT_RETRIES     5</span>
00186 <span class="preprocessor">#define DEFAULT_TIMEOUT     1000000L</span>
00187 <span class="preprocessor">#define DEFAULT_REMPORT     SNMP_PORT</span>
00188 <span class="preprocessor">#define DEFAULT_ENTERPRISE  default_enterprise</span>
00189 <span class="preprocessor">#define DEFAULT_TIME        0</span>
00190 
00191 <span class="comment">/*</span>
00192 <span class="comment"> * don't set higher than 0x7fffffff, and I doubt it should be that high</span>
00193 <span class="comment"> * * = 4 gig snmp messages max </span>
00194 <span class="comment"> */</span>
00195 <span class="preprocessor">#define MAXIMUM_PACKET_SIZE 0x7fffffff</span>
00196 
00197 <span class="comment">/*</span>
00198 <span class="comment"> * Internal information about the state of the snmp session.</span>
00199 <span class="comment"> */</span>
00200 <span class="keyword">struct </span>snmp_internal_session {
00201     netsnmp_request_list *requests;     <span class="comment">/* Info about outstanding requests */</span>
00202     netsnmp_request_list *requestsEnd;  <span class="comment">/* ptr to end of list */</span>
00203     int             (*hook_pre) (<a class="code" href=
"structsnmp__session.html">netsnmp_session</a> *, netsnmp_transport *,
00204                                  <span class="keywordtype">void</span> *, int);
00205     int             (*hook_parse) (<a class="code" href="structsnmp__session.html">netsnmp_session</a> *, <a class="code"
href="structsnmp__pdu.html">netsnmp_pdu</a> *,
00206                                    u_char *, size_t);
00207     int             (*hook_post) (<a class="code" href=
"structsnmp__session.html">netsnmp_session</a> *, netsnmp_pdu *, int);
00208     int             (*hook_build) (<a class="code" href="structsnmp__session.html">netsnmp_session</a> *, netsnmp_pdu *,
00209                                    u_char *, size_t *);
00210     int             (*hook_realloc_build) (<a class="code" href="structsnmp__session.html">netsnmp_session</a> *,
00211                                            netsnmp_pdu *, u_char **,
00212                                            size_t *, size_t *);
00213     int             (*check_packet) (u_char *, size_t);
00214     netsnmp_pdu    *(*hook_create_pdu) (netsnmp_transport *,
00215                                         <span class="keywordtype">void</span> *, size_t);
00216 
00217     u_char         *packet;
00218     size_t          packet_len, packet_size;
00219 };
00220 
00221 <span class="comment">/*</span>
00222 <span class="comment"> * The list of active/open sessions.</span>
00223 <span class="comment"> */</span>
00224 <span class="keyword">struct </span>session_list {
00225     <span class="keyword">struct </span>session_list *next;
00226     <a class="code" href="structsnmp__session.html">netsnmp_session</a> *session;
00227     netsnmp_transport *transport;
00228     <span class="keyword">struct </span>snmp_internal_session *internal;
00229 };
00230 
00231 
00232 
00233 <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *api_errors[-SNMPERR_MAX + 1] = {
00234     <span class="stringliteral">"No error"</span>,                 <span class="comment">/* SNMPERR_SUCCESS */</span>
00235     <span class="stringliteral">"Generic error"</span>,            <span class="comment">/* SNMPERR_GENERR */</span>
00236     <span class="stringliteral">"Invalid local port"</span>,       <span class="comment">/* SNMPERR_BAD_LOCPORT */</span>
00237     <span class="stringliteral">"Unknown host"</span>,             <span class="comment">/* SNMPERR_BAD_ADDRESS */</span>
00238     <span class="stringliteral">"Unknown session"</span>,          <span class="comment">/* SNMPERR_BAD_SESSION */</span>
00239     <span class="stringliteral">"Too long"</span>,                 <span class="comment">/* SNMPERR_TOO_LONG */</span>
00240     <span class="stringliteral">"No socket"</span>,                <span class="comment">/* SNMPERR_NO_SOCKET */</span>
00241     <span class="stringliteral">"Cannot send V2 PDU on V1 session"</span>, <span class=
"comment">/* SNMPERR_V2_IN_V1 */</span>
00242     <span class="stringliteral">"Cannot send V1 PDU on V2 session"</span>, <span class=
"comment">/* SNMPERR_V1_IN_V2 */</span>
00243     <span class="stringliteral">"Bad value for non-repeaters"</span>,      <span class=
"comment">/* SNMPERR_BAD_REPEATERS */</span>
00244     <span class="stringliteral">"Bad value for max-repetitions"</span>,    <span class=
"comment">/* SNMPERR_BAD_REPETITIONS */</span>
00245     <span class="stringliteral">"Error building ASN.1 representation"</span>,      <span class=
"comment">/* SNMPERR_BAD_ASN1_BUILD */</span>
00246     <span class="stringliteral">"Failure in sendto"</span>,        <span class="comment">/* SNMPERR_BAD_SENDTO */</span>
00247     <span class="stringliteral">"Bad parse of ASN.1 type"</span>,  <span class="comment">/* SNMPERR_BAD_PARSE */</span>
00248     <span class="stringliteral">"Bad version specified"</span>,    <span class="comment">/* SNMPERR_BAD_VERSION */</span>
00249     <span class="stringliteral">"Bad source party specified"</span>,       <span class=
"comment">/* SNMPERR_BAD_SRC_PARTY */</span>
00250     <span class="stringliteral">"Bad destination party specified"</span>,  <span class=
"comment">/* SNMPERR_BAD_DST_PARTY */</span>
00251     <span class="stringliteral">"Bad context specified"</span>,    <span class="comment">/* SNMPERR_BAD_CONTEXT */</span>
00252     <span class="stringliteral">"Bad community specified"</span>,  <span class="comment">/* SNMPERR_BAD_COMMUNITY */</span>
00253     <span class="stringliteral">"Cannot send noAuth/Priv"</span>,       <span class=
"comment">/* SNMPERR_NOAUTH_DESPRIV */</span>
00254     <span class="stringliteral">"Bad ACL definition"</span>,       <span class="comment">/* SNMPERR_BAD_ACL */</span>
00255     <span class="stringliteral">"Bad Party definition"</span>,     <span class="comment">/* SNMPERR_BAD_PARTY */</span>
00256     <span class="stringliteral">"Session abort failure"</span>,    <span class="comment">/* SNMPERR_ABORT */</span>
00257     <span class="stringliteral">"Unknown PDU type"</span>,         <span class="comment">/* SNMPERR_UNKNOWN_PDU */</span>
00258     <span class="stringliteral">"Timeout"</span>,                  <span class="comment">/* SNMPERR_TIMEOUT */</span>
00259     <span class="stringliteral">"Failure in recvfrom"</span>,      <span class="comment">/* SNMPERR_BAD_RECVFROM */</span>
00260     <span class="stringliteral">"Unable to determine contextEngineID"</span>,      <span class=
"comment">/* SNMPERR_BAD_ENG_ID */</span>
00261     <span class="stringliteral">"No securityName specified"</span>,        <span class=
"comment">/* SNMPERR_BAD_SEC_NAME */</span>
00262     <span class="stringliteral">"Unable to determine securityLevel"</span>,        <span class=
"comment">/* SNMPERR_BAD_SEC_LEVEL  */</span>
00263     <span class="stringliteral">"ASN.1 parse error in message"</span>,     <span class=
"comment">/* SNMPERR_ASN_PARSE_ERR */</span>
00264     <span class="stringliteral">"Unknown security model in message"</span>,        <span class=
"comment">/* SNMPERR_UNKNOWN_SEC_MODEL */</span>
00265     <span class="stringliteral">"Invalid message (e.g. msgFlags)"</span>,  <span class=
"comment">/* SNMPERR_INVALID_MSG */</span>
00266     <span class="stringliteral">"Unknown engine ID"</span>,        <span class=
"comment">/* SNMPERR_UNKNOWN_ENG_ID */</span>
00267     <span class="stringliteral">"Unknown user name"</span>,        <span class=
"comment">/* SNMPERR_UNKNOWN_USER_NAME */</span>
00268     <span class="stringliteral">"Unsupported security level"</span>,       <span class=
"comment">/* SNMPERR_UNSUPPORTED_SEC_LEVEL */</span>
00269     <span class="stringliteral">"Authentication failure (incorrect password, community or key)"</span>,    <span class=
"comment">/* SNMPERR_AUTHENTICATION_FAILURE */</span>
00270     <span class="stringliteral">"Not in time window"</span>,       <span class=
"comment">/* SNMPERR_NOT_IN_TIME_WINDOW */</span>
00271     <span class="stringliteral">"Decryption error"</span>,         <span class=
"comment">/* SNMPERR_DECRYPTION_ERR */</span>
00272     <span class="stringliteral">"SCAPI general failure"</span>,    <span class=
"comment">/* SNMPERR_SC_GENERAL_FAILURE */</span>
00273     <span class="stringliteral">"SCAPI sub-system not configured"</span>,  <span class=
"comment">/* SNMPERR_SC_NOT_CONFIGURED */</span>
00274     <span class="stringliteral">"Key tools not available"</span>,  <span class=
"comment">/* SNMPERR_KT_NOT_AVAILABLE */</span>
00275     <span class="stringliteral">"Unknown Report message"</span>,   <span class=
"comment">/* SNMPERR_UNKNOWN_REPORT */</span>
00276     <span class="stringliteral">"USM generic error"</span>,        <span class=
"comment">/* SNMPERR_USM_GENERICERROR */</span>
00277     <span class="stringliteral">"USM unknown security name (no such user exists)"</span>,  <span class=
"comment">/* SNMPERR_USM_UNKNOWNSECURITYNAME */</span>
00278     <span class=
"stringliteral">"USM unsupported security level (this user has not been configured for that level of security)"</span>,    <span class="comment">/* SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL */</span>
00279     <span class="stringliteral">"USM encryption error"</span>,     <span class=
"comment">/* SNMPERR_USM_ENCRYPTIONERROR */</span>
00280     <span class="stringliteral">"USM authentication failure (incorrect password or key)"</span>,   <span class=
"comment">/* SNMPERR_USM_AUTHENTICATIONFAILURE */</span>
00281     <span class="stringliteral">"USM parse error"</span>,          <span class=
"comment">/* SNMPERR_USM_PARSEERROR */</span>
00282     <span class="stringliteral">"USM unknown engineID"</span>,     <span class=
"comment">/* SNMPERR_USM_UNKNOWNENGINEID */</span>
00283     <span class="stringliteral">"USM not in time window"</span>,   <span class=
"comment">/* SNMPERR_USM_NOTINTIMEWINDOW */</span>
00284     <span class="stringliteral">"USM decryption error"</span>,     <span class=
"comment">/* SNMPERR_USM_DECRYPTIONERROR */</span>
00285     <span class="stringliteral">"MIB not initialized"</span>,      <span class="comment">/* SNMPERR_NOMIB */</span>
00286     <span class="stringliteral">"Value out of range"</span>,       <span class="comment">/* SNMPERR_RANGE */</span>
00287     <span class="stringliteral">"Sub-id out of range"</span>,      <span class="comment">/* SNMPERR_MAX_SUBID */</span>
00288     <span class="stringliteral">"Bad sub-id in object identifier"</span>,  <span class=
"comment">/* SNMPERR_BAD_SUBID */</span>
00289     <span class="stringliteral">"Object identifier too long"</span>,       <span class=
"comment">/* SNMPERR_LONG_OID */</span>
00290     <span class="stringliteral">"Bad value name"</span>,           <span class="comment">/* SNMPERR_BAD_NAME */</span>
00291     <span class="stringliteral">"Bad value notation"</span>,       <span class="comment">/* SNMPERR_VALUE */</span>
00292     <span class="stringliteral">"Unknown Object Identifier"</span>,        <span class=
"comment">/* SNMPERR_UNKNOWN_OBJID */</span>
00293     <span class="stringliteral">"No PDU in snmp_send"</span>,      <span class="comment">/* SNMPERR_NULL_PDU */</span>
00294     <span class="stringliteral">"Missing variables in PDU"</span>, <span class="comment">/* SNMPERR_NO_VARS */</span>
00295     <span class="stringliteral">"Bad variable type"</span>,        <span class="comment">/* SNMPERR_VAR_TYPE */</span>
00296     <span class="stringliteral">"Out of memory (malloc failure)"</span>,   <span class=
"comment">/* SNMPERR_MALLOC */</span>
00297     <span class="stringliteral">"Kerberos related error"</span>,   <span class="comment">/* SNMPERR_KRB5 */</span>
00298 };
00299 
00300 <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *secLevelName[] = {
00301     <span class="stringliteral">"BAD_SEC_LEVEL"</span>,
00302     <span class="stringliteral">"noAuthNoPriv"</span>,
00303     <span class="stringliteral">"authNoPriv"</span>,
00304     <span class="stringliteral">"authPriv"</span>
00305 };
00306 
00307 <span class="comment">/*</span>
00308 <span class="comment"> * Multiple threads may changes these variables.</span>
00309 <span class="comment"> * Suggest using the Single API, which does not use Sessions.</span>
00310 <span class="comment"> *</span>
00311 <span class="comment"> * Reqid may need to be protected. Time will tell...</span>
00312 <span class="comment"> *</span>
00313 <span class="comment"> */</span>
00314 <span class="comment">/*</span>
00315 <span class="comment"> * MTCRITICAL_RESOURCE</span>
00316 <span class="comment"> */</span>
00317 <span class="comment">/*</span>
00318 <span class="comment"> * use token in comments to individually protect these resources </span>
00319 <span class="comment"> */</span>
00320 <span class="keyword">struct </span>session_list *Sessions = NULL;   <span class="comment">/* MT_LIB_SESSION */</span>
00321 <span class="keyword">static</span> <span class="keywordtype">long</span>     Reqid = 0;      <span class=
"comment">/* MT_LIB_REQUESTID */</span>
00322 <span class="keyword">static</span> <span class="keywordtype">long</span>     Msgid = 0;      <span class=
"comment">/* MT_LIB_MESSAGEID */</span>
00323 <span class="keyword">static</span> <span class="keywordtype">long</span>     Sessid = 0;     <span class=
"comment">/* MT_LIB_SESSIONID */</span>
00324 <span class="keyword">static</span> <span class="keywordtype">long</span>     Transid = 0;    <span class=
"comment">/* MT_LIB_TRANSID */</span>
00325 <span class="keywordtype">int</span>             snmp_errno = 0;
00326 <span class="comment">/*</span>
00327 <span class="comment"> * END MTCRITICAL_RESOURCE</span>
00328 <span class="comment"> */</span>
00329 
00330 <span class="comment">/*</span>
00331 <span class="comment"> * global error detail storage</span>
00332 <span class="comment"> */</span>
00333 <span class="keyword">static</span> <span class="keywordtype">char</span>     snmp_detail[192];
00334 <span class="keyword">static</span> <span class="keywordtype">int</span>      snmp_detail_f = 0;
00335 
00336 <span class="comment">/*</span>
00337 <span class="comment"> * Prototypes.</span>
00338 <span class="comment"> */</span>
00339 <span class="keywordtype">int</span>             snmp_build(u_char ** pkt, size_t * pkt_len,
00340                            size_t * offset, <a class="code" href="structsnmp__session.html">netsnmp_session</a> * pss,
00341                            <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu);
00342 <span class="keyword">static</span> <span class="keywordtype">int</span>      snmp_parse(<span class=
"keywordtype">void</span> *, <a class="code" href="structsnmp__session.html">netsnmp_session</a> *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *,
00343                            u_char *, size_t);
00344 
00345 <span class="keyword">static</span> <span class="keywordtype">void</span>     snmpv3_calc_msg_flags(<span class=
"keywordtype">int</span>, <span class="keywordtype">int</span>, u_char *);
00346 <span class="keyword">static</span> <span class=
"keywordtype">int</span>      snmpv3_verify_msg(netsnmp_request_list *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *);
00347 <span class="keyword">static</span> <span class="keywordtype">int</span>      snmpv3_build_probe_pdu(<a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> **);
00348 <span class="keyword">static</span> <span class="keywordtype">int</span>      snmpv3_build(u_char ** pkt, size_t * pkt_len,
00349                              size_t * offset, <a class="code" href=
"structsnmp__session.html">netsnmp_session</a> * session,
00350                              <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu);
00351 <span class="keyword">static</span> <span class="keywordtype">int</span>      snmp_parse_version(u_char *, size_t);
00352 <span class="keyword">static</span> <span class="keywordtype">int</span>      snmp_resend_request(<span class=
"keyword">struct</span> session_list *slp,
00353                                     netsnmp_request_list *rp,
00354                                     <span class="keywordtype">int</span> incr_retries);
00355 <span class="keyword">static</span> <span class="keywordtype">void</span>     register_default_handlers(<span class=
"keywordtype">void</span>);
00356 <span class="keyword">static</span> <span class="keyword">struct </span>session_list *snmp_sess_copy(<a class="code" href=
"structsnmp__session.html">netsnmp_session</a> * pss);
00357 <span class="keywordtype">int</span>             snmp_get_errno(<span class="keywordtype">void</span>);
00358 <span class="keywordtype">void</span>            snmp_synch_reset(<a class="code" href=
"structsnmp__session.html">netsnmp_session</a> * notused);
00359 <span class="keywordtype">void</span>            snmp_synch_setup(<a class="code" href=
"structsnmp__session.html">netsnmp_session</a> * notused);
00360 
00361 <span class="preprocessor">#ifndef HAVE_STRERROR</span>
00362 <span class="keyword">const</span> <span class="keywordtype">char</span>     *
00363 strerror(<span class="keywordtype">int</span> err)
00364 {
00365     <span class="keyword">extern</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *sys_errlist[];
00366     <span class="keyword">extern</span> <span class="keywordtype">int</span>      sys_nerr;
00367 
00368     <span class="keywordflow">if</span> (err &lt; 0 || err &gt;= sys_nerr)
00369         <span class="keywordflow">return</span> <span class="stringliteral">"Unknown error"</span>;
00370     <span class="keywordflow">return</span> sys_errlist[err];
00371 }
00372 <span class="preprocessor">#endif</span>
00373 
00374 <span class="preprocessor">#define DEBUGPRINTPDUTYPE(token, type) \</span>
00375 <span class="preprocessor">    switch(type) { \</span>
00376 <span class="preprocessor">      case SNMP_MSG_GET: \</span>
00377 <span class="preprocessor">        DEBUGDUMPSECTION(token, "PDU-GET"); \</span>
00378 <span class="preprocessor">        break; \</span>
00379 <span class="preprocessor">      case SNMP_MSG_GETNEXT: \</span>
00380 <span class="preprocessor">        DEBUGDUMPSECTION(token, "PDU-GETNEXT"); \</span>
00381 <span class="preprocessor">        break; \</span>
00382 <span class="preprocessor">      case SNMP_MSG_RESPONSE: \</span>
00383 <span class="preprocessor">        DEBUGDUMPSECTION(token, "PDU-RESPONSE"); \</span>
00384 <span class="preprocessor">        break; \</span>
00385 <span class="preprocessor">      case SNMP_MSG_SET: \</span>
00386 <span class="preprocessor">        DEBUGDUMPSECTION(token, "PDU-SET"); \</span>
00387 <span class="preprocessor">        break; \</span>
00388 <span class="preprocessor">      case SNMP_MSG_GETBULK: \</span>
00389 <span class="preprocessor">        DEBUGDUMPSECTION(token, "PDU-GETBULK"); \</span>
00390 <span class="preprocessor">        break; \</span>
00391 <span class="preprocessor">      case SNMP_MSG_INFORM: \</span>
00392 <span class="preprocessor">        DEBUGDUMPSECTION(token, "PDU-INFORM"); \</span>
00393 <span class="preprocessor">        break; \</span>
00394 <span class="preprocessor">      case SNMP_MSG_TRAP2: \</span>
00395 <span class="preprocessor">        DEBUGDUMPSECTION(token, "PDU-TRAP2"); \</span>
00396 <span class="preprocessor">        break; \</span>
00397 <span class="preprocessor">      case SNMP_MSG_REPORT: \</span>
00398 <span class="preprocessor">        DEBUGDUMPSECTION(token, "PDU-REPORT"); \</span>
00399 <span class="preprocessor">        break; \</span>
00400 <span class="preprocessor">      default: \</span>
00401 <span class="preprocessor">        DEBUGDUMPSECTION(token, "PDU-UNKNOWN"); \</span>
00402 <span class="preprocessor">        break; \</span>
00403 <span class="preprocessor">    }</span>
00404 
00405 <span class="keywordtype">long</span>
00406 snmp_get_next_reqid(<span class="keywordtype">void</span>)
00407 {
00408     <span class="keywordtype">long</span>            retVal;
00409     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_REQUESTID);
00410     retVal = 1 + Reqid;         <span class="comment">/*MTCRITICAL_RESOURCE */</span>
00411     <span class="keywordflow">if</span> (!retVal)
00412         retVal = 2;
00413     Reqid = retVal;
00414     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_REQUESTID);
00415     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_16BIT_IDS))
00416         <span class="keywordflow">return</span> (retVal &amp; 0x7fff);       <span class=
"comment">/* mask to 15 bits */</span>
00417     <span class="keywordflow">else</span>
00418         <span class="keywordflow">return</span> retVal;
00419 }
00420 
00421 <span class="keywordtype">long</span>
00422 snmp_get_next_msgid(<span class="keywordtype">void</span>)
00423 {
00424     <span class="keywordtype">long</span>            retVal;
00425     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_MESSAGEID);
00426     retVal = 1 + Msgid;         <span class="comment">/*MTCRITICAL_RESOURCE */</span>
00427     <span class="keywordflow">if</span> (!retVal)
00428         retVal = 2;
00429     Msgid = retVal;
00430     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_MESSAGEID);
00431     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_16BIT_IDS))
00432         <span class="keywordflow">return</span> (retVal &amp; 0x7fff);       <span class=
"comment">/* mask to 15 bits */</span>
00433     <span class="keywordflow">else</span>
00434         <span class="keywordflow">return</span> retVal;
00435 }
00436 
00437 <span class="keywordtype">long</span>
00438 snmp_get_next_sessid(<span class="keywordtype">void</span>)
00439 {
00440     <span class="keywordtype">long</span>            retVal;
00441     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSIONID);
00442     retVal = 1 + Sessid;        <span class="comment">/*MTCRITICAL_RESOURCE */</span>
00443     <span class="keywordflow">if</span> (!retVal)
00444         retVal = 2;
00445     Sessid = retVal;
00446     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSIONID);
00447     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_16BIT_IDS))
00448         <span class="keywordflow">return</span> (retVal &amp; 0x7fff);       <span class=
"comment">/* mask to 15 bits */</span>
00449     <span class="keywordflow">else</span>
00450         <span class="keywordflow">return</span> retVal;
00451 }
00452 
00453 <span class="keywordtype">long</span>
00454 snmp_get_next_transid(<span class="keywordtype">void</span>)
00455 {
00456     <span class="keywordtype">long</span>            retVal;
00457     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_TRANSID);
00458     retVal = 1 + Transid;       <span class="comment">/*MTCRITICAL_RESOURCE */</span>
00459     <span class="keywordflow">if</span> (!retVal)
00460         retVal = 2;
00461     Transid = retVal;
00462     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_TRANSID);
00463     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_16BIT_IDS))
00464         <span class="keywordflow">return</span> (retVal &amp; 0x7fff);       <span class=
"comment">/* mask to 15 bits */</span>
00465     <span class="keywordflow">else</span>
00466         <span class="keywordflow">return</span> retVal;
00467 }
00468 
00469 <span class="keywordtype">void</span>
00470 snmp_perror(<span class="keyword">const</span> <span class="keywordtype">char</span> *prog_string)
00471 {
00472     <span class="keyword">const</span> <span class="keywordtype">char</span>     *str;
00473     <span class="keywordtype">int</span>             xerr;
00474     xerr = snmp_errno;          <span class="comment">/*MTCRITICAL_RESOURCE */</span>
00475     str = snmp_api_errstring(xerr);
00476     <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"%s: %s\n"</span>, prog_string, str);
00477 }
00478 
00479 <span class="keywordtype">void</span>
00480 snmp_set_detail(<span class="keyword">const</span> <span class="keywordtype">char</span> *detail_string)
00481 {
00482     <span class="keywordflow">if</span> (detail_string != NULL) {
00483         strncpy((<span class="keywordtype">char</span> *) snmp_detail, detail_string, <span class=
"keyword">sizeof</span>(snmp_detail));
00484         snmp_detail[<span class="keyword">sizeof</span>(snmp_detail) - 1] = <span class="charliteral">'\0'</span>;
00485         snmp_detail_f = 1;
00486     }
00487 }
00488 
00489 <span class="comment">/*</span>
00490 <span class="comment"> * returns pointer to static data </span>
00491 <span class="comment"> */</span>
00492 <span class="comment">/*</span>
00493 <span class="comment"> * results not guaranteed in multi-threaded use </span>
00494 <span class="comment"> */</span>
00495 <span class="keyword">const</span> <span class="keywordtype">char</span>     *
00496 snmp_api_errstring(<span class="keywordtype">int</span> snmp_errnumber)
00497 {
00498     <span class="keyword">const</span> <span class="keywordtype">char</span>     *msg = <span class=
"stringliteral">""</span>;
00499     <span class="keyword">static</span> <span class="keywordtype">char</span>     msg_buf[256];
00500     <span class="keywordflow">if</span> (snmp_errnumber &gt;= SNMPERR_MAX &amp;&amp; snmp_errnumber &lt;= SNMPERR_GENERR) {
00501         msg = api_errors[-snmp_errnumber];
00502     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (snmp_errnumber != SNMPERR_SUCCESS) {
00503         msg = <span class="stringliteral">"Unknown Error"</span>;
00504     }
00505     <span class="keywordflow">if</span> (snmp_detail_f) {
00506         snprintf(msg_buf, 256, <span class="stringliteral">"%s (%s)"</span>, msg, snmp_detail);
00507         snmp_detail_f = 0;
00508     } <span class="keywordflow">else</span> {
00509         strncpy(msg_buf, msg, 256);
00510     }
00511     msg_buf[255] = <span class="charliteral">'\0'</span>;
00512 
00513     <span class="keywordflow">return</span> (msg_buf);
00514 }
00515 
00516 <span class="comment">/*</span>
00517 <span class="comment"> * snmp_error - return error data</span>
00518 <span class="comment"> * Inputs :  address of errno, address of snmp_errno, address of string</span>
00519 <span class="comment"> * Caller must free the string returned after use.</span>
00520 <span class="comment"> */</span>
00521 <span class="keywordtype">void</span>
00522 snmp_error(<a class="code" href="structsnmp__session.html">netsnmp_session</a> * psess,
00523            <span class="keywordtype">int</span> *p_errno, <span class="keywordtype">int</span> *p_snmp_errno, <span class=
"keywordtype">char</span> **p_str)
00524 {
00525     <span class="keywordtype">char</span>            buf[SPRINT_MAX_LEN];
00526     <span class="keywordtype">int</span>             snmp_errnumber;
00527 
00528     <span class="keywordflow">if</span> (p_errno)
00529         *p_errno = psess-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a>;
00530     <span class="keywordflow">if</span> (p_snmp_errno)
00531         *p_snmp_errno = psess-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>;
00532     <span class="keywordflow">if</span> (p_str == NULL)
00533         <span class="keywordflow">return</span>;
00534 
00535     strcpy(buf, <span class="stringliteral">""</span>);
00536     snmp_errnumber = psess-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>;
00537     <span class="keywordflow">if</span> (snmp_errnumber &gt;= SNMPERR_MAX &amp;&amp; snmp_errnumber &lt;= SNMPERR_GENERR) {
00538         strncpy(buf, api_errors[-snmp_errnumber], 256);
00539     } <span class="keywordflow">else</span> {
00540         <span class="keywordflow">if</span> (snmp_errnumber)
00541             snprintf(buf, 256, <span class="stringliteral">"Unknown Error %d"</span>, snmp_errnumber);
00542     }
00543     buf[255] = <span class="charliteral">'\0'</span>;
00544 
00545     <span class="comment">/*</span>
00546 <span class="comment">     * append a useful system errno interpretation. </span>
00547 <span class="comment">     */</span>
00548     <span class="keywordflow">if</span> (psess-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a>) {
00549         <span class="keyword">const</span> <span class="keywordtype">char</span>* error = strerror(psess-&gt;<a class=
"code" href="structsnmp__session.html#o13">s_errno</a>);
00550         <span class="keywordflow">if</span>(error == NULL)
00551             error = <span class="stringliteral">"Unknown Error"</span>;
00552         snprintf (&amp;buf[strlen(buf)], 256-strlen(buf),
00553                  <span class="stringliteral">" (%s)"</span>, error);
00554     }
00555     buf[255] = <span class="charliteral">'\0'</span>;
00556     *p_str = strdup(buf);
00557 }
00558 
00559 <span class="comment">/*</span>
00560 <span class="comment"> * snmp_sess_error - same as snmp_error for single session API use.</span>
00561 <span class="comment"> */</span>
00562 <span class="keywordtype">void</span>
00563 snmp_sess_error(<span class="keywordtype">void</span> *sessp, <span class="keywordtype">int</span> *p_errno, <span class=
"keywordtype">int</span> *p_snmp_errno, <span class="keywordtype">char</span> **p_str)
00564 {
00565     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
00566 
00567     <span class="keywordflow">if</span> ((slp) &amp;&amp; (slp-&gt;session))
00568         snmp_error(slp-&gt;session, p_errno, p_snmp_errno, p_str);
00569 }
00570 
00571 <span class="comment">/*</span>
00572 <span class="comment"> * snmp_sess_perror(): print a error stored in a session pointer </span>
00573 <span class="comment"> */</span>
00574 <span class="keywordtype">void</span>
00575 netsnmp_sess_log_error(<span class="keywordtype">int</span> priority,
00576                        <span class="keyword">const</span> <span class="keywordtype">char</span> *prog_string, <a class=
"code" href="structsnmp__session.html">netsnmp_session</a> * ss)
00577 {
00578     <span class="keywordtype">char</span>           *err;
00579     snmp_error(ss, NULL, NULL, &amp;err);
00580     <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(priority, <span class=
"stringliteral">"%s: %s\n"</span>, prog_string, err);
00581     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(err);
00582 }
00583 
00584 <span class="comment">/*</span>
00585 <span class="comment"> * snmp_sess_perror(): print a error stored in a session pointer </span>
00586 <span class="comment"> */</span>
00587 <span class="keywordtype">void</span>
00588 snmp_sess_perror(<span class="keyword">const</span> <span class="keywordtype">char</span> *prog_string, <a class="code"
href="structsnmp__session.html">netsnmp_session</a> * ss)
00589 {
00590     netsnmp_sess_log_error(LOG_ERR, prog_string, ss);
00591 }
00592 
00593 
00594 
00595 <span class="comment">/*</span>
00596 <span class="comment"> * Primordial SNMP library initialization.</span>
00597 <span class="comment"> * Initializes mutex locks.</span>
00598 <span class="comment"> * Invokes minimum required initialization for displaying MIB objects.</span>
00599 <span class="comment"> * Gets initial request ID for all transactions,</span>
00600 <span class="comment"> * and finds which port SNMP over UDP uses.</span>
00601 <span class="comment"> * SNMP over AppleTalk is not currently supported.</span>
00602 <span class="comment"> *</span>
00603 <span class="comment"> * Warning: no debug messages here.</span>
00604 <span class="comment"> */</span>
00605 <span class="keyword">static</span> <span class="keywordtype">void</span>
00606 _init_snmp(<span class="keywordtype">void</span>)
00607 {
00608 <span class="preprocessor">#ifdef  HAVE_GETSERVBYNAME</span>
00609     <span class="keyword">struct </span>servent *servp;
00610 <span class="preprocessor">#endif</span>
00611     <span class="keyword">static</span> <span class="keywordtype">char</span>     have_done_init = 0;
00612 
00613     <span class="keyword">struct </span>timeval  tv;
00614     <span class="keywordtype">long</span>            tmpReqid, tmpMsgid;
00615     u_short         s_port = SNMP_PORT;
00616 
00617     <span class="keywordflow">if</span> (have_done_init)
00618         <span class="keywordflow">return</span>;
00619     have_done_init = 1;
00620     Reqid = 1;
00621 
00622     snmp_res_init();            <span class="comment">/* initialize the mt locking structures */</span>
00623 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
00624     init_mib_internals();
00625 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
00626     netsnmp_tdomain_init();
00627 
00628     gettimeofday(&amp;tv, (<span class="keyword">struct</span> timezone *) 0);
00629     <span class="comment">/*</span>
00630 <span class="comment">     * Now = tv;</span>
00631 <span class="comment">     */</span>
00632 
00633     <span class="comment">/*</span>
00634 <span class="comment">     * get pseudo-random values for request ID and message ID </span>
00635 <span class="comment">     */</span>
00636     <span class="comment">/*</span>
00637 <span class="comment">     * don't allow zero value to repeat init </span>
00638 <span class="comment">     */</span>
00639 <span class="preprocessor">#ifdef SVR4</span>
00640     srand48(tv.tv_sec ^ tv.tv_usec);
00641     tmpReqid = lrand48();
00642     tmpMsgid = lrand48();
00643 <span class="preprocessor">#else</span>
00644     srandom(tv.tv_sec ^ tv.tv_usec);
00645     tmpReqid = random();
00646     tmpMsgid = random();
00647 <span class="preprocessor">#endif</span>
00648 
00649     <span class="keywordflow">if</span> (tmpReqid == 0)
00650         tmpReqid = 1;
00651     <span class="keywordflow">if</span> (tmpMsgid == 0)
00652         tmpMsgid = 1;
00653     Reqid = tmpReqid;
00654     Msgid = tmpMsgid;
00655 
00656 <span class="preprocessor">#ifdef HAVE_GETSERVBYNAME</span>
00657     servp = getservbyname(<span class="stringliteral">"snmp"</span>, <span class="stringliteral">"udp"</span>);
00658     <span class="keywordflow">if</span> (servp) {
00659         <span class="comment">/*</span>
00660 <span class="comment">         * store it in host byte order </span>
00661 <span class="comment">         */</span>
00662         s_port = ntohs(servp-&gt;s_port);
00663     }
00664 <span class="preprocessor">#endif</span>
00665 
00666     netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, 
00667                        NETSNMP_DS_LIB_DEFAULT_PORT, s_port);
00668     netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, 
00669                        NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH, 16);
00670 
00671 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
00672     <a class="code" href="group__default__store.html#ga8">netsnmp_ds_set_boolean</a>(NETSNMP_DS_LIBRARY_ID, 
00673                            NETSNMP_DS_LIB_REVERSE_ENCODE,
00674                            DEFAULT_ASNENCODING_DIRECTION);
00675 <span class="preprocessor">#endif</span>
00676 }
00677 
00678 <span class="comment">/*</span>
00679 <span class="comment"> * Initializes the session structure.</span>
00680 <span class="comment"> * May perform one time minimal library initialization.</span>
00681 <span class="comment"> * No MIB file processing is done via this call.</span>
00682 <span class="comment"> */</span>
00683 <span class="keywordtype">void</span>
00684 snmp_sess_init(<a class="code" href="structsnmp__session.html">netsnmp_session</a> * session)
00685 {
00686     _init_snmp();
00687 
00688     <span class="comment">/*</span>
00689 <span class="comment">     * initialize session to default values </span>
00690 <span class="comment">     */</span>
00691 
00692     memset(session, 0, <span class="keyword">sizeof</span>(<a class="code" href=
"structsnmp__session.html">netsnmp_session</a>));
00693     session-&gt;<a class="code" href="structsnmp__session.html#o7">remote_port</a> = SNMP_DEFAULT_REMPORT;
00694     session-&gt;<a class="code" href="structsnmp__session.html#o2">timeout</a> = SNMP_DEFAULT_TIMEOUT;
00695     session-&gt;<a class="code" href="structsnmp__session.html#o1">retries</a> = SNMP_DEFAULT_RETRIES;
00696     session-&gt;<a class="code" href="structsnmp__session.html#o0">version</a> = SNMP_DEFAULT_VERSION;
00697     session-&gt;<a class="code" href="structsnmp__session.html#o43">securityModel</a> = SNMP_DEFAULT_SECMODEL;
00698     session-&gt;<a class="code" href="structsnmp__session.html#o18">rcvMsgMaxSize</a> = SNMP_MAX_MSG_SIZE;
00699 }
00700 
00701 
00702 <span class="keyword">static</span> <span class="keywordtype">void</span>
00703 register_default_handlers(<span class="keywordtype">void</span>)
00704 {
00705     netsnmp_ds_register_config(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"dumpPacket"</span>,
00706                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DUMP_PACKET);
00707     netsnmp_ds_register_config(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"reverseEncodeBER"</span>,
00708                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REVERSE_ENCODE);
00709     netsnmp_ds_register_config(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"defaultPort"</span>,
00710                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DEFAULT_PORT);
00711 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
00712     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"defCommunity"</span>,
00713                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_COMMUNITY);
00714 <span class="preprocessor">#endif</span>
00715     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"noTokenWarnings"</span>,
00716                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NO_TOKEN_WARNINGS);
00717     netsnmp_ds_register_config(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"noRangeCheck"</span>,
00718                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_CHECK_RANGE);
00719     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"persistentDir"</span>,
00720                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PERSISTENT_DIR);
00721     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"tempFilePattern"</span>,
00722                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_TEMP_FILE_PATTERN);
00723     netsnmp_ds_register_config(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"noDisplayHint"</span>,
00724                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NO_DISPLAY_HINT);
00725     netsnmp_ds_register_config(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"16bitIDs"</span>,
00726                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_16BIT_IDS);
00727     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"clientaddr"</span>,
00728                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_CLIENT_ADDR);
00729     netsnmp_ds_register_config(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"serverSendBuf"</span>,
00730                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SERVERSENDBUF);
00731     netsnmp_ds_register_config(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"serverRecvBuf"</span>,
00732                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SERVERRECVBUF);
00733     netsnmp_ds_register_config(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"clientSendBuf"</span>,
00734                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_CLIENTSENDBUF);
00735     netsnmp_ds_register_config(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"clientRecvBuf"</span>,
00736                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_CLIENTRECVBUF);
00737 }
00738 
00739 <span class="keywordtype">void</span>
00740 init_snmp_enums(<span class="keywordtype">void</span>)
00741 {
00742     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"integer"</span>), ASN_INTEGER);
00743     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"counter"</span>), ASN_COUNTER);
00744     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"uinteger"</span>), ASN_GAUGE);
00745     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"timeticks"</span>), ASN_TIMETICKS);
00746     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"counter64"</span>), ASN_COUNTER64);
00747     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"octet_str"</span>), ASN_OCTET_STR);
00748     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"ipaddress"</span>), ASN_IPADDRESS);
00749     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"opaque"</span>), ASN_OPAQUE);
00750     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"nsap"</span>), ASN_NSAP);
00751     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"object_id"</span>), ASN_OBJECT_ID);
00752     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"null"</span>), ASN_NULL);
00753 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00754     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"opaque_counter64"</span>),
00755                          ASN_OPAQUE_COUNTER64);
00756     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"opaque_u64"</span>), ASN_OPAQUE_U64);
00757     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"opaque_float"</span>),
00758                          ASN_OPAQUE_FLOAT);
00759     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"opaque_double"</span>),
00760                          ASN_OPAQUE_DOUBLE);
00761     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"opaque_i64"</span>), ASN_OPAQUE_I64);
00762 <span class="preprocessor">#endif</span>
00763 }
00764 
00765 
00766 
00777 <span class="keywordtype">void</span>
<a name="l00778" id="l00778"></a><a class="code" href="group__library.html#ga51">00778</a> <a class="code" href=
"group__library.html#ga51">init_snmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *type)
00779 {
00780     <span class="keyword">static</span> <span class="keywordtype">int</span>      done_init = 0;      <span class=
"comment">/* To prevent double init's. */</span>
00781 
00782     <span class="keywordflow">if</span> (done_init) {
00783         <span class="keywordflow">return</span>;
00784     }
00785 
00786     done_init = 1;
00787 
00788     <span class="comment">/*</span>
00789 <span class="comment">     * make the type available everywhere else </span>
00790 <span class="comment">     */</span>
00791     <span class="keywordflow">if</span> (type &amp;&amp; !netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
00792                                        NETSNMP_DS_LIB_APPTYPE)) {
00793         netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID, 
00794                               NETSNMP_DS_LIB_APPTYPE, type);
00795     }
00796 
00797     _init_snmp();
00798 
00799     <span class="comment">/*</span>
00800 <span class="comment">     * set our current locale properly to initialize isprint() type functions </span>
00801 <span class="comment">     */</span>
00802 <span class="preprocessor">#ifdef HAVE_SETLOCALE</span>
00803     setlocale(LC_CTYPE, <span class="stringliteral">""</span>);
00804 <span class="preprocessor">#endif</span>
00805 
00806     snmp_debug_init();    <span class="comment">/* should be done first, to turn on debugging ASAP */</span>
00807     netsnmp_container_init_list();
00808     init_callbacks();
00809     init_snmp_logging();
00810     snmp_init_statistics();
00811     register_mib_handlers();
00812     register_default_handlers();
00813     init_snmpv3(type);
00814     init_snmp_alarm();
00815     init_snmp_enum(type);
00816     init_snmp_enums();
00817 
00818     read_premib_configs();
00819 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
00820     <a class="code" href="group__mib__utilities.html#ga56">init_mib</a>();
00821 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
00822 
00823     read_configs();
00824 
00825 }                               <span class="comment">/* end init_snmp() */</span>
00826 
00827 <span class="keywordtype">void</span>
00828 snmp_store(<span class="keyword">const</span> <span class="keywordtype">char</span> *type)
00829 {
00830     DEBUGMSGTL((<span class="stringliteral">"snmp_store"</span>, <span class="stringliteral">"storing stuff...\n"</span>));
00831     snmp_save_persistent(type);
00832     <a class="code" href=
"group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL);
00833     snmp_clean_persistent(type);
00834 }
00835 
00836 
00845 <span class="keywordtype">void</span>
<a name="l00846" id="l00846"></a><a class="code" href="group__library.html#ga53">00846</a> <a class="code" href=
"group__library.html#ga53">snmp_shutdown</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *type)
00847 {
00848     snmp_store(type);
00849     <a class="code" href=
"group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, NULL);
00850     <a class="code" href="group__snmp__alarm.html#ga7">snmp_alarm_unregister_all</a>();
00851     snmp_close_sessions();
00852 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
00853     <a class="code" href="group__mib__utilities.html#ga57">shutdown_mib</a>();
00854 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
00855     unregister_all_config_handlers();
00856     netsnmp_container_free_list();
00857     clear_sec_mod();
00858     clear_snmp_enum();
00859     netsnmp_clear_tdomain_list();
00860     clear_callback();
00861     netsnmp_ds_shutdown();
00862 }
00863 
00864 
00865 <span class="comment">/*</span>
00866 <span class="comment"> * Sets up the session with the snmp_session information provided by the user.</span>
00867 <span class="comment"> * Then opens and binds the necessary low-level transport.  A handle to the</span>
00868 <span class="comment"> * created session is returned (this is NOT the same as the pointer passed to</span>
00869 <span class="comment"> * snmp_open()).  On any error, NULL is returned and snmp_errno is set to the</span>
00870 <span class="comment"> * appropriate error code.</span>
00871 <span class="comment"> */</span>
00872 <a class="code" href="structsnmp__session.html">netsnmp_session</a> *
00873 snmp_open(<a class="code" href="structsnmp__session.html">netsnmp_session</a> *session)
00874 {
00875     <span class="keyword">struct </span>session_list *slp;
00876     slp = (<span class="keyword">struct </span>session_list *) snmp_sess_open(session);
00877     <span class="keywordflow">if</span> (!slp) {
00878         <span class="keywordflow">return</span> NULL;
00879     }
00880 
00881     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
00882     slp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = Sessions;
00883     Sessions = slp;
00884     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
00885 
00886     <span class="keywordflow">return</span> (slp-&gt;session);
00887 }
00888 
00889 <span class="comment">/*</span>
00890 <span class="comment"> * extended open </span>
00891 <span class="comment"> */</span>
00892 <a class="code" href="structsnmp__session.html">netsnmp_session</a> *
00893 snmp_open_ex(<a class="code" href="structsnmp__session.html">netsnmp_session</a> *session,
00894              <span class="keywordtype">int</span> (*fpre_parse)  (<a class="code" href=
"structsnmp__session.html">netsnmp_session</a> *, netsnmp_transport *,
00895                                 <span class="keywordtype">void</span> *, <span class="keywordtype">int</span>),
00896              <span class="keywordtype">int</span> (*fparse)      (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, u_char *,
00897                                  size_t),
00898              <span class="keywordtype">int</span> (*fpost_parse) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, <span class="keywordtype">int</span>),
00899 
00900              <span class="keywordtype">int</span> (*fbuild)      (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, u_char *,
00901                                  size_t *),
00902              <span class="keywordtype">int</span> (*frbuild)     (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *,
00903                                  u_char **, size_t *, size_t *),
00904              <span class="keywordtype">int</span> (*fcheck)      (u_char *, size_t)
00905              )
00906 {
00907     <span class="keyword">struct </span>session_list *slp;
00908     slp = (<span class="keyword">struct </span>session_list *) snmp_sess_open(session);
00909     <span class="keywordflow">if</span> (!slp) {
00910         <span class="keywordflow">return</span> NULL;
00911     }
00912     slp-&gt;internal-&gt;hook_pre = fpre_parse;
00913     slp-&gt;internal-&gt;hook_parse = fparse;
00914     slp-&gt;internal-&gt;hook_post = fpost_parse;
00915     slp-&gt;internal-&gt;hook_build = fbuild;
00916     slp-&gt;internal-&gt;hook_realloc_build = frbuild;
00917     slp-&gt;internal-&gt;check_packet = fcheck;
00918 
00919     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
00920     slp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = Sessions;
00921     Sessions = slp;
00922     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
00923 
00924     <span class="keywordflow">return</span> (slp-&gt;session);
00925 }
00926 
00927 <span class="keyword">static</span> <span class="keyword">struct </span>session_list *
00928 _sess_copy(netsnmp_session * in_session)
00929 {
00930     <span class="keyword">struct </span>session_list *slp;
00931     <span class="keyword">struct </span>snmp_internal_session *isp;
00932     netsnmp_session *session;
00933     <span class="keyword">struct </span>snmp_secmod_def *sptr;
00934     <span class="keywordtype">char</span>           *cp;
00935     u_char         *ucp;
00936     size_t          i;
00937 
00938     in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
00939     in_session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
00940 
00941     <span class="comment">/*</span>
00942 <span class="comment">     * Copy session structure and link into list </span>
00943 <span class="comment">     */</span>
00944     slp = (<span class="keyword">struct </span>session_list *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> session_list));
00945     <span class="keywordflow">if</span> (slp == NULL) {
00946         in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
00947         <span class="keywordflow">return</span> (NULL);
00948     }
00949 
00950     slp-&gt;transport = NULL;
00951 
00952     isp = (<span class="keyword">struct </span>snmp_internal_session *)calloc(1, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> snmp_internal_session));
00953 
00954     <span class="keywordflow">if</span> (isp == NULL) {
00955         snmp_sess_close(slp);
00956         in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
00957         <span class="keywordflow">return</span> (NULL);
00958     }
00959 
00960     slp-&gt;internal = isp;
00961     slp-&gt;session = (netsnmp_session *)malloc(<span class="keyword">sizeof</span>(netsnmp_session));
00962     <span class="keywordflow">if</span> (slp-&gt;session == NULL) {
00963         snmp_sess_close(slp);
00964         in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
00965         <span class="keywordflow">return</span> (NULL);
00966     }
00967     memmove(slp-&gt;session, in_session, <span class="keyword">sizeof</span>(netsnmp_session));
00968     session = slp-&gt;session;
00969 
00970     <span class="comment">/*</span>
00971 <span class="comment">     * zero out pointers so if we have to free the session we wont free mem</span>
00972 <span class="comment">     * owned by in_session </span>
00973 <span class="comment">     */</span>
00974     session-&gt;<a class="code" href="structsnmp__session.html#o6">peername</a> = NULL;
00975     session-&gt;<a class="code" href="structsnmp__session.html#o16">community</a> = NULL;
00976     session-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a> = NULL;
00977     session-&gt;<a class="code" href="structsnmp__session.html#o25">contextName</a> = NULL;
00978     session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a> = NULL;
00979     session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a> = NULL;
00980     session-&gt;<a class="code" href="structsnmp__session.html#o31">securityAuthProto</a> = NULL;
00981     session-&gt;<a class="code" href="structsnmp__session.html#o37">securityPrivProto</a> = NULL;
00982     <span class="comment">/*</span>
00983 <span class="comment">     * session now points to the new structure that still contains pointers to</span>
00984 <span class="comment">     * data allocated elsewhere.  Some of this data is copied to space malloc'd</span>
00985 <span class="comment">     * here, and the pointer replaced with the new one.</span>
00986 <span class="comment">     */</span>
00987 
00988     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o6">peername</a> != NULL) {
00989         session-&gt;<a class="code" href="structsnmp__session.html#o6">peername</a> = (<span class=
"keywordtype">char</span> *)malloc(strlen(in_session-&gt;<a class="code" href="structsnmp__session.html#o6">peername</a>) + 1);
00990         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o6">peername</a> == NULL) {
00991             snmp_sess_close(slp);
00992             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
00993             <span class="keywordflow">return</span> (NULL);
00994         }
00995         strcpy(session-&gt;<a class="code" href="structsnmp__session.html#o6">peername</a>, in_session-&gt;<a class="code"
href="structsnmp__session.html#o6">peername</a>);
00996     }
00997 
00998     <span class="comment">/*</span>
00999 <span class="comment">     * Fill in defaults if necessary </span>
01000 <span class="comment">     */</span>
01001 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
01002     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a> != SNMP_DEFAULT_COMMUNITY_LEN) {
01003         ucp = (u_char *) malloc(in_session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a>);
01004         <span class="keywordflow">if</span> (ucp != NULL)
01005             memmove(ucp, in_session-&gt;<a class="code" href=
"structsnmp__session.html#o16">community</a>, in_session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>);
01006     } <span class="keywordflow">else</span> {
01007         <span class="keywordflow">if</span> ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01008                                         NETSNMP_DS_LIB_COMMUNITY)) != NULL) {
01009             session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a> = strlen(cp);
01010             ucp = (u_char *) malloc(session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a>);
01011             <span class="keywordflow">if</span> (ucp)
01012                 memmove(ucp, cp, session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a>);
01013         } <span class="keywordflow">else</span> {
01014 <span class="preprocessor">#ifdef NO_ZEROLENGTH_COMMUNITY</span>
01015             session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a> = strlen(DEFAULT_COMMUNITY);
01016             ucp = (u_char *) malloc(session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a>);
01017             <span class="keywordflow">if</span> (ucp)
01018                 memmove(ucp, DEFAULT_COMMUNITY, session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>);
01019 <span class="preprocessor">#else</span>
01020             ucp = (u_char *) strdup(<span class="stringliteral">""</span>);
01021 <span class="preprocessor">#endif</span>
01022         }
01023     }
01024 
01025     <span class="keywordflow">if</span> (ucp == NULL) {
01026         snmp_sess_close(slp);
01027         in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
01028         <span class="keywordflow">return</span> (NULL);
01029     }
01030     session-&gt;<a class="code" href="structsnmp__session.html#o16">community</a> = ucp;   <span class=
"comment">/* replace pointer with pointer to new data */</span>
01031 <span class="preprocessor">#endif</span>
01032 
01033     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o44">securityLevel</a> &lt;= 0) {
01034         session-&gt;<a class="code" href="structsnmp__session.html#o44">securityLevel</a> =
01035             netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SECLEVEL);
01036     }
01037 
01038     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o44">securityLevel</a> == 0)
01039         session-&gt;<a class="code" href="structsnmp__session.html#o44">securityLevel</a> = SNMP_SEC_LEVEL_NOAUTH;
01040 
01041     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o32">securityAuthProtoLen</a> &gt; 0) {
01042         session-&gt;<a class="code" href="structsnmp__session.html#o31">securityAuthProto</a> =
01043             snmp_duplicate_objid(in_session-&gt;<a class="code" href="structsnmp__session.html#o31">securityAuthProto</a>,
01044                                  in_session-&gt;<a class="code" href=
"structsnmp__session.html#o32">securityAuthProtoLen</a>);
01045         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o31">securityAuthProto</a> == NULL) {
01046             snmp_sess_close(slp);
01047             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
01048             <span class="keywordflow">return</span> (NULL);
01049         }
01050     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (get_default_authtype(&amp;i) != NULL) {
01051         session-&gt;<a class="code" href="structsnmp__session.html#o31">securityAuthProto</a> =
01052             snmp_duplicate_objid(get_default_authtype(NULL), i);
01053         session-&gt;<a class="code" href="structsnmp__session.html#o32">securityAuthProtoLen</a> = i;
01054     }
01055 
01056     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o38">securityPrivProtoLen</a> &gt; 0) {
01057         session-&gt;<a class="code" href="structsnmp__session.html#o37">securityPrivProto</a> =
01058             snmp_duplicate_objid(in_session-&gt;<a class="code" href="structsnmp__session.html#o37">securityPrivProto</a>,
01059                                  in_session-&gt;<a class="code" href=
"structsnmp__session.html#o38">securityPrivProtoLen</a>);
01060         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o37">securityPrivProto</a> == NULL) {
01061             snmp_sess_close(slp);
01062             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
01063             <span class="keywordflow">return</span> (NULL);
01064         }
01065     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (get_default_privtype(&amp;i) != NULL) {
01066         session-&gt;<a class="code" href="structsnmp__session.html#o37">securityPrivProto</a> =
01067             snmp_duplicate_objid(get_default_privtype(NULL), i);
01068         session-&gt;<a class="code" href="structsnmp__session.html#o38">securityPrivProtoLen</a> = i;
01069     }
01070 
01071     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a> &gt; 0) {
01072         ucp = (u_char *) malloc(in_session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a>);
01073         <span class="keywordflow">if</span> (ucp == NULL) {
01074             snmp_sess_close(slp);
01075             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
01076             <span class="keywordflow">return</span> (NULL);
01077         }
01078         memmove(ucp, in_session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
01079                 in_session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>);
01080         session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a> = ucp;
01081 
01082     }
01083 
01084     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o22">contextEngineIDLen</a> &gt; 0) {
01085         ucp = (u_char *) malloc(in_session-&gt;<a class="code" href="structsnmp__session.html#o22">contextEngineIDLen</a>);
01086         <span class="keywordflow">if</span> (ucp == NULL) {
01087             snmp_sess_close(slp);
01088             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
01089             <span class="keywordflow">return</span> (NULL);
01090         }
01091         memmove(ucp, in_session-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a>,
01092                 in_session-&gt;<a class="code" href="structsnmp__session.html#o22">contextEngineIDLen</a>);
01093         session-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a> = ucp;
01094     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a> &gt; 0) {
01095         <span class="comment">/*</span>
01096 <span class="comment">         * default contextEngineID to securityEngineIDLen if defined </span>
01097 <span class="comment">         */</span>
01098         ucp = (u_char *) malloc(in_session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a>);
01099         <span class="keywordflow">if</span> (ucp == NULL) {
01100             snmp_sess_close(slp);
01101             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
01102             <span class="keywordflow">return</span> (NULL);
01103         }
01104         memmove(ucp, in_session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
01105                 in_session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>);
01106         session-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a> = ucp;
01107         session-&gt;<a class="code" href="structsnmp__session.html#o22">contextEngineIDLen</a> = in_session-&gt;<a class=
"code" href="structsnmp__session.html#o28">securityEngineIDLen</a>;
01108     }
01109 
01110     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o25">contextName</a>) {
01111         session-&gt;<a class="code" href="structsnmp__session.html#o25">contextName</a> = strdup(in_session-&gt;<a class=
"code" href="structsnmp__session.html#o25">contextName</a>);
01112         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o25">contextName</a> == NULL) {
01113             snmp_sess_close(slp);
01114             <span class="keywordflow">return</span> (NULL);
01115         }
01116     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01117                                            NETSNMP_DS_LIB_CONTEXT)) != NULL) {
01118         cp = strdup(cp);
01119         <span class="keywordflow">if</span> (cp == NULL) {
01120             snmp_sess_close(slp);
01121             <span class="keywordflow">return</span> (NULL);
01122         }
01123         session-&gt;<a class="code" href="structsnmp__session.html#o25">contextName</a> = cp;
01124         session-&gt;<a class="code" href="structsnmp__session.html#o26">contextNameLen</a> = strlen(cp);
01125     } <span class="keywordflow">else</span> {
01126         cp = strdup(SNMP_DEFAULT_CONTEXT);
01127         session-&gt;<a class="code" href="structsnmp__session.html#o25">contextName</a> = cp;
01128         session-&gt;<a class="code" href="structsnmp__session.html#o26">contextNameLen</a> = strlen(cp);
01129     }
01130 
01131     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o29">securityName</a>) {
01132         session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a> = strdup(in_session-&gt;<a class=
"code" href="structsnmp__session.html#o29">securityName</a>);
01133         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o29">securityName</a> == NULL) {
01134             snmp_sess_close(slp);
01135             <span class="keywordflow">return</span> (NULL);
01136         }
01137     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01138                                            NETSNMP_DS_LIB_SECNAME)) != NULL) {
01139         cp = strdup(cp);
01140         <span class="keywordflow">if</span> (cp == NULL) {
01141             snmp_sess_close(slp);
01142             <span class="keywordflow">return</span> (NULL);
01143         }
01144         session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a> = cp;
01145         session-&gt;<a class="code" href="structsnmp__session.html#o30">securityNameLen</a> = strlen(cp);
01146     }
01147 
01148     <span class="keywordflow">if</span> ((in_session-&gt;<a class="code" href=
"structsnmp__session.html#o34">securityAuthKeyLen</a> &lt;= 0) &amp;&amp;
01149         ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01150                                      NETSNMP_DS_LIB_AUTHMASTERKEY)))) {
01151         size_t buflen = <span class="keyword">sizeof</span>(session-&gt;<a class="code" href=
"structsnmp__session.html#o33">securityAuthKey</a>);
01152         u_char *tmpp = session-&gt;<a class="code" href="structsnmp__session.html#o33">securityAuthKey</a>;
01153         session-&gt;<a class="code" href="structsnmp__session.html#o34">securityAuthKeyLen</a> = 0;
01154         <span class="comment">/* it will be a hex string */</span>
01155         <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;tmpp, &amp;buflen,
01156                                 &amp;session-&gt;<a class="code" href=
"structsnmp__session.html#o34">securityAuthKeyLen</a>, 0, cp)) {
01157             snmp_set_detail(<span class="stringliteral">"error parsing authentication master key"</span>);
01158             snmp_sess_close(slp);
01159             <span class="keywordflow">return</span> NULL;
01160         }
01161     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((in_session-&gt;<a class="code" href=
"structsnmp__session.html#o34">securityAuthKeyLen</a> &lt;= 0) &amp;&amp;
01162         ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01163                                      NETSNMP_DS_LIB_AUTHPASSPHRASE)) ||
01164          (cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01165                                      NETSNMP_DS_LIB_PASSPHRASE)))) {
01166         session-&gt;<a class="code" href="structsnmp__session.html#o34">securityAuthKeyLen</a> = USM_AUTH_KU_LEN;
01167         <span class="keywordflow">if</span> (generate_Ku(session-&gt;<a class="code" href=
"structsnmp__session.html#o31">securityAuthProto</a>,
01168                         session-&gt;<a class="code" href="structsnmp__session.html#o32">securityAuthProtoLen</a>,
01169                         (u_char *) cp, strlen(cp),
01170                         session-&gt;<a class="code" href="structsnmp__session.html#o33">securityAuthKey</a>,
01171                         &amp;session-&gt;<a class="code" href=
"structsnmp__session.html#o34">securityAuthKeyLen</a>) != SNMPERR_SUCCESS) {
01172             snmp_set_detail
01173                 (<span class=
"stringliteral">"Error generating a key (Ku) from the supplied authentication pass phrase."</span>);
01174             snmp_sess_close(slp);
01175             <span class="keywordflow">return</span> NULL;
01176         }
01177     }
01178 
01179     
01180     <span class="keywordflow">if</span> ((in_session-&gt;<a class="code" href=
"structsnmp__session.html#o40">securityPrivKeyLen</a> &lt;= 0) &amp;&amp;
01181         ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01182                                      NETSNMP_DS_LIB_PRIVMASTERKEY)))) {
01183         size_t buflen = <span class="keyword">sizeof</span>(session-&gt;<a class="code" href=
"structsnmp__session.html#o39">securityPrivKey</a>);
01184         u_char *tmpp = session-&gt;<a class="code" href="structsnmp__session.html#o39">securityPrivKey</a>;
01185         session-&gt;<a class="code" href="structsnmp__session.html#o40">securityPrivKeyLen</a> = 0;
01186         <span class="comment">/* it will be a hex string */</span>
01187         <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;tmpp, &amp;buflen,
01188                                 &amp;session-&gt;<a class="code" href=
"structsnmp__session.html#o40">securityPrivKeyLen</a>, 0, cp)) {
01189             snmp_set_detail(<span class="stringliteral">"error parsing encryption master key"</span>);
01190             snmp_sess_close(slp);
01191             <span class="keywordflow">return</span> NULL;
01192         }
01193     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((in_session-&gt;<a class="code" href=
"structsnmp__session.html#o40">securityPrivKeyLen</a> &lt;= 0) &amp;&amp;
01194         ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01195                                      NETSNMP_DS_LIB_PRIVPASSPHRASE)) ||
01196          (cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01197                                      NETSNMP_DS_LIB_PASSPHRASE)))) {
01198         session-&gt;<a class="code" href="structsnmp__session.html#o40">securityPrivKeyLen</a> = USM_PRIV_KU_LEN;
01199         <span class="keywordflow">if</span> (generate_Ku(session-&gt;<a class="code" href=
"structsnmp__session.html#o31">securityAuthProto</a>,
01200                         session-&gt;<a class="code" href="structsnmp__session.html#o32">securityAuthProtoLen</a>,
01201                         (u_char *) cp, strlen(cp),
01202                         session-&gt;<a class="code" href="structsnmp__session.html#o39">securityPrivKey</a>,
01203                         &amp;session-&gt;<a class="code" href=
"structsnmp__session.html#o40">securityPrivKeyLen</a>) != SNMPERR_SUCCESS) {
01204             snmp_set_detail
01205                 (<span class="stringliteral">"Error generating a key (Ku) from the supplied privacy pass phrase."</span>);
01206             snmp_sess_close(slp);
01207             <span class="keywordflow">return</span> NULL;
01208         }
01209     }
01210 
01211     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o1">retries</a> == SNMP_DEFAULT_RETRIES)
01212         session-&gt;<a class="code" href="structsnmp__session.html#o1">retries</a> = DEFAULT_RETRIES;
01213     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o2">timeout</a> == SNMP_DEFAULT_TIMEOUT)
01214         session-&gt;<a class="code" href="structsnmp__session.html#o2">timeout</a> = DEFAULT_TIMEOUT;
01215     session-&gt;<a class="code" href="structsnmp__session.html#o15">sessid</a> = snmp_get_next_sessid();
01216 
01217     <a class="code" href=
"group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SESSION_INIT,
01218                         session);
01219 
01220     <span class="keywordflow">if</span> ((sptr = find_sec_mod(session-&gt;<a class="code" href=
"structsnmp__session.html#o43">securityModel</a>)) != NULL &amp;&amp;
01221         sptr-&gt;session_open != NULL) {
01222         <span class="comment">/*</span>
01223 <span class="comment">         * security module specific inialization </span>
01224 <span class="comment">         */</span>
01225         (*sptr-&gt;session_open) (session);
01226     }
01227 
01228     <span class="keywordflow">return</span> (slp);
01229 }
01230 
01231 <span class="keyword">static</span> <span class="keyword">struct </span>session_list *
01232 snmp_sess_copy(netsnmp_session * pss)
01233 {
01234     <span class="keyword">struct </span>session_list *psl;
01235     psl = _sess_copy(pss);
01236     <span class="keywordflow">if</span> (!psl) {
01237         <span class="keywordflow">if</span> (!pss-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a>) {
01238             pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_GENERR;
01239         }
01240         SET_SNMP_ERROR(pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
01241     }
01242     <span class="keywordflow">return</span> psl;
01243 }
01244 
01245 
01246 
01247 <span class="keywordtype">int</span>
01248 snmpv3_engineID_probe(<span class="keyword">struct</span> session_list *slp,
01249                       netsnmp_session * in_session)
01250 {
01251     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>    *pdu = NULL, *response = NULL;
01252     netsnmp_session *session;
01253     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    i;
01254     <span class="keywordtype">int</span>             status;
01255 
01256     <span class="keywordflow">if</span> (slp == NULL || slp-&gt;session == NULL) {
01257         <span class="keywordflow">return</span> 0;
01258     }
01259 
01260     session = slp-&gt;session;
01261 
01262     <span class="comment">/*</span>
01263 <span class="comment">     * If we are opening a V3 session and we don't know engineID we must probe</span>
01264 <span class="comment">     * it -- this must be done after the session is created and inserted in the</span>
01265 <span class="comment">     * list so that the response can handled correctly. </span>
01266 <span class="comment">     */</span>
01267 
01268     <span class="keywordflow">if</span> ((session-&gt;<a class="code" href=
"structsnmp__session.html#o3">flags</a> &amp; SNMP_FLAGS_DONT_PROBE) == SNMP_FLAGS_DONT_PROBE)
01269         <span class="keywordflow">return</span> 1;
01270 
01271     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a> == SNMP_VERSION_3) {
01272         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a> == 0) {
01273             <span class="keywordflow">if</span> (snmpv3_build_probe_pdu(&amp;pdu) != 0) {
01274                 DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>, <span class=
"stringliteral">"unable to create probe PDU\n"</span>));
01275                 <span class="keywordflow">return</span> 0;
01276             }
01277             DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>, <span class=
"stringliteral">"probing for engineID...\n"</span>));
01278             status = snmp_sess_synch_response(slp, pdu, &amp;response);
01279 
01280             <span class="keywordflow">if</span> ((response == NULL) &amp;&amp; (status == STAT_SUCCESS)) {
01281                 status = STAT_ERROR;
01282             }
01283 
01284             <span class="keywordflow">switch</span> (status) {
01285             <span class="keywordflow">case</span> STAT_SUCCESS:
01286                 in_session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_INVALID_MSG; <span class="comment">/* XX?? */</span>
01287                 DEBUGMSGTL((<span class="stringliteral">"snmp_sess_open"</span>,
01288                             <span class="stringliteral">"error: expected Report as response to probe: %s (%d)\n"</span>,
01289                             snmp_errstring(response-&gt;errstat),
01290                             response-&gt;errstat));
01291                 <span class="keywordflow">break</span>;
01292             <span class="keywordflow">case</span> STAT_ERROR:   <span class=
"comment">/* this is what we expected -&gt; Report == STAT_ERROR */</span>
01293                 in_session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_UNKNOWN_ENG_ID;
01294                 <span class="keywordflow">break</span>;
01295             <span class="keywordflow">case</span> STAT_TIMEOUT:
01296                 in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_TIMEOUT;
01297             <span class="keywordflow">default</span>:
01298                 DEBUGMSGTL((<span class="stringliteral">"snmp_sess_open"</span>,
01299                             <span class="stringliteral">"unable to connect with remote engine: %s (%d)\n"</span>,
01300                             snmp_api_errstring(session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a>),
01301                             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>));
01302                 <span class="keywordflow">break</span>;
01303             }
01304 
01305             <span class="keywordflow">if</span> (slp-&gt;session-&gt;securityEngineIDLen == 0) {
01306                 DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>,
01307                             <span class="stringliteral">"unable to determine remote engine ID\n"</span>));
01308                 <span class="keywordflow">return</span> 0;
01309             }
01310 
01311             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_SUCCESS;
01312             <span class="keywordflow">if</span> (snmp_get_do_debugging()) {
01313                 DEBUGMSGTL((<span class="stringliteral">"snmp_sess_open"</span>,
01314                             <span class="stringliteral">"  probe found engineID:  "</span>));
01315                 <span class="keywordflow">for</span> (i = 0; i &lt; slp-&gt;session-&gt;securityEngineIDLen; i++)
01316                     DEBUGMSG((<span class="stringliteral">"snmp_sess_open"</span>, <span class=
"stringliteral">"%02x"</span>,
01317                               slp-&gt;session-&gt;securityEngineID[i]));
01318                 DEBUGMSG((<span class="stringliteral">"snmp_sess_open"</span>, <span class="stringliteral">"\n"</span>));
01319             }
01320         }
01321 
01322         <span class="comment">/*</span>
01323 <span class="comment">         * if boot/time supplied set it for this engineID </span>
01324 <span class="comment">         */</span>
01325         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o23">engineBoots</a> || session-&gt;<a class="code" href=
"structsnmp__session.html#o24">engineTime</a>) {
01326             set_enginetime(session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
01327                            session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>,
01328                            session-&gt;<a class="code" href=
"structsnmp__session.html#o23">engineBoots</a>, session-&gt;<a class="code" href="structsnmp__session.html#o24">engineTime</a>,
01329                            TRUE);
01330         }
01331 
01332         <span class="keywordflow">if</span> (create_user_from_session(slp-&gt;session) != SNMPERR_SUCCESS) {
01333             in_session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_UNKNOWN_USER_NAME;       <span class="comment">/* XX?? */</span>
01334             DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>,
01335                         <span class=
"stringliteral">"snmp_sess_open(): failed(2) to create a new user from session\n"</span>));
01336             <span class="keywordflow">return</span> 0;
01337         }
01338     }
01339 
01340     <span class="keywordflow">return</span> 1;
01341 }
01342 
01343 
01344 
01345 <span class="comment">/*******************************************************************-o-******</span>
01346 <span class="comment"> * snmp_sess_open</span>
01347 <span class="comment"> *</span>
01348 <span class="comment"> * Parameters:</span>
01349 <span class="comment"> *      *in_session</span>
01350 <span class="comment"> *</span>
01351 <span class="comment"> * Returns:</span>
01352 <span class="comment"> *      Pointer to a session in the session list   -OR-         FIX -- right?</span>
01353 <span class="comment"> *      NULL on failure.</span>
01354 <span class="comment"> *</span>
01355 <span class="comment"> * The "spin-free" version of snmp_open.</span>
01356 <span class="comment"> */</span>
01357 <span class="keyword">static</span> <span class="keywordtype">void</span>    *
01358 _sess_open(netsnmp_session * in_session)
01359 {
01360     <span class="keyword">struct </span>session_list *slp;
01361     netsnmp_session *session;
01362     <span class="keywordtype">char</span>            *clientaddr_save = NULL;
01363 
01364     in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
01365     in_session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
01366 
01367     _init_snmp();
01368 
01369     <span class="keywordflow">if</span> ((slp = snmp_sess_copy(in_session)) == NULL) {
01370         <span class="keywordflow">return</span> (NULL);
01371     }
01372     session = slp-&gt;session;
01373     slp-&gt;transport = NULL;
01374 
01375     <span class="keywordflow">if</span> (NULL != session-&gt;<a class="code" href=
"structsnmp__session.html#o8">localname</a>) {
01376         clientaddr_save = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
01377                                                 NETSNMP_DS_LIB_CLIENT_ADDR);
01378         netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,
01379                               NETSNMP_DS_LIB_CLIENT_ADDR, session-&gt;<a class="code" href=
"structsnmp__session.html#o8">localname</a>);
01380     }
01381 
01382     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o3">flags</a> &amp; SNMP_FLAGS_STREAM_SOCKET) {
01383         slp-&gt;transport = netsnmp_tdomain_transport(session-&gt;<a class="code" href=
"structsnmp__session.html#o6">peername</a>,
01384                                                    session-&gt;<a class="code" href=
"structsnmp__session.html#o9">local_port</a>,
01385                                                    <span class="stringliteral">"tcp"</span>);
01386     } <span class="keywordflow">else</span> {
01387         slp-&gt;transport = netsnmp_tdomain_transport(session-&gt;<a class="code" href=
"structsnmp__session.html#o6">peername</a>,
01388                                                    session-&gt;<a class="code" href=
"structsnmp__session.html#o9">local_port</a>,
01389                                                    <span class="stringliteral">"udp"</span>);
01390     }
01391 
01392     <span class="keywordflow">if</span> (NULL != session-&gt;<a class="code" href=
"structsnmp__session.html#o8">localname</a>)
01393         netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,
01394                               NETSNMP_DS_LIB_CLIENT_ADDR, clientaddr_save);
01395 
01396     <span class="keywordflow">if</span> (slp-&gt;transport == NULL) {
01397         DEBUGMSGTL((<span class="stringliteral">"_sess_open"</span>, <span class=
"stringliteral">"couldn't interpret peername\n"</span>));
01398         in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_ADDRESS;
01399         in_session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = errno;
01400         snmp_set_detail(session-&gt;<a class="code" href="structsnmp__session.html#o6">peername</a>);
01401         snmp_sess_close(slp);
01402         <span class="keywordflow">return</span> NULL;
01403     }
01404 
01405     session-&gt;<a class="code" href="structsnmp__session.html#o18">rcvMsgMaxSize</a> = slp-&gt;transport-&gt;msgMaxSize;
01406 
01407     <span class="keywordflow">if</span> (!snmpv3_engineID_probe(slp, in_session)) {
01408         snmp_sess_close(slp);
01409         <span class="keywordflow">return</span> 0;
01410     }
01411 
01412     <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) slp;
01413 }                               <span class="comment">/* end snmp_sess_open() */</span>
01414 
01415 
01416 
01417 <span class="comment">/*</span>
01418 <span class="comment"> * EXPERIMENTAL API EXTENSIONS ------------------------------------------ </span>
01419 <span class="comment"> * </span>
01420 <span class="comment"> * snmp_sess_add_ex, snmp_sess_add, snmp_add </span>
01421 <span class="comment"> * </span>
01422 <span class="comment"> * Analogous to snmp_open family of functions, but taking a netsnmp_transport</span>
01423 <span class="comment"> * pointer as an extra argument.  Unlike snmp_open et al. it doesn't attempt</span>
01424 <span class="comment"> * to interpret the in_session-&gt;peername as a transport endpoint specifier,</span>
01425 <span class="comment"> * but instead uses the supplied transport.  JBPN</span>
01426 <span class="comment"> * </span>
01427 <span class="comment"> */</span>
01428 
01429 netsnmp_session *
01430 snmp_add(netsnmp_session * in_session,
01431          netsnmp_transport *transport,
01432          <span class="keywordtype">int</span> (*fpre_parse) (netsnmp_session *, netsnmp_transport *, <span class=
"keywordtype">void</span> *,
01433                             <span class="keywordtype">int</span>), <span class=
"keywordtype">int</span> (*fpost_parse) (netsnmp_session *,
01434                                                       <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, <span class="keywordtype">int</span>))
01435 {
01436     <span class="keyword">struct </span>session_list *slp;
01437     slp = (<span class="keyword">struct </span>session_list *) snmp_sess_add_ex(in_session, transport,
01438                                                    fpre_parse, NULL,
01439                                                    fpost_parse, NULL, NULL,
01440                                                    NULL, NULL);
01441     <span class="keywordflow">if</span> (slp == NULL) {
01442         <span class="keywordflow">return</span> NULL;
01443     }
01444 
01445     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
01446     slp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = Sessions;
01447     Sessions = slp;
01448     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
01449 
01450     <span class="keywordflow">return</span> (slp-&gt;session);
01451 }
01452 
01453 netsnmp_session *
01454 snmp_add_full(netsnmp_session * in_session,
01455               netsnmp_transport *transport,
01456               <span class="keywordtype">int</span> (*fpre_parse) (netsnmp_session *, netsnmp_transport *,
01457                                  <span class="keywordtype">void</span> *, <span class="keywordtype">int</span>),
01458               <span class="keywordtype">int</span> (*fparse) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, u_char *,
01459                              size_t),
01460               <span class="keywordtype">int</span> (*fpost_parse) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, <span class="keywordtype">int</span>),
01461               <span class="keywordtype">int</span> (*fbuild) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, u_char *,
01462                              size_t *), <span class="keywordtype">int</span> (*frbuild) (netsnmp_session *,
01463                                                         <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *,
01464                                                         u_char **,
01465                                                         size_t *,
01466                                                         size_t *),
01467               <span class="keywordtype">int</span> (*fcheck) (u_char *, size_t),
01468               <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *(*fcreate_pdu) (netsnmp_transport *, <span class="keywordtype">void</span> *,
01469                                            size_t))
01470 {
01471     <span class="keyword">struct </span>session_list *slp;
01472     slp = (<span class="keyword">struct </span>session_list *) snmp_sess_add_ex(in_session, transport,
01473                                                    fpre_parse, fparse,
01474                                                    fpost_parse, fbuild,
01475                                                    frbuild, fcheck,
01476                                                    fcreate_pdu);
01477     <span class="keywordflow">if</span> (slp == NULL) {
01478         <span class="keywordflow">return</span> NULL;
01479     }
01480 
01481     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
01482     slp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = Sessions;
01483     Sessions = slp;
01484     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
01485 
01486     <span class="keywordflow">return</span> (slp-&gt;session);
01487 }
01488 
01489 
01490 
01491 <span class="keywordtype">void</span>           *
01492 snmp_sess_add_ex(netsnmp_session * in_session,
01493                  netsnmp_transport *transport,
01494                  <span class="keywordtype">int</span> (*fpre_parse) (netsnmp_session *, netsnmp_transport *,
01495                                     <span class="keywordtype">void</span> *, <span class="keywordtype">int</span>),
01496                  <span class="keywordtype">int</span> (*fparse) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, u_char *,
01497                                 size_t),
01498                  <span class="keywordtype">int</span> (*fpost_parse) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *,
01499                                      <span class="keywordtype">int</span>),
01500                  <span class="keywordtype">int</span> (*fbuild) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, u_char *,
01501                                 size_t *),
01502                  <span class="keywordtype">int</span> (*frbuild) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *,
01503                                  u_char **, size_t *, size_t *),
01504                  <span class="keywordtype">int</span> (*fcheck) (u_char *, size_t),
01505                  <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *(*fcreate_pdu) (netsnmp_transport *, <span class="keywordtype">void</span> *,
01506                                               size_t))
01507 {
01508     <span class="keyword">struct </span>session_list *slp;
01509 
01510     _init_snmp();
01511 
01512     <span class="keywordflow">if</span> (in_session == NULL || transport == NULL) {
01513         <span class="keywordflow">return</span> NULL;
01514     }
01515 
01516     DEBUGMSGTL((<span class="stringliteral">"snmp_sess_add"</span>, <span class=
"stringliteral">"fd %d\n"</span>, transport-&gt;sock));
01517 
01518     <span class="keywordflow">if</span> ((slp = snmp_sess_copy(in_session)) == NULL) {
01519         <span class="keywordflow">return</span> (NULL);
01520     }
01521 
01522     slp-&gt;transport = transport;
01523     slp-&gt;internal-&gt;hook_pre = fpre_parse;
01524     slp-&gt;internal-&gt;hook_parse = fparse;
01525     slp-&gt;internal-&gt;hook_post = fpost_parse;
01526     slp-&gt;internal-&gt;hook_build = fbuild;
01527     slp-&gt;internal-&gt;hook_realloc_build = frbuild;
01528     slp-&gt;internal-&gt;check_packet = fcheck;
01529     slp-&gt;internal-&gt;hook_create_pdu = fcreate_pdu;
01530 
01531     slp-&gt;session-&gt;rcvMsgMaxSize = transport-&gt;msgMaxSize;
01532 
01533     <span class="keywordflow">if</span> (slp-&gt;session-&gt;version == SNMP_VERSION_3) {
01534         DEBUGMSGTL((<span class="stringliteral">"snmp_sess_add"</span>,
01535                     <span class="stringliteral">"adding v3 session -- engineID probe now\n"</span>));
01536         <span class="keywordflow">if</span> (!snmpv3_engineID_probe(slp, in_session)) {
01537             DEBUGMSGTL((<span class="stringliteral">"snmp_sess_add"</span>, <span class=
"stringliteral">"engine ID probe failed\n"</span>));
01538             snmp_sess_close(slp);
01539             slp = NULL;
01540         }
01541     }
01542 
01543     <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) slp;
01544 }                               <span class="comment">/*  end snmp_sess_add_ex()  */</span>
01545 
01546 
01547 
01548 <span class="keywordtype">void</span>           *
01549 snmp_sess_add(netsnmp_session * in_session,
01550               netsnmp_transport *transport,
01551               <span class="keywordtype">int</span> (*fpre_parse) (netsnmp_session *, netsnmp_transport *,
01552                                  <span class="keywordtype">void</span> *, <span class="keywordtype">int</span>),
01553               <span class="keywordtype">int</span> (*fpost_parse) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, <span class="keywordtype">int</span>))
01554 {
01555     <span class="keywordflow">return</span> snmp_sess_add_ex(in_session, transport, fpre_parse, NULL,
01556                             fpost_parse, NULL, NULL, NULL, NULL);
01557 }
01558 
01559 
01560 
01561 <span class="keywordtype">void</span>           *
01562 snmp_sess_open(netsnmp_session * pss)
01563 {
01564     <span class="keywordtype">void</span>           *pvoid;
01565     pvoid = _sess_open(pss);
01566     <span class="keywordflow">if</span> (!pvoid) {
01567         SET_SNMP_ERROR(pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
01568     }
01569     <span class="keywordflow">return</span> pvoid;
01570 }
01571 
01572 
01573 
01574 <span class="comment">/*</span>
01575 <span class="comment"> * create_user_from_session(netsnmp_session *session):</span>
01576 <span class="comment"> * </span>
01577 <span class="comment"> * creates a user in the usm table from the information in a session.</span>
01578 <span class="comment"> * If the user already exists, it is updated with the current</span>
01579 <span class="comment"> * information from the session</span>
01580 <span class="comment"> * </span>
01581 <span class="comment"> * Parameters:</span>
01582 <span class="comment"> * session -- IN: pointer to the session to use when creating the user.</span>
01583 <span class="comment"> * </span>
01584 <span class="comment"> * Returns:</span>
01585 <span class="comment"> * SNMPERR_SUCCESS</span>
01586 <span class="comment"> * SNMPERR_GENERR </span>
01587 <span class="comment"> */</span>
01588 <span class="keywordtype">int</span>
01589 create_user_from_session(netsnmp_session * session)
01590 {
01591     <span class="keyword">struct </span>usmUser *user;
01592     <span class="keywordtype">int</span>             user_just_created = 0;
01593     u_char *cp;
01594 
01595     <span class="comment">/*</span>
01596 <span class="comment">     * now that we have the engineID, create an entry in the USM list</span>
01597 <span class="comment">     * for this user using the information in the session </span>
01598 <span class="comment">     */</span>
01599     user = usm_get_user_from_list(session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
01600                                   session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>,
01601                                   session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a>,
01602                                   usm_get_userList(), 0);
01603     <span class="keywordflow">if</span> (user == NULL) {
01604         DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>, <span class=
"stringliteral">"Building user %s...\n"</span>,
01605                     session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a>));
01606         <span class="comment">/*</span>
01607 <span class="comment">         * user doesn't exist so we create and add it </span>
01608 <span class="comment">         */</span>
01609         user = (<span class="keyword">struct </span>usmUser *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> usmUser));
01610         <span class="keywordflow">if</span> (user == NULL)
01611             <span class="keywordflow">return</span> SNMPERR_GENERR;
01612 
01613         <span class="comment">/*</span>
01614 <span class="comment">         * copy in the securityName </span>
01615 <span class="comment">         */</span>
01616         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o29">securityName</a>) {
01617             user-&gt;name = strdup(session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a>);
01618             user-&gt;secName = strdup(session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a>);
01619             <span class="keywordflow">if</span> (user-&gt;name == NULL || user-&gt;secName == NULL) {
01620                 usm_free_user(user);
01621                 <span class="keywordflow">return</span> SNMPERR_GENERR;
01622             }
01623         }
01624 
01625         <span class="comment">/*</span>
01626 <span class="comment">         * copy in the engineID </span>
01627 <span class="comment">         */</span>
01628         <span class="keywordflow">if</span> (<a class="code" href=
"group__util.html#ga5">memdup</a>(&amp;user-&gt;engineID, session-&gt;<a class="code" href=
"structsnmp__session.html#o27">securityEngineID</a>,
01629                    session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a>) != SNMPERR_SUCCESS) {
01630             usm_free_user(user);
01631             <span class="keywordflow">return</span> SNMPERR_GENERR;
01632         }
01633         user-&gt;engineIDLen = session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>;
01634 
01635         user_just_created = 1;
01636     }
01637     <span class="comment">/*</span>
01638 <span class="comment">     * copy the auth protocol </span>
01639 <span class="comment">     */</span>
01640     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o31">securityAuthProto</a> != NULL) {
01641         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;authProtocol);
01642         user-&gt;authProtocol =
01643             snmp_duplicate_objid(session-&gt;<a class="code" href="structsnmp__session.html#o31">securityAuthProto</a>,
01644                                  session-&gt;<a class="code" href="structsnmp__session.html#o32">securityAuthProtoLen</a>);
01645         <span class="keywordflow">if</span> (user-&gt;authProtocol == NULL) {
01646             usm_free_user(user);
01647             <span class="keywordflow">return</span> SNMPERR_GENERR;
01648         }
01649         user-&gt;authProtocolLen = session-&gt;<a class="code" href=
"structsnmp__session.html#o32">securityAuthProtoLen</a>;
01650     }
01651 
01652     <span class="comment">/*</span>
01653 <span class="comment">     * copy the priv protocol </span>
01654 <span class="comment">     */</span>
01655     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o37">securityPrivProto</a> != NULL) {
01656         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;privProtocol);
01657         user-&gt;privProtocol =
01658             snmp_duplicate_objid(session-&gt;<a class="code" href="structsnmp__session.html#o37">securityPrivProto</a>,
01659                                  session-&gt;<a class="code" href="structsnmp__session.html#o38">securityPrivProtoLen</a>);
01660         <span class="keywordflow">if</span> (user-&gt;privProtocol == NULL) {
01661             usm_free_user(user);
01662             <span class="keywordflow">return</span> SNMPERR_GENERR;
01663         }
01664         user-&gt;privProtocolLen = session-&gt;<a class="code" href=
"structsnmp__session.html#o38">securityPrivProtoLen</a>;
01665     }
01666 
01667     <span class="comment">/*</span>
01668 <span class="comment">     * copy in the authentication Key.  If not localized, localize it </span>
01669 <span class="comment">     */</span>
01670     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o35">securityAuthLocalKey</a> != NULL
01671         &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#o36">securityAuthLocalKeyLen</a> != 0) {
01672         <span class="comment">/* already localized key passed in.  use it */</span>
01673         <span class="keywordflow">if</span> (<a class="code" href=
"group__util.html#ga5">memdup</a>(&amp;user-&gt;authKey, session-&gt;<a class="code" href=
"structsnmp__session.html#o35">securityAuthLocalKey</a>,
01674                    session-&gt;<a class="code" href=
"structsnmp__session.html#o36">securityAuthLocalKeyLen</a>) != SNMPERR_SUCCESS) {
01675             usm_free_user(user);
01676             <span class="keywordflow">return</span> SNMPERR_GENERR;
01677         }
01678         user-&gt;authKeyLen = session-&gt;<a class="code" href="structsnmp__session.html#o36">securityAuthLocalKeyLen</a>;
01679     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o33">securityAuthKey</a> != NULL
01680         &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#o34">securityAuthKeyLen</a> != 0) {
01681         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;authKey);
01682         user-&gt;authKey = (u_char *) calloc(1, USM_LENGTH_KU_HASHBLOCK);
01683         <span class="keywordflow">if</span> (user-&gt;authKey == NULL) {
01684             usm_free_user(user);
01685             <span class="keywordflow">return</span> SNMPERR_GENERR;
01686         }
01687         user-&gt;authKeyLen = USM_LENGTH_KU_HASHBLOCK;
01688         <span class="keywordflow">if</span> (generate_kul(user-&gt;authProtocol, user-&gt;authProtocolLen,
01689                          session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
01690                          session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>,
01691                          session-&gt;<a class="code" href="structsnmp__session.html#o33">securityAuthKey</a>,
01692                          session-&gt;<a class="code" href=
"structsnmp__session.html#o34">securityAuthKeyLen</a>, user-&gt;authKey,
01693                          &amp;user-&gt;authKeyLen) != SNMPERR_SUCCESS) {
01694             usm_free_user(user);
01695             <span class="keywordflow">return</span> SNMPERR_GENERR;
01696         }
01697     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01698                                            NETSNMP_DS_LIB_AUTHLOCALIZEDKEY))) {
01699         size_t buflen = USM_AUTH_KU_LEN;
01700         user-&gt;authKey = malloc(buflen); <span class="comment">/* max length needed */</span>
01701         user-&gt;authKeyLen = 0;
01702         <span class="comment">/* it will be a hex string */</span>
01703         <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;user-&gt;authKey, &amp;buflen, &amp;user-&gt;authKeyLen,
01704                                 0, cp)) {
01705             usm_free_user(user);
01706             <span class="keywordflow">return</span> SNMPERR_GENERR;
01707         }
01708     }
01709 
01710     <span class="comment">/*</span>
01711 <span class="comment">     * copy in the privacy Key.  If not localized, localize it </span>
01712 <span class="comment">     */</span>
01713     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o41">securityPrivLocalKey</a> != NULL
01714         &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#o42">securityPrivLocalKeyLen</a> != 0) {
01715         <span class="comment">/* already localized key passed in.  use it */</span>
01716         <span class="keywordflow">if</span> (<a class="code" href=
"group__util.html#ga5">memdup</a>(&amp;user-&gt;privKey, session-&gt;<a class="code" href=
"structsnmp__session.html#o41">securityPrivLocalKey</a>,
01717                    session-&gt;<a class="code" href=
"structsnmp__session.html#o42">securityPrivLocalKeyLen</a>) != SNMPERR_SUCCESS) {
01718             usm_free_user(user);
01719             <span class="keywordflow">return</span> SNMPERR_GENERR;
01720         }
01721         user-&gt;privKeyLen = session-&gt;<a class="code" href="structsnmp__session.html#o42">securityPrivLocalKeyLen</a>;
01722     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o39">securityPrivKey</a> != NULL
01723         &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#o40">securityPrivKeyLen</a> != 0) {
01724         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;privKey);
01725         user-&gt;privKey = (u_char *) calloc(1, USM_LENGTH_KU_HASHBLOCK);
01726         <span class="keywordflow">if</span> (user-&gt;privKey == NULL) {
01727             usm_free_user(user);
01728             <span class="keywordflow">return</span> SNMPERR_GENERR;
01729         }
01730         user-&gt;privKeyLen = USM_LENGTH_KU_HASHBLOCK;
01731         <span class="keywordflow">if</span> (generate_kul(user-&gt;authProtocol, user-&gt;authProtocolLen,
01732                          session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
01733                          session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>,
01734                          session-&gt;<a class="code" href="structsnmp__session.html#o39">securityPrivKey</a>,
01735                          session-&gt;<a class="code" href=
"structsnmp__session.html#o40">securityPrivKeyLen</a>, user-&gt;privKey,
01736                          &amp;user-&gt;privKeyLen) != SNMPERR_SUCCESS) {
01737             usm_free_user(user);
01738             <span class="keywordflow">return</span> SNMPERR_GENERR;
01739         }
01740     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01741                                            NETSNMP_DS_LIB_PRIVLOCALIZEDKEY))) {
01742         size_t buflen = USM_PRIV_KU_LEN;
01743         user-&gt;privKey = malloc(buflen); <span class="comment">/* max length needed */</span>
01744         user-&gt;privKeyLen = 0;
01745         <span class="comment">/* it will be a hex string */</span>
01746         <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;user-&gt;privKey, &amp;buflen, &amp;user-&gt;privKeyLen,
01747                                 0, cp)) {
01748             usm_free_user(user);
01749             <span class="keywordflow">return</span> SNMPERR_GENERR;
01750         }
01751     }
01752 
01753     user-&gt;userStatus = RS_ACTIVE;
01754     user-&gt;userStorageType = ST_READONLY;
01755 
01756     <span class="keywordflow">if</span> (user_just_created) {
01757         <span class="comment">/*</span>
01758 <span class="comment">         * add the user into the database </span>
01759 <span class="comment">         */</span>
01760         usm_add_user(user);
01761     }
01762 
01763     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
01764 
01765 
01766 }                               <span class="comment">/* end create_user_from_session() */</span>
01767 
01768 <span class="comment">/*</span>
01769 <span class="comment"> *  Do a "deep free()" of a netsnmp_session.</span>
01770 <span class="comment"> *</span>
01771 <span class="comment"> *  CAUTION:  SHOULD ONLY BE USED FROM snmp_sess_close() OR SIMILAR.</span>
01772 <span class="comment"> *                                                      (hence it is static)</span>
01773 <span class="comment"> */</span>
01774 
01775 <span class="keyword">static</span> <span class="keywordtype">void</span>
01776 snmp_free_session(netsnmp_session * s)
01777 {
01778     <span class="keywordflow">if</span> (s) {
01779         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o6">peername</a>);
01780         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o16">community</a>);
01781         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o21">contextEngineID</a>);
01782         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o25">contextName</a>);
01783         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o27">securityEngineID</a>);
01784         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o29">securityName</a>);
01785         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o31">securityAuthProto</a>);
01786         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o37">securityPrivProto</a>);
01787         free((<span class="keywordtype">char</span> *) s);
01788     }
01789 }
01790 
01791 <span class="comment">/*</span>
01792 <span class="comment"> * Close the input session.  Frees all data allocated for the session,</span>
01793 <span class="comment"> * dequeues any pending requests, and closes any sockets allocated for</span>
01794 <span class="comment"> * the session.  Returns 0 on error, 1 otherwise.</span>
01795 <span class="comment"> */</span>
01796 <span class="keywordtype">int</span>
01797 snmp_sess_close(<span class="keywordtype">void</span> *sessp)
01798 {
01799     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
01800     netsnmp_transport *transport;
01801     <span class="keyword">struct </span>snmp_internal_session *isp;
01802     netsnmp_session *sesp = NULL;
01803     <span class="keyword">struct </span>snmp_secmod_def *sptr;
01804 
01805     <span class="keywordflow">if</span> (slp == NULL) {
01806         <span class="keywordflow">return</span> 0;
01807     }
01808 
01809     <span class="keywordflow">if</span> (slp-&gt;session != NULL &amp;&amp;
01810         (sptr = find_sec_mod(slp-&gt;session-&gt;securityModel)) != NULL &amp;&amp;
01811         sptr-&gt;session_close != NULL) {
01812         (*sptr-&gt;session_close) (slp-&gt;session);
01813     }
01814 
01815     isp = slp-&gt;internal;
01816     slp-&gt;internal = 0;
01817 
01818     <span class="keywordflow">if</span> (isp) {
01819         netsnmp_request_list *rp, *orp;
01820 
01821         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(isp-&gt;packet);
01822 
01823         <span class="comment">/*</span>
01824 <span class="comment">         * Free each element in the input request list.  </span>
01825 <span class="comment">         */</span>
01826         rp = isp-&gt;requests;
01827         <span class="keywordflow">while</span> (rp) {
01828             orp = rp;
01829             rp = rp-&gt;next_request;
01830             snmp_free_pdu(orp-&gt;pdu);
01831             free((<span class="keywordtype">char</span> *) orp);
01832         }
01833 
01834         free((<span class="keywordtype">char</span> *) isp);
01835     }
01836 
01837     transport = slp-&gt;transport;
01838     slp-&gt;transport = 0;
01839 
01840     <span class="keywordflow">if</span> (transport) {
01841         transport-&gt;f_close(transport);
01842         netsnmp_transport_free(transport);
01843     }
01844 
01845     sesp = slp-&gt;session;
01846     slp-&gt;session = 0;
01847 
01848     <span class="comment">/*</span>
01849 <span class="comment">     * The following is necessary to avoid memory leakage when closing AgentX </span>
01850 <span class="comment">     * sessions that may have multiple subsessions.  These hang off the main</span>
01851 <span class="comment">     * session at -&gt;subsession, and chain through -&gt;next.  </span>
01852 <span class="comment">     */</span>
01853 
01854     <span class="keywordflow">if</span> (sesp != NULL &amp;&amp; sesp-&gt;<a class="code" href=
"structsnmp__session.html#o4">subsession</a> != NULL) {
01855         netsnmp_session *subsession = sesp-&gt;<a class="code" href="structsnmp__session.html#o4">subsession</a>, *tmpsub;
01856 
01857         <span class="keywordflow">while</span> (subsession != NULL) {
01858             DEBUGMSGTL((<span class="stringliteral">"snmp_sess_close"</span>,
01859                         <span class="stringliteral">"closing session %p, subsession %p\n"</span>, sesp,
01860                         subsession));
01861             tmpsub = subsession-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
01862             snmp_free_session(subsession);
01863             subsession = tmpsub;
01864         }
01865     }
01866 
01867     snmp_free_session(sesp);
01868     free((<span class="keywordtype">char</span> *) slp);
01869     <span class="keywordflow">return</span> 1;
01870 }
01871 
01872 <span class="keywordtype">int</span>
01873 snmp_close(netsnmp_session * session)
01874 {
01875     <span class="keyword">struct </span>session_list *slp = NULL, *oslp = NULL;
01876 
01877     {                           <span class="comment">/*MTCRITICAL_RESOURCE */</span>
01878         snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
01879         <span class="keywordflow">if</span> (Sessions &amp;&amp; Sessions-&gt;session == session) { <span class=
"comment">/* If first entry */</span>
01880             slp = Sessions;
01881             Sessions = slp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
01882         } <span class="keywordflow">else</span> {
01883             <span class="keywordflow">for</span> (slp = Sessions; slp; slp = slp-&gt;next) {
01884                 <span class="keywordflow">if</span> (slp-&gt;session == session) {
01885                     <span class="keywordflow">if</span> (oslp)   <span class=
"comment">/* if we found entry that points here */</span>
01886                         oslp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = slp-&gt;<a class="code"
href="structsnmp__session.html#o5">next</a>; <span class="comment">/* link around this entry */</span>
01887                     <span class="keywordflow">break</span>;
01888                 }
01889                 oslp = slp;
01890             }
01891         }
01892         snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
01893     }                           <span class="comment">/*END MTCRITICAL_RESOURCE */</span>
01894     <span class="keywordflow">if</span> (slp == NULL) {
01895         <span class="keywordflow">return</span> 0;
01896     }
01897     <span class="keywordflow">return</span> snmp_sess_close((<span class="keywordtype">void</span> *) slp);
01898 }
01899 
01900 <span class="keywordtype">int</span>
01901 snmp_close_sessions(<span class="keywordtype">void</span>)
01902 {
01903     <span class="keyword">struct </span>session_list *slp;
01904 
01905     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
01906     <span class="keywordflow">while</span> (Sessions) {
01907         slp = Sessions;
01908         Sessions = Sessions-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
01909         snmp_sess_close((<span class="keywordtype">void</span> *) slp);
01910     }
01911     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
01912     <span class="keywordflow">return</span> 1;
01913 }
01914 
01915 <span class="keyword">static</span> <span class="keywordtype">int</span>
01916 snmpv3_build_probe_pdu(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> **pdu)
01917 {
01918     <span class="keyword">struct </span>usmUser *user;
01919 
01920     <span class="comment">/*</span>
01921 <span class="comment">     * create the pdu </span>
01922 <span class="comment">     */</span>
01923     <span class="keywordflow">if</span> (!pdu)
01924         <span class="keywordflow">return</span> -1;
01925     *pdu = snmp_pdu_create(SNMP_MSG_GET);
01926     <span class="keywordflow">if</span> (!(*pdu))
01927         <span class="keywordflow">return</span> -1;
01928     (*pdu)-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a> = SNMP_VERSION_3;
01929     (*pdu)-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a> = strdup(<span class=
"stringliteral">""</span>);
01930     (*pdu)-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a> = strlen((*pdu)-&gt;securityName);
01931     (*pdu)-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> = SNMP_SEC_LEVEL_NOAUTH;
01932     (*pdu)-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a> = SNMP_SEC_MODEL_USM;
01933 
01934     <span class="comment">/*</span>
01935 <span class="comment">     * create the empty user </span>
01936 <span class="comment">     */</span>
01937     user = usm_get_user(NULL, 0, (*pdu)-&gt;securityName);
01938     <span class="keywordflow">if</span> (user == NULL) {
01939         user = (<span class="keyword">struct </span>usmUser *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> usmUser));
01940         <span class="keywordflow">if</span> (user == NULL) {
01941             snmp_free_pdu(*pdu);
01942             *pdu = (<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *) NULL;
01943             <span class="keywordflow">return</span> -1;
01944         }
01945         user-&gt;name = strdup((*pdu)-&gt;securityName);
01946         user-&gt;secName = strdup((*pdu)-&gt;securityName);
01947         user-&gt;authProtocolLen = <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class=
"keyword">sizeof</span>(oid);
01948         user-&gt;authProtocol =
01949             snmp_duplicate_objid(usmNoAuthProtocol, user-&gt;authProtocolLen);
01950         user-&gt;privProtocolLen = <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class=
"keyword">sizeof</span>(oid);
01951         user-&gt;privProtocol =
01952             snmp_duplicate_objid(usmNoPrivProtocol, user-&gt;privProtocolLen);
01953         usm_add_user(user);
01954     }
01955     <span class="keywordflow">return</span> 0;
01956 }
01957 
01958 <span class="keyword">static</span> <span class="keywordtype">void</span>
01959 snmpv3_calc_msg_flags(<span class="keywordtype">int</span> sec_level, <span class=
"keywordtype">int</span> msg_command, u_char * flags)
01960 {
01961     *flags = 0;
01962     <span class="keywordflow">if</span> (sec_level == SNMP_SEC_LEVEL_AUTHNOPRIV)
01963         *flags = SNMP_MSG_FLAG_AUTH_BIT;
01964     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sec_level == SNMP_SEC_LEVEL_AUTHPRIV)
01965         *flags = SNMP_MSG_FLAG_AUTH_BIT | SNMP_MSG_FLAG_PRIV_BIT;
01966 
01967     <span class="keywordflow">if</span> (SNMP_CMD_CONFIRMED(msg_command))
01968         *flags |= SNMP_MSG_FLAG_RPRT_BIT;
01969 
01970     <span class="keywordflow">return</span>;
01971 }
01972 
01973 <span class="keyword">static</span> <span class="keywordtype">int</span>
01974 snmpv3_verify_msg(netsnmp_request_list *rp, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
01975 {
01976     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>    *rpdu;
01977 
01978     <span class="keywordflow">if</span> (!rp || !rp-&gt;pdu || !pdu)
01979         <span class="keywordflow">return</span> 0;
01980     <span class="comment">/*</span>
01981 <span class="comment">     * Reports don't have to match anything according to the spec </span>
01982 <span class="comment">     */</span>
01983     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a> == SNMP_MSG_REPORT)
01984         <span class="keywordflow">return</span> 1;
01985     rpdu = rp-&gt;pdu;
01986     <span class="keywordflow">if</span> (rp-&gt;request_id != pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a> || rpdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a> != pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o2">reqid</a>)
01987         <span class="keywordflow">return</span> 0;
01988     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> != pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>)
01989         <span class="keywordflow">return</span> 0;
01990     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o10">securityModel</a> != pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>)
01991         <span class="keywordflow">return</span> 0;
01992     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o11">securityLevel</a> != pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a>)
01993         <span class="keywordflow">return</span> 0;
01994 
01995     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o26">contextEngineIDLen</a> != pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o26">contextEngineIDLen</a> ||
01996         memcmp(rpdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o25">contextEngineID</a>,
01997                pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>))
01998         <span class="keywordflow">return</span> 0;
01999     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o28">contextNameLen</a> != pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a> ||
02000         memcmp(rpdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o27">contextName</a>, pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a>))
02001         <span class="keywordflow">return</span> 0;
02002     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o30">securityEngineIDLen</a> != pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o30">securityEngineIDLen</a> ||
02003         memcmp(rpdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o29">securityEngineID</a>,
02004                pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>))
02005         <span class="keywordflow">return</span> 0;
02006     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o32">securityNameLen</a> != pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a> ||
02007         memcmp(rpdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o31">securityName</a>,
02008                pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a>))
02009         <span class="keywordflow">return</span> 0;
02010     <span class="keywordflow">return</span> 1;
02011 }
02012 
02013 
02014 <span class="comment">/*</span>
02015 <span class="comment"> * SNMPv3</span>
02016 <span class="comment"> * * Takes a session and a pdu and serializes the ASN PDU into the area</span>
02017 <span class="comment"> * * pointed to by packet.  out_length is the size of the data area available.</span>
02018 <span class="comment"> * * Returns the length of the completed packet in out_length.  If any errors</span>
02019 <span class="comment"> * * occur, -1 is returned.  If all goes well, 0 is returned.</span>
02020 <span class="comment"> */</span>
02021 <span class="keyword">static</span> <span class="keywordtype">int</span>
02022 snmpv3_build(u_char ** pkt, size_t * pkt_len, size_t * offset,
02023              netsnmp_session * session, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
02024 {
02025     <span class="keywordtype">int</span>             ret;
02026 
02027     session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
02028     session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
02029 
02030     <span class="comment">/*</span>
02031 <span class="comment">     * do validation for PDU types </span>
02032 <span class="comment">     */</span>
02033     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>) {
02034     <span class="keywordflow">case</span> SNMP_MSG_RESPONSE:
02035     <span class="keywordflow">case</span> SNMP_MSG_TRAP2:
02036     <span class="keywordflow">case</span> SNMP_MSG_REPORT:
02037         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> &amp;= (~UCD_MSG_FLAG_EXPECT_RESPONSE);
02038         <span class="comment">/*</span>
02039 <span class="comment">         * Fallthrough </span>
02040 <span class="comment">         */</span>
02041     <span class="keywordflow">case</span> SNMP_MSG_GET:
02042     <span class="keywordflow">case</span> SNMP_MSG_GETNEXT:
02043     <span class="keywordflow">case</span> SNMP_MSG_SET:
02044     <span class="keywordflow">case</span> SNMP_MSG_INFORM:
02045         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o6">errstat</a> == SNMP_DEFAULT_ERRSTAT)
02046             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a> = 0;
02047         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a> == SNMP_DEFAULT_ERRINDEX)
02048             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o7">errindex</a> = 0;
02049         <span class="keywordflow">break</span>;
02050 
02051     <span class="keywordflow">case</span> SNMP_MSG_GETBULK:
02052         <span class="keywordflow">if</span> (pdu-&gt;max_repetitions &lt; 0) {
02053             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_REPETITIONS;
02054             <span class="keywordflow">return</span> -1;
02055         }
02056         <span class="keywordflow">if</span> (pdu-&gt;non_repeaters &lt; 0) {
02057             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_REPEATERS;
02058             <span class="keywordflow">return</span> -1;
02059         }
02060         <span class="keywordflow">break</span>;
02061 
02062     <span class="keywordflow">case</span> SNMP_MSG_TRAP:
02063         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_V1_IN_V2;
02064         <span class="keywordflow">return</span> -1;
02065 
02066     <span class="keywordflow">default</span>:
02067         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_UNKNOWN_PDU;
02068         <span class="keywordflow">return</span> -1;
02069     }
02070 
02071     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o30">securityEngineIDLen</a> == 0) {
02072         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a>) {
02073             snmpv3_clone_engineID(&amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>,
02074                                   &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>,
02075                                   session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
02076                                   session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>);
02077         }
02078     }
02079 
02080     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o26">contextEngineIDLen</a> == 0) {
02081         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o22">contextEngineIDLen</a>) {
02082             snmpv3_clone_engineID(&amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a>,
02083                                   &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>,
02084                                   session-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a>,
02085                                   session-&gt;<a class="code" href="structsnmp__session.html#o22">contextEngineIDLen</a>);
02086         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o30">securityEngineIDLen</a>) {
02087             snmpv3_clone_engineID(&amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a>,
02088                                   &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>,
02089                                   pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>,
02090                                   pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>);
02091         }
02092     }
02093 
02094     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a> == NULL) {
02095         <span class="keywordflow">if</span> (!session-&gt;<a class="code" href=
"structsnmp__session.html#o25">contextName</a>) {
02096             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_CONTEXT;
02097             <span class="keywordflow">return</span> -1;
02098         }
02099         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a> = strdup(session-&gt;<a class="code" href=
"structsnmp__session.html#o25">contextName</a>);
02100         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o27">contextName</a> == NULL) {
02101             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_GENERR;
02102             <span class="keywordflow">return</span> -1;
02103         }
02104         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o26">contextNameLen</a>;
02105     }
02106     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o10">securityModel</a> == SNMP_DEFAULT_SECMODEL) {
02107         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o43">securityModel</a>;
02108         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o10">securityModel</a> == SNMP_DEFAULT_SECMODEL) {
02109             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a> = SNMP_SEC_MODEL_USM;
02110         }
02111     }
02112     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o32">securityNameLen</a> == 0 &amp;&amp; pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o31">securityName</a> == 0) {
02113         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o30">securityNameLen</a> == 0) {
02114             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_SEC_NAME;
02115             <span class="keywordflow">return</span> -1;
02116         }
02117         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a> = strdup(session-&gt;<a class="code" href=
"structsnmp__session.html#o29">securityName</a>);
02118         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o31">securityName</a> == NULL) {
02119             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_GENERR;
02120             <span class="keywordflow">return</span> -1;
02121         }
02122         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o30">securityNameLen</a>;
02123     }
02124     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> == 0) {
02125         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o44">securityLevel</a> == 0) {
02126             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_SEC_LEVEL;
02127             <span class="keywordflow">return</span> -1;
02128         }
02129         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o44">securityLevel</a>;
02130     }
02131     DEBUGMSGTL((<span class="stringliteral">"snmp_build"</span>,
02132                 <span class="stringliteral">"Building SNMPv3 message (secName:\"%s\", secLevel:%s)...\n"</span>,
02133                 ((session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a>) ? (<span class=
"keywordtype">char</span> *) session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a> :
02134                  ((pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a>) ? (<span class=
"keywordtype">char</span> *) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a> :
02135                   <span class="stringliteral">"ERROR: undefined"</span>)), secLevelName[pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o11">securityLevel</a>]));
02136 
02137     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"SNMPv3 Message"</span>);
02138 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02139     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REVERSE_ENCODE)) {
02140         ret = snmpv3_packet_realloc_rbuild(pkt, pkt_len, offset,
02141                                            session, pdu, NULL, 0);
02142     } <span class="keywordflow">else</span> {
02143 <span class="preprocessor">#endif</span>
02144         ret = snmpv3_packet_build(session, pdu, *pkt, pkt_len, NULL, 0);
02145 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02146     }
02147 <span class="preprocessor">#endif</span>
02148     DEBUGINDENTLESS();
02149     <span class="keywordflow">if</span> (-1 != ret) {
02150         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = ret;
02151     }
02152 
02153     <span class="keywordflow">return</span> ret;
02154 
02155 }                               <span class="comment">/* end snmpv3_build() */</span>
02156 
02157 
02158 
02159 
02160 <span class="keyword">static</span> u_char  *
02161 snmpv3_header_build(netsnmp_session * session, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
02162                     u_char * packet, size_t * out_length,
02163                     size_t length, u_char ** msg_hdr_e)
02164 {
02165     u_char         *global_hdr, *global_hdr_e;
02166     u_char         *cp;
02167     u_char          msg_flags;
02168     <span class="keywordtype">long</span>            max_size;
02169     <span class="keywordtype">long</span>            sec_model;
02170     u_char         *pb, *pb0e;
02171 
02172     <span class="comment">/*</span>
02173 <span class="comment">     * Save current location and build SEQUENCE tag and length placeholder</span>
02174 <span class="comment">     * * for SNMP message sequence (actual length inserted later)</span>
02175 <span class="comment">     */</span>
02176     cp = asn_build_sequence(packet, out_length,
02177                             (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
02178                             length);
02179     <span class="keywordflow">if</span> (cp == NULL)
02180         <span class="keywordflow">return</span> NULL;
02181     <span class="keywordflow">if</span> (msg_hdr_e != NULL)
02182         *msg_hdr_e = cp;
02183     pb0e = cp;
02184 
02185 
02186     <span class="comment">/*</span>
02187 <span class="comment">     * store the version field - msgVersion</span>
02188 <span class="comment">     */</span>
02189     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"SNMP Version Number"</span>);
02190     cp = asn_build_int(cp, out_length,
02191                        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02192                                  ASN_INTEGER), (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a>,
02193                        <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a>));
02194     DEBUGINDENTLESS();
02195     <span class="keywordflow">if</span> (cp == NULL)
02196         <span class="keywordflow">return</span> NULL;
02197 
02198     global_hdr = cp;
02199     <span class="comment">/*</span>
02200 <span class="comment">     * msgGlobalData HeaderData </span>
02201 <span class="comment">     */</span>
02202     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgGlobalData"</span>);
02203     cp = asn_build_sequence(cp, out_length,
02204                             (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR), 0);
02205     <span class="keywordflow">if</span> (cp == NULL)
02206         <span class="keywordflow">return</span> NULL;
02207     global_hdr_e = cp;
02208 
02209 
02210     <span class="comment">/*</span>
02211 <span class="comment">     * msgID </span>
02212 <span class="comment">     */</span>
02213     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgID"</span>);
02214     cp = asn_build_int(cp, out_length,
02215                        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02216                                  ASN_INTEGER), &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a>,
02217                        <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o3">msgid</a>));
02218     DEBUGINDENTLESS();
02219     <span class="keywordflow">if</span> (cp == NULL)
02220         <span class="keywordflow">return</span> NULL;
02221 
02222     <span class="comment">/*</span>
02223 <span class="comment">     * msgMaxSize </span>
02224 <span class="comment">     */</span>
02225     max_size = session-&gt;<a class="code" href="structsnmp__session.html#o18">rcvMsgMaxSize</a>;
02226     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgMaxSize"</span>);
02227     cp = asn_build_int(cp, out_length,
02228                        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02229                                  ASN_INTEGER), &amp;max_size,
02230                        <span class="keyword">sizeof</span>(max_size));
02231     DEBUGINDENTLESS();
02232     <span class="keywordflow">if</span> (cp == NULL)
02233         <span class="keywordflow">return</span> NULL;
02234 
02235     <span class="comment">/*</span>
02236 <span class="comment">     * msgFlags </span>
02237 <span class="comment">     */</span>
02238     snmpv3_calc_msg_flags(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a>, pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o1">command</a>, &amp;msg_flags);
02239     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgFlags"</span>);
02240     cp = asn_build_string(cp, out_length,
02241                           (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02242                                     ASN_OCTET_STR), &amp;msg_flags,
02243                           <span class="keyword">sizeof</span>(msg_flags));
02244     DEBUGINDENTLESS();
02245     <span class="keywordflow">if</span> (cp == NULL)
02246         <span class="keywordflow">return</span> NULL;
02247 
02248     <span class="comment">/*</span>
02249 <span class="comment">     * msgSecurityModel </span>
02250 <span class="comment">     */</span>
02251     sec_model = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>;
02252     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgSecurityModel"</span>);
02253     cp = asn_build_int(cp, out_length,
02254                        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02255                                  ASN_INTEGER), &amp;sec_model,
02256                        <span class="keyword">sizeof</span>(sec_model));
02257     DEBUGINDENTADD(-4);         <span class="comment">/* return from global data indent */</span>
02258     <span class="keywordflow">if</span> (cp == NULL)
02259         <span class="keywordflow">return</span> NULL;
02260 
02261 
02262     <span class="comment">/*</span>
02263 <span class="comment">     * insert actual length of globalData</span>
02264 <span class="comment">     */</span>
02265     pb = asn_build_sequence(global_hdr, out_length,
02266                             (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
02267                             cp - global_hdr_e);
02268     <span class="keywordflow">if</span> (pb == NULL)
02269         <span class="keywordflow">return</span> NULL;
02270 
02271 
02272     <span class="comment">/*</span>
02273 <span class="comment">     * insert the actual length of the entire packet</span>
02274 <span class="comment">     */</span>
02275     pb = asn_build_sequence(packet, out_length,
02276                             (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
02277                             length + (cp - pb0e));
02278     <span class="keywordflow">if</span> (pb == NULL)
02279         <span class="keywordflow">return</span> NULL;
02280 
02281     <span class="keywordflow">return</span> cp;
02282 
02283 }                               <span class="comment">/* end snmpv3_header_build() */</span>
02284 
02285 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02286 
02287 <span class="keywordtype">int</span>
02288 snmpv3_header_realloc_rbuild(u_char ** pkt, size_t * pkt_len,
02289                              size_t * offset, netsnmp_session * session,
02290                              <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
02291 {
02292     size_t          start_offset = *offset;
02293     u_char          msg_flags;
02294     <span class="keywordtype">long</span>            max_size, sec_model;
02295     <span class="keywordtype">int</span>             rc = 0;
02296 
02297     <span class="comment">/*</span>
02298 <span class="comment">     * msgSecurityModel.  </span>
02299 <span class="comment">     */</span>
02300     sec_model = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>;
02301     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgSecurityModel"</span>);
02302     rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
02303                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02304                                           ASN_INTEGER), &amp;sec_model,
02305                                 <span class="keyword">sizeof</span>(sec_model));
02306     DEBUGINDENTLESS();
02307     <span class="keywordflow">if</span> (rc == 0) {
02308         <span class="keywordflow">return</span> 0;
02309     }
02310 
02311     <span class="comment">/*</span>
02312 <span class="comment">     * msgFlags.  </span>
02313 <span class="comment">     */</span>
02314     snmpv3_calc_msg_flags(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a>, pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o1">command</a>, &amp;msg_flags);
02315     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgFlags"</span>);
02316     rc = asn_realloc_rbuild_string(pkt, pkt_len, offset, 1,
02317                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
02318                                              | ASN_OCTET_STR), &amp;msg_flags,
02319                                    <span class="keyword">sizeof</span>(msg_flags));
02320     DEBUGINDENTLESS();
02321     <span class="keywordflow">if</span> (rc == 0) {
02322         <span class="keywordflow">return</span> 0;
02323     }
02324 
02325     <span class="comment">/*</span>
02326 <span class="comment">     * msgMaxSize.  </span>
02327 <span class="comment">     */</span>
02328     max_size = session-&gt;<a class="code" href="structsnmp__session.html#o18">rcvMsgMaxSize</a>;
02329     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgMaxSize"</span>);
02330     rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
02331                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02332                                           ASN_INTEGER), &amp;max_size,
02333                                 <span class="keyword">sizeof</span>(max_size));
02334     DEBUGINDENTLESS();
02335     <span class="keywordflow">if</span> (rc == 0) {
02336         <span class="keywordflow">return</span> 0;
02337     }
02338 
02339     <span class="comment">/*</span>
02340 <span class="comment">     * msgID.  </span>
02341 <span class="comment">     */</span>
02342     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgID"</span>);
02343     rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
02344                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02345                                           ASN_INTEGER), &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o3">msgid</a>,
02346                                 <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o3">msgid</a>));
02347     DEBUGINDENTLESS();
02348     <span class="keywordflow">if</span> (rc == 0) {
02349         <span class="keywordflow">return</span> 0;
02350     }
02351 
02352     <span class="comment">/*</span>
02353 <span class="comment">     * Global data sequence.  </span>
02354 <span class="comment">     */</span>
02355     rc = asn_realloc_rbuild_sequence(pkt, pkt_len, offset, 1,
02356                                      (u_char) (ASN_SEQUENCE |
02357                                                ASN_CONSTRUCTOR),
02358                                      *offset - start_offset);
02359     <span class="keywordflow">if</span> (rc == 0) {
02360         <span class="keywordflow">return</span> 0;
02361     }
02362 
02363     <span class="comment">/*</span>
02364 <span class="comment">     * Store the version field - msgVersion.  </span>
02365 <span class="comment">     */</span>
02366     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"SNMP Version Number"</span>);
02367     rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
02368                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02369                                           ASN_INTEGER),
02370                                 (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a>,
02371                                 <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a>));
02372     DEBUGINDENTLESS();
02373     <span class="keywordflow">return</span> rc;
02374 }                               <span class="comment">/* end snmpv3_header_realloc_rbuild() */</span>
02375 <span class="preprocessor">#endif                          </span><span class=
"comment">/* USE_REVERSE_ASNENCODING */</span>
02376 
02377 <span class="keyword">static</span> u_char  *
02378 snmpv3_scopedPDU_header_build(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
02379                               u_char * packet, size_t * out_length,
02380                               u_char ** spdu_e)
02381 {
02382     size_t          init_length;
02383     u_char         *scopedPdu, *pb;
02384 
02385 
02386     init_length = *out_length;
02387 
02388     pb = scopedPdu = packet;
02389     pb = asn_build_sequence(pb, out_length,
02390                             (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR), 0);
02391     <span class="keywordflow">if</span> (pb == NULL)
02392         <span class="keywordflow">return</span> NULL;
02393     <span class="keywordflow">if</span> (spdu_e)
02394         *spdu_e = pb;
02395 
02396     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"contextEngineID"</span>);
02397     pb = asn_build_string(pb, out_length,
02398                           (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR),
02399                           pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a>, pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>);
02400     DEBUGINDENTLESS();
02401     <span class="keywordflow">if</span> (pb == NULL)
02402         <span class="keywordflow">return</span> NULL;
02403 
02404     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"contextName"</span>);
02405     pb = asn_build_string(pb, out_length,
02406                           (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR),
02407                           (u_char *) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a>,
02408                           pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a>);
02409     DEBUGINDENTLESS();
02410     <span class="keywordflow">if</span> (pb == NULL)
02411         <span class="keywordflow">return</span> NULL;
02412 
02413     <span class="keywordflow">return</span> pb;
02414 
02415 }                               <span class="comment">/* end snmpv3_scopedPDU_header_build() */</span>
02416 
02417 
02418 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02419 <span class="keywordtype">int</span>
02420 snmpv3_scopedPDU_header_realloc_rbuild(u_char ** pkt, size_t * pkt_len,
02421                                        size_t * offset, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
02422                                        size_t body_len)
02423 {
02424     size_t          start_offset = *offset;
02425     <span class="keywordtype">int</span>             rc = 0;
02426 
02427     <span class="comment">/*</span>
02428 <span class="comment">     * contextName.  </span>
02429 <span class="comment">     */</span>
02430     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"contextName"</span>);
02431     rc = asn_realloc_rbuild_string(pkt, pkt_len, offset, 1,
02432                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
02433                                              | ASN_OCTET_STR),
02434                                    (u_char *) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a>,
02435                                    pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a>);
02436     DEBUGINDENTLESS();
02437     <span class="keywordflow">if</span> (rc == 0) {
02438         <span class="keywordflow">return</span> 0;
02439     }
02440 
02441     <span class="comment">/*</span>
02442 <span class="comment">     * contextEngineID.  </span>
02443 <span class="comment">     */</span>
02444     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"contextEngineID"</span>);
02445     rc = asn_realloc_rbuild_string(pkt, pkt_len, offset, 1,
02446                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
02447                                              | ASN_OCTET_STR),
02448                                    pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a>,
02449                                    pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>);
02450     DEBUGINDENTLESS();
02451     <span class="keywordflow">if</span> (rc == 0) {
02452         <span class="keywordflow">return</span> 0;
02453     }
02454 
02455     rc = asn_realloc_rbuild_sequence(pkt, pkt_len, offset, 1,
02456                                      (u_char) (ASN_SEQUENCE |
02457                                                ASN_CONSTRUCTOR),
02458                                      *offset - start_offset + body_len);
02459 
02460     <span class="keywordflow">return</span> rc;
02461 }                               <span class="comment">/* end snmpv3_scopedPDU_header_realloc_rbuild() */</span>
02462 <span class="preprocessor">#endif                          </span><span class=
"comment">/* USE_REVERSE_ASNENCODING */</span>
02463 
02464 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02465 <span class="comment">/*</span>
02466 <span class="comment"> * returns 0 if success, -1 if fail, not 0 if SM build failure </span>
02467 <span class="comment"> */</span>
02468 <span class="keywordtype">int</span>
02469 snmpv3_packet_realloc_rbuild(u_char ** pkt, size_t * pkt_len,
02470                              size_t * offset, netsnmp_session * session,
02471                              <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, u_char * pdu_data,
02472                              size_t pdu_data_len)
02473 {
02474     u_char         *scoped_pdu, *hdrbuf = NULL, *hdr = NULL;
02475     size_t          hdrbuf_len = SNMP_MAX_MSG_V3_HDRS, hdr_offset =
02476         0, spdu_offset = 0;
02477     size_t          body_end_offset = *offset, body_len = 0;
02478     <span class="keyword">struct </span>snmp_secmod_def *sptr = NULL;
02479     <span class="keywordtype">int</span>             rc = 0;
02480 
02481     <span class="comment">/*</span>
02482 <span class="comment">     * Build a scopedPDU structure into the packet buffer.  </span>
02483 <span class="comment">     */</span>
02484     DEBUGPRINTPDUTYPE(<span class="stringliteral">"send"</span>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a>);
02485     <span class="keywordflow">if</span> (pdu_data) {
02486         <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; pdu_data_len) {
02487             <span class="keywordflow">if</span> (!asn_realloc(pkt, pkt_len)) {
02488                 <span class="keywordflow">return</span> -1;
02489             }
02490         }
02491 
02492         *offset += pdu_data_len;
02493         memcpy(*pkt + *pkt_len - *offset, pdu_data, pdu_data_len);
02494     } <span class="keywordflow">else</span> {
02495         rc = snmp_pdu_realloc_rbuild(pkt, pkt_len, offset, pdu);
02496         <span class="keywordflow">if</span> (rc == 0) {
02497             <span class="keywordflow">return</span> -1;
02498         }
02499     }
02500     body_len = *offset - body_end_offset;
02501 
02502     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"ScopedPdu"</span>);
02503     rc = snmpv3_scopedPDU_header_realloc_rbuild(pkt, pkt_len, offset,
02504                                                 pdu, body_len);
02505     <span class="keywordflow">if</span> (rc == 0) {
02506         <span class="keywordflow">return</span> -1;
02507     }
02508     spdu_offset = *offset;
02509     DEBUGINDENTADD(-4);         <span class="comment">/*  Return from Scoped PDU.  */</span>
02510 
02511     <span class="keywordflow">if</span> ((hdrbuf = (u_char *) malloc(hdrbuf_len)) == NULL) {
02512         <span class="keywordflow">return</span> -1;
02513     }
02514 
02515     rc = snmpv3_header_realloc_rbuild(&amp;hdrbuf, &amp;hdrbuf_len, &amp;hdr_offset,
02516                                       session, pdu);
02517     <span class="keywordflow">if</span> (rc == 0) {
02518         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(hdrbuf);
02519         <span class="keywordflow">return</span> -1;
02520     }
02521     hdr = hdrbuf + hdrbuf_len - hdr_offset;
02522     scoped_pdu = *pkt + *pkt_len - spdu_offset;
02523 
02524     <span class="comment">/*</span>
02525 <span class="comment">     * Call the security module to possibly encrypt and authenticate the</span>
02526 <span class="comment">     * message---the entire message to transmitted on the wire is returned.  </span>
02527 <span class="comment">     */</span>
02528 
02529     sptr = find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
02530     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SM msgSecurityParameters"</span>);
02531     <span class="keywordflow">if</span> (sptr &amp;&amp; sptr-&gt;encode_reverse) {
02532         <span class="keyword">struct </span>snmp_secmod_outgoing_params parms;
02533 
02534         parms.msgProcModel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o12">msgParseModel</a>;
02535         parms.globalData = hdr;
02536         parms.globalDataLen = hdr_offset;
02537         parms.maxMsgSize = SNMP_MAX_MSG_SIZE;
02538         parms.secModel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>;
02539         parms.secEngineID = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>;
02540         parms.secEngineIDLen = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>;
02541         parms.secName = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a>;
02542         parms.secNameLen = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a>;
02543         parms.secLevel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a>;
02544         parms.scopedPdu = scoped_pdu;
02545         parms.scopedPduLen = spdu_offset;
02546         parms.secStateRef = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>;
02547         parms.wholeMsg = pkt;
02548         parms.wholeMsgLen = pkt_len;
02549         parms.wholeMsgOffset = offset;
02550         parms.session = session;
02551         parms.pdu = pdu;
02552 
02553         rc = (*sptr-&gt;encode_reverse) (&amp;parms);
02554     } <span class="keywordflow">else</span> {
02555         <span class="keywordflow">if</span> (!sptr) {
02556             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,
02557                      <span class="stringliteral">"no such security service available: %d\n"</span>,
02558                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
02559         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!sptr-&gt;encode_reverse) {
02560             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,
02561                      <span class="stringliteral">"security service %d doesn't support reverse encoding.\n"</span>,
02562                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
02563         }
02564         rc = -1;
02565     }
02566 
02567     DEBUGINDENTLESS();
02568     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(hdrbuf);
02569     <span class="keywordflow">return</span> rc;
02570 }                               <span class="comment">/* end snmpv3_packet_realloc_rbuild() */</span>
02571 <span class="preprocessor">#endif                          </span><span class=
"comment">/* USE_REVERSE_ASNENCODING */</span>
02572 
02573 <span class="comment">/*</span>
02574 <span class="comment"> * returns 0 if success, -1 if fail, not 0 if SM build failure </span>
02575 <span class="comment"> */</span>
02576 <span class="keywordtype">int</span>
02577 snmpv3_packet_build(netsnmp_session * session, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
02578                     u_char * packet, size_t * out_length,
02579                     u_char * pdu_data, size_t pdu_data_len)
02580 {
02581     u_char         *global_data, *sec_params, *spdu_hdr_e;
02582     size_t          global_data_len, sec_params_len;
02583     u_char          spdu_buf[SNMP_MAX_MSG_SIZE];
02584     size_t          spdu_buf_len, spdu_len;
02585     u_char         *cp;
02586     <span class="keywordtype">int</span>             result;
02587     <span class="keyword">struct </span>snmp_secmod_def *sptr;
02588 
02589     global_data = packet;
02590 
02591     <span class="comment">/*</span>
02592 <span class="comment">     * build the headers for the packet, returned addr = start of secParams</span>
02593 <span class="comment">     */</span>
02594     sec_params = snmpv3_header_build(session, pdu, global_data,
02595                                      out_length, 0, NULL);
02596     <span class="keywordflow">if</span> (sec_params == NULL)
02597         <span class="keywordflow">return</span> -1;
02598     global_data_len = sec_params - global_data;
02599     sec_params_len = *out_length;       <span class="comment">/* length left in packet buf for sec_params */</span>
02600 
02601 
02602     <span class="comment">/*</span>
02603 <span class="comment">     * build a scopedPDU structure into spdu_buf</span>
02604 <span class="comment">     */</span>
02605     spdu_buf_len = SNMP_MAX_MSG_SIZE;
02606     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"ScopedPdu"</span>);
02607     cp = snmpv3_scopedPDU_header_build(pdu, spdu_buf, &amp;spdu_buf_len,
02608                                        &amp;spdu_hdr_e);
02609     <span class="keywordflow">if</span> (cp == NULL)
02610         <span class="keywordflow">return</span> -1;
02611 
02612     <span class="comment">/*</span>
02613 <span class="comment">     * build the PDU structure onto the end of spdu_buf </span>
02614 <span class="comment">     */</span>
02615     DEBUGPRINTPDUTYPE(<span class="stringliteral">"send"</span>, ((pdu_data) ? *pdu_data : 0x00));
02616     <span class="keywordflow">if</span> (pdu_data) {
02617         memcpy(cp, pdu_data, pdu_data_len);
02618         cp += pdu_data_len;
02619     } <span class="keywordflow">else</span> {
02620         cp = snmp_pdu_build(pdu, cp, &amp;spdu_buf_len);
02621         <span class="keywordflow">if</span> (cp == NULL)
02622             <span class="keywordflow">return</span> -1;
02623     }
02624     DEBUGINDENTADD(-4);         <span class="comment">/* return from Scoped PDU */</span>
02625 
02626     <span class="comment">/*</span>
02627 <span class="comment">     * re-encode the actual ASN.1 length of the scopedPdu</span>
02628 <span class="comment">     */</span>
02629     spdu_len = cp - spdu_hdr_e; <span class="comment">/* length of scopedPdu minus ASN.1 headers */</span>
02630     spdu_buf_len = SNMP_MAX_MSG_SIZE;
02631     <span class="keywordflow">if</span> (asn_build_sequence(spdu_buf, &amp;spdu_buf_len,
02632                            (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
02633                            spdu_len) == NULL)
02634         <span class="keywordflow">return</span> -1;
02635     spdu_len = cp - spdu_buf;   <span class="comment">/* the length of the entire scopedPdu */</span>
02636 
02637 
02638     <span class="comment">/*</span>
02639 <span class="comment">     * call the security module to possibly encrypt and authenticate the</span>
02640 <span class="comment">     * message - the entire message to transmitted on the wire is returned</span>
02641 <span class="comment">     */</span>
02642     cp = NULL;
02643     *out_length = SNMP_MAX_MSG_SIZE;
02644     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SM msgSecurityParameters"</span>);
02645     sptr = find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
02646     <span class="keywordflow">if</span> (sptr &amp;&amp; sptr-&gt;encode_forward) {
02647         <span class="keyword">struct </span>snmp_secmod_outgoing_params parms;
02648         parms.msgProcModel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o12">msgParseModel</a>;
02649         parms.globalData = global_data;
02650         parms.globalDataLen = global_data_len;
02651         parms.maxMsgSize = SNMP_MAX_MSG_SIZE;
02652         parms.secModel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>;
02653         parms.secEngineID = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>;
02654         parms.secEngineIDLen = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>;
02655         parms.secName = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a>;
02656         parms.secNameLen = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a>;
02657         parms.secLevel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a>;
02658         parms.scopedPdu = spdu_buf;
02659         parms.scopedPduLen = spdu_len;
02660         parms.secStateRef = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>;
02661         parms.secParams = sec_params;
02662         parms.secParamsLen = &amp;sec_params_len;
02663         parms.wholeMsg = &amp;cp;
02664         parms.wholeMsgLen = out_length;
02665         parms.session = session;
02666         parms.pdu = pdu;
02667         result = (*sptr-&gt;encode_forward) (&amp;parms);
02668     } <span class="keywordflow">else</span> {
02669         <span class="keywordflow">if</span> (!sptr) {
02670             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"no such security service available: %d\n"</span>,
02671                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
02672         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!sptr-&gt;encode_forward) {
02673             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,
02674                      <span class="stringliteral">"security service %d doesn't support forward out encoding.\n"</span>,
02675                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
02676         }
02677         result = -1;
02678     }
02679     DEBUGINDENTLESS();
02680     <span class="keywordflow">return</span> result;
02681 
02682 }                               <span class="comment">/* end snmpv3_packet_build() */</span>
02683 
02684 
02685 <span class="comment">/*</span>
02686 <span class="comment"> * Takes a session and a pdu and serializes the ASN PDU into the area</span>
02687 <span class="comment"> * pointed to by *pkt.  *pkt_len is the size of the data area available.</span>
02688 <span class="comment"> * Returns the length of the completed packet in *offset.  If any errors</span>
02689 <span class="comment"> * occur, -1 is returned.  If all goes well, 0 is returned.</span>
02690 <span class="comment"> */</span>
02691 
02692 <span class="keyword">static</span> <span class="keywordtype">int</span>
02693 _snmp_build(u_char ** pkt, size_t * pkt_len, size_t * offset,
02694             netsnmp_session * session, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
02695 {
02696 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
02697     u_char         *h0e = 0;
02698     size_t          start_offset = *offset;
02699     <span class="keywordtype">long</span>            version;
02700     <span class="keywordtype">int</span>             rc = 0;
02701 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
02702     
02703     u_char         *h0, *h1;
02704     u_char         *cp;
02705     size_t          length;
02706 
02707     session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
02708     session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
02709 
02710     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_3) {
02711         <span class="keywordflow">return</span> snmpv3_build(pkt, pkt_len, offset, session, pdu);
02712     }
02713 
02714     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>) {
02715     <span class="keywordflow">case</span> SNMP_MSG_RESPONSE:
02716         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> &amp;= (~UCD_MSG_FLAG_EXPECT_RESPONSE);
02717         <span class="comment">/*</span>
02718 <span class="comment">         * Fallthrough </span>
02719 <span class="comment">         */</span>
02720     <span class="keywordflow">case</span> SNMP_MSG_GET:
02721     <span class="keywordflow">case</span> SNMP_MSG_GETNEXT:
02722     <span class="keywordflow">case</span> SNMP_MSG_SET:
02723         <span class="comment">/*</span>
02724 <span class="comment">         * all versions support these PDU types </span>
02725 <span class="comment">         */</span>
02726         <span class="comment">/*</span>
02727 <span class="comment">         * initialize defaulted PDU fields </span>
02728 <span class="comment">         */</span>
02729 
02730         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o6">errstat</a> == SNMP_DEFAULT_ERRSTAT)
02731             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a> = 0;
02732         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a> == SNMP_DEFAULT_ERRINDEX)
02733             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o7">errindex</a> = 0;
02734         <span class="keywordflow">break</span>;
02735 
02736     <span class="keywordflow">case</span> SNMP_MSG_TRAP2:
02737         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> &amp;= (~UCD_MSG_FLAG_EXPECT_RESPONSE);
02738         <span class="comment">/*</span>
02739 <span class="comment">         * Fallthrough </span>
02740 <span class="comment">         */</span>
02741     <span class="keywordflow">case</span> SNMP_MSG_INFORM:
02742 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
02743         <span class="comment">/*</span>
02744 <span class="comment">         * not supported in SNMPv1 and SNMPsec </span>
02745 <span class="comment">         */</span>
02746         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_1) {
02747             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_V2_IN_V1;
02748             <span class="keywordflow">return</span> -1;
02749         }
02750 <span class="preprocessor">#endif</span>
02751         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o6">errstat</a> == SNMP_DEFAULT_ERRSTAT)
02752             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a> = 0;
02753         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a> == SNMP_DEFAULT_ERRINDEX)
02754             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o7">errindex</a> = 0;
02755         <span class="keywordflow">break</span>;
02756 
02757     <span class="keywordflow">case</span> SNMP_MSG_GETBULK:
02758         <span class="comment">/*</span>
02759 <span class="comment">         * not supported in SNMPv1 and SNMPsec </span>
02760 <span class="comment">         */</span>
02761 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
02762         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_1) {
02763             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_V2_IN_V1;
02764             <span class="keywordflow">return</span> -1;
02765         }
02766 <span class="preprocessor">#endif</span>
02767         <span class="keywordflow">if</span> (pdu-&gt;max_repetitions &lt; 0) {
02768             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_REPETITIONS;
02769             <span class="keywordflow">return</span> -1;
02770         }
02771         <span class="keywordflow">if</span> (pdu-&gt;non_repeaters &lt; 0) {
02772             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_REPEATERS;
02773             <span class="keywordflow">return</span> -1;
02774         }
02775         <span class="keywordflow">break</span>;
02776 
02777     <span class="keywordflow">case</span> SNMP_MSG_TRAP:
02778         <span class="comment">/*</span>
02779 <span class="comment">         * *only* supported in SNMPv1 and SNMPsec </span>
02780 <span class="comment">         */</span>
02781 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
02782         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> != SNMP_VERSION_1) {
02783             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_V1_IN_V2;
02784             <span class="keywordflow">return</span> -1;
02785         }
02786 <span class="preprocessor">#endif</span>
02787         <span class="comment">/*</span>
02788 <span class="comment">         * initialize defaulted Trap PDU fields </span>
02789 <span class="comment">         */</span>
02790         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a> = 1;         <span class=
"comment">/* give a bogus non-error reqid for traps */</span>
02791         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o21">enterprise_length</a> == SNMP_DEFAULT_ENTERPRISE_LENGTH) {
02792             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a> = (oid *) malloc(<span class=
"keyword">sizeof</span>(DEFAULT_ENTERPRISE));
02793             <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o20">enterprise</a> == NULL) {
02794                 session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
02795                 <span class="keywordflow">return</span> -1;
02796             }
02797             memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>, DEFAULT_ENTERPRISE,
02798                     <span class="keyword">sizeof</span>(DEFAULT_ENTERPRISE));
02799             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> =
02800                 <span class="keyword">sizeof</span>(DEFAULT_ENTERPRISE) / <span class="keyword">sizeof</span>(oid);
02801         }
02802         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a> == SNMP_DEFAULT_TIME)
02803             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o8">time</a> = DEFAULT_TIME;
02804         <span class="comment">/*</span>
02805 <span class="comment">         * don't expect a response </span>
02806 <span class="comment">         */</span>
02807         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> &amp;= (~UCD_MSG_FLAG_EXPECT_RESPONSE);
02808         <span class="keywordflow">break</span>;
02809 
02810     <span class="keywordflow">case</span> SNMP_MSG_REPORT:      <span class="comment">/* SNMPv3 only */</span>
02811     <span class="keywordflow">default</span>:
02812         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_UNKNOWN_PDU;
02813         <span class="keywordflow">return</span> -1;
02814     }
02815 
02816     <span class="comment">/*</span>
02817 <span class="comment">     * save length </span>
02818 <span class="comment">     */</span>
02819     length = *pkt_len;
02820 
02821     <span class="comment">/*</span>
02822 <span class="comment">     * setup administrative fields based on version </span>
02823 <span class="comment">     */</span>
02824     <span class="comment">/*</span>
02825 <span class="comment">     * build the message wrapper and all the administrative fields</span>
02826 <span class="comment">     * upto the PDU sequence</span>
02827 <span class="comment">     * (note that actual length of message will be inserted later) </span>
02828 <span class="comment">     */</span>
02829     h0 = *pkt;
02830     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>) {
02831 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
02832     <span class="keywordflow">case</span> SNMP_VERSION_1:
02833 <span class="preprocessor">#endif</span>
02834 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
02835     <span class="keywordflow">case</span> SNMP_VERSION_2c:
02836 <span class="preprocessor">#endif</span>
02837 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
02838 <span class="preprocessor">#ifdef NO_ZEROLENGTH_COMMUNITY</span>
02839         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o19">community_len</a> == 0) {
02840             <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a> == 0) {
02841                 session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_COMMUNITY;
02842                 <span class="keywordflow">return</span> -1;
02843             }
02844             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a> = (u_char *) malloc(session-&gt;<a class=
"code" href="structsnmp__session.html#o17">community_len</a>);
02845             <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a> == NULL) {
02846                 session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
02847                 <span class="keywordflow">return</span> -1;
02848             }
02849             memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a>,
02850                     session-&gt;<a class="code" href="structsnmp__session.html#o16">community</a>, session-&gt;<a class=
"code" href="structsnmp__session.html#o17">community_len</a>);
02851             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>;
02852         }
02853 <span class="preprocessor">#else                           </span><span class=
"comment">/* !NO_ZEROLENGTH_COMMUNITY */</span>
02854         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o19">community_len</a> == 0 &amp;&amp; pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a> != SNMP_MSG_RESPONSE) {
02855             <span class="comment">/*</span>
02856 <span class="comment">             * copy session community exactly to pdu community </span>
02857 <span class="comment">             */</span>
02858             <span class="keywordflow">if</span> (0 == session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>) {
02859                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a>);
02860                 pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a> = NULL;
02861             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o19">community_len</a> == session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>) {
02862                 memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a>,
02863                         session-&gt;<a class="code" href=
"structsnmp__session.html#o16">community</a>, session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a>);
02864             } <span class="keywordflow">else</span> {
02865                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a>);
02866                 pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a> = (u_char *) malloc(session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>);
02867                 <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a> == NULL) {
02868                     session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
02869                     <span class="keywordflow">return</span> -1;
02870                 }
02871                 memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a>,
02872                         session-&gt;<a class="code" href=
"structsnmp__session.html#o16">community</a>, session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a>);
02873             }
02874             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>;
02875         }
02876 <span class="preprocessor">#endif                          </span><span class=
"comment">/* !NO_ZEROLENGTH_COMMUNITY */</span>
02877 
02878         DEBUGMSGTL((<span class="stringliteral">"snmp_send"</span>, <span class=
"stringliteral">"Building SNMPv%d message...\n"</span>,
02879                     (1 + pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>)));
02880 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02881         <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REVERSE_ENCODE)) {
02882             DEBUGPRINTPDUTYPE(<span class="stringliteral">"send"</span>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a>);
02883             rc = snmp_pdu_realloc_rbuild(pkt, pkt_len, offset, pdu);
02884             <span class="keywordflow">if</span> (rc == 0) {
02885                 <span class="keywordflow">return</span> -1;
02886             }
02887 
02888             DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"Community String"</span>);
02889             rc = asn_realloc_rbuild_string(pkt, pkt_len, offset, 1,
02890                                            (u_char) (ASN_UNIVERSAL |
02891                                                      ASN_PRIMITIVE |
02892                                                      ASN_OCTET_STR),
02893                                            pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a>,
02894                                            pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a>);
02895             DEBUGINDENTLESS();
02896             <span class="keywordflow">if</span> (rc == 0) {
02897                 <span class="keywordflow">return</span> -1;
02898             }
02899 
02900 
02901             <span class="comment">/*</span>
02902 <span class="comment">             * Store the version field.  </span>
02903 <span class="comment">             */</span>
02904             DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SNMP Version Number"</span>);
02905 
02906             version = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>;
02907             rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
02908                                         (u_char) (ASN_UNIVERSAL |
02909                                                   ASN_PRIMITIVE |
02910                                                   ASN_INTEGER),
02911                                         (<span class="keywordtype">long</span> *) &amp;version,
02912                                         <span class="keyword">sizeof</span>(version));
02913             DEBUGINDENTLESS();
02914             <span class="keywordflow">if</span> (rc == 0) {
02915                 <span class="keywordflow">return</span> -1;
02916             }
02917 
02918             <span class="comment">/*</span>
02919 <span class="comment">             * Build the final sequence.  </span>
02920 <span class="comment">             */</span>
02921             <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_1) {
02922                 DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SNMPv1 Message"</span>);
02923             } <span class="keywordflow">else</span> {
02924                 DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SNMPv2c Message"</span>);
02925             }
02926             rc = asn_realloc_rbuild_sequence(pkt, pkt_len, offset, 1,
02927                                              (u_char) (ASN_SEQUENCE |
02928                                                        ASN_CONSTRUCTOR),
02929                                              *offset - start_offset);
02930             DEBUGINDENTLESS();
02931 
02932             <span class="keywordflow">if</span> (rc == 0) {
02933                 <span class="keywordflow">return</span> -1;
02934             }
02935             <span class="keywordflow">return</span> 0;
02936         } <span class="keywordflow">else</span> {
02937 
02938 <span class="preprocessor">#endif                          </span><span class=
"comment">/* USE_REVERSE_ASNENCODING */</span>
02939             <span class="comment">/*</span>
02940 <span class="comment">             * Save current location and build SEQUENCE tag and length</span>
02941 <span class="comment">             * placeholder for SNMP message sequence</span>
02942 <span class="comment">             * (actual length will be inserted later) </span>
02943 <span class="comment">             */</span>
02944             cp = asn_build_sequence(*pkt, pkt_len,
02945                                     (u_char) (ASN_SEQUENCE |
02946                                               ASN_CONSTRUCTOR), 0);
02947             <span class="keywordflow">if</span> (cp == NULL) {
02948                 <span class="keywordflow">return</span> -1;
02949             }
02950             h0e = cp;
02951 
02952             <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_1) {
02953                 DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SNMPv1 Message"</span>);
02954             } <span class="keywordflow">else</span> {
02955                 DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SNMPv2c Message"</span>);
02956             }
02957 
02958             <span class="comment">/*</span>
02959 <span class="comment">             * store the version field </span>
02960 <span class="comment">             */</span>
02961             DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SNMP Version Number"</span>);
02962 
02963             version = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>;
02964             cp = asn_build_int(*pkt, pkt_len,
02965                                (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02966                                          ASN_INTEGER), (<span class="keywordtype">long</span> *) &amp;version,
02967                                <span class="keyword">sizeof</span>(version));
02968             DEBUGINDENTLESS();
02969             <span class="keywordflow">if</span> (cp == NULL)
02970                 <span class="keywordflow">return</span> -1;
02971 
02972             <span class="comment">/*</span>
02973 <span class="comment">             * store the community string </span>
02974 <span class="comment">             */</span>
02975             DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"Community String"</span>);
02976             cp = asn_build_string(*pkt, pkt_len,
02977                                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02978                                             ASN_OCTET_STR), pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a>,
02979                                   pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a>);
02980             DEBUGINDENTLESS();
02981             <span class="keywordflow">if</span> (cp == NULL)
02982                 <span class="keywordflow">return</span> -1;
02983             <span class="keywordflow">break</span>;
02984 
02985 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02986         }
02987 <span class="preprocessor">#endif                          </span><span class=
"comment">/* USE_REVERSE_ASNENCODING */</span>
02988         <span class="keywordflow">break</span>;
02989 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
02990     <span class="keywordflow">case</span> SNMP_VERSION_2p:
02991     <span class="keywordflow">case</span> SNMP_VERSION_sec:
02992     <span class="keywordflow">case</span> SNMP_VERSION_2u:
02993     <span class="keywordflow">case</span> SNMP_VERSION_2star:
02994     <span class="keywordflow">default</span>:
02995         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
02996         <span class="keywordflow">return</span> -1;
02997     }
02998 
02999     h1 = cp;
03000     DEBUGPRINTPDUTYPE(<span class="stringliteral">"send"</span>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a>);
03001     cp = snmp_pdu_build(pdu, cp, pkt_len);
03002     DEBUGINDENTADD(-4);         <span class="comment">/* return from entire v1/v2c message */</span>
03003     <span class="keywordflow">if</span> (cp == NULL)
03004         <span class="keywordflow">return</span> -1;
03005 
03006     <span class="comment">/*</span>
03007 <span class="comment">     * insert the actual length of the message sequence </span>
03008 <span class="comment">     */</span>
03009     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>) {
03010 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
03011     <span class="keywordflow">case</span> SNMP_VERSION_1:
03012 <span class="preprocessor">#endif</span>
03013 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
03014     <span class="keywordflow">case</span> SNMP_VERSION_2c:
03015 <span class="preprocessor">#endif</span>
03016 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
03017         asn_build_sequence(*pkt, &amp;length,
03018                            (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
03019                            cp - h0e);
03020         <span class="keywordflow">break</span>;
03021 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
03022 
03023     <span class="keywordflow">case</span> SNMP_VERSION_2p:
03024     <span class="keywordflow">case</span> SNMP_VERSION_sec:
03025     <span class="keywordflow">case</span> SNMP_VERSION_2u:
03026     <span class="keywordflow">case</span> SNMP_VERSION_2star:
03027     <span class="keywordflow">default</span>:
03028         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
03029         <span class="keywordflow">return</span> -1;
03030     }
03031     *pkt_len = cp - *pkt;
03032     <span class="keywordflow">return</span> 0;
03033 }
03034 
03035 <span class="keywordtype">int</span>
03036 snmp_build(u_char ** pkt, size_t * pkt_len, size_t * offset,
03037            netsnmp_session * pss, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
03038 {
03039     <span class="keywordtype">int</span>             rc;
03040     rc = _snmp_build(pkt, pkt_len, offset, pss, pdu);
03041     <span class="keywordflow">if</span> (rc) {
03042         <span class="keywordflow">if</span> (!pss-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a>) {
03043             pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_ASN1_BUILD;
03044         }
03045         SET_SNMP_ERROR(pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
03046         rc = -1;
03047     }
03048     <span class="keywordflow">return</span> rc;
03049 }
03050 
03051 <span class="comment">/*</span>
03052 <span class="comment"> * on error, returns NULL (likely an encoding problem). </span>
03053 <span class="comment"> */</span>
03054 u_char         *
03055 snmp_pdu_build(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, u_char * cp, size_t * out_length)
03056 {
03057     u_char         *h1, *h1e, *h2, *h2e;
03058     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vp;
03059     size_t          length;
03060 
03061     length = *out_length;
03062     <span class="comment">/*</span>
03063 <span class="comment">     * Save current location and build PDU tag and length placeholder</span>
03064 <span class="comment">     * (actual length will be inserted later) </span>
03065 <span class="comment">     */</span>
03066     h1 = cp;
03067     cp = asn_build_sequence(cp, out_length, (u_char) pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a>, 0);
03068     <span class="keywordflow">if</span> (cp == NULL)
03069         <span class="keywordflow">return</span> NULL;
03070     h1e = cp;
03071 
03072     <span class="comment">/*</span>
03073 <span class="comment">     * store fields in the PDU preceeding the variable-bindings sequence </span>
03074 <span class="comment">     */</span>
03075     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a> != SNMP_MSG_TRAP) {
03076         <span class="comment">/*</span>
03077 <span class="comment">         * PDU is not an SNMPv1 trap </span>
03078 <span class="comment">         */</span>
03079 
03080         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"request_id"</span>);
03081         <span class="comment">/*</span>
03082 <span class="comment">         * request id </span>
03083 <span class="comment">         */</span>
03084         cp = asn_build_int(cp, out_length,
03085                            (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03086                                      ASN_INTEGER), &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a>,
03087                            <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a>));
03088         DEBUGINDENTLESS();
03089         <span class="keywordflow">if</span> (cp == NULL)
03090             <span class="keywordflow">return</span> NULL;
03091 
03092         <span class="comment">/*</span>
03093 <span class="comment">         * error status (getbulk non-repeaters) </span>
03094 <span class="comment">         */</span>
03095         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"error status"</span>);
03096         cp = asn_build_int(cp, out_length,
03097                            (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03098                                      ASN_INTEGER), &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a>,
03099                            <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o6">errstat</a>));
03100         DEBUGINDENTLESS();
03101         <span class="keywordflow">if</span> (cp == NULL)
03102             <span class="keywordflow">return</span> NULL;
03103 
03104         <span class="comment">/*</span>
03105 <span class="comment">         * error index (getbulk max-repetitions) </span>
03106 <span class="comment">         */</span>
03107         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"error index"</span>);
03108         cp = asn_build_int(cp, out_length,
03109                            (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03110                                      ASN_INTEGER), &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a>,
03111                            <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a>));
03112         DEBUGINDENTLESS();
03113         <span class="keywordflow">if</span> (cp == NULL)
03114             <span class="keywordflow">return</span> NULL;
03115     } <span class="keywordflow">else</span> {
03116         <span class="comment">/*</span>
03117 <span class="comment">         * an SNMPv1 trap PDU </span>
03118 <span class="comment">         */</span>
03119 
03120         <span class="comment">/*</span>
03121 <span class="comment">         * enterprise </span>
03122 <span class="comment">         */</span>
03123         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"enterprise OBJID"</span>);
03124         cp = asn_build_objid(cp, out_length,
03125                              (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03126                                        ASN_OBJECT_ID),
03127                              (oid *) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>,
03128                              pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a>);
03129         DEBUGINDENTLESS();
03130         <span class="keywordflow">if</span> (cp == NULL)
03131             <span class="keywordflow">return</span> NULL;
03132 
03133         <span class="comment">/*</span>
03134 <span class="comment">         * agent-addr </span>
03135 <span class="comment">         */</span>
03136         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"agent Address"</span>);
03137         cp = asn_build_string(cp, out_length,
03138                               (u_char) (ASN_IPADDRESS | ASN_PRIMITIVE),
03139                               (u_char *) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>, 4);
03140         DEBUGINDENTLESS();
03141         <span class="keywordflow">if</span> (cp == NULL)
03142             <span class="keywordflow">return</span> NULL;
03143 
03144         <span class="comment">/*</span>
03145 <span class="comment">         * generic trap </span>
03146 <span class="comment">         */</span>
03147         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"generic trap number"</span>);
03148         cp = asn_build_int(cp, out_length,
03149                            (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03150                                      ASN_INTEGER),
03151                            (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a>,
03152                            <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a>));
03153         DEBUGINDENTLESS();
03154         <span class="keywordflow">if</span> (cp == NULL)
03155             <span class="keywordflow">return</span> NULL;
03156 
03157         <span class="comment">/*</span>
03158 <span class="comment">         * specific trap </span>
03159 <span class="comment">         */</span>
03160         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"specific trap number"</span>);
03161         cp = asn_build_int(cp, out_length,
03162                            (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03163                                      ASN_INTEGER),
03164                            (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>,
03165                            <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>));
03166         DEBUGINDENTLESS();
03167         <span class="keywordflow">if</span> (cp == NULL)
03168             <span class="keywordflow">return</span> NULL;
03169 
03170         <span class="comment">/*</span>
03171 <span class="comment">         * timestamp  </span>
03172 <span class="comment">         */</span>
03173         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"timestamp"</span>);
03174         cp = asn_build_unsigned_int(cp, out_length,
03175                                     (u_char) (ASN_TIMETICKS |
03176                                               ASN_PRIMITIVE), &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a>,
03177                                     <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a>));
03178         DEBUGINDENTLESS();
03179         <span class="keywordflow">if</span> (cp == NULL)
03180             <span class="keywordflow">return</span> NULL;
03181     }
03182 
03183     <span class="comment">/*</span>
03184 <span class="comment">     * Save current location and build SEQUENCE tag and length placeholder</span>
03185 <span class="comment">     * for variable-bindings sequence</span>
03186 <span class="comment">     * (actual length will be inserted later) </span>
03187 <span class="comment">     */</span>
03188     h2 = cp;
03189     cp = asn_build_sequence(cp, out_length,
03190                             (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR), 0);
03191     <span class="keywordflow">if</span> (cp == NULL)
03192         <span class="keywordflow">return</span> NULL;
03193     h2e = cp;
03194 
03195     <span class="comment">/*</span>
03196 <span class="comment">     * Store variable-bindings </span>
03197 <span class="comment">     */</span>
03198     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"VarBindList"</span>);
03199     <span class="keywordflow">for</span> (vp = pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>; vp; vp = vp-&gt;<a class="code" href=
"structvariable__list.html#o0">next_variable</a>) {
03200         DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"VarBind"</span>);
03201         cp = snmp_build_var_op(cp, vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a>, vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
03202                                vp-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>, (u_char *) vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string,
03203                                out_length);
03204         DEBUGINDENTLESS();
03205         <span class="keywordflow">if</span> (cp == NULL)
03206             <span class="keywordflow">return</span> NULL;
03207     }
03208     DEBUGINDENTLESS();
03209 
03210     <span class="comment">/*</span>
03211 <span class="comment">     * insert actual length of variable-bindings sequence </span>
03212 <span class="comment">     */</span>
03213     asn_build_sequence(h2, &amp;length,
03214                        (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
03215                        cp - h2e);
03216 
03217     <span class="comment">/*</span>
03218 <span class="comment">     * insert actual length of PDU sequence </span>
03219 <span class="comment">     */</span>
03220     asn_build_sequence(h1, &amp;length, (u_char) pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a>, cp - h1e);
03221 
03222     <span class="keywordflow">return</span> cp;
03223 }
03224 
03225 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
03226 <span class="comment">/*</span>
03227 <span class="comment"> * On error, returns 0 (likely an encoding problem).  </span>
03228 <span class="comment"> */</span>
03229 <span class="keywordtype">int</span>
03230 snmp_pdu_realloc_rbuild(u_char ** pkt, size_t * pkt_len, size_t * offset,
03231                         <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
03232 {
03233 <span class="preprocessor">#ifndef VPCACHE_SIZE</span>
03234 <span class="preprocessor">#define VPCACHE_SIZE 50</span>
03235 <span class="preprocessor">#endif</span>
03236     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vpcache[VPCACHE_SIZE];
03237     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vp, *tmpvp;
03238     size_t          start_offset = *offset;
03239     <span class="keywordtype">int</span>             i, wrapped = 0, notdone, <span class="keyword">final</span>, rc = 0;
03240 
03241     DEBUGMSGTL((<span class="stringliteral">"snmp_pdu_realloc_rbuild"</span>, <span class=
"stringliteral">"starting\n"</span>));
03242     <span class="keywordflow">for</span> (vp = pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>, i = VPCACHE_SIZE - 1; vp;
03243          vp = vp-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>, i--) {
03244         <span class="keywordflow">if</span> (i &lt; 0) {
03245             wrapped = notdone = 1;
03246             i = VPCACHE_SIZE - 1;
03247             DEBUGMSGTL((<span class="stringliteral">"snmp_pdu_realloc_rbuild"</span>, <span class=
"stringliteral">"wrapped\n"</span>));
03248         }
03249         vpcache[i] = vp;
03250     }
03251     <span class="keyword">final</span> = i + 1;
03252 
03253     <span class="keywordflow">do</span> {
03254         <span class="keywordflow">for</span> (i = <span class="keyword">final</span>; i &lt; VPCACHE_SIZE; i++) {
03255             vp = vpcache[i];
03256             DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"VarBind"</span>);
03257             rc = snmp_realloc_rbuild_var_op(pkt, pkt_len, offset, 1,
03258                                             vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>,
03259                                             vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
03260                                             (u_char *) vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string,
03261                                             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
03262             DEBUGINDENTLESS();
03263             <span class="keywordflow">if</span> (rc == 0) {
03264                 <span class="keywordflow">return</span> 0;
03265             }
03266         }
03267 
03268         DEBUGINDENTLESS();
03269         <span class="keywordflow">if</span> (wrapped) {
03270             notdone = 1;
03271             <span class="keywordflow">for</span> (i = 0; i &lt; <span class="keyword">final</span>; i++) {
03272                 vp = vpcache[i];
03273                 DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"VarBind"</span>);
03274                 rc = snmp_realloc_rbuild_var_op(pkt, pkt_len, offset, 1,
03275                                                 vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>,
03276                                                 vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
03277                                                 (u_char *) vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string,
03278                                                 vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
03279                 DEBUGINDENTLESS();
03280                 <span class="keywordflow">if</span> (rc == 0) {
03281                     <span class="keywordflow">return</span> 0;
03282                 }
03283             }
03284 
03285             <span class="keywordflow">if</span> (<span class="keyword">final</span> == 0) {
03286                 tmpvp = vpcache[VPCACHE_SIZE - 1];
03287             } <span class="keywordflow">else</span> {
03288                 tmpvp = vpcache[<span class="keyword">final</span> - 1];
03289             }
03290             wrapped = 0;
03291 
03292             <span class="keywordflow">for</span> (vp = pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>, i = VPCACHE_SIZE - 1;
03293                  vp &amp;&amp; vp != tmpvp; vp = vp-&gt;<a class="code" href=
"structvariable__list.html#o0">next_variable</a>, i--) {
03294                 <span class="keywordflow">if</span> (i &lt; 0) {
03295                     wrapped = 1;
03296                     i = VPCACHE_SIZE - 1;
03297                     DEBUGMSGTL((<span class="stringliteral">"snmp_pdu_realloc_rbuild"</span>, <span class=
"stringliteral">"wrapped\n"</span>));
03298                 }
03299                 vpcache[i] = vp;
03300             }
03301             <span class="keyword">final</span> = i + 1;
03302         } <span class="keywordflow">else</span> {
03303             notdone = 0;
03304         }
03305     } <span class="keywordflow">while</span> (notdone);
03306 
03307     <span class="comment">/*</span>
03308 <span class="comment">     * Save current location and build SEQUENCE tag and length placeholder for</span>
03309 <span class="comment">     * variable-bindings sequence (actual length will be inserted later).  </span>
03310 <span class="comment">     */</span>
03311 
03312     rc = asn_realloc_rbuild_sequence(pkt, pkt_len, offset, 1,
03313                                      (u_char) (ASN_SEQUENCE |
03314                                                ASN_CONSTRUCTOR),
03315                                      *offset - start_offset);
03316 
03317     <span class="comment">/*</span>
03318 <span class="comment">     * Store fields in the PDU preceeding the variable-bindings sequence.  </span>
03319 <span class="comment">     */</span>
03320     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a> != SNMP_MSG_TRAP) {
03321         <span class="comment">/*</span>
03322 <span class="comment">         * Error index (getbulk max-repetitions).  </span>
03323 <span class="comment">         */</span>
03324         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"error index"</span>);
03325         rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
03326                                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
03327                                               | ASN_INTEGER),
03328                                     &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o7">errindex</a>, <span class=
"keyword">sizeof</span>(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o7">errindex</a>));
03329         DEBUGINDENTLESS();
03330         <span class="keywordflow">if</span> (rc == 0) {
03331             <span class="keywordflow">return</span> 0;
03332         }
03333 
03334         <span class="comment">/*</span>
03335 <span class="comment">         * Error status (getbulk non-repeaters).  </span>
03336 <span class="comment">         */</span>
03337         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"error status"</span>);
03338         rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
03339                                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
03340                                               | ASN_INTEGER),
03341                                     &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a>, <span class=
"keyword">sizeof</span>(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a>));
03342         DEBUGINDENTLESS();
03343         <span class="keywordflow">if</span> (rc == 0) {
03344             <span class="keywordflow">return</span> 0;
03345         }
03346 
03347         <span class="comment">/*</span>
03348 <span class="comment">         * Request ID.  </span>
03349 <span class="comment">         */</span>
03350         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"request_id"</span>);
03351         rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
03352                                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
03353                                               | ASN_INTEGER), &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a>,
03354                                     <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a>));
03355         DEBUGINDENTLESS();
03356         <span class="keywordflow">if</span> (rc == 0) {
03357             <span class="keywordflow">return</span> 0;
03358         }
03359     } <span class="keywordflow">else</span> {
03360         <span class="comment">/*</span>
03361 <span class="comment">         * An SNMPv1 trap PDU.  </span>
03362 <span class="comment">         */</span>
03363 
03364         <span class="comment">/*</span>
03365 <span class="comment">         * Timestamp.  </span>
03366 <span class="comment">         */</span>
03367         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"timestamp"</span>);
03368         rc = asn_realloc_rbuild_unsigned_int(pkt, pkt_len, offset, 1,
03369                                              (u_char) (ASN_TIMETICKS |
03370                                                        ASN_PRIMITIVE),
03371                                              &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o8">time</a>,
03372                                              <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a>));
03373         DEBUGINDENTLESS();
03374         <span class="keywordflow">if</span> (rc == 0) {
03375             <span class="keywordflow">return</span> 0;
03376         }
03377 
03378         <span class="comment">/*</span>
03379 <span class="comment">         * Specific trap.  </span>
03380 <span class="comment">         */</span>
03381         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"specific trap number"</span>);
03382         rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
03383                                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
03384                                               | ASN_INTEGER),
03385                                     (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>,
03386                                     <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>));
03387         DEBUGINDENTLESS();
03388         <span class="keywordflow">if</span> (rc == 0) {
03389             <span class="keywordflow">return</span> 0;
03390         }
03391 
03392         <span class="comment">/*</span>
03393 <span class="comment">         * Generic trap.  </span>
03394 <span class="comment">         */</span>
03395         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"generic trap number"</span>);
03396         rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
03397                                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
03398                                               | ASN_INTEGER),
03399                                     (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a>,
03400                                     <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a>));
03401         DEBUGINDENTLESS();
03402         <span class="keywordflow">if</span> (rc == 0) {
03403             <span class="keywordflow">return</span> 0;
03404         }
03405 
03406         <span class="comment">/*</span>
03407 <span class="comment">         * Agent-addr.  </span>
03408 <span class="comment">         */</span>
03409         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"agent Address"</span>);
03410         rc = asn_realloc_rbuild_string(pkt, pkt_len, offset, 1,
03411                                        (u_char) (ASN_IPADDRESS |
03412                                                  ASN_PRIMITIVE),
03413                                        (u_char *) pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o24">agent_addr</a>, 4);
03414         DEBUGINDENTLESS();
03415         <span class="keywordflow">if</span> (rc == 0) {
03416             <span class="keywordflow">return</span> 0;
03417         }
03418 
03419         <span class="comment">/*</span>
03420 <span class="comment">         * Enterprise.  </span>
03421 <span class="comment">         */</span>
03422         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"enterprise OBJID"</span>);
03423         rc = asn_realloc_rbuild_objid(pkt, pkt_len, offset, 1,
03424                                       (u_char) (ASN_UNIVERSAL |
03425                                                 ASN_PRIMITIVE |
03426                                                 ASN_OBJECT_ID),
03427                                       (oid *) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>,
03428                                       pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a>);
03429         DEBUGINDENTLESS();
03430         <span class="keywordflow">if</span> (rc == 0) {
03431             <span class="keywordflow">return</span> 0;
03432         }
03433     }
03434 
03435     <span class="comment">/*</span>
03436 <span class="comment">     * Build the PDU sequence.  </span>
03437 <span class="comment">     */</span>
03438     rc = asn_realloc_rbuild_sequence(pkt, pkt_len, offset, 1,
03439                                      (u_char) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>,
03440                                      *offset - start_offset);
03441     <span class="keywordflow">return</span> rc;
03442 }
03443 <span class="preprocessor">#endif                          </span><span class=
"comment">/* USE_REVERSE_ASNENCODING */</span>
03444 
03445 <span class="comment">/*</span>
03446 <span class="comment"> * Parses the packet received to determine version, either directly</span>
03447 <span class="comment"> * from packets version field or inferred from ASN.1 construct.</span>
03448 <span class="comment"> */</span>
03449 <span class="keyword">static</span> <span class="keywordtype">int</span>
03450 snmp_parse_version(u_char * data, size_t length)
03451 {
03452     u_char          type;
03453     <span class="keywordtype">long</span>            version = SNMPERR_BAD_VERSION;
03454 
03455     data = asn_parse_sequence(data, &amp;length, &amp;type,
03456                               (ASN_SEQUENCE | ASN_CONSTRUCTOR), <span class="stringliteral">"version"</span>);
03457     <span class="keywordflow">if</span> (data) {
03458         data =
03459             asn_parse_int(data, &amp;length, &amp;type, &amp;version, <span class="keyword">sizeof</span>(version));
03460         <span class="keywordflow">if</span> (!data || type != ASN_INTEGER) {
03461             <span class="keywordflow">return</span> SNMPERR_BAD_VERSION;
03462         }
03463     }
03464     <span class="keywordflow">return</span> version;
03465 }
03466 
03467 
03468 <span class="keywordtype">int</span>
03469 snmpv3_parse(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
03470              u_char * data,
03471              size_t * length,
03472              u_char ** after_header, netsnmp_session * sess)
03473 {
03474     u_char          type, msg_flags;
03475     <span class="keywordtype">long</span>            ver, msg_max_size, msg_sec_model;
03476     size_t          max_size_response;
03477     u_char          tmp_buf[SNMP_MAX_MSG_SIZE];
03478     size_t          tmp_buf_len;
03479     u_char          pdu_buf[SNMP_MAX_MSG_SIZE];
03480     u_char         *mallocbuf = NULL;
03481     size_t          pdu_buf_len = SNMP_MAX_MSG_SIZE;
03482     u_char         *sec_params;
03483     u_char         *msg_data;
03484     u_char         *cp;
03485     size_t          asn_len, msg_len;
03486     <span class="keywordtype">int</span>             ret, ret_val;
03487     <span class="keyword">struct </span>snmp_secmod_def *sptr;
03488 
03489 
03490     msg_data = data;
03491     msg_len = *length;
03492 
03493 
03494     <span class="comment">/*</span>
03495 <span class="comment">     * message is an ASN.1 SEQUENCE  </span>
03496 <span class="comment">     */</span>
03497     DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"SNMPv3 Message"</span>);
03498     data = asn_parse_sequence(data, length, &amp;type,
03499                               (ASN_SEQUENCE | ASN_CONSTRUCTOR), <span class="stringliteral">"message"</span>);
03500     <span class="keywordflow">if</span> (data == NULL) {
03501         <span class="comment">/*</span>
03502 <span class="comment">         * error msg detail is set </span>
03503 <span class="comment">         */</span>
03504         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03505         DEBUGINDENTLESS();
03506         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03507     }
03508 
03509     <span class="comment">/*</span>
03510 <span class="comment">     * parse msgVersion  </span>
03511 <span class="comment">     */</span>
03512     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"SNMP Version Number"</span>);
03513     data = asn_parse_int(data, length, &amp;type, &amp;ver, <span class="keyword">sizeof</span>(ver));
03514     DEBUGINDENTLESS();
03515     <span class="keywordflow">if</span> (data == NULL) {
03516         ERROR_MSG(<span class="stringliteral">"bad parse of version"</span>);
03517         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03518         DEBUGINDENTLESS();
03519         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03520     }
03521     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a> = ver;
03522 
03523     <span class="comment">/*</span>
03524 <span class="comment">     * parse msgGlobalData sequence  </span>
03525 <span class="comment">     */</span>
03526     cp = data;
03527     asn_len = *length;
03528     DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"msgGlobalData"</span>);
03529     data = asn_parse_sequence(data, &amp;asn_len, &amp;type,
03530                               (ASN_SEQUENCE | ASN_CONSTRUCTOR),
03531                               <span class="stringliteral">"msgGlobalData"</span>);
03532     <span class="keywordflow">if</span> (data == NULL) {
03533         <span class="comment">/*</span>
03534 <span class="comment">         * error msg detail is set </span>
03535 <span class="comment">         */</span>
03536         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03537         DEBUGINDENTADD(-4);
03538         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03539     }
03540     *length -= data - cp;       <span class="comment">/* subtract off the length of the header */</span>
03541 
03542     <span class="comment">/*</span>
03543 <span class="comment">     * msgID </span>
03544 <span class="comment">     */</span>
03545     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"msgID"</span>);
03546     data =
03547         asn_parse_int(data, length, &amp;type, &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a>,
03548                       <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o3">msgid</a>));
03549     DEBUGINDENTLESS();
03550     <span class="keywordflow">if</span> (data == NULL || type != ASN_INTEGER) {
03551         ERROR_MSG(<span class="stringliteral">"error parsing msgID"</span>);
03552         DEBUGINDENTADD(-4);
03553         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03554         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03555     }
03556 
03557     <span class="comment">/*</span>
03558 <span class="comment">     * Check the msgID we received is a legal value.  If not, then increment</span>
03559 <span class="comment">     * snmpInASNParseErrs and return the appropriate error (see RFC 2572,</span>
03560 <span class="comment">     * para. 7.2, section 2 -- note that a bad msgID means that the received</span>
03561 <span class="comment">     * message is NOT a serialiization of an SNMPv3Message, since the msgID</span>
03562 <span class="comment">     * field is out of bounds).  </span>
03563 <span class="comment">     */</span>
03564 
03565     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o3">msgid</a> &lt; 0 || pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a> &gt; 0x7fffffff) {
03566         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Received bad msgID (%ld %s %s).\n"</span>, pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a>,
03567                  (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a> &lt; 0) ? <span class=
"stringliteral">"&lt;"</span> : <span class="stringliteral">"&gt;"</span>,
03568                  (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a> &lt; 0) ? <span class=
"stringliteral">"0"</span> : <span class="stringliteral">"2^31 - 1"</span>);
03569         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03570         DEBUGINDENTADD(-4);
03571         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03572     }
03573 
03574     <span class="comment">/*</span>
03575 <span class="comment">     * msgMaxSize </span>
03576 <span class="comment">     */</span>
03577     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"msgMaxSize"</span>);
03578     data = asn_parse_int(data, length, &amp;type, &amp;msg_max_size,
03579                          <span class="keyword">sizeof</span>(msg_max_size));
03580     DEBUGINDENTLESS();
03581     <span class="keywordflow">if</span> (data == NULL || type != ASN_INTEGER) {
03582         ERROR_MSG(<span class="stringliteral">"error parsing msgMaxSize"</span>);
03583         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03584         DEBUGINDENTADD(-4);
03585         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03586     }
03587 
03588     <span class="comment">/*</span>
03589 <span class="comment">     * Check the msgMaxSize we received is a legal value.  If not, then</span>
03590 <span class="comment">     * increment snmpInASNParseErrs and return the appropriate error (see RFC</span>
03591 <span class="comment">     * 2572, para. 7.2, section 2 -- note that a bad msgMaxSize means that the</span>
03592 <span class="comment">     * received message is NOT a serialiization of an SNMPv3Message, since the</span>
03593 <span class="comment">     * msgMaxSize field is out of bounds).</span>
03594 <span class="comment">     * </span>
03595 <span class="comment">     * Note we store the msgMaxSize on a per-session basis which also seems</span>
03596 <span class="comment">     * reasonable; it could vary from PDU to PDU but that would be strange</span>
03597 <span class="comment">     * (also since we deal with a PDU at a time, it wouldn't make any</span>
03598 <span class="comment">     * difference to our responses, if any).  </span>
03599 <span class="comment">     */</span>
03600 
03601     <span class="keywordflow">if</span> (msg_max_size &lt; 484) {
03602         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Received bad msgMaxSize (%lu &lt; 484).\n"</span>,
03603                  msg_max_size);
03604         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03605         DEBUGINDENTADD(-4);
03606         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03607     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg_max_size &gt; 0x7fffffff) {
03608         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Received bad msgMaxSize (%lu &gt; 2^31 - 1).\n"</span>,
03609                  msg_max_size);
03610         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03611         DEBUGINDENTADD(-4);
03612         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03613     } <span class="keywordflow">else</span> {
03614         DEBUGMSGTL((<span class="stringliteral">"snmpv3_parse"</span>, <span class=
"stringliteral">"msgMaxSize %lu received\n"</span>,
03615                     msg_max_size));
03616         sess-&gt;<a class="code" href="structsnmp__session.html#o19">sndMsgMaxSize</a> = msg_max_size;
03617     }
03618 
03619     <span class="comment">/*</span>
03620 <span class="comment">     * msgFlags </span>
03621 <span class="comment">     */</span>
03622     tmp_buf_len = SNMP_MAX_MSG_SIZE;
03623     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"msgFlags"</span>);
03624     data = asn_parse_string(data, length, &amp;type, tmp_buf, &amp;tmp_buf_len);
03625     DEBUGINDENTLESS();
03626     <span class="keywordflow">if</span> (data == NULL || type != ASN_OCTET_STR || tmp_buf_len != 1) {
03627         ERROR_MSG(<span class="stringliteral">"error parsing msgFlags"</span>);
03628         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03629         DEBUGINDENTADD(-4);
03630         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03631     }
03632     msg_flags = *tmp_buf;
03633     <span class="keywordflow">if</span> (msg_flags &amp; SNMP_MSG_FLAG_RPRT_BIT)
03634         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> |= SNMP_MSG_FLAG_RPRT_BIT;
03635     <span class="keywordflow">else</span>
03636         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> &amp;= (~SNMP_MSG_FLAG_RPRT_BIT);
03637 
03638     <span class="comment">/*</span>
03639 <span class="comment">     * msgSecurityModel </span>
03640 <span class="comment">     */</span>
03641     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"msgSecurityModel"</span>);
03642     data = asn_parse_int(data, length, &amp;type, &amp;msg_sec_model,
03643                          <span class="keyword">sizeof</span>(msg_sec_model));
03644     DEBUGINDENTADD(-4);         <span class="comment">/* return from global data indent */</span>
03645     <span class="keywordflow">if</span> (data == NULL || type != ASN_INTEGER ||
03646         msg_sec_model &lt; 1 || msg_sec_model &gt; 0x7fffffff) {
03647         ERROR_MSG(<span class="stringliteral">"error parsing msgSecurityModel"</span>);
03648         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03649         DEBUGINDENTLESS();
03650         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03651     }
03652     sptr = find_sec_mod(msg_sec_model);
03653     <span class="keywordflow">if</span> (!sptr) {
03654         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING, <span class=
"stringliteral">"unknown security model: %d\n"</span>,
03655                  msg_sec_model);
03656         snmp_increment_statistic(STAT_SNMPUNKNOWNSECURITYMODELS);
03657         DEBUGINDENTLESS();
03658         <span class="keywordflow">return</span> SNMPERR_UNKNOWN_SEC_MODEL;
03659     }
03660     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a> = msg_sec_model;
03661 
03662     <span class="keywordflow">if</span> (msg_flags &amp; SNMP_MSG_FLAG_PRIV_BIT &amp;&amp;
03663         !(msg_flags &amp; SNMP_MSG_FLAG_AUTH_BIT)) {
03664         ERROR_MSG(<span class="stringliteral">"invalid message, illegal msgFlags"</span>);
03665         snmp_increment_statistic(STAT_SNMPINVALIDMSGS);
03666         DEBUGINDENTLESS();
03667         <span class="keywordflow">return</span> SNMPERR_INVALID_MSG;
03668     }
03669     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> = ((msg_flags &amp; SNMP_MSG_FLAG_AUTH_BIT)
03670                           ? ((msg_flags &amp; SNMP_MSG_FLAG_PRIV_BIT)
03671                              ? SNMP_SEC_LEVEL_AUTHPRIV
03672                              : SNMP_SEC_LEVEL_AUTHNOPRIV)
03673                           : SNMP_SEC_LEVEL_NOAUTH);
03674     <span class="comment">/*</span>
03675 <span class="comment">     * end of msgGlobalData </span>
03676 <span class="comment">     */</span>
03677 
03678     <span class="comment">/*</span>
03679 <span class="comment">     * securtityParameters OCTET STRING begins after msgGlobalData </span>
03680 <span class="comment">     */</span>
03681     sec_params = data;
03682     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a> = (u_char *) calloc(1, SNMP_MAX_ENG_SIZE);
03683     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a> = SNMP_MAX_ENG_SIZE;
03684 
03685     <span class="comment">/*</span>
03686 <span class="comment">     * Note: there is no length limit on the msgAuthoritativeEngineID field,</span>
03687 <span class="comment">     * although we would EXPECT it to be limited to 32 (the SnmpEngineID TC</span>
03688 <span class="comment">     * limit).  We'll use double that here to be on the safe side.  </span>
03689 <span class="comment">     */</span>
03690 
03691     pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o29">securityEngineID</a> = (u_char *) calloc(1, SNMP_MAX_ENG_SIZE * 2);
03692     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a> = SNMP_MAX_ENG_SIZE * 2;
03693     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a> = (<span class=
"keywordtype">char</span> *) calloc(1, SNMP_MAX_SEC_NAME_SIZE);
03694     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a> = SNMP_MAX_SEC_NAME_SIZE;
03695 
03696     <span class="keywordflow">if</span> ((pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o31">securityName</a> == NULL) ||
03697         (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a> == NULL) ||
03698         (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a> == NULL)) {
03699         <span class="keywordflow">return</span> SNMPERR_MALLOC;
03700     }
03701 
03702     <span class="keywordflow">if</span> (pdu_buf_len &lt; msg_len
03703         &amp;&amp; pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> == SNMP_SEC_LEVEL_AUTHPRIV) {
03704         <span class="comment">/*</span>
03705 <span class="comment">         * space needed is larger than we have in the default buffer </span>
03706 <span class="comment">         */</span>
03707         mallocbuf = (u_char *) calloc(1, msg_len);
03708         pdu_buf_len = msg_len;
03709         cp = mallocbuf;
03710     } <span class="keywordflow">else</span> {
03711         memset(pdu_buf, 0, pdu_buf_len);
03712         cp = pdu_buf;
03713     }
03714 
03715     DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"SM msgSecurityParameters"</span>);
03716     <span class="keywordflow">if</span> (sptr-&gt;decode) {
03717         <span class="keyword">struct </span>snmp_secmod_incoming_params parms;
03718         parms.msgProcModel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o12">msgParseModel</a>;
03719         parms.maxMsgSize = msg_max_size;
03720         parms.secParams = sec_params;
03721         parms.secModel = msg_sec_model;
03722         parms.secLevel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a>;
03723         parms.wholeMsg = msg_data;
03724         parms.wholeMsgLen = msg_len;
03725         parms.secEngineID = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>;
03726         parms.secEngineIDLen = &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>;
03727         parms.secName = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a>;
03728         parms.secNameLen = &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a>;
03729         parms.scopedPdu = &amp;cp;
03730         parms.scopedPduLen = &amp;pdu_buf_len;
03731         parms.maxSizeResponse = &amp;max_size_response;
03732         parms.secStateRef = &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>;
03733         parms.sess = sess;
03734         parms.pdu = pdu;
03735         parms.msg_flags = msg_flags;
03736         ret_val = (*sptr-&gt;decode) (&amp;parms);
03737     } <span class="keywordflow">else</span> {
03738         DEBUGINDENTLESS();
03739         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING, <span class=
"stringliteral">"security service %d can't decode packets\n"</span>,
03740                  msg_sec_model);
03741         <span class="keywordflow">return</span> (-1);
03742     }
03743 
03744     <span class="keywordflow">if</span> (ret_val != SNMPERR_SUCCESS) {
03745         DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"ScopedPDU"</span>);
03746         <span class="comment">/*</span>
03747 <span class="comment">         * Parse as much as possible -- though I don't see the point? [jbpn].  </span>
03748 <span class="comment">         */</span>
03749         <span class="keywordflow">if</span> (cp) {
03750             cp = snmpv3_scopedPDU_parse(pdu, cp, &amp;pdu_buf_len);
03751         }
03752         <span class="keywordflow">if</span> (cp) {
03753             DEBUGPRINTPDUTYPE(<span class="stringliteral">"recv"</span>, *cp);
03754             snmp_pdu_parse(pdu, cp, &amp;pdu_buf_len);
03755             DEBUGINDENTADD(-8);
03756         } <span class="keywordflow">else</span> {
03757             DEBUGINDENTADD(-4);
03758         }
03759 
03760         <span class="keywordflow">if</span> (mallocbuf) {
03761             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(mallocbuf);
03762         }
03763         <span class="keywordflow">return</span> ret_val;
03764     }
03765 
03766     <span class="comment">/*</span>
03767 <span class="comment">     * parse plaintext ScopedPDU sequence </span>
03768 <span class="comment">     */</span>
03769     *length = pdu_buf_len;
03770     DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"ScopedPDU"</span>);
03771     data = snmpv3_scopedPDU_parse(pdu, cp, length);
03772     <span class="keywordflow">if</span> (data == NULL) {
03773         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03774         DEBUGINDENTADD(-4);
03775         <span class="keywordflow">if</span> (mallocbuf) {
03776             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(mallocbuf);
03777         }
03778         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03779     }
03780 
03781     <span class="comment">/*</span>
03782 <span class="comment">     * parse the PDU.  </span>
03783 <span class="comment">     */</span>
03784     <span class="keywordflow">if</span> (after_header != NULL) {
03785         *after_header = data;
03786         tmp_buf_len = *length;
03787     }
03788 
03789     DEBUGPRINTPDUTYPE(<span class="stringliteral">"recv"</span>, *data);
03790     ret = snmp_pdu_parse(pdu, data, length);
03791     DEBUGINDENTADD(-8);
03792 
03793     <span class="keywordflow">if</span> (after_header != NULL) {
03794         *length = tmp_buf_len;
03795     }
03796 
03797     <span class="keywordflow">if</span> (ret != SNMPERR_SUCCESS) {
03798         ERROR_MSG(<span class="stringliteral">"error parsing PDU"</span>);
03799         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03800         <span class="keywordflow">if</span> (mallocbuf) {
03801             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(mallocbuf);
03802         }
03803         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03804     }
03805 
03806     <span class="keywordflow">if</span> (mallocbuf) {
03807         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(mallocbuf);
03808     }
03809     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03810 }                               <span class="comment">/* end snmpv3_parse() */</span>
03811 
03812 <span class="preprocessor">#define ERROR_STAT_LENGTH 11</span>
03813 
03814 <span class="keywordtype">int</span>
03815 snmpv3_make_report(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, <span class=
"keywordtype">int</span> error)
03816 {
03817 
03818     <span class="keywordtype">long</span>            ltmp;
03819     <span class="keyword">static</span> oid      unknownSecurityLevel[] =
03820         { 1, 3, 6, 1, 6, 3, 15, 1, 1, 1, 0 };
03821     <span class="keyword">static</span> oid      notInTimeWindow[] =
03822         { 1, 3, 6, 1, 6, 3, 15, 1, 1, 2, 0 };
03823     <span class="keyword">static</span> oid      unknownUserName[] =
03824         { 1, 3, 6, 1, 6, 3, 15, 1, 1, 3, 0 };
03825     <span class="keyword">static</span> oid      unknownEngineID[] =
03826         { 1, 3, 6, 1, 6, 3, 15, 1, 1, 4, 0 };
03827     <span class="keyword">static</span> oid      wrongDigest[] = { 1, 3, 6, 1, 6, 3, 15, 1, 1, 5, 0 };
03828     <span class="keyword">static</span> oid      decryptionError[] =
03829         { 1, 3, 6, 1, 6, 3, 15, 1, 1, 6, 0 };
03830     oid            *err_var;
03831     <span class="keywordtype">int</span>             err_var_len;
03832     <span class="keywordtype">int</span>             stat_ind;
03833     <span class="keyword">struct </span>snmp_secmod_def *sptr;
03834 
03835     <span class="keywordflow">switch</span> (error) {
03836     <span class="keywordflow">case</span> SNMPERR_USM_UNKNOWNENGINEID:
03837         stat_ind = STAT_USMSTATSUNKNOWNENGINEIDS;
03838         err_var = unknownEngineID;
03839         err_var_len = ERROR_STAT_LENGTH;
03840         <span class="keywordflow">break</span>;
03841     <span class="keywordflow">case</span> SNMPERR_USM_UNKNOWNSECURITYNAME:
03842         stat_ind = STAT_USMSTATSUNKNOWNUSERNAMES;
03843         err_var = unknownUserName;
03844         err_var_len = ERROR_STAT_LENGTH;
03845         <span class="keywordflow">break</span>;
03846     <span class="keywordflow">case</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL:
03847         stat_ind = STAT_USMSTATSUNSUPPORTEDSECLEVELS;
03848         err_var = unknownSecurityLevel;
03849         err_var_len = ERROR_STAT_LENGTH;
03850         <span class="keywordflow">break</span>;
03851     <span class="keywordflow">case</span> SNMPERR_USM_AUTHENTICATIONFAILURE:
03852         stat_ind = STAT_USMSTATSWRONGDIGESTS;
03853         err_var = wrongDigest;
03854         err_var_len = ERROR_STAT_LENGTH;
03855         <span class="keywordflow">break</span>;
03856     <span class="keywordflow">case</span> SNMPERR_USM_NOTINTIMEWINDOW:
03857         stat_ind = STAT_USMSTATSNOTINTIMEWINDOWS;
03858         err_var = notInTimeWindow;
03859         err_var_len = ERROR_STAT_LENGTH;
03860         <span class="keywordflow">break</span>;
03861     <span class="keywordflow">case</span> SNMPERR_USM_DECRYPTIONERROR:
03862         stat_ind = STAT_USMSTATSDECRYPTIONERRORS;
03863         err_var = decryptionError;
03864         err_var_len = ERROR_STAT_LENGTH;
03865         <span class="keywordflow">break</span>;
03866     <span class="keywordflow">default</span>:
03867         <span class="keywordflow">return</span> SNMPERR_GENERR;
03868     }
03869 
03870     snmp_free_varbind(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>);  <span class=
"comment">/* free the current varbind */</span>
03871 
03872     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = NULL;
03873     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o29">securityEngineID</a>);
03874     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a> =
03875         snmpv3_generate_engineID(&amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>);
03876     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o25">contextEngineID</a>);
03877     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a> =
03878         snmpv3_generate_engineID(&amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>);
03879     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = SNMP_MSG_REPORT;
03880     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a> = 0;
03881     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o7">errindex</a> = 0;
03882     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o27">contextName</a>);
03883     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a> = strdup(<span class=
"stringliteral">""</span>);
03884     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a> = strlen(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o27">contextName</a>);
03885 
03886     <span class="comment">/*</span>
03887 <span class="comment">     * reports shouldn't cache previous data. </span>
03888 <span class="comment">     */</span>
03889     <span class="comment">/*</span>
03890 <span class="comment">     * FIX - yes they should but USM needs to follow new EoP to determine</span>
03891 <span class="comment">     * which cached values to use </span>
03892 <span class="comment">     */</span>
03893     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>) {
03894         sptr = find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
03895         <span class="keywordflow">if</span> (sptr) {
03896             <span class="keywordflow">if</span> (sptr-&gt;pdu_free_state_ref) {
03897                 (*sptr-&gt;pdu_free_state_ref) (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o35">securityStateRef</a>);
03898             } <span class="keywordflow">else</span> {
03899                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,
03900                          <span class="stringliteral">"Security Model %d can't free state references\n"</span>,
03901                          pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
03902             }
03903         } <span class="keywordflow">else</span> {
03904             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,
03905                      <span class="stringliteral">"Can't find security model to free ptr: %d\n"</span>,
03906                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
03907         }
03908         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a> = NULL;
03909     }
03910 
03911     <span class="keywordflow">if</span> (error == SNMPERR_USM_NOTINTIMEWINDOW) {
03912         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> = SNMP_SEC_LEVEL_AUTHNOPRIV;
03913     } <span class="keywordflow">else</span> {
03914         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> = SNMP_SEC_LEVEL_NOAUTH;
03915     }
03916 
03917     <span class="comment">/*</span>
03918 <span class="comment">     * find the appropriate error counter  </span>
03919 <span class="comment">     */</span>
03920     ltmp = snmp_get_statistic(stat_ind);
03921 
03922     <span class="comment">/*</span>
03923 <span class="comment">     * return the appropriate error counter  </span>
03924 <span class="comment">     */</span>
03925     snmp_pdu_add_variable(pdu, err_var, err_var_len,
03926                           ASN_COUNTER, (u_char *) &amp; ltmp, <span class="keyword">sizeof</span>(ltmp));
03927 
03928     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03929 }                               <span class="comment">/* end snmpv3_make_report() */</span>
03930 
03931 
03932 <span class="keywordtype">int</span>
03933 snmpv3_get_report_type(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
03934 {
03935     <span class="keyword">static</span> oid      snmpMPDStats[] = { 1, 3, 6, 1, 6, 3, 11, 2, 1 };
03936     <span class="keyword">static</span> oid      usmStats[] = { 1, 3, 6, 1, 6, 3, 15, 1, 1 };
03937     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vp;
03938     <span class="keywordtype">int</span>             rpt_type = SNMPERR_UNKNOWN_REPORT;
03939 
03940     <span class="keywordflow">if</span> (pdu == NULL || pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a> == NULL)
03941         <span class="keywordflow">return</span> rpt_type;
03942     vp = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>;
03943     <span class="keywordflow">if</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> == REPORT_STATS_LEN + 2) {
03944         <span class="keywordflow">if</span> (memcmp(snmpMPDStats, vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, REPORT_STATS_LEN * <span class="keyword">sizeof</span>(oid))
03945             == 0) {
03946             <span class="keywordflow">switch</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>[REPORT_STATS_LEN]) {
03947             <span class="keywordflow">case</span> REPORT_snmpUnknownSecurityModels_NUM:
03948                 rpt_type = SNMPERR_UNKNOWN_SEC_MODEL;
03949                 <span class="keywordflow">break</span>;
03950             <span class="keywordflow">case</span> REPORT_snmpInvalidMsgs_NUM:
03951                 rpt_type = SNMPERR_INVALID_MSG;
03952                 <span class="keywordflow">break</span>;
03953             }
03954         } <span class="keywordflow">else</span>
03955             <span class="keywordflow">if</span> (memcmp(usmStats, vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, REPORT_STATS_LEN * <span class="keyword">sizeof</span>(oid))
03956                 == 0) {
03957             <span class="keywordflow">switch</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>[REPORT_STATS_LEN]) {
03958             <span class="keywordflow">case</span> REPORT_usmStatsUnsupportedSecLevels_NUM:
03959                 rpt_type = SNMPERR_UNSUPPORTED_SEC_LEVEL;
03960                 <span class="keywordflow">break</span>;
03961             <span class="keywordflow">case</span> REPORT_usmStatsNotInTimeWindows_NUM:
03962                 rpt_type = SNMPERR_NOT_IN_TIME_WINDOW;
03963                 <span class="keywordflow">break</span>;
03964             <span class="keywordflow">case</span> REPORT_usmStatsUnknownUserNames_NUM:
03965                 rpt_type = SNMPERR_UNKNOWN_USER_NAME;
03966                 <span class="keywordflow">break</span>;
03967             <span class="keywordflow">case</span> REPORT_usmStatsUnknownEngineIDs_NUM:
03968                 rpt_type = SNMPERR_UNKNOWN_ENG_ID;
03969                 <span class="keywordflow">break</span>;
03970             <span class="keywordflow">case</span> REPORT_usmStatsWrongDigests_NUM:
03971                 rpt_type = SNMPERR_AUTHENTICATION_FAILURE;
03972                 <span class="keywordflow">break</span>;
03973             <span class="keywordflow">case</span> REPORT_usmStatsDecryptionErrors_NUM:
03974                 rpt_type = SNMPERR_DECRYPTION_ERR;
03975                 <span class="keywordflow">break</span>;
03976             }
03977         }
03978     }
03979     DEBUGMSGTL((<span class="stringliteral">"report"</span>, <span class=
"stringliteral">"Report type: %d\n"</span>, rpt_type));
03980     <span class="keywordflow">return</span> rpt_type;
03981 }
03982 
03983 <span class="comment">/*</span>
03984 <span class="comment"> * Parses the packet received on the input session, and places the data into</span>
03985 <span class="comment"> * the input pdu.  length is the length of the input packet.</span>
03986 <span class="comment"> * If any errors are encountered, -1 or USM error is returned.</span>
03987 <span class="comment"> * Otherwise, a 0 is returned.</span>
03988 <span class="comment"> */</span>
03989 <span class="keyword">static</span> <span class="keywordtype">int</span>
03990 _snmp_parse(<span class="keywordtype">void</span> *sessp,
03991             netsnmp_session * session,
03992             <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, u_char * data, size_t length)
03993 {
03994 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
03995     u_char          community[COMMUNITY_MAX_LEN];
03996     size_t          community_length = COMMUNITY_MAX_LEN;
03997 <span class="preprocessor">#endif</span>
03998     <span class="keywordtype">int</span>             result = -1;
03999 
04000     session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
04001     session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
04002 
04003     <span class="comment">/*</span>
04004 <span class="comment">     * Ensure all incoming PDUs have a unique means of identification </span>
04005 <span class="comment">     * (This is not restricted to AgentX handling,</span>
04006 <span class="comment">     * though that is where the need becomes visible)   </span>
04007 <span class="comment">     */</span>
04008     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o4">transid</a> = snmp_get_next_transid();
04009 
04010     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a> != SNMP_DEFAULT_VERSION) {
04011         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a>;
04012     } <span class="keywordflow">else</span> {
04013         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a> = snmp_parse_version(data, length);
04014     }
04015 
04016     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>) {
04017 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
04018     <span class="keywordflow">case</span> SNMP_VERSION_1:
04019 <span class="preprocessor">#endif</span>
04020 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
04021     <span class="keywordflow">case</span> SNMP_VERSION_2c:
04022 <span class="preprocessor">#endif</span>
04023 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
04024         DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>, <span class=
"stringliteral">"Parsing SNMPv%d message...\n"</span>,
04025                     (1 + pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>)));
04026 
04027         <span class="comment">/*</span>
04028 <span class="comment">         * authenticates message and returns length if valid </span>
04029 <span class="comment">         */</span>
04030         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_1) {
04031             DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"SNMPv1 message\n"</span>);
04032         } <span class="keywordflow">else</span> {
04033             DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"SNMPv2c message\n"</span>);
04034         }
04035         data = snmp_comstr_parse(data, &amp;length,
04036                                  community, &amp;community_length,
04037                                  &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>);
04038         <span class="keywordflow">if</span> (data == NULL)
04039             <span class="keywordflow">return</span> -1;
04040 
04041         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> != session-&gt;<a class="code" href="structsnmp__session.html#o0">version</a> &amp;&amp;
04042             session-&gt;<a class="code" href="structsnmp__session.html#o0">version</a> != SNMP_DEFAULT_VERSION) {
04043             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
04044             <span class="keywordflow">return</span> -1;
04045         }
04046 
04047         <span class="comment">/*</span>
04048 <span class="comment">         * maybe get the community string. </span>
04049 <span class="comment">         */</span>
04050         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> = SNMP_SEC_LEVEL_NOAUTH;
04051         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a> = (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_1) ?
04052             SNMP_SEC_MODEL_SNMPv1 : SNMP_SEC_MODEL_SNMPv2c;
04053         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a>);
04054         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a> = 0;
04055         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a> = (u_char *) 0;
04056         <span class="keywordflow">if</span> (community_length) {
04057             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a> = community_length;
04058             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a> = (u_char *) malloc(community_length);
04059             <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a> == NULL) {
04060                 session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
04061                 <span class="keywordflow">return</span> -1;
04062             }
04063             memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a>, community, community_length);
04064         }
04065         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o10">authenticator</a>) {
04066             data = session-&gt;<a class="code" href="structsnmp__session.html#o10">authenticator</a>(data, &amp;length,
04067                                           community, community_length);
04068             <span class="keywordflow">if</span> (data == NULL) {
04069                 session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_AUTHENTICATION_FAILURE;
04070                 <span class="keywordflow">return</span> -1;
04071             }
04072         }
04073 
04074         DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"PDU"</span>);
04075         result = snmp_pdu_parse(pdu, data, &amp;length);
04076         <span class="keywordflow">if</span> (result &lt; 0) {
04077             <span class="comment">/*</span>
04078 <span class="comment">             * This indicates a parse error.  </span>
04079 <span class="comment">             */</span>
04080             snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
04081         }
04082         DEBUGINDENTADD(-6);
04083         <span class="keywordflow">break</span>;
04084 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
04085 
04086     <span class="keywordflow">case</span> SNMP_VERSION_3:
04087         result = snmpv3_parse(pdu, data, &amp;length, NULL, session);
04088         DEBUGMSGTL((<span class="stringliteral">"snmp_parse"</span>,
04089                     <span class="stringliteral">"Parsed SNMPv3 message (secName:%s, secLevel:%s): %s\n"</span>,
04090                     pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o31">securityName</a>, secLevelName[pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o11">securityLevel</a>],
04091                     snmp_api_errstring(result)));
04092 
04093         <span class="keywordflow">if</span> (result) {
04094             <span class="keyword">struct </span>snmp_secmod_def *secmod =
04095                 find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
04096             <span class="keywordflow">if</span> (!sessp) {
04097                 session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = result;
04098             } <span class="keywordflow">else</span> {
04099                 <span class="comment">/*</span>
04100 <span class="comment">                 * Call the security model to special handle any errors</span>
04101 <span class="comment">                 */</span>
04102 
04103                 <span class="keywordflow">if</span> (secmod &amp;&amp; secmod-&gt;handle_report) {
04104                     <span class="keyword">struct </span>session_list *slp = (<span class=
"keyword">struct </span>session_list *) sessp;
04105                     (*secmod-&gt;handle_report)(sessp, slp-&gt;transport, session,
04106                                              result, pdu);
04107                 }
04108             }
04109             <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o35">securityStateRef</a> != NULL) {
04110                 <span class="keywordflow">if</span> (secmod &amp;&amp; secmod-&gt;pdu_free_state_ref) {
04111                     secmod-&gt;pdu_free_state_ref(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o35">securityStateRef</a>);
04112                     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a> = NULL;
04113                 }
04114             }
04115         }
04116         <span class="keywordflow">break</span>;
04117     <span class="keywordflow">case</span> SNMPERR_BAD_VERSION:
04118         ERROR_MSG(<span class="stringliteral">"error parsing snmp message version"</span>);
04119         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
04120         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
04121         <span class="keywordflow">break</span>;
04122     <span class="keywordflow">case</span> SNMP_VERSION_sec:
04123     <span class="keywordflow">case</span> SNMP_VERSION_2u:
04124     <span class="keywordflow">case</span> SNMP_VERSION_2star:
04125     <span class="keywordflow">case</span> SNMP_VERSION_2p:
04126     <span class="keywordflow">default</span>:
04127         ERROR_MSG(<span class="stringliteral">"unsupported snmp message version"</span>);
04128         snmp_increment_statistic(STAT_SNMPINBADVERSIONS);
04129 
04130         <span class="comment">/*</span>
04131 <span class="comment">         * need better way to determine OS independent</span>
04132 <span class="comment">         * INT32_MAX value, for now hardcode</span>
04133 <span class="comment">         */</span>
04134         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> &lt; 0 || pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> &gt; 2147483647) {
04135             snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
04136         }
04137         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
04138         <span class="keywordflow">break</span>;
04139     }
04140 
04141     <span class="keywordflow">return</span> result;
04142 }
04143 
04144 <span class="keyword">static</span> <span class="keywordtype">int</span>
04145 snmp_parse(<span class="keywordtype">void</span> *sessp,
04146            netsnmp_session * pss,
04147            <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, u_char * data, size_t length)
04148 {
04149     <span class="keywordtype">int</span>             rc;
04150 
04151     rc = _snmp_parse(sessp, pss, pdu, data, length);
04152     <span class="keywordflow">if</span> (rc) {
04153         <span class="keywordflow">if</span> (!pss-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a>) {
04154             pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_PARSE;
04155         }
04156         SET_SNMP_ERROR(pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
04157     }
04158 
04159     <span class="keywordflow">return</span> rc;
04160 }
04161 
04162 <span class="keywordtype">int</span>
04163 snmp_pdu_parse(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, u_char * data, size_t * length)
04164 {
04165     u_char          type;
04166     u_char          msg_type;
04167     u_char         *var_val;
04168     <span class="keywordtype">int</span>             badtype = 0;
04169     size_t          len;
04170     size_t          four;
04171     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vp = NULL;
04172     oid             objid[MAX_OID_LEN];
04173 
04174     <span class="comment">/*</span>
04175 <span class="comment">     * Get the PDU type </span>
04176 <span class="comment">     */</span>
04177     data = asn_parse_header(data, length, &amp;msg_type);
04178     <span class="keywordflow">if</span> (data == NULL)
04179         <span class="keywordflow">return</span> -1;
04180     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = msg_type;
04181     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> &amp;= (~UCD_MSG_FLAG_RESPONSE_PDU);
04182 
04183     <span class="comment">/*</span>
04184 <span class="comment">     * get the fields in the PDU preceeding the variable-bindings sequence </span>
04185 <span class="comment">     */</span>
04186     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>) {
04187     <span class="keywordflow">case</span> SNMP_MSG_TRAP:
04188         <span class="comment">/*</span>
04189 <span class="comment">         * enterprise </span>
04190 <span class="comment">         */</span>
04191         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> = MAX_OID_LEN;
04192         data = asn_parse_objid(data, length, &amp;type, objid,
04193                                &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a>);
04194         <span class="keywordflow">if</span> (data == NULL)
04195             <span class="keywordflow">return</span> -1;
04196         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a> =
04197             (oid *) malloc(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> * <span class=
"keyword">sizeof</span>(oid));
04198         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o20">enterprise</a> == NULL) {
04199             <span class="keywordflow">return</span> -1;
04200         }
04201         memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>, objid,
04202                 pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> * <span class=
"keyword">sizeof</span>(oid));
04203 
04204         <span class="comment">/*</span>
04205 <span class="comment">         * agent-addr </span>
04206 <span class="comment">         */</span>
04207         four = 4;
04208         data = asn_parse_string(data, length, &amp;type,
04209                                 (u_char *) pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o24">agent_addr</a>, &amp;four);
04210         <span class="keywordflow">if</span> (data == NULL)
04211             <span class="keywordflow">return</span> -1;
04212 
04213         <span class="comment">/*</span>
04214 <span class="comment">         * generic trap </span>
04215 <span class="comment">         */</span>
04216         data = asn_parse_int(data, length, &amp;type, (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o22">trap_type</a>,
04217                              <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a>));
04218         <span class="keywordflow">if</span> (data == NULL)
04219             <span class="keywordflow">return</span> -1;
04220         <span class="comment">/*</span>
04221 <span class="comment">         * specific trap </span>
04222 <span class="comment">         */</span>
04223         data =
04224             asn_parse_int(data, length, &amp;type,
04225                           (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>,
04226                           <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>));
04227         <span class="keywordflow">if</span> (data == NULL)
04228             <span class="keywordflow">return</span> -1;
04229 
04230         <span class="comment">/*</span>
04231 <span class="comment">         * timestamp  </span>
04232 <span class="comment">         */</span>
04233         data = asn_parse_unsigned_int(data, length, &amp;type, &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a>,
04234                                       <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a>));
04235         <span class="keywordflow">if</span> (data == NULL)
04236             <span class="keywordflow">return</span> -1;
04237 
04238         <span class="keywordflow">break</span>;
04239 
04240     <span class="keywordflow">case</span> SNMP_MSG_RESPONSE:
04241     <span class="keywordflow">case</span> SNMP_MSG_REPORT:
04242         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> |= UCD_MSG_FLAG_RESPONSE_PDU;
04243         <span class="comment">/*</span>
04244 <span class="comment">         * fallthrough </span>
04245 <span class="comment">         */</span>
04246 
04247     <span class="keywordflow">case</span> SNMP_MSG_GET:
04248     <span class="keywordflow">case</span> SNMP_MSG_GETNEXT:
04249     <span class="keywordflow">case</span> SNMP_MSG_GETBULK:
04250     <span class="keywordflow">case</span> SNMP_MSG_TRAP2:
04251     <span class="keywordflow">case</span> SNMP_MSG_INFORM:
04252     <span class="keywordflow">case</span> SNMP_MSG_SET:
04253         <span class="comment">/*</span>
04254 <span class="comment">         * PDU is not an SNMPv1 TRAP </span>
04255 <span class="comment">         */</span>
04256 
04257         <span class="comment">/*</span>
04258 <span class="comment">         * request id </span>
04259 <span class="comment">         */</span>
04260         DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"request_id"</span>);
04261         data = asn_parse_int(data, length, &amp;type, &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a>,
04262                              <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a>));
04263         DEBUGINDENTLESS();
04264         <span class="keywordflow">if</span> (data == NULL) {
04265             <span class="keywordflow">return</span> -1;
04266         }
04267 
04268         <span class="comment">/*</span>
04269 <span class="comment">         * error status (getbulk non-repeaters) </span>
04270 <span class="comment">         */</span>
04271         DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"error status"</span>);
04272         data = asn_parse_int(data, length, &amp;type, &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o6">errstat</a>,
04273                              <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o6">errstat</a>));
04274         DEBUGINDENTLESS();
04275         <span class="keywordflow">if</span> (data == NULL) {
04276             <span class="keywordflow">return</span> -1;
04277         }
04278 
04279         <span class="comment">/*</span>
04280 <span class="comment">         * error index (getbulk max-repetitions) </span>
04281 <span class="comment">         */</span>
04282         DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"error index"</span>);
04283         data = asn_parse_int(data, length, &amp;type, &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a>,
04284                              <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a>));
04285         DEBUGINDENTLESS();
04286         <span class="keywordflow">if</span> (data == NULL) {
04287             <span class="keywordflow">return</span> -1;
04288         }
04289         <span class="keywordflow">break</span>;
04290 
04291     <span class="keywordflow">default</span>:
04292         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Bad PDU type received: 0x%.2x\n"</span>, pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>);
04293         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
04294         <span class="keywordflow">return</span> -1;
04295     }
04296 
04297     <span class="comment">/*</span>
04298 <span class="comment">     * get header for variable-bindings sequence </span>
04299 <span class="comment">     */</span>
04300     DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"VarBindList"</span>);
04301     data = asn_parse_sequence(data, length, &amp;type,
04302                               (ASN_SEQUENCE | ASN_CONSTRUCTOR),
04303                               <span class="stringliteral">"varbinds"</span>);
04304     <span class="keywordflow">if</span> (data == NULL)
04305         <span class="keywordflow">return</span> -1;
04306 
04307     <span class="comment">/*</span>
04308 <span class="comment">     * get each varBind sequence </span>
04309 <span class="comment">     */</span>
04310     <span class="keywordflow">while</span> ((int) *length &gt; 0) {
04311         <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vptemp;
04312         vptemp = (<a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *) malloc(<span class=
"keyword">sizeof</span>(*vptemp));
04313         <span class="keywordflow">if</span> (0 == vptemp) {
04314             <span class="keywordflow">return</span> -1;
04315         }
04316         <span class="keywordflow">if</span> (0 == vp) {
04317             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = vptemp;
04318         } <span class="keywordflow">else</span> {
04319             vp-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a> = vptemp;
04320         }
04321         vp = vptemp;
04322 
04323         vp-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a> = NULL;
04324         vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string = NULL;
04325         vp-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = MAX_OID_LEN;
04326         vp-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = 0;
04327         vp-&gt;<a class="code" href="structvariable__list.html#o10">index</a> = 0;
04328         vp-&gt;<a class="code" href="structvariable__list.html#o8">data</a> = 0;
04329         vp-&gt;<a class="code" href="structvariable__list.html#o9">dataFreeHook</a> = 0;
04330         DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"VarBind"</span>);
04331         data = snmp_parse_var_op(data, objid, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a>, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
04332                                  &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>, &amp;var_val, length);
04333         <span class="keywordflow">if</span> (data == NULL)
04334             <span class="keywordflow">return</span> -1;
04335         <span class="keywordflow">if</span> (snmp_set_var_objid(vp, objid, vp-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a>))
04336             <span class="keywordflow">return</span> -1;
04337 
04338         len = MAX_PACKET_LENGTH;
04339         DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"Value"</span>);
04340         <span class="keywordflow">switch</span> ((short) vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>) {
04341         <span class="keywordflow">case</span> ASN_INTEGER:
04342             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.integer = (<span class=
"keywordtype">long</span> *) vp-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>;
04343             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(long);
04344             asn_parse_int(var_val, &amp;len, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
04345                           (<span class="keywordtype">long</span> *) vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer,
04346                           <span class="keyword">sizeof</span>(*vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer));
04347             <span class="keywordflow">break</span>;
04348         <span class="keywordflow">case</span> ASN_COUNTER:
04349         <span class="keywordflow">case</span> ASN_GAUGE:
04350         <span class="keywordflow">case</span> ASN_TIMETICKS:
04351         <span class="keywordflow">case</span> ASN_UINTEGER:
04352             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.integer = (<span class=
"keywordtype">long</span> *) vp-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>;
04353             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(u_long);
04354             asn_parse_unsigned_int(var_val, &amp;len, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>,
04355                                    (u_long *) vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.integer,
04356                                    vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
04357             <span class="keywordflow">break</span>;
04358 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
04359         <span class="keywordflow">case</span> ASN_OPAQUE_COUNTER64:
04360         <span class="keywordflow">case</span> ASN_OPAQUE_U64:
04361 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
04362         <span class="keywordflow">case</span> ASN_COUNTER64:
04363             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.counter64 = (<span class=
"keyword">struct </span>counter64 *) vp-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>;
04364             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(<span class="keyword">struct </span>counter64);
04365             asn_parse_unsigned_int64(var_val, &amp;len, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>,
04366                                      (<span class="keyword">struct</span> counter64 *) vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.
04367                                      counter64, vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
04368             <span class="keywordflow">break</span>;
04369 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
04370         <span class="keywordflow">case</span> ASN_OPAQUE_FLOAT:
04371             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.floatVal = (<span class=
"keywordtype">float</span> *) vp-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>;
04372             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(float);
04373             asn_parse_float(var_val, &amp;len, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
04374                             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.floatVal, vp-&gt;<a class=
"code" href="structvariable__list.html#o5">val_len</a>);
04375             <span class="keywordflow">break</span>;
04376         <span class="keywordflow">case</span> ASN_OPAQUE_DOUBLE:
04377             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.doubleVal = (<span class=
"keywordtype">double</span> *) vp-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>;
04378             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(double);
04379             asn_parse_double(var_val, &amp;len, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
04380                              vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.doubleVal, vp-&gt;<a class=
"code" href="structvariable__list.html#o5">val_len</a>);
04381             <span class="keywordflow">break</span>;
04382         <span class="keywordflow">case</span> ASN_OPAQUE_I64:
04383             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.counter64 = (<span class=
"keyword">struct </span>counter64 *) vp-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>;
04384             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(<span class="keyword">struct </span>counter64);
04385             asn_parse_signed_int64(var_val, &amp;len, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>,
04386                                    (<span class="keyword">struct</span> counter64 *) vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.counter64,
04387                                    <span class="keyword">sizeof</span>(*vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.counter64));
04388 
04389             <span class="keywordflow">break</span>;
04390 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
04391         <span class="keywordflow">case</span> ASN_OCTET_STR:
04392         <span class="keywordflow">case</span> ASN_IPADDRESS:
04393         <span class="keywordflow">case</span> ASN_OPAQUE:
04394         <span class="keywordflow">case</span> ASN_NSAP:
04395             <span class="keywordflow">if</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> &lt; <span class="keyword">sizeof</span>(vp-&gt;<a class="code" href=
"structvariable__list.html#o7">buf</a>)) {
04396                 vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string = (u_char *) vp-&gt;<a class=
"code" href="structvariable__list.html#o7">buf</a>;
04397             } <span class="keywordflow">else</span> {
04398                 vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string = (u_char *) malloc(vp-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>);
04399             }
04400             <span class="keywordflow">if</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string == NULL) {
04401                 <span class="keywordflow">return</span> -1;
04402             }
04403             asn_parse_string(var_val, &amp;len, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>, vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string,
04404                              &amp;vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
04405             <span class="keywordflow">break</span>;
04406         <span class="keywordflow">case</span> ASN_OBJECT_ID:
04407             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = MAX_OID_LEN;
04408             asn_parse_objid(var_val, &amp;len, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>, objid, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
04409             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> *= <span class=
"keyword">sizeof</span>(oid);
04410             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid = (oid *) malloc(vp-&gt;<a class=
"code" href="structvariable__list.html#o5">val_len</a>);
04411             <span class="keywordflow">if</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid == NULL) {
04412                 <span class="keywordflow">return</span> -1;
04413             }
04414             memmove(vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid, objid, vp-&gt;<a class="code"
href="structvariable__list.html#o5">val_len</a>);
04415             <span class="keywordflow">break</span>;
04416         <span class="keywordflow">case</span> SNMP_NOSUCHOBJECT:
04417         <span class="keywordflow">case</span> SNMP_NOSUCHINSTANCE:
04418         <span class="keywordflow">case</span> SNMP_ENDOFMIBVIEW:
04419         <span class="keywordflow">case</span> ASN_NULL:
04420             <span class="keywordflow">break</span>;
04421         <span class="keywordflow">case</span> ASN_BIT_STR:
04422             vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.bitstring = (u_char *) malloc(vp-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>);
04423             <span class="keywordflow">if</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.bitstring == NULL) {
04424                 <span class="keywordflow">return</span> -1;
04425             }
04426             asn_parse_bitstring(var_val, &amp;len, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>,
04427                                 vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.bitstring, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
04428             <span class="keywordflow">break</span>;
04429         <span class="keywordflow">default</span>:
04430             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"bad type returned (%x)\n"</span>, vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>);
04431             badtype = -1;
04432             <span class="keywordflow">break</span>;
04433         }
04434         DEBUGINDENTADD(-4);
04435     }
04436     <span class="keywordflow">return</span> badtype;
04437 }
04438 
04439 <span class="comment">/*</span>
04440 <span class="comment"> * snmp v3 utility function to parse into the scopedPdu. stores contextName</span>
04441 <span class="comment"> * and contextEngineID in pdu struct. Also stores pdu-&gt;command (handy for </span>
04442 <span class="comment"> * Report generation).</span>
04443 <span class="comment"> * </span>
04444 <span class="comment"> * returns pointer to begining of PDU or NULL on error.</span>
04445 <span class="comment"> */</span>
04446 u_char         *
04447 snmpv3_scopedPDU_parse(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, u_char * cp, size_t * length)
04448 {
04449     u_char          tmp_buf[SNMP_MAX_MSG_SIZE];
04450     size_t          tmp_buf_len;
04451     u_char          type;
04452     size_t          asn_len;
04453     u_char         *data;
04454 
04455     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = 0;           <span class=
"comment">/* initialize so we know if it got parsed */</span>
04456     asn_len = *length;
04457     data = asn_parse_sequence(cp, &amp;asn_len, &amp;type,
04458                               (ASN_SEQUENCE | ASN_CONSTRUCTOR),
04459                               <span class="stringliteral">"plaintext scopedPDU"</span>);
04460     <span class="keywordflow">if</span> (data == NULL) {
04461         <span class="keywordflow">return</span> NULL;
04462     }
04463     *length -= data - cp;
04464 
04465     <span class="comment">/*</span>
04466 <span class="comment">     * contextEngineID from scopedPdu  </span>
04467 <span class="comment">     */</span>
04468     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"contextEngineID"</span>);
04469     data = asn_parse_string(data, length, &amp;type, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o25">contextEngineID</a>,
04470                             &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>);
04471     DEBUGINDENTLESS();
04472     <span class="keywordflow">if</span> (data == NULL) {
04473         ERROR_MSG(<span class="stringliteral">"error parsing contextEngineID from scopedPdu"</span>);
04474         <span class="keywordflow">return</span> NULL;
04475     }
04476 
04477     <span class="comment">/*</span>
04478 <span class="comment">     * check that it agrees with engineID returned from USM above</span>
04479 <span class="comment">     * * only a warning because this could be legal if we are a proxy</span>
04480 <span class="comment">     */</span>
04481     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o30">securityEngineIDLen</a> != pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o26">contextEngineIDLen</a> ||
04482         memcmp(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o25">contextEngineID</a>,
04483                pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>) != 0) {
04484         DEBUGMSGTL((<span class="stringliteral">"scopedPDU_parse"</span>,
04485                     <span class="stringliteral">"inconsistent engineID information in message\n"</span>));
04486     }
04487 
04488     <span class="comment">/*</span>
04489 <span class="comment">     * parse contextName from scopedPdu</span>
04490 <span class="comment">     */</span>
04491     tmp_buf_len = SNMP_MAX_CONTEXT_SIZE;
04492     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"contextName"</span>);
04493     data = asn_parse_string(data, length, &amp;type, tmp_buf, &amp;tmp_buf_len);
04494     DEBUGINDENTLESS();
04495     <span class="keywordflow">if</span> (data == NULL) {
04496         ERROR_MSG(<span class="stringliteral">"error parsing contextName from scopedPdu"</span>);
04497         <span class="keywordflow">return</span> NULL;
04498     }
04499 
04500     <span class="keywordflow">if</span> (tmp_buf_len) {
04501         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a> = (<span class=
"keywordtype">char</span> *) malloc(tmp_buf_len);
04502         memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a>, tmp_buf, tmp_buf_len);
04503         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a> = tmp_buf_len;
04504     } <span class="keywordflow">else</span> {
04505         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a> = strdup(<span class=
"stringliteral">""</span>);
04506         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a> = 0;
04507     }
04508     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a> == NULL) {
04509         ERROR_MSG(<span class="stringliteral">"error copying contextName from scopedPdu"</span>);
04510         <span class="keywordflow">return</span> NULL;
04511     }
04512 
04513     <span class="comment">/*</span>
04514 <span class="comment">     * Get the PDU type </span>
04515 <span class="comment">     */</span>
04516     asn_len = *length;
04517     cp = asn_parse_header(data, &amp;asn_len, &amp;type);
04518     <span class="keywordflow">if</span> (cp == NULL)
04519         <span class="keywordflow">return</span> NULL;
04520 
04521     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = type;
04522 
04523     <span class="keywordflow">return</span> data;
04524 }
04525 
04526 <span class="comment">/*</span>
04527 <span class="comment"> * These functions send PDUs using an active session:</span>
04528 <span class="comment"> * snmp_send             - traditional API, no callback</span>
04529 <span class="comment"> * snmp_async_send       - traditional API, with callback</span>
04530 <span class="comment"> * snmp_sess_send        - single session API, no callback</span>
04531 <span class="comment"> * snmp_sess_async_send  - single session API, with callback</span>
04532 <span class="comment"> *</span>
04533 <span class="comment"> * Call snmp_build to create a serialized packet (the pdu).</span>
04534 <span class="comment"> * If necessary, set some of the pdu data from the</span>
04535 <span class="comment"> * session defaults.</span>
04536 <span class="comment"> * If there is an expected response for this PDU,</span>
04537 <span class="comment"> * queue a corresponding request on the list</span>
04538 <span class="comment"> * of outstanding requests for this session,</span>
04539 <span class="comment"> * and store the callback vectors in the request.</span>
04540 <span class="comment"> *</span>
04541 <span class="comment"> * Send the pdu to the target identified by this session.</span>
04542 <span class="comment"> * Return on success:</span>
04543 <span class="comment"> *   The request id of the pdu is returned, and the pdu is freed.</span>
04544 <span class="comment"> * Return on failure:</span>
04545 <span class="comment"> *   Zero (0) is returned.</span>
04546 <span class="comment"> *   The caller must call snmp_free_pdu if 0 is returned.</span>
04547 <span class="comment"> */</span>
04548 <span class="keywordtype">int</span>
04549 snmp_send(netsnmp_session * session, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
04550 {
04551     <span class="keywordflow">return</span> snmp_async_send(session, pdu, NULL, NULL);
04552 }
04553 
04554 <span class="keywordtype">int</span>
04555 snmp_sess_send(<span class="keywordtype">void</span> *sessp, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
04556 {
04557     <span class="keywordflow">return</span> snmp_sess_async_send(sessp, pdu, NULL, NULL);
04558 }
04559 
04560 <span class="keywordtype">int</span>
04561 snmp_async_send(netsnmp_session * session,
04562                 <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, snmp_callback callback, <span class=
"keywordtype">void</span> *cb_data)
04563 {
04564     <span class="keywordtype">void</span>           *sessp = snmp_sess_pointer(session);
04565     <span class="keywordflow">return</span> snmp_sess_async_send(sessp, pdu, callback, cb_data);
04566 }
04567 
04568 <span class="keyword">static</span> <span class="keywordtype">int</span>
04569 _sess_async_send(<span class="keywordtype">void</span> *sessp,
04570                  <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, snmp_callback callback, <span class=
"keywordtype">void</span> *cb_data)
04571 {
04572     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
04573     netsnmp_session *session;
04574     <span class="keyword">struct </span>snmp_internal_session *isp;
04575     netsnmp_transport *transport = NULL;
04576     u_char         *pktbuf = NULL, *packet = NULL;
04577     size_t          pktbuf_len = 0, offset = 0, length = 0;
04578     <span class="keywordtype">int</span>             result;
04579     <span class="keywordtype">long</span>            reqid;
04580 
04581     <span class="keywordflow">if</span> (slp == NULL) {
04582         <span class="keywordflow">return</span> 0;
04583     } <span class="keywordflow">else</span> {
04584         session = slp-&gt;session;
04585         isp = slp-&gt;internal;
04586         transport = slp-&gt;transport;
04587         <span class="keywordflow">if</span> (!session || !isp || !transport) {
04588             DEBUGMSGTL((<span class="stringliteral">"sess_async_send"</span>, <span class=
"stringliteral">"send fail: closing...\n"</span>));
04589             <span class="keywordflow">return</span> 0;
04590         }
04591     }
04592 
04593     <span class="keywordflow">if</span> (pdu == NULL) {
04594         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_NULL_PDU;
04595         <span class="keywordflow">return</span> 0;
04596     }
04597 
04598     <span class="keywordflow">if</span> ((pktbuf = malloc(2048)) == NULL) {
04599         DEBUGMSGTL((<span class="stringliteral">"sess_async_send"</span>,
04600                     <span class="stringliteral">"couldn't malloc initial packet buffer\n"</span>));
04601         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
04602         <span class="keywordflow">return</span> 0;
04603     } <span class="keywordflow">else</span> {
04604         pktbuf_len = 2048;
04605     }
04606 
04607     session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
04608     session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
04609 
04610 <span class="preprocessor">#if TEMPORARILY_DISABLED</span>
04611     <span class="comment">/*</span>
04612 <span class="comment">     *  NULL variable are allowed in certain PDU types.</span>
04613 <span class="comment">     *  In particular, SNMPv3 engineID probes are of this form.</span>
04614 <span class="comment">     *  There is an internal PDU flag to indicate that this</span>
04615 <span class="comment">     *    is acceptable, but until the construction of engineID</span>
04616 <span class="comment">     *    probes can be amended to set this flag, we'll simply</span>
04617 <span class="comment">     *    skip this test altogether.</span>
04618 <span class="comment">     */</span>
04619     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> == NULL) {
04620         <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>) {
04621         <span class="keywordflow">case</span> SNMP_MSG_GET:
04622         <span class="keywordflow">case</span> SNMP_MSG_SET:
04623         <span class="keywordflow">case</span> SNMP_MSG_GETNEXT:
04624         <span class="keywordflow">case</span> SNMP_MSG_GETBULK:
04625         <span class="keywordflow">case</span> SNMP_MSG_RESPONSE:
04626         <span class="keywordflow">case</span> SNMP_MSG_TRAP2:
04627         <span class="keywordflow">case</span> SNMP_MSG_REPORT:
04628         <span class="keywordflow">case</span> SNMP_MSG_INFORM:
04629             session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> = snmp_errno = SNMPERR_NO_VARS;
04630             <span class="keywordflow">return</span> 0;
04631         <span class="keywordflow">case</span> SNMP_MSG_TRAP:
04632             <span class="keywordflow">break</span>;
04633         }
04634     }
04635 <span class="preprocessor">#endif</span>
04636 
04637     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> |= UCD_MSG_FLAG_EXPECT_RESPONSE;
04638 
04639     <span class="comment">/*</span>
04640 <span class="comment">     * Check/setup the version.  </span>
04641 <span class="comment">     */</span>
04642 
04643     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_DEFAULT_VERSION) {
04644         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a> == SNMP_DEFAULT_VERSION) {
04645             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
04646             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
04647             <span class="keywordflow">return</span> 0;
04648         }
04649         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a>;
04650     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a> == SNMP_DEFAULT_VERSION) {
04651         <span class="comment">/*</span>
04652 <span class="comment">         * It's OK  </span>
04653 <span class="comment">         */</span>
04654     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> != session-&gt;<a class="code" href="structsnmp__session.html#o0">version</a>) {
04655         <span class="comment">/*</span>
04656 <span class="comment">         * ENHANCE: we should support multi-lingual sessions  </span>
04657 <span class="comment">         */</span>
04658         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
04659         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
04660         <span class="keywordflow">return</span> 0;
04661     }
04662 
04663     <span class="comment">/*</span>
04664 <span class="comment">     * Build the message to send.  </span>
04665 <span class="comment">     */</span>
04666     <span class="keywordflow">if</span> (isp-&gt;hook_realloc_build) {
04667         result = isp-&gt;hook_realloc_build(session, pdu,
04668                                          &amp;pktbuf, &amp;pktbuf_len, &amp;offset);
04669         packet = pktbuf;
04670         length = offset;
04671     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isp-&gt;hook_build) {
04672         packet = pktbuf;
04673         length = pktbuf_len;
04674         result = isp-&gt;hook_build(session, pdu, pktbuf, &amp;length);
04675     } <span class="keywordflow">else</span> {
04676 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
04677         <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REVERSE_ENCODE)) {
04678             result =
04679                 snmp_build(&amp;pktbuf, &amp;pktbuf_len, &amp;offset, session, pdu);
04680             packet = pktbuf + pktbuf_len - offset;
04681             length = offset;
04682         } <span class="keywordflow">else</span> {
04683 <span class="preprocessor">#endif</span>
04684             packet = pktbuf;
04685             length = pktbuf_len;
04686             result = snmp_build(&amp;pktbuf, &amp;length, &amp;offset, session, pdu);
04687 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
04688         }
04689 <span class="preprocessor">#endif</span>
04690     }
04691 
04692     <span class="keywordflow">if</span> (result &lt; 0) {
04693         DEBUGMSGTL((<span class="stringliteral">"sess_async_send"</span>, <span class=
"stringliteral">"encoding failure\n"</span>));
04694         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
04695         <span class="keywordflow">return</span> 0;
04696     }
04697 
04698     <span class="comment">/*</span>
04699 <span class="comment">     * Make sure we don't send something that is bigger than the msgMaxSize</span>
04700 <span class="comment">     * specified in the received PDU.  </span>
04701 <span class="comment">     */</span>
04702 
04703     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o19">sndMsgMaxSize</a> != 0 &amp;&amp; length &gt; session-&gt;<a class="code" href=
"structsnmp__session.html#o19">sndMsgMaxSize</a>) {
04704         DEBUGMSGTL((<span class="stringliteral">"sess_async_send"</span>,
04705                     <span class="stringliteral">"length of packet (%lu) exceeds session maximum (%lu)\n"</span>,
04706                     length, session-&gt;<a class="code" href="structsnmp__session.html#o19">sndMsgMaxSize</a>));
04707         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_TOO_LONG;
04708         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
04709         <span class="keywordflow">return</span> 0;
04710     }
04711 
04712     <span class="comment">/*</span>
04713 <span class="comment">     * Check that the underlying transport is capable of sending a packet as</span>
04714 <span class="comment">     * large as length.  </span>
04715 <span class="comment">     */</span>
04716 
04717     <span class="keywordflow">if</span> (transport-&gt;msgMaxSize != 0 &amp;&amp; length &gt; transport-&gt;msgMaxSize) {
04718         DEBUGMSGTL((<span class="stringliteral">"sess_async_send"</span>,
04719                     <span class="stringliteral">"length of packet (%lu) exceeds transport maximum (%lu)\n"</span>,
04720                     length, transport-&gt;msgMaxSize));
04721         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_TOO_LONG;
04722         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
04723         <span class="keywordflow">return</span> 0;
04724     }
04725 
04726     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DUMP_PACKET)) {
04727         <span class="keywordflow">if</span> (transport-&gt;f_fmtaddr != NULL) {
04728             <span class="keywordtype">char</span>           *dest_txt =
04729                 transport-&gt;f_fmtaddr(transport, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o13">transport_data</a>,
04730                                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o14">transport_data_length</a>);
04731             <span class="keywordflow">if</span> (dest_txt != NULL) {
04732                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_DEBUG, <span class=
"stringliteral">"\nSending %u bytes to %s\n"</span>, length,
04733                          dest_txt);
04734                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(dest_txt);
04735             } <span class="keywordflow">else</span> {
04736                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_DEBUG, <span class=
"stringliteral">"\nSending %u bytes to &lt;UNKNOWN&gt;\n"</span>,
04737                          length);
04738             }
04739         }
04740         xdump(packet, length, <span class="stringliteral">""</span>);
04741     }
04742 
04743     <span class="comment">/*</span>
04744 <span class="comment">     * Send the message.  </span>
04745 <span class="comment">     */</span>
04746 
04747     result = transport-&gt;f_send(transport, packet, length,
04748                                &amp;(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o13">transport_data</a>),
04749                                &amp;(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o14">transport_data_length</a>));
04750 
04751     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
04752 
04753     <span class="keywordflow">if</span> (result &lt; 0) {
04754         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_SENDTO;
04755         session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = errno;
04756         <span class="keywordflow">return</span> 0;
04757     }
04758 
04759     reqid = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a>;
04760 
04761     <span class="comment">/*</span>
04762 <span class="comment">     * Add to pending requests list if we expect a response.  </span>
04763 <span class="comment">     */</span>
04764     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a> &amp; UCD_MSG_FLAG_EXPECT_RESPONSE) {
04765         netsnmp_request_list *rp;
04766         <span class="keyword">struct </span>timeval  tv;
04767 
04768         rp = (netsnmp_request_list *) calloc(1,
04769                                              <span class="keyword">sizeof</span>(netsnmp_request_list));
04770         <span class="keywordflow">if</span> (rp == NULL) {
04771             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_GENERR;
04772             <span class="keywordflow">return</span> 0;
04773         }
04774 
04775         gettimeofday(&amp;tv, (<span class="keyword">struct</span> timezone *) 0);
04776         rp-&gt;pdu = pdu;
04777         rp-&gt;request_id = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a>;
04778         rp-&gt;message_id = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a>;
04779         rp-&gt;callback = callback;
04780         rp-&gt;cb_data = cb_data;
04781         rp-&gt;retries = 0;
04782         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a> &amp; UCD_MSG_FLAG_PDU_TIMEOUT) {
04783             rp-&gt;timeout = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o8">time</a> * 1000000L;
04784         } <span class="keywordflow">else</span> {
04785             rp-&gt;timeout = session-&gt;<a class="code" href="structsnmp__session.html#o2">timeout</a>;
04786         }
04787         rp-&gt;time = tv;
04788         tv.tv_usec += rp-&gt;<a class="code" href="structsnmp__session.html#o2">timeout</a>;
04789         tv.tv_sec += tv.tv_usec / 1000000L;
04790         tv.tv_usec %= 1000000L;
04791         rp-&gt;expire = tv;
04792 
04793         <span class="comment">/*</span>
04794 <span class="comment">         * XX lock should be per session ! </span>
04795 <span class="comment">         */</span>
04796         snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
04797         <span class="keywordflow">if</span> (isp-&gt;requestsEnd) {
04798             rp-&gt;next_request = isp-&gt;requestsEnd-&gt;next_request;
04799             isp-&gt;requestsEnd-&gt;next_request = rp;
04800             isp-&gt;requestsEnd = rp;
04801         } <span class="keywordflow">else</span> {
04802             rp-&gt;next_request = isp-&gt;requests;
04803             isp-&gt;requests = rp;
04804             isp-&gt;requestsEnd = rp;
04805         }
04806         snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
04807     } <span class="keywordflow">else</span> {
04808         <span class="comment">/*</span>
04809 <span class="comment">         * No response expected...  </span>
04810 <span class="comment">         */</span>
04811         <span class="keywordflow">if</span> (reqid) {
04812             <span class="comment">/*</span>
04813 <span class="comment">             * Free v1 or v2 TRAP PDU iff no error  </span>
04814 <span class="comment">             */</span>
04815             snmp_free_pdu(pdu);
04816         }
04817     }
04818 
04819     <span class="keywordflow">return</span> reqid;
04820 }
04821 
04822 <span class="keywordtype">int</span>
04823 snmp_sess_async_send(<span class="keywordtype">void</span> *sessp,
04824                      <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
04825                      snmp_callback callback, <span class="keywordtype">void</span> *cb_data)
04826 {
04827     <span class="keywordtype">int</span>             rc;
04828 
04829     <span class="keywordflow">if</span> (sessp == NULL) {
04830         snmp_errno = SNMPERR_BAD_SESSION;       <span class="comment">/*MTCRITICAL_RESOURCE */</span>
04831         <span class="keywordflow">return</span> (0);
04832     }
04833     rc = _sess_async_send(sessp, pdu, callback, cb_data);
04834     <span class="keywordflow">if</span> (rc == 0) {
04835         <span class="keyword">struct </span>session_list *psl;
04836         netsnmp_session *pss;
04837         psl = (<span class="keyword">struct </span>session_list *) sessp;
04838         pss = psl-&gt;session;
04839         SET_SNMP_ERROR(pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
04840     }
04841     <span class="keywordflow">return</span> rc;
04842 }
04843 
04844 
04845 <span class="comment">/*</span>
04846 <span class="comment"> * Frees the variable and any malloc'd data associated with it.</span>
04847 <span class="comment"> */</span>
04848 <span class="keywordtype">void</span>
04849 snmp_free_var(<a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * var)
04850 {
04851     <span class="keywordflow">if</span> (!var)
04852         <span class="keywordflow">return</span>;
04853 
04854     <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a> != var-&gt;<a class="code" href="structvariable__list.html#o6">name_loc</a>)
04855         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(var-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>);
04856     <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string != var-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>)
04857         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string);
04858     <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#o8">data</a>) {
04859         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o9">dataFreeHook</a>) {
04860             var-&gt;<a class="code" href="structvariable__list.html#o9">dataFreeHook</a>(var-&gt;<a class="code" href=
"structvariable__list.html#o8">data</a>);
04861             var-&gt;<a class="code" href="structvariable__list.html#o8">data</a> = NULL;
04862         } <span class="keywordflow">else</span> {
04863             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(var-&gt;<a class="code" href=
"structvariable__list.html#o8">data</a>);
04864         }
04865     }
04866 
04867     free((<span class="keywordtype">char</span> *) var);
04868 }
04869 
04870 <span class="keywordtype">void</span>
04871 snmp_free_varbind(<a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * var)
04872 {
04873     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *ptr;
04874     <span class="keywordflow">while</span> (var) {
04875         ptr = var-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>;
04876         snmp_free_var(var);
04877         var = ptr;
04878     }
04879 }
04880 
04881 <span class="comment">/*</span>
04882 <span class="comment"> * Frees the pdu and any malloc'd data associated with it.</span>
04883 <span class="comment"> */</span>
04884 <span class="keywordtype">void</span>
04885 snmp_free_pdu(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
04886 {
04887     <span class="keyword">struct </span>snmp_secmod_def *sptr;
04888 
04889     <span class="keywordflow">if</span> (!pdu)
04890         <span class="keywordflow">return</span>;
04891 
04892     <span class="comment">/*</span>
04893 <span class="comment">     * If the command field is empty, that probably indicates</span>
04894 <span class="comment">     *   that this PDU structure has already been freed.</span>
04895 <span class="comment">     *   Log a warning and return (rather than freeing things again)</span>
04896 <span class="comment">     *</span>
04897 <span class="comment">     * Note that this does not pick up dual-frees where the</span>
04898 <span class="comment">     *   memory is set to random junk, which is probably more serious.</span>
04899 <span class="comment">     *</span>
04900 <span class="comment">     * rks: while this is a good idea, there are two problems.</span>
04901 <span class="comment">     *         1) agentx sets command to 0 in some cases</span>
04902 <span class="comment">     *         2) according to Wes, a bad decode of a v3 message could</span>
04903 <span class="comment">     *            result in a 0 at this offset.</span>
04904 <span class="comment">     *      so I'm commenting it out until a better solution is found.</span>
04905 <span class="comment">     *      note that I'm leaving the memset, below....</span>
04906 <span class="comment">     *</span>
04907 <span class="comment">    if (pdu-&gt;command == 0) {</span>
04908 <span class="comment">        snmp_log(LOG_WARNING, "snmp_free_pdu probably called twice\n");</span>
04909 <span class="comment">        return;</span>
04910 <span class="comment">    }</span>
04911 <span class="comment">     */</span>
04912     <span class="keywordflow">if</span> ((sptr = find_sec_mod(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o10">securityModel</a>)) != NULL &amp;&amp;
04913         sptr-&gt;pdu_free != NULL) {
04914         (*sptr-&gt;pdu_free) (pdu);
04915     }
04916     snmp_free_varbind(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>);
04917     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o20">enterprise</a>);
04918     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a>);
04919     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o25">contextEngineID</a>);
04920     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o29">securityEngineID</a>);
04921     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o27">contextName</a>);
04922     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o31">securityName</a>);
04923     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o13">transport_data</a>);
04924     memset(pdu, 0, <span class="keyword">sizeof</span>(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>));
04925     free((<span class="keywordtype">char</span> *) pdu);
04926 }
04927 
04928 <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>    *
04929 snmp_create_sess_pdu(netsnmp_transport *transport, <span class="keywordtype">void</span> *opaque,
04930                      size_t olength)
04931 {
04932     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu = (<a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *)calloc(1, <span class="keyword">sizeof</span>(<a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a>));
04933     <span class="keywordflow">if</span> (pdu == NULL) {
04934         DEBUGMSGTL((<span class="stringliteral">"sess_process_packet"</span>, <span class=
"stringliteral">"can't malloc space for PDU\n"</span>));
04935         <span class="keywordflow">return</span> NULL;
04936     }
04937 
04938     <span class="comment">/*</span>
04939 <span class="comment">     * Save the transport-level data specific to this reception (e.g. UDP</span>
04940 <span class="comment">     * source address).  </span>
04941 <span class="comment">     */</span>
04942 
04943     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o13">transport_data</a> = opaque;
04944     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o14">transport_data_length</a> = olength;
04945     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o15">tDomain</a> = transport-&gt;domain;
04946     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o16">tDomainLen</a> = transport-&gt;domain_length;
04947     <span class="keywordflow">return</span> pdu;
04948 }
04949 
04950 
04951 <span class="comment">/*</span>
04952 <span class="comment"> * This function processes a complete (according to asn_check_packet or the</span>
04953 <span class="comment"> * AgentX equivalent) packet, parsing it into a PDU and calling the relevant</span>
04954 <span class="comment"> * callbacks.  On entry, packetptr points at the packet in the session's</span>
04955 <span class="comment"> * buffer and length is the length of the packet.  </span>
04956 <span class="comment"> */</span>
04957 
04958 <span class="keyword">static</span> <span class="keywordtype">int</span>
04959 _sess_process_packet(<span class="keywordtype">void</span> *sessp, netsnmp_session * sp,
04960                      <span class="keyword">struct</span> snmp_internal_session *isp,
04961                      netsnmp_transport *transport,
04962                      <span class="keywordtype">void</span> *opaque, <span class="keywordtype">int</span> olength,
04963                      u_char * packetptr, <span class="keywordtype">int</span> length)
04964 {
04965   <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
04966   <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>    *pdu;
04967   netsnmp_request_list *rp, *orp = NULL;
04968   <span class="keyword">struct </span>snmp_secmod_def *sptr;
04969   <span class="keywordtype">int</span>             ret = 0, handled = 0;
04970 
04971   DEBUGMSGTL((<span class="stringliteral">"sess_process_packet"</span>,
04972               <span class="stringliteral">"session %p fd %d pkt %p length %d\n"</span>, sessp,
04973               transport-&gt;sock, packetptr, length));
04974 
04975   <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
04976                              NETSNMP_DS_LIB_DUMP_PACKET)) {
04977     <span class="keywordflow">if</span> (transport-&gt;f_fmtaddr != NULL) {
04978       <span class="keywordtype">char</span> *addrtxt = transport-&gt;f_fmtaddr(transport, opaque, olength);
04979       <span class="keywordflow">if</span> (addrtxt != NULL) {
04980         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_DEBUG, <span class=
"stringliteral">"\nReceived %d bytes from %s\n"</span>,
04981                  length, addrtxt);
04982         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(addrtxt);
04983       } <span class="keywordflow">else</span> {
04984         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_DEBUG, <span class=
"stringliteral">"\nReceived %d bytes from &lt;UNKNOWN&gt;\n"</span>,
04985                  length);
04986       }
04987     }
04988     xdump(packetptr, length, <span class="stringliteral">""</span>);
04989   }
04990 
04991   <span class="comment">/*</span>
04992 <span class="comment">   * Do transport-level filtering (e.g. IP-address based allow/deny).  </span>
04993 <span class="comment">   */</span>
04994 
04995   <span class="keywordflow">if</span> (isp-&gt;hook_pre) {
04996     <span class="keywordflow">if</span> (isp-&gt;hook_pre(sp, transport, opaque, olength) == 0) {
04997       DEBUGMSGTL((<span class="stringliteral">"sess_process_packet"</span>, <span class=
"stringliteral">"pre-parse fail\n"</span>));
04998       <span class="keywordflow">if</span> (opaque != NULL) {
04999         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05000       }
05001       <span class="keywordflow">return</span> -1;
05002     }
05003   }
05004 
05005   <span class="keywordflow">if</span> (isp-&gt;hook_create_pdu) {
05006     pdu = isp-&gt;hook_create_pdu(transport, opaque, olength);
05007   } <span class="keywordflow">else</span> {
05008     pdu = snmp_create_sess_pdu(transport, opaque, olength);
05009   }
05010   <span class="keywordflow">if</span> (pdu == NULL) {
05011     <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"pdu failed to be created\n"</span>);
05012     <span class="keywordflow">if</span> (opaque != NULL) {
05013       <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05014     }
05015     <span class="keywordflow">return</span> -1;
05016   }
05017 
05018   <span class="keywordflow">if</span> (isp-&gt;hook_parse) {
05019     ret = isp-&gt;hook_parse(sp, pdu, packetptr, length);
05020   } <span class="keywordflow">else</span> {
05021     ret = snmp_parse(sessp, sp, pdu, packetptr, length);
05022   }
05023 
05024   <span class="keywordflow">if</span> (ret != SNMP_ERR_NOERROR) {
05025     DEBUGMSGTL((<span class="stringliteral">"sess_process_packet"</span>, <span class=
"stringliteral">"parse fail\n"</span>));
05026   }
05027 
05028   <span class="keywordflow">if</span> (isp-&gt;hook_post) {
05029     <span class="keywordflow">if</span> (isp-&gt;hook_post(sp, pdu, ret) == 0) {
05030       DEBUGMSGTL((<span class="stringliteral">"sess_process_packet"</span>, <span class=
"stringliteral">"post-parse fail\n"</span>));
05031       ret = SNMPERR_ASN_PARSE_ERR;
05032     }
05033   }
05034 
05035   <span class="keywordflow">if</span> (ret != SNMP_ERR_NOERROR) {
05036     <span class="comment">/*</span>
05037 <span class="comment">     * Call the security model to free any securityStateRef supplied w/ msg.  </span>
05038 <span class="comment">     */</span>
05039     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o35">securityStateRef</a> != NULL) {
05040       sptr = find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05041       <span class="keywordflow">if</span> (sptr != NULL) {
05042         <span class="keywordflow">if</span> (sptr-&gt;pdu_free_state_ref != NULL) {
05043           (*sptr-&gt;pdu_free_state_ref) (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>);
05044         } <span class="keywordflow">else</span> {
05045           <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,
05046                    <span class="stringliteral">"Security Model %d can't free state references\n"</span>,
05047                    pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05048         }
05049       } <span class="keywordflow">else</span> {
05050         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,
05051                  <span class="stringliteral">"Can't find security model to free ptr: %d\n"</span>,
05052                  pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05053       }
05054       pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a> = NULL;
05055     }
05056     snmp_free_pdu(pdu);
05057     <span class="keywordflow">return</span> -1;
05058   }
05059 
05060   <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a> &amp; UCD_MSG_FLAG_RESPONSE_PDU) {
05061     <span class="comment">/*</span>
05062 <span class="comment">     * Call USM to free any securityStateRef supplied with the message.  </span>
05063 <span class="comment">     */</span>
05064     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>) {
05065       sptr = find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05066       <span class="keywordflow">if</span> (sptr) {
05067         <span class="keywordflow">if</span> (sptr-&gt;pdu_free_state_ref) {
05068           (*sptr-&gt;pdu_free_state_ref) (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>);
05069         } <span class="keywordflow">else</span> {
05070           <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,
05071                    <span class="stringliteral">"Security Model %d can't free state references\n"</span>,
05072                    pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05073         }
05074       } <span class="keywordflow">else</span> {
05075         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,
05076                  <span class="stringliteral">"Can't find security model to free ptr: %d\n"</span>,
05077                  pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05078       }
05079       pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a> = NULL;
05080     }
05081 
05082     <span class="keywordflow">for</span> (rp = isp-&gt;requests; rp; orp = rp, rp = rp-&gt;next_request) {
05083       snmp_callback   callback;
05084       <span class="keywordtype">void</span>           *magic;
05085 
05086       <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_3) {
05087         <span class="comment">/*</span>
05088 <span class="comment">         * msgId must match for v3 messages.  </span>
05089 <span class="comment">         */</span>
05090         <span class="keywordflow">if</span> (rp-&gt;message_id != pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o3">msgid</a>) {
05091           <span class="keywordflow">continue</span>;
05092         }
05093 
05094         <span class="comment">/*</span>
05095 <span class="comment">         * Check that message fields match original, if not, no further</span>
05096 <span class="comment">         * processing.  </span>
05097 <span class="comment">         */</span>
05098         <span class="keywordflow">if</span> (!snmpv3_verify_msg(rp, pdu)) {
05099           <span class="keywordflow">break</span>;
05100         }
05101       } <span class="keywordflow">else</span> {
05102         <span class="keywordflow">if</span> (rp-&gt;request_id != pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a>) {
05103           <span class="keywordflow">continue</span>;
05104         }
05105       }
05106 
05107       <span class="keywordflow">if</span> (rp-&gt;callback) {
05108         callback = rp-&gt;callback;
05109         magic = rp-&gt;cb_data;
05110       } <span class="keywordflow">else</span> {
05111         callback = sp-&gt;<a class="code" href="structsnmp__session.html#o11">callback</a>;
05112         magic = sp-&gt;<a class="code" href="structsnmp__session.html#o12">callback_magic</a>;
05113       }
05114       handled = 1;
05115 
05116       <span class="comment">/*</span>
05117 <span class="comment">       * MTR snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);  ?* XX lock</span>
05118 <span class="comment">       * should be per session ! </span>
05119 <span class="comment">       */</span>
05120 
05121       <span class="keywordflow">if</span> (callback == NULL
05122           || callback(NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE, sp,
05123                       pdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a>, pdu, magic) == 1) {
05124         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a> == SNMP_MSG_REPORT) {
05125           <span class="keywordflow">if</span> (sp-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> == SNMPERR_NOT_IN_TIME_WINDOW ||
05126               snmpv3_get_report_type(pdu) ==
05127               SNMPERR_NOT_IN_TIME_WINDOW) {
05128             <span class="comment">/*</span>
05129 <span class="comment">             * trigger immediate retry on recoverable Reports </span>
05130 <span class="comment">             * * (notInTimeWindow), incr_retries == TRUE to prevent</span>
05131 <span class="comment">             * * inifinite resend                      </span>
05132 <span class="comment">             */</span>
05133             <span class="keywordflow">if</span> (rp-&gt;retries &lt;= sp-&gt;<a class="code" href=
"structsnmp__session.html#o1">retries</a>) {
05134               snmp_resend_request(slp, rp, TRUE);
05135               <span class="keywordflow">break</span>;
05136             }
05137           } <span class="keywordflow">else</span> {
05138             <span class="keywordflow">if</span> (SNMPV3_IGNORE_UNAUTH_REPORTS) {
05139               <span class="keywordflow">break</span>;
05140             }
05141           }
05142 
05143           <span class="comment">/*</span>
05144 <span class="comment">           * Handle engineID discovery.  </span>
05145 <span class="comment">           */</span>
05146           <span class="keywordflow">if</span> (!sp-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a> &amp;&amp; pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o30">securityEngineIDLen</a>) {
05147             sp-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a> =
05148               (u_char *) malloc(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>);
05149             <span class="keywordflow">if</span> (sp-&gt;<a class="code" href=
"structsnmp__session.html#o27">securityEngineID</a> == NULL) {
05150               <span class="comment">/*</span>
05151 <span class="comment">               * TODO FIX: recover after message callback *?</span>
05152 <span class="comment">               * return -1;</span>
05153 <span class="comment">               */</span>
05154             }
05155             memcpy(sp-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>, pdu-&gt;<a class="code"
href="structsnmp__pdu.html#o29">securityEngineID</a>,
05156                    pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>);
05157             sp-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a> = pdu-&gt;<a class="code"
href="structsnmp__pdu.html#o30">securityEngineIDLen</a>;
05158             <span class="keywordflow">if</span> (!sp-&gt;<a class="code" href=
"structsnmp__session.html#o22">contextEngineIDLen</a>) {
05159               sp-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a> =
05160                 (u_char *) malloc(pdu-&gt;
05161                                   securityEngineIDLen);
05162               <span class="keywordflow">if</span> (sp-&gt;<a class="code" href=
"structsnmp__session.html#o21">contextEngineID</a> == NULL) {
05163                 <span class="comment">/*</span>
05164 <span class="comment">                 * TODO FIX: recover after message callback *?</span>
05165 <span class="comment">                 * return -1;</span>
05166 <span class="comment">                 */</span>
05167               }
05168               memcpy(sp-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a>,
05169                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>,
05170                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>);
05171               sp-&gt;<a class="code" href="structsnmp__session.html#o22">contextEngineIDLen</a> =
05172                 pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>;
05173             }
05174           }
05175         }
05176 
05177         <span class="comment">/*</span>
05178 <span class="comment">         * Successful, so delete request.  </span>
05179 <span class="comment">         */</span>
05180         <span class="keywordflow">if</span> (isp-&gt;requests == rp) {
05181           isp-&gt;requests = rp-&gt;next_request;
05182           <span class="keywordflow">if</span> (isp-&gt;requestsEnd == rp) {
05183             isp-&gt;requestsEnd = NULL;
05184           }
05185         } <span class="keywordflow">else</span> {
05186           orp-&gt;next_request = rp-&gt;next_request;
05187           <span class="keywordflow">if</span> (isp-&gt;requestsEnd == rp) {
05188             isp-&gt;requestsEnd = orp;
05189           }
05190         }
05191         snmp_free_pdu(rp-&gt;pdu);
05192         free((<span class="keywordtype">char</span> *) rp);
05193         <span class="comment">/*</span>
05194 <span class="comment">         * There shouldn't be any more requests with the same reqid.  </span>
05195 <span class="comment">         */</span>
05196         <span class="keywordflow">break</span>;
05197       }
05198       <span class="comment">/*</span>
05199 <span class=
"comment">       * MTR snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);  ?* XX lock should be per session ! </span>
05200 <span class="comment">       */</span>
05201     }
05202   } <span class="keywordflow">else</span> {
05203     <span class="keywordflow">if</span> (sp-&gt;<a class="code" href="structsnmp__session.html#o11">callback</a>) {
05204       <span class="comment">/*</span>
05205 <span class="comment">       * MTR snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION); </span>
05206 <span class="comment">       */</span>
05207       handled = 1;
05208       sp-&gt;<a class="code" href="structsnmp__session.html#o11">callback</a>(NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE,
05209                    sp, pdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a>, pdu, sp-&gt;<a class="code" href=
"structsnmp__session.html#o12">callback_magic</a>);
05210       <span class="comment">/*</span>
05211 <span class="comment">       * MTR snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION); </span>
05212 <span class="comment">       */</span>
05213     }
05214   }
05215 
05216   <span class="comment">/*</span>
05217 <span class="comment">   * Call USM to free any securityStateRef supplied with the message.  </span>
05218 <span class="comment">   */</span>
05219   <span class="keywordflow">if</span> (pdu != NULL &amp;&amp; pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o35">securityStateRef</a> &amp;&amp;
05220       pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> == SNMP_MSG_TRAP2) {
05221     sptr = find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05222     <span class="keywordflow">if</span> (sptr) {
05223       <span class="keywordflow">if</span> (sptr-&gt;pdu_free_state_ref) {
05224         (*sptr-&gt;pdu_free_state_ref) (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>);
05225       } <span class="keywordflow">else</span> {
05226         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,
05227                  <span class="stringliteral">"Security Model %d can't free state references\n"</span>,
05228                  pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05229       }
05230     } <span class="keywordflow">else</span> {
05231       <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,
05232                <span class="stringliteral">"Can't find security model to free ptr: %d\n"</span>,
05233                pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05234     }
05235     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a> = NULL;
05236   }
05237 
05238   <span class="keywordflow">if</span> (!handled) {
05239     snmp_increment_statistic(STAT_SNMPUNKNOWNPDUHANDLERS);
05240     DEBUGMSGTL((<span class="stringliteral">"sess_process_packet"</span>, <span class=
"stringliteral">"unhandled PDU\n"</span>));
05241   }
05242 
05243   snmp_free_pdu(pdu);
05244   <span class="keywordflow">return</span> 0;
05245 }
05246 
05247 <span class="comment">/*</span>
05248 <span class="comment"> * Checks to see if any of the fd's set in the fdset belong to</span>
05249 <span class="comment"> * snmp.  Each socket with it's fd set has a packet read from it</span>
05250 <span class="comment"> * and snmp_parse is called on the packet received.  The resulting pdu</span>
05251 <span class="comment"> * is passed to the callback routine for that session.  If the callback</span>
05252 <span class="comment"> * routine returns successfully, the pdu and it's request are deleted.</span>
05253 <span class="comment"> */</span>
05254 <span class="keywordtype">void</span>
05255 snmp_read(fd_set * fdset)
05256 {
05257     <span class="keyword">struct </span>session_list *slp;
05258     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
05259     <span class="keywordflow">for</span> (slp = Sessions; slp; slp = slp-&gt;next) {
05260         snmp_sess_read((<span class="keywordtype">void</span> *) slp, fdset);
05261     }
05262     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
05263 }
05264 
05265 <span class="comment">/*</span>
05266 <span class="comment"> * Same as snmp_read, but works just one session. </span>
05267 <span class="comment"> * returns 0 if success, -1 if fail </span>
05268 <span class="comment"> * MTR: can't lock here and at snmp_read </span>
05269 <span class="comment"> * Beware recursive send maybe inside snmp_read callback function. </span>
05270 <span class="comment"> */</span>
05271 <span class="keywordtype">int</span>
05272 _sess_read(<span class="keywordtype">void</span> *sessp, fd_set * fdset)
05273 {
05274     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
05275     netsnmp_session *sp = slp ? slp-&gt;session : NULL;
05276     <span class="keyword">struct </span>snmp_internal_session *isp = slp ? slp-&gt;internal : NULL;
05277     netsnmp_transport *transport = slp ? slp-&gt;transport : NULL;
05278     size_t          pdulen = 0, rxbuf_len = 65536;
05279     u_char         *rxbuf = NULL;
05280     <span class="keywordtype">int</span>             length = 0, olength = 0, rc = 0;
05281     <span class="keywordtype">void</span>           *opaque = NULL;
05282 
05283     <span class="keywordflow">if</span> (!sp || !isp || !transport) {
05284         DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"read fail: closing...\n"</span>));
05285         <span class="keywordflow">return</span> 0;
05286     }
05287 
05288     <span class="keywordflow">if</span> (!fdset || !(FD_ISSET(transport-&gt;sock, fdset))) {
05289         DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"not reading %d (fdset %p set %d)\n"</span>,
05290                     transport-&gt;sock, fdset,
05291                     fdset ? FD_ISSET(transport-&gt;sock, fdset) : -9));
05292         <span class="keywordflow">return</span> 0;
05293     }
05294 
05295     sp-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
05296     sp-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
05297 
05298     <span class="keywordflow">if</span> (transport-&gt;flags &amp; NETSNMP_TRANSPORT_FLAG_LISTEN) {
05299         <span class="keywordtype">int</span>             data_sock = transport-&gt;f_accept(transport);
05300 
05301         <span class="keywordflow">if</span> (data_sock &gt;= 0) {
05302             <span class="comment">/*</span>
05303 <span class="comment">             * We've successfully accepted a new stream-based connection.</span>
05304 <span class="comment">             * It's not too clear what should happen here if we are using the</span>
05305 <span class="comment">             * single-session API at this point.  Basically a "session</span>
05306 <span class="comment">             * accepted" callback is probably needed to hand the new session</span>
05307 <span class="comment">             * over to the application.</span>
05308 <span class="comment">             * </span>
05309 <span class="comment">             * However, for now, as in the original snmp_api, we will ASSUME</span>
05310 <span class="comment">             * that we're using the traditional API, and simply add the new</span>
05311 <span class="comment">             * session to the list.  Note we don't have to get the Session</span>
05312 <span class="comment">             * list lock here, because under that assumption we already hold</span>
05313 <span class="comment">             * it (this is also why we don't just use snmp_add).</span>
05314 <span class="comment">             * </span>
05315 <span class="comment">             * The moral of the story is: don't use listening stream-based</span>
05316 <span class="comment">             * transports in a multi-threaded environment because something</span>
05317 <span class="comment">             * will go HORRIBLY wrong (and also that SNMP/TCP is not trivial).</span>
05318 <span class="comment">             * </span>
05319 <span class="comment">             * Another open issue: what should happen to sockets that have</span>
05320 <span class="comment">             * been accept()ed from a listening socket when that original</span>
05321 <span class="comment">             * socket is closed?  If they are left open, then attempting to</span>
05322 <span class="comment">             * re-open the listening socket will fail, which is semantically</span>
05323 <span class="comment">             * confusing.  Perhaps there should be some kind of chaining in</span>
05324 <span class="comment">             * the transport structure so that they can all be closed.</span>
05325 <span class="comment">             * Discuss.  ;-)</span>
05326 <span class="comment">             */</span>
05327 
05328             netsnmp_transport *new_transport=netsnmp_transport_copy(transport);
05329             <span class="keywordflow">if</span> (new_transport != NULL) {
05330                 <span class="keyword">struct </span>session_list *nslp = NULL;
05331 
05332                 new_transport-&gt;sock = data_sock;
05333                 new_transport-&gt;<a class="code" href=
"structsnmp__session.html#o3">flags</a> &amp;= ~NETSNMP_TRANSPORT_FLAG_LISTEN;
05334 
05335                 nslp = (<span class="keyword">struct </span>session_list *)snmp_sess_add_ex(sp,
05336                           new_transport, isp-&gt;hook_pre, isp-&gt;hook_parse,
05337                           isp-&gt;hook_post, isp-&gt;hook_build,
05338                           isp-&gt;hook_realloc_build, isp-&gt;check_packet,
05339                           isp-&gt;hook_create_pdu);
05340 
05341                 <span class="keywordflow">if</span> (nslp != NULL) {
05342                     nslp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = Sessions;
05343                     Sessions = nslp;
05344                 } <span class="keywordflow">else</span> {
05345                     new_transport-&gt;f_close(new_transport);
05346                     netsnmp_transport_free(new_transport);
05347                 }
05348                 <span class="keywordflow">return</span> 0;
05349             } <span class="keywordflow">else</span> {
05350                 sp-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
05351                 sp-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = errno;
05352                 snmp_set_detail(strerror(errno));
05353                 <span class="keywordflow">return</span> -1;
05354             }
05355         } <span class="keywordflow">else</span> {
05356             sp-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_RECVFROM;
05357             sp-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = errno;
05358             snmp_set_detail(strerror(errno));
05359             <span class="keywordflow">return</span> -1;
05360         }
05361     }
05362 
05363     <span class="comment">/*</span>
05364 <span class="comment">     * Work out where to receive the data to.  </span>
05365 <span class="comment">     */</span>
05366 
05367     <span class="keywordflow">if</span> (transport-&gt;flags &amp; NETSNMP_TRANSPORT_FLAG_STREAM) {
05368         <span class="keywordflow">if</span> (isp-&gt;packet == NULL) {
05369             <span class="comment">/*</span>
05370 <span class="comment">             * We have no saved packet.  Allocate one.  </span>
05371 <span class="comment">             */</span>
05372             <span class="keywordflow">if</span> ((isp-&gt;packet = (u_char *) malloc(rxbuf_len)) == NULL) {
05373                 DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"can't malloc %d bytes for rxbuf\n"</span>,
05374                             rxbuf_len));
05375                 <span class="keywordflow">return</span> 0;
05376             } <span class="keywordflow">else</span> {
05377                 rxbuf = isp-&gt;packet;
05378                 isp-&gt;packet_size = rxbuf_len;
05379                 isp-&gt;packet_len = 0;
05380             }
05381         } <span class="keywordflow">else</span> {
05382             <span class="comment">/*</span>
05383 <span class="comment">             * We have saved a partial packet from last time.  Extend that, if</span>
05384 <span class="comment">             * necessary, and receive new data after the old data.  </span>
05385 <span class="comment">             */</span>
05386             u_char         *newbuf;
05387 
05388             <span class="keywordflow">if</span> (isp-&gt;packet_size &lt; isp-&gt;packet_len + rxbuf_len) {
05389                 newbuf =
05390                     (u_char *) realloc(isp-&gt;packet,
05391                                        isp-&gt;packet_len + rxbuf_len);
05392                 <span class="keywordflow">if</span> (newbuf == NULL) {
05393                     DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>,
05394                                 <span class="stringliteral">"can't malloc %d more for rxbuf (%d tot)\n"</span>,
05395                                 rxbuf_len, isp-&gt;packet_len + rxbuf_len));
05396                     <span class="keywordflow">return</span> 0;
05397                 } <span class="keywordflow">else</span> {
05398                     isp-&gt;packet = newbuf;
05399                     isp-&gt;packet_size = isp-&gt;packet_len + rxbuf_len;
05400                     rxbuf = isp-&gt;packet + isp-&gt;packet_len;
05401                 }
05402             } <span class="keywordflow">else</span> {
05403                 rxbuf = isp-&gt;packet + isp-&gt;packet_len;
05404                 rxbuf_len = isp-&gt;packet_size - isp-&gt;packet_len;
05405             }
05406         }
05407     } <span class="keywordflow">else</span> {
05408         <span class="keywordflow">if</span> ((rxbuf = (u_char *) malloc(rxbuf_len)) == NULL) {
05409             DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"can't malloc %d bytes for rxbuf\n"</span>,
05410                         rxbuf_len));
05411             <span class="keywordflow">return</span> 0;
05412         }
05413     }
05414 
05415     length = transport-&gt;f_recv(transport, rxbuf, rxbuf_len, &amp;opaque, &amp;olength);
05416 
05417     <span class=
"keywordflow">if</span> (length == -1 &amp;&amp; !(transport-&gt;flags &amp; NETSNMP_TRANSPORT_FLAG_STREAM)) {
05418         sp-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_RECVFROM;
05419         sp-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = errno;
05420         snmp_set_detail(strerror(errno));
05421         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(rxbuf);
05422         <span class="keywordflow">if</span> (opaque != NULL) {
05423             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05424         }
05425         <span class="keywordflow">return</span> -1;
05426     }
05427 
05428     <span class="comment">/*</span>
05429 <span class="comment">     * Remote end closed connection.  </span>
05430 <span class="comment">     */</span>
05431 
05432     <span class=
"keywordflow">if</span> (length &lt;= 0 &amp;&amp; transport-&gt;flags &amp; NETSNMP_TRANSPORT_FLAG_STREAM) {
05433         <span class="comment">/*</span>
05434 <span class="comment">         * Alert the application if possible.  </span>
05435 <span class="comment">         */</span>
05436         <span class="keywordflow">if</span> (sp-&gt;<a class="code" href=
"structsnmp__session.html#o11">callback</a> != NULL) {
05437             DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"perform callback with op=DISCONNECT\n"</span>));
05438             (void) sp-&gt;<a class="code" href=
"structsnmp__session.html#o11">callback</a>(NETSNMP_CALLBACK_OP_DISCONNECT, sp, 0,
05439                                 NULL, sp-&gt;<a class="code" href="structsnmp__session.html#o12">callback_magic</a>);
05440         }
05441         <span class="comment">/*</span>
05442 <span class="comment">         * Close socket and mark session for deletion.  </span>
05443 <span class="comment">         */</span>
05444         DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"fd %d closed\n"</span>, transport-&gt;sock));
05445         transport-&gt;f_close(transport);
05446         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(rxbuf);
05447         isp-&gt;packet = NULL;
05448         <span class="keywordflow">if</span> (opaque != NULL) {
05449             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05450         }
05451         <span class="keywordflow">return</span> -1;
05452     }
05453 
05454     <span class="keywordflow">if</span> (transport-&gt;flags &amp; NETSNMP_TRANSPORT_FLAG_STREAM) {
05455         u_char *pptr = isp-&gt;packet;
05456         <span class="keywordtype">void</span> *ocopy = NULL;
05457 
05458         isp-&gt;packet_len += length;
05459 
05460         <span class="keywordflow">while</span> (isp-&gt;packet_len &gt; 0) {
05461 
05462             <span class="comment">/*</span>
05463 <span class="comment">             * Get the total data length we're expecting (and need to wait</span>
05464 <span class="comment">             * for).</span>
05465 <span class="comment">             */</span>
05466             <span class="keywordflow">if</span> (isp-&gt;check_packet) {
05467                 pdulen = isp-&gt;check_packet(pptr, isp-&gt;packet_len);
05468             } <span class="keywordflow">else</span> {
05469                 pdulen = asn_check_packet(pptr, isp-&gt;packet_len);
05470             }
05471 
05472             DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"  loop packet_len %d, PDU length %d\n"</span>,
05473                         isp-&gt;packet_len, pdulen));
05474 
05475             <span class="keywordflow">if</span> (pdulen &gt; MAX_PACKET_LENGTH) {
05476                 <span class="comment">/*</span>
05477 <span class="comment">                 * Illegal length, drop the connection.  </span>
05478 <span class="comment">                 */</span>
05479                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, 
05480                          <span class="stringliteral">"Maximum packet size exceeded in a request.\n"</span>);
05481                 <span class="keywordflow">if</span> (sp-&gt;<a class="code" href=
"structsnmp__session.html#o11">callback</a> != NULL) {
05482                   DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>,
05483                               <span class="stringliteral">"perform callback with op=DISCONNECT\n"</span>));
05484                   (void)sp-&gt;<a class="code" href=
"structsnmp__session.html#o11">callback</a>(NETSNMP_CALLBACK_OP_DISCONNECT,
05485                                      sp, 0, NULL, sp-&gt;<a class="code" href=
"structsnmp__session.html#o12">callback_magic</a>);
05486                 }
05487                 DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"fd %d closed\n"</span>, transport-&gt;sock));
05488                 transport-&gt;f_close(transport);
05489                 <span class="keywordflow">if</span> (opaque != NULL) {
05490                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05491                 }
05492                 <span class="keywordflow">return</span> -1;
05493             }
05494 
05495             <span class="keywordflow">if</span> (pdulen &gt; isp-&gt;packet_len) {
05496                 <span class="comment">/*</span>
05497 <span class="comment">                 * We don't have a complete packet yet.  Return, and wait for</span>
05498 <span class="comment">                 * more data to arrive.</span>
05499 <span class="comment">                 */</span>
05500                 DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>,
05501                             <span class="stringliteral">"pkt not complete (need %d got %d so far)\n"</span>,
05502                             pdulen, isp-&gt;packet_len));
05503                 <span class="keywordflow">if</span> (opaque != NULL) {
05504                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05505                 }
05506                 <span class="keywordflow">return</span> 0;
05507             }
05508 
05509             <span class="comment">/*  We have *at least* one complete packet in the buffer now.  If</span>
05510 <span class="comment">                we have possibly more than one packet, we must copy the opaque</span>
05511 <span class="comment">                pointer because we may need to reuse it for a later packet.  */</span>
05512 
05513             <span class="keywordflow">if</span> (pdulen &lt; isp-&gt;packet_len) {
05514                 <span class="keywordflow">if</span> (olength &gt; 0 &amp;&amp; opaque != NULL) {
05515                     ocopy = malloc(olength);
05516                     <span class="keywordflow">if</span> (ocopy != NULL) {
05517                         memcpy(ocopy, opaque, olength);
05518                     }
05519                 }
05520             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pdulen == isp-&gt;packet_len) {
05521                 <span class="comment">/*  Common case -- exactly one packet.  No need to copy the</span>
05522 <span class="comment">                    opaque pointer.  */</span>
05523                 ocopy = opaque;
05524                 opaque = NULL;
05525             }
05526 
05527             <span class="keywordflow">if</span> ((rc = _sess_process_packet(sessp, sp, isp, transport,
05528                                            ocopy, ocopy?olength:0, pptr,
05529                                            pdulen))) {
05530                 <span class="comment">/*</span>
05531 <span class="comment">                 * Something went wrong while processing this packet -- set the</span>
05532 <span class="comment">                 * errno.  </span>
05533 <span class="comment">                 */</span>
05534                 <span class="keywordflow">if</span> (sp-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> != 0) {
05535                     SET_SNMP_ERROR(sp-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
05536                 }
05537             }
05538 
05539             <span class="comment">/*  ocopy has been free()d by _sess_process_packet by this point,</span>
05540 <span class="comment">                so set it to NULL.  */</span>
05541 
05542             ocopy = NULL;
05543 
05544             <span class="comment">/*  Step past the packet we've just dealt with.  */</span>
05545 
05546             pptr += pdulen;
05547             isp-&gt;packet_len -= pdulen;
05548         }
05549 
05550         <span class="comment">/*  If we had more than one packet, then we were working with copies</span>
05551 <span class="comment">            of the opaque pointer, so we still need to free() the opaque</span>
05552 <span class="comment">            pointer itself.  */</span>
05553 
05554         <span class="keywordflow">if</span> (opaque != NULL) {
05555             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05556         }
05557 
05558         <span class="keywordflow">if</span> (isp-&gt;packet_len &gt;= MAXIMUM_PACKET_SIZE) {
05559             <span class="comment">/*</span>
05560 <span class="comment">             * Obviously this should never happen!  </span>
05561 <span class="comment">             */</span>
05562             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,
05563                      <span class="stringliteral">"too large packet_len = %d, dropping connection %d\n"</span>,
05564                      isp-&gt;packet_len, transport-&gt;sock);
05565             transport-&gt;f_close(transport);
05566             <span class="keywordflow">return</span> -1;
05567         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isp-&gt;packet_len == 0) {
05568             <span class="comment">/*</span>
05569 <span class="comment">             * This is good: it means the packet buffer contained an integral</span>
05570 <span class="comment">             * number of PDUs, so we don't have to save any data for next</span>
05571 <span class="comment">             * time.  We can free() the buffer now to keep the memory</span>
05572 <span class="comment">             * footprint down.</span>
05573 <span class="comment">             */</span>
05574             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(isp-&gt;packet);
05575             isp-&gt;packet = NULL;
05576             isp-&gt;packet_size = 0;
05577             isp-&gt;packet_len = 0;
05578             <span class="keywordflow">return</span> rc;
05579         }
05580 
05581         <span class="comment">/*</span>
05582 <span class="comment">         * If we get here, then there is a partial packet of length</span>
05583 <span class="comment">         * isp-&gt;packet_len bytes starting at pptr left over.  Move that to the</span>
05584 <span class="comment">         * start of the buffer, and then realloc() the buffer down to size to</span>
05585 <span class="comment">         * reduce the memory footprint.  </span>
05586 <span class="comment">         */</span>
05587 
05588         memmove(isp-&gt;packet, pptr, isp-&gt;packet_len);
05589         DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"end: memmove(%p, %p, %d); realloc(%p, %d)\n"</span>,
05590                     isp-&gt;packet, pptr, isp-&gt;packet_len, isp-&gt;packet,
05591                     isp-&gt;packet_len));
05592 
05593         <span class="keywordflow">if</span> ((rxbuf = realloc(isp-&gt;packet, isp-&gt;packet_len)) == NULL) {
05594             <span class="comment">/*</span>
05595 <span class="comment">             * I don't see why this should ever fail, but it's not a big deal.</span>
05596 <span class="comment">             */</span>
05597             DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"realloc() failed\n"</span>));
05598         } <span class="keywordflow">else</span> {
05599             DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"realloc() okay, old buffer %p, new %p\n"</span>,
05600                         isp-&gt;packet, rxbuf));
05601             isp-&gt;packet = rxbuf;
05602             isp-&gt;packet_size = isp-&gt;packet_len;
05603         }
05604         <span class="keywordflow">return</span> rc;
05605     } <span class="keywordflow">else</span> {
05606         rc = _sess_process_packet(sessp, sp, isp, transport, opaque,
05607                                   olength, rxbuf, length);
05608         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(rxbuf);
05609         <span class="keywordflow">return</span> rc;
05610     }
05611 }
05612 
05613 
05614 
05615 <span class="comment">/*</span>
05616 <span class="comment"> * returns 0 if success, -1 if fail </span>
05617 <span class="comment"> */</span>
05618 <span class="keywordtype">int</span>
05619 snmp_sess_read(<span class="keywordtype">void</span> *sessp, fd_set * fdset)
05620 {
05621     <span class="keyword">struct </span>session_list *psl;
05622     netsnmp_session *pss;
05623     <span class="keywordtype">int</span>             rc;
05624 
05625     rc = _sess_read(sessp, fdset);
05626     psl = (<span class="keyword">struct </span>session_list *) sessp;
05627     pss = psl-&gt;session;
05628     <span class="keywordflow">if</span> (rc &amp;&amp; pss-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a>) {
05629         SET_SNMP_ERROR(pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
05630     }
05631     <span class="keywordflow">return</span> rc;
05632 }
05633 
05634 
05635 <span class="comment">/*</span>
05636 <span class="comment"> * Returns info about what snmp requires from a select statement.</span>
05637 <span class="comment"> * numfds is the number of fds in the list that are significant.</span>
05638 <span class="comment"> * All file descriptors opened for SNMP are OR'd into the fdset.</span>
05639 <span class="comment"> * If activity occurs on any of these file descriptors, snmp_read</span>
05640 <span class="comment"> * should be called with that file descriptor set</span>
05641 <span class="comment"> *</span>
05642 <span class="comment"> * The timeout is the latest time that SNMP can wait for a timeout.  The</span>
05643 <span class="comment"> * select should be done with the minimum time between timeout and any other</span>
05644 <span class="comment"> * timeouts necessary.  This should be checked upon each invocation of select.</span>
05645 <span class="comment"> * If a timeout is received, snmp_timeout should be called to check if the</span>
05646 <span class="comment"> * timeout was for SNMP.  (snmp_timeout is idempotent)</span>
05647 <span class="comment"> *</span>
05648 <span class="comment"> * The value of block indicates how the timeout value is interpreted.</span>
05649 <span class="comment"> * If block is true on input, the timeout value will be treated as undefined,</span>
05650 <span class="comment"> * but it must be available for setting in snmp_select_info.  On return,</span>
05651 <span class="comment"> * block is set to true if the value returned for timeout is undefined;</span>
05652 <span class="comment"> * when block is set to false, timeout may be used as a parmeter to 'select'.</span>
05653 <span class="comment"> *</span>
05654 <span class="comment"> * snmp_select_info returns the number of open sockets.  (i.e. The number of</span>
05655 <span class="comment"> * sessions open)</span>
05656 <span class="comment"> */</span>
05657 
05658 <span class="keywordtype">int</span>
05659 snmp_select_info(<span class="keywordtype">int</span> *numfds,
05660                  fd_set * fdset, <span class="keyword">struct</span> timeval *timeout, <span class=
"keywordtype">int</span> *block)
05661     <span class="comment">/*</span>
05662 <span class="comment">     * input:  set to 1 if input timeout value is undefined  </span>
05663 <span class="comment">     * set to 0 if input timeout value is defined    </span>
05664 <span class="comment">     * output: set to 1 if output timeout value is undefined </span>
05665 <span class="comment">     * set to 0 if output rimeout vlaue id defined   </span>
05666 <span class="comment">     */</span>
05667 {
05668     <span class="keywordflow">return</span> snmp_sess_select_info((<span class=
"keywordtype">void</span> *) 0, numfds, fdset, timeout,
05669                                  block);
05670 }
05671 
05672 <span class="comment">/*</span>
05673 <span class="comment"> * Same as snmp_select_info, but works just one session. </span>
05674 <span class="comment"> */</span>
05675 <span class="keywordtype">int</span>
05676 snmp_sess_select_info(<span class="keywordtype">void</span> *sessp,
05677                       <span class="keywordtype">int</span> *numfds,
05678                       fd_set * fdset, <span class="keyword">struct</span> timeval *timeout, <span class=
"keywordtype">int</span> *block)
05679 {
05680     <span class="keyword">struct </span>session_list *slptest = (<span class="keyword">struct </span>session_list *) sessp;
05681     <span class="keyword">struct </span>session_list *slp, *next = NULL;
05682     netsnmp_request_list *rp;
05683     <span class="keyword">struct </span>timeval  now, earliest, delta;
05684     <span class="keywordtype">int</span>             active = 0, requests = 0;
05685     <span class="keywordtype">int</span>             next_alarm = 0;
05686 
05687     timerclear(&amp;earliest);
05688 
05689     <span class="comment">/*</span>
05690 <span class="comment">     * For each request outstanding, add its socket to the fdset,</span>
05691 <span class="comment">     * and if it is the earliest timeout to expire, mark it as lowest.</span>
05692 <span class="comment">     * If a single session is specified, do just for that session.</span>
05693 <span class="comment">     */</span>
05694 
05695     <span class="keywordflow">if</span> (sessp) {
05696         slp = slptest;
05697     } <span class="keywordflow">else</span> {
05698         slp = Sessions;
05699     }
05700 
05701     DEBUGMSGTL((<span class="stringliteral">"sess_select"</span>, <span class="stringliteral">"for %s session%s: "</span>,
05702                 sessp ? <span class="stringliteral">"single"</span> : <span class=
"stringliteral">"all"</span>, sessp ? <span class="stringliteral">""</span> : <span class="stringliteral">"s"</span>));
05703 
05704     <span class="keywordflow">for</span> (; slp; slp = next) {
05705         next = slp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
05706 
05707         <span class="keywordflow">if</span> (slp-&gt;transport == NULL) {
05708             <span class="comment">/*</span>
05709 <span class="comment">             * Close in progress -- skip this one.  </span>
05710 <span class="comment">             */</span>
05711             DEBUGMSG((<span class="stringliteral">"sess_select"</span>, <span class="stringliteral">"skip "</span>));
05712             <span class="keywordflow">continue</span>;
05713         }
05714 
05715         <span class="keywordflow">if</span> (slp-&gt;transport-&gt;sock == -1) {
05716             <span class="comment">/*</span>
05717 <span class="comment">             * This session was marked for deletion.  </span>
05718 <span class="comment">             */</span>
05719             DEBUGMSG((<span class="stringliteral">"sess_select"</span>, <span class="stringliteral">"delete\n"</span>));
05720             <span class="keywordflow">if</span> (sessp == NULL) {
05721                 snmp_close(slp-&gt;session);
05722             } <span class="keywordflow">else</span> {
05723                 snmp_sess_close(slp);
05724             }
05725             DEBUGMSGTL((<span class="stringliteral">"sess_select"</span>, <span class=
"stringliteral">"for %s session%s: "</span>,
05726                         sessp ? <span class="stringliteral">"single"</span> : <span class=
"stringliteral">"all"</span>, sessp ? <span class="stringliteral">""</span> : <span class="stringliteral">"s"</span>));
05727             <span class="keywordflow">continue</span>;
05728         }
05729 
05730         DEBUGMSG((<span class="stringliteral">"sess_select"</span>, <span class=
"stringliteral">"%d "</span>, slp-&gt;transport-&gt;sock));
05731         <span class="keywordflow">if</span> ((slp-&gt;transport-&gt;sock + 1) &gt; *numfds) {
05732             *numfds = (slp-&gt;transport-&gt;sock + 1);
05733         }
05734 
05735         FD_SET(slp-&gt;transport-&gt;sock, fdset);
05736         <span class="keywordflow">if</span> (slp-&gt;internal != NULL &amp;&amp; slp-&gt;internal-&gt;requests) {
05737             <span class="comment">/*</span>
05738 <span class="comment">             * Found another session with outstanding requests.  </span>
05739 <span class="comment">             */</span>
05740             requests++;
05741             <span class="keywordflow">for</span> (rp = slp-&gt;internal-&gt;requests; rp; rp = rp-&gt;next_request) {
05742                 <span class="keywordflow">if</span> ((!timerisset(&amp;earliest)
05743                      || (timercmp(&amp;rp-&gt;expire, &amp;earliest, &lt;)))) {
05744                     earliest = rp-&gt;expire;
05745                     DEBUGMSG((<span class="stringliteral">"verbose:sess_select"</span>,<span class=
"stringliteral">"(to in %d.%d sec) "</span>,
05746                                earliest.tv_sec, earliest.tv_usec));
05747                 }
05748             }
05749         }
05750 
05751         active++;
05752         <span class="keywordflow">if</span> (sessp) {
05753             <span class="comment">/*</span>
05754 <span class="comment">             * Single session processing.  </span>
05755 <span class="comment">             */</span>
05756             <span class="keywordflow">break</span>;
05757         }
05758     }
05759     DEBUGMSG((<span class="stringliteral">"sess_select"</span>, <span class="stringliteral">"\n"</span>));
05760 
05761     <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ALARM_DONT_USE_SIG)) {
05762         next_alarm = get_next_alarm_delay_time(&amp;delta);
05763         DEBUGMSGT((<span class="stringliteral">"sess_select"</span>,<span class=
"stringliteral">"next alarm %d.%d sec\n"</span>,
05764                    delta.tv_sec, delta.tv_usec));
05765     }
05766     <span class="keywordflow">if</span> (next_alarm == 0 &amp;&amp; requests == 0) {
05767         <span class="comment">/*</span>
05768 <span class="comment">         * If none are active, skip arithmetic.  </span>
05769 <span class="comment">         */</span>
05770         DEBUGMSGT((<span class="stringliteral">"sess_select"</span>,<span class=
"stringliteral">"blocking:no session requests or alarms.\n"</span>));
05771         *block = 1; <span class="comment">/* can block - timeout value is undefined if no requests */</span>
05772         <span class="keywordflow">return</span> active;
05773     }
05774 
05775     <span class="comment">/*</span>
05776 <span class="comment">     * * Now find out how much time until the earliest timeout.  This</span>
05777 <span class="comment">     * * transforms earliest from an absolute time into a delta time, the</span>
05778 <span class="comment">     * * time left until the select should timeout.</span>
05779 <span class="comment">     */</span>
05780     gettimeofday(&amp;now, (<span class="keyword">struct</span> timezone *) 0);
05781     <span class="comment">/*</span>
05782 <span class="comment">     * Now = now;</span>
05783 <span class="comment">     */</span>
05784 
05785     <span class="keywordflow">if</span> (next_alarm) {
05786         delta.tv_sec += now.tv_sec;
05787         delta.tv_usec += now.tv_usec;
05788         <span class="keywordflow">while</span> (delta.tv_usec &gt;= 1000000) {
05789             delta.tv_usec -= 1000000;
05790             delta.tv_sec += 1;
05791         }
05792         <span class="keywordflow">if</span> (!timerisset(&amp;earliest) ||
05793             ((earliest.tv_sec &gt; delta.tv_sec) ||
05794              ((earliest.tv_sec == delta.tv_sec) &amp;&amp;
05795               (earliest.tv_usec &gt; delta.tv_usec)))) {
05796             earliest.tv_sec = delta.tv_sec;
05797             earliest.tv_usec = delta.tv_usec;
05798         }
05799     }
05800 
05801     <span class="keywordflow">if</span> (earliest.tv_sec &lt; now.tv_sec) {
05802         DEBUGMSGT((<span class="stringliteral">"verbose:sess_select"</span>,<span class=
"stringliteral">"timer overdue\n"</span>));
05803         earliest.tv_sec = 0;
05804         earliest.tv_usec = 0;
05805     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (earliest.tv_sec == now.tv_sec) {
05806         earliest.tv_sec = 0;
05807         earliest.tv_usec = (earliest.tv_usec - now.tv_usec);
05808         <span class="keywordflow">if</span> (earliest.tv_usec &lt; 0) {
05809             earliest.tv_usec = 100;
05810         }
05811         DEBUGMSGT((<span class="stringliteral">"verbose:sess_select"</span>,<span class=
"stringliteral">"timer due *real* soon. %d usec\n"</span>,
05812                    earliest.tv_usec));
05813     } <span class="keywordflow">else</span> {
05814         earliest.tv_sec = (earliest.tv_sec - now.tv_sec);
05815         earliest.tv_usec = (earliest.tv_usec - now.tv_usec);
05816         <span class="keywordflow">if</span> (earliest.tv_usec &lt; 0) {
05817             earliest.tv_sec--;
05818             earliest.tv_usec = (1000000L + earliest.tv_usec);
05819         }
05820         DEBUGMSGT((<span class="stringliteral">"verbose:sess_select"</span>,<span class=
"stringliteral">"timer due in %d.%d sec\n"</span>,
05821                    earliest.tv_sec, earliest.tv_usec));
05822     }
05823 
05824     <span class="comment">/*</span>
05825 <span class="comment">     * if it was blocking before or our delta time is less, reset timeout </span>
05826 <span class="comment">     */</span>
05827     <span class="keywordflow">if</span> ((*block || (timercmp(&amp;earliest, timeout, &lt;)))) {
05828         DEBUGMSGT((<span class="stringliteral">"verbose:sess_select"</span>,
05829                    <span class="stringliteral">"setting timer to %d.%d sec, clear block (was %d)\n"</span>,
05830                    earliest.tv_sec, earliest.tv_usec, *block));
05831         *timeout = earliest;
05832         *block = 0;
05833     }
05834     <span class="keywordflow">return</span> active;
05835 }
05836 
05837 <span class="comment">/*</span>
05838 <span class="comment"> * snmp_timeout should be called whenever the timeout from snmp_select_info</span>
05839 <span class="comment"> * expires, but it is idempotent, so snmp_timeout can be polled (probably a</span>
05840 <span class="comment"> * cpu expensive proposition).  snmp_timeout checks to see if any of the</span>
05841 <span class="comment"> * sessions have an outstanding request that has timed out.  If it finds one</span>
05842 <span class="comment"> * (or more), and that pdu has more retries available, a new packet is formed</span>
05843 <span class="comment"> * from the pdu and is resent.  If there are no more retries available, the</span>
05844 <span class="comment"> *  callback for the session is used to alert the user of the timeout.</span>
05845 <span class="comment"> */</span>
05846 <span class="keywordtype">void</span>
05847 snmp_timeout(<span class="keywordtype">void</span>)
05848 {
05849     <span class="keyword">struct </span>session_list *slp;
05850     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
05851     <span class="keywordflow">for</span> (slp = Sessions; slp; slp = slp-&gt;next) {
05852         snmp_sess_timeout((<span class="keywordtype">void</span> *) slp);
05853     }
05854     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
05855 }
05856 
05857 <span class="keyword">static</span> <span class="keywordtype">int</span>
05858 snmp_resend_request(<span class="keyword">struct</span> session_list *slp, netsnmp_request_list *rp,
05859                     <span class="keywordtype">int</span> incr_retries)
05860 {
05861     <span class="keyword">struct </span>snmp_internal_session *isp;
05862     netsnmp_session *sp;
05863     netsnmp_transport *transport;
05864     u_char         *pktbuf = NULL, *packet = NULL;
05865     size_t          pktbuf_len = 0, offset = 0, length = 0;
05866     <span class="keyword">struct </span>timeval  tv, now;
05867     <span class="keywordtype">int</span>             result = 0;
05868 
05869     sp = slp-&gt;session;
05870     isp = slp-&gt;internal;
05871     transport = slp-&gt;transport;
05872     <span class="keywordflow">if</span> (!sp || !isp || !transport) {
05873         DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"resend fail: closing...\n"</span>));
05874         <span class="keywordflow">return</span> 0;
05875     }
05876 
05877     <span class="keywordflow">if</span> ((pktbuf = malloc(2048)) == NULL) {
05878         DEBUGMSGTL((<span class="stringliteral">"sess_resend"</span>,
05879                     <span class="stringliteral">"couldn't malloc initial packet buffer\n"</span>));
05880         <span class="keywordflow">return</span> 0;
05881     } <span class="keywordflow">else</span> {
05882         pktbuf_len = 2048;
05883     }
05884 
05885     <span class="keywordflow">if</span> (incr_retries) {
05886         rp-&gt;<a class="code" href="structsnmp__session.html#o1">retries</a>++;
05887     }
05888 
05889     <span class="comment">/*</span>
05890 <span class="comment">     * Always increment msgId for resent messages.  </span>
05891 <span class="comment">     */</span>
05892     rp-&gt;pdu-&gt;msgid = rp-&gt;message_id = snmp_get_next_msgid();
05893 
05894     <span class="keywordflow">if</span> (isp-&gt;hook_realloc_build) {
05895         result = isp-&gt;hook_realloc_build(sp, rp-&gt;pdu,
05896                                          &amp;pktbuf, &amp;pktbuf_len, &amp;offset);
05897 
05898         packet = pktbuf;
05899         length = offset;
05900     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isp-&gt;hook_build) {
05901         packet = pktbuf;
05902         length = pktbuf_len;
05903         result = isp-&gt;hook_build(sp, rp-&gt;pdu, pktbuf, &amp;length);
05904     } <span class="keywordflow">else</span> {
05905 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
05906         <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REVERSE_ENCODE)) {
05907             result =
05908                 snmp_build(&amp;pktbuf, &amp;pktbuf_len, &amp;offset, sp, rp-&gt;pdu);
05909             packet = pktbuf + pktbuf_len - offset;
05910             length = offset;
05911         } <span class="keywordflow">else</span> {
05912 <span class="preprocessor">#endif</span>
05913             packet = pktbuf;
05914             length = pktbuf_len;
05915             result = snmp_build(&amp;pktbuf, &amp;length, &amp;offset, sp, rp-&gt;pdu);
05916 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
05917         }
05918 <span class="preprocessor">#endif</span>
05919     }
05920 
05921     <span class="keywordflow">if</span> (result &lt; 0) {
05922         <span class="comment">/*</span>
05923 <span class="comment">         * This should never happen.  </span>
05924 <span class="comment">         */</span>
05925         DEBUGMSGTL((<span class="stringliteral">"sess_resend"</span>, <span class=
"stringliteral">"encoding failure\n"</span>));
05926         <span class="keywordflow">if</span> (pktbuf != NULL) {
05927             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
05928         }
05929         <span class="keywordflow">return</span> -1;
05930     }
05931 
05932     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DUMP_PACKET)) {
05933         <span class="keywordflow">if</span> (transport-&gt;f_fmtaddr != NULL) {
05934             <span class="keywordtype">char</span>           *string = NULL;
05935             string =
05936                 transport-&gt;f_fmtaddr(transport, rp-&gt;pdu-&gt;transport_data,
05937                                      rp-&gt;pdu-&gt;transport_data_length);
05938             <span class="keywordflow">if</span> (string != NULL) {
05939                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_DEBUG, <span class=
"stringliteral">"\nResending %d bytes to %s\n"</span>, length,
05940                          string);
05941                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(string);
05942             } <span class="keywordflow">else</span> {
05943                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_DEBUG, <span class=
"stringliteral">"\nResending %d bytes to &lt;UNKNOWN&gt;\n"</span>,
05944                          length);
05945             }
05946         }
05947         xdump(packet, length, <span class="stringliteral">""</span>);
05948     }
05949 
05950     result = transport-&gt;f_send(transport, packet, length,
05951                                &amp;(rp-&gt;pdu-&gt;transport_data),
05952                                &amp;(rp-&gt;pdu-&gt;transport_data_length));
05953 
05954     <span class="comment">/*</span>
05955 <span class="comment">     * We are finished with the local packet buffer, if we allocated one (due</span>
05956 <span class="comment">     * to there being no saved packet).  </span>
05957 <span class="comment">     */</span>
05958 
05959     <span class="keywordflow">if</span> (pktbuf != NULL) {
05960         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
05961         pktbuf = packet = NULL;
05962     }
05963 
05964     <span class="keywordflow">if</span> (result &lt; 0) {
05965         sp-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_SENDTO;
05966         sp-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = errno;
05967         snmp_set_detail(strerror(errno));
05968         <span class="keywordflow">return</span> -1;
05969     } <span class="keywordflow">else</span> {
05970         gettimeofday(&amp;now, (<span class="keyword">struct</span> timezone *) 0);
05971         tv = now;
05972         rp-&gt;time = tv;
05973         tv.tv_usec += rp-&gt;<a class="code" href="structsnmp__session.html#o2">timeout</a>;
05974         tv.tv_sec += tv.tv_usec / 1000000L;
05975         tv.tv_usec %= 1000000L;
05976         rp-&gt;expire = tv;
05977     }
05978     <span class="keywordflow">return</span> 0;
05979 }
05980 
05981 
05982 
05983 <span class="keywordtype">void</span>
05984 snmp_sess_timeout(<span class="keywordtype">void</span> *sessp)
05985 {
05986     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
05987     netsnmp_session *sp;
05988     <span class="keyword">struct </span>snmp_internal_session *isp;
05989     netsnmp_request_list *rp, *orp = NULL, *freeme = NULL;
05990     <span class="keyword">struct </span>timeval  now;
05991     snmp_callback   callback;
05992     <span class="keywordtype">void</span>           *magic;
05993     <span class="keyword">struct </span>snmp_secmod_def *sptr;
05994 
05995     sp = slp-&gt;session;
05996     isp = slp-&gt;internal;
05997     <span class="keywordflow">if</span> (!sp || !isp) {
05998         DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"timeout fail: closing...\n"</span>));
05999         <span class="keywordflow">return</span>;
06000     }
06001 
06002     gettimeofday(&amp;now, (<span class="keyword">struct</span> timezone *) 0);
06003 
06004     <span class="comment">/*</span>
06005 <span class="comment">     * For each request outstanding, check to see if it has expired.</span>
06006 <span class="comment">     */</span>
06007     <span class="keywordflow">for</span> (rp = isp-&gt;requests; rp; rp = rp-&gt;next_request) {
06008         <span class="keywordflow">if</span> (freeme != NULL) {
06009             <span class="comment">/*</span>
06010 <span class="comment">             * frees rp's after the for loop goes on to the next_request </span>
06011 <span class="comment">             */</span>
06012             free((<span class="keywordtype">char</span> *) freeme);
06013             freeme = NULL;
06014         }
06015 
06016         <span class="keywordflow">if</span> ((timercmp(&amp;rp-&gt;expire, &amp;now, &lt;))) {
06017             <span class="keywordflow">if</span> ((sptr = find_sec_mod(rp-&gt;pdu-&gt;securityModel)) != NULL &amp;&amp;
06018                 sptr-&gt;pdu_timeout != NULL) {
06019                 <span class="comment">/*</span>
06020 <span class="comment">                 * call security model if it needs to know about this </span>
06021 <span class="comment">                 */</span>
06022                 (*sptr-&gt;pdu_timeout) (rp-&gt;pdu);
06023             }
06024 
06025             <span class="comment">/*</span>
06026 <span class="comment">             * this timer has expired </span>
06027 <span class="comment">             */</span>
06028             <span class="keywordflow">if</span> (rp-&gt;retries &gt;= sp-&gt;<a class="code" href=
"structsnmp__session.html#o1">retries</a>) {
06029                 <span class="keywordflow">if</span> (rp-&gt;callback) {
06030                     callback = rp-&gt;<a class="code" href="structsnmp__session.html#o11">callback</a>;
06031                     magic = rp-&gt;cb_data;
06032                 } <span class="keywordflow">else</span> {
06033                     callback = sp-&gt;<a class="code" href="structsnmp__session.html#o11">callback</a>;
06034                     magic = sp-&gt;<a class="code" href="structsnmp__session.html#o12">callback_magic</a>;
06035                 }
06036 
06037                 <span class="comment">/*</span>
06038 <span class="comment">                 * No more chances, delete this entry </span>
06039 <span class="comment">                 */</span>
06040                 <span class="keywordflow">if</span> (callback) {
06041                     callback(NETSNMP_CALLBACK_OP_TIMED_OUT, sp,
06042                              rp-&gt;pdu-&gt;reqid, rp-&gt;pdu, magic);
06043                 }
06044                 <span class="keywordflow">if</span> (isp-&gt;requests == rp) {
06045                     isp-&gt;requests = rp-&gt;next_request;
06046                     <span class="keywordflow">if</span> (isp-&gt;requestsEnd == rp) {
06047                         isp-&gt;requestsEnd = NULL;
06048                     }
06049                 } <span class="keywordflow">else</span> {
06050                     orp-&gt;next_request = rp-&gt;next_request;
06051                     <span class="keywordflow">if</span> (isp-&gt;requestsEnd == rp) {
06052                         isp-&gt;requestsEnd = orp;
06053                     }
06054                 }
06055                 snmp_free_pdu(rp-&gt;pdu); <span class="comment">/* FIX  rp is already free'd! */</span>
06056                 freeme = rp;
06057                 <span class="keywordflow">continue</span>;       <span class="comment">/* don't update orp below */</span>
06058             } <span class="keywordflow">else</span> {
06059                 <span class="keywordflow">if</span> (snmp_resend_request(slp, rp, TRUE)) {
06060                     <span class="keywordflow">break</span>;
06061                 }
06062             }
06063         }
06064         orp = rp;
06065     }
06066 
06067     <span class="keywordflow">if</span> (freeme != NULL) {
06068         free((<span class="keywordtype">char</span> *) freeme);
06069         freeme = NULL;
06070     }
06071 }
06072 
06073 <span class="comment">/*</span>
06074 <span class="comment"> * lexicographical compare two object identifiers.</span>
06075 <span class="comment"> * * Returns -1 if name1 &lt; name2,</span>
06076 <span class="comment"> * *          0 if name1 = name2,</span>
06077 <span class="comment"> * *          1 if name1 &gt; name2</span>
06078 <span class="comment"> * *</span>
06079 <span class="comment"> * * Caution: this method is called often by</span>
06080 <span class="comment"> * *          command responder applications (ie, agent).</span>
06081 <span class="comment"> */</span>
06082 <span class="keywordtype">int</span>
06083 snmp_oid_ncompare(<span class="keyword">const</span> oid * in_name1,
06084                   size_t len1,
06085                   <span class="keyword">const</span> oid * in_name2, size_t len2, size_t max_len)
06086 {
06087     <span class="keyword">register</span> <span class="keywordtype">int</span>    len;
06088     <span class="keyword">register</span> <span class="keyword">const</span> oid *name1 = in_name1;
06089     <span class="keyword">register</span> <span class="keyword">const</span> oid *name2 = in_name2;
06090     size_t          min_len;
06091 
06092     <span class="comment">/*</span>
06093 <span class="comment">     * len = minimum of len1 and len2 </span>
06094 <span class="comment">     */</span>
06095     <span class="keywordflow">if</span> (len1 &lt; len2)
06096         min_len = len1;
06097     <span class="keywordflow">else</span>
06098         min_len = len2;
06099 
06100     <span class="keywordflow">if</span> (min_len &gt; max_len)
06101         min_len = max_len;
06102 
06103     len = min_len;
06104 
06105     <span class="comment">/*</span>
06106 <span class="comment">     * find first non-matching OID </span>
06107 <span class="comment">     */</span>
06108     <span class="keywordflow">while</span> (len-- &gt; 0) {
06109         <span class="comment">/*</span>
06110 <span class="comment">         * these must be done in seperate comparisons, since</span>
06111 <span class="comment">         * subtracting them and using that result has problems with</span>
06112 <span class="comment">         * subids &gt; 2^31. </span>
06113 <span class="comment">         */</span>
06114         <span class="keywordflow">if</span> (*(name1) != *(name2)) {
06115             <span class="keywordflow">if</span> (*(name1) &lt; *(name2))
06116                 <span class="keywordflow">return</span> -1;
06117             <span class="keywordflow">return</span> 1;
06118         }
06119         name1++;
06120         name2++;
06121     }
06122 
06123     <span class="keywordflow">if</span> (min_len != max_len) {
06124         <span class="comment">/*</span>
06125 <span class="comment">         * both OIDs equal up to length of shorter OID </span>
06126 <span class="comment">         */</span>
06127         <span class="keywordflow">if</span> (len1 &lt; len2)
06128             <span class="keywordflow">return</span> -1;
06129         <span class="keywordflow">if</span> (len2 &lt; len1)
06130             <span class="keywordflow">return</span> 1;
06131     }
06132 
06133     <span class="keywordflow">return</span> 0;
06134 }
06135 
06143 <span class="keywordtype">int</span>
<a name="l06144" id="l06144"></a><a class="code" href="group__library.html#ga98">06144</a> <a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>(<span class="keyword">const</span> oid * in_name1,
06145                  size_t len1, <span class="keyword">const</span> oid * in_name2, size_t len2)
06146 {
06147     <span class="keyword">register</span> <span class="keywordtype">int</span>    len;
06148     <span class="keyword">register</span> <span class="keyword">const</span> oid *name1 = in_name1;
06149     <span class="keyword">register</span> <span class="keyword">const</span> oid *name2 = in_name2;
06150 
06151     <span class="comment">/*</span>
06152 <span class="comment">     * len = minimum of len1 and len2 </span>
06153 <span class="comment">     */</span>
06154     <span class="keywordflow">if</span> (len1 &lt; len2)
06155         len = len1;
06156     <span class="keywordflow">else</span>
06157         len = len2;
06158     <span class="comment">/*</span>
06159 <span class="comment">     * find first non-matching OID </span>
06160 <span class="comment">     */</span>
06161     <span class="keywordflow">while</span> (len-- &gt; 0) {
06162         <span class="comment">/*</span>
06163 <span class="comment">         * these must be done in seperate comparisons, since</span>
06164 <span class="comment">         * subtracting them and using that result has problems with</span>
06165 <span class="comment">         * subids &gt; 2^31. </span>
06166 <span class="comment">         */</span>
06167         <span class="keywordflow">if</span> (*(name1) != *(name2)) {
06168             <span class="keywordflow">if</span> (*(name1) &lt; *(name2))
06169                 <span class="keywordflow">return</span> -1;
06170             <span class="keywordflow">return</span> 1;
06171         }
06172         name1++;
06173         name2++;
06174     }
06175     <span class="comment">/*</span>
06176 <span class="comment">     * both OIDs equal up to length of shorter OID </span>
06177 <span class="comment">     */</span>
06178     <span class="keywordflow">if</span> (len1 &lt; len2)
06179         <span class="keywordflow">return</span> -1;
06180     <span class="keywordflow">if</span> (len2 &lt; len1)
06181         <span class="keywordflow">return</span> 1;
06182     <span class="keywordflow">return</span> 0;
06183 }
06184 
06192 <span class="keywordtype">int</span>
<a name="l06193" id="l06193"></a><a class="code" href="group__library.html#ga99">06193</a> <a class="code" href=
"group__library.html#ga99">snmp_oidtree_compare</a>(<span class="keyword">const</span> oid * in_name1,
06194                      size_t len1, <span class="keyword">const</span> oid * in_name2, size_t len2)
06195 {
06196     <span class="keywordtype">int</span>             len = ((len1 &lt; len2) ? len1 : len2);
06197 
06198     <span class="keywordflow">return</span> (<a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>(in_name1, len, in_name2, len));
06199 }
06200 
06211 <span class="keywordtype">int</span>
<a name="l06212" id="l06212"></a><a class="code" href="group__library.html#ga100">06212</a> <a class="code" href=
"group__library.html#ga100">netsnmp_oid_equals</a>(<span class="keyword">const</span> oid * in_name1,
06213                    size_t len1, <span class="keyword">const</span> oid * in_name2, size_t len2)
06214 {
06215     <span class="keyword">register</span> <span class="keyword">const</span> oid *name1 = in_name1;
06216     <span class="keyword">register</span> <span class="keyword">const</span> oid *name2 = in_name2;
06217     <span class="keyword">register</span> <span class="keywordtype">int</span>    len = len1;
06218 
06219     <span class="comment">/*</span>
06220 <span class="comment">     * len = minimum of len1 and len2 </span>
06221 <span class="comment">     */</span>
06222     <span class="keywordflow">if</span> (len1 != len2)
06223         <span class="keywordflow">return</span> 1;
06224     <span class="comment">/*</span>
06225 <span class="comment">     * find first non-matching OID </span>
06226 <span class="comment">     */</span>
06227     <span class="keywordflow">while</span> (len-- &gt; 0) {
06228         <span class="comment">/*</span>
06229 <span class="comment">         * these must be done in seperate comparisons, since</span>
06230 <span class="comment">         * subtracting them and using that result has problems with</span>
06231 <span class="comment">         * subids &gt; 2^31. </span>
06232 <span class="comment">         */</span>
06233         <span class="keywordflow">if</span> (*(name1++) != *(name2++))
06234             <span class="keywordflow">return</span> 1;
06235     }
06236     <span class="keywordflow">return</span> 0;
06237 }
06238 
06247 <span class="keywordtype">int</span>
<a name="l06248" id="l06248"></a><a class="code" href="group__library.html#ga101">06248</a> <a class="code" href=
"group__library.html#ga101">netsnmp_oid_is_subtree</a>(<span class="keyword">const</span> oid * in_name1,
06249                        size_t len1, <span class="keyword">const</span> oid * in_name2, size_t len2)
06250 {
06251     <span class="keywordflow">if</span> (len1 &gt; len2)
06252         <span class="keywordflow">return</span> 1;
06253 
06254     <span class="keywordflow">if</span> (memcmp(in_name1, in_name2, len1 * <span class="keyword">sizeof</span>(oid)))
06255         <span class="keywordflow">return</span> 1;
06256 
06257     <span class="keywordflow">return</span> 0;
06258 }
06259 
06267 <span class="keywordtype">int</span>
<a name="l06268" id="l06268"></a><a class="code" href="group__library.html#ga102">06268</a> <a class="code" href=
"group__library.html#ga102">netsnmp_oid_find_prefix</a>(<span class="keyword">const</span> oid * in_name1, size_t len1,
06269                         <span class="keyword">const</span> oid * in_name2, size_t len2)
06270 {
06271     <span class="keywordtype">int</span> i;
06272     size_t min_size;
06273 
06274     <span class="keywordflow">if</span> (!in_name1 || !in_name2)
06275         <span class="keywordflow">return</span> -1;
06276 
06277     min_size = <a class="code" href="group__util.html#ga46">SNMP_MIN</a>(len1, len2);
06278     <span class="keywordflow">for</span>(i = 0; i &lt; (int)min_size; i++) {
06279         <span class="keywordflow">if</span> (in_name1[i] != in_name2[i])
06280             <span class="keywordflow">return</span> i + 1;
06281     }
06282     <span class="keywordflow">return</span> 0;
06283 }
06284 
06285 <span class="keyword">static</span> <span class="keywordtype">int</span> _check_range(<span class=
"keyword">struct</span> tree *tp, <span class="keywordtype">long</span> ltmp, <span class="keywordtype">int</span> *resptr,
06286                         <span class="keyword">const</span> <span class="keywordtype">char</span> *errmsg)
06287 {
06288     <span class="keywordtype">int</span> check = !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
06289                                         NETSNMP_DS_LIB_DONT_CHECK_RANGE);
06290   
06291     <span class="keywordflow">if</span> (check &amp;&amp; tp &amp;&amp; tp-&gt;ranges) {
06292         <span class="keyword">struct </span>range_list *rp = tp-&gt;ranges;
06293         <span class="keywordflow">while</span> (rp) {
06294             <span class="keywordflow">if</span> (rp-&gt;low &lt;= ltmp &amp;&amp; ltmp &lt;= rp-&gt;high) <span class=
"keywordflow">break</span>;
06295             rp = rp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
06296         }
06297         <span class="keywordflow">if</span> (!rp) {
06298             *resptr = SNMPERR_RANGE;
06299             snmp_set_detail(errmsg);
06300             <span class="keywordflow">return</span> 0;
06301         }
06302     }
06303     <span class="keywordflow">return</span> 1;
06304 }
06305         
06306 
06307 <span class="comment">/*</span>
06308 <span class="comment"> * Add a variable with the requested name to the end of the list of</span>
06309 <span class="comment"> * variables for this pdu.</span>
06310 <span class="comment"> */</span>
06311 <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *
06312 snmp_pdu_add_variable(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
06313                       <span class="keyword">const</span> oid * name,
06314                       size_t name_length,
06315                       u_char type, <span class="keyword">const</span> u_char * value, size_t len)
06316 {
06317     <span class="keywordflow">return</span> snmp_varlist_add_variable(&amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>, name, name_length,
06318                                      type, value, len);
06319 }
06320 
06321 <span class="comment">/*</span>
06322 <span class="comment"> * Add a variable with the requested name to the end of the list of</span>
06323 <span class="comment"> * variables for this pdu.</span>
06324 <span class="comment"> */</span>
06325 <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *
06326 snmp_varlist_add_variable(<a class="code" href="structvariable__list.html">netsnmp_variable_list</a> ** varlist,
06327                           <span class="keyword">const</span> oid * name,
06328                           size_t name_length,
06329                           u_char type, <span class="keyword">const</span> u_char * value, size_t len)
06330 {
06331     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vars, *vtmp;
06332     <span class="keywordtype">int</span>             largeval = 1;
06333     <span class="keyword">const</span> <span class="keywordtype">long</span>     *val_long = NULL;
06334     <span class="keyword">const</span> <span class="keywordtype">int</span>      *val_int  = NULL;
06335 
06336     <span class="keywordflow">if</span> (varlist == NULL)
06337         <span class="keywordflow">return</span> NULL;
06338 
06339     vars = (<a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *) malloc(<span class=
"keyword">sizeof</span>(<a class="code" href="structvariable__list.html">netsnmp_variable_list</a>));
06340     <span class="keywordflow">if</span> (vars == NULL)
06341         <span class="keywordflow">return</span> NULL;
06342 
06343     vars-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a> = 0;
06344     vars-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = 0;
06345     vars-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = 0;
06346     vars-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string = 0;
06347     vars-&gt;<a class="code" href="structvariable__list.html#o8">data</a> = 0;
06348     vars-&gt;<a class="code" href="structvariable__list.html#o9">dataFreeHook</a> = 0;
06349     vars-&gt;<a class="code" href="structvariable__list.html#o10">index</a> = 0;
06350 
06351     <span class="comment">/*</span>
06352 <span class="comment">     * use built-in storage for smaller values </span>
06353 <span class="comment">     */</span>
06354     <span class="keywordflow">if</span> (len &lt;= (<span class="keyword">sizeof</span>(vars-&gt;<a class="code" href=
"structvariable__list.html#o7">buf</a>) - 1)) {
06355         vars-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string = (u_char *) vars-&gt;<a class="code"
href="structvariable__list.html#o7">buf</a>;
06356         largeval = 0;
06357     }
06358 
06359     vars-&gt;<a class="code" href="structvariable__list.html#o3">type</a> = type;
06360     vars-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = len;
06361     <span class="keywordflow">switch</span> (type) {
06362     <span class="keywordflow">case</span> ASN_INTEGER:
06363     <span class="keywordflow">case</span> ASN_UNSIGNED:
06364     <span class="keywordflow">case</span> ASN_TIMETICKS:
06365     <span class="keywordflow">case</span> ASN_IPADDRESS:
06366     <span class="keywordflow">case</span> ASN_COUNTER:
06367         <span class="keywordflow">if</span> (value) {
06368             <span class="keywordflow">if</span> (largeval) {
06369                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"bad size for integer-like type (%d)\n"</span>,
06370                          vars-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
06371                 snmp_free_var(vars);
06372                 <span class="keywordflow">return</span> (0);
06373             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vars-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> == <span class="keyword">sizeof</span>(int)) {
06374                 val_int = (<span class="keyword">const</span> <span class="keywordtype">int</span> *) value;
06375                 *(vars-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.integer) = (long) *val_int;
06376             } <span class="keywordflow">else</span> {
06377                 val_long = (<span class="keyword">const</span> <span class="keywordtype">long</span> *) value;
06378                 *(vars-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.integer) = *val_long;
06379             }
06380         }
06381         vars-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(long);
06382         <span class="keywordflow">break</span>;
06383 
06384     <span class="keywordflow">case</span> ASN_OBJECT_ID:
06385     <span class="keywordflow">case</span> ASN_PRIV_IMPLIED_OBJECT_ID:
06386     <span class="keywordflow">case</span> ASN_PRIV_INCL_RANGE:
06387     <span class="keywordflow">case</span> ASN_PRIV_EXCL_RANGE:
06388         <span class="keywordflow">if</span> (largeval) {
06389             vars-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid = (oid *) malloc(vars-&gt;<a class=
"code" href="structvariable__list.html#o5">val_len</a>);
06390         }
06391         <span class="keywordflow">if</span> (vars-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid == NULL) {
06392             <span class="keywordflow">return</span> NULL;
06393         }
06394         memmove(vars-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid, value, vars-&gt;<a class="code"
href="structvariable__list.html#o5">val_len</a>);
06395         <span class="keywordflow">break</span>;
06396 
06397     <span class="keywordflow">case</span> ASN_PRIV_IMPLIED_OCTET_STR:
06398     <span class="keywordflow">case</span> ASN_OCTET_STR:
06399     <span class="keywordflow">case</span> ASN_BIT_STR:
06400     <span class="keywordflow">case</span> ASN_OPAQUE:
06401     <span class="keywordflow">case</span> ASN_NSAP:
06402         <span class="keywordflow">if</span> (largeval) {
06403             vars-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string = (u_char *) malloc(vars-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> + 1);
06404         }
06405         <span class="keywordflow">if</span> (vars-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string == NULL) {
06406             <span class="keywordflow">return</span> NULL;
06407         }
06408         memmove(vars-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string, value, vars-&gt;<a class=
"code" href="structvariable__list.html#o5">val_len</a>);
06409         <span class="comment">/*</span>
06410 <span class="comment">         * Make sure the string is zero-terminated; some bits of code make</span>
06411 <span class="comment">         * this assumption.  Easier to do this here than fix all these wrong</span>
06412 <span class="comment">         * assumptions.  </span>
06413 <span class="comment">         */</span>
06414         vars-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[vars-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>] = <span class="charliteral">'\0'</span>;
06415         <span class="keywordflow">break</span>;
06416 
06417     <span class="keywordflow">case</span> SNMP_NOSUCHOBJECT:
06418     <span class="keywordflow">case</span> SNMP_NOSUCHINSTANCE:
06419     <span class="keywordflow">case</span> SNMP_ENDOFMIBVIEW:
06420     <span class="keywordflow">case</span> ASN_NULL:
06421         vars-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = 0;
06422         vars-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string = NULL;
06423         <span class="keywordflow">break</span>;
06424 
06425 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
06426     <span class="keywordflow">case</span> ASN_OPAQUE_U64:
06427     <span class="keywordflow">case</span> ASN_OPAQUE_I64:
06428 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
06429     <span class="keywordflow">case</span> ASN_COUNTER64:
06430         <span class="keywordflow">if</span> (largeval) {
06431             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"bad size for counter 64 (%d)\n"</span>,
06432                      vars-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
06433             snmp_free_var(vars);
06434             <span class="keywordflow">return</span> (0);
06435         }
06436         vars-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(<span class="keyword">struct </span>counter64);
06437         memmove(vars-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.counter64, value, vars-&gt;<a class=
"code" href="structvariable__list.html#o5">val_len</a>);
06438         <span class="keywordflow">break</span>;
06439 
06440 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
06441     <span class="keywordflow">case</span> ASN_OPAQUE_FLOAT:
06442         <span class="keywordflow">if</span> (largeval) {
06443             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"bad size for opaque float (%d)\n"</span>,
06444                      vars-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
06445             snmp_free_var(vars);
06446             <span class="keywordflow">return</span> (0);
06447         }
06448         vars-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(float);
06449         memmove(vars-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.floatVal, value, vars-&gt;<a class=
"code" href="structvariable__list.html#o5">val_len</a>);
06450         <span class="keywordflow">break</span>;
06451 
06452     <span class="keywordflow">case</span> ASN_OPAQUE_DOUBLE:
06453         <span class="keywordflow">if</span> (largeval) {
06454             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"bad size for opaque double (%d)\n"</span>,
06455                      vars-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
06456             snmp_free_var(vars);
06457             <span class="keywordflow">return</span> (0);
06458         }
06459         vars-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(double);
06460         memmove(vars-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.doubleVal, value, vars-&gt;<a class=
"code" href="structvariable__list.html#o5">val_len</a>);
06461         <span class="keywordflow">break</span>;
06462 
06463 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
06464 
06465     <span class="keywordflow">default</span>:
06466         snmp_set_detail(<span class="stringliteral">"Internal error in type switching\n"</span>);
06467         snmp_free_var(vars);
06468         <span class="keywordflow">return</span> (0);
06469     }
06470 
06471     <span class="keywordflow">if</span> (name != NULL &amp;&amp; snmp_set_var_objid(vars, name, name_length)) {
06472         snmp_free_var(vars);
06473         <span class="keywordflow">return</span> (0);
06474     }
06475 
06476     <span class="comment">/*</span>
06477 <span class="comment">     * put only qualified variable onto varlist </span>
06478 <span class="comment">     */</span>
06479     <span class="keywordflow">if</span> (*varlist == NULL) {
06480         *varlist = vars;
06481     } <span class="keywordflow">else</span> {
06482         <span class="keywordflow">for</span> (vtmp = *varlist; vtmp-&gt;<a class="code" href=
"structvariable__list.html#o0">next_variable</a>;
06483              vtmp = vtmp-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>);
06484 
06485         vtmp-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a> = vars;
06486     }
06487 
06488     <span class="keywordflow">return</span> vars;
06489 }
06490 
06491 
06492 
06493 <span class="comment">/*</span>
06494 <span class="comment"> * Add a variable with the requested name to the end of the list of</span>
06495 <span class="comment"> * variables for this pdu.</span>
06496 <span class="comment"> * Returns:</span>
06497 <span class="comment"> * may set these error types :</span>
06498 <span class="comment"> * SNMPERR_RANGE - type, value, or length not found or out of range</span>
06499 <span class="comment"> * SNMPERR_VALUE - value is not correct</span>
06500 <span class="comment"> * SNMPERR_BAD_NAME - name is not found</span>
06501 <span class="comment"> *</span>
06502 <span class="comment"> * returns 0 if success, error if failure.</span>
06503 <span class="comment"> */</span>
06504 <span class="keywordtype">int</span>
06505 snmp_add_var(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
06506              <span class="keyword">const</span> oid * name, size_t name_length, <span class=
"keywordtype">char</span> type, <span class="keyword">const</span> <span class="keywordtype">char</span> *value)
06507 {
06508     <span class="keywordtype">char</span>           *st;
06509     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp;
06510     <span class="keywordtype">char</span>           *ecp, *vp;
06511     <span class="keywordtype">int</span>             result = SNMPERR_SUCCESS;
06512 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06513     <span class="keywordtype">int</span>             check = !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
06514                                              NETSNMP_DS_LIB_DONT_CHECK_RANGE);
06515     <span class="keywordtype">int</span>             do_hint = !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
06516                                              NETSNMP_DS_LIB_NO_DISPLAY_HINT);
06517     u_char         *hintptr;
06518     <span class="keyword">struct </span>tree    *tp;
06519 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06520     u_char         *buf = NULL;
06521     <span class="keyword">const</span> u_char   *buf_ptr = NULL;
06522     size_t          buf_len = 0, value_len = 0, tint;
06523     <span class="keywordtype">long</span>            ltmp;
06524     <span class="keywordtype">int</span>             itmp;
06525     <span class="keyword">struct </span>enum_list *ep;
06526 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
06527     <span class="keywordtype">double</span>          dtmp;
06528     <span class="keywordtype">float</span>           ftmp;
06529     <span class="keyword">struct </span>counter64 c64tmp;
06530 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
06531 
06532 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06533     tp = <a class="code" href="group__mib__utilities.html#ga83">get_tree</a>(name, name_length, <a class="code" href=
"group__mib__utilities.html#ga45">get_tree_head</a>());
06534     <span class="keywordflow">if</span> (!tp || !tp-&gt;type || tp-&gt;type &gt; TYPE_SIMPLE_LAST) {
06535         check = 0;
06536     }
06537     <span class="keywordflow">if</span> (!(tp &amp;&amp; tp-&gt;hint))
06538         do_hint = 0;
06539 
06540     <span class="keywordflow">if</span> (tp &amp;&amp; type == <span class="charliteral">'='</span>) {
06541         <span class="comment">/*</span>
06542 <span class="comment">         * generic assignment - let the tree node decide value format </span>
06543 <span class="comment">         */</span>
06544         <span class="keywordflow">switch</span> (tp-&gt;type) {
06545         <span class="keywordflow">case</span> TYPE_INTEGER:
06546         <span class="keywordflow">case</span> TYPE_INTEGER32:
06547             type = <span class="charliteral">'i'</span>;
06548             <span class="keywordflow">break</span>;
06549         <span class="keywordflow">case</span> TYPE_GAUGE:
06550         <span class="keywordflow">case</span> TYPE_UNSIGNED32:
06551             type = <span class="charliteral">'u'</span>;
06552             <span class="keywordflow">break</span>;
06553         <span class="keywordflow">case</span> TYPE_UINTEGER:
06554             type = <span class="charliteral">'3'</span>;
06555             <span class="keywordflow">break</span>;
06556         <span class="keywordflow">case</span> TYPE_COUNTER:
06557             type = <span class="charliteral">'c'</span>;
06558             <span class="keywordflow">break</span>;
06559         <span class="keywordflow">case</span> TYPE_TIMETICKS:
06560             type = <span class="charliteral">'t'</span>;
06561             <span class="keywordflow">break</span>;
06562         <span class="keywordflow">case</span> TYPE_OCTETSTR:
06563             type = <span class="charliteral">'s'</span>;
06564             <span class="keywordflow">break</span>;
06565         <span class="keywordflow">case</span> TYPE_BITSTRING:
06566             type = <span class="charliteral">'b'</span>;
06567             <span class="keywordflow">break</span>;
06568         <span class="keywordflow">case</span> TYPE_IPADDR:
06569             type = <span class="charliteral">'a'</span>;
06570             <span class="keywordflow">break</span>;
06571         <span class="keywordflow">case</span> TYPE_OBJID:
06572             type = <span class="charliteral">'o'</span>;
06573             <span class="keywordflow">break</span>;
06574         }
06575     }
06576 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06577 
06578     <span class="keywordflow">switch</span> (type) {
06579     <span class="keywordflow">case</span> <span class="charliteral">'i'</span>:
06580 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06581         <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_INTEGER
06582             &amp;&amp; tp-&gt;type != TYPE_INTEGER32) {
06583             value = <span class="stringliteral">"INTEGER"</span>;
06584             result = SNMPERR_VALUE;
06585             <span class="keywordflow">goto</span> type_error;
06586         }
06587 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06588         <span class="keywordflow">if</span> (!*value)
06589             <span class="keywordflow">goto</span> fail;
06590         ltmp = strtol(value, &amp;ecp, 10);
06591         <span class="keywordflow">if</span> (*ecp) {
06592 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06593             ep = tp ? tp-&gt;enums : NULL;
06594             <span class="keywordflow">while</span> (ep) {
06595                 <span class="keywordflow">if</span> (strcmp(value, ep-&gt;label) == 0) {
06596                     ltmp = ep-&gt;value;
06597                     <span class="keywordflow">break</span>;
06598                 }
06599                 ep = ep-&gt;next;
06600             }
06601             <span class="keywordflow">if</span> (!ep) {
06602 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06603                 result = SNMPERR_BAD_NAME;
06604                 snmp_set_detail(value);
06605                 <span class="keywordflow">break</span>;
06606 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06607             }
06608 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06609         }
06610 
06611 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06612         <span class="keywordflow">if</span> (!_check_range(tp, ltmp, &amp;result, value))
06613             <span class="keywordflow">break</span>;
06614 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06615         snmp_pdu_add_variable(pdu, name, name_length, ASN_INTEGER,
06616                               (u_char *) &amp; ltmp, <span class="keyword">sizeof</span>(ltmp));
06617         <span class="keywordflow">break</span>;
06618 
06619     <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
06620 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06621         <span class=
"keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_GAUGE &amp;&amp; tp-&gt;type != TYPE_UNSIGNED32) {
06622             value = <span class="stringliteral">"Unsigned32"</span>;
06623             result = SNMPERR_VALUE;
06624             <span class="keywordflow">goto</span> type_error;
06625         }
06626 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06627         ltmp = strtoul(value, &amp;ecp, 10);
06628         <span class="keywordflow">if</span> (*value &amp;&amp; !*ecp)
06629             snmp_pdu_add_variable(pdu, name, name_length, ASN_UNSIGNED,
06630                                   (u_char *) &amp; ltmp, <span class="keyword">sizeof</span>(ltmp));
06631         <span class="keywordflow">else</span>
06632             <span class="keywordflow">goto</span> fail;
06633         <span class="keywordflow">break</span>;
06634 
06635     <span class="keywordflow">case</span> <span class="charliteral">'3'</span>:
06636 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06637         <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_UINTEGER) {
06638             value = <span class="stringliteral">"UInteger32"</span>;
06639             result = SNMPERR_VALUE;
06640             <span class="keywordflow">goto</span> type_error;
06641         }
06642 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06643         ltmp = strtoul(value, &amp;ecp, 10);
06644         <span class="keywordflow">if</span> (*value &amp;&amp; !*ecp)
06645             snmp_pdu_add_variable(pdu, name, name_length, ASN_UINTEGER,
06646                                   (u_char *) &amp; ltmp, <span class="keyword">sizeof</span>(ltmp));
06647         <span class="keywordflow">else</span>
06648             <span class="keywordflow">goto</span> fail;
06649         <span class="keywordflow">break</span>;
06650 
06651     <span class="keywordflow">case</span> <span class="charliteral">'c'</span>:
06652 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06653         <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_COUNTER) {
06654             value = <span class="stringliteral">"Counter32"</span>;
06655             result = SNMPERR_VALUE;
06656             <span class="keywordflow">goto</span> type_error;
06657         }
06658 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06659         ltmp = strtoul(value, &amp;ecp, 10);
06660         <span class="keywordflow">if</span> (*value &amp;&amp; !*ecp)
06661             snmp_pdu_add_variable(pdu, name, name_length, ASN_COUNTER,
06662                                   (u_char *) &amp; ltmp, <span class="keyword">sizeof</span>(ltmp));
06663         <span class="keywordflow">else</span>
06664             <span class="keywordflow">goto</span> fail;
06665         <span class="keywordflow">break</span>;
06666 
06667     <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:
06668 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06669         <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_TIMETICKS) {
06670             value = <span class="stringliteral">"Timeticks"</span>;
06671             result = SNMPERR_VALUE;
06672             <span class="keywordflow">goto</span> type_error;
06673         }
06674 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06675         ltmp = strtoul(value, &amp;ecp, 10);
06676         <span class="keywordflow">if</span> (*value &amp;&amp; !*ecp)
06677             snmp_pdu_add_variable(pdu, name, name_length, ASN_TIMETICKS,
06678                                   (u_char *) &amp; ltmp, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
06679         <span class="keywordflow">else</span>
06680             <span class="keywordflow">goto</span> fail;
06681         <span class="keywordflow">break</span>;
06682 
06683     <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
06684 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06685         <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_IPADDR) {
06686             value = <span class="stringliteral">"IpAddress"</span>;
06687             result = SNMPERR_VALUE;
06688             <span class="keywordflow">goto</span> type_error;
06689         }
06690 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06691         ltmp = inet_addr(value);
06692         <span class="keywordflow">if</span> (ltmp != (long) -1 || !strcmp(value, <span class=
"stringliteral">"255.255.255.255"</span>))
06693             snmp_pdu_add_variable(pdu, name, name_length, ASN_IPADDRESS,
06694                                   (u_char *) &amp; ltmp, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
06695         <span class="keywordflow">else</span>
06696             <span class="keywordflow">goto</span> fail;
06697         <span class="keywordflow">break</span>;
06698 
06699     <span class="keywordflow">case</span> <span class="charliteral">'o'</span>:
06700 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06701         <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_OBJID) {
06702             value = <span class="stringliteral">"OBJECT IDENTIFIER"</span>;
06703             result = SNMPERR_VALUE;
06704             <span class="keywordflow">goto</span> type_error;
06705         }
06706 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06707         <span class="keywordflow">if</span> ((buf = malloc(<span class=
"keyword">sizeof</span>(oid) * MAX_OID_LEN)) == NULL) {
06708             result = SNMPERR_MALLOC;
06709         } <span class="keywordflow">else</span> {
06710             tint = MAX_OID_LEN;
06711             <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga103">snmp_parse_oid</a>(value, (oid *) buf, &amp;tint)) {
06712                 snmp_pdu_add_variable(pdu, name, name_length,
06713                                       ASN_OBJECT_ID, buf,
06714                                       <span class="keyword">sizeof</span>(oid) * tint);
06715             } <span class="keywordflow">else</span> {
06716                 result = snmp_errno;    <span class="comment">/*MTCRITICAL_RESOURCE */</span>
06717             }
06718         }
06719         <span class="keywordflow">break</span>;
06720 
06721     <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
06722     <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
06723     <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
06724 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06725         <span class=
"keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_OCTETSTR &amp;&amp; tp-&gt;type != TYPE_BITSTRING) {
06726             value = <span class="stringliteral">"OCTET STRING"</span>;
06727             result = SNMPERR_VALUE;
06728             <span class="keywordflow">goto</span> type_error;
06729         }
06730         <span class="keywordflow">if</span> (<span class=
"charliteral">'s'</span> == type &amp;&amp; do_hint &amp;&amp; !parse_octet_hint(tp-&gt;hint, value, &amp;hintptr, &amp;itmp)) {
06731             <span class="keywordflow">if</span> (_check_range(tp, itmp, &amp;result, <span class=
"stringliteral">"Value does not match DISPLAY-HINT"</span>)) {
06732                 snmp_pdu_add_variable(pdu, name, name_length,
06733                                       ASN_OCTET_STR, hintptr, itmp);
06734             }
06735             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(hintptr);
06736             hintptr = buf;
06737             <span class="keywordflow">break</span>;
06738         }
06739 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06740         <span class="keywordflow">if</span> (type == <span class="charliteral">'d'</span>) {
06741             <span class="keywordflow">if</span> (!snmp_decimal_to_binary
06742                 (&amp;buf, &amp;buf_len, &amp;value_len, 1, value)) {
06743                 result = SNMPERR_VALUE;
06744                 snmp_set_detail(value);
06745                 <span class="keywordflow">break</span>;
06746             }
06747             buf_ptr = buf;
06748         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == <span class=
"charliteral">'x'</span>) {
06749             <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;buf, &amp;buf_len, &amp;value_len, 1, value)) {
06750                 result = SNMPERR_VALUE;
06751                 snmp_set_detail(value);
06752                 <span class="keywordflow">break</span>;
06753             }
06754             <span class="comment">/* initialize itmp value so that range check below works */</span>
06755             itmp = value_len;
06756             buf_ptr = buf;
06757         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == <span class=
"charliteral">'s'</span>) {
06758             buf_ptr = value;
06759             value_len = strlen(value);
06760         }
06761 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06762         <span class="keywordflow">if</span> (!_check_range(tp, value_len, &amp;result, <span class=
"stringliteral">"Bad string length"</span>))
06763             <span class="keywordflow">break</span>;
06764 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06765         snmp_pdu_add_variable(pdu, name, name_length, ASN_OCTET_STR,
06766                               buf_ptr, value_len);
06767         <span class="keywordflow">break</span>;
06768 
06769     <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
06770         snmp_pdu_add_variable(pdu, name, name_length, ASN_NULL, 0, 0);
06771         <span class="keywordflow">break</span>;
06772 
06773     <span class="keywordflow">case</span> <span class="charliteral">'b'</span>:
06774 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06775         <span class="keywordflow">if</span> (check &amp;&amp; (tp-&gt;type != TYPE_BITSTRING || !tp-&gt;enums)) {
06776             value = <span class="stringliteral">"BITS"</span>;
06777             result = SNMPERR_VALUE;
06778             <span class="keywordflow">goto</span> type_error;
06779         }
06780 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06781         tint = 0;
06782         <span class="keywordflow">if</span> ((buf = (u_char *) malloc(256)) == NULL) {
06783             result = SNMPERR_MALLOC;
06784             <span class="keywordflow">break</span>;
06785         } <span class="keywordflow">else</span> {
06786             buf_len = 256;
06787             memset(buf, 0, buf_len);
06788         }
06789 
06790 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06791         <span class="keywordflow">for</span> (ep = tp ? tp-&gt;enums : NULL; ep; ep = ep-&gt;next) {
06792             <span class="keywordflow">if</span> (ep-&gt;value / 8 &gt;= (int) tint) {
06793                 tint = ep-&gt;value / 8 + 1;
06794             }
06795         }
06796 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06797 
06798         vp = strdup(value);
06799         <span class="keywordflow">for</span> (cp = strtok_r(vp, <span class=
"stringliteral">" ,\t"</span>, &amp;st); cp; cp = strtok_r(NULL, <span class="stringliteral">" ,\t"</span>, &amp;st)) {
06800             <span class="keywordtype">int</span>             ix, bit;
06801 
06802             ltmp = strtoul(cp, &amp;ecp, 0);
06803             <span class="keywordflow">if</span> (*ecp != 0) {
06804 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06805                 <span class="keywordflow">for</span> (ep = tp ? tp-&gt;enums : NULL; ep != NULL; ep = ep-&gt;next) {
06806                     <span class="keywordflow">if</span> (strncmp(ep-&gt;label, cp, strlen(ep-&gt;label)) == 0) {
06807                         <span class="keywordflow">break</span>;
06808                     }
06809                 }
06810                 <span class="keywordflow">if</span> (ep != NULL) {
06811                     ltmp = ep-&gt;value;
06812                 } <span class="keywordflow">else</span> {
06813 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06814                     result = SNMPERR_BAD_NAME;
06815                     snmp_set_detail(cp);
06816                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(buf);
06817                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(vp);
06818                     <span class="keywordflow">goto</span> out;
06819 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06820                 }
06821 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06822             }
06823 
06824             ix = ltmp / 8;
06825             <span class="keywordflow">if</span> (ix &gt;= (int) tint) {
06826                 tint = ix + 1;
06827             }
06828             <span class="keywordflow">if</span> (ix &gt;= (int)buf_len &amp;&amp; !<a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(&amp;buf, &amp;buf_len)) {
06829                 result = SNMPERR_MALLOC;
06830                 <span class="keywordflow">break</span>;
06831             }
06832             bit = 0x80 &gt;&gt; ltmp % 8;
06833             buf[ix] |= bit;
06834             
06835         }
06836         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(vp);
06837         snmp_pdu_add_variable(pdu, name, name_length, ASN_OCTET_STR,
06838                               buf, tint);
06839         <span class="keywordflow">break</span>;
06840 
06841 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
06842     <span class="keywordflow">case</span> <span class="charliteral">'U'</span>:
06843         <span class="keywordflow">if</span> (read64(&amp;c64tmp, value))
06844             snmp_pdu_add_variable(pdu, name, name_length, ASN_OPAQUE_U64,
06845                                   (u_char *) &amp; c64tmp, <span class="keyword">sizeof</span>(c64tmp));
06846         <span class="keywordflow">else</span>
06847             <span class="keywordflow">goto</span> fail;
06848         <span class="keywordflow">break</span>;
06849 
06850     <span class="keywordflow">case</span> <span class="charliteral">'I'</span>:
06851         <span class="keywordflow">if</span> (read64(&amp;c64tmp, value))
06852             snmp_pdu_add_variable(pdu, name, name_length, ASN_OPAQUE_I64,
06853                                   (u_char *) &amp; c64tmp, <span class="keyword">sizeof</span>(c64tmp));
06854         <span class="keywordflow">else</span>
06855             <span class="keywordflow">goto</span> fail;
06856         <span class="keywordflow">break</span>;
06857 
06858     <span class="keywordflow">case</span> <span class="charliteral">'F'</span>:
06859         <span class="keywordflow">if</span> (sscanf(value, <span class="stringliteral">"%f"</span>, &amp;ftmp) == 1)
06860             snmp_pdu_add_variable(pdu, name, name_length, ASN_OPAQUE_FLOAT,
06861                                   (u_char *) &amp; ftmp, <span class="keyword">sizeof</span>(ftmp));
06862         <span class="keywordflow">else</span>
06863             <span class="keywordflow">goto</span> fail;
06864         <span class="keywordflow">break</span>;
06865 
06866     <span class="keywordflow">case</span> <span class="charliteral">'D'</span>:
06867         <span class="keywordflow">if</span> (sscanf(value, <span class="stringliteral">"%lf"</span>, &amp;dtmp) == 1)
06868             snmp_pdu_add_variable(pdu, name, name_length,
06869                                   ASN_OPAQUE_DOUBLE, (u_char *) &amp; dtmp,
06870                                   <span class="keyword">sizeof</span>(dtmp));
06871         <span class="keywordflow">else</span>
06872             <span class="keywordflow">goto</span> fail;
06873         <span class="keywordflow">break</span>;
06874 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
06875 
06876     <span class="keywordflow">default</span>:
06877         result = SNMPERR_VAR_TYPE;
06878         buf = calloc(1, 4);
06879         <span class="keywordflow">if</span> (buf != NULL) {
06880             sprintf((<span class="keywordtype">char</span> *)buf, <span class="stringliteral">"\"%c\""</span>, type);
06881             snmp_set_detail((<span class="keywordtype">char</span> *)buf);
06882         }
06883         <span class="keywordflow">break</span>;
06884     }
06885 
06886     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(buf);
06887     SET_SNMP_ERROR(result);
06888     <span class="keywordflow">return</span> result;
06889 
06890 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06891   type_error:
06892     {
06893         <span class="keywordtype">char</span>            error_msg[256];
06894         <span class="keywordtype">char</span>            undef_msg[32];
06895         <span class="keyword">const</span> <span class="keywordtype">char</span>     *var_type;
06896         <span class="keywordflow">switch</span> (tp-&gt;type) {
06897         <span class="keywordflow">case</span> TYPE_OBJID:
06898             var_type = <span class="stringliteral">"OBJECT IDENTIFIER"</span>;
06899             <span class="keywordflow">break</span>;
06900         <span class="keywordflow">case</span> TYPE_OCTETSTR:
06901             var_type = <span class="stringliteral">"OCTET STRING"</span>;
06902             <span class="keywordflow">break</span>;
06903         <span class="keywordflow">case</span> TYPE_INTEGER:
06904             var_type = <span class="stringliteral">"INTEGER"</span>;
06905             <span class="keywordflow">break</span>;
06906         <span class="keywordflow">case</span> TYPE_NETADDR:
06907             var_type = <span class="stringliteral">"NetworkAddress"</span>;
06908             <span class="keywordflow">break</span>;
06909         <span class="keywordflow">case</span> TYPE_IPADDR:
06910             var_type = <span class="stringliteral">"IpAddress"</span>;
06911             <span class="keywordflow">break</span>;
06912         <span class="keywordflow">case</span> TYPE_COUNTER:
06913             var_type = <span class="stringliteral">"Counter32"</span>;
06914             <span class="keywordflow">break</span>;
06915         <span class="keywordflow">case</span> TYPE_GAUGE:
06916             var_type = <span class="stringliteral">"Gauge32"</span>;
06917             <span class="keywordflow">break</span>;
06918         <span class="keywordflow">case</span> TYPE_TIMETICKS:
06919             var_type = <span class="stringliteral">"Timeticks"</span>;
06920             <span class="keywordflow">break</span>;
06921         <span class="keywordflow">case</span> TYPE_OPAQUE:
06922             var_type = <span class="stringliteral">"Opaque"</span>;
06923             <span class="keywordflow">break</span>;
06924         <span class="keywordflow">case</span> TYPE_NULL:
06925             var_type = <span class="stringliteral">"Null"</span>;
06926             <span class="keywordflow">break</span>;
06927         <span class="keywordflow">case</span> TYPE_COUNTER64:
06928             var_type = <span class="stringliteral">"Counter64"</span>;
06929             <span class="keywordflow">break</span>;
06930         <span class="keywordflow">case</span> TYPE_BITSTRING:
06931             var_type = <span class="stringliteral">"BITS"</span>;
06932             <span class="keywordflow">break</span>;
06933         <span class="keywordflow">case</span> TYPE_NSAPADDRESS:
06934             var_type = <span class="stringliteral">"NsapAddress"</span>;
06935             <span class="keywordflow">break</span>;
06936         <span class="keywordflow">case</span> TYPE_UINTEGER:
06937             var_type = <span class="stringliteral">"UInteger"</span>;
06938             <span class="keywordflow">break</span>;
06939         <span class="keywordflow">case</span> TYPE_UNSIGNED32:
06940             var_type = <span class="stringliteral">"Unsigned32"</span>;
06941             <span class="keywordflow">break</span>;
06942         <span class="keywordflow">case</span> TYPE_INTEGER32:
06943             var_type = <span class="stringliteral">"Integer32"</span>;
06944             <span class="keywordflow">break</span>;
06945         <span class="keywordflow">default</span>:
06946             sprintf(undef_msg, <span class="stringliteral">"TYPE_%d"</span>, tp-&gt;type);
06947             var_type = undef_msg;
06948         }
06949         snprintf(error_msg, <span class="keyword">sizeof</span>(error_msg),
06950                <span class="stringliteral">"Type of attribute is %s, not %s"</span>, var_type, value);
06951         error_msg[ <span class="keyword">sizeof</span>(error_msg)-1 ] = 0;
06952         result = SNMPERR_VAR_TYPE;
06953         snmp_set_detail(error_msg);
06954         <span class="keywordflow">goto</span> out;
06955     }
06956 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06957   fail:
06958     result = SNMPERR_VALUE;
06959     snmp_set_detail(value);
06960   out:
06961     SET_SNMP_ERROR(result);
06962     <span class="keywordflow">return</span> result;
06963 }
06964 
06965 <span class="comment">/*</span>
06966 <span class="comment"> * returns NULL or internal pointer to session</span>
06967 <span class="comment"> * use this pointer for the other snmp_sess* routines,</span>
06968 <span class="comment"> * which guarantee action will occur ONLY for this given session.</span>
06969 <span class="comment"> */</span>
06970 <span class="keywordtype">void</span>           *
06971 snmp_sess_pointer(netsnmp_session * session)
06972 {
06973     <span class="keyword">struct </span>session_list *slp;
06974 
06975     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
06976     <span class="keywordflow">for</span> (slp = Sessions; slp; slp = slp-&gt;next) {
06977         <span class="keywordflow">if</span> (slp-&gt;session == session) {
06978             <span class="keywordflow">break</span>;
06979         }
06980     }
06981     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
06982 
06983     <span class="keywordflow">if</span> (slp == NULL) {
06984         snmp_errno = SNMPERR_BAD_SESSION;       <span class="comment">/*MTCRITICAL_RESOURCE */</span>
06985         <span class="keywordflow">return</span> (NULL);
06986     }
06987     <span class="keywordflow">return</span> ((<span class="keywordtype">void</span> *) slp);
06988 }
06989 
06990 <span class="comment">/*</span>
06991 <span class="comment"> * Input : an opaque pointer, returned by snmp_sess_open.</span>
06992 <span class="comment"> * returns NULL or pointer to session.</span>
06993 <span class="comment"> */</span>
06994 netsnmp_session *
06995 snmp_sess_session(<span class="keywordtype">void</span> *sessp)
06996 {
06997     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
06998     <span class="keywordflow">if</span> (slp == NULL)
06999         <span class="keywordflow">return</span> (NULL);
07000     <span class="keywordflow">return</span> (slp-&gt;session);
07001 }
07002 
07003 
07004 
07005 <span class="comment">/*</span>
07006 <span class="comment"> * snmp_sess_transport: takes an opaque pointer (as returned by</span>
07007 <span class="comment"> * snmp_sess_open or snmp_sess_pointer) and returns the corresponding</span>
07008 <span class="comment"> * netsnmp_transport pointer (or NULL if the opaque pointer does not correspond</span>
07009 <span class="comment"> * to an active internal session).  </span>
07010 <span class="comment"> */</span>
07011 
07012 netsnmp_transport *
07013 snmp_sess_transport(<span class="keywordtype">void</span> *sessp)
07014 {
07015     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
07016     <span class="keywordflow">if</span> (slp == NULL) {
07017         <span class="keywordflow">return</span> NULL;
07018     } <span class="keywordflow">else</span> {
07019         <span class="keywordflow">return</span> slp-&gt;transport;
07020     }
07021 }
07022 
07023 
07024 
07025 <span class="comment">/*</span>
07026 <span class="comment"> * snmp_sess_transport_set: set the transport pointer for the opaque</span>
07027 <span class="comment"> * session pointer sp.  </span>
07028 <span class="comment"> */</span>
07029 
07030 <span class="keywordtype">void</span>
07031 snmp_sess_transport_set(<span class="keywordtype">void</span> *sp, netsnmp_transport *t)
07032 {
07033     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sp;
07034     <span class="keywordflow">if</span> (slp != NULL) {
07035         slp-&gt;transport = t;
07036     }
07037 }
07038 
07039 
07040 <span class="comment">/*</span>
07041 <span class="comment"> * snmp_duplicate_objid: duplicates (mallocs) an objid based on the</span>
07042 <span class="comment"> * input objid </span>
07043 <span class="comment"> */</span>
07044 oid            *
07045 snmp_duplicate_objid(<span class="keyword">const</span> oid * objToCopy, size_t objToCopyLen)
07046 {
07047     oid            *returnOid = NULL;
07048     <span class="keywordflow">if</span> (objToCopy != NULL &amp;&amp; objToCopyLen != 0) {
07049         returnOid = (oid *) malloc(objToCopyLen * <span class="keyword">sizeof</span>(oid));
07050         <span class="keywordflow">if</span> (returnOid) {
07051             memmove(returnOid, objToCopy, objToCopyLen * <span class="keyword">sizeof</span>(oid));
07052         }
07053     }
07054     <span class="keywordflow">return</span> returnOid;
07055 }
07056 
07057 <span class="comment">/*</span>
07058 <span class="comment"> * generic statistics counter functions </span>
07059 <span class="comment"> */</span>
07060 <span class="keyword">static</span> u_int    statistics[MAX_STATS];
07061 
07062 u_int
07063 snmp_increment_statistic(<span class="keywordtype">int</span> which)
07064 {
07065     <span class="keywordflow">if</span> (which &gt;= 0 &amp;&amp; which &lt; MAX_STATS) {
07066         statistics[which]++;
07067         <span class="keywordflow">return</span> statistics[which];
07068     }
07069     <span class="keywordflow">return</span> 0;
07070 }
07071 
07072 u_int
07073 snmp_increment_statistic_by(<span class="keywordtype">int</span> which, <span class="keywordtype">int</span> count)
07074 {
07075     <span class="keywordflow">if</span> (which &gt;= 0 &amp;&amp; which &lt; MAX_STATS) {
07076         statistics[which] += count;
07077         <span class="keywordflow">return</span> statistics[which];
07078     }
07079     <span class="keywordflow">return</span> 0;
07080 }
07081 
07082 u_int
07083 snmp_get_statistic(<span class="keywordtype">int</span> which)
07084 {
07085     <span class="keywordflow">if</span> (which &gt;= 0 &amp;&amp; which &lt; MAX_STATS)
07086         <span class="keywordflow">return</span> statistics[which];
07087     <span class="keywordflow">return</span> 0;
07088 }
07089 
07090 <span class="keywordtype">void</span>
07091 snmp_init_statistics(<span class="keywordtype">void</span>)
07092 {
07093     memset(statistics, 0, <span class="keyword">sizeof</span>(statistics));
07094 }
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small><!--#include virtual="/sfbutton.html" --><br />
    Generated on Thu Nov 25 17:51:40 2004 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

