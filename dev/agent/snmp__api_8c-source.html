<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>snmp_api.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
00002 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00003 <span class="comment"> * that may apply:</span>
00004 <span class="comment"> */</span>
00005 <span class="comment">/******************************************************************</span>
00006 <span class="comment">        Copyright 1989, 1991, 1992 by Carnegie Mellon University</span>
00007 
00008 <span class="comment">                      All Rights Reserved</span>
00009 
00010 <span class="comment">Permission to use, copy, modify, and distribute this software and its</span>
00011 <span class="comment">documentation for any purpose and without fee is hereby granted,</span>
00012 <span class="comment">provided that the above copyright notice appear in all copies and that</span>
00013 <span class="comment">both that copyright notice and this permission notice appear in</span>
00014 <span class="comment">supporting documentation, and that the name of CMU not be</span>
00015 <span class="comment">used in advertising or publicity pertaining to distribution of the</span>
00016 <span class="comment">software without specific, written prior permission.</span>
00017 
00018 <span class="comment">CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING</span>
00019 <span class="comment">ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL</span>
00020 <span class="comment">CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR</span>
00021 <span class="comment">ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</span>
00022 <span class="comment">WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,</span>
00023 <span class="comment">ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS</span>
00024 <span class="comment">SOFTWARE.</span>
00025 <span class="comment">******************************************************************/</span>
00026 <span class="comment">/*</span>
00027 <span class="comment"> * Portions of this file are copyrighted by:</span>
00028 <span class="comment"> * Copyright Copyright 2003 Sun Microsystems, Inc. All rights reserved.</span>
00029 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00030 <span class="comment"> * distributed with the Net-SNMP package.</span>
00031 <span class="comment"> */</span>
00032 
00036 <span class="comment">/*</span>
00037 <span class="comment"> * snmp_api.c - API for access to snmp.</span>
00038 <span class="comment"> */</span>
00039 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00040 
00041 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00042 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00043 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00044 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00045 <span class="preprocessor">#endif</span>
00046 <span class="preprocessor">#if HAVE_STRING_H</span>
00047 <span class="preprocessor">#include &lt;string.h&gt;</span>
00048 <span class="preprocessor">#else</span>
00049 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00050 <span class="preprocessor">#endif</span>
00051 <span class="preprocessor">#if HAVE_UNISTD_H</span>
00052 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00053 <span class="preprocessor">#endif</span>
00054 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00055 <span class="preprocessor">#if HAVE_SYS_PARAM_H</span>
00056 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00057 <span class="preprocessor">#endif</span>
00058 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00059 <span class="preprocessor"># ifdef WIN32</span>
00060 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00061 <span class="preprocessor"># else</span>
00062 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00063 <span class="preprocessor"># endif</span>
00064 <span class="preprocessor"># include &lt;time.h&gt;</span>
00065 <span class="preprocessor">#else</span>
00066 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00067 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00068 <span class="preprocessor"># else</span>
00069 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00070 <span class="preprocessor"># endif</span>
00071 <span class="preprocessor">#endif</span>
00072 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00073 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00074 <span class="preprocessor">#endif</span>
00075 <span class="preprocessor">#if HAVE_ARPA_INET_H</span>
00076 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
00077 <span class="preprocessor">#endif</span>
00078 <span class="preprocessor">#if HAVE_SYS_SELECT_H</span>
00079 <span class="preprocessor">#include &lt;sys/select.h&gt;</span>
00080 <span class="preprocessor">#endif</span>
00081 <span class="preprocessor">#if HAVE_IO_H</span>
00082 <span class="preprocessor">#include &lt;io.h&gt;</span>
00083 <span class="preprocessor">#endif</span>
00084 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00085 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00086 <span class="preprocessor">#endif</span>
00087 <span class="preprocessor">#if HAVE_SYS_SOCKET_H</span>
00088 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00089 <span class="preprocessor">#endif</span>
00090 <span class="preprocessor">#if HAVE_SYS_UN_H</span>
00091 <span class="preprocessor">#include &lt;sys/un.h&gt;</span>
00092 <span class="preprocessor">#endif</span>
00093 <span class="preprocessor">#if HAVE_NETDB_H</span>
00094 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00095 <span class="preprocessor">#endif</span>
00096 <span class="preprocessor">#if HAVE_NET_IF_DL_H</span>
00097 <span class="preprocessor">#ifndef dynix</span>
00098 <span class="preprocessor">#include &lt;net/if_dl.h&gt;</span>
00099 <span class="preprocessor">#else</span>
00100 <span class="preprocessor">#include &lt;sys/net/if_dl.h&gt;</span>
00101 <span class="preprocessor">#endif</span>
00102 <span class="preprocessor">#endif</span>
00103 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00104 
00105 <span class="preprocessor">#if HAVE_LOCALE_H</span>
00106 <span class="preprocessor">#include &lt;locale.h&gt;</span>
00107 <span class="preprocessor">#endif</span>
00108 
00109 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00110 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00111 <span class="preprocessor">#endif</span>
00112 
00113 <span class="preprocessor">#define SNMP_NEED_REQUEST_LIST</span>
00114 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00115 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00116 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00117 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00118 
00119 <span class="preprocessor">#include &lt;net-snmp/library/asn1.h&gt;</span>
00120 <span class="preprocessor">#include &lt;net-snmp/library/snmp.h&gt;</span>      <span class=
"comment">/* for xdump &amp; {build,parse}_var_op */</span>
00121 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00122 <span class="preprocessor">#include &lt;net-snmp/library/snmp_client.h&gt;</span>
00123 <span class="preprocessor">#include &lt;net-snmp/library/parse.h&gt;</span>
00124 <span class="preprocessor">#include &lt;net-snmp/library/mib.h&gt;</span>
00125 <span class="preprocessor">#include &lt;net-snmp/library/int64.h&gt;</span>
00126 <span class="preprocessor">#include &lt;net-snmp/library/snmpv3.h&gt;</span>
00127 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
00128 <span class="preprocessor">#include &lt;net-snmp/library/container.h&gt;</span>
00129 <span class="preprocessor">#include &lt;net-snmp/library/snmp_secmod.h&gt;</span>
00130 <span class="preprocessor">#ifdef SNMP_SECMOD_USM</span>
00131 <span class="preprocessor">#include &lt;net-snmp/library/snmpusm.h&gt;</span>
00132 <span class="preprocessor">#endif</span>
00133 <span class="preprocessor">#ifdef SNMP_SECMOD_KSM</span>
00134 <span class="preprocessor">#include &lt;net-snmp/library/snmpksm.h&gt;</span>
00135 <span class="preprocessor">#endif</span>
00136 <span class="preprocessor">#include &lt;net-snmp/library/keytools.h&gt;</span>
00137 <span class="preprocessor">#include &lt;net-snmp/library/lcd_time.h&gt;</span>
00138 <span class="preprocessor">#include &lt;net-snmp/library/snmp_alarm.h&gt;</span>
00139 <span class="preprocessor">#include &lt;net-snmp/library/snmp_transport.h&gt;</span>
00140 <span class="preprocessor">#include &lt;net-snmp/library/vacm.h&gt;</span>
00141 
00142 <span class="keyword">static</span> <span class="keywordtype">void</span>     _init_snmp(<span class=
"keywordtype">void</span>);
00143 
00144 <span class="preprocessor">#include "../agent/mibgroup/agentx/protocol.h"</span>
00145 <span class="preprocessor">#include &lt;net-snmp/library/transform_oids.h&gt;</span>
00146 <span class="preprocessor">#ifndef timercmp</span>
00147 <span class="preprocessor">#define timercmp(tvp, uvp, cmp) \</span>
00148 <span class="preprocessor">        </span><span class="comment">/* CSTYLED */</span> \
00149         ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec || \
00150         ((tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec &amp;&amp; \
00151         <span class="comment">/* CSTYLED */</span> \
00152         (tvp)-&gt;tv_usec cmp (uvp)-&gt;tv_usec))
00153 <span class="preprocessor">#endif</span>
00154 <span class="preprocessor">#ifndef timerclear</span>
00155 <span class="preprocessor">#define timerclear(tvp)         (tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0</span>
00156 <span class="preprocessor">#endif</span>
00157 
00158 <span class="comment">/*</span>
00159 <span class="comment"> * Globals.</span>
00160 <span class="comment"> */</span>
00161 <span class="preprocessor">#define MAX_PACKET_LENGTH       (0x7fffffff)</span>
00162 <span class="preprocessor">#ifndef NETSNMP_STREAM_QUEUE_LEN</span>
00163 <span class="preprocessor">#define NETSNMP_STREAM_QUEUE_LEN  5</span>
00164 <span class="preprocessor">#endif</span>
00165 
00166 <span class="preprocessor">#ifndef BSD4_3</span>
00167 <span class="preprocessor">#define BSD4_2</span>
00168 <span class="preprocessor">#endif</span>
00169 
00170 <span class="preprocessor">#ifndef FD_SET</span>
00171 
00172 <span class="keyword">typedef</span> <span class="keywordtype">long</span>    fd_mask;
00173 <span class="preprocessor">#define NFDBITS (sizeof(fd_mask) * NBBY)        </span><span class=
"comment">/* bits per mask */</span>
00174 
00175 <span class="preprocessor">#define FD_SET(n, p)    ((p)-&gt;fds_bits[(n)/NFDBITS] |= (1 &lt;&lt; ((n) % NFDBITS)))</span>
00176 <span class=
"preprocessor">#define FD_CLR(n, p)    ((p)-&gt;fds_bits[(n)/NFDBITS] &amp;= ~(1 &lt;&lt; ((n) % NFDBITS)))</span>
00177 <span class=
"preprocessor">#define FD_ISSET(n, p)  ((p)-&gt;fds_bits[(n)/NFDBITS] &amp; (1 &lt;&lt; ((n) % NFDBITS)))</span>
00178 <span class="preprocessor">#define FD_ZERO(p)      memset((p), 0, sizeof(*(p)))</span>
00179 <span class="preprocessor">#endif</span>
00180 
00181 <span class="keyword">static</span> oid      default_enterprise[] = { 1, 3, 6, 1, 4, 1, 3, 1, 1 };
00182 <span class="comment">/*</span>
00183 <span class="comment"> * enterprises.cmu.systems.cmuSNMP </span>
00184 <span class="comment"> */</span>
00185 
00186 <span class="preprocessor">#define DEFAULT_COMMUNITY   "public"</span>
00187 <span class="preprocessor">#define DEFAULT_RETRIES     5</span>
00188 <span class="preprocessor">#define DEFAULT_TIMEOUT     1000000L</span>
00189 <span class="preprocessor">#define DEFAULT_REMPORT     SNMP_PORT</span>
00190 <span class="preprocessor">#define DEFAULT_ENTERPRISE  default_enterprise</span>
00191 <span class="preprocessor">#define DEFAULT_TIME        0</span>
00192 
00193 <span class="comment">/*</span>
00194 <span class="comment"> * don't set higher than 0x7fffffff, and I doubt it should be that high</span>
00195 <span class="comment"> * * = 4 gig snmp messages max </span>
00196 <span class="comment"> */</span>
00197 <span class="preprocessor">#define MAXIMUM_PACKET_SIZE 0x7fffffff</span>
00198 
00199 <span class="comment">/*</span>
00200 <span class="comment"> * Internal information about the state of the snmp session.</span>
00201 <span class="comment"> */</span>
00202 <span class="keyword">struct </span>snmp_internal_session {
00203     netsnmp_request_list *requests;     <span class="comment">/* Info about outstanding requests */</span>
00204     netsnmp_request_list *requestsEnd;  <span class="comment">/* ptr to end of list */</span>
00205     int             (*hook_pre) (<a class="code" href=
"structsnmp__session.html">netsnmp_session</a> *, netsnmp_transport *,
00206                                  <span class="keywordtype">void</span> *, int);
00207     int             (*hook_parse) (<a class="code" href="structsnmp__session.html">netsnmp_session</a> *, <a class="code"
href="structsnmp__pdu.html">netsnmp_pdu</a> *,
00208                                    u_char *, size_t);
00209     int             (*hook_post) (<a class="code" href=
"structsnmp__session.html">netsnmp_session</a> *, netsnmp_pdu *, int);
00210     int             (*hook_build) (<a class="code" href="structsnmp__session.html">netsnmp_session</a> *, netsnmp_pdu *,
00211                                    u_char *, size_t *);
00212     int             (*hook_realloc_build) (<a class="code" href="structsnmp__session.html">netsnmp_session</a> *,
00213                                            netsnmp_pdu *, u_char **,
00214                                            size_t *, size_t *);
00215     int             (*check_packet) (u_char *, size_t);
00216     netsnmp_pdu    *(*hook_create_pdu) (netsnmp_transport *,
00217                                         <span class="keywordtype">void</span> *, size_t);
00218 
00219     u_char         *packet;
00220     size_t          packet_len, packet_size;
00221 };
00222 
00223 <span class="comment">/*</span>
00224 <span class="comment"> * The list of active/open sessions.</span>
00225 <span class="comment"> */</span>
00226 <span class="keyword">struct </span>session_list {
00227     <span class="keyword">struct </span>session_list *next;
00228     <a class="code" href="structsnmp__session.html">netsnmp_session</a> *session;
00229     netsnmp_transport *transport;
00230     <span class="keyword">struct </span>snmp_internal_session *internal;
00231 };
00232 
00233 
00234 
00235 <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *api_errors[-SNMPERR_MAX + 1] = {
00236     <span class="stringliteral">"No error"</span>,                 <span class="comment">/* SNMPERR_SUCCESS */</span>
00237     <span class="stringliteral">"Generic error"</span>,            <span class="comment">/* SNMPERR_GENERR */</span>
00238     <span class="stringliteral">"Invalid local port"</span>,       <span class="comment">/* SNMPERR_BAD_LOCPORT */</span>
00239     <span class="stringliteral">"Unknown host"</span>,             <span class="comment">/* SNMPERR_BAD_ADDRESS */</span>
00240     <span class="stringliteral">"Unknown session"</span>,          <span class="comment">/* SNMPERR_BAD_SESSION */</span>
00241     <span class="stringliteral">"Too long"</span>,                 <span class="comment">/* SNMPERR_TOO_LONG */</span>
00242     <span class="stringliteral">"No socket"</span>,                <span class="comment">/* SNMPERR_NO_SOCKET */</span>
00243     <span class="stringliteral">"Cannot send V2 PDU on V1 session"</span>, <span class=
"comment">/* SNMPERR_V2_IN_V1 */</span>
00244     <span class="stringliteral">"Cannot send V1 PDU on V2 session"</span>, <span class=
"comment">/* SNMPERR_V1_IN_V2 */</span>
00245     <span class="stringliteral">"Bad value for non-repeaters"</span>,      <span class=
"comment">/* SNMPERR_BAD_REPEATERS */</span>
00246     <span class="stringliteral">"Bad value for max-repetitions"</span>,    <span class=
"comment">/* SNMPERR_BAD_REPETITIONS */</span>
00247     <span class="stringliteral">"Error building ASN.1 representation"</span>,      <span class=
"comment">/* SNMPERR_BAD_ASN1_BUILD */</span>
00248     <span class="stringliteral">"Failure in sendto"</span>,        <span class="comment">/* SNMPERR_BAD_SENDTO */</span>
00249     <span class="stringliteral">"Bad parse of ASN.1 type"</span>,  <span class="comment">/* SNMPERR_BAD_PARSE */</span>
00250     <span class="stringliteral">"Bad version specified"</span>,    <span class="comment">/* SNMPERR_BAD_VERSION */</span>
00251     <span class="stringliteral">"Bad source party specified"</span>,       <span class=
"comment">/* SNMPERR_BAD_SRC_PARTY */</span>
00252     <span class="stringliteral">"Bad destination party specified"</span>,  <span class=
"comment">/* SNMPERR_BAD_DST_PARTY */</span>
00253     <span class="stringliteral">"Bad context specified"</span>,    <span class="comment">/* SNMPERR_BAD_CONTEXT */</span>
00254     <span class="stringliteral">"Bad community specified"</span>,  <span class="comment">/* SNMPERR_BAD_COMMUNITY */</span>
00255     <span class="stringliteral">"Cannot send noAuth/Priv"</span>,       <span class=
"comment">/* SNMPERR_NOAUTH_DESPRIV */</span>
00256     <span class="stringliteral">"Bad ACL definition"</span>,       <span class="comment">/* SNMPERR_BAD_ACL */</span>
00257     <span class="stringliteral">"Bad Party definition"</span>,     <span class="comment">/* SNMPERR_BAD_PARTY */</span>
00258     <span class="stringliteral">"Session abort failure"</span>,    <span class="comment">/* SNMPERR_ABORT */</span>
00259     <span class="stringliteral">"Unknown PDU type"</span>,         <span class="comment">/* SNMPERR_UNKNOWN_PDU */</span>
00260     <span class="stringliteral">"Timeout"</span>,                  <span class="comment">/* SNMPERR_TIMEOUT */</span>
00261     <span class="stringliteral">"Failure in recvfrom"</span>,      <span class="comment">/* SNMPERR_BAD_RECVFROM */</span>
00262     <span class="stringliteral">"Unable to determine contextEngineID"</span>,      <span class=
"comment">/* SNMPERR_BAD_ENG_ID */</span>
00263     <span class="stringliteral">"No securityName specified"</span>,        <span class=
"comment">/* SNMPERR_BAD_SEC_NAME */</span>
00264     <span class="stringliteral">"Unable to determine securityLevel"</span>,        <span class=
"comment">/* SNMPERR_BAD_SEC_LEVEL  */</span>
00265     <span class="stringliteral">"ASN.1 parse error in message"</span>,     <span class=
"comment">/* SNMPERR_ASN_PARSE_ERR */</span>
00266     <span class="stringliteral">"Unknown security model in message"</span>,        <span class=
"comment">/* SNMPERR_UNKNOWN_SEC_MODEL */</span>
00267     <span class="stringliteral">"Invalid message (e.g. msgFlags)"</span>,  <span class=
"comment">/* SNMPERR_INVALID_MSG */</span>
00268     <span class="stringliteral">"Unknown engine ID"</span>,        <span class=
"comment">/* SNMPERR_UNKNOWN_ENG_ID */</span>
00269     <span class="stringliteral">"Unknown user name"</span>,        <span class=
"comment">/* SNMPERR_UNKNOWN_USER_NAME */</span>
00270     <span class="stringliteral">"Unsupported security level"</span>,       <span class=
"comment">/* SNMPERR_UNSUPPORTED_SEC_LEVEL */</span>
00271     <span class="stringliteral">"Authentication failure (incorrect password, community or key)"</span>,    <span class=
"comment">/* SNMPERR_AUTHENTICATION_FAILURE */</span>
00272     <span class="stringliteral">"Not in time window"</span>,       <span class=
"comment">/* SNMPERR_NOT_IN_TIME_WINDOW */</span>
00273     <span class="stringliteral">"Decryption error"</span>,         <span class=
"comment">/* SNMPERR_DECRYPTION_ERR */</span>
00274     <span class="stringliteral">"SCAPI general failure"</span>,    <span class=
"comment">/* SNMPERR_SC_GENERAL_FAILURE */</span>
00275     <span class="stringliteral">"SCAPI sub-system not configured"</span>,  <span class=
"comment">/* SNMPERR_SC_NOT_CONFIGURED */</span>
00276     <span class="stringliteral">"Key tools not available"</span>,  <span class=
"comment">/* SNMPERR_KT_NOT_AVAILABLE */</span>
00277     <span class="stringliteral">"Unknown Report message"</span>,   <span class=
"comment">/* SNMPERR_UNKNOWN_REPORT */</span>
00278     <span class="stringliteral">"USM generic error"</span>,        <span class=
"comment">/* SNMPERR_USM_GENERICERROR */</span>
00279     <span class="stringliteral">"USM unknown security name (no such user exists)"</span>,  <span class=
"comment">/* SNMPERR_USM_UNKNOWNSECURITYNAME */</span>
00280     <span class=
"stringliteral">"USM unsupported security level (this user has not been configured for that level of security)"</span>,    <span class="comment">/* SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL */</span>
00281     <span class="stringliteral">"USM encryption error"</span>,     <span class=
"comment">/* SNMPERR_USM_ENCRYPTIONERROR */</span>
00282     <span class="stringliteral">"USM authentication failure (incorrect password or key)"</span>,   <span class=
"comment">/* SNMPERR_USM_AUTHENTICATIONFAILURE */</span>
00283     <span class="stringliteral">"USM parse error"</span>,          <span class=
"comment">/* SNMPERR_USM_PARSEERROR */</span>
00284     <span class="stringliteral">"USM unknown engineID"</span>,     <span class=
"comment">/* SNMPERR_USM_UNKNOWNENGINEID */</span>
00285     <span class="stringliteral">"USM not in time window"</span>,   <span class=
"comment">/* SNMPERR_USM_NOTINTIMEWINDOW */</span>
00286     <span class="stringliteral">"USM decryption error"</span>,     <span class=
"comment">/* SNMPERR_USM_DECRYPTIONERROR */</span>
00287     <span class="stringliteral">"MIB not initialized"</span>,      <span class="comment">/* SNMPERR_NOMIB */</span>
00288     <span class="stringliteral">"Value out of range"</span>,       <span class="comment">/* SNMPERR_RANGE */</span>
00289     <span class="stringliteral">"Sub-id out of range"</span>,      <span class="comment">/* SNMPERR_MAX_SUBID */</span>
00290     <span class="stringliteral">"Bad sub-id in object identifier"</span>,  <span class=
"comment">/* SNMPERR_BAD_SUBID */</span>
00291     <span class="stringliteral">"Object identifier too long"</span>,       <span class=
"comment">/* SNMPERR_LONG_OID */</span>
00292     <span class="stringliteral">"Bad value name"</span>,           <span class="comment">/* SNMPERR_BAD_NAME */</span>
00293     <span class="stringliteral">"Bad value notation"</span>,       <span class="comment">/* SNMPERR_VALUE */</span>
00294     <span class="stringliteral">"Unknown Object Identifier"</span>,        <span class=
"comment">/* SNMPERR_UNKNOWN_OBJID */</span>
00295     <span class="stringliteral">"No PDU in snmp_send"</span>,      <span class="comment">/* SNMPERR_NULL_PDU */</span>
00296     <span class="stringliteral">"Missing variables in PDU"</span>, <span class="comment">/* SNMPERR_NO_VARS */</span>
00297     <span class="stringliteral">"Bad variable type"</span>,        <span class="comment">/* SNMPERR_VAR_TYPE */</span>
00298     <span class="stringliteral">"Out of memory (malloc failure)"</span>,   <span class=
"comment">/* SNMPERR_MALLOC */</span>
00299     <span class="stringliteral">"Kerberos related error"</span>,   <span class="comment">/* SNMPERR_KRB5 */</span>
00300     <span class="stringliteral">"Protocol error"</span>,           <span class="comment">/* SNMPERR_PROTOCOL */</span>
00301 };
00302 
00303 <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *secLevelName[] = {
00304     <span class="stringliteral">"BAD_SEC_LEVEL"</span>,
00305     <span class="stringliteral">"noAuthNoPriv"</span>,
00306     <span class="stringliteral">"authNoPriv"</span>,
00307     <span class="stringliteral">"authPriv"</span>
00308 };
00309 
00310 <span class="comment">/*</span>
00311 <span class="comment"> * Multiple threads may changes these variables.</span>
00312 <span class="comment"> * Suggest using the Single API, which does not use Sessions.</span>
00313 <span class="comment"> *</span>
00314 <span class="comment"> * Reqid may need to be protected. Time will tell...</span>
00315 <span class="comment"> *</span>
00316 <span class="comment"> */</span>
00317 <span class="comment">/*</span>
00318 <span class="comment"> * MTCRITICAL_RESOURCE</span>
00319 <span class="comment"> */</span>
00320 <span class="comment">/*</span>
00321 <span class="comment"> * use token in comments to individually protect these resources </span>
00322 <span class="comment"> */</span>
00323 <span class="keyword">struct </span>session_list *Sessions = NULL;   <span class="comment">/* MT_LIB_SESSION */</span>
00324 <span class="keyword">static</span> <span class="keywordtype">long</span>     Reqid = 0;      <span class=
"comment">/* MT_LIB_REQUESTID */</span>
00325 <span class="keyword">static</span> <span class="keywordtype">long</span>     Msgid = 0;      <span class=
"comment">/* MT_LIB_MESSAGEID */</span>
00326 <span class="keyword">static</span> <span class="keywordtype">long</span>     Sessid = 0;     <span class=
"comment">/* MT_LIB_SESSIONID */</span>
00327 <span class="keyword">static</span> <span class="keywordtype">long</span>     Transid = 0;    <span class=
"comment">/* MT_LIB_TRANSID */</span>
00328 <span class="keywordtype">int</span>             snmp_errno = 0;
00329 <span class="comment">/*</span>
00330 <span class="comment"> * END MTCRITICAL_RESOURCE</span>
00331 <span class="comment"> */</span>
00332 
00333 <span class="comment">/*</span>
00334 <span class="comment"> * global error detail storage</span>
00335 <span class="comment"> */</span>
00336 <span class="keyword">static</span> <span class="keywordtype">char</span>     snmp_detail[192];
00337 <span class="keyword">static</span> <span class="keywordtype">int</span>      snmp_detail_f = 0;
00338 
00339 <span class="comment">/*</span>
00340 <span class="comment"> * Prototypes.</span>
00341 <span class="comment"> */</span>
00342 <span class="keywordtype">int</span>             snmp_build(u_char ** pkt, size_t * pkt_len,
00343                            size_t * offset, <a class="code" href="structsnmp__session.html">netsnmp_session</a> * pss,
00344                            <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu);
00345 <span class="keyword">static</span> <span class="keywordtype">int</span>      snmp_parse(<span class=
"keywordtype">void</span> *, <a class="code" href="structsnmp__session.html">netsnmp_session</a> *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *,
00346                            u_char *, size_t);
00347 
00348 <span class="keyword">static</span> <span class="keywordtype">void</span>     snmpv3_calc_msg_flags(<span class=
"keywordtype">int</span>, <span class="keywordtype">int</span>, u_char *);
00349 <span class="keyword">static</span> <span class=
"keywordtype">int</span>      snmpv3_verify_msg(netsnmp_request_list *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *);
00350 <span class="keyword">static</span> <span class="keywordtype">int</span>      snmpv3_build_probe_pdu(<a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> **);
00351 <span class="keyword">static</span> <span class="keywordtype">int</span>      snmpv3_build(u_char ** pkt, size_t * pkt_len,
00352                              size_t * offset, <a class="code" href=
"structsnmp__session.html">netsnmp_session</a> * session,
00353                              <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu);
00354 <span class="keyword">static</span> <span class="keywordtype">int</span>      snmp_parse_version(u_char *, size_t);
00355 <span class="keyword">static</span> <span class="keywordtype">int</span>      snmp_resend_request(<span class=
"keyword">struct</span> session_list *slp,
00356                                     netsnmp_request_list *rp,
00357                                     <span class="keywordtype">int</span> incr_retries);
00358 <span class="keyword">static</span> <span class="keywordtype">void</span>     register_default_handlers(<span class=
"keywordtype">void</span>);
00359 <span class="keyword">static</span> <span class="keyword">struct </span>session_list *snmp_sess_copy(<a class="code" href=
"structsnmp__session.html">netsnmp_session</a> * pss);
00360 <span class="keywordtype">int</span>             snmp_get_errno(<span class="keywordtype">void</span>);
00361 <span class="keywordtype">void</span>            snmp_synch_reset(<a class="code" href=
"structsnmp__session.html">netsnmp_session</a> * notused);
00362 <span class="keywordtype">void</span>            snmp_synch_setup(<a class="code" href=
"structsnmp__session.html">netsnmp_session</a> * notused);
00363 
00364 <span class="preprocessor">#ifndef HAVE_STRERROR</span>
00365 <span class="keyword">const</span> <span class="keywordtype">char</span>     *
00366 strerror(<span class="keywordtype">int</span> err)
00367 {
00368     <span class="keyword">extern</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *sys_errlist[];
00369     <span class="keyword">extern</span> <span class="keywordtype">int</span>      sys_nerr;
00370 
00371     <span class="keywordflow">if</span> (err &lt; 0 || err &gt;= sys_nerr)
00372         <span class="keywordflow">return</span> <span class="stringliteral">"Unknown error"</span>;
00373     <span class="keywordflow">return</span> sys_errlist[err];
00374 }
00375 <span class="preprocessor">#endif</span>
00376 
00377 <span class="keyword">const</span> <span class="keywordtype">char</span> *
00378 snmp_pdu_type(<span class="keywordtype">int</span> type)
00379 {
00380     <span class="keyword">static</span> <span class="keywordtype">char</span> unknown[20];
00381     <span class="keywordflow">switch</span>(type) {
00382     <span class="keywordflow">case</span> SNMP_MSG_GET:
00383         <span class="keywordflow">return</span> <span class="stringliteral">"GET"</span>;
00384     <span class="keywordflow">case</span> SNMP_MSG_GETNEXT:
00385         <span class="keywordflow">return</span> <span class="stringliteral">"GETNEXT"</span>;
00386     <span class="keywordflow">case</span> SNMP_MSG_RESPONSE:
00387         <span class="keywordflow">return</span> <span class="stringliteral">"RESPONSE"</span>;
00388     <span class="keywordflow">case</span> SNMP_MSG_SET:
00389         <span class="keywordflow">return</span> <span class="stringliteral">"SET"</span>;
00390     <span class="keywordflow">case</span> SNMP_MSG_GETBULK:
00391         <span class="keywordflow">return</span> <span class="stringliteral">"GETBULK"</span>;
00392     <span class="keywordflow">case</span> SNMP_MSG_INFORM:
00393         <span class="keywordflow">return</span> <span class="stringliteral">"INFORM"</span>;
00394     <span class="keywordflow">case</span> SNMP_MSG_TRAP2:
00395         <span class="keywordflow">return</span> <span class="stringliteral">"TRAP2"</span>;
00396     <span class="keywordflow">case</span> SNMP_MSG_REPORT:
00397         <span class="keywordflow">return</span> <span class="stringliteral">"REPORT"</span>;
00398     <span class="keywordflow">default</span>:
00399         snprintf(unknown, <span class="keyword">sizeof</span>(unknown), <span class=
"stringliteral">"?0x%2X?"</span>, type);
00400         <span class="keywordflow">return</span> unknown;
00401     }
00402 }
00403 
00404 <span class="preprocessor">#define DEBUGPRINTPDUTYPE(token, type) \</span>
00405 <span class="preprocessor">    DEBUGDUMPSECTION(token, snmp_pdu_type(type))</span>
00406 
00407 <span class="keywordtype">long</span>
00408 snmp_get_next_reqid(<span class="keywordtype">void</span>)
00409 {
00410     <span class="keywordtype">long</span>            retVal;
00411     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_REQUESTID);
00412     retVal = 1 + Reqid;         <span class="comment">/*MTCRITICAL_RESOURCE */</span>
00413     <span class="keywordflow">if</span> (!retVal)
00414         retVal = 2;
00415     Reqid = retVal;
00416     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_REQUESTID);
00417     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_16BIT_IDS))
00418         <span class="keywordflow">return</span> (retVal &amp; 0x7fff);       <span class=
"comment">/* mask to 15 bits */</span>
00419     <span class="keywordflow">else</span>
00420         <span class="keywordflow">return</span> retVal;
00421 }
00422 
00423 <span class="keywordtype">long</span>
00424 snmp_get_next_msgid(<span class="keywordtype">void</span>)
00425 {
00426     <span class="keywordtype">long</span>            retVal;
00427     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_MESSAGEID);
00428     retVal = 1 + Msgid;         <span class="comment">/*MTCRITICAL_RESOURCE */</span>
00429     <span class="keywordflow">if</span> (!retVal)
00430         retVal = 2;
00431     Msgid = retVal;
00432     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_MESSAGEID);
00433     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_16BIT_IDS))
00434         <span class="keywordflow">return</span> (retVal &amp; 0x7fff);       <span class=
"comment">/* mask to 15 bits */</span>
00435     <span class="keywordflow">else</span>
00436         <span class="keywordflow">return</span> retVal;
00437 }
00438 
00439 <span class="keywordtype">long</span>
00440 snmp_get_next_sessid(<span class="keywordtype">void</span>)
00441 {
00442     <span class="keywordtype">long</span>            retVal;
00443     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSIONID);
00444     retVal = 1 + Sessid;        <span class="comment">/*MTCRITICAL_RESOURCE */</span>
00445     <span class="keywordflow">if</span> (!retVal)
00446         retVal = 2;
00447     Sessid = retVal;
00448     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSIONID);
00449     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_16BIT_IDS))
00450         <span class="keywordflow">return</span> (retVal &amp; 0x7fff);       <span class=
"comment">/* mask to 15 bits */</span>
00451     <span class="keywordflow">else</span>
00452         <span class="keywordflow">return</span> retVal;
00453 }
00454 
00455 <span class="keywordtype">long</span>
00456 snmp_get_next_transid(<span class="keywordtype">void</span>)
00457 {
00458     <span class="keywordtype">long</span>            retVal;
00459     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_TRANSID);
00460     retVal = 1 + Transid;       <span class="comment">/*MTCRITICAL_RESOURCE */</span>
00461     <span class="keywordflow">if</span> (!retVal)
00462         retVal = 2;
00463     Transid = retVal;
00464     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_TRANSID);
00465     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_16BIT_IDS))
00466         <span class="keywordflow">return</span> (retVal &amp; 0x7fff);       <span class=
"comment">/* mask to 15 bits */</span>
00467     <span class="keywordflow">else</span>
00468         <span class="keywordflow">return</span> retVal;
00469 }
00470 
00471 <span class="keywordtype">void</span>
00472 snmp_perror(<span class="keyword">const</span> <span class="keywordtype">char</span> *prog_string)
00473 {
00474     <span class="keyword">const</span> <span class="keywordtype">char</span>     *str;
00475     <span class="keywordtype">int</span>             xerr;
00476     xerr = snmp_errno;          <span class="comment">/*MTCRITICAL_RESOURCE */</span>
00477     str = snmp_api_errstring(xerr);
00478     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"%s: %s\n"</span>, prog_string, str);
00479 }
00480 
00481 <span class="keywordtype">void</span>
00482 snmp_set_detail(<span class="keyword">const</span> <span class="keywordtype">char</span> *detail_string)
00483 {
00484     <span class="keywordflow">if</span> (detail_string != NULL) {
00485         strncpy((<span class="keywordtype">char</span> *) snmp_detail, detail_string, <span class=
"keyword">sizeof</span>(snmp_detail));
00486         snmp_detail[<span class="keyword">sizeof</span>(snmp_detail) - 1] = <span class="charliteral">'\0'</span>;
00487         snmp_detail_f = 1;
00488     }
00489 }
00490 
00491 <span class="comment">/*</span>
00492 <span class="comment"> * returns pointer to static data </span>
00493 <span class="comment"> */</span>
00494 <span class="comment">/*</span>
00495 <span class="comment"> * results not guaranteed in multi-threaded use </span>
00496 <span class="comment"> */</span>
00497 <span class="keyword">const</span> <span class="keywordtype">char</span>     *
00498 snmp_api_errstring(<span class="keywordtype">int</span> snmp_errnumber)
00499 {
00500     <span class="keyword">const</span> <span class="keywordtype">char</span>     *msg = <span class=
"stringliteral">""</span>;
00501     <span class="keyword">static</span> <span class="keywordtype">char</span>     msg_buf[SPRINT_MAX_LEN];
00502     <span class="keywordflow">if</span> (snmp_errnumber &gt;= SNMPERR_MAX &amp;&amp; snmp_errnumber &lt;= SNMPERR_GENERR) {
00503         msg = api_errors[-snmp_errnumber];
00504     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (snmp_errnumber != SNMPERR_SUCCESS) {
00505         msg = NULL;
00506     }
00507     <span class="keywordflow">if</span> (!msg)
00508         snprintf(msg_buf, <span class="keyword">sizeof</span>(msg_buf), <span class=
"stringliteral">"Unknown error: %d"</span>, snmp_errnumber);
00509     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (snmp_detail_f) {
00510         snprintf(msg_buf, <span class="keyword">sizeof</span>(msg_buf), <span class=
"stringliteral">"%s (%s)"</span>, msg, snmp_detail);
00511         snmp_detail_f = 0;
00512     } <span class="keywordflow">else</span> {
00513         strncpy(msg_buf, msg, <span class="keyword">sizeof</span>(msg_buf));
00514     }
00515     msg_buf[<span class="keyword">sizeof</span>(msg_buf)-1] = <span class="charliteral">'\0'</span>;
00516 
00517     <span class="keywordflow">return</span> (msg_buf);
00518 }
00519 
00520 <span class="comment">/*</span>
00521 <span class="comment"> * snmp_error - return error data</span>
00522 <span class="comment"> * Inputs :  address of errno, address of snmp_errno, address of string</span>
00523 <span class="comment"> * Caller must free the string returned after use.</span>
00524 <span class="comment"> */</span>
00525 <span class="keywordtype">void</span>
00526 snmp_error(<a class="code" href="structsnmp__session.html">netsnmp_session</a> * psess,
00527            <span class="keywordtype">int</span> *p_errno, <span class="keywordtype">int</span> *p_snmp_errno, <span class=
"keywordtype">char</span> **p_str)
00528 {
00529     <span class="keywordtype">char</span>            buf[SPRINT_MAX_LEN];
00530     <span class="keywordtype">int</span>             snmp_errnumber;
00531 
00532     <span class="keywordflow">if</span> (p_errno)
00533         *p_errno = psess-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a>;
00534     <span class="keywordflow">if</span> (p_snmp_errno)
00535         *p_snmp_errno = psess-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>;
00536     <span class="keywordflow">if</span> (p_str == NULL)
00537         <span class="keywordflow">return</span>;
00538 
00539     strcpy(buf, <span class="stringliteral">""</span>);
00540     snmp_errnumber = psess-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>;
00541     <span class="keywordflow">if</span> (snmp_errnumber &gt;= SNMPERR_MAX &amp;&amp; snmp_errnumber &lt;= SNMPERR_GENERR) {
00542         <span class="keywordflow">if</span> (snmp_detail_f) {
00543             snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class=
"stringliteral">"%s (%s)"</span>, api_errors[-snmp_errnumber],
00544                     snmp_detail);
00545             snmp_detail_f = 0;
00546         }
00547         <span class="keywordflow">else</span>
00548             strncpy(buf, api_errors[-snmp_errnumber], <span class="keyword">sizeof</span>(buf));
00549     } <span class="keywordflow">else</span> {
00550         <span class="keywordflow">if</span> (snmp_errnumber)
00551             snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class=
"stringliteral">"Unknown Error %d"</span>, snmp_errnumber);
00552     }
00553     buf[<span class="keyword">sizeof</span>(buf)-1] = <span class="charliteral">'\0'</span>;
00554 
00555     <span class="comment">/*</span>
00556 <span class="comment">     * append a useful system errno interpretation. </span>
00557 <span class="comment">     */</span>
00558     <span class="keywordflow">if</span> (psess-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a>) {
00559         <span class="keyword">const</span> <span class="keywordtype">char</span>* error = strerror(psess-&gt;<a class=
"code" href="structsnmp__session.html#o13">s_errno</a>);
00560         <span class="keywordflow">if</span>(error == NULL)
00561             error = <span class="stringliteral">"Unknown Error"</span>;
00562         snprintf (&amp;buf[strlen(buf)], <span class="keyword">sizeof</span>(buf)-strlen(buf),
00563                  <span class="stringliteral">" (%s)"</span>, error);
00564     }
00565     buf[<span class="keyword">sizeof</span>(buf)-1] = <span class="charliteral">'\0'</span>;
00566     *p_str = strdup(buf);
00567 }
00568 
00569 <span class="comment">/*</span>
00570 <span class="comment"> * snmp_sess_error - same as snmp_error for single session API use.</span>
00571 <span class="comment"> */</span>
00572 <span class="keywordtype">void</span>
00573 snmp_sess_error(<span class="keywordtype">void</span> *sessp, <span class="keywordtype">int</span> *p_errno, <span class=
"keywordtype">int</span> *p_snmp_errno, <span class="keywordtype">char</span> **p_str)
00574 {
00575     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
00576 
00577     <span class="keywordflow">if</span> ((slp) &amp;&amp; (slp-&gt;session))
00578         snmp_error(slp-&gt;session, p_errno, p_snmp_errno, p_str);
00579 }
00580 
00581 <span class="comment">/*</span>
00582 <span class="comment"> * snmp_sess_perror(): print a error stored in a session pointer </span>
00583 <span class="comment"> */</span>
00584 <span class="keywordtype">void</span>
00585 netsnmp_sess_log_error(<span class="keywordtype">int</span> priority,
00586                        <span class="keyword">const</span> <span class="keywordtype">char</span> *prog_string, <a class=
"code" href="structsnmp__session.html">netsnmp_session</a> * ss)
00587 {
00588     <span class="keywordtype">char</span>           *err;
00589     snmp_error(ss, NULL, NULL, &amp;err);
00590     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(priority, <span class=
"stringliteral">"%s: %s\n"</span>, prog_string, err);
00591     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(err);
00592 }
00593 
00594 <span class="comment">/*</span>
00595 <span class="comment"> * snmp_sess_perror(): print a error stored in a session pointer </span>
00596 <span class="comment"> */</span>
00597 <span class="keywordtype">void</span>
00598 snmp_sess_perror(<span class="keyword">const</span> <span class="keywordtype">char</span> *prog_string, <a class="code"
href="structsnmp__session.html">netsnmp_session</a> * ss)
00599 {
00600     netsnmp_sess_log_error(LOG_ERR, prog_string, ss);
00601 }
00602 
00603 
00604 
00605 <span class="comment">/*</span>
00606 <span class="comment"> * Primordial SNMP library initialization.</span>
00607 <span class="comment"> * Initializes mutex locks.</span>
00608 <span class="comment"> * Invokes minimum required initialization for displaying MIB objects.</span>
00609 <span class="comment"> * Gets initial request ID for all transactions,</span>
00610 <span class="comment"> * and finds which port SNMP over UDP uses.</span>
00611 <span class="comment"> * SNMP over AppleTalk is not currently supported.</span>
00612 <span class="comment"> *</span>
00613 <span class="comment"> * Warning: no debug messages here.</span>
00614 <span class="comment"> */</span>
00615 <span class="keyword">static</span> <span class="keywordtype">void</span>
00616 _init_snmp(<span class="keywordtype">void</span>)
00617 {
00618 <span class="preprocessor">#ifdef  HAVE_GETSERVBYNAME</span>
00619     <span class="keyword">struct </span>servent *servp;
00620 <span class="preprocessor">#endif</span>
00621     <span class="keyword">static</span> <span class="keywordtype">char</span>     have_done_init = 0;
00622 
00623     <span class="keyword">struct </span>timeval  tv;
00624     <span class="keywordtype">long</span>            tmpReqid, tmpMsgid;
00625     u_short         s_port = SNMP_PORT;
00626 
00627     <span class="keywordflow">if</span> (have_done_init)
00628         <span class="keywordflow">return</span>;
00629     have_done_init = 1;
00630     Reqid = 1;
00631 
00632     snmp_res_init();            <span class="comment">/* initialize the mt locking structures */</span>
00633 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
00634     init_mib_internals();
00635 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
00636     netsnmp_tdomain_init();
00637 
00638     gettimeofday(&amp;tv, (<span class="keyword">struct</span> timezone *) 0);
00639     <span class="comment">/*</span>
00640 <span class="comment">     * Now = tv;</span>
00641 <span class="comment">     */</span>
00642 
00643     <span class="comment">/*</span>
00644 <span class="comment">     * get pseudo-random values for request ID and message ID </span>
00645 <span class="comment">     */</span>
00646     <span class="comment">/*</span>
00647 <span class="comment">     * don't allow zero value to repeat init </span>
00648 <span class="comment">     */</span>
00649 <span class="preprocessor">#ifdef SVR4</span>
00650     srand48(tv.tv_sec ^ tv.tv_usec);
00651     tmpReqid = lrand48();
00652     tmpMsgid = lrand48();
00653 <span class="preprocessor">#else</span>
00654     srandom(tv.tv_sec ^ tv.tv_usec);
00655     tmpReqid = random();
00656     tmpMsgid = random();
00657 <span class="preprocessor">#endif</span>
00658 
00659     <span class="keywordflow">if</span> (tmpReqid == 0)
00660         tmpReqid = 1;
00661     <span class="keywordflow">if</span> (tmpMsgid == 0)
00662         tmpMsgid = 1;
00663     Reqid = tmpReqid;
00664     Msgid = tmpMsgid;
00665 
00666 <span class="preprocessor">#ifdef HAVE_GETSERVBYNAME</span>
00667     servp = getservbyname(<span class="stringliteral">"snmp"</span>, <span class="stringliteral">"udp"</span>);
00668     <span class="keywordflow">if</span> (servp) {
00669         <span class="comment">/*</span>
00670 <span class="comment">         * store it in host byte order </span>
00671 <span class="comment">         */</span>
00672         s_port = ntohs(servp-&gt;s_port);
00673     }
00674 <span class="preprocessor">#endif</span>
00675 
00676     netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, 
00677                        NETSNMP_DS_LIB_DEFAULT_PORT, s_port);
00678     netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, 
00679                        NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH, 16);
00680 
00681 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
00682     <a class="code" href="group__default__store.html#ga8">netsnmp_ds_set_boolean</a>(NETSNMP_DS_LIBRARY_ID, 
00683                            NETSNMP_DS_LIB_REVERSE_ENCODE,
00684                            DEFAULT_ASNENCODING_DIRECTION);
00685 <span class="preprocessor">#endif</span>
00686 }
00687 
00688 <span class="comment">/*</span>
00689 <span class="comment"> * Initializes the session structure.</span>
00690 <span class="comment"> * May perform one time minimal library initialization.</span>
00691 <span class="comment"> * No MIB file processing is done via this call.</span>
00692 <span class="comment"> */</span>
00693 <span class="keywordtype">void</span>
00694 snmp_sess_init(<a class="code" href="structsnmp__session.html">netsnmp_session</a> * session)
00695 {
00696     _init_snmp();
00697 
00698     <span class="comment">/*</span>
00699 <span class="comment">     * initialize session to default values </span>
00700 <span class="comment">     */</span>
00701 
00702     memset(session, 0, <span class="keyword">sizeof</span>(<a class="code" href=
"structsnmp__session.html">netsnmp_session</a>));
00703     session-&gt;<a class="code" href="structsnmp__session.html#o7">remote_port</a> = SNMP_DEFAULT_REMPORT;
00704     session-&gt;<a class="code" href="structsnmp__session.html#o2">timeout</a> = SNMP_DEFAULT_TIMEOUT;
00705     session-&gt;<a class="code" href="structsnmp__session.html#o1">retries</a> = SNMP_DEFAULT_RETRIES;
00706     session-&gt;<a class="code" href="structsnmp__session.html#o0">version</a> = SNMP_DEFAULT_VERSION;
00707     session-&gt;<a class="code" href="structsnmp__session.html#o43">securityModel</a> = SNMP_DEFAULT_SECMODEL;
00708     session-&gt;<a class="code" href="structsnmp__session.html#o18">rcvMsgMaxSize</a> = SNMP_MAX_MSG_SIZE;
00709     session-&gt;<a class="code" href="structsnmp__session.html#o3">flags</a> |= SNMP_FLAGS_DONT_PROBE;
00710 }
00711 
00712 
00713 <span class="keyword">static</span> <span class="keywordtype">void</span>
00714 register_default_handlers(<span class="keywordtype">void</span>)
00715 {
00716     netsnmp_ds_register_config(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"dumpPacket"</span>,
00717                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DUMP_PACKET);
00718     netsnmp_ds_register_config(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"reverseEncodeBER"</span>,
00719                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REVERSE_ENCODE);
00720     netsnmp_ds_register_config(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"defaultPort"</span>,
00721                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DEFAULT_PORT);
00722 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
00723     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"defCommunity"</span>,
00724                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_COMMUNITY);
00725 <span class="preprocessor">#endif</span>
00726     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"noTokenWarnings"</span>,
00727                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NO_TOKEN_WARNINGS);
00728     netsnmp_ds_register_config(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"noRangeCheck"</span>,
00729                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_CHECK_RANGE);
00730     netsnmp_ds_register_premib(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"persistentDir"</span>,
00731                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PERSISTENT_DIR);
00732     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"tempFilePattern"</span>,
00733                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_TEMP_FILE_PATTERN);
00734     netsnmp_ds_register_config(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"noDisplayHint"</span>,
00735                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NO_DISPLAY_HINT);
00736     netsnmp_ds_register_config(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"16bitIDs"</span>,
00737                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_16BIT_IDS);
00738     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"clientaddr"</span>,
00739                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_CLIENT_ADDR);
00740     netsnmp_ds_register_config(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"serverSendBuf"</span>,
00741                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SERVERSENDBUF);
00742     netsnmp_ds_register_config(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"serverRecvBuf"</span>,
00743                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SERVERRECVBUF);
00744     netsnmp_ds_register_config(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"clientSendBuf"</span>,
00745                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_CLIENTSENDBUF);
00746     netsnmp_ds_register_config(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"clientRecvBuf"</span>,
00747                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_CLIENTRECVBUF);
00748     netsnmp_ds_register_config(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"noPersistentLoad"</span>,
00749                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DISABLE_PERSISTENT_LOAD);
00750     netsnmp_ds_register_config(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"noPersistentSave"</span>,
00751                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAVE);
00752 }
00753 
00754 <span class="keywordtype">void</span>
00755 init_snmp_enums(<span class="keywordtype">void</span>)
00756 {
00757     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"integer"</span>), ASN_INTEGER);
00758     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"counter"</span>), ASN_COUNTER);
00759     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"uinteger"</span>), ASN_GAUGE);
00760     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"timeticks"</span>), ASN_TIMETICKS);
00761     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"counter64"</span>), ASN_COUNTER64);
00762     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"octet_str"</span>), ASN_OCTET_STR);
00763     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"ipaddress"</span>), ASN_IPADDRESS);
00764     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"opaque"</span>), ASN_OPAQUE);
00765     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"nsap"</span>), ASN_NSAP);
00766     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"object_id"</span>), ASN_OBJECT_ID);
00767     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"null"</span>), ASN_NULL);
00768 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00769     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"opaque_counter64"</span>),
00770                          ASN_OPAQUE_COUNTER64);
00771     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"opaque_u64"</span>), ASN_OPAQUE_U64);
00772     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"opaque_float"</span>),
00773                          ASN_OPAQUE_FLOAT);
00774     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"opaque_double"</span>),
00775                          ASN_OPAQUE_DOUBLE);
00776     se_add_pair_to_slist(<span class="stringliteral">"asntypes"</span>, strdup(<span class=
"stringliteral">"opaque_i64"</span>), ASN_OPAQUE_I64);
00777 <span class="preprocessor">#endif</span>
00778 }
00779 
00780 
00781 
00792 <span class="keywordtype">void</span>
<a name="l00793" id="l00793"></a><a class="code" href="group__library.html#ga56">00793</a> <a class="code" href=
"group__library.html#ga56">init_snmp</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *type)
00794 {
00795     <span class="keyword">static</span> <span class="keywordtype">int</span>      done_init = 0;      <span class=
"comment">/* To prevent double init's. */</span>
00796 
00797     <span class="keywordflow">if</span> (done_init) {
00798         <span class="keywordflow">return</span>;
00799     }
00800 
00801     done_init = 1;
00802 
00803     <span class="comment">/*</span>
00804 <span class="comment">     * make the type available everywhere else </span>
00805 <span class="comment">     */</span>
00806     <span class="keywordflow">if</span> (type &amp;&amp; !netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
00807                                        NETSNMP_DS_LIB_APPTYPE)) {
00808         netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID, 
00809                               NETSNMP_DS_LIB_APPTYPE, type);
00810     }
00811 
00812     _init_snmp();
00813 
00814     <span class="comment">/*</span>
00815 <span class="comment">     * set our current locale properly to initialize isprint() type functions </span>
00816 <span class="comment">     */</span>
00817 <span class="preprocessor">#ifdef HAVE_SETLOCALE</span>
00818     setlocale(LC_CTYPE, <span class="stringliteral">""</span>);
00819 <span class="preprocessor">#endif</span>
00820 
00821     snmp_debug_init();    <span class="comment">/* should be done first, to turn on debugging ASAP */</span>
00822     netsnmp_container_init_list();
00823     init_callbacks();
00824     init_snmp_logging();
00825     snmp_init_statistics();
00826     register_mib_handlers();
00827     register_default_handlers();
00828     init_snmpv3(type);
00829     init_snmp_alarm();
00830     init_snmp_enum(type);
00831     init_snmp_enums();
00832     init_vacm();
00833 
00834     read_premib_configs();
00835 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
00836     <a class="code" href="group__mib__utilities.html#ga57">init_mib</a>();
00837 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
00838 
00839     read_configs();
00840 
00841 }                               <span class="comment">/* end init_snmp() */</span>
00842 
00843 <span class="keywordtype">void</span>
00844 snmp_store(<span class="keyword">const</span> <span class="keywordtype">char</span> *type)
00845 {
00846     DEBUGMSGTL((<span class="stringliteral">"snmp_store"</span>, <span class="stringliteral">"storing stuff...\n"</span>));
00847     snmp_save_persistent(type);
00848     <a class="code" href=
"group__callback.html#ga10">snmp_call_callbacks</a>(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, NULL);
00849     snmp_clean_persistent(type);
00850 }
00851 
00852 
00861 <span class="keywordtype">void</span>
<a name="l00862" id="l00862"></a><a class="code" href="group__library.html#ga58">00862</a> <a class="code" href=
"group__library.html#ga58">snmp_shutdown</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *type)
00863 {
00864     snmp_store(type);
00865     <a class="code" href=
"group__callback.html#ga10">snmp_call_callbacks</a>(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, NULL);
00866     <a class="code" href="group__snmp__alarm.html#ga7">snmp_alarm_unregister_all</a>();
00867     snmp_close_sessions();
00868 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
00869     <a class="code" href="group__mib__utilities.html#ga58">shutdown_mib</a>();
00870 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
00871     unregister_all_config_handlers();
00872     netsnmp_container_free_list();
00873     clear_sec_mod();
00874     clear_snmp_enum();
00875     netsnmp_clear_tdomain_list();
00876     clear_callback();
00877     netsnmp_ds_shutdown();
00878 }
00879 
00880 
00881 <span class="comment">/*</span>
00882 <span class="comment"> * Sets up the session with the snmp_session information provided by the user.</span>
00883 <span class="comment"> * Then opens and binds the necessary low-level transport.  A handle to the</span>
00884 <span class="comment"> * created session is returned (this is NOT the same as the pointer passed to</span>
00885 <span class="comment"> * snmp_open()).  On any error, NULL is returned and snmp_errno is set to the</span>
00886 <span class="comment"> * appropriate error code.</span>
00887 <span class="comment"> */</span>
00888 <a class="code" href="structsnmp__session.html">netsnmp_session</a> *
00889 snmp_open(<a class="code" href="structsnmp__session.html">netsnmp_session</a> *session)
00890 {
00891     <span class="keyword">struct </span>session_list *slp;
00892     slp = (<span class="keyword">struct </span>session_list *) snmp_sess_open(session);
00893     <span class="keywordflow">if</span> (!slp) {
00894         <span class="keywordflow">return</span> NULL;
00895     }
00896 
00897     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
00898     slp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = Sessions;
00899     Sessions = slp;
00900     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
00901 
00902     <span class="keywordflow">return</span> (slp-&gt;session);
00903 }
00904 
00905 <span class="comment">/*</span>
00906 <span class="comment"> * extended open </span>
00907 <span class="comment"> */</span>
00908 <a class="code" href="structsnmp__session.html">netsnmp_session</a> *
00909 snmp_open_ex(<a class="code" href="structsnmp__session.html">netsnmp_session</a> *session,
00910              <span class="keywordtype">int</span> (*fpre_parse)  (<a class="code" href=
"structsnmp__session.html">netsnmp_session</a> *, netsnmp_transport *,
00911                                 <span class="keywordtype">void</span> *, <span class="keywordtype">int</span>),
00912              <span class="keywordtype">int</span> (*fparse)      (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, u_char *,
00913                                  size_t),
00914              <span class="keywordtype">int</span> (*fpost_parse) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, <span class="keywordtype">int</span>),
00915 
00916              <span class="keywordtype">int</span> (*fbuild)      (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, u_char *,
00917                                  size_t *),
00918              <span class="keywordtype">int</span> (*frbuild)     (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *,
00919                                  u_char **, size_t *, size_t *),
00920              <span class="keywordtype">int</span> (*fcheck)      (u_char *, size_t)
00921              )
00922 {
00923     <span class="keyword">struct </span>session_list *slp;
00924     slp = (<span class="keyword">struct </span>session_list *) snmp_sess_open(session);
00925     <span class="keywordflow">if</span> (!slp) {
00926         <span class="keywordflow">return</span> NULL;
00927     }
00928     slp-&gt;internal-&gt;hook_pre = fpre_parse;
00929     slp-&gt;internal-&gt;hook_parse = fparse;
00930     slp-&gt;internal-&gt;hook_post = fpost_parse;
00931     slp-&gt;internal-&gt;hook_build = fbuild;
00932     slp-&gt;internal-&gt;hook_realloc_build = frbuild;
00933     slp-&gt;internal-&gt;check_packet = fcheck;
00934 
00935     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
00936     slp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = Sessions;
00937     Sessions = slp;
00938     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
00939 
00940     <span class="keywordflow">return</span> (slp-&gt;session);
00941 }
00942 
00943 <span class="keyword">static</span> <span class="keyword">struct </span>session_list *
00944 _sess_copy(netsnmp_session * in_session)
00945 {
00946     <span class="keyword">struct </span>session_list *slp;
00947     <span class="keyword">struct </span>snmp_internal_session *isp;
00948     netsnmp_session *session;
00949     <span class="keyword">struct </span>snmp_secmod_def *sptr;
00950     <span class="keywordtype">char</span>           *cp;
00951     u_char         *ucp;
00952     size_t          i;
00953 
00954     in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
00955     in_session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
00956 
00957     <span class="comment">/*</span>
00958 <span class="comment">     * Copy session structure and link into list </span>
00959 <span class="comment">     */</span>
00960     slp = (<span class="keyword">struct </span>session_list *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> session_list));
00961     <span class="keywordflow">if</span> (slp == NULL) {
00962         in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
00963         <span class="keywordflow">return</span> (NULL);
00964     }
00965 
00966     slp-&gt;transport = NULL;
00967 
00968     isp = (<span class="keyword">struct </span>snmp_internal_session *)calloc(1, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> snmp_internal_session));
00969 
00970     <span class="keywordflow">if</span> (isp == NULL) {
00971         snmp_sess_close(slp);
00972         in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
00973         <span class="keywordflow">return</span> (NULL);
00974     }
00975 
00976     slp-&gt;internal = isp;
00977     slp-&gt;session = (netsnmp_session *)malloc(<span class="keyword">sizeof</span>(netsnmp_session));
00978     <span class="keywordflow">if</span> (slp-&gt;session == NULL) {
00979         snmp_sess_close(slp);
00980         in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
00981         <span class="keywordflow">return</span> (NULL);
00982     }
00983     memmove(slp-&gt;session, in_session, <span class="keyword">sizeof</span>(netsnmp_session));
00984     session = slp-&gt;session;
00985 
00986     <span class="comment">/*</span>
00987 <span class="comment">     * zero out pointers so if we have to free the session we wont free mem</span>
00988 <span class="comment">     * owned by in_session </span>
00989 <span class="comment">     */</span>
00990     session-&gt;<a class="code" href="structsnmp__session.html#o6">peername</a> = NULL;
00991     session-&gt;<a class="code" href="structsnmp__session.html#o16">community</a> = NULL;
00992     session-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a> = NULL;
00993     session-&gt;<a class="code" href="structsnmp__session.html#o25">contextName</a> = NULL;
00994     session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a> = NULL;
00995     session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a> = NULL;
00996     session-&gt;<a class="code" href="structsnmp__session.html#o31">securityAuthProto</a> = NULL;
00997     session-&gt;<a class="code" href="structsnmp__session.html#o37">securityPrivProto</a> = NULL;
00998     <span class="comment">/*</span>
00999 <span class="comment">     * session now points to the new structure that still contains pointers to</span>
01000 <span class="comment">     * data allocated elsewhere.  Some of this data is copied to space malloc'd</span>
01001 <span class="comment">     * here, and the pointer replaced with the new one.</span>
01002 <span class="comment">     */</span>
01003 
01004     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o6">peername</a> != NULL) {
01005         session-&gt;<a class="code" href="structsnmp__session.html#o6">peername</a> = (<span class=
"keywordtype">char</span> *)malloc(strlen(in_session-&gt;<a class="code" href="structsnmp__session.html#o6">peername</a>) + 1);
01006         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o6">peername</a> == NULL) {
01007             snmp_sess_close(slp);
01008             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
01009             <span class="keywordflow">return</span> (NULL);
01010         }
01011         strcpy(session-&gt;<a class="code" href="structsnmp__session.html#o6">peername</a>, in_session-&gt;<a class="code"
href="structsnmp__session.html#o6">peername</a>);
01012     }
01013 
01014     <span class="comment">/*</span>
01015 <span class="comment">     * Fill in defaults if necessary </span>
01016 <span class="comment">     */</span>
01017 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
01018     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a> != SNMP_DEFAULT_COMMUNITY_LEN) {
01019         ucp = (u_char *) malloc(in_session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a>);
01020         <span class="keywordflow">if</span> (ucp != NULL)
01021             memmove(ucp, in_session-&gt;<a class="code" href=
"structsnmp__session.html#o16">community</a>, in_session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>);
01022     } <span class="keywordflow">else</span> {
01023         <span class="keywordflow">if</span> ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01024                                         NETSNMP_DS_LIB_COMMUNITY)) != NULL) {
01025             session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a> = strlen(cp);
01026             ucp = (u_char *) malloc(session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a>);
01027             <span class="keywordflow">if</span> (ucp)
01028                 memmove(ucp, cp, session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a>);
01029         } <span class="keywordflow">else</span> {
01030 <span class="preprocessor">#ifdef NO_ZEROLENGTH_COMMUNITY</span>
01031             session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a> = strlen(DEFAULT_COMMUNITY);
01032             ucp = (u_char *) malloc(session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a>);
01033             <span class="keywordflow">if</span> (ucp)
01034                 memmove(ucp, DEFAULT_COMMUNITY, session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>);
01035 <span class="preprocessor">#else</span>
01036             ucp = (u_char *) strdup(<span class="stringliteral">""</span>);
01037 <span class="preprocessor">#endif</span>
01038         }
01039     }
01040 
01041     <span class="keywordflow">if</span> (ucp == NULL) {
01042         snmp_sess_close(slp);
01043         in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
01044         <span class="keywordflow">return</span> (NULL);
01045     }
01046     session-&gt;<a class="code" href="structsnmp__session.html#o16">community</a> = ucp;   <span class=
"comment">/* replace pointer with pointer to new data */</span>
01047 <span class="preprocessor">#endif</span>
01048 
01049     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o44">securityLevel</a> &lt;= 0) {
01050         session-&gt;<a class="code" href="structsnmp__session.html#o44">securityLevel</a> =
01051             netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SECLEVEL);
01052     }
01053 
01054     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o44">securityLevel</a> == 0)
01055         session-&gt;<a class="code" href="structsnmp__session.html#o44">securityLevel</a> = SNMP_SEC_LEVEL_NOAUTH;
01056 
01057     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o32">securityAuthProtoLen</a> &gt; 0) {
01058         session-&gt;<a class="code" href="structsnmp__session.html#o31">securityAuthProto</a> =
01059             snmp_duplicate_objid(in_session-&gt;<a class="code" href="structsnmp__session.html#o31">securityAuthProto</a>,
01060                                  in_session-&gt;<a class="code" href=
"structsnmp__session.html#o32">securityAuthProtoLen</a>);
01061         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o31">securityAuthProto</a> == NULL) {
01062             snmp_sess_close(slp);
01063             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
01064             <span class="keywordflow">return</span> (NULL);
01065         }
01066     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (get_default_authtype(&amp;i) != NULL) {
01067         session-&gt;<a class="code" href="structsnmp__session.html#o31">securityAuthProto</a> =
01068             snmp_duplicate_objid(get_default_authtype(NULL), i);
01069         session-&gt;<a class="code" href="structsnmp__session.html#o32">securityAuthProtoLen</a> = i;
01070     }
01071 
01072     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o38">securityPrivProtoLen</a> &gt; 0) {
01073         session-&gt;<a class="code" href="structsnmp__session.html#o37">securityPrivProto</a> =
01074             snmp_duplicate_objid(in_session-&gt;<a class="code" href="structsnmp__session.html#o37">securityPrivProto</a>,
01075                                  in_session-&gt;<a class="code" href=
"structsnmp__session.html#o38">securityPrivProtoLen</a>);
01076         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o37">securityPrivProto</a> == NULL) {
01077             snmp_sess_close(slp);
01078             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
01079             <span class="keywordflow">return</span> (NULL);
01080         }
01081     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (get_default_privtype(&amp;i) != NULL) {
01082         session-&gt;<a class="code" href="structsnmp__session.html#o37">securityPrivProto</a> =
01083             snmp_duplicate_objid(get_default_privtype(NULL), i);
01084         session-&gt;<a class="code" href="structsnmp__session.html#o38">securityPrivProtoLen</a> = i;
01085     }
01086 
01087     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a> &gt; 0) {
01088         ucp = (u_char *) malloc(in_session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a>);
01089         <span class="keywordflow">if</span> (ucp == NULL) {
01090             snmp_sess_close(slp);
01091             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
01092             <span class="keywordflow">return</span> (NULL);
01093         }
01094         memmove(ucp, in_session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
01095                 in_session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>);
01096         session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a> = ucp;
01097 
01098     }
01099 
01100     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o22">contextEngineIDLen</a> &gt; 0) {
01101         ucp = (u_char *) malloc(in_session-&gt;<a class="code" href="structsnmp__session.html#o22">contextEngineIDLen</a>);
01102         <span class="keywordflow">if</span> (ucp == NULL) {
01103             snmp_sess_close(slp);
01104             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
01105             <span class="keywordflow">return</span> (NULL);
01106         }
01107         memmove(ucp, in_session-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a>,
01108                 in_session-&gt;<a class="code" href="structsnmp__session.html#o22">contextEngineIDLen</a>);
01109         session-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a> = ucp;
01110     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a> &gt; 0) {
01111         <span class="comment">/*</span>
01112 <span class="comment">         * default contextEngineID to securityEngineIDLen if defined </span>
01113 <span class="comment">         */</span>
01114         ucp = (u_char *) malloc(in_session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a>);
01115         <span class="keywordflow">if</span> (ucp == NULL) {
01116             snmp_sess_close(slp);
01117             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
01118             <span class="keywordflow">return</span> (NULL);
01119         }
01120         memmove(ucp, in_session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
01121                 in_session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>);
01122         session-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a> = ucp;
01123         session-&gt;<a class="code" href="structsnmp__session.html#o22">contextEngineIDLen</a> = in_session-&gt;<a class=
"code" href="structsnmp__session.html#o28">securityEngineIDLen</a>;
01124     }
01125 
01126     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o25">contextName</a>) {
01127         session-&gt;<a class="code" href="structsnmp__session.html#o25">contextName</a> = strdup(in_session-&gt;<a class=
"code" href="structsnmp__session.html#o25">contextName</a>);
01128         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o25">contextName</a> == NULL) {
01129             snmp_sess_close(slp);
01130             <span class="keywordflow">return</span> (NULL);
01131         }
01132     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01133                                            NETSNMP_DS_LIB_CONTEXT)) != NULL) {
01134         cp = strdup(cp);
01135         <span class="keywordflow">if</span> (cp == NULL) {
01136             snmp_sess_close(slp);
01137             <span class="keywordflow">return</span> (NULL);
01138         }
01139         session-&gt;<a class="code" href="structsnmp__session.html#o25">contextName</a> = cp;
01140         session-&gt;<a class="code" href="structsnmp__session.html#o26">contextNameLen</a> = strlen(cp);
01141     } <span class="keywordflow">else</span> {
01142         cp = strdup(SNMP_DEFAULT_CONTEXT);
01143         session-&gt;<a class="code" href="structsnmp__session.html#o25">contextName</a> = cp;
01144         session-&gt;<a class="code" href="structsnmp__session.html#o26">contextNameLen</a> = strlen(cp);
01145     }
01146 
01147     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href=
"structsnmp__session.html#o29">securityName</a>) {
01148         session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a> = strdup(in_session-&gt;<a class=
"code" href="structsnmp__session.html#o29">securityName</a>);
01149         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o29">securityName</a> == NULL) {
01150             snmp_sess_close(slp);
01151             <span class="keywordflow">return</span> (NULL);
01152         }
01153     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01154                                            NETSNMP_DS_LIB_SECNAME)) != NULL) {
01155         cp = strdup(cp);
01156         <span class="keywordflow">if</span> (cp == NULL) {
01157             snmp_sess_close(slp);
01158             <span class="keywordflow">return</span> (NULL);
01159         }
01160         session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a> = cp;
01161         session-&gt;<a class="code" href="structsnmp__session.html#o30">securityNameLen</a> = strlen(cp);
01162     }
01163 
01164     <span class="keywordflow">if</span> ((in_session-&gt;<a class="code" href=
"structsnmp__session.html#o34">securityAuthKeyLen</a> &lt;= 0) &amp;&amp;
01165         ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01166                                      NETSNMP_DS_LIB_AUTHMASTERKEY)))) {
01167         size_t buflen = <span class="keyword">sizeof</span>(session-&gt;<a class="code" href=
"structsnmp__session.html#o33">securityAuthKey</a>);
01168         u_char *tmpp = session-&gt;<a class="code" href="structsnmp__session.html#o33">securityAuthKey</a>;
01169         session-&gt;<a class="code" href="structsnmp__session.html#o34">securityAuthKeyLen</a> = 0;
01170         <span class="comment">/* it will be a hex string */</span>
01171         <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;tmpp, &amp;buflen,
01172                                 &amp;session-&gt;<a class="code" href=
"structsnmp__session.html#o34">securityAuthKeyLen</a>, 0, cp)) {
01173             snmp_set_detail(<span class="stringliteral">"error parsing authentication master key"</span>);
01174             snmp_sess_close(slp);
01175             <span class="keywordflow">return</span> NULL;
01176         }
01177     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((in_session-&gt;<a class="code" href=
"structsnmp__session.html#o34">securityAuthKeyLen</a> &lt;= 0) &amp;&amp;
01178         ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01179                                      NETSNMP_DS_LIB_AUTHPASSPHRASE)) ||
01180          (cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01181                                      NETSNMP_DS_LIB_PASSPHRASE)))) {
01182         session-&gt;<a class="code" href="structsnmp__session.html#o34">securityAuthKeyLen</a> = USM_AUTH_KU_LEN;
01183         <span class="keywordflow">if</span> (generate_Ku(session-&gt;<a class="code" href=
"structsnmp__session.html#o31">securityAuthProto</a>,
01184                         session-&gt;<a class="code" href="structsnmp__session.html#o32">securityAuthProtoLen</a>,
01185                         (u_char *) cp, strlen(cp),
01186                         session-&gt;<a class="code" href="structsnmp__session.html#o33">securityAuthKey</a>,
01187                         &amp;session-&gt;<a class="code" href=
"structsnmp__session.html#o34">securityAuthKeyLen</a>) != SNMPERR_SUCCESS) {
01188             snmp_set_detail
01189                 (<span class=
"stringliteral">"Error generating a key (Ku) from the supplied authentication pass phrase."</span>);
01190             snmp_sess_close(slp);
01191             <span class="keywordflow">return</span> NULL;
01192         }
01193     }
01194 
01195     
01196     <span class="keywordflow">if</span> ((in_session-&gt;<a class="code" href=
"structsnmp__session.html#o40">securityPrivKeyLen</a> &lt;= 0) &amp;&amp;
01197         ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01198                                      NETSNMP_DS_LIB_PRIVMASTERKEY)))) {
01199         size_t buflen = <span class="keyword">sizeof</span>(session-&gt;<a class="code" href=
"structsnmp__session.html#o39">securityPrivKey</a>);
01200         u_char *tmpp = session-&gt;<a class="code" href="structsnmp__session.html#o39">securityPrivKey</a>;
01201         session-&gt;<a class="code" href="structsnmp__session.html#o40">securityPrivKeyLen</a> = 0;
01202         <span class="comment">/* it will be a hex string */</span>
01203         <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;tmpp, &amp;buflen,
01204                                 &amp;session-&gt;<a class="code" href=
"structsnmp__session.html#o40">securityPrivKeyLen</a>, 0, cp)) {
01205             snmp_set_detail(<span class="stringliteral">"error parsing encryption master key"</span>);
01206             snmp_sess_close(slp);
01207             <span class="keywordflow">return</span> NULL;
01208         }
01209     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((in_session-&gt;<a class="code" href=
"structsnmp__session.html#o40">securityPrivKeyLen</a> &lt;= 0) &amp;&amp;
01210         ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01211                                      NETSNMP_DS_LIB_PRIVPASSPHRASE)) ||
01212          (cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01213                                      NETSNMP_DS_LIB_PASSPHRASE)))) {
01214         session-&gt;<a class="code" href="structsnmp__session.html#o40">securityPrivKeyLen</a> = USM_PRIV_KU_LEN;
01215         <span class="keywordflow">if</span> (generate_Ku(session-&gt;<a class="code" href=
"structsnmp__session.html#o31">securityAuthProto</a>,
01216                         session-&gt;<a class="code" href="structsnmp__session.html#o32">securityAuthProtoLen</a>,
01217                         (u_char *) cp, strlen(cp),
01218                         session-&gt;<a class="code" href="structsnmp__session.html#o39">securityPrivKey</a>,
01219                         &amp;session-&gt;<a class="code" href=
"structsnmp__session.html#o40">securityPrivKeyLen</a>) != SNMPERR_SUCCESS) {
01220             snmp_set_detail
01221                 (<span class="stringliteral">"Error generating a key (Ku) from the supplied privacy pass phrase."</span>);
01222             snmp_sess_close(slp);
01223             <span class="keywordflow">return</span> NULL;
01224         }
01225     }
01226 
01227     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o1">retries</a> == SNMP_DEFAULT_RETRIES)
01228         session-&gt;<a class="code" href="structsnmp__session.html#o1">retries</a> = DEFAULT_RETRIES;
01229     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o2">timeout</a> == SNMP_DEFAULT_TIMEOUT)
01230         session-&gt;<a class="code" href="structsnmp__session.html#o2">timeout</a> = DEFAULT_TIMEOUT;
01231     session-&gt;<a class="code" href="structsnmp__session.html#o15">sessid</a> = snmp_get_next_sessid();
01232 
01233     <a class="code" href=
"group__callback.html#ga10">snmp_call_callbacks</a>(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SESSION_INIT,
01234                         session);
01235 
01236     <span class="keywordflow">if</span> ((sptr = find_sec_mod(session-&gt;<a class="code" href=
"structsnmp__session.html#o43">securityModel</a>)) != NULL &amp;&amp;
01237         sptr-&gt;session_open != NULL) {
01238         <span class="comment">/*</span>
01239 <span class="comment">         * security module specific inialization </span>
01240 <span class="comment">         */</span>
01241         (*sptr-&gt;session_open) (session);
01242     }
01243 
01244     <span class="keywordflow">return</span> (slp);
01245 }
01246 
01247 <span class="keyword">static</span> <span class="keyword">struct </span>session_list *
01248 snmp_sess_copy(netsnmp_session * pss)
01249 {
01250     <span class="keyword">struct </span>session_list *psl;
01251     psl = _sess_copy(pss);
01252     <span class="keywordflow">if</span> (!psl) {
01253         <span class="keywordflow">if</span> (!pss-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a>) {
01254             pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_GENERR;
01255         }
01256         SET_SNMP_ERROR(pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
01257     }
01258     <span class="keywordflow">return</span> psl;
01259 }
01260 
01261 
01277 <span class="keywordtype">int</span>
<a name="l01278" id="l01278"></a><a class="code" href="group__library.html#ga62">01278</a> <a class="code" href=
"group__library.html#ga62">snmpv3_engineID_probe</a>(<span class="keyword">struct</span> session_list *slp,
01279                       netsnmp_session * in_session)
01280 {
01281     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>    *pdu = NULL, *response = NULL;
01282     netsnmp_session *session;
01283     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    i;
01284     <span class="keywordtype">int</span>             status;
01285 
01286     <span class="keywordflow">if</span> (slp == NULL || slp-&gt;session == NULL) {
01287         <span class="keywordflow">return</span> 0;
01288     }
01289 
01290     session = slp-&gt;session;
01291 
01292     <span class="comment">/*</span>
01293 <span class="comment">     * If we are opening a V3 session and we don't know engineID we must probe</span>
01294 <span class="comment">     * it -- this must be done after the session is created and inserted in the</span>
01295 <span class="comment">     * list so that the response can handled correctly. </span>
01296 <span class="comment">     */</span>
01297 
01298     <span class="keywordflow">if</span> ((session-&gt;<a class="code" href=
"structsnmp__session.html#o3">flags</a> &amp; SNMP_FLAGS_DONT_PROBE) == SNMP_FLAGS_DONT_PROBE)
01299         <span class="keywordflow">return</span> 1;
01300 
01301     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a> == SNMP_VERSION_3) {
01302         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a> == 0) {
01303             <span class="keywordflow">if</span> (snmpv3_build_probe_pdu(&amp;pdu) != 0) {
01304                 DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>, <span class=
"stringliteral">"unable to create probe PDU\n"</span>));
01305                 <span class="keywordflow">return</span> 0;
01306             }
01307             DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>, <span class=
"stringliteral">"probing for engineID...\n"</span>));
01308             session-&gt;<a class="code" href="structsnmp__session.html#o3">flags</a> |= SNMP_FLAGS_DONT_PROBE; <span class=
"comment">/* prevent recursion */</span>
01309             status = snmp_sess_synch_response(slp, pdu, &amp;response);
01310 
01311             <span class="keywordflow">if</span> ((response == NULL) &amp;&amp; (status == STAT_SUCCESS)) {
01312                 status = STAT_ERROR;
01313             }
01314 
01315             <span class="keywordflow">switch</span> (status) {
01316             <span class="keywordflow">case</span> STAT_SUCCESS:
01317                 in_session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_INVALID_MSG; <span class="comment">/* XX?? */</span>
01318                 DEBUGMSGTL((<span class="stringliteral">"snmp_sess_open"</span>,
01319                             <span class="stringliteral">"error: expected Report as response to probe: %s (%d)\n"</span>,
01320                             snmp_errstring(response-&gt;errstat),
01321                             response-&gt;errstat));
01322                 <span class="keywordflow">break</span>;
01323             <span class="keywordflow">case</span> STAT_ERROR:   <span class=
"comment">/* this is what we expected -&gt; Report == STAT_ERROR */</span>
01324                 in_session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_UNKNOWN_ENG_ID;
01325                 <span class="keywordflow">break</span>;
01326             <span class="keywordflow">case</span> STAT_TIMEOUT:
01327                 in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_TIMEOUT;
01328             <span class="keywordflow">default</span>:
01329                 DEBUGMSGTL((<span class="stringliteral">"snmp_sess_open"</span>,
01330                             <span class="stringliteral">"unable to connect with remote engine: %s (%d)\n"</span>,
01331                             snmp_api_errstring(session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a>),
01332                             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>));
01333                 <span class="keywordflow">break</span>;
01334             }
01335 
01336             <span class="keywordflow">if</span> (slp-&gt;session-&gt;securityEngineIDLen == 0) {
01337                 DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>,
01338                             <span class="stringliteral">"unable to determine remote engine ID\n"</span>));
01339                 <span class="keywordflow">return</span> 0;
01340             }
01341 
01342             in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_SUCCESS;
01343             <span class="keywordflow">if</span> (snmp_get_do_debugging()) {
01344                 DEBUGMSGTL((<span class="stringliteral">"snmp_sess_open"</span>,
01345                             <span class="stringliteral">"  probe found engineID:  "</span>));
01346                 <span class="keywordflow">for</span> (i = 0; i &lt; slp-&gt;session-&gt;securityEngineIDLen; i++)
01347                     DEBUGMSG((<span class="stringliteral">"snmp_sess_open"</span>, <span class=
"stringliteral">"%02x"</span>,
01348                               slp-&gt;session-&gt;securityEngineID[i]));
01349                 DEBUGMSG((<span class="stringliteral">"snmp_sess_open"</span>, <span class="stringliteral">"\n"</span>));
01350             }
01351         }
01352 
01353         <span class="comment">/*</span>
01354 <span class="comment">         * if boot/time supplied set it for this engineID </span>
01355 <span class="comment">         */</span>
01356         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o23">engineBoots</a> || session-&gt;<a class="code" href=
"structsnmp__session.html#o24">engineTime</a>) {
01357             set_enginetime(session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
01358                            session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>,
01359                            session-&gt;<a class="code" href=
"structsnmp__session.html#o23">engineBoots</a>, session-&gt;<a class="code" href="structsnmp__session.html#o24">engineTime</a>,
01360                            TRUE);
01361         }
01362 
01363         <span class="keywordflow">if</span> (create_user_from_session(slp-&gt;session) != SNMPERR_SUCCESS) {
01364             in_session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_UNKNOWN_USER_NAME;       <span class="comment">/* XX?? */</span>
01365             DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>,
01366                         <span class=
"stringliteral">"snmp_sess_open(): failed(2) to create a new user from session\n"</span>));
01367             <span class="keywordflow">return</span> 0;
01368         }
01369     }
01370 
01371     <span class="keywordflow">return</span> 1;
01372 }
01373 
01374 
01375 
01376 <span class="comment">/*******************************************************************-o-******</span>
01377 <span class="comment"> * snmp_sess_open</span>
01378 <span class="comment"> *</span>
01379 <span class="comment"> * Parameters:</span>
01380 <span class="comment"> *      *in_session</span>
01381 <span class="comment"> *</span>
01382 <span class="comment"> * Returns:</span>
01383 <span class="comment"> *      Pointer to a session in the session list   -OR-         FIX -- right?</span>
01384 <span class="comment"> *      NULL on failure.</span>
01385 <span class="comment"> *</span>
01386 <span class="comment"> * The "spin-free" version of snmp_open.</span>
01387 <span class="comment"> */</span>
01388 <span class="keyword">static</span> <span class="keywordtype">void</span>    *
01389 _sess_open(netsnmp_session * in_session)
01390 {
01391     <span class="keyword">struct </span>session_list *slp;
01392     netsnmp_session *session;
01393     <span class="keywordtype">char</span>            *clientaddr_save = NULL;
01394 
01395     in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
01396     in_session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
01397 
01398     _init_snmp();
01399 
01400     <span class="keywordflow">if</span> ((slp = snmp_sess_copy(in_session)) == NULL) {
01401         <span class="keywordflow">return</span> (NULL);
01402     }
01403     session = slp-&gt;session;
01404     slp-&gt;transport = NULL;
01405 
01406     <span class="keywordflow">if</span> (NULL != session-&gt;<a class="code" href=
"structsnmp__session.html#o8">localname</a>) {
01407         clientaddr_save = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
01408                                                 NETSNMP_DS_LIB_CLIENT_ADDR);
01409         netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,
01410                               NETSNMP_DS_LIB_CLIENT_ADDR, session-&gt;<a class="code" href=
"structsnmp__session.html#o8">localname</a>);
01411     }
01412 
01413     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o3">flags</a> &amp; SNMP_FLAGS_STREAM_SOCKET) {
01414         slp-&gt;transport = netsnmp_tdomain_transport(session-&gt;<a class="code" href=
"structsnmp__session.html#o6">peername</a>,
01415                                                    session-&gt;<a class="code" href=
"structsnmp__session.html#o9">local_port</a>,
01416                                                    <span class="stringliteral">"tcp"</span>);
01417     } <span class="keywordflow">else</span> {
01418         slp-&gt;transport = netsnmp_tdomain_transport(session-&gt;<a class="code" href=
"structsnmp__session.html#o6">peername</a>,
01419                                                    session-&gt;<a class="code" href=
"structsnmp__session.html#o9">local_port</a>,
01420                                                    <span class="stringliteral">"udp"</span>);
01421     }
01422 
01423     <span class="keywordflow">if</span> (NULL != session-&gt;<a class="code" href=
"structsnmp__session.html#o8">localname</a>)
01424         netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,
01425                               NETSNMP_DS_LIB_CLIENT_ADDR, clientaddr_save);
01426 
01427     <span class="keywordflow">if</span> (slp-&gt;transport == NULL) {
01428         DEBUGMSGTL((<span class="stringliteral">"_sess_open"</span>, <span class=
"stringliteral">"couldn't interpret peername\n"</span>));
01429         in_session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_ADDRESS;
01430         in_session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = errno;
01431         snmp_set_detail(session-&gt;<a class="code" href="structsnmp__session.html#o6">peername</a>);
01432         snmp_sess_close(slp);
01433         <span class="keywordflow">return</span> NULL;
01434     }
01435 
01436     session-&gt;<a class="code" href="structsnmp__session.html#o18">rcvMsgMaxSize</a> = slp-&gt;transport-&gt;msgMaxSize;
01437 
01438     <span class="keywordflow">if</span> (!<a class="code" href=
"group__library.html#ga62">snmpv3_engineID_probe</a>(slp, in_session)) {
01439         snmp_sess_close(slp);
01440         <span class="keywordflow">return</span> 0;
01441     }
01442     <span class="keywordflow">if</span> (create_user_from_session(slp-&gt;session) != SNMPERR_SUCCESS) {
01443         in_session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_UNKNOWN_USER_NAME;       <span class="comment">/* XX?? */</span>
01444         DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>,
01445                     <span class="stringliteral">"_sess_open(): failed(2) to create a new user from session\n"</span>));
01446         <span class="keywordflow">return</span> 0;
01447     }
01448     
01449     session-&gt;<a class="code" href="structsnmp__session.html#o3">flags</a> &amp;= ~SNMP_FLAGS_DONT_PROBE;
01450 
01451 
01452     <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) slp;
01453 }                               <span class="comment">/* end snmp_sess_open() */</span>
01454 
01455 
01456 
01457 <span class="comment">/*</span>
01458 <span class="comment"> * EXPERIMENTAL API EXTENSIONS ------------------------------------------ </span>
01459 <span class="comment"> * </span>
01460 <span class="comment"> * snmp_sess_add_ex, snmp_sess_add, snmp_add </span>
01461 <span class="comment"> * </span>
01462 <span class="comment"> * Analogous to snmp_open family of functions, but taking a netsnmp_transport</span>
01463 <span class="comment"> * pointer as an extra argument.  Unlike snmp_open et al. it doesn't attempt</span>
01464 <span class="comment"> * to interpret the in_session-&gt;peername as a transport endpoint specifier,</span>
01465 <span class="comment"> * but instead uses the supplied transport.  JBPN</span>
01466 <span class="comment"> * </span>
01467 <span class="comment"> */</span>
01468 
01469 netsnmp_session *
01470 snmp_add(netsnmp_session * in_session,
01471          netsnmp_transport *transport,
01472          <span class="keywordtype">int</span> (*fpre_parse) (netsnmp_session *, netsnmp_transport *, <span class=
"keywordtype">void</span> *,
01473                             <span class="keywordtype">int</span>), <span class=
"keywordtype">int</span> (*fpost_parse) (netsnmp_session *,
01474                                                       <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, <span class="keywordtype">int</span>))
01475 {
01476     <span class="keyword">struct </span>session_list *slp;
01477     slp = (<span class="keyword">struct </span>session_list *) snmp_sess_add_ex(in_session, transport,
01478                                                    fpre_parse, NULL,
01479                                                    fpost_parse, NULL, NULL,
01480                                                    NULL, NULL);
01481     <span class="keywordflow">if</span> (slp == NULL) {
01482         <span class="keywordflow">return</span> NULL;
01483     }
01484 
01485     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
01486     slp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = Sessions;
01487     Sessions = slp;
01488     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
01489 
01490     <span class="keywordflow">return</span> (slp-&gt;session);
01491 }
01492 
01493 netsnmp_session *
01494 snmp_add_full(netsnmp_session * in_session,
01495               netsnmp_transport *transport,
01496               <span class="keywordtype">int</span> (*fpre_parse) (netsnmp_session *, netsnmp_transport *,
01497                                  <span class="keywordtype">void</span> *, <span class="keywordtype">int</span>),
01498               <span class="keywordtype">int</span> (*fparse) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, u_char *,
01499                              size_t),
01500               <span class="keywordtype">int</span> (*fpost_parse) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, <span class="keywordtype">int</span>),
01501               <span class="keywordtype">int</span> (*fbuild) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, u_char *,
01502                              size_t *), <span class="keywordtype">int</span> (*frbuild) (netsnmp_session *,
01503                                                         <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *,
01504                                                         u_char **,
01505                                                         size_t *,
01506                                                         size_t *),
01507               <span class="keywordtype">int</span> (*fcheck) (u_char *, size_t),
01508               <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *(*fcreate_pdu) (netsnmp_transport *, <span class="keywordtype">void</span> *,
01509                                            size_t))
01510 {
01511     <span class="keyword">struct </span>session_list *slp;
01512     slp = (<span class="keyword">struct </span>session_list *) snmp_sess_add_ex(in_session, transport,
01513                                                    fpre_parse, fparse,
01514                                                    fpost_parse, fbuild,
01515                                                    frbuild, fcheck,
01516                                                    fcreate_pdu);
01517     <span class="keywordflow">if</span> (slp == NULL) {
01518         <span class="keywordflow">return</span> NULL;
01519     }
01520 
01521     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
01522     slp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = Sessions;
01523     Sessions = slp;
01524     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
01525 
01526     <span class="keywordflow">return</span> (slp-&gt;session);
01527 }
01528 
01529 
01530 
01531 <span class="keywordtype">void</span>           *
01532 snmp_sess_add_ex(netsnmp_session * in_session,
01533                  netsnmp_transport *transport,
01534                  <span class="keywordtype">int</span> (*fpre_parse) (netsnmp_session *, netsnmp_transport *,
01535                                     <span class="keywordtype">void</span> *, <span class="keywordtype">int</span>),
01536                  <span class="keywordtype">int</span> (*fparse) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, u_char *,
01537                                 size_t),
01538                  <span class="keywordtype">int</span> (*fpost_parse) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *,
01539                                      <span class="keywordtype">int</span>),
01540                  <span class="keywordtype">int</span> (*fbuild) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, u_char *,
01541                                 size_t *),
01542                  <span class="keywordtype">int</span> (*frbuild) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *,
01543                                  u_char **, size_t *, size_t *),
01544                  <span class="keywordtype">int</span> (*fcheck) (u_char *, size_t),
01545                  <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *(*fcreate_pdu) (netsnmp_transport *, <span class="keywordtype">void</span> *,
01546                                               size_t))
01547 {
01548     <span class="keyword">struct </span>session_list *slp;
01549 
01550     _init_snmp();
01551 
01552     <span class="keywordflow">if</span> (in_session == NULL || transport == NULL) {
01553         <span class="keywordflow">return</span> NULL;
01554     }
01555 
01556     DEBUGMSGTL((<span class="stringliteral">"snmp_sess_add"</span>, <span class=
"stringliteral">"fd %d\n"</span>, transport-&gt;sock));
01557 
01558     <span class="keywordflow">if</span> ((slp = snmp_sess_copy(in_session)) == NULL) {
01559         <span class="keywordflow">return</span> (NULL);
01560     }
01561 
01562     slp-&gt;transport = transport;
01563     slp-&gt;internal-&gt;hook_pre = fpre_parse;
01564     slp-&gt;internal-&gt;hook_parse = fparse;
01565     slp-&gt;internal-&gt;hook_post = fpost_parse;
01566     slp-&gt;internal-&gt;hook_build = fbuild;
01567     slp-&gt;internal-&gt;hook_realloc_build = frbuild;
01568     slp-&gt;internal-&gt;check_packet = fcheck;
01569     slp-&gt;internal-&gt;hook_create_pdu = fcreate_pdu;
01570 
01571     slp-&gt;session-&gt;rcvMsgMaxSize = transport-&gt;msgMaxSize;
01572 
01573     <span class="keywordflow">if</span> (slp-&gt;session-&gt;version == SNMP_VERSION_3) {
01574         DEBUGMSGTL((<span class="stringliteral">"snmp_sess_add"</span>,
01575                     <span class="stringliteral">"adding v3 session -- engineID probe now\n"</span>));
01576         <span class="keywordflow">if</span> (!<a class="code" href=
"group__library.html#ga62">snmpv3_engineID_probe</a>(slp, in_session)) {
01577             DEBUGMSGTL((<span class="stringliteral">"snmp_sess_add"</span>, <span class=
"stringliteral">"engine ID probe failed\n"</span>));
01578             snmp_sess_close(slp);
01579             slp = NULL;
01580         }
01581         <span class="keywordflow">if</span> (create_user_from_session(slp-&gt;session) != SNMPERR_SUCCESS) {
01582             slp-&gt;session-&gt;s_snmp_errno = SNMPERR_UNKNOWN_USER_NAME;
01583             DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>,
01584                         <span class="stringliteral">"_sess_open(): failed(2) to create a new user from session\n"</span>));
01585             <span class="keywordflow">return</span> 0;
01586         }
01587     }
01588 
01589     <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) slp;
01590 }                               <span class="comment">/*  end snmp_sess_add_ex()  */</span>
01591 
01592 
01593 
01594 <span class="keywordtype">void</span>           *
01595 snmp_sess_add(netsnmp_session * in_session,
01596               netsnmp_transport *transport,
01597               <span class="keywordtype">int</span> (*fpre_parse) (netsnmp_session *, netsnmp_transport *,
01598                                  <span class="keywordtype">void</span> *, <span class="keywordtype">int</span>),
01599               <span class="keywordtype">int</span> (*fpost_parse) (netsnmp_session *, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *, <span class="keywordtype">int</span>))
01600 {
01601     <span class="keywordflow">return</span> snmp_sess_add_ex(in_session, transport, fpre_parse, NULL,
01602                             fpost_parse, NULL, NULL, NULL, NULL);
01603 }
01604 
01605 
01606 
01607 <span class="keywordtype">void</span>           *
01608 snmp_sess_open(netsnmp_session * pss)
01609 {
01610     <span class="keywordtype">void</span>           *pvoid;
01611     pvoid = _sess_open(pss);
01612     <span class="keywordflow">if</span> (!pvoid) {
01613         SET_SNMP_ERROR(pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
01614     }
01615     <span class="keywordflow">return</span> pvoid;
01616 }
01617 
01618 
01619 
01620 <span class="comment">/*</span>
01621 <span class="comment"> * create_user_from_session(netsnmp_session *session):</span>
01622 <span class="comment"> * </span>
01623 <span class="comment"> * creates a user in the usm table from the information in a session.</span>
01624 <span class="comment"> * If the user already exists, it is updated with the current</span>
01625 <span class="comment"> * information from the session</span>
01626 <span class="comment"> * </span>
01627 <span class="comment"> * Parameters:</span>
01628 <span class="comment"> * session -- IN: pointer to the session to use when creating the user.</span>
01629 <span class="comment"> * </span>
01630 <span class="comment"> * Returns:</span>
01631 <span class="comment"> * SNMPERR_SUCCESS</span>
01632 <span class="comment"> * SNMPERR_GENERR </span>
01633 <span class="comment"> */</span>
01634 <span class="keywordtype">int</span>
01635 create_user_from_session(netsnmp_session * session)
01636 {
01637     <span class="keyword">struct </span>usmUser *user;
01638     <span class="keywordtype">int</span>             user_just_created = 0;
01639     u_char *cp;
01640 
01641     <span class="comment">/*</span>
01642 <span class="comment">     * - don't create-another/copy-into user for this session by default</span>
01643 <span class="comment">     * - bail now (no error) if we don't have an engineID</span>
01644 <span class="comment">     */</span>
01645     <span class="keywordflow">if</span> (SNMP_FLAGS_USER_CREATED == (session-&gt;<a class="code" href=
"structsnmp__session.html#o3">flags</a> &amp; SNMP_FLAGS_USER_CREATED) ||
01646         session-&gt;<a class="code" href="structsnmp__session.html#o43">securityModel</a> != SNMP_SEC_MODEL_USM ||
01647         session-&gt;<a class="code" href="structsnmp__session.html#o0">version</a> != SNMP_VERSION_3 ||
01648         session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a> == 0)
01649         <span class="keywordflow">return</span> SNMPERR_SUCCESS;
01650 
01651     session-&gt;<a class="code" href="structsnmp__session.html#o3">flags</a> |= SNMP_FLAGS_USER_CREATED;
01652 
01653     <span class="comment">/*</span>
01654 <span class="comment">     * now that we have the engineID, create an entry in the USM list</span>
01655 <span class="comment">     * for this user using the information in the session </span>
01656 <span class="comment">     */</span>
01657     user = usm_get_user_from_list(session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
01658                                   session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>,
01659                                   session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a>,
01660                                   usm_get_userList(), 0);
01661     <span class="keywordflow">if</span> (user == NULL) {
01662         DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>, <span class=
"stringliteral">"Building user %s...\n"</span>,
01663                     session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a>));
01664         <span class="comment">/*</span>
01665 <span class="comment">         * user doesn't exist so we create and add it </span>
01666 <span class="comment">         */</span>
01667         user = (<span class="keyword">struct </span>usmUser *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> usmUser));
01668         <span class="keywordflow">if</span> (user == NULL)
01669             <span class="keywordflow">return</span> SNMPERR_GENERR;
01670 
01671         <span class="comment">/*</span>
01672 <span class="comment">         * copy in the securityName </span>
01673 <span class="comment">         */</span>
01674         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o29">securityName</a>) {
01675             user-&gt;name = strdup(session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a>);
01676             user-&gt;secName = strdup(session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a>);
01677             <span class="keywordflow">if</span> (user-&gt;name == NULL || user-&gt;secName == NULL) {
01678                 usm_free_user(user);
01679                 <span class="keywordflow">return</span> SNMPERR_GENERR;
01680             }
01681         }
01682 
01683         <span class="comment">/*</span>
01684 <span class="comment">         * copy in the engineID </span>
01685 <span class="comment">         */</span>
01686         <span class="keywordflow">if</span> (<a class="code" href=
"group__util.html#ga5">memdup</a>(&amp;user-&gt;engineID, session-&gt;<a class="code" href=
"structsnmp__session.html#o27">securityEngineID</a>,
01687                    session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a>) != SNMPERR_SUCCESS) {
01688             usm_free_user(user);
01689             <span class="keywordflow">return</span> SNMPERR_GENERR;
01690         }
01691         user-&gt;engineIDLen = session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>;
01692 
01693         user_just_created = 1;
01694     }
01695     <span class="comment">/*</span>
01696 <span class="comment">     * copy the auth protocol </span>
01697 <span class="comment">     */</span>
01698     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o31">securityAuthProto</a> != NULL) {
01699         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;authProtocol);
01700         user-&gt;authProtocol =
01701             snmp_duplicate_objid(session-&gt;<a class="code" href="structsnmp__session.html#o31">securityAuthProto</a>,
01702                                  session-&gt;<a class="code" href="structsnmp__session.html#o32">securityAuthProtoLen</a>);
01703         <span class="keywordflow">if</span> (user-&gt;authProtocol == NULL) {
01704             usm_free_user(user);
01705             <span class="keywordflow">return</span> SNMPERR_GENERR;
01706         }
01707         user-&gt;authProtocolLen = session-&gt;<a class="code" href=
"structsnmp__session.html#o32">securityAuthProtoLen</a>;
01708     }
01709 
01710     <span class="comment">/*</span>
01711 <span class="comment">     * copy the priv protocol </span>
01712 <span class="comment">     */</span>
01713     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o37">securityPrivProto</a> != NULL) {
01714         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;privProtocol);
01715         user-&gt;privProtocol =
01716             snmp_duplicate_objid(session-&gt;<a class="code" href="structsnmp__session.html#o37">securityPrivProto</a>,
01717                                  session-&gt;<a class="code" href="structsnmp__session.html#o38">securityPrivProtoLen</a>);
01718         <span class="keywordflow">if</span> (user-&gt;privProtocol == NULL) {
01719             usm_free_user(user);
01720             <span class="keywordflow">return</span> SNMPERR_GENERR;
01721         }
01722         user-&gt;privProtocolLen = session-&gt;<a class="code" href=
"structsnmp__session.html#o38">securityPrivProtoLen</a>;
01723     }
01724 
01725     <span class="comment">/*</span>
01726 <span class="comment">     * copy in the authentication Key.  If not localized, localize it </span>
01727 <span class="comment">     */</span>
01728     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o35">securityAuthLocalKey</a> != NULL
01729         &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#o36">securityAuthLocalKeyLen</a> != 0) {
01730         <span class="comment">/* already localized key passed in.  use it */</span>
01731         <span class="keywordflow">if</span> (<a class="code" href=
"group__util.html#ga5">memdup</a>(&amp;user-&gt;authKey, session-&gt;<a class="code" href=
"structsnmp__session.html#o35">securityAuthLocalKey</a>,
01732                    session-&gt;<a class="code" href=
"structsnmp__session.html#o36">securityAuthLocalKeyLen</a>) != SNMPERR_SUCCESS) {
01733             usm_free_user(user);
01734             <span class="keywordflow">return</span> SNMPERR_GENERR;
01735         }
01736         user-&gt;authKeyLen = session-&gt;<a class="code" href="structsnmp__session.html#o36">securityAuthLocalKeyLen</a>;
01737     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o33">securityAuthKey</a> != NULL
01738         &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#o34">securityAuthKeyLen</a> != 0) {
01739         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;authKey);
01740         user-&gt;authKey = (u_char *) calloc(1, USM_LENGTH_KU_HASHBLOCK);
01741         <span class="keywordflow">if</span> (user-&gt;authKey == NULL) {
01742             usm_free_user(user);
01743             <span class="keywordflow">return</span> SNMPERR_GENERR;
01744         }
01745         user-&gt;authKeyLen = USM_LENGTH_KU_HASHBLOCK;
01746         <span class="keywordflow">if</span> (generate_kul(user-&gt;authProtocol, user-&gt;authProtocolLen,
01747                          session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
01748                          session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>,
01749                          session-&gt;<a class="code" href="structsnmp__session.html#o33">securityAuthKey</a>,
01750                          session-&gt;<a class="code" href=
"structsnmp__session.html#o34">securityAuthKeyLen</a>, user-&gt;authKey,
01751                          &amp;user-&gt;authKeyLen) != SNMPERR_SUCCESS) {
01752             usm_free_user(user);
01753             <span class="keywordflow">return</span> SNMPERR_GENERR;
01754         }
01755     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01756                                            NETSNMP_DS_LIB_AUTHLOCALIZEDKEY))) {
01757         size_t buflen = USM_AUTH_KU_LEN;
01758         user-&gt;authKey = malloc(buflen); <span class="comment">/* max length needed */</span>
01759         user-&gt;authKeyLen = 0;
01760         <span class="comment">/* it will be a hex string */</span>
01761         <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;user-&gt;authKey, &amp;buflen, &amp;user-&gt;authKeyLen,
01762                                 0, cp)) {
01763             usm_free_user(user);
01764             <span class="keywordflow">return</span> SNMPERR_GENERR;
01765         }
01766     }
01767 
01768     <span class="comment">/*</span>
01769 <span class="comment">     * copy in the privacy Key.  If not localized, localize it </span>
01770 <span class="comment">     */</span>
01771     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o41">securityPrivLocalKey</a> != NULL
01772         &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#o42">securityPrivLocalKeyLen</a> != 0) {
01773         <span class="comment">/* already localized key passed in.  use it */</span>
01774         <span class="keywordflow">if</span> (<a class="code" href=
"group__util.html#ga5">memdup</a>(&amp;user-&gt;privKey, session-&gt;<a class="code" href=
"structsnmp__session.html#o41">securityPrivLocalKey</a>,
01775                    session-&gt;<a class="code" href=
"structsnmp__session.html#o42">securityPrivLocalKeyLen</a>) != SNMPERR_SUCCESS) {
01776             usm_free_user(user);
01777             <span class="keywordflow">return</span> SNMPERR_GENERR;
01778         }
01779         user-&gt;privKeyLen = session-&gt;<a class="code" href="structsnmp__session.html#o42">securityPrivLocalKeyLen</a>;
01780     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o39">securityPrivKey</a> != NULL
01781         &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#o40">securityPrivKeyLen</a> != 0) {
01782         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;privKey);
01783         user-&gt;privKey = (u_char *) calloc(1, USM_LENGTH_KU_HASHBLOCK);
01784         <span class="keywordflow">if</span> (user-&gt;privKey == NULL) {
01785             usm_free_user(user);
01786             <span class="keywordflow">return</span> SNMPERR_GENERR;
01787         }
01788         user-&gt;privKeyLen = USM_LENGTH_KU_HASHBLOCK;
01789         <span class="keywordflow">if</span> (generate_kul(user-&gt;authProtocol, user-&gt;authProtocolLen,
01790                          session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
01791                          session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>,
01792                          session-&gt;<a class="code" href="structsnmp__session.html#o39">securityPrivKey</a>,
01793                          session-&gt;<a class="code" href=
"structsnmp__session.html#o40">securityPrivKeyLen</a>, user-&gt;privKey,
01794                          &amp;user-&gt;privKeyLen) != SNMPERR_SUCCESS) {
01795             usm_free_user(user);
01796             <span class="keywordflow">return</span> SNMPERR_GENERR;
01797         }
01798     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01799                                            NETSNMP_DS_LIB_PRIVLOCALIZEDKEY))) {
01800         size_t buflen = USM_PRIV_KU_LEN;
01801         user-&gt;privKey = malloc(buflen); <span class="comment">/* max length needed */</span>
01802         user-&gt;privKeyLen = 0;
01803         <span class="comment">/* it will be a hex string */</span>
01804         <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;user-&gt;privKey, &amp;buflen, &amp;user-&gt;privKeyLen,
01805                                 0, cp)) {
01806             usm_free_user(user);
01807             <span class="keywordflow">return</span> SNMPERR_GENERR;
01808         }
01809     }
01810 
01811     user-&gt;userStatus = RS_ACTIVE;
01812     user-&gt;userStorageType = ST_READONLY;
01813 
01814     <span class="keywordflow">if</span> (user_just_created) {
01815         <span class="comment">/*</span>
01816 <span class="comment">         * add the user into the database </span>
01817 <span class="comment">         */</span>
01818         usm_add_user(user);
01819     }
01820 
01821     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
01822 
01823 
01824 }                               <span class="comment">/* end create_user_from_session() */</span>
01825 
01826 <span class="comment">/*</span>
01827 <span class="comment"> *  Do a "deep free()" of a netsnmp_session.</span>
01828 <span class="comment"> *</span>
01829 <span class="comment"> *  CAUTION:  SHOULD ONLY BE USED FROM snmp_sess_close() OR SIMILAR.</span>
01830 <span class="comment"> *                                                      (hence it is static)</span>
01831 <span class="comment"> */</span>
01832 
01833 <span class="keyword">static</span> <span class="keywordtype">void</span>
01834 snmp_free_session(netsnmp_session * s)
01835 {
01836     <span class="keywordflow">if</span> (s) {
01837         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o6">peername</a>);
01838         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o16">community</a>);
01839         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o21">contextEngineID</a>);
01840         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o25">contextName</a>);
01841         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o27">securityEngineID</a>);
01842         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o29">securityName</a>);
01843         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o31">securityAuthProto</a>);
01844         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o37">securityPrivProto</a>);
01845         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s-&gt;<a class="code" href=
"structsnmp__session.html#o45">paramName</a>);
01846 
01847         <span class="comment">/*</span>
01848 <span class="comment">         * clear session from any callbacks</span>
01849 <span class="comment">         */</span>
01850         <a class="code" href="group__callback.html#ga14">netsnmp_callback_clear_client_arg</a>(s, 0, 0);
01851 
01852         free((<span class="keywordtype">char</span> *) s);
01853     }
01854 }
01855 
01856 <span class="comment">/*</span>
01857 <span class="comment"> * Close the input session.  Frees all data allocated for the session,</span>
01858 <span class="comment"> * dequeues any pending requests, and closes any sockets allocated for</span>
01859 <span class="comment"> * the session.  Returns 0 on error, 1 otherwise.</span>
01860 <span class="comment"> */</span>
01861 <span class="keywordtype">int</span>
01862 snmp_sess_close(<span class="keywordtype">void</span> *sessp)
01863 {
01864     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
01865     netsnmp_transport *transport;
01866     <span class="keyword">struct </span>snmp_internal_session *isp;
01867     netsnmp_session *sesp = NULL;
01868     <span class="keyword">struct </span>snmp_secmod_def *sptr;
01869 
01870     <span class="keywordflow">if</span> (slp == NULL) {
01871         <span class="keywordflow">return</span> 0;
01872     }
01873 
01874     <span class="keywordflow">if</span> (slp-&gt;session != NULL &amp;&amp;
01875         (sptr = find_sec_mod(slp-&gt;session-&gt;securityModel)) != NULL &amp;&amp;
01876         sptr-&gt;session_close != NULL) {
01877         (*sptr-&gt;session_close) (slp-&gt;session);
01878     }
01879 
01880     isp = slp-&gt;internal;
01881     slp-&gt;internal = 0;
01882 
01883     <span class="keywordflow">if</span> (isp) {
01884         netsnmp_request_list *rp, *orp;
01885 
01886         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(isp-&gt;packet);
01887 
01888         <span class="comment">/*</span>
01889 <span class="comment">         * Free each element in the input request list.  </span>
01890 <span class="comment">         */</span>
01891         rp = isp-&gt;requests;
01892         <span class="keywordflow">while</span> (rp) {
01893             orp = rp;
01894             rp = rp-&gt;next_request;
01895             snmp_free_pdu(orp-&gt;pdu);
01896             free((<span class="keywordtype">char</span> *) orp);
01897         }
01898 
01899         free((<span class="keywordtype">char</span> *) isp);
01900     }
01901 
01902     transport = slp-&gt;transport;
01903     slp-&gt;transport = 0;
01904 
01905     <span class="keywordflow">if</span> (transport) {
01906         transport-&gt;f_close(transport);
01907         netsnmp_transport_free(transport);
01908     }
01909 
01910     sesp = slp-&gt;session;
01911     slp-&gt;session = 0;
01912 
01913     <span class="comment">/*</span>
01914 <span class="comment">     * The following is necessary to avoid memory leakage when closing AgentX </span>
01915 <span class="comment">     * sessions that may have multiple subsessions.  These hang off the main</span>
01916 <span class="comment">     * session at -&gt;subsession, and chain through -&gt;next.  </span>
01917 <span class="comment">     */</span>
01918 
01919     <span class="keywordflow">if</span> (sesp != NULL &amp;&amp; sesp-&gt;<a class="code" href=
"structsnmp__session.html#o4">subsession</a> != NULL) {
01920         netsnmp_session *subsession = sesp-&gt;<a class="code" href="structsnmp__session.html#o4">subsession</a>, *tmpsub;
01921 
01922         <span class="keywordflow">while</span> (subsession != NULL) {
01923             DEBUGMSGTL((<span class="stringliteral">"snmp_sess_close"</span>,
01924                         <span class="stringliteral">"closing session %p, subsession %p\n"</span>, sesp,
01925                         subsession));
01926             tmpsub = subsession-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
01927             snmp_free_session(subsession);
01928             subsession = tmpsub;
01929         }
01930     }
01931 
01932     snmp_free_session(sesp);
01933     free((<span class="keywordtype">char</span> *) slp);
01934     <span class="keywordflow">return</span> 1;
01935 }
01936 
01937 <span class="keywordtype">int</span>
01938 snmp_close(netsnmp_session * session)
01939 {
01940     <span class="keyword">struct </span>session_list *slp = NULL, *oslp = NULL;
01941 
01942     {                           <span class="comment">/*MTCRITICAL_RESOURCE */</span>
01943         snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
01944         <span class="keywordflow">if</span> (Sessions &amp;&amp; Sessions-&gt;session == session) { <span class=
"comment">/* If first entry */</span>
01945             slp = Sessions;
01946             Sessions = slp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
01947         } <span class="keywordflow">else</span> {
01948             <span class="keywordflow">for</span> (slp = Sessions; slp; slp = slp-&gt;next) {
01949                 <span class="keywordflow">if</span> (slp-&gt;session == session) {
01950                     <span class="keywordflow">if</span> (oslp)   <span class=
"comment">/* if we found entry that points here */</span>
01951                         oslp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = slp-&gt;<a class="code"
href="structsnmp__session.html#o5">next</a>; <span class="comment">/* link around this entry */</span>
01952                     <span class="keywordflow">break</span>;
01953                 }
01954                 oslp = slp;
01955             }
01956         }
01957         snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
01958     }                           <span class="comment">/*END MTCRITICAL_RESOURCE */</span>
01959     <span class="keywordflow">if</span> (slp == NULL) {
01960         <span class="keywordflow">return</span> 0;
01961     }
01962     <span class="keywordflow">return</span> snmp_sess_close((<span class="keywordtype">void</span> *) slp);
01963 }
01964 
01965 <span class="keywordtype">int</span>
01966 snmp_close_sessions(<span class="keywordtype">void</span>)
01967 {
01968     <span class="keyword">struct </span>session_list *slp;
01969 
01970     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
01971     <span class="keywordflow">while</span> (Sessions) {
01972         slp = Sessions;
01973         Sessions = Sessions-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
01974         snmp_sess_close((<span class="keywordtype">void</span> *) slp);
01975     }
01976     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
01977     <span class="keywordflow">return</span> 1;
01978 }
01979 
01980 <span class="keyword">static</span> <span class="keywordtype">int</span>
01981 snmpv3_build_probe_pdu(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> **pdu)
01982 {
01983     <span class="keyword">struct </span>usmUser *user;
01984 
01985     <span class="comment">/*</span>
01986 <span class="comment">     * create the pdu </span>
01987 <span class="comment">     */</span>
01988     <span class="keywordflow">if</span> (!pdu)
01989         <span class="keywordflow">return</span> -1;
01990     *pdu = snmp_pdu_create(SNMP_MSG_GET);
01991     <span class="keywordflow">if</span> (!(*pdu))
01992         <span class="keywordflow">return</span> -1;
01993     (*pdu)-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a> = SNMP_VERSION_3;
01994     (*pdu)-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a> = strdup(<span class=
"stringliteral">""</span>);
01995     (*pdu)-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a> = strlen((*pdu)-&gt;securityName);
01996     (*pdu)-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> = SNMP_SEC_LEVEL_NOAUTH;
01997     (*pdu)-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a> = SNMP_SEC_MODEL_USM;
01998 
01999     <span class="comment">/*</span>
02000 <span class="comment">     * create the empty user </span>
02001 <span class="comment">     */</span>
02002     user = usm_get_user(NULL, 0, (*pdu)-&gt;securityName);
02003     <span class="keywordflow">if</span> (user == NULL) {
02004         user = (<span class="keyword">struct </span>usmUser *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> usmUser));
02005         <span class="keywordflow">if</span> (user == NULL) {
02006             snmp_free_pdu(*pdu);
02007             *pdu = (<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *) NULL;
02008             <span class="keywordflow">return</span> -1;
02009         }
02010         user-&gt;name = strdup((*pdu)-&gt;securityName);
02011         user-&gt;secName = strdup((*pdu)-&gt;securityName);
02012         user-&gt;authProtocolLen = <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class=
"keyword">sizeof</span>(oid);
02013         user-&gt;authProtocol =
02014             snmp_duplicate_objid(usmNoAuthProtocol, user-&gt;authProtocolLen);
02015         user-&gt;privProtocolLen = <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class=
"keyword">sizeof</span>(oid);
02016         user-&gt;privProtocol =
02017             snmp_duplicate_objid(usmNoPrivProtocol, user-&gt;privProtocolLen);
02018         usm_add_user(user);
02019     }
02020     <span class="keywordflow">return</span> 0;
02021 }
02022 
02023 <span class="keyword">static</span> <span class="keywordtype">void</span>
02024 snmpv3_calc_msg_flags(<span class="keywordtype">int</span> sec_level, <span class=
"keywordtype">int</span> msg_command, u_char * flags)
02025 {
02026     *flags = 0;
02027     <span class="keywordflow">if</span> (sec_level == SNMP_SEC_LEVEL_AUTHNOPRIV)
02028         *flags = SNMP_MSG_FLAG_AUTH_BIT;
02029     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sec_level == SNMP_SEC_LEVEL_AUTHPRIV)
02030         *flags = SNMP_MSG_FLAG_AUTH_BIT | SNMP_MSG_FLAG_PRIV_BIT;
02031 
02032     <span class="keywordflow">if</span> (SNMP_CMD_CONFIRMED(msg_command))
02033         *flags |= SNMP_MSG_FLAG_RPRT_BIT;
02034 
02035     <span class="keywordflow">return</span>;
02036 }
02037 
02038 <span class="keyword">static</span> <span class="keywordtype">int</span>
02039 snmpv3_verify_msg(netsnmp_request_list *rp, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
02040 {
02041     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>    *rpdu;
02042 
02043     <span class="keywordflow">if</span> (!rp || !rp-&gt;pdu || !pdu)
02044         <span class="keywordflow">return</span> 0;
02045     <span class="comment">/*</span>
02046 <span class="comment">     * Reports don't have to match anything according to the spec </span>
02047 <span class="comment">     */</span>
02048     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a> == SNMP_MSG_REPORT)
02049         <span class="keywordflow">return</span> 1;
02050     rpdu = rp-&gt;pdu;
02051     <span class="keywordflow">if</span> (rp-&gt;request_id != pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a> || rpdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a> != pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o2">reqid</a>)
02052         <span class="keywordflow">return</span> 0;
02053     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> != pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>)
02054         <span class="keywordflow">return</span> 0;
02055     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o10">securityModel</a> != pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>)
02056         <span class="keywordflow">return</span> 0;
02057     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o11">securityLevel</a> != pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a>)
02058         <span class="keywordflow">return</span> 0;
02059 
02060     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o26">contextEngineIDLen</a> != pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o26">contextEngineIDLen</a> ||
02061         memcmp(rpdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o25">contextEngineID</a>,
02062                pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>))
02063         <span class="keywordflow">return</span> 0;
02064     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o28">contextNameLen</a> != pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a> ||
02065         memcmp(rpdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o27">contextName</a>, pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a>))
02066         <span class="keywordflow">return</span> 0;
02067     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o30">securityEngineIDLen</a> != pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o30">securityEngineIDLen</a> ||
02068         memcmp(rpdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o29">securityEngineID</a>,
02069                pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>))
02070         <span class="keywordflow">return</span> 0;
02071     <span class="keywordflow">if</span> (rpdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o32">securityNameLen</a> != pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a> ||
02072         memcmp(rpdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o31">securityName</a>,
02073                pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a>))
02074         <span class="keywordflow">return</span> 0;
02075     <span class="keywordflow">return</span> 1;
02076 }
02077 
02078 
02079 <span class="comment">/*</span>
02080 <span class="comment"> * SNMPv3</span>
02081 <span class="comment"> * * Takes a session and a pdu and serializes the ASN PDU into the area</span>
02082 <span class="comment"> * * pointed to by packet.  out_length is the size of the data area available.</span>
02083 <span class="comment"> * * Returns the length of the completed packet in out_length.  If any errors</span>
02084 <span class="comment"> * * occur, -1 is returned.  If all goes well, 0 is returned.</span>
02085 <span class="comment"> */</span>
02086 <span class="keyword">static</span> <span class="keywordtype">int</span>
02087 snmpv3_build(u_char ** pkt, size_t * pkt_len, size_t * offset,
02088              netsnmp_session * session, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
02089 {
02090     <span class="keywordtype">int</span>             ret;
02091 
02092     session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
02093     session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
02094 
02095     <span class="comment">/*</span>
02096 <span class="comment">     * do validation for PDU types </span>
02097 <span class="comment">     */</span>
02098     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>) {
02099     <span class="keywordflow">case</span> SNMP_MSG_RESPONSE:
02100     <span class="keywordflow">case</span> SNMP_MSG_TRAP2:
02101     <span class="keywordflow">case</span> SNMP_MSG_REPORT:
02102         netsnmp_assert(0 == (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a> &amp; UCD_MSG_FLAG_EXPECT_RESPONSE));
02103         <span class="comment">/*</span>
02104 <span class="comment">         * Fallthrough </span>
02105 <span class="comment">         */</span>
02106     <span class="keywordflow">case</span> SNMP_MSG_GET:
02107     <span class="keywordflow">case</span> SNMP_MSG_GETNEXT:
02108     <span class="keywordflow">case</span> SNMP_MSG_SET:
02109     <span class="keywordflow">case</span> SNMP_MSG_INFORM:
02110         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o6">errstat</a> == SNMP_DEFAULT_ERRSTAT)
02111             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a> = 0;
02112         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a> == SNMP_DEFAULT_ERRINDEX)
02113             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o7">errindex</a> = 0;
02114         <span class="keywordflow">break</span>;
02115 
02116     <span class="keywordflow">case</span> SNMP_MSG_GETBULK:
02117         <span class="keywordflow">if</span> (pdu-&gt;max_repetitions &lt; 0) {
02118             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_REPETITIONS;
02119             <span class="keywordflow">return</span> -1;
02120         }
02121         <span class="keywordflow">if</span> (pdu-&gt;non_repeaters &lt; 0) {
02122             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_REPEATERS;
02123             <span class="keywordflow">return</span> -1;
02124         }
02125         <span class="keywordflow">break</span>;
02126 
02127     <span class="keywordflow">case</span> SNMP_MSG_TRAP:
02128         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_V1_IN_V2;
02129         <span class="keywordflow">return</span> -1;
02130 
02131     <span class="keywordflow">default</span>:
02132         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_UNKNOWN_PDU;
02133         <span class="keywordflow">return</span> -1;
02134     }
02135 
02136     <span class="comment">/* Do we need to set the session security engineid? */</span>
02137     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o30">securityEngineIDLen</a> == 0) {
02138         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a>) {
02139             snmpv3_clone_engineID(&amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>,
02140                                   &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>,
02141                                   session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>,
02142                                   session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a>);
02143         }
02144     }
02145     
02146     <span class="comment">/* Do we need to set the session context engineid? */</span>
02147     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o26">contextEngineIDLen</a> == 0) {
02148         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o22">contextEngineIDLen</a>) {
02149             snmpv3_clone_engineID(&amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a>,
02150                                   &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>,
02151                                   session-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a>,
02152                                   session-&gt;<a class="code" href="structsnmp__session.html#o22">contextEngineIDLen</a>);
02153         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o30">securityEngineIDLen</a>) {
02154             snmpv3_clone_engineID(&amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a>,
02155                                   &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>,
02156                                   pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>,
02157                                   pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>);
02158         }
02159     }
02160 
02161     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a> == NULL) {
02162         <span class="keywordflow">if</span> (!session-&gt;<a class="code" href=
"structsnmp__session.html#o25">contextName</a>) {
02163             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_CONTEXT;
02164             <span class="keywordflow">return</span> -1;
02165         }
02166         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a> = strdup(session-&gt;<a class="code" href=
"structsnmp__session.html#o25">contextName</a>);
02167         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o27">contextName</a> == NULL) {
02168             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_GENERR;
02169             <span class="keywordflow">return</span> -1;
02170         }
02171         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o26">contextNameLen</a>;
02172     }
02173     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o10">securityModel</a> == SNMP_DEFAULT_SECMODEL) {
02174         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o43">securityModel</a>;
02175         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o10">securityModel</a> == SNMP_DEFAULT_SECMODEL) {
02176             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a> = SNMP_SEC_MODEL_USM;
02177         }
02178     }
02179     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o32">securityNameLen</a> == 0 &amp;&amp; pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o31">securityName</a> == 0) {
02180         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o30">securityNameLen</a> == 0) {
02181             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_SEC_NAME;
02182             <span class="keywordflow">return</span> -1;
02183         }
02184         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a> = strdup(session-&gt;<a class="code" href=
"structsnmp__session.html#o29">securityName</a>);
02185         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o31">securityName</a> == NULL) {
02186             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_GENERR;
02187             <span class="keywordflow">return</span> -1;
02188         }
02189         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o30">securityNameLen</a>;
02190     }
02191     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> == 0) {
02192         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o44">securityLevel</a> == 0) {
02193             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_SEC_LEVEL;
02194             <span class="keywordflow">return</span> -1;
02195         }
02196         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o44">securityLevel</a>;
02197     }
02198     DEBUGMSGTL((<span class="stringliteral">"snmp_build"</span>,
02199                 <span class="stringliteral">"Building SNMPv3 message (secName:\"%s\", secLevel:%s)...\n"</span>,
02200                 ((session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a>) ? (<span class=
"keywordtype">char</span> *) session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a> :
02201                  ((pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a>) ? (<span class=
"keywordtype">char</span> *) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a> :
02202                   <span class="stringliteral">"ERROR: undefined"</span>)), secLevelName[pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o11">securityLevel</a>]));
02203 
02204     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"SNMPv3 Message"</span>);
02205 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02206     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REVERSE_ENCODE)) {
02207         ret = snmpv3_packet_realloc_rbuild(pkt, pkt_len, offset,
02208                                            session, pdu, NULL, 0);
02209     } <span class="keywordflow">else</span> {
02210 <span class="preprocessor">#endif</span>
02211         ret = snmpv3_packet_build(session, pdu, *pkt, pkt_len, NULL, 0);
02212 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02213     }
02214 <span class="preprocessor">#endif</span>
02215     DEBUGINDENTLESS();
02216     <span class="keywordflow">if</span> (-1 != ret) {
02217         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = ret;
02218     }
02219 
02220     <span class="keywordflow">return</span> ret;
02221 
02222 }                               <span class="comment">/* end snmpv3_build() */</span>
02223 
02224 
02225 
02226 
02227 <span class="keyword">static</span> u_char  *
02228 snmpv3_header_build(netsnmp_session * session, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
02229                     u_char * packet, size_t * out_length,
02230                     size_t length, u_char ** msg_hdr_e)
02231 {
02232     u_char         *global_hdr, *global_hdr_e;
02233     u_char         *cp;
02234     u_char          msg_flags;
02235     <span class="keywordtype">long</span>            max_size;
02236     <span class="keywordtype">long</span>            sec_model;
02237     u_char         *pb, *pb0e;
02238 
02239     <span class="comment">/*</span>
02240 <span class="comment">     * Save current location and build SEQUENCE tag and length placeholder</span>
02241 <span class="comment">     * * for SNMP message sequence (actual length inserted later)</span>
02242 <span class="comment">     */</span>
02243     cp = asn_build_sequence(packet, out_length,
02244                             (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
02245                             length);
02246     <span class="keywordflow">if</span> (cp == NULL)
02247         <span class="keywordflow">return</span> NULL;
02248     <span class="keywordflow">if</span> (msg_hdr_e != NULL)
02249         *msg_hdr_e = cp;
02250     pb0e = cp;
02251 
02252 
02253     <span class="comment">/*</span>
02254 <span class="comment">     * store the version field - msgVersion</span>
02255 <span class="comment">     */</span>
02256     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"SNMP Version Number"</span>);
02257     cp = asn_build_int(cp, out_length,
02258                        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02259                                  ASN_INTEGER), (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a>,
02260                        <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a>));
02261     DEBUGINDENTLESS();
02262     <span class="keywordflow">if</span> (cp == NULL)
02263         <span class="keywordflow">return</span> NULL;
02264 
02265     global_hdr = cp;
02266     <span class="comment">/*</span>
02267 <span class="comment">     * msgGlobalData HeaderData </span>
02268 <span class="comment">     */</span>
02269     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgGlobalData"</span>);
02270     cp = asn_build_sequence(cp, out_length,
02271                             (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR), 0);
02272     <span class="keywordflow">if</span> (cp == NULL)
02273         <span class="keywordflow">return</span> NULL;
02274     global_hdr_e = cp;
02275 
02276 
02277     <span class="comment">/*</span>
02278 <span class="comment">     * msgID </span>
02279 <span class="comment">     */</span>
02280     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgID"</span>);
02281     cp = asn_build_int(cp, out_length,
02282                        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02283                                  ASN_INTEGER), &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a>,
02284                        <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o3">msgid</a>));
02285     DEBUGINDENTLESS();
02286     <span class="keywordflow">if</span> (cp == NULL)
02287         <span class="keywordflow">return</span> NULL;
02288 
02289     <span class="comment">/*</span>
02290 <span class="comment">     * msgMaxSize </span>
02291 <span class="comment">     */</span>
02292     max_size = session-&gt;<a class="code" href="structsnmp__session.html#o18">rcvMsgMaxSize</a>;
02293     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgMaxSize"</span>);
02294     cp = asn_build_int(cp, out_length,
02295                        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02296                                  ASN_INTEGER), &amp;max_size,
02297                        <span class="keyword">sizeof</span>(max_size));
02298     DEBUGINDENTLESS();
02299     <span class="keywordflow">if</span> (cp == NULL)
02300         <span class="keywordflow">return</span> NULL;
02301 
02302     <span class="comment">/*</span>
02303 <span class="comment">     * msgFlags </span>
02304 <span class="comment">     */</span>
02305     snmpv3_calc_msg_flags(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a>, pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o1">command</a>, &amp;msg_flags);
02306     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgFlags"</span>);
02307     cp = asn_build_string(cp, out_length,
02308                           (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02309                                     ASN_OCTET_STR), &amp;msg_flags,
02310                           <span class="keyword">sizeof</span>(msg_flags));
02311     DEBUGINDENTLESS();
02312     <span class="keywordflow">if</span> (cp == NULL)
02313         <span class="keywordflow">return</span> NULL;
02314 
02315     <span class="comment">/*</span>
02316 <span class="comment">     * msgSecurityModel </span>
02317 <span class="comment">     */</span>
02318     sec_model = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>;
02319     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgSecurityModel"</span>);
02320     cp = asn_build_int(cp, out_length,
02321                        (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02322                                  ASN_INTEGER), &amp;sec_model,
02323                        <span class="keyword">sizeof</span>(sec_model));
02324     DEBUGINDENTADD(-4);         <span class="comment">/* return from global data indent */</span>
02325     <span class="keywordflow">if</span> (cp == NULL)
02326         <span class="keywordflow">return</span> NULL;
02327 
02328 
02329     <span class="comment">/*</span>
02330 <span class="comment">     * insert actual length of globalData</span>
02331 <span class="comment">     */</span>
02332     pb = asn_build_sequence(global_hdr, out_length,
02333                             (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
02334                             cp - global_hdr_e);
02335     <span class="keywordflow">if</span> (pb == NULL)
02336         <span class="keywordflow">return</span> NULL;
02337 
02338 
02339     <span class="comment">/*</span>
02340 <span class="comment">     * insert the actual length of the entire packet</span>
02341 <span class="comment">     */</span>
02342     pb = asn_build_sequence(packet, out_length,
02343                             (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
02344                             length + (cp - pb0e));
02345     <span class="keywordflow">if</span> (pb == NULL)
02346         <span class="keywordflow">return</span> NULL;
02347 
02348     <span class="keywordflow">return</span> cp;
02349 
02350 }                               <span class="comment">/* end snmpv3_header_build() */</span>
02351 
02352 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02353 
02354 <span class="keywordtype">int</span>
02355 snmpv3_header_realloc_rbuild(u_char ** pkt, size_t * pkt_len,
02356                              size_t * offset, netsnmp_session * session,
02357                              <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
02358 {
02359     size_t          start_offset = *offset;
02360     u_char          msg_flags;
02361     <span class="keywordtype">long</span>            max_size, sec_model;
02362     <span class="keywordtype">int</span>             rc = 0;
02363 
02364     <span class="comment">/*</span>
02365 <span class="comment">     * msgSecurityModel.  </span>
02366 <span class="comment">     */</span>
02367     sec_model = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>;
02368     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgSecurityModel"</span>);
02369     rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
02370                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02371                                           ASN_INTEGER), &amp;sec_model,
02372                                 <span class="keyword">sizeof</span>(sec_model));
02373     DEBUGINDENTLESS();
02374     <span class="keywordflow">if</span> (rc == 0) {
02375         <span class="keywordflow">return</span> 0;
02376     }
02377 
02378     <span class="comment">/*</span>
02379 <span class="comment">     * msgFlags.  </span>
02380 <span class="comment">     */</span>
02381     snmpv3_calc_msg_flags(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a>, pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o1">command</a>, &amp;msg_flags);
02382     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgFlags"</span>);
02383     rc = asn_realloc_rbuild_string(pkt, pkt_len, offset, 1,
02384                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
02385                                              | ASN_OCTET_STR), &amp;msg_flags,
02386                                    <span class="keyword">sizeof</span>(msg_flags));
02387     DEBUGINDENTLESS();
02388     <span class="keywordflow">if</span> (rc == 0) {
02389         <span class="keywordflow">return</span> 0;
02390     }
02391 
02392     <span class="comment">/*</span>
02393 <span class="comment">     * msgMaxSize.  </span>
02394 <span class="comment">     */</span>
02395     max_size = session-&gt;<a class="code" href="structsnmp__session.html#o18">rcvMsgMaxSize</a>;
02396     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgMaxSize"</span>);
02397     rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
02398                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02399                                           ASN_INTEGER), &amp;max_size,
02400                                 <span class="keyword">sizeof</span>(max_size));
02401     DEBUGINDENTLESS();
02402     <span class="keywordflow">if</span> (rc == 0) {
02403         <span class="keywordflow">return</span> 0;
02404     }
02405 
02406     <span class="comment">/*</span>
02407 <span class="comment">     * msgID.  </span>
02408 <span class="comment">     */</span>
02409     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgID"</span>);
02410     rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
02411                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02412                                           ASN_INTEGER), &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o3">msgid</a>,
02413                                 <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o3">msgid</a>));
02414     DEBUGINDENTLESS();
02415     <span class="keywordflow">if</span> (rc == 0) {
02416         <span class="keywordflow">return</span> 0;
02417     }
02418 
02419     <span class="comment">/*</span>
02420 <span class="comment">     * Global data sequence.  </span>
02421 <span class="comment">     */</span>
02422     rc = asn_realloc_rbuild_sequence(pkt, pkt_len, offset, 1,
02423                                      (u_char) (ASN_SEQUENCE |
02424                                                ASN_CONSTRUCTOR),
02425                                      *offset - start_offset);
02426     <span class="keywordflow">if</span> (rc == 0) {
02427         <span class="keywordflow">return</span> 0;
02428     }
02429 
02430     <span class="comment">/*</span>
02431 <span class="comment">     * Store the version field - msgVersion.  </span>
02432 <span class="comment">     */</span>
02433     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"SNMP Version Number"</span>);
02434     rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
02435                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
02436                                           ASN_INTEGER),
02437                                 (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a>,
02438                                 <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a>));
02439     DEBUGINDENTLESS();
02440     <span class="keywordflow">return</span> rc;
02441 }                               <span class="comment">/* end snmpv3_header_realloc_rbuild() */</span>
02442 <span class="preprocessor">#endif                          </span><span class=
"comment">/* USE_REVERSE_ASNENCODING */</span>
02443 
02444 <span class="keyword">static</span> u_char  *
02445 snmpv3_scopedPDU_header_build(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
02446                               u_char * packet, size_t * out_length,
02447                               u_char ** spdu_e)
02448 {
02449     size_t          init_length;
02450     u_char         *scopedPdu, *pb;
02451 
02452 
02453     init_length = *out_length;
02454 
02455     pb = scopedPdu = packet;
02456     pb = asn_build_sequence(pb, out_length,
02457                             (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR), 0);
02458     <span class="keywordflow">if</span> (pb == NULL)
02459         <span class="keywordflow">return</span> NULL;
02460     <span class="keywordflow">if</span> (spdu_e)
02461         *spdu_e = pb;
02462 
02463     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"contextEngineID"</span>);
02464     pb = asn_build_string(pb, out_length,
02465                           (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR),
02466                           pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a>, pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>);
02467     DEBUGINDENTLESS();
02468     <span class="keywordflow">if</span> (pb == NULL)
02469         <span class="keywordflow">return</span> NULL;
02470 
02471     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"contextName"</span>);
02472     pb = asn_build_string(pb, out_length,
02473                           (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR),
02474                           (u_char *) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a>,
02475                           pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a>);
02476     DEBUGINDENTLESS();
02477     <span class="keywordflow">if</span> (pb == NULL)
02478         <span class="keywordflow">return</span> NULL;
02479 
02480     <span class="keywordflow">return</span> pb;
02481 
02482 }                               <span class="comment">/* end snmpv3_scopedPDU_header_build() */</span>
02483 
02484 
02485 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02486 <span class="keywordtype">int</span>
02487 snmpv3_scopedPDU_header_realloc_rbuild(u_char ** pkt, size_t * pkt_len,
02488                                        size_t * offset, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
02489                                        size_t body_len)
02490 {
02491     size_t          start_offset = *offset;
02492     <span class="keywordtype">int</span>             rc = 0;
02493 
02494     <span class="comment">/*</span>
02495 <span class="comment">     * contextName.  </span>
02496 <span class="comment">     */</span>
02497     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"contextName"</span>);
02498     rc = asn_realloc_rbuild_string(pkt, pkt_len, offset, 1,
02499                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
02500                                              | ASN_OCTET_STR),
02501                                    (u_char *) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a>,
02502                                    pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a>);
02503     DEBUGINDENTLESS();
02504     <span class="keywordflow">if</span> (rc == 0) {
02505         <span class="keywordflow">return</span> 0;
02506     }
02507 
02508     <span class="comment">/*</span>
02509 <span class="comment">     * contextEngineID.  </span>
02510 <span class="comment">     */</span>
02511     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"contextEngineID"</span>);
02512     rc = asn_realloc_rbuild_string(pkt, pkt_len, offset, 1,
02513                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
02514                                              | ASN_OCTET_STR),
02515                                    pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a>,
02516                                    pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>);
02517     DEBUGINDENTLESS();
02518     <span class="keywordflow">if</span> (rc == 0) {
02519         <span class="keywordflow">return</span> 0;
02520     }
02521 
02522     rc = asn_realloc_rbuild_sequence(pkt, pkt_len, offset, 1,
02523                                      (u_char) (ASN_SEQUENCE |
02524                                                ASN_CONSTRUCTOR),
02525                                      *offset - start_offset + body_len);
02526 
02527     <span class="keywordflow">return</span> rc;
02528 }                               <span class="comment">/* end snmpv3_scopedPDU_header_realloc_rbuild() */</span>
02529 <span class="preprocessor">#endif                          </span><span class=
"comment">/* USE_REVERSE_ASNENCODING */</span>
02530 
02531 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02532 <span class="comment">/*</span>
02533 <span class="comment"> * returns 0 if success, -1 if fail, not 0 if SM build failure </span>
02534 <span class="comment"> */</span>
02535 <span class="keywordtype">int</span>
02536 snmpv3_packet_realloc_rbuild(u_char ** pkt, size_t * pkt_len,
02537                              size_t * offset, netsnmp_session * session,
02538                              <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, u_char * pdu_data,
02539                              size_t pdu_data_len)
02540 {
02541     u_char         *scoped_pdu, *hdrbuf = NULL, *hdr = NULL;
02542     size_t          hdrbuf_len = SNMP_MAX_MSG_V3_HDRS, hdr_offset =
02543         0, spdu_offset = 0;
02544     size_t          body_end_offset = *offset, body_len = 0;
02545     <span class="keyword">struct </span>snmp_secmod_def *sptr = NULL;
02546     <span class="keywordtype">int</span>             rc = 0;
02547 
02548     <span class="comment">/*</span>
02549 <span class="comment">     * Build a scopedPDU structure into the packet buffer.  </span>
02550 <span class="comment">     */</span>
02551     DEBUGPRINTPDUTYPE(<span class="stringliteral">"send"</span>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a>);
02552     <span class="keywordflow">if</span> (pdu_data) {
02553         <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; pdu_data_len) {
02554             <span class="keywordflow">if</span> (!asn_realloc(pkt, pkt_len)) {
02555                 <span class="keywordflow">return</span> -1;
02556             }
02557         }
02558 
02559         *offset += pdu_data_len;
02560         memcpy(*pkt + *pkt_len - *offset, pdu_data, pdu_data_len);
02561     } <span class="keywordflow">else</span> {
02562         rc = snmp_pdu_realloc_rbuild(pkt, pkt_len, offset, pdu);
02563         <span class="keywordflow">if</span> (rc == 0) {
02564             <span class="keywordflow">return</span> -1;
02565         }
02566     }
02567     body_len = *offset - body_end_offset;
02568 
02569     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"ScopedPdu"</span>);
02570     rc = snmpv3_scopedPDU_header_realloc_rbuild(pkt, pkt_len, offset,
02571                                                 pdu, body_len);
02572     <span class="keywordflow">if</span> (rc == 0) {
02573         <span class="keywordflow">return</span> -1;
02574     }
02575     spdu_offset = *offset;
02576     DEBUGINDENTADD(-4);         <span class="comment">/*  Return from Scoped PDU.  */</span>
02577 
02578     <span class="keywordflow">if</span> ((hdrbuf = (u_char *) malloc(hdrbuf_len)) == NULL) {
02579         <span class="keywordflow">return</span> -1;
02580     }
02581 
02582     rc = snmpv3_header_realloc_rbuild(&amp;hdrbuf, &amp;hdrbuf_len, &amp;hdr_offset,
02583                                       session, pdu);
02584     <span class="keywordflow">if</span> (rc == 0) {
02585         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(hdrbuf);
02586         <span class="keywordflow">return</span> -1;
02587     }
02588     hdr = hdrbuf + hdrbuf_len - hdr_offset;
02589     scoped_pdu = *pkt + *pkt_len - spdu_offset;
02590 
02591     <span class="comment">/*</span>
02592 <span class="comment">     * Call the security module to possibly encrypt and authenticate the</span>
02593 <span class="comment">     * message---the entire message to transmitted on the wire is returned.  </span>
02594 <span class="comment">     */</span>
02595 
02596     sptr = find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
02597     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SM msgSecurityParameters"</span>);
02598     <span class="keywordflow">if</span> (sptr &amp;&amp; sptr-&gt;encode_reverse) {
02599         <span class="keyword">struct </span>snmp_secmod_outgoing_params parms;
02600 
02601         parms.msgProcModel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o12">msgParseModel</a>;
02602         parms.globalData = hdr;
02603         parms.globalDataLen = hdr_offset;
02604         parms.maxMsgSize = SNMP_MAX_MSG_SIZE;
02605         parms.secModel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>;
02606         parms.secEngineID = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>;
02607         parms.secEngineIDLen = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>;
02608         parms.secName = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a>;
02609         parms.secNameLen = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a>;
02610         parms.secLevel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a>;
02611         parms.scopedPdu = scoped_pdu;
02612         parms.scopedPduLen = spdu_offset;
02613         parms.secStateRef = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>;
02614         parms.wholeMsg = pkt;
02615         parms.wholeMsgLen = pkt_len;
02616         parms.wholeMsgOffset = offset;
02617         parms.session = session;
02618         parms.pdu = pdu;
02619 
02620         rc = (*sptr-&gt;encode_reverse) (&amp;parms);
02621     } <span class="keywordflow">else</span> {
02622         <span class="keywordflow">if</span> (!sptr) {
02623             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
02624                      <span class="stringliteral">"no such security service available: %d\n"</span>,
02625                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
02626         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!sptr-&gt;encode_reverse) {
02627             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
02628                      <span class="stringliteral">"security service %d doesn't support reverse encoding.\n"</span>,
02629                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
02630         }
02631         rc = -1;
02632     }
02633 
02634     DEBUGINDENTLESS();
02635     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(hdrbuf);
02636     <span class="keywordflow">return</span> rc;
02637 }                               <span class="comment">/* end snmpv3_packet_realloc_rbuild() */</span>
02638 <span class="preprocessor">#endif                          </span><span class=
"comment">/* USE_REVERSE_ASNENCODING */</span>
02639 
02640 <span class="comment">/*</span>
02641 <span class="comment"> * returns 0 if success, -1 if fail, not 0 if SM build failure </span>
02642 <span class="comment"> */</span>
02643 <span class="keywordtype">int</span>
02644 snmpv3_packet_build(netsnmp_session * session, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
02645                     u_char * packet, size_t * out_length,
02646                     u_char * pdu_data, size_t pdu_data_len)
02647 {
02648     u_char         *global_data, *sec_params, *spdu_hdr_e;
02649     size_t          global_data_len, sec_params_len;
02650     u_char          spdu_buf[SNMP_MAX_MSG_SIZE];
02651     size_t          spdu_buf_len, spdu_len;
02652     u_char         *cp;
02653     <span class="keywordtype">int</span>             result;
02654     <span class="keyword">struct </span>snmp_secmod_def *sptr;
02655 
02656     global_data = packet;
02657 
02658     <span class="comment">/*</span>
02659 <span class="comment">     * build the headers for the packet, returned addr = start of secParams</span>
02660 <span class="comment">     */</span>
02661     sec_params = snmpv3_header_build(session, pdu, global_data,
02662                                      out_length, 0, NULL);
02663     <span class="keywordflow">if</span> (sec_params == NULL)
02664         <span class="keywordflow">return</span> -1;
02665     global_data_len = sec_params - global_data;
02666     sec_params_len = *out_length;       <span class="comment">/* length left in packet buf for sec_params */</span>
02667 
02668 
02669     <span class="comment">/*</span>
02670 <span class="comment">     * build a scopedPDU structure into spdu_buf</span>
02671 <span class="comment">     */</span>
02672     spdu_buf_len = SNMP_MAX_MSG_SIZE;
02673     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"ScopedPdu"</span>);
02674     cp = snmpv3_scopedPDU_header_build(pdu, spdu_buf, &amp;spdu_buf_len,
02675                                        &amp;spdu_hdr_e);
02676     <span class="keywordflow">if</span> (cp == NULL)
02677         <span class="keywordflow">return</span> -1;
02678 
02679     <span class="comment">/*</span>
02680 <span class="comment">     * build the PDU structure onto the end of spdu_buf </span>
02681 <span class="comment">     */</span>
02682     DEBUGPRINTPDUTYPE(<span class="stringliteral">"send"</span>, ((pdu_data) ? *pdu_data : 0x00));
02683     <span class="keywordflow">if</span> (pdu_data) {
02684         memcpy(cp, pdu_data, pdu_data_len);
02685         cp += pdu_data_len;
02686     } <span class="keywordflow">else</span> {
02687         cp = snmp_pdu_build(pdu, cp, &amp;spdu_buf_len);
02688         <span class="keywordflow">if</span> (cp == NULL)
02689             <span class="keywordflow">return</span> -1;
02690     }
02691     DEBUGINDENTADD(-4);         <span class="comment">/* return from Scoped PDU */</span>
02692 
02693     <span class="comment">/*</span>
02694 <span class="comment">     * re-encode the actual ASN.1 length of the scopedPdu</span>
02695 <span class="comment">     */</span>
02696     spdu_len = cp - spdu_hdr_e; <span class="comment">/* length of scopedPdu minus ASN.1 headers */</span>
02697     spdu_buf_len = SNMP_MAX_MSG_SIZE;
02698     <span class="keywordflow">if</span> (asn_build_sequence(spdu_buf, &amp;spdu_buf_len,
02699                            (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
02700                            spdu_len) == NULL)
02701         <span class="keywordflow">return</span> -1;
02702     spdu_len = cp - spdu_buf;   <span class="comment">/* the length of the entire scopedPdu */</span>
02703 
02704 
02705     <span class="comment">/*</span>
02706 <span class="comment">     * call the security module to possibly encrypt and authenticate the</span>
02707 <span class="comment">     * message - the entire message to transmitted on the wire is returned</span>
02708 <span class="comment">     */</span>
02709     cp = NULL;
02710     *out_length = SNMP_MAX_MSG_SIZE;
02711     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SM msgSecurityParameters"</span>);
02712     sptr = find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
02713     <span class="keywordflow">if</span> (sptr &amp;&amp; sptr-&gt;encode_forward) {
02714         <span class="keyword">struct </span>snmp_secmod_outgoing_params parms;
02715         parms.msgProcModel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o12">msgParseModel</a>;
02716         parms.globalData = global_data;
02717         parms.globalDataLen = global_data_len;
02718         parms.maxMsgSize = SNMP_MAX_MSG_SIZE;
02719         parms.secModel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>;
02720         parms.secEngineID = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>;
02721         parms.secEngineIDLen = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>;
02722         parms.secName = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a>;
02723         parms.secNameLen = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a>;
02724         parms.secLevel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a>;
02725         parms.scopedPdu = spdu_buf;
02726         parms.scopedPduLen = spdu_len;
02727         parms.secStateRef = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>;
02728         parms.secParams = sec_params;
02729         parms.secParamsLen = &amp;sec_params_len;
02730         parms.wholeMsg = &amp;cp;
02731         parms.wholeMsgLen = out_length;
02732         parms.session = session;
02733         parms.pdu = pdu;
02734         result = (*sptr-&gt;encode_forward) (&amp;parms);
02735     } <span class="keywordflow">else</span> {
02736         <span class="keywordflow">if</span> (!sptr) {
02737             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"no such security service available: %d\n"</span>,
02738                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
02739         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!sptr-&gt;encode_forward) {
02740             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
02741                      <span class="stringliteral">"security service %d doesn't support forward out encoding.\n"</span>,
02742                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
02743         }
02744         result = -1;
02745     }
02746     DEBUGINDENTLESS();
02747     <span class="keywordflow">return</span> result;
02748 
02749 }                               <span class="comment">/* end snmpv3_packet_build() */</span>
02750 
02751 
02752 <span class="comment">/*</span>
02753 <span class="comment"> * Takes a session and a pdu and serializes the ASN PDU into the area</span>
02754 <span class="comment"> * pointed to by *pkt.  *pkt_len is the size of the data area available.</span>
02755 <span class="comment"> * Returns the length of the completed packet in *offset.  If any errors</span>
02756 <span class="comment"> * occur, -1 is returned.  If all goes well, 0 is returned.</span>
02757 <span class="comment"> */</span>
02758 
02759 <span class="keyword">static</span> <span class="keywordtype">int</span>
02760 _snmp_build(u_char ** pkt, size_t * pkt_len, size_t * offset,
02761             netsnmp_session * session, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
02762 {
02763 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
02764     u_char         *h0e = 0;
02765     size_t          start_offset = *offset;
02766     <span class="keywordtype">long</span>            version;
02767     <span class="keywordtype">int</span>             rc = 0;
02768 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
02769     
02770     u_char         *h0, *h1;
02771     u_char         *cp;
02772     size_t          length;
02773 
02774     session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
02775     session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
02776 
02777     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_3) {
02778         <span class="keywordflow">return</span> snmpv3_build(pkt, pkt_len, offset, session, pdu);
02779     }
02780 
02781     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>) {
02782     <span class="keywordflow">case</span> SNMP_MSG_RESPONSE:
02783         netsnmp_assert(0 == (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a> &amp; UCD_MSG_FLAG_EXPECT_RESPONSE));
02784         <span class="comment">/*</span>
02785 <span class="comment">         * Fallthrough </span>
02786 <span class="comment">         */</span>
02787     <span class="keywordflow">case</span> SNMP_MSG_GET:
02788     <span class="keywordflow">case</span> SNMP_MSG_GETNEXT:
02789     <span class="keywordflow">case</span> SNMP_MSG_SET:
02790         <span class="comment">/*</span>
02791 <span class="comment">         * all versions support these PDU types </span>
02792 <span class="comment">         */</span>
02793         <span class="comment">/*</span>
02794 <span class="comment">         * initialize defaulted PDU fields </span>
02795 <span class="comment">         */</span>
02796 
02797         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o6">errstat</a> == SNMP_DEFAULT_ERRSTAT)
02798             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a> = 0;
02799         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a> == SNMP_DEFAULT_ERRINDEX)
02800             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o7">errindex</a> = 0;
02801         <span class="keywordflow">break</span>;
02802 
02803     <span class="keywordflow">case</span> SNMP_MSG_TRAP2:
02804         netsnmp_assert(0 == (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a> &amp; UCD_MSG_FLAG_EXPECT_RESPONSE));
02805         <span class="comment">/*</span>
02806 <span class="comment">         * Fallthrough </span>
02807 <span class="comment">         */</span>
02808     <span class="keywordflow">case</span> SNMP_MSG_INFORM:
02809 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
02810         <span class="comment">/*</span>
02811 <span class="comment">         * not supported in SNMPv1 and SNMPsec </span>
02812 <span class="comment">         */</span>
02813         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_1) {
02814             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_V2_IN_V1;
02815             <span class="keywordflow">return</span> -1;
02816         }
02817 <span class="preprocessor">#endif</span>
02818         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o6">errstat</a> == SNMP_DEFAULT_ERRSTAT)
02819             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a> = 0;
02820         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a> == SNMP_DEFAULT_ERRINDEX)
02821             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o7">errindex</a> = 0;
02822         <span class="keywordflow">break</span>;
02823 
02824     <span class="keywordflow">case</span> SNMP_MSG_GETBULK:
02825         <span class="comment">/*</span>
02826 <span class="comment">         * not supported in SNMPv1 and SNMPsec </span>
02827 <span class="comment">         */</span>
02828 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
02829         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_1) {
02830             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_V2_IN_V1;
02831             <span class="keywordflow">return</span> -1;
02832         }
02833 <span class="preprocessor">#endif</span>
02834         <span class="keywordflow">if</span> (pdu-&gt;max_repetitions &lt; 0) {
02835             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_REPETITIONS;
02836             <span class="keywordflow">return</span> -1;
02837         }
02838         <span class="keywordflow">if</span> (pdu-&gt;non_repeaters &lt; 0) {
02839             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_REPEATERS;
02840             <span class="keywordflow">return</span> -1;
02841         }
02842         <span class="keywordflow">break</span>;
02843 
02844     <span class="keywordflow">case</span> SNMP_MSG_TRAP:
02845         <span class="comment">/*</span>
02846 <span class="comment">         * *only* supported in SNMPv1 and SNMPsec </span>
02847 <span class="comment">         */</span>
02848 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
02849         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> != SNMP_VERSION_1) {
02850             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_V1_IN_V2;
02851             <span class="keywordflow">return</span> -1;
02852         }
02853 <span class="preprocessor">#endif</span>
02854         <span class="comment">/*</span>
02855 <span class="comment">         * initialize defaulted Trap PDU fields </span>
02856 <span class="comment">         */</span>
02857         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a> = 1;         <span class=
"comment">/* give a bogus non-error reqid for traps */</span>
02858         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o21">enterprise_length</a> == SNMP_DEFAULT_ENTERPRISE_LENGTH) {
02859             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a> = (oid *) malloc(<span class=
"keyword">sizeof</span>(DEFAULT_ENTERPRISE));
02860             <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o20">enterprise</a> == NULL) {
02861                 session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
02862                 <span class="keywordflow">return</span> -1;
02863             }
02864             memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>, DEFAULT_ENTERPRISE,
02865                     <span class="keyword">sizeof</span>(DEFAULT_ENTERPRISE));
02866             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> =
02867                 <span class="keyword">sizeof</span>(DEFAULT_ENTERPRISE) / <span class="keyword">sizeof</span>(oid);
02868         }
02869         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a> == SNMP_DEFAULT_TIME)
02870             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o8">time</a> = DEFAULT_TIME;
02871         <span class="comment">/*</span>
02872 <span class="comment">         * don't expect a response </span>
02873 <span class="comment">         */</span>
02874         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> &amp;= (~UCD_MSG_FLAG_EXPECT_RESPONSE);
02875         <span class="keywordflow">break</span>;
02876 
02877     <span class="keywordflow">case</span> SNMP_MSG_REPORT:      <span class="comment">/* SNMPv3 only */</span>
02878     <span class="keywordflow">default</span>:
02879         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_UNKNOWN_PDU;
02880         <span class="keywordflow">return</span> -1;
02881     }
02882 
02883     <span class="comment">/*</span>
02884 <span class="comment">     * save length </span>
02885 <span class="comment">     */</span>
02886     length = *pkt_len;
02887 
02888     <span class="comment">/*</span>
02889 <span class="comment">     * setup administrative fields based on version </span>
02890 <span class="comment">     */</span>
02891     <span class="comment">/*</span>
02892 <span class="comment">     * build the message wrapper and all the administrative fields</span>
02893 <span class="comment">     * upto the PDU sequence</span>
02894 <span class="comment">     * (note that actual length of message will be inserted later) </span>
02895 <span class="comment">     */</span>
02896     h0 = *pkt;
02897     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>) {
02898 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
02899     <span class="keywordflow">case</span> SNMP_VERSION_1:
02900 <span class="preprocessor">#endif</span>
02901 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
02902     <span class="keywordflow">case</span> SNMP_VERSION_2c:
02903 <span class="preprocessor">#endif</span>
02904 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
02905 <span class="preprocessor">#ifdef NO_ZEROLENGTH_COMMUNITY</span>
02906         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o19">community_len</a> == 0) {
02907             <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a> == 0) {
02908                 session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_COMMUNITY;
02909                 <span class="keywordflow">return</span> -1;
02910             }
02911             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a> = (u_char *) malloc(session-&gt;<a class=
"code" href="structsnmp__session.html#o17">community_len</a>);
02912             <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a> == NULL) {
02913                 session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
02914                 <span class="keywordflow">return</span> -1;
02915             }
02916             memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a>,
02917                     session-&gt;<a class="code" href="structsnmp__session.html#o16">community</a>, session-&gt;<a class=
"code" href="structsnmp__session.html#o17">community_len</a>);
02918             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>;
02919         }
02920 <span class="preprocessor">#else                           </span><span class=
"comment">/* !NO_ZEROLENGTH_COMMUNITY */</span>
02921         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o19">community_len</a> == 0 &amp;&amp; pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a> != SNMP_MSG_RESPONSE) {
02922             <span class="comment">/*</span>
02923 <span class="comment">             * copy session community exactly to pdu community </span>
02924 <span class="comment">             */</span>
02925             <span class="keywordflow">if</span> (0 == session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>) {
02926                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a>);
02927                 pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a> = NULL;
02928             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o19">community_len</a> == session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>) {
02929                 memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a>,
02930                         session-&gt;<a class="code" href=
"structsnmp__session.html#o16">community</a>, session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a>);
02931             } <span class="keywordflow">else</span> {
02932                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a>);
02933                 pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a> = (u_char *) malloc(session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>);
02934                 <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a> == NULL) {
02935                     session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
02936                     <span class="keywordflow">return</span> -1;
02937                 }
02938                 memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a>,
02939                         session-&gt;<a class="code" href=
"structsnmp__session.html#o16">community</a>, session-&gt;<a class="code" href="structsnmp__session.html#o17">community_len</a>);
02940             }
02941             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o17">community_len</a>;
02942         }
02943 <span class="preprocessor">#endif                          </span><span class=
"comment">/* !NO_ZEROLENGTH_COMMUNITY */</span>
02944 
02945         DEBUGMSGTL((<span class="stringliteral">"snmp_send"</span>, <span class=
"stringliteral">"Building SNMPv%d message...\n"</span>,
02946                     (1 + pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>)));
02947 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02948         <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REVERSE_ENCODE)) {
02949             DEBUGPRINTPDUTYPE(<span class="stringliteral">"send"</span>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a>);
02950             rc = snmp_pdu_realloc_rbuild(pkt, pkt_len, offset, pdu);
02951             <span class="keywordflow">if</span> (rc == 0) {
02952                 <span class="keywordflow">return</span> -1;
02953             }
02954 
02955             DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"Community String"</span>);
02956             rc = asn_realloc_rbuild_string(pkt, pkt_len, offset, 1,
02957                                            (u_char) (ASN_UNIVERSAL |
02958                                                      ASN_PRIMITIVE |
02959                                                      ASN_OCTET_STR),
02960                                            pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a>,
02961                                            pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a>);
02962             DEBUGINDENTLESS();
02963             <span class="keywordflow">if</span> (rc == 0) {
02964                 <span class="keywordflow">return</span> -1;
02965             }
02966 
02967 
02968             <span class="comment">/*</span>
02969 <span class="comment">             * Store the version field.  </span>
02970 <span class="comment">             */</span>
02971             DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SNMP Version Number"</span>);
02972 
02973             version = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>;
02974             rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
02975                                         (u_char) (ASN_UNIVERSAL |
02976                                                   ASN_PRIMITIVE |
02977                                                   ASN_INTEGER),
02978                                         (<span class="keywordtype">long</span> *) &amp;version,
02979                                         <span class="keyword">sizeof</span>(version));
02980             DEBUGINDENTLESS();
02981             <span class="keywordflow">if</span> (rc == 0) {
02982                 <span class="keywordflow">return</span> -1;
02983             }
02984 
02985             <span class="comment">/*</span>
02986 <span class="comment">             * Build the final sequence.  </span>
02987 <span class="comment">             */</span>
02988 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
02989             <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_1) {
02990                 DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SNMPv1 Message"</span>);
02991             } <span class="keywordflow">else</span> {
02992 <span class="preprocessor">#endif</span>
02993                 DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SNMPv2c Message"</span>);
02994 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
02995             }
02996 <span class="preprocessor">#endif</span>
02997             rc = asn_realloc_rbuild_sequence(pkt, pkt_len, offset, 1,
02998                                              (u_char) (ASN_SEQUENCE |
02999                                                        ASN_CONSTRUCTOR),
03000                                              *offset - start_offset);
03001             DEBUGINDENTLESS();
03002 
03003             <span class="keywordflow">if</span> (rc == 0) {
03004                 <span class="keywordflow">return</span> -1;
03005             }
03006             <span class="keywordflow">return</span> 0;
03007         } <span class="keywordflow">else</span> {
03008 
03009 <span class="preprocessor">#endif                          </span><span class=
"comment">/* USE_REVERSE_ASNENCODING */</span>
03010             <span class="comment">/*</span>
03011 <span class="comment">             * Save current location and build SEQUENCE tag and length</span>
03012 <span class="comment">             * placeholder for SNMP message sequence</span>
03013 <span class="comment">             * (actual length will be inserted later) </span>
03014 <span class="comment">             */</span>
03015             cp = asn_build_sequence(*pkt, pkt_len,
03016                                     (u_char) (ASN_SEQUENCE |
03017                                               ASN_CONSTRUCTOR), 0);
03018             <span class="keywordflow">if</span> (cp == NULL) {
03019                 <span class="keywordflow">return</span> -1;
03020             }
03021             h0e = cp;
03022 
03023 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
03024             <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_1) {
03025                 DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SNMPv1 Message"</span>);
03026             } <span class="keywordflow">else</span> {
03027 <span class="preprocessor">#endif</span>
03028                 DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SNMPv2c Message"</span>);
03029 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
03030             }
03031 <span class="preprocessor">#endif</span>
03032 
03033             <span class="comment">/*</span>
03034 <span class="comment">             * store the version field </span>
03035 <span class="comment">             */</span>
03036             DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"SNMP Version Number"</span>);
03037 
03038             version = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>;
03039             cp = asn_build_int(*pkt, pkt_len,
03040                                (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03041                                          ASN_INTEGER), (<span class="keywordtype">long</span> *) &amp;version,
03042                                <span class="keyword">sizeof</span>(version));
03043             DEBUGINDENTLESS();
03044             <span class="keywordflow">if</span> (cp == NULL)
03045                 <span class="keywordflow">return</span> -1;
03046 
03047             <span class="comment">/*</span>
03048 <span class="comment">             * store the community string </span>
03049 <span class="comment">             */</span>
03050             DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"Community String"</span>);
03051             cp = asn_build_string(*pkt, pkt_len,
03052                                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03053                                             ASN_OCTET_STR), pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a>,
03054                                   pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a>);
03055             DEBUGINDENTLESS();
03056             <span class="keywordflow">if</span> (cp == NULL)
03057                 <span class="keywordflow">return</span> -1;
03058             <span class="keywordflow">break</span>;
03059 
03060 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
03061         }
03062 <span class="preprocessor">#endif                          </span><span class=
"comment">/* USE_REVERSE_ASNENCODING */</span>
03063         <span class="keywordflow">break</span>;
03064 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
03065     <span class="keywordflow">case</span> SNMP_VERSION_2p:
03066     <span class="keywordflow">case</span> SNMP_VERSION_sec:
03067     <span class="keywordflow">case</span> SNMP_VERSION_2u:
03068     <span class="keywordflow">case</span> SNMP_VERSION_2star:
03069     <span class="keywordflow">default</span>:
03070         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
03071         <span class="keywordflow">return</span> -1;
03072     }
03073 
03074     h1 = cp;
03075     DEBUGPRINTPDUTYPE(<span class="stringliteral">"send"</span>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a>);
03076     cp = snmp_pdu_build(pdu, cp, pkt_len);
03077     DEBUGINDENTADD(-4);         <span class="comment">/* return from entire v1/v2c message */</span>
03078     <span class="keywordflow">if</span> (cp == NULL)
03079         <span class="keywordflow">return</span> -1;
03080 
03081     <span class="comment">/*</span>
03082 <span class="comment">     * insert the actual length of the message sequence </span>
03083 <span class="comment">     */</span>
03084     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>) {
03085 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
03086     <span class="keywordflow">case</span> SNMP_VERSION_1:
03087 <span class="preprocessor">#endif</span>
03088 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
03089     <span class="keywordflow">case</span> SNMP_VERSION_2c:
03090 <span class="preprocessor">#endif</span>
03091 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
03092         asn_build_sequence(*pkt, &amp;length,
03093                            (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
03094                            cp - h0e);
03095         <span class="keywordflow">break</span>;
03096 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
03097 
03098     <span class="keywordflow">case</span> SNMP_VERSION_2p:
03099     <span class="keywordflow">case</span> SNMP_VERSION_sec:
03100     <span class="keywordflow">case</span> SNMP_VERSION_2u:
03101     <span class="keywordflow">case</span> SNMP_VERSION_2star:
03102     <span class="keywordflow">default</span>:
03103         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
03104         <span class="keywordflow">return</span> -1;
03105     }
03106     *pkt_len = cp - *pkt;
03107     <span class="keywordflow">return</span> 0;
03108 }
03109 
03110 <span class="keywordtype">int</span>
03111 snmp_build(u_char ** pkt, size_t * pkt_len, size_t * offset,
03112            netsnmp_session * pss, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
03113 {
03114     <span class="keywordtype">int</span>             rc;
03115     rc = _snmp_build(pkt, pkt_len, offset, pss, pdu);
03116     <span class="keywordflow">if</span> (rc) {
03117         <span class="keywordflow">if</span> (!pss-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a>) {
03118             pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_ASN1_BUILD;
03119             netsnmp_assert(pss-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> != SNMPERR_BAD_ASN1_BUILD);
03120         }
03121         SET_SNMP_ERROR(pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
03122         rc = -1;
03123     }
03124     <span class="keywordflow">return</span> rc;
03125 }
03126 
03127 <span class="comment">/*</span>
03128 <span class="comment"> * on error, returns NULL (likely an encoding problem). </span>
03129 <span class="comment"> */</span>
03130 u_char         *
03131 snmp_pdu_build(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, u_char * cp, size_t * out_length)
03132 {
03133     u_char         *h1, *h1e, *h2, *h2e;
03134     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vp;
03135     size_t          length;
03136 
03137     length = *out_length;
03138     <span class="comment">/*</span>
03139 <span class="comment">     * Save current location and build PDU tag and length placeholder</span>
03140 <span class="comment">     * (actual length will be inserted later) </span>
03141 <span class="comment">     */</span>
03142     h1 = cp;
03143     cp = asn_build_sequence(cp, out_length, (u_char) pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a>, 0);
03144     <span class="keywordflow">if</span> (cp == NULL)
03145         <span class="keywordflow">return</span> NULL;
03146     h1e = cp;
03147 
03148     <span class="comment">/*</span>
03149 <span class="comment">     * store fields in the PDU preceeding the variable-bindings sequence </span>
03150 <span class="comment">     */</span>
03151     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a> != SNMP_MSG_TRAP) {
03152         <span class="comment">/*</span>
03153 <span class="comment">         * PDU is not an SNMPv1 trap </span>
03154 <span class="comment">         */</span>
03155 
03156         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"request_id"</span>);
03157         <span class="comment">/*</span>
03158 <span class="comment">         * request id </span>
03159 <span class="comment">         */</span>
03160         cp = asn_build_int(cp, out_length,
03161                            (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03162                                      ASN_INTEGER), &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a>,
03163                            <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a>));
03164         DEBUGINDENTLESS();
03165         <span class="keywordflow">if</span> (cp == NULL)
03166             <span class="keywordflow">return</span> NULL;
03167 
03168         <span class="comment">/*</span>
03169 <span class="comment">         * error status (getbulk non-repeaters) </span>
03170 <span class="comment">         */</span>
03171         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"error status"</span>);
03172         cp = asn_build_int(cp, out_length,
03173                            (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03174                                      ASN_INTEGER), &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a>,
03175                            <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o6">errstat</a>));
03176         DEBUGINDENTLESS();
03177         <span class="keywordflow">if</span> (cp == NULL)
03178             <span class="keywordflow">return</span> NULL;
03179 
03180         <span class="comment">/*</span>
03181 <span class="comment">         * error index (getbulk max-repetitions) </span>
03182 <span class="comment">         */</span>
03183         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"error index"</span>);
03184         cp = asn_build_int(cp, out_length,
03185                            (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03186                                      ASN_INTEGER), &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a>,
03187                            <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a>));
03188         DEBUGINDENTLESS();
03189         <span class="keywordflow">if</span> (cp == NULL)
03190             <span class="keywordflow">return</span> NULL;
03191     } <span class="keywordflow">else</span> {
03192         <span class="comment">/*</span>
03193 <span class="comment">         * an SNMPv1 trap PDU </span>
03194 <span class="comment">         */</span>
03195 
03196         <span class="comment">/*</span>
03197 <span class="comment">         * enterprise </span>
03198 <span class="comment">         */</span>
03199         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"enterprise OBJID"</span>);
03200         cp = asn_build_objid(cp, out_length,
03201                              (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03202                                        ASN_OBJECT_ID),
03203                              (oid *) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>,
03204                              pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a>);
03205         DEBUGINDENTLESS();
03206         <span class="keywordflow">if</span> (cp == NULL)
03207             <span class="keywordflow">return</span> NULL;
03208 
03209         <span class="comment">/*</span>
03210 <span class="comment">         * agent-addr </span>
03211 <span class="comment">         */</span>
03212         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"agent Address"</span>);
03213         cp = asn_build_string(cp, out_length,
03214                               (u_char) (ASN_IPADDRESS | ASN_PRIMITIVE),
03215                               (u_char *) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>, 4);
03216         DEBUGINDENTLESS();
03217         <span class="keywordflow">if</span> (cp == NULL)
03218             <span class="keywordflow">return</span> NULL;
03219 
03220         <span class="comment">/*</span>
03221 <span class="comment">         * generic trap </span>
03222 <span class="comment">         */</span>
03223         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"generic trap number"</span>);
03224         cp = asn_build_int(cp, out_length,
03225                            (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03226                                      ASN_INTEGER),
03227                            (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a>,
03228                            <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a>));
03229         DEBUGINDENTLESS();
03230         <span class="keywordflow">if</span> (cp == NULL)
03231             <span class="keywordflow">return</span> NULL;
03232 
03233         <span class="comment">/*</span>
03234 <span class="comment">         * specific trap </span>
03235 <span class="comment">         */</span>
03236         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"specific trap number"</span>);
03237         cp = asn_build_int(cp, out_length,
03238                            (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
03239                                      ASN_INTEGER),
03240                            (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>,
03241                            <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>));
03242         DEBUGINDENTLESS();
03243         <span class="keywordflow">if</span> (cp == NULL)
03244             <span class="keywordflow">return</span> NULL;
03245 
03246         <span class="comment">/*</span>
03247 <span class="comment">         * timestamp  </span>
03248 <span class="comment">         */</span>
03249         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"timestamp"</span>);
03250         cp = asn_build_unsigned_int(cp, out_length,
03251                                     (u_char) (ASN_TIMETICKS |
03252                                               ASN_PRIMITIVE), &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a>,
03253                                     <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a>));
03254         DEBUGINDENTLESS();
03255         <span class="keywordflow">if</span> (cp == NULL)
03256             <span class="keywordflow">return</span> NULL;
03257     }
03258 
03259     <span class="comment">/*</span>
03260 <span class="comment">     * Save current location and build SEQUENCE tag and length placeholder</span>
03261 <span class="comment">     * for variable-bindings sequence</span>
03262 <span class="comment">     * (actual length will be inserted later) </span>
03263 <span class="comment">     */</span>
03264     h2 = cp;
03265     cp = asn_build_sequence(cp, out_length,
03266                             (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR), 0);
03267     <span class="keywordflow">if</span> (cp == NULL)
03268         <span class="keywordflow">return</span> NULL;
03269     h2e = cp;
03270 
03271     <span class="comment">/*</span>
03272 <span class="comment">     * Store variable-bindings </span>
03273 <span class="comment">     */</span>
03274     DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"VarBindList"</span>);
03275     <span class="keywordflow">for</span> (vp = pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>; vp; vp = vp-&gt;<a class="code" href=
"structvariable__list.html#o0">next_variable</a>) {
03276         DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"VarBind"</span>);
03277         cp = snmp_build_var_op(cp, vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a>, vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
03278                                vp-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>, (u_char *) vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string,
03279                                out_length);
03280         DEBUGINDENTLESS();
03281         <span class="keywordflow">if</span> (cp == NULL)
03282             <span class="keywordflow">return</span> NULL;
03283     }
03284     DEBUGINDENTLESS();
03285 
03286     <span class="comment">/*</span>
03287 <span class="comment">     * insert actual length of variable-bindings sequence </span>
03288 <span class="comment">     */</span>
03289     asn_build_sequence(h2, &amp;length,
03290                        (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
03291                        cp - h2e);
03292 
03293     <span class="comment">/*</span>
03294 <span class="comment">     * insert actual length of PDU sequence </span>
03295 <span class="comment">     */</span>
03296     asn_build_sequence(h1, &amp;length, (u_char) pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a>, cp - h1e);
03297 
03298     <span class="keywordflow">return</span> cp;
03299 }
03300 
03301 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
03302 <span class="comment">/*</span>
03303 <span class="comment"> * On error, returns 0 (likely an encoding problem).  </span>
03304 <span class="comment"> */</span>
03305 <span class="keywordtype">int</span>
03306 snmp_pdu_realloc_rbuild(u_char ** pkt, size_t * pkt_len, size_t * offset,
03307                         <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
03308 {
03309 <span class="preprocessor">#ifndef VPCACHE_SIZE</span>
03310 <span class="preprocessor">#define VPCACHE_SIZE 50</span>
03311 <span class="preprocessor">#endif</span>
03312     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vpcache[VPCACHE_SIZE];
03313     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vp, *tmpvp;
03314     size_t          start_offset = *offset;
03315     <span class="keywordtype">int</span>             i, wrapped = 0, notdone, <span class="keyword">final</span>, rc = 0;
03316 
03317     DEBUGMSGTL((<span class="stringliteral">"snmp_pdu_realloc_rbuild"</span>, <span class=
"stringliteral">"starting\n"</span>));
03318     <span class="keywordflow">for</span> (vp = pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>, i = VPCACHE_SIZE - 1; vp;
03319          vp = vp-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>, i--) {
03320         <span class="keywordflow">if</span> (i &lt; 0) {
03321             wrapped = notdone = 1;
03322             i = VPCACHE_SIZE - 1;
03323             DEBUGMSGTL((<span class="stringliteral">"snmp_pdu_realloc_rbuild"</span>, <span class=
"stringliteral">"wrapped\n"</span>));
03324         }
03325         vpcache[i] = vp;
03326     }
03327     <span class="keyword">final</span> = i + 1;
03328 
03329     <span class="keywordflow">do</span> {
03330         <span class="keywordflow">for</span> (i = <span class="keyword">final</span>; i &lt; VPCACHE_SIZE; i++) {
03331             vp = vpcache[i];
03332             DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"VarBind"</span>);
03333             rc = snmp_realloc_rbuild_var_op(pkt, pkt_len, offset, 1,
03334                                             vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>,
03335                                             vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
03336                                             (u_char *) vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string,
03337                                             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
03338             DEBUGINDENTLESS();
03339             <span class="keywordflow">if</span> (rc == 0) {
03340                 <span class="keywordflow">return</span> 0;
03341             }
03342         }
03343 
03344         DEBUGINDENTLESS();
03345         <span class="keywordflow">if</span> (wrapped) {
03346             notdone = 1;
03347             <span class="keywordflow">for</span> (i = 0; i &lt; <span class="keyword">final</span>; i++) {
03348                 vp = vpcache[i];
03349                 DEBUGDUMPSECTION(<span class="stringliteral">"send"</span>, <span class="stringliteral">"VarBind"</span>);
03350                 rc = snmp_realloc_rbuild_var_op(pkt, pkt_len, offset, 1,
03351                                                 vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>,
03352                                                 vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
03353                                                 (u_char *) vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string,
03354                                                 vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
03355                 DEBUGINDENTLESS();
03356                 <span class="keywordflow">if</span> (rc == 0) {
03357                     <span class="keywordflow">return</span> 0;
03358                 }
03359             }
03360 
03361             <span class="keywordflow">if</span> (<span class="keyword">final</span> == 0) {
03362                 tmpvp = vpcache[VPCACHE_SIZE - 1];
03363             } <span class="keywordflow">else</span> {
03364                 tmpvp = vpcache[<span class="keyword">final</span> - 1];
03365             }
03366             wrapped = 0;
03367 
03368             <span class="keywordflow">for</span> (vp = pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>, i = VPCACHE_SIZE - 1;
03369                  vp &amp;&amp; vp != tmpvp; vp = vp-&gt;<a class="code" href=
"structvariable__list.html#o0">next_variable</a>, i--) {
03370                 <span class="keywordflow">if</span> (i &lt; 0) {
03371                     wrapped = 1;
03372                     i = VPCACHE_SIZE - 1;
03373                     DEBUGMSGTL((<span class="stringliteral">"snmp_pdu_realloc_rbuild"</span>, <span class=
"stringliteral">"wrapped\n"</span>));
03374                 }
03375                 vpcache[i] = vp;
03376             }
03377             <span class="keyword">final</span> = i + 1;
03378         } <span class="keywordflow">else</span> {
03379             notdone = 0;
03380         }
03381     } <span class="keywordflow">while</span> (notdone);
03382 
03383     <span class="comment">/*</span>
03384 <span class="comment">     * Save current location and build SEQUENCE tag and length placeholder for</span>
03385 <span class="comment">     * variable-bindings sequence (actual length will be inserted later).  </span>
03386 <span class="comment">     */</span>
03387 
03388     rc = asn_realloc_rbuild_sequence(pkt, pkt_len, offset, 1,
03389                                      (u_char) (ASN_SEQUENCE |
03390                                                ASN_CONSTRUCTOR),
03391                                      *offset - start_offset);
03392 
03393     <span class="comment">/*</span>
03394 <span class="comment">     * Store fields in the PDU preceeding the variable-bindings sequence.  </span>
03395 <span class="comment">     */</span>
03396     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a> != SNMP_MSG_TRAP) {
03397         <span class="comment">/*</span>
03398 <span class="comment">         * Error index (getbulk max-repetitions).  </span>
03399 <span class="comment">         */</span>
03400         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"error index"</span>);
03401         rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
03402                                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
03403                                               | ASN_INTEGER),
03404                                     &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o7">errindex</a>, <span class=
"keyword">sizeof</span>(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o7">errindex</a>));
03405         DEBUGINDENTLESS();
03406         <span class="keywordflow">if</span> (rc == 0) {
03407             <span class="keywordflow">return</span> 0;
03408         }
03409 
03410         <span class="comment">/*</span>
03411 <span class="comment">         * Error status (getbulk non-repeaters).  </span>
03412 <span class="comment">         */</span>
03413         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"error status"</span>);
03414         rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
03415                                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
03416                                               | ASN_INTEGER),
03417                                     &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a>, <span class=
"keyword">sizeof</span>(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a>));
03418         DEBUGINDENTLESS();
03419         <span class="keywordflow">if</span> (rc == 0) {
03420             <span class="keywordflow">return</span> 0;
03421         }
03422 
03423         <span class="comment">/*</span>
03424 <span class="comment">         * Request ID.  </span>
03425 <span class="comment">         */</span>
03426         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"request_id"</span>);
03427         rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
03428                                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
03429                                               | ASN_INTEGER), &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a>,
03430                                     <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a>));
03431         DEBUGINDENTLESS();
03432         <span class="keywordflow">if</span> (rc == 0) {
03433             <span class="keywordflow">return</span> 0;
03434         }
03435     } <span class="keywordflow">else</span> {
03436         <span class="comment">/*</span>
03437 <span class="comment">         * An SNMPv1 trap PDU.  </span>
03438 <span class="comment">         */</span>
03439 
03440         <span class="comment">/*</span>
03441 <span class="comment">         * Timestamp.  </span>
03442 <span class="comment">         */</span>
03443         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"timestamp"</span>);
03444         rc = asn_realloc_rbuild_unsigned_int(pkt, pkt_len, offset, 1,
03445                                              (u_char) (ASN_TIMETICKS |
03446                                                        ASN_PRIMITIVE),
03447                                              &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o8">time</a>,
03448                                              <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a>));
03449         DEBUGINDENTLESS();
03450         <span class="keywordflow">if</span> (rc == 0) {
03451             <span class="keywordflow">return</span> 0;
03452         }
03453 
03454         <span class="comment">/*</span>
03455 <span class="comment">         * Specific trap.  </span>
03456 <span class="comment">         */</span>
03457         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"specific trap number"</span>);
03458         rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
03459                                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
03460                                               | ASN_INTEGER),
03461                                     (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>,
03462                                     <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>));
03463         DEBUGINDENTLESS();
03464         <span class="keywordflow">if</span> (rc == 0) {
03465             <span class="keywordflow">return</span> 0;
03466         }
03467 
03468         <span class="comment">/*</span>
03469 <span class="comment">         * Generic trap.  </span>
03470 <span class="comment">         */</span>
03471         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"generic trap number"</span>);
03472         rc = asn_realloc_rbuild_int(pkt, pkt_len, offset, 1,
03473                                     (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
03474                                               | ASN_INTEGER),
03475                                     (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a>,
03476                                     <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a>));
03477         DEBUGINDENTLESS();
03478         <span class="keywordflow">if</span> (rc == 0) {
03479             <span class="keywordflow">return</span> 0;
03480         }
03481 
03482         <span class="comment">/*</span>
03483 <span class="comment">         * Agent-addr.  </span>
03484 <span class="comment">         */</span>
03485         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"agent Address"</span>);
03486         rc = asn_realloc_rbuild_string(pkt, pkt_len, offset, 1,
03487                                        (u_char) (ASN_IPADDRESS |
03488                                                  ASN_PRIMITIVE),
03489                                        (u_char *) pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o24">agent_addr</a>, 4);
03490         DEBUGINDENTLESS();
03491         <span class="keywordflow">if</span> (rc == 0) {
03492             <span class="keywordflow">return</span> 0;
03493         }
03494 
03495         <span class="comment">/*</span>
03496 <span class="comment">         * Enterprise.  </span>
03497 <span class="comment">         */</span>
03498         DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"enterprise OBJID"</span>);
03499         rc = asn_realloc_rbuild_objid(pkt, pkt_len, offset, 1,
03500                                       (u_char) (ASN_UNIVERSAL |
03501                                                 ASN_PRIMITIVE |
03502                                                 ASN_OBJECT_ID),
03503                                       (oid *) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>,
03504                                       pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a>);
03505         DEBUGINDENTLESS();
03506         <span class="keywordflow">if</span> (rc == 0) {
03507             <span class="keywordflow">return</span> 0;
03508         }
03509     }
03510 
03511     <span class="comment">/*</span>
03512 <span class="comment">     * Build the PDU sequence.  </span>
03513 <span class="comment">     */</span>
03514     rc = asn_realloc_rbuild_sequence(pkt, pkt_len, offset, 1,
03515                                      (u_char) pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>,
03516                                      *offset - start_offset);
03517     <span class="keywordflow">return</span> rc;
03518 }
03519 <span class="preprocessor">#endif                          </span><span class=
"comment">/* USE_REVERSE_ASNENCODING */</span>
03520 
03521 <span class="comment">/*</span>
03522 <span class="comment"> * Parses the packet received to determine version, either directly</span>
03523 <span class="comment"> * from packets version field or inferred from ASN.1 construct.</span>
03524 <span class="comment"> */</span>
03525 <span class="keyword">static</span> <span class="keywordtype">int</span>
03526 snmp_parse_version(u_char * data, size_t length)
03527 {
03528     u_char          type;
03529     <span class="keywordtype">long</span>            version = SNMPERR_BAD_VERSION;
03530 
03531     data = asn_parse_sequence(data, &amp;length, &amp;type,
03532                               (ASN_SEQUENCE | ASN_CONSTRUCTOR), <span class="stringliteral">"version"</span>);
03533     <span class="keywordflow">if</span> (data) {
03534         data =
03535             asn_parse_int(data, &amp;length, &amp;type, &amp;version, <span class="keyword">sizeof</span>(version));
03536         <span class="keywordflow">if</span> (!data || type != ASN_INTEGER) {
03537             <span class="keywordflow">return</span> SNMPERR_BAD_VERSION;
03538         }
03539     }
03540     <span class="keywordflow">return</span> version;
03541 }
03542 
03543 
03544 <span class="keywordtype">int</span>
03545 snmpv3_parse(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
03546              u_char * data,
03547              size_t * length,
03548              u_char ** after_header, netsnmp_session * sess)
03549 {
03550     u_char          type, msg_flags;
03551     <span class="keywordtype">long</span>            ver, msg_max_size, msg_sec_model;
03552     size_t          max_size_response;
03553     u_char          tmp_buf[SNMP_MAX_MSG_SIZE];
03554     size_t          tmp_buf_len;
03555     u_char          pdu_buf[SNMP_MAX_MSG_SIZE];
03556     u_char         *mallocbuf = NULL;
03557     size_t          pdu_buf_len = SNMP_MAX_MSG_SIZE;
03558     u_char         *sec_params;
03559     u_char         *msg_data;
03560     u_char         *cp;
03561     size_t          asn_len, msg_len;
03562     <span class="keywordtype">int</span>             ret, ret_val;
03563     <span class="keyword">struct </span>snmp_secmod_def *sptr;
03564 
03565 
03566     msg_data = data;
03567     msg_len = *length;
03568 
03569 
03570     <span class="comment">/*</span>
03571 <span class="comment">     * message is an ASN.1 SEQUENCE  </span>
03572 <span class="comment">     */</span>
03573     DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"SNMPv3 Message"</span>);
03574     data = asn_parse_sequence(data, length, &amp;type,
03575                               (ASN_SEQUENCE | ASN_CONSTRUCTOR), <span class="stringliteral">"message"</span>);
03576     <span class="keywordflow">if</span> (data == NULL) {
03577         <span class="comment">/*</span>
03578 <span class="comment">         * error msg detail is set </span>
03579 <span class="comment">         */</span>
03580         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03581         DEBUGINDENTLESS();
03582         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03583     }
03584 
03585     <span class="comment">/*</span>
03586 <span class="comment">     * parse msgVersion  </span>
03587 <span class="comment">     */</span>
03588     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"SNMP Version Number"</span>);
03589     data = asn_parse_int(data, length, &amp;type, &amp;ver, <span class="keyword">sizeof</span>(ver));
03590     DEBUGINDENTLESS();
03591     <span class="keywordflow">if</span> (data == NULL) {
03592         ERROR_MSG(<span class="stringliteral">"bad parse of version"</span>);
03593         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03594         DEBUGINDENTLESS();
03595         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03596     }
03597     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a> = ver;
03598 
03599     <span class="comment">/*</span>
03600 <span class="comment">     * parse msgGlobalData sequence  </span>
03601 <span class="comment">     */</span>
03602     cp = data;
03603     asn_len = *length;
03604     DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"msgGlobalData"</span>);
03605     data = asn_parse_sequence(data, &amp;asn_len, &amp;type,
03606                               (ASN_SEQUENCE | ASN_CONSTRUCTOR),
03607                               <span class="stringliteral">"msgGlobalData"</span>);
03608     <span class="keywordflow">if</span> (data == NULL) {
03609         <span class="comment">/*</span>
03610 <span class="comment">         * error msg detail is set </span>
03611 <span class="comment">         */</span>
03612         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03613         DEBUGINDENTADD(-4);
03614         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03615     }
03616     *length -= data - cp;       <span class="comment">/* subtract off the length of the header */</span>
03617 
03618     <span class="comment">/*</span>
03619 <span class="comment">     * msgID </span>
03620 <span class="comment">     */</span>
03621     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"msgID"</span>);
03622     data =
03623         asn_parse_int(data, length, &amp;type, &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a>,
03624                       <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o3">msgid</a>));
03625     DEBUGINDENTLESS();
03626     <span class="keywordflow">if</span> (data == NULL || type != ASN_INTEGER) {
03627         ERROR_MSG(<span class="stringliteral">"error parsing msgID"</span>);
03628         DEBUGINDENTADD(-4);
03629         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03630         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03631     }
03632 
03633     <span class="comment">/*</span>
03634 <span class="comment">     * Check the msgID we received is a legal value.  If not, then increment</span>
03635 <span class="comment">     * snmpInASNParseErrs and return the appropriate error (see RFC 2572,</span>
03636 <span class="comment">     * para. 7.2, section 2 -- note that a bad msgID means that the received</span>
03637 <span class="comment">     * message is NOT a serialiization of an SNMPv3Message, since the msgID</span>
03638 <span class="comment">     * field is out of bounds).  </span>
03639 <span class="comment">     */</span>
03640 
03641     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o3">msgid</a> &lt; 0 || pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a> &gt; 0x7fffffff) {
03642         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Received bad msgID (%ld %s %s).\n"</span>, pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a>,
03643                  (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a> &lt; 0) ? <span class=
"stringliteral">"&lt;"</span> : <span class="stringliteral">"&gt;"</span>,
03644                  (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a> &lt; 0) ? <span class=
"stringliteral">"0"</span> : <span class="stringliteral">"2^31 - 1"</span>);
03645         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03646         DEBUGINDENTADD(-4);
03647         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03648     }
03649 
03650     <span class="comment">/*</span>
03651 <span class="comment">     * msgMaxSize </span>
03652 <span class="comment">     */</span>
03653     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"msgMaxSize"</span>);
03654     data = asn_parse_int(data, length, &amp;type, &amp;msg_max_size,
03655                          <span class="keyword">sizeof</span>(msg_max_size));
03656     DEBUGINDENTLESS();
03657     <span class="keywordflow">if</span> (data == NULL || type != ASN_INTEGER) {
03658         ERROR_MSG(<span class="stringliteral">"error parsing msgMaxSize"</span>);
03659         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03660         DEBUGINDENTADD(-4);
03661         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03662     }
03663 
03664     <span class="comment">/*</span>
03665 <span class="comment">     * Check the msgMaxSize we received is a legal value.  If not, then</span>
03666 <span class="comment">     * increment snmpInASNParseErrs and return the appropriate error (see RFC</span>
03667 <span class="comment">     * 2572, para. 7.2, section 2 -- note that a bad msgMaxSize means that the</span>
03668 <span class="comment">     * received message is NOT a serialiization of an SNMPv3Message, since the</span>
03669 <span class="comment">     * msgMaxSize field is out of bounds).</span>
03670 <span class="comment">     * </span>
03671 <span class="comment">     * Note we store the msgMaxSize on a per-session basis which also seems</span>
03672 <span class="comment">     * reasonable; it could vary from PDU to PDU but that would be strange</span>
03673 <span class="comment">     * (also since we deal with a PDU at a time, it wouldn't make any</span>
03674 <span class="comment">     * difference to our responses, if any).  </span>
03675 <span class="comment">     */</span>
03676 
03677     <span class="keywordflow">if</span> (msg_max_size &lt; 484) {
03678         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Received bad msgMaxSize (%lu &lt; 484).\n"</span>,
03679                  msg_max_size);
03680         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03681         DEBUGINDENTADD(-4);
03682         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03683     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg_max_size &gt; 0x7fffffff) {
03684         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Received bad msgMaxSize (%lu &gt; 2^31 - 1).\n"</span>,
03685                  msg_max_size);
03686         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03687         DEBUGINDENTADD(-4);
03688         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03689     } <span class="keywordflow">else</span> {
03690         DEBUGMSGTL((<span class="stringliteral">"snmpv3_parse"</span>, <span class=
"stringliteral">"msgMaxSize %lu received\n"</span>,
03691                     msg_max_size));
03692         sess-&gt;<a class="code" href="structsnmp__session.html#o19">sndMsgMaxSize</a> = msg_max_size;
03693     }
03694 
03695     <span class="comment">/*</span>
03696 <span class="comment">     * msgFlags </span>
03697 <span class="comment">     */</span>
03698     tmp_buf_len = SNMP_MAX_MSG_SIZE;
03699     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"msgFlags"</span>);
03700     data = asn_parse_string(data, length, &amp;type, tmp_buf, &amp;tmp_buf_len);
03701     DEBUGINDENTLESS();
03702     <span class="keywordflow">if</span> (data == NULL || type != ASN_OCTET_STR || tmp_buf_len != 1) {
03703         ERROR_MSG(<span class="stringliteral">"error parsing msgFlags"</span>);
03704         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03705         DEBUGINDENTADD(-4);
03706         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03707     }
03708     msg_flags = *tmp_buf;
03709     <span class="keywordflow">if</span> (msg_flags &amp; SNMP_MSG_FLAG_RPRT_BIT)
03710         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> |= SNMP_MSG_FLAG_RPRT_BIT;
03711     <span class="keywordflow">else</span>
03712         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> &amp;= (~SNMP_MSG_FLAG_RPRT_BIT);
03713 
03714     <span class="comment">/*</span>
03715 <span class="comment">     * msgSecurityModel </span>
03716 <span class="comment">     */</span>
03717     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"msgSecurityModel"</span>);
03718     data = asn_parse_int(data, length, &amp;type, &amp;msg_sec_model,
03719                          <span class="keyword">sizeof</span>(msg_sec_model));
03720     DEBUGINDENTADD(-4);         <span class="comment">/* return from global data indent */</span>
03721     <span class="keywordflow">if</span> (data == NULL || type != ASN_INTEGER ||
03722         msg_sec_model &lt; 1 || msg_sec_model &gt; 0x7fffffff) {
03723         ERROR_MSG(<span class="stringliteral">"error parsing msgSecurityModel"</span>);
03724         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03725         DEBUGINDENTLESS();
03726         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03727     }
03728     sptr = find_sec_mod(msg_sec_model);
03729     <span class="keywordflow">if</span> (!sptr) {
03730         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING, <span class=
"stringliteral">"unknown security model: %ld\n"</span>,
03731                  msg_sec_model);
03732         snmp_increment_statistic(STAT_SNMPUNKNOWNSECURITYMODELS);
03733         DEBUGINDENTLESS();
03734         <span class="keywordflow">return</span> SNMPERR_UNKNOWN_SEC_MODEL;
03735     }
03736     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a> = msg_sec_model;
03737 
03738     <span class="keywordflow">if</span> (msg_flags &amp; SNMP_MSG_FLAG_PRIV_BIT &amp;&amp;
03739         !(msg_flags &amp; SNMP_MSG_FLAG_AUTH_BIT)) {
03740         ERROR_MSG(<span class="stringliteral">"invalid message, illegal msgFlags"</span>);
03741         snmp_increment_statistic(STAT_SNMPINVALIDMSGS);
03742         DEBUGINDENTLESS();
03743         <span class="keywordflow">return</span> SNMPERR_INVALID_MSG;
03744     }
03745     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> = ((msg_flags &amp; SNMP_MSG_FLAG_AUTH_BIT)
03746                           ? ((msg_flags &amp; SNMP_MSG_FLAG_PRIV_BIT)
03747                              ? SNMP_SEC_LEVEL_AUTHPRIV
03748                              : SNMP_SEC_LEVEL_AUTHNOPRIV)
03749                           : SNMP_SEC_LEVEL_NOAUTH);
03750     <span class="comment">/*</span>
03751 <span class="comment">     * end of msgGlobalData </span>
03752 <span class="comment">     */</span>
03753 
03754     <span class="comment">/*</span>
03755 <span class="comment">     * securtityParameters OCTET STRING begins after msgGlobalData </span>
03756 <span class="comment">     */</span>
03757     sec_params = data;
03758     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a> = (u_char *) calloc(1, SNMP_MAX_ENG_SIZE);
03759     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a> = SNMP_MAX_ENG_SIZE;
03760 
03761     <span class="comment">/*</span>
03762 <span class="comment">     * Note: there is no length limit on the msgAuthoritativeEngineID field,</span>
03763 <span class="comment">     * although we would EXPECT it to be limited to 32 (the SnmpEngineID TC</span>
03764 <span class="comment">     * limit).  We'll use double that here to be on the safe side.  </span>
03765 <span class="comment">     */</span>
03766 
03767     pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o29">securityEngineID</a> = (u_char *) calloc(1, SNMP_MAX_ENG_SIZE * 2);
03768     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a> = SNMP_MAX_ENG_SIZE * 2;
03769     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a> = (<span class=
"keywordtype">char</span> *) calloc(1, SNMP_MAX_SEC_NAME_SIZE);
03770     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a> = SNMP_MAX_SEC_NAME_SIZE;
03771 
03772     <span class="keywordflow">if</span> ((pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o31">securityName</a> == NULL) ||
03773         (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a> == NULL) ||
03774         (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a> == NULL)) {
03775         <span class="keywordflow">return</span> SNMPERR_MALLOC;
03776     }
03777 
03778     <span class="keywordflow">if</span> (pdu_buf_len &lt; msg_len
03779         &amp;&amp; pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> == SNMP_SEC_LEVEL_AUTHPRIV) {
03780         <span class="comment">/*</span>
03781 <span class="comment">         * space needed is larger than we have in the default buffer </span>
03782 <span class="comment">         */</span>
03783         mallocbuf = (u_char *) calloc(1, msg_len);
03784         pdu_buf_len = msg_len;
03785         cp = mallocbuf;
03786     } <span class="keywordflow">else</span> {
03787         memset(pdu_buf, 0, pdu_buf_len);
03788         cp = pdu_buf;
03789     }
03790 
03791     DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"SM msgSecurityParameters"</span>);
03792     <span class="keywordflow">if</span> (sptr-&gt;decode) {
03793         <span class="keyword">struct </span>snmp_secmod_incoming_params parms;
03794         parms.msgProcModel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o12">msgParseModel</a>;
03795         parms.maxMsgSize = msg_max_size;
03796         parms.secParams = sec_params;
03797         parms.secModel = msg_sec_model;
03798         parms.secLevel = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a>;
03799         parms.wholeMsg = msg_data;
03800         parms.wholeMsgLen = msg_len;
03801         parms.secEngineID = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>;
03802         parms.secEngineIDLen = &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>;
03803         parms.secName = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o31">securityName</a>;
03804         parms.secNameLen = &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o32">securityNameLen</a>;
03805         parms.scopedPdu = &amp;cp;
03806         parms.scopedPduLen = &amp;pdu_buf_len;
03807         parms.maxSizeResponse = &amp;max_size_response;
03808         parms.secStateRef = &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>;
03809         parms.sess = sess;
03810         parms.pdu = pdu;
03811         parms.msg_flags = msg_flags;
03812         ret_val = (*sptr-&gt;decode) (&amp;parms);
03813     } <span class="keywordflow">else</span> {
03814         DEBUGINDENTLESS();
03815         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING, <span class=
"stringliteral">"security service %ld can't decode packets\n"</span>,
03816                  msg_sec_model);
03817         <span class="keywordflow">return</span> (-1);
03818     }
03819 
03820     <span class="keywordflow">if</span> (ret_val != SNMPERR_SUCCESS) {
03821         DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"ScopedPDU"</span>);
03822         <span class="comment">/*</span>
03823 <span class="comment">         * Parse as much as possible -- though I don't see the point? [jbpn].  </span>
03824 <span class="comment">         */</span>
03825         <span class="keywordflow">if</span> (cp) {
03826             cp = snmpv3_scopedPDU_parse(pdu, cp, &amp;pdu_buf_len);
03827         }
03828         <span class="keywordflow">if</span> (cp) {
03829             DEBUGPRINTPDUTYPE(<span class="stringliteral">"recv"</span>, *cp);
03830             snmp_pdu_parse(pdu, cp, &amp;pdu_buf_len);
03831             DEBUGINDENTADD(-8);
03832         } <span class="keywordflow">else</span> {
03833             DEBUGINDENTADD(-4);
03834         }
03835 
03836         <span class="keywordflow">if</span> (mallocbuf) {
03837             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(mallocbuf);
03838         }
03839         <span class="keywordflow">return</span> ret_val;
03840     }
03841 
03842     <span class="comment">/*</span>
03843 <span class="comment">     * parse plaintext ScopedPDU sequence </span>
03844 <span class="comment">     */</span>
03845     *length = pdu_buf_len;
03846     DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"ScopedPDU"</span>);
03847     data = snmpv3_scopedPDU_parse(pdu, cp, length);
03848     <span class="keywordflow">if</span> (data == NULL) {
03849         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03850         DEBUGINDENTADD(-4);
03851         <span class="keywordflow">if</span> (mallocbuf) {
03852             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(mallocbuf);
03853         }
03854         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03855     }
03856 
03857     <span class="comment">/*</span>
03858 <span class="comment">     * parse the PDU.  </span>
03859 <span class="comment">     */</span>
03860     <span class="keywordflow">if</span> (after_header != NULL) {
03861         *after_header = data;
03862         tmp_buf_len = *length;
03863     }
03864 
03865     DEBUGPRINTPDUTYPE(<span class="stringliteral">"recv"</span>, *data);
03866     ret = snmp_pdu_parse(pdu, data, length);
03867     DEBUGINDENTADD(-8);
03868 
03869     <span class="keywordflow">if</span> (after_header != NULL) {
03870         *length = tmp_buf_len;
03871     }
03872 
03873     <span class="keywordflow">if</span> (ret != SNMPERR_SUCCESS) {
03874         ERROR_MSG(<span class="stringliteral">"error parsing PDU"</span>);
03875         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
03876         <span class="keywordflow">if</span> (mallocbuf) {
03877             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(mallocbuf);
03878         }
03879         <span class="keywordflow">return</span> SNMPERR_ASN_PARSE_ERR;
03880     }
03881 
03882     <span class="keywordflow">if</span> (mallocbuf) {
03883         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(mallocbuf);
03884     }
03885     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03886 }                               <span class="comment">/* end snmpv3_parse() */</span>
03887 
03888 <span class="preprocessor">#define ERROR_STAT_LENGTH 11</span>
03889 
03890 <span class="keywordtype">int</span>
03891 snmpv3_make_report(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, <span class=
"keywordtype">int</span> error)
03892 {
03893 
03894     <span class="keywordtype">long</span>            ltmp;
03895     <span class="keyword">static</span> oid      unknownSecurityLevel[] =
03896         { 1, 3, 6, 1, 6, 3, 15, 1, 1, 1, 0 };
03897     <span class="keyword">static</span> oid      notInTimeWindow[] =
03898         { 1, 3, 6, 1, 6, 3, 15, 1, 1, 2, 0 };
03899     <span class="keyword">static</span> oid      unknownUserName[] =
03900         { 1, 3, 6, 1, 6, 3, 15, 1, 1, 3, 0 };
03901     <span class="keyword">static</span> oid      unknownEngineID[] =
03902         { 1, 3, 6, 1, 6, 3, 15, 1, 1, 4, 0 };
03903     <span class="keyword">static</span> oid      wrongDigest[] = { 1, 3, 6, 1, 6, 3, 15, 1, 1, 5, 0 };
03904     <span class="keyword">static</span> oid      decryptionError[] =
03905         { 1, 3, 6, 1, 6, 3, 15, 1, 1, 6, 0 };
03906     oid            *err_var;
03907     <span class="keywordtype">int</span>             err_var_len;
03908     <span class="keywordtype">int</span>             stat_ind;
03909     <span class="keyword">struct </span>snmp_secmod_def *sptr;
03910 
03911     <span class="keywordflow">switch</span> (error) {
03912     <span class="keywordflow">case</span> SNMPERR_USM_UNKNOWNENGINEID:
03913         stat_ind = STAT_USMSTATSUNKNOWNENGINEIDS;
03914         err_var = unknownEngineID;
03915         err_var_len = ERROR_STAT_LENGTH;
03916         <span class="keywordflow">break</span>;
03917     <span class="keywordflow">case</span> SNMPERR_USM_UNKNOWNSECURITYNAME:
03918         stat_ind = STAT_USMSTATSUNKNOWNUSERNAMES;
03919         err_var = unknownUserName;
03920         err_var_len = ERROR_STAT_LENGTH;
03921         <span class="keywordflow">break</span>;
03922     <span class="keywordflow">case</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL:
03923         stat_ind = STAT_USMSTATSUNSUPPORTEDSECLEVELS;
03924         err_var = unknownSecurityLevel;
03925         err_var_len = ERROR_STAT_LENGTH;
03926         <span class="keywordflow">break</span>;
03927     <span class="keywordflow">case</span> SNMPERR_USM_AUTHENTICATIONFAILURE:
03928         stat_ind = STAT_USMSTATSWRONGDIGESTS;
03929         err_var = wrongDigest;
03930         err_var_len = ERROR_STAT_LENGTH;
03931         <span class="keywordflow">break</span>;
03932     <span class="keywordflow">case</span> SNMPERR_USM_NOTINTIMEWINDOW:
03933         stat_ind = STAT_USMSTATSNOTINTIMEWINDOWS;
03934         err_var = notInTimeWindow;
03935         err_var_len = ERROR_STAT_LENGTH;
03936         <span class="keywordflow">break</span>;
03937     <span class="keywordflow">case</span> SNMPERR_USM_DECRYPTIONERROR:
03938         stat_ind = STAT_USMSTATSDECRYPTIONERRORS;
03939         err_var = decryptionError;
03940         err_var_len = ERROR_STAT_LENGTH;
03941         <span class="keywordflow">break</span>;
03942     <span class="keywordflow">default</span>:
03943         <span class="keywordflow">return</span> SNMPERR_GENERR;
03944     }
03945 
03946     snmp_free_varbind(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>);  <span class=
"comment">/* free the current varbind */</span>
03947 
03948     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = NULL;
03949     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o29">securityEngineID</a>);
03950     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a> =
03951         snmpv3_generate_engineID(&amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>);
03952     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o25">contextEngineID</a>);
03953     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o25">contextEngineID</a> =
03954         snmpv3_generate_engineID(&amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>);
03955     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = SNMP_MSG_REPORT;
03956     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o6">errstat</a> = 0;
03957     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o7">errindex</a> = 0;
03958     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o27">contextName</a>);
03959     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a> = strdup(<span class=
"stringliteral">""</span>);
03960     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a> = strlen(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o27">contextName</a>);
03961 
03962     <span class="comment">/*</span>
03963 <span class="comment">     * reports shouldn't cache previous data. </span>
03964 <span class="comment">     */</span>
03965     <span class="comment">/*</span>
03966 <span class="comment">     * FIX - yes they should but USM needs to follow new EoP to determine</span>
03967 <span class="comment">     * which cached values to use </span>
03968 <span class="comment">     */</span>
03969     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>) {
03970         sptr = find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
03971         <span class="keywordflow">if</span> (sptr) {
03972             <span class="keywordflow">if</span> (sptr-&gt;pdu_free_state_ref) {
03973                 (*sptr-&gt;pdu_free_state_ref) (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o35">securityStateRef</a>);
03974             } <span class="keywordflow">else</span> {
03975                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
03976                          <span class="stringliteral">"Security Model %d can't free state references\n"</span>,
03977                          pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
03978             }
03979         } <span class="keywordflow">else</span> {
03980             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
03981                      <span class="stringliteral">"Can't find security model to free ptr: %d\n"</span>,
03982                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
03983         }
03984         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a> = NULL;
03985     }
03986 
03987     <span class="keywordflow">if</span> (error == SNMPERR_USM_NOTINTIMEWINDOW) {
03988         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> = SNMP_SEC_LEVEL_AUTHNOPRIV;
03989     } <span class="keywordflow">else</span> {
03990         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> = SNMP_SEC_LEVEL_NOAUTH;
03991     }
03992 
03993     <span class="comment">/*</span>
03994 <span class="comment">     * find the appropriate error counter  </span>
03995 <span class="comment">     */</span>
03996     ltmp = snmp_get_statistic(stat_ind);
03997 
03998     <span class="comment">/*</span>
03999 <span class="comment">     * return the appropriate error counter  </span>
04000 <span class="comment">     */</span>
04001     snmp_pdu_add_variable(pdu, err_var, err_var_len,
04002                           ASN_COUNTER, (u_char *) &amp; ltmp, <span class="keyword">sizeof</span>(ltmp));
04003 
04004     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
04005 }                               <span class="comment">/* end snmpv3_make_report() */</span>
04006 
04007 
04008 <span class="keywordtype">int</span>
04009 snmpv3_get_report_type(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
04010 {
04011     <span class="keyword">static</span> oid      snmpMPDStats[] = { 1, 3, 6, 1, 6, 3, 11, 2, 1 };
04012     <span class="keyword">static</span> oid      usmStats[] = { 1, 3, 6, 1, 6, 3, 15, 1, 1 };
04013     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vp;
04014     <span class="keywordtype">int</span>             rpt_type = SNMPERR_UNKNOWN_REPORT;
04015 
04016     <span class="keywordflow">if</span> (pdu == NULL || pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a> == NULL)
04017         <span class="keywordflow">return</span> rpt_type;
04018     vp = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>;
04019     <span class="keywordflow">if</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> == REPORT_STATS_LEN + 2) {
04020         <span class="keywordflow">if</span> (memcmp(snmpMPDStats, vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, REPORT_STATS_LEN * <span class="keyword">sizeof</span>(oid))
04021             == 0) {
04022             <span class="keywordflow">switch</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>[REPORT_STATS_LEN]) {
04023             <span class="keywordflow">case</span> REPORT_snmpUnknownSecurityModels_NUM:
04024                 rpt_type = SNMPERR_UNKNOWN_SEC_MODEL;
04025                 <span class="keywordflow">break</span>;
04026             <span class="keywordflow">case</span> REPORT_snmpInvalidMsgs_NUM:
04027                 rpt_type = SNMPERR_INVALID_MSG;
04028                 <span class="keywordflow">break</span>;
04029             }
04030         } <span class="keywordflow">else</span>
04031             <span class="keywordflow">if</span> (memcmp(usmStats, vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, REPORT_STATS_LEN * <span class="keyword">sizeof</span>(oid))
04032                 == 0) {
04033             <span class="keywordflow">switch</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>[REPORT_STATS_LEN]) {
04034             <span class="keywordflow">case</span> REPORT_usmStatsUnsupportedSecLevels_NUM:
04035                 rpt_type = SNMPERR_UNSUPPORTED_SEC_LEVEL;
04036                 <span class="keywordflow">break</span>;
04037             <span class="keywordflow">case</span> REPORT_usmStatsNotInTimeWindows_NUM:
04038                 rpt_type = SNMPERR_NOT_IN_TIME_WINDOW;
04039                 <span class="keywordflow">break</span>;
04040             <span class="keywordflow">case</span> REPORT_usmStatsUnknownUserNames_NUM:
04041                 rpt_type = SNMPERR_UNKNOWN_USER_NAME;
04042                 <span class="keywordflow">break</span>;
04043             <span class="keywordflow">case</span> REPORT_usmStatsUnknownEngineIDs_NUM:
04044                 rpt_type = SNMPERR_UNKNOWN_ENG_ID;
04045                 <span class="keywordflow">break</span>;
04046             <span class="keywordflow">case</span> REPORT_usmStatsWrongDigests_NUM:
04047                 rpt_type = SNMPERR_AUTHENTICATION_FAILURE;
04048                 <span class="keywordflow">break</span>;
04049             <span class="keywordflow">case</span> REPORT_usmStatsDecryptionErrors_NUM:
04050                 rpt_type = SNMPERR_DECRYPTION_ERR;
04051                 <span class="keywordflow">break</span>;
04052             }
04053         }
04054     }
04055     DEBUGMSGTL((<span class="stringliteral">"report"</span>, <span class=
"stringliteral">"Report type: %d\n"</span>, rpt_type));
04056     <span class="keywordflow">return</span> rpt_type;
04057 }
04058 
04059 <span class="comment">/*</span>
04060 <span class="comment"> * Parses the packet received on the input session, and places the data into</span>
04061 <span class="comment"> * the input pdu.  length is the length of the input packet.</span>
04062 <span class="comment"> * If any errors are encountered, -1 or USM error is returned.</span>
04063 <span class="comment"> * Otherwise, a 0 is returned.</span>
04064 <span class="comment"> */</span>
04065 <span class="keyword">static</span> <span class="keywordtype">int</span>
04066 _snmp_parse(<span class="keywordtype">void</span> *sessp,
04067             netsnmp_session * session,
04068             <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, u_char * data, size_t length)
04069 {
04070 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
04071     u_char          community[COMMUNITY_MAX_LEN];
04072     size_t          community_length = COMMUNITY_MAX_LEN;
04073 <span class="preprocessor">#endif</span>
04074     <span class="keywordtype">int</span>             result = -1;
04075 
04076     session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
04077     session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
04078 
04079     <span class="comment">/*</span>
04080 <span class="comment">     * Ensure all incoming PDUs have a unique means of identification </span>
04081 <span class="comment">     * (This is not restricted to AgentX handling,</span>
04082 <span class="comment">     * though that is where the need becomes visible)   </span>
04083 <span class="comment">     */</span>
04084     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o4">transid</a> = snmp_get_next_transid();
04085 
04086     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a> != SNMP_DEFAULT_VERSION) {
04087         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a>;
04088     } <span class="keywordflow">else</span> {
04089         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a> = snmp_parse_version(data, length);
04090     }
04091 
04092     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>) {
04093 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
04094     <span class="keywordflow">case</span> SNMP_VERSION_1:
04095 <span class="preprocessor">#endif</span>
04096 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
04097     <span class="keywordflow">case</span> SNMP_VERSION_2c:
04098 <span class="preprocessor">#endif</span>
04099 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
04100         DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>, <span class=
"stringliteral">"Parsing SNMPv%d message...\n"</span>,
04101                     (1 + pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>)));
04102 
04103         <span class="comment">/*</span>
04104 <span class="comment">         * authenticates message and returns length if valid </span>
04105 <span class="comment">         */</span>
04106 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
04107         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_1) {
04108             DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"SNMPv1 message\n"</span>);
04109         } <span class="keywordflow">else</span> {
04110 <span class="preprocessor">#endif</span>
04111             DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"SNMPv2c message\n"</span>);
04112 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
04113         }
04114 <span class="preprocessor">#endif</span>
04115         data = snmp_comstr_parse(data, &amp;length,
04116                                  community, &amp;community_length,
04117                                  &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>);
04118         <span class="keywordflow">if</span> (data == NULL)
04119             <span class="keywordflow">return</span> -1;
04120 
04121         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> != session-&gt;<a class="code" href="structsnmp__session.html#o0">version</a> &amp;&amp;
04122             session-&gt;<a class="code" href="structsnmp__session.html#o0">version</a> != SNMP_DEFAULT_VERSION) {
04123             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
04124             <span class="keywordflow">return</span> -1;
04125         }
04126 
04127         <span class="comment">/*</span>
04128 <span class="comment">         * maybe get the community string. </span>
04129 <span class="comment">         */</span>
04130         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o11">securityLevel</a> = SNMP_SEC_LEVEL_NOAUTH;
04131         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a> = 
04132 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
04133             (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_1) ? SNMP_SEC_MODEL_SNMPv1 : 
04134 <span class="preprocessor">#endif</span>
04135                                                SNMP_SEC_MODEL_SNMPv2c;
04136         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a>);
04137         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a> = 0;
04138         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a> = (u_char *) 0;
04139         <span class="keywordflow">if</span> (community_length) {
04140             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a> = community_length;
04141             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a> = (u_char *) malloc(community_length);
04142             <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a> == NULL) {
04143                 session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
04144                 <span class="keywordflow">return</span> -1;
04145             }
04146             memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a>, community, community_length);
04147         }
04148         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o10">authenticator</a>) {
04149             data = session-&gt;<a class="code" href="structsnmp__session.html#o10">authenticator</a>(data, &amp;length,
04150                                           community, community_length);
04151             <span class="keywordflow">if</span> (data == NULL) {
04152                 session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_AUTHENTICATION_FAILURE;
04153                 <span class="keywordflow">return</span> -1;
04154             }
04155         }
04156 
04157         DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"PDU"</span>);
04158         result = snmp_pdu_parse(pdu, data, &amp;length);
04159         <span class="keywordflow">if</span> (result &lt; 0) {
04160             <span class="comment">/*</span>
04161 <span class="comment">             * This indicates a parse error.  </span>
04162 <span class="comment">             */</span>
04163             snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
04164         }
04165         DEBUGINDENTADD(-6);
04166         <span class="keywordflow">break</span>;
04167 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
04168 
04169     <span class="keywordflow">case</span> SNMP_VERSION_3:
04170         result = snmpv3_parse(pdu, data, &amp;length, NULL, session);
04171         DEBUGMSGTL((<span class="stringliteral">"snmp_parse"</span>,
04172                     <span class="stringliteral">"Parsed SNMPv3 message (secName:%s, secLevel:%s): %s\n"</span>,
04173                     pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o31">securityName</a>, secLevelName[pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o11">securityLevel</a>],
04174                     snmp_api_errstring(result)));
04175 
04176         <span class="keywordflow">if</span> (result) {
04177             <span class="keyword">struct </span>snmp_secmod_def *secmod =
04178                 find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
04179             <span class="keywordflow">if</span> (!sessp) {
04180                 session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = result;
04181             } <span class="keywordflow">else</span> {
04182                 <span class="comment">/*</span>
04183 <span class="comment">                 * Call the security model to special handle any errors</span>
04184 <span class="comment">                 */</span>
04185 
04186                 <span class="keywordflow">if</span> (secmod &amp;&amp; secmod-&gt;handle_report) {
04187                     <span class="keyword">struct </span>session_list *slp = (<span class=
"keyword">struct </span>session_list *) sessp;
04188                     (*secmod-&gt;handle_report)(sessp, slp-&gt;transport, session,
04189                                              result, pdu);
04190                 }
04191             }
04192             <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o35">securityStateRef</a> != NULL) {
04193                 <span class="keywordflow">if</span> (secmod &amp;&amp; secmod-&gt;pdu_free_state_ref) {
04194                     secmod-&gt;pdu_free_state_ref(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o35">securityStateRef</a>);
04195                     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a> = NULL;
04196                 }
04197             }
04198         }
04199         <span class="keywordflow">break</span>;
04200     <span class="keywordflow">case</span> SNMPERR_BAD_VERSION:
04201         ERROR_MSG(<span class="stringliteral">"error parsing snmp message version"</span>);
04202         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
04203         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
04204         <span class="keywordflow">break</span>;
04205     <span class="keywordflow">case</span> SNMP_VERSION_sec:
04206     <span class="keywordflow">case</span> SNMP_VERSION_2u:
04207     <span class="keywordflow">case</span> SNMP_VERSION_2star:
04208     <span class="keywordflow">case</span> SNMP_VERSION_2p:
04209     <span class="keywordflow">default</span>:
04210         ERROR_MSG(<span class="stringliteral">"unsupported snmp message version"</span>);
04211         snmp_increment_statistic(STAT_SNMPINBADVERSIONS);
04212 
04213         <span class="comment">/*</span>
04214 <span class="comment">         * need better way to determine OS independent</span>
04215 <span class="comment">         * INT32_MAX value, for now hardcode</span>
04216 <span class="comment">         */</span>
04217         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> &lt; 0 || pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> &gt; 2147483647) {
04218             snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
04219         }
04220         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
04221         <span class="keywordflow">break</span>;
04222     }
04223 
04224     <span class="keywordflow">return</span> result;
04225 }
04226 
04227 <span class="keyword">static</span> <span class="keywordtype">int</span>
04228 snmp_parse(<span class="keywordtype">void</span> *sessp,
04229            netsnmp_session * pss,
04230            <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, u_char * data, size_t length)
04231 {
04232     <span class="keywordtype">int</span>             rc;
04233 
04234     rc = _snmp_parse(sessp, pss, pdu, data, length);
04235     <span class="keywordflow">if</span> (rc) {
04236         <span class="keywordflow">if</span> (!pss-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a>) {
04237             pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_PARSE;
04238         }
04239         SET_SNMP_ERROR(pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
04240     }
04241 
04242     <span class="keywordflow">return</span> rc;
04243 }
04244 
04245 <span class="keywordtype">int</span>
04246 snmp_pdu_parse(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, u_char * data, size_t * length)
04247 {
04248     u_char          type;
04249     u_char          msg_type;
04250     u_char         *var_val;
04251     <span class="keywordtype">int</span>             badtype = 0;
04252     size_t          len;
04253     size_t          four;
04254     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vp = NULL;
04255     oid             objid[MAX_OID_LEN];
04256 
04257     <span class="comment">/*</span>
04258 <span class="comment">     * Get the PDU type </span>
04259 <span class="comment">     */</span>
04260     data = asn_parse_header(data, length, &amp;msg_type);
04261     <span class="keywordflow">if</span> (data == NULL)
04262         <span class="keywordflow">return</span> -1;
04263     DEBUGMSGTL((<span class="stringliteral">"dumpv_recv"</span>,<span class=
"stringliteral">"    Command %s\n"</span>, snmp_pdu_type(msg_type)));
04264     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = msg_type;
04265     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> &amp;= (~UCD_MSG_FLAG_RESPONSE_PDU);
04266 
04267     <span class="comment">/*</span>
04268 <span class="comment">     * get the fields in the PDU preceeding the variable-bindings sequence </span>
04269 <span class="comment">     */</span>
04270     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>) {
04271     <span class="keywordflow">case</span> SNMP_MSG_TRAP:
04272         <span class="comment">/*</span>
04273 <span class="comment">         * enterprise </span>
04274 <span class="comment">         */</span>
04275         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> = MAX_OID_LEN;
04276         data = asn_parse_objid(data, length, &amp;type, objid,
04277                                &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a>);
04278         <span class="keywordflow">if</span> (data == NULL)
04279             <span class="keywordflow">return</span> -1;
04280         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a> =
04281             (oid *) malloc(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> * <span class=
"keyword">sizeof</span>(oid));
04282         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o20">enterprise</a> == NULL) {
04283             <span class="keywordflow">return</span> -1;
04284         }
04285         memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>, objid,
04286                 pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> * <span class=
"keyword">sizeof</span>(oid));
04287 
04288         <span class="comment">/*</span>
04289 <span class="comment">         * agent-addr </span>
04290 <span class="comment">         */</span>
04291         four = 4;
04292         data = asn_parse_string(data, length, &amp;type,
04293                                 (u_char *) pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o24">agent_addr</a>, &amp;four);
04294         <span class="keywordflow">if</span> (data == NULL)
04295             <span class="keywordflow">return</span> -1;
04296 
04297         <span class="comment">/*</span>
04298 <span class="comment">         * generic trap </span>
04299 <span class="comment">         */</span>
04300         data = asn_parse_int(data, length, &amp;type, (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o22">trap_type</a>,
04301                              <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a>));
04302         <span class="keywordflow">if</span> (data == NULL)
04303             <span class="keywordflow">return</span> -1;
04304         <span class="comment">/*</span>
04305 <span class="comment">         * specific trap </span>
04306 <span class="comment">         */</span>
04307         data =
04308             asn_parse_int(data, length, &amp;type,
04309                           (<span class="keywordtype">long</span> *) &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>,
04310                           <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>));
04311         <span class="keywordflow">if</span> (data == NULL)
04312             <span class="keywordflow">return</span> -1;
04313 
04314         <span class="comment">/*</span>
04315 <span class="comment">         * timestamp  </span>
04316 <span class="comment">         */</span>
04317         data = asn_parse_unsigned_int(data, length, &amp;type, &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a>,
04318                                       <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a>));
04319         <span class="keywordflow">if</span> (data == NULL)
04320             <span class="keywordflow">return</span> -1;
04321 
04322         <span class="keywordflow">break</span>;
04323 
04324     <span class="keywordflow">case</span> SNMP_MSG_RESPONSE:
04325     <span class="keywordflow">case</span> SNMP_MSG_REPORT:
04326         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> |= UCD_MSG_FLAG_RESPONSE_PDU;
04327         <span class="comment">/*</span>
04328 <span class="comment">         * fallthrough </span>
04329 <span class="comment">         */</span>
04330 
04331     <span class="keywordflow">case</span> SNMP_MSG_GET:
04332     <span class="keywordflow">case</span> SNMP_MSG_GETNEXT:
04333     <span class="keywordflow">case</span> SNMP_MSG_GETBULK:
04334     <span class="keywordflow">case</span> SNMP_MSG_TRAP2:
04335     <span class="keywordflow">case</span> SNMP_MSG_INFORM:
04336     <span class="keywordflow">case</span> SNMP_MSG_SET:
04337         <span class="comment">/*</span>
04338 <span class="comment">         * PDU is not an SNMPv1 TRAP </span>
04339 <span class="comment">         */</span>
04340 
04341         <span class="comment">/*</span>
04342 <span class="comment">         * request id </span>
04343 <span class="comment">         */</span>
04344         DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"request_id"</span>);
04345         data = asn_parse_int(data, length, &amp;type, &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a>,
04346                              <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a>));
04347         DEBUGINDENTLESS();
04348         <span class="keywordflow">if</span> (data == NULL) {
04349             <span class="keywordflow">return</span> -1;
04350         }
04351 
04352         <span class="comment">/*</span>
04353 <span class="comment">         * error status (getbulk non-repeaters) </span>
04354 <span class="comment">         */</span>
04355         DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"error status"</span>);
04356         data = asn_parse_int(data, length, &amp;type, &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o6">errstat</a>,
04357                              <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o6">errstat</a>));
04358         DEBUGINDENTLESS();
04359         <span class="keywordflow">if</span> (data == NULL) {
04360             <span class="keywordflow">return</span> -1;
04361         }
04362 
04363         <span class="comment">/*</span>
04364 <span class="comment">         * error index (getbulk max-repetitions) </span>
04365 <span class="comment">         */</span>
04366         DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"error index"</span>);
04367         data = asn_parse_int(data, length, &amp;type, &amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a>,
04368                              <span class="keyword">sizeof</span>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o7">errindex</a>));
04369         DEBUGINDENTLESS();
04370         <span class="keywordflow">if</span> (data == NULL) {
04371             <span class="keywordflow">return</span> -1;
04372         }
04373         <span class="keywordflow">break</span>;
04374 
04375     <span class="keywordflow">default</span>:
04376         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Bad PDU type received: 0x%.2x\n"</span>, pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>);
04377         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
04378         <span class="keywordflow">return</span> -1;
04379     }
04380 
04381     <span class="comment">/*</span>
04382 <span class="comment">     * get header for variable-bindings sequence </span>
04383 <span class="comment">     */</span>
04384     DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"VarBindList"</span>);
04385     data = asn_parse_sequence(data, length, &amp;type,
04386                               (ASN_SEQUENCE | ASN_CONSTRUCTOR),
04387                               <span class="stringliteral">"varbinds"</span>);
04388     <span class="keywordflow">if</span> (data == NULL)
04389         <span class="keywordflow">return</span> -1;
04390 
04391     <span class="comment">/*</span>
04392 <span class="comment">     * get each varBind sequence </span>
04393 <span class="comment">     */</span>
04394     <span class="keywordflow">while</span> ((int) *length &gt; 0) {
04395         <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vptemp;
04396         vptemp = (<a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *) malloc(<span class=
"keyword">sizeof</span>(*vptemp));
04397         <span class="keywordflow">if</span> (0 == vptemp) {
04398             <span class="keywordflow">return</span> -1;
04399         }
04400         <span class="keywordflow">if</span> (0 == vp) {
04401             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = vptemp;
04402         } <span class="keywordflow">else</span> {
04403             vp-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a> = vptemp;
04404         }
04405         vp = vptemp;
04406 
04407         vp-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a> = NULL;
04408         vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string = NULL;
04409         vp-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = MAX_OID_LEN;
04410         vp-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = 0;
04411         vp-&gt;<a class="code" href="structvariable__list.html#o10">index</a> = 0;
04412         vp-&gt;<a class="code" href="structvariable__list.html#o8">data</a> = 0;
04413         vp-&gt;<a class="code" href="structvariable__list.html#o9">dataFreeHook</a> = 0;
04414         DEBUGDUMPSECTION(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"VarBind"</span>);
04415         data = snmp_parse_var_op(data, objid, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a>, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
04416                                  &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>, &amp;var_val, length);
04417         <span class="keywordflow">if</span> (data == NULL)
04418             <span class="keywordflow">return</span> -1;
04419         <span class="keywordflow">if</span> (snmp_set_var_objid(vp, objid, vp-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a>))
04420             <span class="keywordflow">return</span> -1;
04421 
04422         len = MAX_PACKET_LENGTH;
04423         DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"Value"</span>);
04424         <span class="keywordflow">switch</span> ((short) vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>) {
04425         <span class="keywordflow">case</span> ASN_INTEGER:
04426             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.integer = (<span class=
"keywordtype">long</span> *) vp-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>;
04427             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(long);
04428             asn_parse_int(var_val, &amp;len, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
04429                           (<span class="keywordtype">long</span> *) vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer,
04430                           <span class="keyword">sizeof</span>(*vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer));
04431             <span class="keywordflow">break</span>;
04432         <span class="keywordflow">case</span> ASN_COUNTER:
04433         <span class="keywordflow">case</span> ASN_GAUGE:
04434         <span class="keywordflow">case</span> ASN_TIMETICKS:
04435         <span class="keywordflow">case</span> ASN_UINTEGER:
04436             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.integer = (<span class=
"keywordtype">long</span> *) vp-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>;
04437             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(u_long);
04438             asn_parse_unsigned_int(var_val, &amp;len, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>,
04439                                    (u_long *) vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.integer,
04440                                    vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
04441             <span class="keywordflow">break</span>;
04442 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
04443         <span class="keywordflow">case</span> ASN_OPAQUE_COUNTER64:
04444         <span class="keywordflow">case</span> ASN_OPAQUE_U64:
04445 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
04446         <span class="keywordflow">case</span> ASN_COUNTER64:
04447             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.counter64 = (<span class=
"keyword">struct </span>counter64 *) vp-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>;
04448             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(<span class="keyword">struct </span>counter64);
04449             asn_parse_unsigned_int64(var_val, &amp;len, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>,
04450                                      (<span class="keyword">struct</span> counter64 *) vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.
04451                                      counter64, vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
04452             <span class="keywordflow">break</span>;
04453 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
04454         <span class="keywordflow">case</span> ASN_OPAQUE_FLOAT:
04455             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.floatVal = (<span class=
"keywordtype">float</span> *) vp-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>;
04456             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(float);
04457             asn_parse_float(var_val, &amp;len, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
04458                             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.floatVal, vp-&gt;<a class=
"code" href="structvariable__list.html#o5">val_len</a>);
04459             <span class="keywordflow">break</span>;
04460         <span class="keywordflow">case</span> ASN_OPAQUE_DOUBLE:
04461             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.doubleVal = (<span class=
"keywordtype">double</span> *) vp-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>;
04462             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(double);
04463             asn_parse_double(var_val, &amp;len, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>,
04464                              vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.doubleVal, vp-&gt;<a class=
"code" href="structvariable__list.html#o5">val_len</a>);
04465             <span class="keywordflow">break</span>;
04466         <span class="keywordflow">case</span> ASN_OPAQUE_I64:
04467             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.counter64 = (<span class=
"keyword">struct </span>counter64 *) vp-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>;
04468             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = <span class=
"keyword">sizeof</span>(<span class="keyword">struct </span>counter64);
04469             asn_parse_signed_int64(var_val, &amp;len, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>,
04470                                    (<span class="keyword">struct</span> counter64 *) vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.counter64,
04471                                    <span class="keyword">sizeof</span>(*vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.counter64));
04472 
04473             <span class="keywordflow">break</span>;
04474 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
04475         <span class="keywordflow">case</span> ASN_OCTET_STR:
04476         <span class="keywordflow">case</span> ASN_IPADDRESS:
04477         <span class="keywordflow">case</span> ASN_OPAQUE:
04478         <span class="keywordflow">case</span> ASN_NSAP:
04479             <span class="keywordflow">if</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> &lt; <span class="keyword">sizeof</span>(vp-&gt;<a class="code" href=
"structvariable__list.html#o7">buf</a>)) {
04480                 vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string = (u_char *) vp-&gt;<a class=
"code" href="structvariable__list.html#o7">buf</a>;
04481             } <span class="keywordflow">else</span> {
04482                 vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string = (u_char *) malloc(vp-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>);
04483             }
04484             <span class="keywordflow">if</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string == NULL) {
04485                 <span class="keywordflow">return</span> -1;
04486             }
04487             asn_parse_string(var_val, &amp;len, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>, vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string,
04488                              &amp;vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
04489             <span class="keywordflow">break</span>;
04490         <span class="keywordflow">case</span> ASN_OBJECT_ID:
04491             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = MAX_OID_LEN;
04492             asn_parse_objid(var_val, &amp;len, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>, objid, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
04493             vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> *= <span class=
"keyword">sizeof</span>(oid);
04494             vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid = (oid *) malloc(vp-&gt;<a class=
"code" href="structvariable__list.html#o5">val_len</a>);
04495             <span class="keywordflow">if</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid == NULL) {
04496                 <span class="keywordflow">return</span> -1;
04497             }
04498             memmove(vp-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid, objid, vp-&gt;<a class="code"
href="structvariable__list.html#o5">val_len</a>);
04499             <span class="keywordflow">break</span>;
04500         <span class="keywordflow">case</span> SNMP_NOSUCHOBJECT:
04501         <span class="keywordflow">case</span> SNMP_NOSUCHINSTANCE:
04502         <span class="keywordflow">case</span> SNMP_ENDOFMIBVIEW:
04503         <span class="keywordflow">case</span> ASN_NULL:
04504             <span class="keywordflow">break</span>;
04505         <span class="keywordflow">case</span> ASN_BIT_STR:
04506             vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.bitstring = (u_char *) malloc(vp-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>);
04507             <span class="keywordflow">if</span> (vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.bitstring == NULL) {
04508                 <span class="keywordflow">return</span> -1;
04509             }
04510             asn_parse_bitstring(var_val, &amp;len, &amp;vp-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>,
04511                                 vp-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.bitstring, &amp;vp-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
04512             <span class="keywordflow">break</span>;
04513         <span class="keywordflow">default</span>:
04514             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"bad type returned (%x)\n"</span>, vp-&gt;<a class="code" href="structvariable__list.html#o3">type</a>);
04515             badtype = -1;
04516             <span class="keywordflow">break</span>;
04517         }
04518         DEBUGINDENTADD(-4);
04519     }
04520     <span class="keywordflow">return</span> badtype;
04521 }
04522 
04523 <span class="comment">/*</span>
04524 <span class="comment"> * snmp v3 utility function to parse into the scopedPdu. stores contextName</span>
04525 <span class="comment"> * and contextEngineID in pdu struct. Also stores pdu-&gt;command (handy for </span>
04526 <span class="comment"> * Report generation).</span>
04527 <span class="comment"> * </span>
04528 <span class="comment"> * returns pointer to begining of PDU or NULL on error.</span>
04529 <span class="comment"> */</span>
04530 u_char         *
04531 snmpv3_scopedPDU_parse(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, u_char * cp, size_t * length)
04532 {
04533     u_char          tmp_buf[SNMP_MAX_MSG_SIZE];
04534     size_t          tmp_buf_len;
04535     u_char          type;
04536     size_t          asn_len;
04537     u_char         *data;
04538 
04539     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = 0;           <span class=
"comment">/* initialize so we know if it got parsed */</span>
04540     asn_len = *length;
04541     data = asn_parse_sequence(cp, &amp;asn_len, &amp;type,
04542                               (ASN_SEQUENCE | ASN_CONSTRUCTOR),
04543                               <span class="stringliteral">"plaintext scopedPDU"</span>);
04544     <span class="keywordflow">if</span> (data == NULL) {
04545         <span class="keywordflow">return</span> NULL;
04546     }
04547     *length -= data - cp;
04548 
04549     <span class="comment">/*</span>
04550 <span class="comment">     * contextEngineID from scopedPdu  </span>
04551 <span class="comment">     */</span>
04552     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"contextEngineID"</span>);
04553     data = asn_parse_string(data, length, &amp;type, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o25">contextEngineID</a>,
04554                             &amp;pdu-&gt;<a class="code" href="structsnmp__pdu.html#o26">contextEngineIDLen</a>);
04555     DEBUGINDENTLESS();
04556     <span class="keywordflow">if</span> (data == NULL) {
04557         ERROR_MSG(<span class="stringliteral">"error parsing contextEngineID from scopedPdu"</span>);
04558         <span class="keywordflow">return</span> NULL;
04559     }
04560 
04561     <span class="comment">/*</span>
04562 <span class="comment">     * check that it agrees with engineID returned from USM above</span>
04563 <span class="comment">     * * only a warning because this could be legal if we are a proxy</span>
04564 <span class="comment">     */</span>
04565     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o30">securityEngineIDLen</a> != pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o26">contextEngineIDLen</a> ||
04566         memcmp(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o25">contextEngineID</a>,
04567                pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>) != 0) {
04568         DEBUGMSGTL((<span class="stringliteral">"scopedPDU_parse"</span>,
04569                     <span class="stringliteral">"inconsistent engineID information in message\n"</span>));
04570     }
04571 
04572     <span class="comment">/*</span>
04573 <span class="comment">     * parse contextName from scopedPdu</span>
04574 <span class="comment">     */</span>
04575     tmp_buf_len = SNMP_MAX_CONTEXT_SIZE;
04576     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"contextName"</span>);
04577     data = asn_parse_string(data, length, &amp;type, tmp_buf, &amp;tmp_buf_len);
04578     DEBUGINDENTLESS();
04579     <span class="keywordflow">if</span> (data == NULL) {
04580         ERROR_MSG(<span class="stringliteral">"error parsing contextName from scopedPdu"</span>);
04581         <span class="keywordflow">return</span> NULL;
04582     }
04583 
04584     <span class="keywordflow">if</span> (tmp_buf_len) {
04585         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a> = (<span class=
"keywordtype">char</span> *) malloc(tmp_buf_len);
04586         memmove(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a>, tmp_buf, tmp_buf_len);
04587         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a> = tmp_buf_len;
04588     } <span class="keywordflow">else</span> {
04589         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a> = strdup(<span class=
"stringliteral">""</span>);
04590         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o28">contextNameLen</a> = 0;
04591     }
04592     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o27">contextName</a> == NULL) {
04593         ERROR_MSG(<span class="stringliteral">"error copying contextName from scopedPdu"</span>);
04594         <span class="keywordflow">return</span> NULL;
04595     }
04596 
04597     <span class="comment">/*</span>
04598 <span class="comment">     * Get the PDU type </span>
04599 <span class="comment">     */</span>
04600     asn_len = *length;
04601     cp = asn_parse_header(data, &amp;asn_len, &amp;type);
04602     <span class="keywordflow">if</span> (cp == NULL)
04603         <span class="keywordflow">return</span> NULL;
04604 
04605     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = type;
04606 
04607     <span class="keywordflow">return</span> data;
04608 }
04609 
04610 <span class="comment">/*</span>
04611 <span class="comment"> * These functions send PDUs using an active session:</span>
04612 <span class="comment"> * snmp_send             - traditional API, no callback</span>
04613 <span class="comment"> * snmp_async_send       - traditional API, with callback</span>
04614 <span class="comment"> * snmp_sess_send        - single session API, no callback</span>
04615 <span class="comment"> * snmp_sess_async_send  - single session API, with callback</span>
04616 <span class="comment"> *</span>
04617 <span class="comment"> * Call snmp_build to create a serialized packet (the pdu).</span>
04618 <span class="comment"> * If necessary, set some of the pdu data from the</span>
04619 <span class="comment"> * session defaults.</span>
04620 <span class="comment"> * If there is an expected response for this PDU,</span>
04621 <span class="comment"> * queue a corresponding request on the list</span>
04622 <span class="comment"> * of outstanding requests for this session,</span>
04623 <span class="comment"> * and store the callback vectors in the request.</span>
04624 <span class="comment"> *</span>
04625 <span class="comment"> * Send the pdu to the target identified by this session.</span>
04626 <span class="comment"> * Return on success:</span>
04627 <span class="comment"> *   The request id of the pdu is returned, and the pdu is freed.</span>
04628 <span class="comment"> * Return on failure:</span>
04629 <span class="comment"> *   Zero (0) is returned.</span>
04630 <span class="comment"> *   The caller must call snmp_free_pdu if 0 is returned.</span>
04631 <span class="comment"> */</span>
04632 <span class="keywordtype">int</span>
04633 snmp_send(netsnmp_session * session, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
04634 {
04635     <span class="keywordflow">return</span> snmp_async_send(session, pdu, NULL, NULL);
04636 }
04637 
04638 <span class="keywordtype">int</span>
04639 snmp_sess_send(<span class="keywordtype">void</span> *sessp, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
04640 {
04641     <span class="keywordflow">return</span> snmp_sess_async_send(sessp, pdu, NULL, NULL);
04642 }
04643 
04644 <span class="keywordtype">int</span>
04645 snmp_async_send(netsnmp_session * session,
04646                 <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, snmp_callback callback, <span class=
"keywordtype">void</span> *cb_data)
04647 {
04648     <span class="keywordtype">void</span>           *sessp = snmp_sess_pointer(session);
04649     <span class="keywordflow">return</span> snmp_sess_async_send(sessp, pdu, callback, cb_data);
04650 }
04651 
04652 <span class="keyword">static</span> <span class="keywordtype">int</span>
04653 _sess_async_send(<span class="keywordtype">void</span> *sessp,
04654                  <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, snmp_callback callback, <span class=
"keywordtype">void</span> *cb_data)
04655 {
04656     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
04657     netsnmp_session *session;
04658     <span class="keyword">struct </span>snmp_internal_session *isp;
04659     netsnmp_transport *transport = NULL;
04660     u_char         *pktbuf = NULL, *packet = NULL;
04661     size_t          pktbuf_len = 0, offset = 0, length = 0;
04662     <span class="keywordtype">int</span>             result;
04663     <span class="keywordtype">long</span>            reqid;
04664 
04665     <span class="keywordflow">if</span> (slp == NULL) {
04666         <span class="keywordflow">return</span> 0;
04667     } <span class="keywordflow">else</span> {
04668         session = slp-&gt;session;
04669         isp = slp-&gt;internal;
04670         transport = slp-&gt;transport;
04671         <span class="keywordflow">if</span> (!session || !isp || !transport) {
04672             DEBUGMSGTL((<span class="stringliteral">"sess_async_send"</span>, <span class=
"stringliteral">"send fail: closing...\n"</span>));
04673             <span class="keywordflow">return</span> 0;
04674         }
04675     }
04676 
04677     <span class="keywordflow">if</span> (pdu == NULL) {
04678         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_NULL_PDU;
04679         <span class="keywordflow">return</span> 0;
04680     }
04681 
04682     session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
04683     session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
04684 
04685     <span class="comment">/*</span>
04686 <span class="comment">     * Check/setup the version.  </span>
04687 <span class="comment">     */</span>
04688     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_DEFAULT_VERSION) {
04689         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a> == SNMP_DEFAULT_VERSION) {
04690             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
04691             <span class="keywordflow">return</span> 0;
04692         }
04693         pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a> = session-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a>;
04694     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a> == SNMP_DEFAULT_VERSION) {
04695         <span class="comment">/*</span>
04696 <span class="comment">         * It's OK  </span>
04697 <span class="comment">         */</span>
04698     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> != session-&gt;<a class="code" href="structsnmp__session.html#o0">version</a>) {
04699         <span class="comment">/*</span>
04700 <span class="comment">         * ENHANCE: we should support multi-lingual sessions  </span>
04701 <span class="comment">         */</span>
04702         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_VERSION;
04703         <span class="keywordflow">return</span> 0;
04704     }
04705 
04706     <span class="comment">/*</span>
04707 <span class="comment">     * do we expect a response?</span>
04708 <span class="comment">     */</span>
04709     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>) {
04710 
04711         <span class="keywordflow">case</span> SNMP_MSG_RESPONSE:
04712         <span class="keywordflow">case</span> SNMP_MSG_TRAP:
04713         <span class="keywordflow">case</span> SNMP_MSG_TRAP2:
04714         <span class="keywordflow">case</span> SNMP_MSG_REPORT:
04715         <span class="keywordflow">case</span> AGENTX_MSG_CLEANUPSET:
04716         <span class="keywordflow">case</span> AGENTX_MSG_RESPONSE:
04717             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> &amp;= ~UCD_MSG_FLAG_EXPECT_RESPONSE;
04718             <span class="keywordflow">break</span>;
04719             
04720         <span class="keywordflow">default</span>:
04721             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> |= UCD_MSG_FLAG_EXPECT_RESPONSE;
04722             <span class="keywordflow">break</span>;
04723     }
04724 
04725     <span class="comment">/*</span>
04726 <span class="comment">     * check to see if we need a v3 engineID probe</span>
04727 <span class="comment">     */</span>
04728     <span class="keywordflow">if</span> ((pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_3) &amp;&amp;
04729         (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> &amp; UCD_MSG_FLAG_EXPECT_RESPONSE) &amp;&amp;
04730         (session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a> == 0) &amp;&amp;
04731         (0 == (session-&gt;<a class="code" href="structsnmp__session.html#o3">flags</a> &amp; SNMP_FLAGS_DONT_PROBE))) {
04732         <span class="keywordtype">int</span> rc;
04733         DEBUGMSGTL((<span class="stringliteral">"snmpv3_build"</span>, <span class=
"stringliteral">"delayed probe for engineID\n"</span>));
04734         rc = <a class="code" href="group__library.html#ga62">snmpv3_engineID_probe</a>(slp, session);
04735         <span class="keywordflow">if</span> (rc == 0)
04736             <span class="keywordflow">return</span> 0; <span class="comment">/* s_snmp_errno already set */</span>
04737     }
04738 
04739     <span class="comment">/*</span>
04740 <span class="comment">     * check to see if we need to create a v3 user from the session info</span>
04741 <span class="comment">     */</span>
04742     <span class="keywordflow">if</span> (create_user_from_session(session) != SNMPERR_SUCCESS) {
04743         session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_UNKNOWN_USER_NAME;  <span class="comment">/* XX?? */</span>
04744         DEBUGMSGTL((<span class="stringliteral">"snmp_api"</span>,
04745                     <span class="stringliteral">"snmp_sess_open(): failed(2) to create a new user from session\n"</span>));
04746         <span class="keywordflow">return</span> 0;
04747     }
04748 
04749     <span class="keywordflow">if</span> ((pktbuf = malloc(2048)) == NULL) {
04750         DEBUGMSGTL((<span class="stringliteral">"sess_async_send"</span>,
04751                     <span class="stringliteral">"couldn't malloc initial packet buffer\n"</span>));
04752         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
04753         <span class="keywordflow">return</span> 0;
04754     } <span class="keywordflow">else</span> {
04755         pktbuf_len = 2048;
04756     }
04757 
04758 <span class="preprocessor">#if TEMPORARILY_DISABLED</span>
04759     <span class="comment">/*</span>
04760 <span class="comment">     *  NULL variable are allowed in certain PDU types.</span>
04761 <span class="comment">     *  In particular, SNMPv3 engineID probes are of this form.</span>
04762 <span class="comment">     *  There is an internal PDU flag to indicate that this</span>
04763 <span class="comment">     *    is acceptable, but until the construction of engineID</span>
04764 <span class="comment">     *    probes can be amended to set this flag, we'll simply</span>
04765 <span class="comment">     *    skip this test altogether.</span>
04766 <span class="comment">     */</span>
04767     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> == NULL) {
04768         <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>) {
04769         <span class="keywordflow">case</span> SNMP_MSG_GET:
04770         <span class="keywordflow">case</span> SNMP_MSG_SET:
04771         <span class="keywordflow">case</span> SNMP_MSG_GETNEXT:
04772         <span class="keywordflow">case</span> SNMP_MSG_GETBULK:
04773         <span class="keywordflow">case</span> SNMP_MSG_RESPONSE:
04774         <span class="keywordflow">case</span> SNMP_MSG_TRAP2:
04775         <span class="keywordflow">case</span> SNMP_MSG_REPORT:
04776         <span class="keywordflow">case</span> SNMP_MSG_INFORM:
04777             session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> = snmp_errno = SNMPERR_NO_VARS;
04778             <span class="keywordflow">return</span> 0;
04779         <span class="keywordflow">case</span> SNMP_MSG_TRAP:
04780             <span class="keywordflow">break</span>;
04781         }
04782     }
04783 <span class="preprocessor">#endif</span>
04784 
04785 
04786     <span class="comment">/*</span>
04787 <span class="comment">     * Build the message to send.  </span>
04788 <span class="comment">     */</span>
04789     <span class="keywordflow">if</span> (isp-&gt;hook_realloc_build) {
04790         result = isp-&gt;hook_realloc_build(session, pdu,
04791                                          &amp;pktbuf, &amp;pktbuf_len, &amp;offset);
04792         packet = pktbuf;
04793         length = offset;
04794     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isp-&gt;hook_build) {
04795         packet = pktbuf;
04796         length = pktbuf_len;
04797         result = isp-&gt;hook_build(session, pdu, pktbuf, &amp;length);
04798     } <span class="keywordflow">else</span> {
04799 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
04800         <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REVERSE_ENCODE)) {
04801             result =
04802                 snmp_build(&amp;pktbuf, &amp;pktbuf_len, &amp;offset, session, pdu);
04803             packet = pktbuf + pktbuf_len - offset;
04804             length = offset;
04805         } <span class="keywordflow">else</span> {
04806 <span class="preprocessor">#endif</span>
04807             packet = pktbuf;
04808             length = pktbuf_len;
04809             result = snmp_build(&amp;pktbuf, &amp;length, &amp;offset, session, pdu);
04810 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
04811         }
04812 <span class="preprocessor">#endif</span>
04813     }
04814 
04815     <span class="keywordflow">if</span> (result &lt; 0) {
04816         DEBUGMSGTL((<span class="stringliteral">"sess_async_send"</span>, <span class=
"stringliteral">"encoding failure\n"</span>));
04817         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
04818         <span class="keywordflow">return</span> 0;
04819     }
04820 
04821     <span class="comment">/*</span>
04822 <span class="comment">     * Make sure we don't send something that is bigger than the msgMaxSize</span>
04823 <span class="comment">     * specified in the received PDU.  </span>
04824 <span class="comment">     */</span>
04825 
04826     <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o19">sndMsgMaxSize</a> != 0 &amp;&amp; length &gt; session-&gt;<a class="code" href=
"structsnmp__session.html#o19">sndMsgMaxSize</a>) {
04827         DEBUGMSGTL((<span class="stringliteral">"sess_async_send"</span>,
04828                     <span class="stringliteral">"length of packet (%lu) exceeds session maximum (%lu)\n"</span>,
04829                     length, session-&gt;<a class="code" href="structsnmp__session.html#o19">sndMsgMaxSize</a>));
04830         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_TOO_LONG;
04831         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
04832         <span class="keywordflow">return</span> 0;
04833     }
04834 
04835     <span class="comment">/*</span>
04836 <span class="comment">     * Check that the underlying transport is capable of sending a packet as</span>
04837 <span class="comment">     * large as length.  </span>
04838 <span class="comment">     */</span>
04839 
04840     <span class="keywordflow">if</span> (transport-&gt;msgMaxSize != 0 &amp;&amp; length &gt; transport-&gt;msgMaxSize) {
04841         DEBUGMSGTL((<span class="stringliteral">"sess_async_send"</span>,
04842                     <span class="stringliteral">"length of packet (%lu) exceeds transport maximum (%lu)\n"</span>,
04843                     length, transport-&gt;msgMaxSize));
04844         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_TOO_LONG;
04845         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
04846         <span class="keywordflow">return</span> 0;
04847     }
04848 
04849     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DUMP_PACKET)) {
04850         <span class="keywordflow">if</span> (transport-&gt;f_fmtaddr != NULL) {
04851             <span class="keywordtype">char</span>           *dest_txt =
04852                 transport-&gt;f_fmtaddr(transport, pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o13">transport_data</a>,
04853                                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o14">transport_data_length</a>);
04854             <span class="keywordflow">if</span> (dest_txt != NULL) {
04855                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_DEBUG, <span class=
"stringliteral">"\nSending %u bytes to %s\n"</span>, length,
04856                          dest_txt);
04857                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(dest_txt);
04858             } <span class="keywordflow">else</span> {
04859                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_DEBUG, <span class=
"stringliteral">"\nSending %u bytes to &lt;UNKNOWN&gt;\n"</span>,
04860                          length);
04861             }
04862         }
04863         xdump(packet, length, <span class="stringliteral">""</span>);
04864     }
04865 
04866     <span class="comment">/*</span>
04867 <span class="comment">     * Send the message.  </span>
04868 <span class="comment">     */</span>
04869 
04870     result = transport-&gt;f_send(transport, packet, length,
04871                                &amp;(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o13">transport_data</a>),
04872                                &amp;(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o14">transport_data_length</a>));
04873 
04874     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
04875 
04876     <span class="keywordflow">if</span> (result &lt; 0) {
04877         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_SENDTO;
04878         session-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = errno;
04879         <span class="keywordflow">return</span> 0;
04880     }
04881 
04882     reqid = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a>;
04883 
04884     <span class="comment">/*</span>
04885 <span class="comment">     * Add to pending requests list if we expect a response.  </span>
04886 <span class="comment">     */</span>
04887     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a> &amp; UCD_MSG_FLAG_EXPECT_RESPONSE) {
04888         netsnmp_request_list *rp;
04889         <span class="keyword">struct </span>timeval  tv;
04890 
04891         rp = (netsnmp_request_list *) calloc(1,
04892                                              <span class="keyword">sizeof</span>(netsnmp_request_list));
04893         <span class="keywordflow">if</span> (rp == NULL) {
04894             session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_GENERR;
04895             <span class="keywordflow">return</span> 0;
04896         }
04897 
04898         gettimeofday(&amp;tv, (<span class="keyword">struct</span> timezone *) 0);
04899         rp-&gt;pdu = pdu;
04900         rp-&gt;request_id = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a>;
04901         rp-&gt;message_id = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o3">msgid</a>;
04902         rp-&gt;callback = callback;
04903         rp-&gt;cb_data = cb_data;
04904         rp-&gt;retries = 0;
04905         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a> &amp; UCD_MSG_FLAG_PDU_TIMEOUT) {
04906             rp-&gt;timeout = pdu-&gt;<a class="code" href="structsnmp__pdu.html#o8">time</a> * 1000000L;
04907         } <span class="keywordflow">else</span> {
04908             rp-&gt;timeout = session-&gt;<a class="code" href="structsnmp__session.html#o2">timeout</a>;
04909         }
04910         rp-&gt;time = tv;
04911         tv.tv_usec += rp-&gt;<a class="code" href="structsnmp__session.html#o2">timeout</a>;
04912         tv.tv_sec += tv.tv_usec / 1000000L;
04913         tv.tv_usec %= 1000000L;
04914         rp-&gt;expire = tv;
04915 
04916         <span class="comment">/*</span>
04917 <span class="comment">         * XX lock should be per session ! </span>
04918 <span class="comment">         */</span>
04919         snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
04920         <span class="keywordflow">if</span> (isp-&gt;requestsEnd) {
04921             rp-&gt;next_request = isp-&gt;requestsEnd-&gt;next_request;
04922             isp-&gt;requestsEnd-&gt;next_request = rp;
04923             isp-&gt;requestsEnd = rp;
04924         } <span class="keywordflow">else</span> {
04925             rp-&gt;next_request = isp-&gt;requests;
04926             isp-&gt;requests = rp;
04927             isp-&gt;requestsEnd = rp;
04928         }
04929         snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
04930     } <span class="keywordflow">else</span> {
04931         <span class="comment">/*</span>
04932 <span class="comment">         * No response expected...  </span>
04933 <span class="comment">         */</span>
04934         <span class="keywordflow">if</span> (reqid) {
04935             <span class="comment">/*</span>
04936 <span class="comment">             * Free v1 or v2 TRAP PDU iff no error  </span>
04937 <span class="comment">             */</span>
04938             snmp_free_pdu(pdu);
04939         }
04940     }
04941 
04942     <span class="keywordflow">return</span> reqid;
04943 }
04944 
04945 <span class="keywordtype">int</span>
04946 snmp_sess_async_send(<span class="keywordtype">void</span> *sessp,
04947                      <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
04948                      snmp_callback callback, <span class="keywordtype">void</span> *cb_data)
04949 {
04950     <span class="keywordtype">int</span>             rc;
04951 
04952     <span class="keywordflow">if</span> (sessp == NULL) {
04953         snmp_errno = SNMPERR_BAD_SESSION;       <span class="comment">/*MTCRITICAL_RESOURCE */</span>
04954         <span class="keywordflow">return</span> (0);
04955     }
04956     <span class="comment">/*</span>
04957 <span class="comment">     * send pdu</span>
04958 <span class="comment">     */</span>
04959     rc = _sess_async_send(sessp, pdu, callback, cb_data);
04960     <span class="keywordflow">if</span> (rc == 0) {
04961         <span class="keyword">struct </span>session_list *psl;
04962         netsnmp_session *pss;
04963         psl = (<span class="keyword">struct </span>session_list *) sessp;
04964         pss = psl-&gt;session;
04965         SET_SNMP_ERROR(pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
04966     }
04967     <span class="keywordflow">return</span> rc;
04968 }
04969 
04970 
04971 <span class="comment">/*</span>
04972 <span class="comment"> * Frees the variable and any malloc'd data associated with it.</span>
04973 <span class="comment"> */</span>
04974 <span class="keywordtype">void</span>
04975 snmp_free_var(<a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * var)
04976 {
04977     <span class="keywordflow">if</span> (!var)
04978         <span class="keywordflow">return</span>;
04979 
04980     <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a> != var-&gt;<a class="code" href="structvariable__list.html#o6">name_loc</a>)
04981         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(var-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>);
04982     <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string != var-&gt;<a class="code" href="structvariable__list.html#o7">buf</a>)
04983         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string);
04984     <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#o8">data</a>) {
04985         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o9">dataFreeHook</a>) {
04986             var-&gt;<a class="code" href="structvariable__list.html#o9">dataFreeHook</a>(var-&gt;<a class="code" href=
"structvariable__list.html#o8">data</a>);
04987             var-&gt;<a class="code" href="structvariable__list.html#o8">data</a> = NULL;
04988         } <span class="keywordflow">else</span> {
04989             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(var-&gt;<a class="code" href=
"structvariable__list.html#o8">data</a>);
04990         }
04991     }
04992 
04993     free((<span class="keywordtype">char</span> *) var);
04994 }
04995 
04996 <span class="keywordtype">void</span>
04997 snmp_free_varbind(<a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * var)
04998 {
04999     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *ptr;
05000     <span class="keywordflow">while</span> (var) {
05001         ptr = var-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>;
05002         snmp_free_var(var);
05003         var = ptr;
05004     }
05005 }
05006 
05007 <span class="comment">/*</span>
05008 <span class="comment"> * Frees the pdu and any malloc'd data associated with it.</span>
05009 <span class="comment"> */</span>
05010 <span class="keywordtype">void</span>
05011 snmp_free_pdu(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
05012 {
05013     <span class="keyword">struct </span>snmp_secmod_def *sptr;
05014 
05015     <span class="keywordflow">if</span> (!pdu)
05016         <span class="keywordflow">return</span>;
05017 
05018     <span class="comment">/*</span>
05019 <span class="comment">     * If the command field is empty, that probably indicates</span>
05020 <span class="comment">     *   that this PDU structure has already been freed.</span>
05021 <span class="comment">     *   Log a warning and return (rather than freeing things again)</span>
05022 <span class="comment">     *</span>
05023 <span class="comment">     * Note that this does not pick up dual-frees where the</span>
05024 <span class="comment">     *   memory is set to random junk, which is probably more serious.</span>
05025 <span class="comment">     *</span>
05026 <span class="comment">     * rks: while this is a good idea, there are two problems.</span>
05027 <span class="comment">     *         1) agentx sets command to 0 in some cases</span>
05028 <span class="comment">     *         2) according to Wes, a bad decode of a v3 message could</span>
05029 <span class="comment">     *            result in a 0 at this offset.</span>
05030 <span class="comment">     *      so I'm commenting it out until a better solution is found.</span>
05031 <span class="comment">     *      note that I'm leaving the memset, below....</span>
05032 <span class="comment">     *</span>
05033 <span class="comment">    if (pdu-&gt;command == 0) {</span>
05034 <span class="comment">        snmp_log(LOG_WARNING, "snmp_free_pdu probably called twice\n");</span>
05035 <span class="comment">        return;</span>
05036 <span class="comment">    }</span>
05037 <span class="comment">     */</span>
05038     <span class="keywordflow">if</span> ((sptr = find_sec_mod(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o10">securityModel</a>)) != NULL &amp;&amp;
05039         sptr-&gt;pdu_free != NULL) {
05040         (*sptr-&gt;pdu_free) (pdu);
05041     }
05042     snmp_free_varbind(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>);
05043     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o20">enterprise</a>);
05044     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a>);
05045     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o25">contextEngineID</a>);
05046     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o29">securityEngineID</a>);
05047     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o27">contextName</a>);
05048     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o31">securityName</a>);
05049     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o13">transport_data</a>);
05050     memset(pdu, 0, <span class="keyword">sizeof</span>(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>));
05051     free((<span class="keywordtype">char</span> *) pdu);
05052 }
05053 
05054 <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>    *
05055 snmp_create_sess_pdu(netsnmp_transport *transport, <span class="keywordtype">void</span> *opaque,
05056                      size_t olength)
05057 {
05058     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu = (<a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *)calloc(1, <span class="keyword">sizeof</span>(<a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a>));
05059     <span class="keywordflow">if</span> (pdu == NULL) {
05060         DEBUGMSGTL((<span class="stringliteral">"sess_process_packet"</span>, <span class=
"stringliteral">"can't malloc space for PDU\n"</span>));
05061         <span class="keywordflow">return</span> NULL;
05062     }
05063 
05064     <span class="comment">/*</span>
05065 <span class="comment">     * Save the transport-level data specific to this reception (e.g. UDP</span>
05066 <span class="comment">     * source address).  </span>
05067 <span class="comment">     */</span>
05068 
05069     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o13">transport_data</a> = opaque;
05070     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o14">transport_data_length</a> = olength;
05071     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o15">tDomain</a> = transport-&gt;domain;
05072     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o16">tDomainLen</a> = transport-&gt;domain_length;
05073     <span class="keywordflow">return</span> pdu;
05074 }
05075 
05076 
05077 <span class="comment">/*</span>
05078 <span class="comment"> * This function processes a complete (according to asn_check_packet or the</span>
05079 <span class="comment"> * AgentX equivalent) packet, parsing it into a PDU and calling the relevant</span>
05080 <span class="comment"> * callbacks.  On entry, packetptr points at the packet in the session's</span>
05081 <span class="comment"> * buffer and length is the length of the packet.  </span>
05082 <span class="comment"> */</span>
05083 
05084 <span class="keyword">static</span> <span class="keywordtype">int</span>
05085 _sess_process_packet(<span class="keywordtype">void</span> *sessp, netsnmp_session * sp,
05086                      <span class="keyword">struct</span> snmp_internal_session *isp,
05087                      netsnmp_transport *transport,
05088                      <span class="keywordtype">void</span> *opaque, <span class="keywordtype">int</span> olength,
05089                      u_char * packetptr, <span class="keywordtype">int</span> length)
05090 {
05091   <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
05092   <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>    *pdu;
05093   netsnmp_request_list *rp, *orp = NULL;
05094   <span class="keyword">struct </span>snmp_secmod_def *sptr;
05095   <span class="keywordtype">int</span>             ret = 0, handled = 0;
05096 
05097   DEBUGMSGTL((<span class="stringliteral">"sess_process_packet"</span>,
05098               <span class="stringliteral">"session %p fd %d pkt %p length %d\n"</span>, sessp,
05099               transport-&gt;sock, packetptr, length));
05100 
05101   <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
05102                              NETSNMP_DS_LIB_DUMP_PACKET)) {
05103     <span class="keywordflow">if</span> (transport-&gt;f_fmtaddr != NULL) {
05104       <span class="keywordtype">char</span> *addrtxt = transport-&gt;f_fmtaddr(transport, opaque, olength);
05105       <span class="keywordflow">if</span> (addrtxt != NULL) {
05106         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_DEBUG, <span class=
"stringliteral">"\nReceived %d bytes from %s\n"</span>,
05107                  length, addrtxt);
05108         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(addrtxt);
05109       } <span class="keywordflow">else</span> {
05110         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_DEBUG, <span class=
"stringliteral">"\nReceived %d bytes from &lt;UNKNOWN&gt;\n"</span>,
05111                  length);
05112       }
05113     }
05114     xdump(packetptr, length, <span class="stringliteral">""</span>);
05115   }
05116 
05117   <span class="comment">/*</span>
05118 <span class="comment">   * Do transport-level filtering (e.g. IP-address based allow/deny).  </span>
05119 <span class="comment">   */</span>
05120 
05121   <span class="keywordflow">if</span> (isp-&gt;hook_pre) {
05122     <span class="keywordflow">if</span> (isp-&gt;hook_pre(sp, transport, opaque, olength) == 0) {
05123       DEBUGMSGTL((<span class="stringliteral">"sess_process_packet"</span>, <span class=
"stringliteral">"pre-parse fail\n"</span>));
05124       <span class="keywordflow">if</span> (opaque != NULL) {
05125         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05126       }
05127       <span class="keywordflow">return</span> -1;
05128     }
05129   }
05130 
05131   <span class="keywordflow">if</span> (isp-&gt;hook_create_pdu) {
05132     pdu = isp-&gt;hook_create_pdu(transport, opaque, olength);
05133   } <span class="keywordflow">else</span> {
05134     pdu = snmp_create_sess_pdu(transport, opaque, olength);
05135   }
05136   <span class="keywordflow">if</span> (pdu == NULL) {
05137     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"pdu failed to be created\n"</span>);
05138     <span class="keywordflow">if</span> (opaque != NULL) {
05139       <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05140     }
05141     <span class="keywordflow">return</span> -1;
05142   }
05143 
05144   <span class="keywordflow">if</span> (isp-&gt;hook_parse) {
05145     ret = isp-&gt;hook_parse(sp, pdu, packetptr, length);
05146   } <span class="keywordflow">else</span> {
05147     ret = snmp_parse(sessp, sp, pdu, packetptr, length);
05148   }
05149 
05150   <span class="keywordflow">if</span> (ret != SNMP_ERR_NOERROR) {
05151     DEBUGMSGTL((<span class="stringliteral">"sess_process_packet"</span>, <span class=
"stringliteral">"parse fail\n"</span>));
05152   }
05153 
05154   <span class="keywordflow">if</span> (isp-&gt;hook_post) {
05155     <span class="keywordflow">if</span> (isp-&gt;hook_post(sp, pdu, ret) == 0) {
05156       DEBUGMSGTL((<span class="stringliteral">"sess_process_packet"</span>, <span class=
"stringliteral">"post-parse fail\n"</span>));
05157       ret = SNMPERR_ASN_PARSE_ERR;
05158     }
05159   }
05160 
05161   <span class="keywordflow">if</span> (ret != SNMP_ERR_NOERROR) {
05162     <span class="comment">/*</span>
05163 <span class="comment">     * Call the security model to free any securityStateRef supplied w/ msg.  </span>
05164 <span class="comment">     */</span>
05165     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o35">securityStateRef</a> != NULL) {
05166       sptr = find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05167       <span class="keywordflow">if</span> (sptr != NULL) {
05168         <span class="keywordflow">if</span> (sptr-&gt;pdu_free_state_ref != NULL) {
05169           (*sptr-&gt;pdu_free_state_ref) (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>);
05170         } <span class="keywordflow">else</span> {
05171           <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
05172                    <span class="stringliteral">"Security Model %d can't free state references\n"</span>,
05173                    pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05174         }
05175       } <span class="keywordflow">else</span> {
05176         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
05177                  <span class="stringliteral">"Can't find security model to free ptr: %d\n"</span>,
05178                  pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05179       }
05180       pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a> = NULL;
05181     }
05182     snmp_free_pdu(pdu);
05183     <span class="keywordflow">return</span> -1;
05184   }
05185 
05186   <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a> &amp; UCD_MSG_FLAG_RESPONSE_PDU) {
05187     <span class="comment">/*</span>
05188 <span class="comment">     * Call USM to free any securityStateRef supplied with the message.  </span>
05189 <span class="comment">     */</span>
05190     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>) {
05191       sptr = find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05192       <span class="keywordflow">if</span> (sptr) {
05193         <span class="keywordflow">if</span> (sptr-&gt;pdu_free_state_ref) {
05194           (*sptr-&gt;pdu_free_state_ref) (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>);
05195         } <span class="keywordflow">else</span> {
05196           <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
05197                    <span class="stringliteral">"Security Model %d can't free state references\n"</span>,
05198                    pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05199         }
05200       } <span class="keywordflow">else</span> {
05201         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
05202                  <span class="stringliteral">"Can't find security model to free ptr: %d\n"</span>,
05203                  pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05204       }
05205       pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a> = NULL;
05206     }
05207 
05208     <span class="keywordflow">for</span> (rp = isp-&gt;requests; rp; orp = rp, rp = rp-&gt;next_request) {
05209       snmp_callback   callback;
05210       <span class="keywordtype">void</span>           *magic;
05211 
05212       <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_3) {
05213         <span class="comment">/*</span>
05214 <span class="comment">         * msgId must match for v3 messages.  </span>
05215 <span class="comment">         */</span>
05216         <span class="keywordflow">if</span> (rp-&gt;message_id != pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o3">msgid</a>) {
05217           <span class="keywordflow">continue</span>;
05218         }
05219 
05220         <span class="comment">/*</span>
05221 <span class="comment">         * Check that message fields match original, if not, no further</span>
05222 <span class="comment">         * processing.  </span>
05223 <span class="comment">         */</span>
05224         <span class="keywordflow">if</span> (!snmpv3_verify_msg(rp, pdu)) {
05225           <span class="keywordflow">break</span>;
05226         }
05227       } <span class="keywordflow">else</span> {
05228         <span class="keywordflow">if</span> (rp-&gt;request_id != pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o2">reqid</a>) {
05229           <span class="keywordflow">continue</span>;
05230         }
05231       }
05232 
05233       <span class="keywordflow">if</span> (rp-&gt;callback) {
05234         callback = rp-&gt;callback;
05235         magic = rp-&gt;cb_data;
05236       } <span class="keywordflow">else</span> {
05237         callback = sp-&gt;<a class="code" href="structsnmp__session.html#o11">callback</a>;
05238         magic = sp-&gt;<a class="code" href="structsnmp__session.html#o12">callback_magic</a>;
05239       }
05240       handled = 1;
05241 
05242       <span class="comment">/*</span>
05243 <span class="comment">       * MTR snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);  ?* XX lock</span>
05244 <span class="comment">       * should be per session ! </span>
05245 <span class="comment">       */</span>
05246 
05247       <span class="keywordflow">if</span> (callback == NULL
05248           || callback(NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE, sp,
05249                       pdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a>, pdu, magic) == 1) {
05250         <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a> == SNMP_MSG_REPORT) {
05251           <span class="keywordflow">if</span> (sp-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> == SNMPERR_NOT_IN_TIME_WINDOW ||
05252               snmpv3_get_report_type(pdu) ==
05253               SNMPERR_NOT_IN_TIME_WINDOW) {
05254             <span class="comment">/*</span>
05255 <span class="comment">             * trigger immediate retry on recoverable Reports </span>
05256 <span class="comment">             * * (notInTimeWindow), incr_retries == TRUE to prevent</span>
05257 <span class="comment">             * * inifinite resend                      </span>
05258 <span class="comment">             */</span>
05259             <span class="keywordflow">if</span> (rp-&gt;retries &lt;= sp-&gt;<a class="code" href=
"structsnmp__session.html#o1">retries</a>) {
05260               snmp_resend_request(slp, rp, TRUE);
05261               <span class="keywordflow">break</span>;
05262             }
05263           } <span class="keywordflow">else</span> {
05264             <span class="keywordflow">if</span> (SNMPV3_IGNORE_UNAUTH_REPORTS) {
05265               <span class="keywordflow">break</span>;
05266             }
05267           }
05268 
05269           <span class="comment">/*</span>
05270 <span class="comment">           * Handle engineID discovery.  </span>
05271 <span class="comment">           */</span>
05272           <span class="keywordflow">if</span> (!sp-&gt;<a class="code" href=
"structsnmp__session.html#o28">securityEngineIDLen</a> &amp;&amp; pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o30">securityEngineIDLen</a>) {
05273             sp-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a> =
05274               (u_char *) malloc(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>);
05275             <span class="keywordflow">if</span> (sp-&gt;<a class="code" href=
"structsnmp__session.html#o27">securityEngineID</a> == NULL) {
05276               <span class="comment">/*</span>
05277 <span class="comment">               * TODO FIX: recover after message callback *?</span>
05278 <span class="comment">               * return -1;</span>
05279 <span class="comment">               */</span>
05280             }
05281             memcpy(sp-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a>, pdu-&gt;<a class="code"
href="structsnmp__pdu.html#o29">securityEngineID</a>,
05282                    pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>);
05283             sp-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a> = pdu-&gt;<a class="code"
href="structsnmp__pdu.html#o30">securityEngineIDLen</a>;
05284             <span class="keywordflow">if</span> (!sp-&gt;<a class="code" href=
"structsnmp__session.html#o22">contextEngineIDLen</a>) {
05285               sp-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a> =
05286                 (u_char *) malloc(pdu-&gt;
05287                                   securityEngineIDLen);
05288               <span class="keywordflow">if</span> (sp-&gt;<a class="code" href=
"structsnmp__session.html#o21">contextEngineID</a> == NULL) {
05289                 <span class="comment">/*</span>
05290 <span class="comment">                 * TODO FIX: recover after message callback *?</span>
05291 <span class="comment">                 * return -1;</span>
05292 <span class="comment">                 */</span>
05293               }
05294               memcpy(sp-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a>,
05295                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o29">securityEngineID</a>,
05296                      pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>);
05297               sp-&gt;<a class="code" href="structsnmp__session.html#o22">contextEngineIDLen</a> =
05298                 pdu-&gt;<a class="code" href="structsnmp__pdu.html#o30">securityEngineIDLen</a>;
05299             }
05300           }
05301         }
05302 
05303         <span class="comment">/*</span>
05304 <span class="comment">         * Successful, so delete request.  </span>
05305 <span class="comment">         */</span>
05306         <span class="keywordflow">if</span> (isp-&gt;requests == rp) {
05307           isp-&gt;requests = rp-&gt;next_request;
05308           <span class="keywordflow">if</span> (isp-&gt;requestsEnd == rp) {
05309             isp-&gt;requestsEnd = NULL;
05310           }
05311         } <span class="keywordflow">else</span> {
05312           orp-&gt;next_request = rp-&gt;next_request;
05313           <span class="keywordflow">if</span> (isp-&gt;requestsEnd == rp) {
05314             isp-&gt;requestsEnd = orp;
05315           }
05316         }
05317         snmp_free_pdu(rp-&gt;pdu);
05318         free((<span class="keywordtype">char</span> *) rp);
05319         <span class="comment">/*</span>
05320 <span class="comment">         * There shouldn't be any more requests with the same reqid.  </span>
05321 <span class="comment">         */</span>
05322         <span class="keywordflow">break</span>;
05323       }
05324       <span class="comment">/*</span>
05325 <span class=
"comment">       * MTR snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);  ?* XX lock should be per session ! </span>
05326 <span class="comment">       */</span>
05327     }
05328   } <span class="keywordflow">else</span> {
05329     <span class="keywordflow">if</span> (sp-&gt;<a class="code" href="structsnmp__session.html#o11">callback</a>) {
05330       <span class="comment">/*</span>
05331 <span class="comment">       * MTR snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION); </span>
05332 <span class="comment">       */</span>
05333       handled = 1;
05334       sp-&gt;<a class="code" href="structsnmp__session.html#o11">callback</a>(NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE,
05335                    sp, pdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a>, pdu, sp-&gt;<a class="code" href=
"structsnmp__session.html#o12">callback_magic</a>);
05336       <span class="comment">/*</span>
05337 <span class="comment">       * MTR snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION); </span>
05338 <span class="comment">       */</span>
05339     }
05340   }
05341 
05342   <span class="comment">/*</span>
05343 <span class="comment">   * Call USM to free any securityStateRef supplied with the message.  </span>
05344 <span class="comment">   */</span>
05345   <span class="keywordflow">if</span> (pdu != NULL &amp;&amp; pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o35">securityStateRef</a> &amp;&amp;
05346       pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> == SNMP_MSG_TRAP2) {
05347     sptr = find_sec_mod(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05348     <span class="keywordflow">if</span> (sptr) {
05349       <span class="keywordflow">if</span> (sptr-&gt;pdu_free_state_ref) {
05350         (*sptr-&gt;pdu_free_state_ref) (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>);
05351       } <span class="keywordflow">else</span> {
05352         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
05353                  <span class="stringliteral">"Security Model %d can't free state references\n"</span>,
05354                  pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05355       }
05356     } <span class="keywordflow">else</span> {
05357       <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
05358                <span class="stringliteral">"Can't find security model to free ptr: %d\n"</span>,
05359                pdu-&gt;<a class="code" href="structsnmp__pdu.html#o10">securityModel</a>);
05360     }
05361     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a> = NULL;
05362   }
05363 
05364   <span class="keywordflow">if</span> (!handled) {
05365     snmp_increment_statistic(STAT_SNMPUNKNOWNPDUHANDLERS);
05366     DEBUGMSGTL((<span class="stringliteral">"sess_process_packet"</span>, <span class=
"stringliteral">"unhandled PDU\n"</span>));
05367   }
05368 
05369   snmp_free_pdu(pdu);
05370   <span class="keywordflow">return</span> 0;
05371 }
05372 
05373 <span class="comment">/*</span>
05374 <span class="comment"> * Checks to see if any of the fd's set in the fdset belong to</span>
05375 <span class="comment"> * snmp.  Each socket with it's fd set has a packet read from it</span>
05376 <span class="comment"> * and snmp_parse is called on the packet received.  The resulting pdu</span>
05377 <span class="comment"> * is passed to the callback routine for that session.  If the callback</span>
05378 <span class="comment"> * routine returns successfully, the pdu and it's request are deleted.</span>
05379 <span class="comment"> */</span>
05380 <span class="keywordtype">void</span>
05381 snmp_read(fd_set * fdset)
05382 {
05383     <span class="keyword">struct </span>session_list *slp;
05384     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
05385     <span class="keywordflow">for</span> (slp = Sessions; slp; slp = slp-&gt;next) {
05386         snmp_sess_read((<span class="keywordtype">void</span> *) slp, fdset);
05387     }
05388     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
05389 }
05390 
05391 <span class="comment">/*</span>
05392 <span class="comment"> * Same as snmp_read, but works just one session. </span>
05393 <span class="comment"> * returns 0 if success, -1 if fail </span>
05394 <span class="comment"> * MTR: can't lock here and at snmp_read </span>
05395 <span class="comment"> * Beware recursive send maybe inside snmp_read callback function. </span>
05396 <span class="comment"> */</span>
05397 <span class="keywordtype">int</span>
<a name="l05398" id="l05398"></a><a class="code" href="group__library.html#ga96">05398</a> <a class="code" href=
"group__library.html#ga96">_sess_read</a>(<span class="keywordtype">void</span> *sessp, fd_set * fdset)
05399 {
05400     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
05401     netsnmp_session *sp = slp ? slp-&gt;session : NULL;
05402     <span class="keyword">struct </span>snmp_internal_session *isp = slp ? slp-&gt;internal : NULL;
05403     netsnmp_transport *transport = slp ? slp-&gt;transport : NULL;
05404     size_t          pdulen = 0, rxbuf_len = 65536;
05405     u_char         *rxbuf = NULL;
05406     <span class="keywordtype">int</span>             length = 0, olength = 0, rc = 0;
05407     <span class="keywordtype">void</span>           *opaque = NULL;
05408 
05409     <span class="keywordflow">if</span> (!sp || !isp || !transport) {
05410         DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"read fail: closing...\n"</span>));
05411         <span class="keywordflow">return</span> 0;
05412     }
05413 
05414     <span class="keywordflow">if</span> (!fdset || !(FD_ISSET(transport-&gt;sock, fdset))) {
05415         DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"not reading %d (fdset %p set %d)\n"</span>,
05416                     transport-&gt;sock, fdset,
05417                     fdset ? FD_ISSET(transport-&gt;sock, fdset) : -9));
05418         <span class="keywordflow">return</span> 0;
05419     }
05420 
05421     sp-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = 0;
05422     sp-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = 0;
05423 
05424     <span class="keywordflow">if</span> (transport-&gt;flags &amp; NETSNMP_TRANSPORT_FLAG_LISTEN) {
05425         <span class="keywordtype">int</span>             data_sock = transport-&gt;f_accept(transport);
05426 
05427         <span class="keywordflow">if</span> (data_sock &gt;= 0) {
05428             <span class="comment">/*</span>
05429 <span class="comment">             * We've successfully accepted a new stream-based connection.</span>
05430 <span class="comment">             * It's not too clear what should happen here if we are using the</span>
05431 <span class="comment">             * single-session API at this point.  Basically a "session</span>
05432 <span class="comment">             * accepted" callback is probably needed to hand the new session</span>
05433 <span class="comment">             * over to the application.</span>
05434 <span class="comment">             * </span>
05435 <span class="comment">             * However, for now, as in the original snmp_api, we will ASSUME</span>
05436 <span class="comment">             * that we're using the traditional API, and simply add the new</span>
05437 <span class="comment">             * session to the list.  Note we don't have to get the Session</span>
05438 <span class="comment">             * list lock here, because under that assumption we already hold</span>
05439 <span class="comment">             * it (this is also why we don't just use snmp_add).</span>
05440 <span class="comment">             * </span>
05441 <span class="comment">             * The moral of the story is: don't use listening stream-based</span>
05442 <span class="comment">             * transports in a multi-threaded environment because something</span>
05443 <span class="comment">             * will go HORRIBLY wrong (and also that SNMP/TCP is not trivial).</span>
05444 <span class="comment">             * </span>
05445 <span class="comment">             * Another open issue: what should happen to sockets that have</span>
05446 <span class="comment">             * been accept()ed from a listening socket when that original</span>
05447 <span class="comment">             * socket is closed?  If they are left open, then attempting to</span>
05448 <span class="comment">             * re-open the listening socket will fail, which is semantically</span>
05449 <span class="comment">             * confusing.  Perhaps there should be some kind of chaining in</span>
05450 <span class="comment">             * the transport structure so that they can all be closed.</span>
05451 <span class="comment">             * Discuss.  ;-)</span>
05452 <span class="comment">             */</span>
05453 
05454             netsnmp_transport *new_transport=netsnmp_transport_copy(transport);
05455             <span class="keywordflow">if</span> (new_transport != NULL) {
05456                 <span class="keyword">struct </span>session_list *nslp = NULL;
05457 
05458                 new_transport-&gt;sock = data_sock;
05459                 new_transport-&gt;<a class="code" href=
"structsnmp__session.html#o3">flags</a> &amp;= ~NETSNMP_TRANSPORT_FLAG_LISTEN;
05460 
05461                 nslp = (<span class="keyword">struct </span>session_list *)snmp_sess_add_ex(sp,
05462                           new_transport, isp-&gt;hook_pre, isp-&gt;hook_parse,
05463                           isp-&gt;hook_post, isp-&gt;hook_build,
05464                           isp-&gt;hook_realloc_build, isp-&gt;check_packet,
05465                           isp-&gt;hook_create_pdu);
05466 
05467                 <span class="keywordflow">if</span> (nslp != NULL) {
05468                     nslp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = Sessions;
05469                     Sessions = nslp;
05470                     <span class="comment">/*</span>
05471 <span class="comment">                     * Tell the new session about its existance if possible.</span>
05472 <span class="comment">                     */</span>
05473                     DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>,
05474                                 <span class="stringliteral">"perform callback with op=CONNECT\n"</span>));
05475                     (void)nslp-&gt;session-&gt;<a class="code" href=
"structsnmp__session.html#o11">callback</a>(NETSNMP_CALLBACK_OP_CONNECT,
05476                                                   nslp-&gt;session, 0, NULL,
05477                                                   sp-&gt;<a class="code" href=
"structsnmp__session.html#o12">callback_magic</a>);
05478                 } <span class="keywordflow">else</span> {
05479                     new_transport-&gt;f_close(new_transport);
05480                     netsnmp_transport_free(new_transport);
05481                 }
05482                 <span class="keywordflow">return</span> 0;
05483             } <span class="keywordflow">else</span> {
05484                 sp-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_MALLOC;
05485                 sp-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = errno;
05486                 snmp_set_detail(strerror(errno));
05487                 <span class="keywordflow">return</span> -1;
05488             }
05489         } <span class="keywordflow">else</span> {
05490             sp-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_RECVFROM;
05491             sp-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = errno;
05492             snmp_set_detail(strerror(errno));
05493             <span class="keywordflow">return</span> -1;
05494         }
05495     }
05496 
05497     <span class="comment">/*</span>
05498 <span class="comment">     * Work out where to receive the data to.  </span>
05499 <span class="comment">     */</span>
05500 
05501     <span class="keywordflow">if</span> (transport-&gt;flags &amp; NETSNMP_TRANSPORT_FLAG_STREAM) {
05502         <span class="keywordflow">if</span> (isp-&gt;packet == NULL) {
05503             <span class="comment">/*</span>
05504 <span class="comment">             * We have no saved packet.  Allocate one.  </span>
05505 <span class="comment">             */</span>
05506             <span class="keywordflow">if</span> ((isp-&gt;packet = (u_char *) malloc(rxbuf_len)) == NULL) {
05507                 DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"can't malloc %d bytes for rxbuf\n"</span>,
05508                             rxbuf_len));
05509                 <span class="keywordflow">return</span> 0;
05510             } <span class="keywordflow">else</span> {
05511                 rxbuf = isp-&gt;packet;
05512                 isp-&gt;packet_size = rxbuf_len;
05513                 isp-&gt;packet_len = 0;
05514             }
05515         } <span class="keywordflow">else</span> {
05516             <span class="comment">/*</span>
05517 <span class="comment">             * We have saved a partial packet from last time.  Extend that, if</span>
05518 <span class="comment">             * necessary, and receive new data after the old data.  </span>
05519 <span class="comment">             */</span>
05520             u_char         *newbuf;
05521 
05522             <span class="keywordflow">if</span> (isp-&gt;packet_size &lt; isp-&gt;packet_len + rxbuf_len) {
05523                 newbuf =
05524                     (u_char *) realloc(isp-&gt;packet,
05525                                        isp-&gt;packet_len + rxbuf_len);
05526                 <span class="keywordflow">if</span> (newbuf == NULL) {
05527                     DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>,
05528                                 <span class="stringliteral">"can't malloc %d more for rxbuf (%d tot)\n"</span>,
05529                                 rxbuf_len, isp-&gt;packet_len + rxbuf_len));
05530                     <span class="keywordflow">return</span> 0;
05531                 } <span class="keywordflow">else</span> {
05532                     isp-&gt;packet = newbuf;
05533                     isp-&gt;packet_size = isp-&gt;packet_len + rxbuf_len;
05534                     rxbuf = isp-&gt;packet + isp-&gt;packet_len;
05535                 }
05536             } <span class="keywordflow">else</span> {
05537                 rxbuf = isp-&gt;packet + isp-&gt;packet_len;
05538                 rxbuf_len = isp-&gt;packet_size - isp-&gt;packet_len;
05539             }
05540         }
05541     } <span class="keywordflow">else</span> {
05542         <span class="keywordflow">if</span> ((rxbuf = (u_char *) malloc(rxbuf_len)) == NULL) {
05543             DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"can't malloc %d bytes for rxbuf\n"</span>,
05544                         rxbuf_len));
05545             <span class="keywordflow">return</span> 0;
05546         }
05547     }
05548 
05549     length = transport-&gt;f_recv(transport, rxbuf, rxbuf_len, &amp;opaque, &amp;olength);
05550 
05551     <span class=
"keywordflow">if</span> (length == -1 &amp;&amp; !(transport-&gt;flags &amp; NETSNMP_TRANSPORT_FLAG_STREAM)) {
05552         sp-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_RECVFROM;
05553         sp-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = errno;
05554         snmp_set_detail(strerror(errno));
05555         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(rxbuf);
05556         <span class="keywordflow">if</span> (opaque != NULL) {
05557             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05558         }
05559         <span class="keywordflow">return</span> -1;
05560     }
05561 
05562     <span class="comment">/*</span>
05563 <span class="comment">     * Remote end closed connection.  </span>
05564 <span class="comment">     */</span>
05565 
05566     <span class=
"keywordflow">if</span> (length &lt;= 0 &amp;&amp; transport-&gt;flags &amp; NETSNMP_TRANSPORT_FLAG_STREAM) {
05567         <span class="comment">/*</span>
05568 <span class="comment">         * Alert the application if possible.  </span>
05569 <span class="comment">         */</span>
05570         <span class="keywordflow">if</span> (sp-&gt;<a class="code" href=
"structsnmp__session.html#o11">callback</a> != NULL) {
05571             DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"perform callback with op=DISCONNECT\n"</span>));
05572             (void) sp-&gt;<a class="code" href=
"structsnmp__session.html#o11">callback</a>(NETSNMP_CALLBACK_OP_DISCONNECT, sp, 0,
05573                                 NULL, sp-&gt;<a class="code" href="structsnmp__session.html#o12">callback_magic</a>);
05574         }
05575         <span class="comment">/*</span>
05576 <span class="comment">         * Close socket and mark session for deletion.  </span>
05577 <span class="comment">         */</span>
05578         DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"fd %d closed\n"</span>, transport-&gt;sock));
05579         transport-&gt;f_close(transport);
05580         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(isp-&gt;packet);
05581         <span class="keywordflow">if</span> (opaque != NULL) {
05582             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05583         }
05584         <span class="keywordflow">return</span> -1;
05585     }
05586 
05587     <span class="keywordflow">if</span> (transport-&gt;flags &amp; NETSNMP_TRANSPORT_FLAG_STREAM) {
05588         u_char *pptr = isp-&gt;packet;
05589         <span class="keywordtype">void</span> *ocopy = NULL;
05590 
05591         isp-&gt;packet_len += length;
05592 
05593         <span class="keywordflow">while</span> (isp-&gt;packet_len &gt; 0) {
05594 
05595             <span class="comment">/*</span>
05596 <span class="comment">             * Get the total data length we're expecting (and need to wait</span>
05597 <span class="comment">             * for).</span>
05598 <span class="comment">             */</span>
05599             <span class="keywordflow">if</span> (isp-&gt;check_packet) {
05600                 pdulen = isp-&gt;check_packet(pptr, isp-&gt;packet_len);
05601             } <span class="keywordflow">else</span> {
05602                 pdulen = asn_check_packet(pptr, isp-&gt;packet_len);
05603             }
05604 
05605             DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"  loop packet_len %d, PDU length %d\n"</span>,
05606                         isp-&gt;packet_len, pdulen));
05607              
05608             <span class="keywordflow">if</span> ((pdulen &gt; MAX_PACKET_LENGTH) || (pdulen &lt; 0)) {
05609                 <span class="comment">/*</span>
05610 <span class="comment">                 * Illegal length, drop the connection.  </span>
05611 <span class="comment">                 */</span>
05612                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, 
05613                          <span class="stringliteral">"Received broken packet. Closing session.\n"</span>);
05614                 <span class="keywordflow">if</span> (sp-&gt;<a class="code" href=
"structsnmp__session.html#o11">callback</a> != NULL) {
05615                   DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>,
05616                               <span class="stringliteral">"perform callback with op=DISCONNECT\n"</span>));
05617                   (void)sp-&gt;<a class="code" href=
"structsnmp__session.html#o11">callback</a>(NETSNMP_CALLBACK_OP_DISCONNECT,
05618                                      sp, 0, NULL, sp-&gt;<a class="code" href=
"structsnmp__session.html#o12">callback_magic</a>);
05619                 }
05620                 DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"fd %d closed\n"</span>, transport-&gt;sock));
05621                 transport-&gt;f_close(transport);
05622                 <span class="keywordflow">if</span> (opaque != NULL) {
05623                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05624                 }
05626                 <span class="keywordflow">return</span> -1;
05627             }
05628 
05629             <span class="keywordflow">if</span> (pdulen &gt; isp-&gt;packet_len || pdulen == 0) {
05630                 <span class="comment">/*</span>
05631 <span class="comment">                 * We don't have a complete packet yet.  If we've already</span>
05632 <span class="comment">                 * processed a packet, break out so we'll shift this packet</span>
05633 <span class="comment">                 * to the start of the buffer. If we're already at the</span>
05634 <span class="comment">                 * start, simply return and wait for more data to arrive.</span>
05635 <span class="comment">                 */</span>
05636                 DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>,
05637                             <span class="stringliteral">"pkt not complete (need %d got %d so far)\n"</span>,
05638                             pdulen, isp-&gt;packet_len));
05639 
05640                 <span class="keywordflow">if</span> (pptr != isp-&gt;packet)
05641                     <span class="keywordflow">break</span>; <span class=
"comment">/* opaque freed for us outside of loop. */</span>
05642 
05643                 <span class="keywordflow">if</span> (opaque != NULL) {
05644                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05645                 }
05646                 <span class="keywordflow">return</span> 0;
05647             }
05648 
05649             <span class="comment">/*  We have *at least* one complete packet in the buffer now.  If</span>
05650 <span class="comment">                we have possibly more than one packet, we must copy the opaque</span>
05651 <span class="comment">                pointer because we may need to reuse it for a later packet.  */</span>
05652 
05653             <span class="keywordflow">if</span> (pdulen &lt; isp-&gt;packet_len) {
05654                 <span class="keywordflow">if</span> (olength &gt; 0 &amp;&amp; opaque != NULL) {
05655                     ocopy = malloc(olength);
05656                     <span class="keywordflow">if</span> (ocopy != NULL) {
05657                         memcpy(ocopy, opaque, olength);
05658                     }
05659                 }
05660             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pdulen == isp-&gt;packet_len) {
05661                 <span class="comment">/*  Common case -- exactly one packet.  No need to copy the</span>
05662 <span class="comment">                    opaque pointer.  */</span>
05663                 ocopy = opaque;
05664                 opaque = NULL;
05665             }
05666 
05667             <span class="keywordflow">if</span> ((rc = _sess_process_packet(sessp, sp, isp, transport,
05668                                            ocopy, ocopy?olength:0, pptr,
05669                                            pdulen))) {
05670                 <span class="comment">/*</span>
05671 <span class="comment">                 * Something went wrong while processing this packet -- set the</span>
05672 <span class="comment">                 * errno.  </span>
05673 <span class="comment">                 */</span>
05674                 <span class="keywordflow">if</span> (sp-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a> != 0) {
05675                     SET_SNMP_ERROR(sp-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
05676                 }
05677             }
05678 
05679             <span class="comment">/*  ocopy has been free()d by _sess_process_packet by this point,</span>
05680 <span class="comment">                so set it to NULL.  */</span>
05681 
05682             ocopy = NULL;
05683 
05684             <span class="comment">/*  Step past the packet we've just dealt with.  */</span>
05685 
05686             pptr += pdulen;
05687             isp-&gt;packet_len -= pdulen;
05688         }
05689 
05690         <span class="comment">/*  If we had more than one packet, then we were working with copies</span>
05691 <span class="comment">            of the opaque pointer, so we still need to free() the opaque</span>
05692 <span class="comment">            pointer itself.  */</span>
05693 
05694         <span class="keywordflow">if</span> (opaque != NULL) {
05695             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(opaque);
05696         }
05697 
05698         <span class="keywordflow">if</span> (isp-&gt;packet_len &gt;= MAXIMUM_PACKET_SIZE) {
05699             <span class="comment">/*</span>
05700 <span class="comment">             * Obviously this should never happen!  </span>
05701 <span class="comment">             */</span>
05702             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
05703                      <span class="stringliteral">"too large packet_len = %d, dropping connection %d\n"</span>,
05704                      isp-&gt;packet_len, transport-&gt;sock);
05705             transport-&gt;f_close(transport);
05707             <span class="keywordflow">return</span> -1;
05708         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isp-&gt;packet_len == 0) {
05709             <span class="comment">/*</span>
05710 <span class="comment">             * This is good: it means the packet buffer contained an integral</span>
05711 <span class="comment">             * number of PDUs, so we don't have to save any data for next</span>
05712 <span class="comment">             * time.  We can free() the buffer now to keep the memory</span>
05713 <span class="comment">             * footprint down.</span>
05714 <span class="comment">             */</span>
05715             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(isp-&gt;packet);
05716             isp-&gt;packet = NULL;
05717             isp-&gt;packet_size = 0;
05718             isp-&gt;packet_len = 0;
05719             <span class="keywordflow">return</span> rc;
05720         }
05721 
05722         <span class="comment">/*</span>
05723 <span class="comment">         * If we get here, then there is a partial packet of length</span>
05724 <span class="comment">         * isp-&gt;packet_len bytes starting at pptr left over.  Move that to the</span>
05725 <span class="comment">         * start of the buffer, and then realloc() the buffer down to size to</span>
05726 <span class="comment">         * reduce the memory footprint.  </span>
05727 <span class="comment">         */</span>
05728 
05729         memmove(isp-&gt;packet, pptr, isp-&gt;packet_len);
05730         DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"end: memmove(%p, %p, %d); realloc(%p, %d)\n"</span>,
05731                     isp-&gt;packet, pptr, isp-&gt;packet_len, isp-&gt;packet,
05732                     isp-&gt;packet_len));
05733 
05734         <span class="keywordflow">if</span> ((rxbuf = realloc(isp-&gt;packet, isp-&gt;packet_len)) == NULL) {
05735             <span class="comment">/*</span>
05736 <span class="comment">             * I don't see why this should ever fail, but it's not a big deal.</span>
05737 <span class="comment">             */</span>
05738             DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"realloc() failed\n"</span>));
05739         } <span class="keywordflow">else</span> {
05740             DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"realloc() okay, old buffer %p, new %p\n"</span>,
05741                         isp-&gt;packet, rxbuf));
05742             isp-&gt;packet = rxbuf;
05743             isp-&gt;packet_size = isp-&gt;packet_len;
05744         }
05745         <span class="keywordflow">return</span> rc;
05746     } <span class="keywordflow">else</span> {
05747         rc = _sess_process_packet(sessp, sp, isp, transport, opaque,
05748                                   olength, rxbuf, length);
05749         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(rxbuf);
05750         <span class="keywordflow">return</span> rc;
05751     }
05752 }
05753 
05754 
05755 
05756 <span class="comment">/*</span>
05757 <span class="comment"> * returns 0 if success, -1 if fail </span>
05758 <span class="comment"> */</span>
05759 <span class="keywordtype">int</span>
05760 snmp_sess_read(<span class="keywordtype">void</span> *sessp, fd_set * fdset)
05761 {
05762     <span class="keyword">struct </span>session_list *psl;
05763     netsnmp_session *pss;
05764     <span class="keywordtype">int</span>             rc;
05765 
05766     rc = <a class="code" href="group__library.html#ga96">_sess_read</a>(sessp, fdset);
05767     psl = (<span class="keyword">struct </span>session_list *) sessp;
05768     pss = psl-&gt;session;
05769     <span class="keywordflow">if</span> (rc &amp;&amp; pss-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a>) {
05770         SET_SNMP_ERROR(pss-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a>);
05771     }
05772     <span class="keywordflow">return</span> rc;
05773 }
05774 
05775 
05776 <span class="comment">/*</span>
05777 <span class="comment"> * Returns info about what snmp requires from a select statement.</span>
05778 <span class="comment"> * numfds is the number of fds in the list that are significant.</span>
05779 <span class="comment"> * All file descriptors opened for SNMP are OR'd into the fdset.</span>
05780 <span class="comment"> * If activity occurs on any of these file descriptors, snmp_read</span>
05781 <span class="comment"> * should be called with that file descriptor set</span>
05782 <span class="comment"> *</span>
05783 <span class="comment"> * The timeout is the latest time that SNMP can wait for a timeout.  The</span>
05784 <span class="comment"> * select should be done with the minimum time between timeout and any other</span>
05785 <span class="comment"> * timeouts necessary.  This should be checked upon each invocation of select.</span>
05786 <span class="comment"> * If a timeout is received, snmp_timeout should be called to check if the</span>
05787 <span class="comment"> * timeout was for SNMP.  (snmp_timeout is idempotent)</span>
05788 <span class="comment"> *</span>
05789 <span class="comment"> * The value of block indicates how the timeout value is interpreted.</span>
05790 <span class="comment"> * If block is true on input, the timeout value will be treated as undefined,</span>
05791 <span class="comment"> * but it must be available for setting in snmp_select_info.  On return,</span>
05792 <span class="comment"> * block is set to true if the value returned for timeout is undefined;</span>
05793 <span class="comment"> * when block is set to false, timeout may be used as a parmeter to 'select'.</span>
05794 <span class="comment"> *</span>
05795 <span class="comment"> * snmp_select_info returns the number of open sockets.  (i.e. The number of</span>
05796 <span class="comment"> * sessions open)</span>
05797 <span class="comment"> */</span>
05798 
05799 <span class="keywordtype">int</span>
05800 snmp_select_info(<span class="keywordtype">int</span> *numfds,
05801                  fd_set * fdset, <span class="keyword">struct</span> timeval *timeout, <span class=
"keywordtype">int</span> *block)
05802     <span class="comment">/*</span>
05803 <span class="comment">     * input:  set to 1 if input timeout value is undefined  </span>
05804 <span class="comment">     * set to 0 if input timeout value is defined    </span>
05805 <span class="comment">     * output: set to 1 if output timeout value is undefined </span>
05806 <span class="comment">     * set to 0 if output rimeout vlaue id defined   </span>
05807 <span class="comment">     */</span>
05808 {
05809     <span class="keywordflow">return</span> snmp_sess_select_info((<span class=
"keywordtype">void</span> *) 0, numfds, fdset, timeout,
05810                                  block);
05811 }
05812 
05813 <span class="comment">/*</span>
05814 <span class="comment"> * Same as snmp_select_info, but works just one session. </span>
05815 <span class="comment"> */</span>
05816 <span class="keywordtype">int</span>
05817 snmp_sess_select_info(<span class="keywordtype">void</span> *sessp,
05818                       <span class="keywordtype">int</span> *numfds,
05819                       fd_set * fdset, <span class="keyword">struct</span> timeval *timeout, <span class=
"keywordtype">int</span> *block)
05820 {
05821     <span class="keyword">struct </span>session_list *slptest = (<span class="keyword">struct </span>session_list *) sessp;
05822     <span class="keyword">struct </span>session_list *slp, *next = NULL;
05823     netsnmp_request_list *rp;
05824     <span class="keyword">struct </span>timeval  now, earliest, delta;
05825     <span class="keywordtype">int</span>             active = 0, requests = 0;
05826     <span class="keywordtype">int</span>             next_alarm = 0;
05827 
05828     timerclear(&amp;earliest);
05829 
05830     <span class="comment">/*</span>
05831 <span class="comment">     * For each request outstanding, add its socket to the fdset,</span>
05832 <span class="comment">     * and if it is the earliest timeout to expire, mark it as lowest.</span>
05833 <span class="comment">     * If a single session is specified, do just for that session.</span>
05834 <span class="comment">     */</span>
05835 
05836     <span class="keywordflow">if</span> (sessp) {
05837         slp = slptest;
05838     } <span class="keywordflow">else</span> {
05839         slp = Sessions;
05840     }
05841 
05842     DEBUGMSGTL((<span class="stringliteral">"sess_select"</span>, <span class="stringliteral">"for %s session%s: "</span>,
05843                 sessp ? <span class="stringliteral">"single"</span> : <span class=
"stringliteral">"all"</span>, sessp ? <span class="stringliteral">""</span> : <span class="stringliteral">"s"</span>));
05844 
05845     <span class="keywordflow">for</span> (; slp; slp = next) {
05846         next = slp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
05847 
05848         <span class="keywordflow">if</span> (slp-&gt;transport == NULL) {
05849             <span class="comment">/*</span>
05850 <span class="comment">             * Close in progress -- skip this one.  </span>
05851 <span class="comment">             */</span>
05852             DEBUGMSG((<span class="stringliteral">"sess_select"</span>, <span class="stringliteral">"skip "</span>));
05853             <span class="keywordflow">continue</span>;
05854         }
05855 
05856         <span class="keywordflow">if</span> (slp-&gt;transport-&gt;sock == -1) {
05857             <span class="comment">/*</span>
05858 <span class="comment">             * This session was marked for deletion.  </span>
05859 <span class="comment">             */</span>
05860             DEBUGMSG((<span class="stringliteral">"sess_select"</span>, <span class="stringliteral">"delete\n"</span>));
05861             <span class="keywordflow">if</span> (sessp == NULL) {
05862                 snmp_close(slp-&gt;session);
05863             } <span class="keywordflow">else</span> {
05864                 snmp_sess_close(slp);
05865             }
05866             DEBUGMSGTL((<span class="stringliteral">"sess_select"</span>, <span class=
"stringliteral">"for %s session%s: "</span>,
05867                         sessp ? <span class="stringliteral">"single"</span> : <span class=
"stringliteral">"all"</span>, sessp ? <span class="stringliteral">""</span> : <span class="stringliteral">"s"</span>));
05868             <span class="keywordflow">continue</span>;
05869         }
05870 
05871         DEBUGMSG((<span class="stringliteral">"sess_select"</span>, <span class=
"stringliteral">"%d "</span>, slp-&gt;transport-&gt;sock));
05872         <span class="keywordflow">if</span> ((slp-&gt;transport-&gt;sock + 1) &gt; *numfds) {
05873             *numfds = (slp-&gt;transport-&gt;sock + 1);
05874         }
05875 
05876         FD_SET(slp-&gt;transport-&gt;sock, fdset);
05877         <span class="keywordflow">if</span> (slp-&gt;internal != NULL &amp;&amp; slp-&gt;internal-&gt;requests) {
05878             <span class="comment">/*</span>
05879 <span class="comment">             * Found another session with outstanding requests.  </span>
05880 <span class="comment">             */</span>
05881             requests++;
05882             <span class="keywordflow">for</span> (rp = slp-&gt;internal-&gt;requests; rp; rp = rp-&gt;next_request) {
05883                 <span class="keywordflow">if</span> ((!timerisset(&amp;earliest)
05884                      || (timercmp(&amp;rp-&gt;expire, &amp;earliest, &lt;)))) {
05885                     earliest = rp-&gt;expire;
05886                     DEBUGMSG((<span class="stringliteral">"verbose:sess_select"</span>,<span class=
"stringliteral">"(to in %d.%d sec) "</span>,
05887                                earliest.tv_sec, earliest.tv_usec));
05888                 }
05889             }
05890         }
05891 
05892         active++;
05893         <span class="keywordflow">if</span> (sessp) {
05894             <span class="comment">/*</span>
05895 <span class="comment">             * Single session processing.  </span>
05896 <span class="comment">             */</span>
05897             <span class="keywordflow">break</span>;
05898         }
05899     }
05900     DEBUGMSG((<span class="stringliteral">"sess_select"</span>, <span class="stringliteral">"\n"</span>));
05901 
05902     <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ALARM_DONT_USE_SIG)) {
05903         next_alarm = get_next_alarm_delay_time(&amp;delta);
05904         DEBUGMSGT((<span class="stringliteral">"sess_select"</span>,<span class=
"stringliteral">"next alarm %d.%d sec\n"</span>,
05905                    delta.tv_sec, delta.tv_usec));
05906     }
05907     <span class="keywordflow">if</span> (next_alarm == 0 &amp;&amp; requests == 0) {
05908         <span class="comment">/*</span>
05909 <span class="comment">         * If none are active, skip arithmetic.  </span>
05910 <span class="comment">         */</span>
05911         DEBUGMSGT((<span class="stringliteral">"sess_select"</span>,<span class=
"stringliteral">"blocking:no session requests or alarms.\n"</span>));
05912         *block = 1; <span class="comment">/* can block - timeout value is undefined if no requests */</span>
05913         <span class="keywordflow">return</span> active;
05914     }
05915 
05916     <span class="comment">/*</span>
05917 <span class="comment">     * * Now find out how much time until the earliest timeout.  This</span>
05918 <span class="comment">     * * transforms earliest from an absolute time into a delta time, the</span>
05919 <span class="comment">     * * time left until the select should timeout.</span>
05920 <span class="comment">     */</span>
05921     gettimeofday(&amp;now, (<span class="keyword">struct</span> timezone *) 0);
05922     <span class="comment">/*</span>
05923 <span class="comment">     * Now = now;</span>
05924 <span class="comment">     */</span>
05925 
05926     <span class="keywordflow">if</span> (next_alarm) {
05927         delta.tv_sec += now.tv_sec;
05928         delta.tv_usec += now.tv_usec;
05929         <span class="keywordflow">while</span> (delta.tv_usec &gt;= 1000000) {
05930             delta.tv_usec -= 1000000;
05931             delta.tv_sec += 1;
05932         }
05933         <span class="keywordflow">if</span> (!timerisset(&amp;earliest) ||
05934             ((earliest.tv_sec &gt; delta.tv_sec) ||
05935              ((earliest.tv_sec == delta.tv_sec) &amp;&amp;
05936               (earliest.tv_usec &gt; delta.tv_usec)))) {
05937             earliest.tv_sec = delta.tv_sec;
05938             earliest.tv_usec = delta.tv_usec;
05939         }
05940     }
05941 
05942     <span class="keywordflow">if</span> (earliest.tv_sec &lt; now.tv_sec) {
05943         DEBUGMSGT((<span class="stringliteral">"verbose:sess_select"</span>,<span class=
"stringliteral">"timer overdue\n"</span>));
05944         earliest.tv_sec = 0;
05945         earliest.tv_usec = 0;
05946     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (earliest.tv_sec == now.tv_sec) {
05947         earliest.tv_sec = 0;
05948         earliest.tv_usec = (earliest.tv_usec - now.tv_usec);
05949         <span class="keywordflow">if</span> (earliest.tv_usec &lt; 0) {
05950             earliest.tv_usec = 100;
05951         }
05952         DEBUGMSGT((<span class="stringliteral">"verbose:sess_select"</span>,<span class=
"stringliteral">"timer due *real* soon. %d usec\n"</span>,
05953                    earliest.tv_usec));
05954     } <span class="keywordflow">else</span> {
05955         earliest.tv_sec = (earliest.tv_sec - now.tv_sec);
05956         earliest.tv_usec = (earliest.tv_usec - now.tv_usec);
05957         <span class="keywordflow">if</span> (earliest.tv_usec &lt; 0) {
05958             earliest.tv_sec--;
05959             earliest.tv_usec = (1000000L + earliest.tv_usec);
05960         }
05961         DEBUGMSGT((<span class="stringliteral">"verbose:sess_select"</span>,<span class=
"stringliteral">"timer due in %d.%d sec\n"</span>,
05962                    earliest.tv_sec, earliest.tv_usec));
05963     }
05964 
05965     <span class="comment">/*</span>
05966 <span class="comment">     * if it was blocking before or our delta time is less, reset timeout </span>
05967 <span class="comment">     */</span>
05968     <span class="keywordflow">if</span> ((*block || (timercmp(&amp;earliest, timeout, &lt;)))) {
05969         DEBUGMSGT((<span class="stringliteral">"verbose:sess_select"</span>,
05970                    <span class="stringliteral">"setting timer to %d.%d sec, clear block (was %d)\n"</span>,
05971                    earliest.tv_sec, earliest.tv_usec, *block));
05972         *timeout = earliest;
05973         *block = 0;
05974     }
05975     <span class="keywordflow">return</span> active;
05976 }
05977 
05978 <span class="comment">/*</span>
05979 <span class="comment"> * snmp_timeout should be called whenever the timeout from snmp_select_info</span>
05980 <span class="comment"> * expires, but it is idempotent, so snmp_timeout can be polled (probably a</span>
05981 <span class="comment"> * cpu expensive proposition).  snmp_timeout checks to see if any of the</span>
05982 <span class="comment"> * sessions have an outstanding request that has timed out.  If it finds one</span>
05983 <span class="comment"> * (or more), and that pdu has more retries available, a new packet is formed</span>
05984 <span class="comment"> * from the pdu and is resent.  If there are no more retries available, the</span>
05985 <span class="comment"> *  callback for the session is used to alert the user of the timeout.</span>
05986 <span class="comment"> */</span>
05987 <span class="keywordtype">void</span>
05988 snmp_timeout(<span class="keywordtype">void</span>)
05989 {
05990     <span class="keyword">struct </span>session_list *slp;
05991     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
05992     <span class="keywordflow">for</span> (slp = Sessions; slp; slp = slp-&gt;next) {
05993         snmp_sess_timeout((<span class="keywordtype">void</span> *) slp);
05994     }
05995     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
05996 }
05997 
05998 <span class="keyword">static</span> <span class="keywordtype">int</span>
05999 snmp_resend_request(<span class="keyword">struct</span> session_list *slp, netsnmp_request_list *rp,
06000                     <span class="keywordtype">int</span> incr_retries)
06001 {
06002     <span class="keyword">struct </span>snmp_internal_session *isp;
06003     netsnmp_session *sp;
06004     netsnmp_transport *transport;
06005     u_char         *pktbuf = NULL, *packet = NULL;
06006     size_t          pktbuf_len = 0, offset = 0, length = 0;
06007     <span class="keyword">struct </span>timeval  tv, now;
06008     <span class="keywordtype">int</span>             result = 0;
06009 
06010     sp = slp-&gt;session;
06011     isp = slp-&gt;internal;
06012     transport = slp-&gt;transport;
06013     <span class="keywordflow">if</span> (!sp || !isp || !transport) {
06014         DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"resend fail: closing...\n"</span>));
06015         <span class="keywordflow">return</span> 0;
06016     }
06017 
06018     <span class="keywordflow">if</span> ((pktbuf = malloc(2048)) == NULL) {
06019         DEBUGMSGTL((<span class="stringliteral">"sess_resend"</span>,
06020                     <span class="stringliteral">"couldn't malloc initial packet buffer\n"</span>));
06021         <span class="keywordflow">return</span> 0;
06022     } <span class="keywordflow">else</span> {
06023         pktbuf_len = 2048;
06024     }
06025 
06026     <span class="keywordflow">if</span> (incr_retries) {
06027         rp-&gt;<a class="code" href="structsnmp__session.html#o1">retries</a>++;
06028     }
06029 
06030     <span class="comment">/*</span>
06031 <span class="comment">     * Always increment msgId for resent messages.  </span>
06032 <span class="comment">     */</span>
06033     rp-&gt;pdu-&gt;msgid = rp-&gt;message_id = snmp_get_next_msgid();
06034 
06035     <span class="keywordflow">if</span> (isp-&gt;hook_realloc_build) {
06036         result = isp-&gt;hook_realloc_build(sp, rp-&gt;pdu,
06037                                          &amp;pktbuf, &amp;pktbuf_len, &amp;offset);
06038 
06039         packet = pktbuf;
06040         length = offset;
06041     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isp-&gt;hook_build) {
06042         packet = pktbuf;
06043         length = pktbuf_len;
06044         result = isp-&gt;hook_build(sp, rp-&gt;pdu, pktbuf, &amp;length);
06045     } <span class="keywordflow">else</span> {
06046 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
06047         <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REVERSE_ENCODE)) {
06048             result =
06049                 snmp_build(&amp;pktbuf, &amp;pktbuf_len, &amp;offset, sp, rp-&gt;pdu);
06050             packet = pktbuf + pktbuf_len - offset;
06051             length = offset;
06052         } <span class="keywordflow">else</span> {
06053 <span class="preprocessor">#endif</span>
06054             packet = pktbuf;
06055             length = pktbuf_len;
06056             result = snmp_build(&amp;pktbuf, &amp;length, &amp;offset, sp, rp-&gt;pdu);
06057 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
06058         }
06059 <span class="preprocessor">#endif</span>
06060     }
06061 
06062     <span class="keywordflow">if</span> (result &lt; 0) {
06063         <span class="comment">/*</span>
06064 <span class="comment">         * This should never happen.  </span>
06065 <span class="comment">         */</span>
06066         DEBUGMSGTL((<span class="stringliteral">"sess_resend"</span>, <span class=
"stringliteral">"encoding failure\n"</span>));
06067         <span class="keywordflow">if</span> (pktbuf != NULL) {
06068             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
06069         }
06070         <span class="keywordflow">return</span> -1;
06071     }
06072 
06073     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DUMP_PACKET)) {
06074         <span class="keywordflow">if</span> (transport-&gt;f_fmtaddr != NULL) {
06075             <span class="keywordtype">char</span>           *str = NULL;
06076             str = transport-&gt;f_fmtaddr(transport, rp-&gt;pdu-&gt;transport_data,
06077                                        rp-&gt;pdu-&gt;transport_data_length);
06078             <span class="keywordflow">if</span> (str != NULL) {
06079                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_DEBUG, <span class=
"stringliteral">"\nResending %d bytes to %s\n"</span>, length,
06080                          str);
06081                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(str);
06082             } <span class="keywordflow">else</span> {
06083                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_DEBUG, <span class=
"stringliteral">"\nResending %d bytes to &lt;UNKNOWN&gt;\n"</span>,
06084                          length);
06085             }
06086         }
06087         xdump(packet, length, <span class="stringliteral">""</span>);
06088     }
06089 
06090     result = transport-&gt;f_send(transport, packet, length,
06091                                &amp;(rp-&gt;pdu-&gt;transport_data),
06092                                &amp;(rp-&gt;pdu-&gt;transport_data_length));
06093 
06094     <span class="comment">/*</span>
06095 <span class="comment">     * We are finished with the local packet buffer, if we allocated one (due</span>
06096 <span class="comment">     * to there being no saved packet).  </span>
06097 <span class="comment">     */</span>
06098 
06099     <span class="keywordflow">if</span> (pktbuf != NULL) {
06100         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(pktbuf);
06101         pktbuf = packet = NULL;
06102     }
06103 
06104     <span class="keywordflow">if</span> (result &lt; 0) {
06105         sp-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = SNMPERR_BAD_SENDTO;
06106         sp-&gt;<a class="code" href="structsnmp__session.html#o13">s_errno</a> = errno;
06107         snmp_set_detail(strerror(errno));
06108         <span class="keywordflow">return</span> -1;
06109     } <span class="keywordflow">else</span> {
06110         gettimeofday(&amp;now, (<span class="keyword">struct</span> timezone *) 0);
06111         tv = now;
06112         rp-&gt;time = tv;
06113         tv.tv_usec += rp-&gt;<a class="code" href="structsnmp__session.html#o2">timeout</a>;
06114         tv.tv_sec += tv.tv_usec / 1000000L;
06115         tv.tv_usec %= 1000000L;
06116         rp-&gt;expire = tv;
06117     }
06118     <span class="keywordflow">return</span> 0;
06119 }
06120 
06121 
06122 
06123 <span class="keywordtype">void</span>
06124 snmp_sess_timeout(<span class="keywordtype">void</span> *sessp)
06125 {
06126     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
06127     netsnmp_session *sp;
06128     <span class="keyword">struct </span>snmp_internal_session *isp;
06129     netsnmp_request_list *rp, *orp = NULL, *freeme = NULL;
06130     <span class="keyword">struct </span>timeval  now;
06131     snmp_callback   callback;
06132     <span class="keywordtype">void</span>           *magic;
06133     <span class="keyword">struct </span>snmp_secmod_def *sptr;
06134 
06135     sp = slp-&gt;session;
06136     isp = slp-&gt;internal;
06137     <span class="keywordflow">if</span> (!sp || !isp) {
06138         DEBUGMSGTL((<span class="stringliteral">"sess_read"</span>, <span class=
"stringliteral">"timeout fail: closing...\n"</span>));
06139         <span class="keywordflow">return</span>;
06140     }
06141 
06142     gettimeofday(&amp;now, (<span class="keyword">struct</span> timezone *) 0);
06143 
06144     <span class="comment">/*</span>
06145 <span class="comment">     * For each request outstanding, check to see if it has expired.</span>
06146 <span class="comment">     */</span>
06147     <span class="keywordflow">for</span> (rp = isp-&gt;requests; rp; rp = rp-&gt;next_request) {
06148         <span class="keywordflow">if</span> (freeme != NULL) {
06149             <span class="comment">/*</span>
06150 <span class="comment">             * frees rp's after the for loop goes on to the next_request </span>
06151 <span class="comment">             */</span>
06152             free((<span class="keywordtype">char</span> *) freeme);
06153             freeme = NULL;
06154         }
06155 
06156         <span class="keywordflow">if</span> ((timercmp(&amp;rp-&gt;expire, &amp;now, &lt;))) {
06157             <span class="keywordflow">if</span> ((sptr = find_sec_mod(rp-&gt;pdu-&gt;securityModel)) != NULL &amp;&amp;
06158                 sptr-&gt;pdu_timeout != NULL) {
06159                 <span class="comment">/*</span>
06160 <span class="comment">                 * call security model if it needs to know about this </span>
06161 <span class="comment">                 */</span>
06162                 (*sptr-&gt;pdu_timeout) (rp-&gt;pdu);
06163             }
06164 
06165             <span class="comment">/*</span>
06166 <span class="comment">             * this timer has expired </span>
06167 <span class="comment">             */</span>
06168             <span class="keywordflow">if</span> (rp-&gt;retries &gt;= sp-&gt;<a class="code" href=
"structsnmp__session.html#o1">retries</a>) {
06169                 <span class="keywordflow">if</span> (rp-&gt;callback) {
06170                     callback = rp-&gt;<a class="code" href="structsnmp__session.html#o11">callback</a>;
06171                     magic = rp-&gt;cb_data;
06172                 } <span class="keywordflow">else</span> {
06173                     callback = sp-&gt;<a class="code" href="structsnmp__session.html#o11">callback</a>;
06174                     magic = sp-&gt;<a class="code" href="structsnmp__session.html#o12">callback_magic</a>;
06175                 }
06176 
06177                 <span class="comment">/*</span>
06178 <span class="comment">                 * No more chances, delete this entry </span>
06179 <span class="comment">                 */</span>
06180                 <span class="keywordflow">if</span> (callback) {
06181                     callback(NETSNMP_CALLBACK_OP_TIMED_OUT, sp,
06182                              rp-&gt;pdu-&gt;reqid, rp-&gt;pdu, magic);
06183                 }
06184                 <span class="keywordflow">if</span> (isp-&gt;requests == rp) {
06185                     isp-&gt;requests = rp-&gt;next_request;
06186                     <span class="keywordflow">if</span> (isp-&gt;requestsEnd == rp) {
06187                         isp-&gt;requestsEnd = NULL;
06188                     }
06189                 } <span class="keywordflow">else</span> {
06190                     orp-&gt;next_request = rp-&gt;next_request;
06191                     <span class="keywordflow">if</span> (isp-&gt;requestsEnd == rp) {
06192                         isp-&gt;requestsEnd = orp;
06193                     }
06194                 }
06195                 snmp_free_pdu(rp-&gt;pdu); <span class="comment">/* FIX  rp is already free'd! */</span>
06196                 freeme = rp;
06197                 <span class="keywordflow">continue</span>;       <span class="comment">/* don't update orp below */</span>
06198             } <span class="keywordflow">else</span> {
06199                 <span class="keywordflow">if</span> (snmp_resend_request(slp, rp, TRUE)) {
06200                     <span class="keywordflow">break</span>;
06201                 }
06202             }
06203         }
06204         orp = rp;
06205     }
06206 
06207     <span class="keywordflow">if</span> (freeme != NULL) {
06208         free((<span class="keywordtype">char</span> *) freeme);
06209         freeme = NULL;
06210     }
06211 }
06212 
06213 <span class="comment">/*</span>
06214 <span class="comment"> * lexicographical compare two object identifiers.</span>
06215 <span class="comment"> * * Returns -1 if name1 &lt; name2,</span>
06216 <span class="comment"> * *          0 if name1 = name2,</span>
06217 <span class="comment"> * *          1 if name1 &gt; name2</span>
06218 <span class="comment"> * *</span>
06219 <span class="comment"> * * Caution: this method is called often by</span>
06220 <span class="comment"> * *          command responder applications (ie, agent).</span>
06221 <span class="comment"> */</span>
06222 <span class="keywordtype">int</span>
06223 snmp_oid_ncompare(<span class="keyword">const</span> oid * in_name1,
06224                   size_t len1,
06225                   <span class="keyword">const</span> oid * in_name2, size_t len2, size_t max_len)
06226 {
06227     <span class="keyword">register</span> <span class="keywordtype">int</span>    len;
06228     <span class="keyword">register</span> <span class="keyword">const</span> oid *name1 = in_name1;
06229     <span class="keyword">register</span> <span class="keyword">const</span> oid *name2 = in_name2;
06230     size_t          min_len;
06231 
06232     <span class="comment">/*</span>
06233 <span class="comment">     * len = minimum of len1 and len2 </span>
06234 <span class="comment">     */</span>
06235     <span class="keywordflow">if</span> (len1 &lt; len2)
06236         min_len = len1;
06237     <span class="keywordflow">else</span>
06238         min_len = len2;
06239 
06240     <span class="keywordflow">if</span> (min_len &gt; max_len)
06241         min_len = max_len;
06242 
06243     len = min_len;
06244 
06245     <span class="comment">/*</span>
06246 <span class="comment">     * find first non-matching OID </span>
06247 <span class="comment">     */</span>
06248     <span class="keywordflow">while</span> (len-- &gt; 0) {
06249         <span class="comment">/*</span>
06250 <span class="comment">         * these must be done in seperate comparisons, since</span>
06251 <span class="comment">         * subtracting them and using that result has problems with</span>
06252 <span class="comment">         * subids &gt; 2^31. </span>
06253 <span class="comment">         */</span>
06254         <span class="keywordflow">if</span> (*(name1) != *(name2)) {
06255             <span class="keywordflow">if</span> (*(name1) &lt; *(name2))
06256                 <span class="keywordflow">return</span> -1;
06257             <span class="keywordflow">return</span> 1;
06258         }
06259         name1++;
06260         name2++;
06261     }
06262 
06263     <span class="keywordflow">if</span> (min_len != max_len) {
06264         <span class="comment">/*</span>
06265 <span class="comment">         * both OIDs equal up to length of shorter OID </span>
06266 <span class="comment">         */</span>
06267         <span class="keywordflow">if</span> (len1 &lt; len2)
06268             <span class="keywordflow">return</span> -1;
06269         <span class="keywordflow">if</span> (len2 &lt; len1)
06270             <span class="keywordflow">return</span> 1;
06271     }
06272 
06273     <span class="keywordflow">return</span> 0;
06274 }
06275 
06283 <span class="keywordtype">int</span>
<a name="l06284" id="l06284"></a><a class="code" href="group__library.html#ga103">06284</a> <a class="code" href=
"group__library.html#ga103">snmp_oid_compare</a>(<span class="keyword">const</span> oid * in_name1,
06285                  size_t len1, <span class="keyword">const</span> oid * in_name2, size_t len2)
06286 {
06287     <span class="keyword">register</span> <span class="keywordtype">int</span>    len;
06288     <span class="keyword">register</span> <span class="keyword">const</span> oid *name1 = in_name1;
06289     <span class="keyword">register</span> <span class="keyword">const</span> oid *name2 = in_name2;
06290 
06291     <span class="comment">/*</span>
06292 <span class="comment">     * len = minimum of len1 and len2 </span>
06293 <span class="comment">     */</span>
06294     <span class="keywordflow">if</span> (len1 &lt; len2)
06295         len = len1;
06296     <span class="keywordflow">else</span>
06297         len = len2;
06298     <span class="comment">/*</span>
06299 <span class="comment">     * find first non-matching OID </span>
06300 <span class="comment">     */</span>
06301     <span class="keywordflow">while</span> (len-- &gt; 0) {
06302         <span class="comment">/*</span>
06303 <span class="comment">         * these must be done in seperate comparisons, since</span>
06304 <span class="comment">         * subtracting them and using that result has problems with</span>
06305 <span class="comment">         * subids &gt; 2^31. </span>
06306 <span class="comment">         */</span>
06307         <span class="keywordflow">if</span> (*(name1) != *(name2)) {
06308             <span class="keywordflow">if</span> (*(name1) &lt; *(name2))
06309                 <span class="keywordflow">return</span> -1;
06310             <span class="keywordflow">return</span> 1;
06311         }
06312         name1++;
06313         name2++;
06314     }
06315     <span class="comment">/*</span>
06316 <span class="comment">     * both OIDs equal up to length of shorter OID </span>
06317 <span class="comment">     */</span>
06318     <span class="keywordflow">if</span> (len1 &lt; len2)
06319         <span class="keywordflow">return</span> -1;
06320     <span class="keywordflow">if</span> (len2 &lt; len1)
06321         <span class="keywordflow">return</span> 1;
06322     <span class="keywordflow">return</span> 0;
06323 }
06324 
06332 <span class="keywordtype">int</span>
<a name="l06333" id="l06333"></a><a class="code" href="group__library.html#ga104">06333</a> <a class="code" href=
"group__library.html#ga104">netsnmp_oid_compare_ll</a>(<span class="keyword">const</span> oid * in_name1,
06334                        size_t len1, <span class="keyword">const</span> oid * in_name2, size_t len2,
06335                        size_t *offpt)
06336 {
06337     <span class="keyword">register</span> <span class="keywordtype">int</span>    len;
06338     <span class="keyword">register</span> <span class="keyword">const</span> oid *name1 = in_name1;
06339     <span class="keyword">register</span> <span class="keyword">const</span> oid *name2 = in_name2;
06340     <span class="keywordtype">int</span> initlen;
06341 
06342     <span class="comment">/*</span>
06343 <span class="comment">     * len = minimum of len1 and len2 </span>
06344 <span class="comment">     */</span>
06345     <span class="keywordflow">if</span> (len1 &lt; len2)
06346         initlen = len = len1;
06347     <span class="keywordflow">else</span>
06348         initlen = len = len2;
06349     <span class="comment">/*</span>
06350 <span class="comment">     * find first non-matching OID </span>
06351 <span class="comment">     */</span>
06352     <span class="keywordflow">while</span> (len-- &gt; 0) {
06353         <span class="comment">/*</span>
06354 <span class="comment">         * these must be done in seperate comparisons, since</span>
06355 <span class="comment">         * subtracting them and using that result has problems with</span>
06356 <span class="comment">         * subids &gt; 2^31. </span>
06357 <span class="comment">         */</span>
06358         <span class="keywordflow">if</span> (*(name1) != *(name2)) {
06359             *offpt = initlen - len;
06360             <span class="keywordflow">if</span> (*(name1) &lt; *(name2))
06361                 <span class="keywordflow">return</span> -1;
06362             <span class="keywordflow">return</span> 1;
06363         }
06364         name1++;
06365         name2++;
06366     }
06367     <span class="comment">/*</span>
06368 <span class="comment">     * both OIDs equal up to length of shorter OID </span>
06369 <span class="comment">     */</span>
06370     *offpt = initlen - len;
06371     <span class="keywordflow">if</span> (len1 &lt; len2)
06372         <span class="keywordflow">return</span> -1;
06373     <span class="keywordflow">if</span> (len2 &lt; len1)
06374         <span class="keywordflow">return</span> 1;
06375     <span class="keywordflow">return</span> 0;
06376 }
06377 
06385 <span class="keywordtype">int</span>
<a name="l06386" id="l06386"></a><a class="code" href="group__library.html#ga105">06386</a> <a class="code" href=
"group__library.html#ga105">snmp_oidtree_compare</a>(<span class="keyword">const</span> oid * in_name1,
06387                      size_t len1, <span class="keyword">const</span> oid * in_name2, size_t len2)
06388 {
06389     <span class="keywordtype">int</span>             len = ((len1 &lt; len2) ? len1 : len2);
06390 
06391     <span class="keywordflow">return</span> (<a class="code" href=
"group__library.html#ga103">snmp_oid_compare</a>(in_name1, len, in_name2, len));
06392 }
06393 
06404 <span class="keywordtype">int</span>
<a name="l06405" id="l06405"></a><a class="code" href="group__library.html#ga106">06405</a> <a class="code" href=
"group__library.html#ga106">netsnmp_oid_equals</a>(<span class="keyword">const</span> oid * in_name1,
06406                    size_t len1, <span class="keyword">const</span> oid * in_name2, size_t len2)
06407 {
06408     <span class="keyword">register</span> <span class="keyword">const</span> oid *name1 = in_name1;
06409     <span class="keyword">register</span> <span class="keyword">const</span> oid *name2 = in_name2;
06410     <span class="keyword">register</span> <span class="keywordtype">int</span>    len = len1;
06411 
06412     <span class="comment">/*</span>
06413 <span class="comment">     * len = minimum of len1 and len2 </span>
06414 <span class="comment">     */</span>
06415     <span class="keywordflow">if</span> (len1 != len2)
06416         <span class="keywordflow">return</span> 1;
06417     <span class="comment">/*</span>
06418 <span class="comment">     * find first non-matching OID </span>
06419 <span class="comment">     */</span>
06420     <span class="keywordflow">while</span> (len-- &gt; 0) {
06421         <span class="comment">/*</span>
06422 <span class="comment">         * these must be done in seperate comparisons, since</span>
06423 <span class="comment">         * subtracting them and using that result has problems with</span>
06424 <span class="comment">         * subids &gt; 2^31. </span>
06425 <span class="comment">         */</span>
06426         <span class="keywordflow">if</span> (*(name1++) != *(name2++))
06427             <span class="keywordflow">return</span> 1;
06428     }
06429     <span class="keywordflow">return</span> 0;
06430 }
06431 
06440 <span class="keywordtype">int</span>
<a name="l06441" id="l06441"></a><a class="code" href="group__library.html#ga107">06441</a> <a class="code" href=
"group__library.html#ga107">netsnmp_oid_is_subtree</a>(<span class="keyword">const</span> oid * in_name1,
06442                        size_t len1, <span class="keyword">const</span> oid * in_name2, size_t len2)
06443 {
06444     <span class="keywordflow">if</span> (len1 &gt; len2)
06445         <span class="keywordflow">return</span> 1;
06446 
06447     <span class="keywordflow">if</span> (memcmp(in_name1, in_name2, len1 * <span class="keyword">sizeof</span>(oid)))
06448         <span class="keywordflow">return</span> 1;
06449 
06450     <span class="keywordflow">return</span> 0;
06451 }
06452 
06460 <span class="keywordtype">int</span>
<a name="l06461" id="l06461"></a><a class="code" href="group__library.html#ga108">06461</a> <a class="code" href=
"group__library.html#ga108">netsnmp_oid_find_prefix</a>(<span class="keyword">const</span> oid * in_name1, size_t len1,
06462                         <span class="keyword">const</span> oid * in_name2, size_t len2)
06463 {
06464     <span class="keywordtype">int</span> i;
06465     size_t min_size;
06466 
06467     <span class="keywordflow">if</span> (!in_name1 || !in_name2)
06468         <span class="keywordflow">return</span> -1;
06469 
06470     min_size = <a class="code" href="group__util.html#ga46">SNMP_MIN</a>(len1, len2);
06471     <span class="keywordflow">for</span>(i = 0; i &lt; (int)min_size; i++) {
06472         <span class="keywordflow">if</span> (in_name1[i] != in_name2[i])
06473             <span class="keywordflow">return</span> i + 1;
06474     }
06475     <span class="keywordflow">return</span> 0;
06476 }
06477 
06478 <span class="keyword">static</span> <span class="keywordtype">int</span> _check_range(<span class=
"keyword">struct</span> tree *tp, <span class="keywordtype">long</span> ltmp, <span class="keywordtype">int</span> *resptr,
06479                         <span class="keyword">const</span> <span class="keywordtype">char</span> *errmsg)
06480 {
06481     <span class="keywordtype">int</span> check = !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
06482                                         NETSNMP_DS_LIB_DONT_CHECK_RANGE);
06483   
06484     <span class="keywordflow">if</span> (check &amp;&amp; tp &amp;&amp; tp-&gt;ranges) {
06485         <span class="keyword">struct </span>range_list *rp = tp-&gt;ranges;
06486         <span class="keywordflow">while</span> (rp) {
06487             <span class="keywordflow">if</span> (rp-&gt;low &lt;= ltmp &amp;&amp; ltmp &lt;= rp-&gt;high) <span class=
"keywordflow">break</span>;
06488             rp = rp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
06489         }
06490         <span class="keywordflow">if</span> (!rp) {
06491             *resptr = SNMPERR_RANGE;
06492             snmp_set_detail(errmsg);
06493             <span class="keywordflow">return</span> 0;
06494         }
06495     }
06496     <span class="keywordflow">return</span> 1;
06497 }
06498         
06499 
06500 <span class="comment">/*</span>
06501 <span class="comment"> * Add a variable with the requested name to the end of the list of</span>
06502 <span class="comment"> * variables for this pdu.</span>
06503 <span class="comment"> */</span>
06504 <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *
06505 snmp_pdu_add_variable(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
06506                       <span class="keyword">const</span> oid * name,
06507                       size_t name_length,
06508                       u_char type, <span class="keyword">const</span> u_char * value, size_t len)
06509 {
06510     <span class="keywordflow">return</span> snmp_varlist_add_variable(&amp;pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>, name, name_length,
06511                                      type, value, len);
06512 }
06513 
06514 <span class="comment">/*</span>
06515 <span class="comment"> * Add a variable with the requested name to the end of the list of</span>
06516 <span class="comment"> * variables for this pdu.</span>
06517 <span class="comment"> */</span>
06518 <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *
06519 snmp_varlist_add_variable(<a class="code" href="structvariable__list.html">netsnmp_variable_list</a> ** varlist,
06520                           <span class="keyword">const</span> oid * name,
06521                           size_t name_length,
06522                           u_char type, <span class="keyword">const</span> u_char * value, size_t len)
06523 {
06524     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vars, *vtmp;
06525     <span class="keywordtype">int</span> rc;
06526 
06527     <span class="keywordflow">if</span> (varlist == NULL)
06528         <span class="keywordflow">return</span> NULL;
06529 
06530     vars = <a class="code" href="group__util.html#ga39">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a>);
06531     <span class="keywordflow">if</span> (vars == NULL)
06532         <span class="keywordflow">return</span> NULL;
06533 
06534     vars-&gt;<a class="code" href="structvariable__list.html#o3">type</a> = type;
06535 
06536     rc = <a class="code" href="group__snmp__client.html#ga25">snmp_set_var_value</a>( vars, value, len );
06537     <span class="keywordflow">if</span> (( 0 != rc ) ||
06538         (name != NULL &amp;&amp; snmp_set_var_objid(vars, name, name_length))) {
06539         snmp_free_var(vars);
06540         <span class="keywordflow">return</span> (0);
06541     }
06542 
06543     <span class="comment">/*</span>
06544 <span class="comment">     * put only qualified variable onto varlist </span>
06545 <span class="comment">     */</span>
06546     <span class="keywordflow">if</span> (*varlist == NULL) {
06547         *varlist = vars;
06548     } <span class="keywordflow">else</span> {
06549         <span class="keywordflow">for</span> (vtmp = *varlist; vtmp-&gt;<a class="code" href=
"structvariable__list.html#o0">next_variable</a>;
06550              vtmp = vtmp-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>);
06551 
06552         vtmp-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a> = vars;
06553     }
06554 
06555     <span class="keywordflow">return</span> vars;
06556 }
06557 
06558 
06559 
06560 <span class="comment">/*</span>
06561 <span class="comment"> * Add a variable with the requested name to the end of the list of</span>
06562 <span class="comment"> * variables for this pdu.</span>
06563 <span class="comment"> * Returns:</span>
06564 <span class="comment"> * may set these error types :</span>
06565 <span class="comment"> * SNMPERR_RANGE - type, value, or length not found or out of range</span>
06566 <span class="comment"> * SNMPERR_VALUE - value is not correct</span>
06567 <span class="comment"> * SNMPERR_BAD_NAME - name is not found</span>
06568 <span class="comment"> *</span>
06569 <span class="comment"> * returns 0 if success, error if failure.</span>
06570 <span class="comment"> */</span>
06571 <span class="keywordtype">int</span>
06572 snmp_add_var(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
06573              <span class="keyword">const</span> oid * name, size_t name_length, <span class=
"keywordtype">char</span> type, <span class="keyword">const</span> <span class="keywordtype">char</span> *value)
06574 {
06575     <span class="keywordtype">char</span>           *st;
06576     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp;
06577     <span class="keywordtype">char</span>           *ecp, *vp;
06578     <span class="keywordtype">int</span>             result = SNMPERR_SUCCESS;
06579 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06580     <span class="keywordtype">int</span>             check = !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
06581                                              NETSNMP_DS_LIB_DONT_CHECK_RANGE);
06582     <span class="keywordtype">int</span>             do_hint = !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
06583                                              NETSNMP_DS_LIB_NO_DISPLAY_HINT);
06584     u_char         *hintptr;
06585     <span class="keyword">struct </span>tree    *tp;
06586 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06587     u_char         *buf = NULL;
06588     <span class="keyword">const</span> u_char   *buf_ptr = NULL;
06589     size_t          buf_len = 0, value_len = 0, tint;
06590     in_addr_t       atmp;
06591     <span class="keywordtype">long</span>            ltmp;
06592     <span class="keywordtype">int</span>             itmp;
06593     <span class="keyword">struct </span>enum_list *ep;
06594 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
06595     <span class="keywordtype">double</span>          dtmp;
06596     <span class="keywordtype">float</span>           ftmp;
06597 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
06598     <span class="keyword">struct </span>counter64 c64tmp;
06599 
06600 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06601     tp = <a class="code" href="group__mib__utilities.html#ga84">get_tree</a>(name, name_length, <a class="code" href=
"group__mib__utilities.html#ga46">get_tree_head</a>());
06602     <span class="keywordflow">if</span> (!tp || !tp-&gt;type || tp-&gt;type &gt; TYPE_SIMPLE_LAST) {
06603         check = 0;
06604     }
06605     <span class="keywordflow">if</span> (!(tp &amp;&amp; tp-&gt;hint))
06606         do_hint = 0;
06607 
06608     <span class="keywordflow">if</span> (tp &amp;&amp; type == <span class="charliteral">'='</span>) {
06609         <span class="comment">/*</span>
06610 <span class="comment">         * generic assignment - let the tree node decide value format </span>
06611 <span class="comment">         */</span>
06612         <span class="keywordflow">switch</span> (tp-&gt;type) {
06613         <span class="keywordflow">case</span> TYPE_INTEGER:
06614         <span class="keywordflow">case</span> TYPE_INTEGER32:
06615             type = <span class="charliteral">'i'</span>;
06616             <span class="keywordflow">break</span>;
06617         <span class="keywordflow">case</span> TYPE_GAUGE:
06618         <span class="keywordflow">case</span> TYPE_UNSIGNED32:
06619             type = <span class="charliteral">'u'</span>;
06620             <span class="keywordflow">break</span>;
06621         <span class="keywordflow">case</span> TYPE_UINTEGER:
06622             type = <span class="charliteral">'3'</span>;
06623             <span class="keywordflow">break</span>;
06624         <span class="keywordflow">case</span> TYPE_COUNTER:
06625             type = <span class="charliteral">'c'</span>;
06626             <span class="keywordflow">break</span>;
06627         <span class="keywordflow">case</span> TYPE_COUNTER64:
06628             type = <span class="charliteral">'C'</span>;
06629             <span class="keywordflow">break</span>;
06630         <span class="keywordflow">case</span> TYPE_TIMETICKS:
06631             type = <span class="charliteral">'t'</span>;
06632             <span class="keywordflow">break</span>;
06633         <span class="keywordflow">case</span> TYPE_OCTETSTR:
06634             type = <span class="charliteral">'s'</span>;
06635             <span class="keywordflow">break</span>;
06636         <span class="keywordflow">case</span> TYPE_BITSTRING:
06637             type = <span class="charliteral">'b'</span>;
06638             <span class="keywordflow">break</span>;
06639         <span class="keywordflow">case</span> TYPE_IPADDR:
06640             type = <span class="charliteral">'a'</span>;
06641             <span class="keywordflow">break</span>;
06642         <span class="keywordflow">case</span> TYPE_OBJID:
06643             type = <span class="charliteral">'o'</span>;
06644             <span class="keywordflow">break</span>;
06645         }
06646     }
06647 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06648 
06649     <span class="keywordflow">switch</span> (type) {
06650     <span class="keywordflow">case</span> <span class="charliteral">'i'</span>:
06651 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06652         <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_INTEGER
06653             &amp;&amp; tp-&gt;type != TYPE_INTEGER32) {
06654             value = <span class="stringliteral">"INTEGER"</span>;
06655             result = SNMPERR_VALUE;
06656             <span class="keywordflow">goto</span> type_error;
06657         }
06658 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06659         <span class="keywordflow">if</span> (!*value)
06660             <span class="keywordflow">goto</span> fail;
06661         ltmp = strtol(value, &amp;ecp, 10);
06662         <span class="keywordflow">if</span> (*ecp) {
06663 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06664             ep = tp ? tp-&gt;enums : NULL;
06665             <span class="keywordflow">while</span> (ep) {
06666                 <span class="keywordflow">if</span> (strcmp(value, ep-&gt;label) == 0) {
06667                     ltmp = ep-&gt;value;
06668                     <span class="keywordflow">break</span>;
06669                 }
06670                 ep = ep-&gt;next;
06671             }
06672             <span class="keywordflow">if</span> (!ep) {
06673 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06674                 result = SNMPERR_BAD_NAME;
06675                 snmp_set_detail(value);
06676                 <span class="keywordflow">break</span>;
06677 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06678             }
06679 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06680         }
06681 
06682 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06683         <span class="keywordflow">if</span> (!_check_range(tp, ltmp, &amp;result, value))
06684             <span class="keywordflow">break</span>;
06685 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06686         snmp_pdu_add_variable(pdu, name, name_length, ASN_INTEGER,
06687                               (u_char *) &amp; ltmp, <span class="keyword">sizeof</span>(ltmp));
06688         <span class="keywordflow">break</span>;
06689 
06690     <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
06691 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06692         <span class=
"keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_GAUGE &amp;&amp; tp-&gt;type != TYPE_UNSIGNED32) {
06693             value = <span class="stringliteral">"Unsigned32"</span>;
06694             result = SNMPERR_VALUE;
06695             <span class="keywordflow">goto</span> type_error;
06696         }
06697 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06698         ltmp = strtoul(value, &amp;ecp, 10);
06699         <span class="keywordflow">if</span> (*value &amp;&amp; !*ecp)
06700             snmp_pdu_add_variable(pdu, name, name_length, ASN_UNSIGNED,
06701                                   (u_char *) &amp; ltmp, <span class="keyword">sizeof</span>(ltmp));
06702         <span class="keywordflow">else</span>
06703             <span class="keywordflow">goto</span> fail;
06704         <span class="keywordflow">break</span>;
06705 
06706     <span class="keywordflow">case</span> <span class="charliteral">'3'</span>:
06707 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06708         <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_UINTEGER) {
06709             value = <span class="stringliteral">"UInteger32"</span>;
06710             result = SNMPERR_VALUE;
06711             <span class="keywordflow">goto</span> type_error;
06712         }
06713 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06714         ltmp = strtoul(value, &amp;ecp, 10);
06715         <span class="keywordflow">if</span> (*value &amp;&amp; !*ecp)
06716             snmp_pdu_add_variable(pdu, name, name_length, ASN_UINTEGER,
06717                                   (u_char *) &amp; ltmp, <span class="keyword">sizeof</span>(ltmp));
06718         <span class="keywordflow">else</span>
06719             <span class="keywordflow">goto</span> fail;
06720         <span class="keywordflow">break</span>;
06721 
06722     <span class="keywordflow">case</span> <span class="charliteral">'c'</span>:
06723 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06724         <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_COUNTER) {
06725             value = <span class="stringliteral">"Counter32"</span>;
06726             result = SNMPERR_VALUE;
06727             <span class="keywordflow">goto</span> type_error;
06728         }
06729 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06730         ltmp = strtoul(value, &amp;ecp, 10);
06731         <span class="keywordflow">if</span> (*value &amp;&amp; !*ecp)
06732             snmp_pdu_add_variable(pdu, name, name_length, ASN_COUNTER,
06733                                   (u_char *) &amp; ltmp, <span class="keyword">sizeof</span>(ltmp));
06734         <span class="keywordflow">else</span>
06735             <span class="keywordflow">goto</span> fail;
06736         <span class="keywordflow">break</span>;
06737 
06738     <span class="keywordflow">case</span> <span class="charliteral">'C'</span>:
06739 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06740         <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_COUNTER64) {
06741             value = <span class="stringliteral">"Counter64"</span>;
06742             result = SNMPERR_VALUE;
06743             <span class="keywordflow">goto</span> type_error;
06744         }
06745 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06746         <span class="keywordflow">if</span> (read64(&amp;c64tmp, value))
06747             snmp_pdu_add_variable(pdu, name, name_length, ASN_COUNTER64,
06748                                   (u_char *) &amp; c64tmp, <span class="keyword">sizeof</span>(c64tmp));
06749         <span class="keywordflow">else</span>
06750             <span class="keywordflow">goto</span> fail;
06751         <span class="keywordflow">break</span>;
06752 
06753     <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:
06754 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06755         <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_TIMETICKS) {
06756             value = <span class="stringliteral">"Timeticks"</span>;
06757             result = SNMPERR_VALUE;
06758             <span class="keywordflow">goto</span> type_error;
06759         }
06760 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06761         ltmp = strtoul(value, &amp;ecp, 10);
06762         <span class="keywordflow">if</span> (*value &amp;&amp; !*ecp)
06763             snmp_pdu_add_variable(pdu, name, name_length, ASN_TIMETICKS,
06764                                   (u_char *) &amp; ltmp, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
06765         <span class="keywordflow">else</span>
06766             <span class="keywordflow">goto</span> fail;
06767         <span class="keywordflow">break</span>;
06768 
06769     <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
06770 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06771         <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_IPADDR) {
06772             value = <span class="stringliteral">"IpAddress"</span>;
06773             result = SNMPERR_VALUE;
06774             <span class="keywordflow">goto</span> type_error;
06775         }
06776 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06777         atmp = inet_addr(value);
06778         <span class="keywordflow">if</span> (atmp != (long) -1 || !strcmp(value, <span class=
"stringliteral">"255.255.255.255"</span>))
06779             snmp_pdu_add_variable(pdu, name, name_length, ASN_IPADDRESS,
06780                                   (u_char *) &amp; atmp, <span class="keyword">sizeof</span>(atmp));
06781         <span class="keywordflow">else</span>
06782             <span class="keywordflow">goto</span> fail;
06783         <span class="keywordflow">break</span>;
06784 
06785     <span class="keywordflow">case</span> <span class="charliteral">'o'</span>:
06786 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06787         <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_OBJID) {
06788             value = <span class="stringliteral">"OBJECT IDENTIFIER"</span>;
06789             result = SNMPERR_VALUE;
06790             <span class="keywordflow">goto</span> type_error;
06791         }
06792 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06793         <span class="keywordflow">if</span> ((buf = malloc(<span class=
"keyword">sizeof</span>(oid) * MAX_OID_LEN)) == NULL) {
06794             result = SNMPERR_MALLOC;
06795         } <span class="keywordflow">else</span> {
06796             tint = MAX_OID_LEN;
06797             <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga107">snmp_parse_oid</a>(value, (oid *) buf, &amp;tint)) {
06798                 snmp_pdu_add_variable(pdu, name, name_length,
06799                                       ASN_OBJECT_ID, buf,
06800                                       <span class="keyword">sizeof</span>(oid) * tint);
06801             } <span class="keywordflow">else</span> {
06802                 result = snmp_errno;    <span class="comment">/*MTCRITICAL_RESOURCE */</span>
06803             }
06804         }
06805         <span class="keywordflow">break</span>;
06806 
06807     <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
06808     <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
06809     <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
06810 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06811         <span class=
"keywordflow">if</span> (check &amp;&amp; tp-&gt;type != TYPE_OCTETSTR &amp;&amp; tp-&gt;type != TYPE_BITSTRING) {
06812             value = <span class="stringliteral">"OCTET STRING"</span>;
06813             result = SNMPERR_VALUE;
06814             <span class="keywordflow">goto</span> type_error;
06815         }
06816         <span class="keywordflow">if</span> (<span class=
"charliteral">'s'</span> == type &amp;&amp; do_hint &amp;&amp; !parse_octet_hint(tp-&gt;hint, value, &amp;hintptr, &amp;itmp)) {
06817             <span class="keywordflow">if</span> (_check_range(tp, itmp, &amp;result, <span class=
"stringliteral">"Value does not match DISPLAY-HINT"</span>)) {
06818                 snmp_pdu_add_variable(pdu, name, name_length,
06819                                       ASN_OCTET_STR, hintptr, itmp);
06820             }
06821             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(hintptr);
06822             hintptr = buf;
06823             <span class="keywordflow">break</span>;
06824         }
06825 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06826         <span class="keywordflow">if</span> (type == <span class="charliteral">'d'</span>) {
06827             <span class="keywordflow">if</span> (!snmp_decimal_to_binary
06828                 (&amp;buf, &amp;buf_len, &amp;value_len, 1, value)) {
06829                 result = SNMPERR_VALUE;
06830                 snmp_set_detail(value);
06831                 <span class="keywordflow">break</span>;
06832             }
06833             buf_ptr = buf;
06834         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == <span class=
"charliteral">'x'</span>) {
06835             <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;buf, &amp;buf_len, &amp;value_len, 1, value)) {
06836                 result = SNMPERR_VALUE;
06837                 snmp_set_detail(value);
06838                 <span class="keywordflow">break</span>;
06839             }
06840             <span class="comment">/* initialize itmp value so that range check below works */</span>
06841             itmp = value_len;
06842             buf_ptr = buf;
06843         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == <span class=
"charliteral">'s'</span>) {
06844             buf_ptr = value;
06845             value_len = strlen(value);
06846         }
06847 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06848         <span class="keywordflow">if</span> (!_check_range(tp, value_len, &amp;result, <span class=
"stringliteral">"Bad string length"</span>))
06849             <span class="keywordflow">break</span>;
06850 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06851         snmp_pdu_add_variable(pdu, name, name_length, ASN_OCTET_STR,
06852                               buf_ptr, value_len);
06853         <span class="keywordflow">break</span>;
06854 
06855     <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
06856         snmp_pdu_add_variable(pdu, name, name_length, ASN_NULL, 0, 0);
06857         <span class="keywordflow">break</span>;
06858 
06859     <span class="keywordflow">case</span> <span class="charliteral">'b'</span>:
06860 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06861         <span class="keywordflow">if</span> (check &amp;&amp; (tp-&gt;type != TYPE_BITSTRING || !tp-&gt;enums)) {
06862             value = <span class="stringliteral">"BITS"</span>;
06863             result = SNMPERR_VALUE;
06864             <span class="keywordflow">goto</span> type_error;
06865         }
06866 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06867         tint = 0;
06868         <span class="keywordflow">if</span> ((buf = (u_char *) malloc(256)) == NULL) {
06869             result = SNMPERR_MALLOC;
06870             <span class="keywordflow">break</span>;
06871         } <span class="keywordflow">else</span> {
06872             buf_len = 256;
06873             memset(buf, 0, buf_len);
06874         }
06875 
06876 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06877         <span class="keywordflow">for</span> (ep = tp ? tp-&gt;enums : NULL; ep; ep = ep-&gt;next) {
06878             <span class="keywordflow">if</span> (ep-&gt;value / 8 &gt;= (int) tint) {
06879                 tint = ep-&gt;value / 8 + 1;
06880             }
06881         }
06882 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06883 
06884         vp = strdup(value);
06885         <span class="keywordflow">for</span> (cp = strtok_r(vp, <span class=
"stringliteral">" ,\t"</span>, &amp;st); cp; cp = strtok_r(NULL, <span class="stringliteral">" ,\t"</span>, &amp;st)) {
06886             <span class="keywordtype">int</span>             ix, bit;
06887 
06888             ltmp = strtoul(cp, &amp;ecp, 0);
06889             <span class="keywordflow">if</span> (*ecp != 0) {
06890 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06891                 <span class="keywordflow">for</span> (ep = tp ? tp-&gt;enums : NULL; ep != NULL; ep = ep-&gt;next) {
06892                     <span class="keywordflow">if</span> (strncmp(ep-&gt;label, cp, strlen(ep-&gt;label)) == 0) {
06893                         <span class="keywordflow">break</span>;
06894                     }
06895                 }
06896                 <span class="keywordflow">if</span> (ep != NULL) {
06897                     ltmp = ep-&gt;value;
06898                 } <span class="keywordflow">else</span> {
06899 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06900                     result = SNMPERR_BAD_NAME;
06901                     snmp_set_detail(cp);
06902                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(buf);
06903                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(vp);
06904                     <span class="keywordflow">goto</span> out;
06905 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06906                 }
06907 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06908             }
06909 
06910             ix = ltmp / 8;
06911             <span class="keywordflow">if</span> (ix &gt;= (int) tint) {
06912                 tint = ix + 1;
06913             }
06914             <span class="keywordflow">if</span> (ix &gt;= (int)buf_len &amp;&amp; !<a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(&amp;buf, &amp;buf_len)) {
06915                 result = SNMPERR_MALLOC;
06916                 <span class="keywordflow">break</span>;
06917             }
06918             bit = 0x80 &gt;&gt; ltmp % 8;
06919             buf[ix] |= bit;
06920             
06921         }
06922         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(vp);
06923         snmp_pdu_add_variable(pdu, name, name_length, ASN_OCTET_STR,
06924                               buf, tint);
06925         <span class="keywordflow">break</span>;
06926 
06927 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
06928     <span class="keywordflow">case</span> <span class="charliteral">'U'</span>:
06929         <span class="keywordflow">if</span> (read64(&amp;c64tmp, value))
06930             snmp_pdu_add_variable(pdu, name, name_length, ASN_OPAQUE_U64,
06931                                   (u_char *) &amp; c64tmp, <span class="keyword">sizeof</span>(c64tmp));
06932         <span class="keywordflow">else</span>
06933             <span class="keywordflow">goto</span> fail;
06934         <span class="keywordflow">break</span>;
06935 
06936     <span class="keywordflow">case</span> <span class="charliteral">'I'</span>:
06937         <span class="keywordflow">if</span> (read64(&amp;c64tmp, value))
06938             snmp_pdu_add_variable(pdu, name, name_length, ASN_OPAQUE_I64,
06939                                   (u_char *) &amp; c64tmp, <span class="keyword">sizeof</span>(c64tmp));
06940         <span class="keywordflow">else</span>
06941             <span class="keywordflow">goto</span> fail;
06942         <span class="keywordflow">break</span>;
06943 
06944     <span class="keywordflow">case</span> <span class="charliteral">'F'</span>:
06945         <span class="keywordflow">if</span> (sscanf(value, <span class="stringliteral">"%f"</span>, &amp;ftmp) == 1)
06946             snmp_pdu_add_variable(pdu, name, name_length, ASN_OPAQUE_FLOAT,
06947                                   (u_char *) &amp; ftmp, <span class="keyword">sizeof</span>(ftmp));
06948         <span class="keywordflow">else</span>
06949             <span class="keywordflow">goto</span> fail;
06950         <span class="keywordflow">break</span>;
06951 
06952     <span class="keywordflow">case</span> <span class="charliteral">'D'</span>:
06953         <span class="keywordflow">if</span> (sscanf(value, <span class="stringliteral">"%lf"</span>, &amp;dtmp) == 1)
06954             snmp_pdu_add_variable(pdu, name, name_length,
06955                                   ASN_OPAQUE_DOUBLE, (u_char *) &amp; dtmp,
06956                                   <span class="keyword">sizeof</span>(dtmp));
06957         <span class="keywordflow">else</span>
06958             <span class="keywordflow">goto</span> fail;
06959         <span class="keywordflow">break</span>;
06960 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
06961 
06962     <span class="keywordflow">default</span>:
06963         result = SNMPERR_VAR_TYPE;
06964         buf = calloc(1, 4);
06965         <span class="keywordflow">if</span> (buf != NULL) {
06966             sprintf((<span class="keywordtype">char</span> *)buf, <span class="stringliteral">"\"%c\""</span>, type);
06967             snmp_set_detail((<span class="keywordtype">char</span> *)buf);
06968         }
06969         <span class="keywordflow">break</span>;
06970     }
06971 
06972     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(buf);
06973     SET_SNMP_ERROR(result);
06974     <span class="keywordflow">return</span> result;
06975 
06976 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
06977   type_error:
06978     {
06979         <span class="keywordtype">char</span>            error_msg[256];
06980         <span class="keywordtype">char</span>            undef_msg[32];
06981         <span class="keyword">const</span> <span class="keywordtype">char</span>     *var_type;
06982         <span class="keywordflow">switch</span> (tp-&gt;type) {
06983         <span class="keywordflow">case</span> TYPE_OBJID:
06984             var_type = <span class="stringliteral">"OBJECT IDENTIFIER"</span>;
06985             <span class="keywordflow">break</span>;
06986         <span class="keywordflow">case</span> TYPE_OCTETSTR:
06987             var_type = <span class="stringliteral">"OCTET STRING"</span>;
06988             <span class="keywordflow">break</span>;
06989         <span class="keywordflow">case</span> TYPE_INTEGER:
06990             var_type = <span class="stringliteral">"INTEGER"</span>;
06991             <span class="keywordflow">break</span>;
06992         <span class="keywordflow">case</span> TYPE_NETADDR:
06993             var_type = <span class="stringliteral">"NetworkAddress"</span>;
06994             <span class="keywordflow">break</span>;
06995         <span class="keywordflow">case</span> TYPE_IPADDR:
06996             var_type = <span class="stringliteral">"IpAddress"</span>;
06997             <span class="keywordflow">break</span>;
06998         <span class="keywordflow">case</span> TYPE_COUNTER:
06999             var_type = <span class="stringliteral">"Counter32"</span>;
07000             <span class="keywordflow">break</span>;
07001         <span class="keywordflow">case</span> TYPE_GAUGE:
07002             var_type = <span class="stringliteral">"Gauge32"</span>;
07003             <span class="keywordflow">break</span>;
07004         <span class="keywordflow">case</span> TYPE_TIMETICKS:
07005             var_type = <span class="stringliteral">"Timeticks"</span>;
07006             <span class="keywordflow">break</span>;
07007         <span class="keywordflow">case</span> TYPE_OPAQUE:
07008             var_type = <span class="stringliteral">"Opaque"</span>;
07009             <span class="keywordflow">break</span>;
07010         <span class="keywordflow">case</span> TYPE_NULL:
07011             var_type = <span class="stringliteral">"Null"</span>;
07012             <span class="keywordflow">break</span>;
07013         <span class="keywordflow">case</span> TYPE_COUNTER64:
07014             var_type = <span class="stringliteral">"Counter64"</span>;
07015             <span class="keywordflow">break</span>;
07016         <span class="keywordflow">case</span> TYPE_BITSTRING:
07017             var_type = <span class="stringliteral">"BITS"</span>;
07018             <span class="keywordflow">break</span>;
07019         <span class="keywordflow">case</span> TYPE_NSAPADDRESS:
07020             var_type = <span class="stringliteral">"NsapAddress"</span>;
07021             <span class="keywordflow">break</span>;
07022         <span class="keywordflow">case</span> TYPE_UINTEGER:
07023             var_type = <span class="stringliteral">"UInteger"</span>;
07024             <span class="keywordflow">break</span>;
07025         <span class="keywordflow">case</span> TYPE_UNSIGNED32:
07026             var_type = <span class="stringliteral">"Unsigned32"</span>;
07027             <span class="keywordflow">break</span>;
07028         <span class="keywordflow">case</span> TYPE_INTEGER32:
07029             var_type = <span class="stringliteral">"Integer32"</span>;
07030             <span class="keywordflow">break</span>;
07031         <span class="keywordflow">default</span>:
07032             sprintf(undef_msg, <span class="stringliteral">"TYPE_%d"</span>, tp-&gt;type);
07033             var_type = undef_msg;
07034         }
07035         snprintf(error_msg, <span class="keyword">sizeof</span>(error_msg),
07036                <span class="stringliteral">"Type of attribute is %s, not %s"</span>, var_type, value);
07037         error_msg[ <span class="keyword">sizeof</span>(error_msg)-1 ] = 0;
07038         result = SNMPERR_VAR_TYPE;
07039         snmp_set_detail(error_msg);
07040         <span class="keywordflow">goto</span> out;
07041     }
07042 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
07043   fail:
07044     result = SNMPERR_VALUE;
07045     snmp_set_detail(value);
07046   out:
07047     SET_SNMP_ERROR(result);
07048     <span class="keywordflow">return</span> result;
07049 }
07050 
07051 <span class="comment">/*</span>
07052 <span class="comment"> * returns NULL or internal pointer to session</span>
07053 <span class="comment"> * use this pointer for the other snmp_sess* routines,</span>
07054 <span class="comment"> * which guarantee action will occur ONLY for this given session.</span>
07055 <span class="comment"> */</span>
07056 <span class="keywordtype">void</span>           *
07057 snmp_sess_pointer(netsnmp_session * session)
07058 {
07059     <span class="keyword">struct </span>session_list *slp;
07060 
07061     snmp_res_lock(MT_LIBRARY_ID, MT_LIB_SESSION);
07062     <span class="keywordflow">for</span> (slp = Sessions; slp; slp = slp-&gt;next) {
07063         <span class="keywordflow">if</span> (slp-&gt;session == session) {
07064             <span class="keywordflow">break</span>;
07065         }
07066     }
07067     snmp_res_unlock(MT_LIBRARY_ID, MT_LIB_SESSION);
07068 
07069     <span class="keywordflow">if</span> (slp == NULL) {
07070         snmp_errno = SNMPERR_BAD_SESSION;       <span class="comment">/*MTCRITICAL_RESOURCE */</span>
07071         <span class="keywordflow">return</span> (NULL);
07072     }
07073     <span class="keywordflow">return</span> ((<span class="keywordtype">void</span> *) slp);
07074 }
07075 
07076 <span class="comment">/*</span>
07077 <span class="comment"> * Input : an opaque pointer, returned by snmp_sess_open.</span>
07078 <span class="comment"> * returns NULL or pointer to session.</span>
07079 <span class="comment"> */</span>
07080 netsnmp_session *
07081 snmp_sess_session(<span class="keywordtype">void</span> *sessp)
07082 {
07083     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
07084     <span class="keywordflow">if</span> (slp == NULL)
07085         <span class="keywordflow">return</span> (NULL);
07086     <span class="keywordflow">return</span> (slp-&gt;session);
07087 }
07088 
07089 
07090 
07091 <span class="comment">/*</span>
07092 <span class="comment"> * snmp_sess_transport: takes an opaque pointer (as returned by</span>
07093 <span class="comment"> * snmp_sess_open or snmp_sess_pointer) and returns the corresponding</span>
07094 <span class="comment"> * netsnmp_transport pointer (or NULL if the opaque pointer does not correspond</span>
07095 <span class="comment"> * to an active internal session).  </span>
07096 <span class="comment"> */</span>
07097 
07098 netsnmp_transport *
07099 snmp_sess_transport(<span class="keywordtype">void</span> *sessp)
07100 {
07101     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sessp;
07102     <span class="keywordflow">if</span> (slp == NULL) {
07103         <span class="keywordflow">return</span> NULL;
07104     } <span class="keywordflow">else</span> {
07105         <span class="keywordflow">return</span> slp-&gt;transport;
07106     }
07107 }
07108 
07109 
07110 
07111 <span class="comment">/*</span>
07112 <span class="comment"> * snmp_sess_transport_set: set the transport pointer for the opaque</span>
07113 <span class="comment"> * session pointer sp.  </span>
07114 <span class="comment"> */</span>
07115 
07116 <span class="keywordtype">void</span>
07117 snmp_sess_transport_set(<span class="keywordtype">void</span> *sp, netsnmp_transport *t)
07118 {
07119     <span class="keyword">struct </span>session_list *slp = (<span class="keyword">struct </span>session_list *) sp;
07120     <span class="keywordflow">if</span> (slp != NULL) {
07121         slp-&gt;transport = t;
07122     }
07123 }
07124 
07125 
07126 <span class="comment">/*</span>
07127 <span class="comment"> * snmp_duplicate_objid: duplicates (mallocs) an objid based on the</span>
07128 <span class="comment"> * input objid </span>
07129 <span class="comment"> */</span>
07130 oid            *
07131 snmp_duplicate_objid(<span class="keyword">const</span> oid * objToCopy, size_t objToCopyLen)
07132 {
07133     oid            *returnOid = NULL;
07134     <span class="keywordflow">if</span> (objToCopy != NULL &amp;&amp; objToCopyLen != 0) {
07135         returnOid = (oid *) malloc(objToCopyLen * <span class="keyword">sizeof</span>(oid));
07136         <span class="keywordflow">if</span> (returnOid) {
07137             memmove(returnOid, objToCopy, objToCopyLen * <span class="keyword">sizeof</span>(oid));
07138         }
07139     }
07140     <span class="keywordflow">return</span> returnOid;
07141 }
07142 
07143 <span class="comment">/*</span>
07144 <span class="comment"> * generic statistics counter functions </span>
07145 <span class="comment"> */</span>
07146 <span class="keyword">static</span> u_int    statistics[MAX_STATS];
07147 
07148 u_int
07149 snmp_increment_statistic(<span class="keywordtype">int</span> which)
07150 {
07151     <span class="keywordflow">if</span> (which &gt;= 0 &amp;&amp; which &lt; MAX_STATS) {
07152         statistics[which]++;
07153         <span class="keywordflow">return</span> statistics[which];
07154     }
07155     <span class="keywordflow">return</span> 0;
07156 }
07157 
07158 u_int
07159 snmp_increment_statistic_by(<span class="keywordtype">int</span> which, <span class="keywordtype">int</span> count)
07160 {
07161     <span class="keywordflow">if</span> (which &gt;= 0 &amp;&amp; which &lt; MAX_STATS) {
07162         statistics[which] += count;
07163         <span class="keywordflow">return</span> statistics[which];
07164     }
07165     <span class="keywordflow">return</span> 0;
07166 }
07167 
07168 u_int
07169 snmp_get_statistic(<span class="keywordtype">int</span> which)
07170 {
07171     <span class="keywordflow">if</span> (which &gt;= 0 &amp;&amp; which &lt; MAX_STATS)
07172         <span class="keywordflow">return</span> statistics[which];
07173     <span class="keywordflow">return</span> 0;
07174 }
07175 
07176 <span class="keywordtype">void</span>
07177 snmp_init_statistics(<span class="keywordtype">void</span>)
07178 {
07179     memset(statistics, 0, <span class="keyword">sizeof</span>(statistics));
07180 }
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small>Generated on Fri Dec 30 13:47:48 2005 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

