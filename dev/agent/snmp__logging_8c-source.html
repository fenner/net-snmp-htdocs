<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>snmp_logging.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * logging.c - generic logging for snmp-agent</span>
00003 <span class="comment"> * * Contributed by Ragnar Kj&oslash;rstad, ucd@ragnark.vestdata.no 1999-06-26 </span>
00004 <span class="comment"> */</span>
00005 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
00006 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00007 <span class="comment"> * that may apply:</span>
00008 <span class="comment"> */</span>
00009 <span class="comment">/*</span>
00010 <span class="comment"> * Portions of this file are copyrighted by:</span>
00011 <span class="comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
00012 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00013 <span class="comment"> * distributed with the Net-SNMP package.</span>
00014 <span class="comment"> */</span>
00020 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00021 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00022 <span class="preprocessor">#if HAVE_MALLOC_H</span>
00023 <span class="preprocessor">#include &lt;malloc.h&gt;</span>
00024 <span class="preprocessor">#endif</span>
00025 <span class="preprocessor">#if HAVE_STRING_H</span>
00026 <span class="preprocessor">#include &lt;string.h&gt;</span>
00027 <span class="preprocessor">#else</span>
00028 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00029 <span class="preprocessor">#endif</span>
00030 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00031 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00032 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00033 <span class="preprocessor">#endif</span>
00034 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00035 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00036 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00037 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00038 <span class="preprocessor">#if HAVE_SYSLOG_H</span>
00039 <span class="preprocessor">#include &lt;syslog.h&gt;</span>
00040 <span class="preprocessor">#ifndef LOG_CONS                </span><span class=
"comment">/* Interesting Ultrix feature */</span>
00041 <span class="preprocessor">#include &lt;sys/syslog.h&gt;</span>
00042 <span class="preprocessor">#endif</span>
00043 <span class="preprocessor">#endif</span>
00044 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00045 <span class="preprocessor"># ifdef WIN32</span>
00046 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00047 <span class="preprocessor"># else</span>
00048 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00049 <span class="preprocessor"># endif</span>
00050 <span class="preprocessor"># include &lt;time.h&gt;</span>
00051 <span class="preprocessor">#else</span>
00052 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00053 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00054 <span class="preprocessor"># else</span>
00055 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00056 <span class="preprocessor"># endif</span>
00057 <span class="preprocessor">#endif</span>
00058 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00059 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00060 <span class="preprocessor">#endif</span>
00061 
00062 <span class="preprocessor">#if HAVE_STDARG_H</span>
00063 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00064 <span class="preprocessor">#else</span>
00065 <span class="preprocessor">#include &lt;varargs.h&gt;</span>
00066 <span class="preprocessor">#endif</span>
00067 
00068 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00069 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00070 <span class="preprocessor">#endif</span>
00071 
00072 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00073 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00074 <span class="preprocessor">#endif</span>
00075 
00076 <span class="preprocessor">#if HAVE_WINDOWS_H</span>
00077 <span class="preprocessor">#include &lt;windows.h&gt;</span>
00078 <span class="preprocessor">#endif</span>
00079 
00080 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00081 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00082 <span class="preprocessor">#include &lt;net-snmp/library/snmp_logging.h&gt;</span>      <span class=
"comment">/* For this file's "internal" definitions */</span>
00083 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00084 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00085 
00086 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
00087 <span class="preprocessor">#define LOGLENGTH 1024</span>
00088 
00089 <span class="comment">/*</span>
00090 <span class="comment"> * logh_head:  A list of all log handlers, in increasing order of priority</span>
00091 <span class="comment"> * logh_priorities:  'Indexes' into this list, by priority</span>
00092 <span class="comment"> */</span>
00093 netsnmp_log_handler *logh_head;
00094 netsnmp_log_handler *logh_priorities[LOG_DEBUG+1];
00095 
00096 <span class="keyword">static</span> <span class="keywordtype">int</span>      newline = 1;     <span class=
"comment">/* MTCRITICAL_RESOURCE */</span>
00097 
00098 <span class="keyword">static</span> <span class="keywordtype">char</span> syslogname[64] = DEFAULT_LOG_ID;
00099 
00100 <span class="preprocessor">#ifndef HAVE_VSNPRINTF</span>
00101                 <span class="comment">/*</span>
00102 <span class="comment">                 * Need to use the UCD-provided one </span>
00103 <span class="comment">                 */</span>
00104 <span class="keywordtype">int</span>             vsnprintf(<span class=
"keywordtype">char</span> *str, size_t count, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt,
00105                           va_list arg);
00106 <span class="preprocessor">#endif</span>
00107 
00108 <span class="keywordtype">void</span>
00109 init_snmp_logging(<span class="keywordtype">void</span>)
00110 {
00111     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"logTimestamp"</span>, 
00112                          NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_LOG_TIMESTAMP);
00113 }
00114 
00115 <span class="comment">/*</span>
00116 <span class="comment"> * These definitions handle 4.2 systems without additional syslog facilities.</span>
00117 <span class="comment"> */</span>
00118 <span class="preprocessor">#ifndef LOG_CONS</span>
00119 <span class="preprocessor">#define LOG_CONS        0       </span><span class=
"comment">/* Don't bother if not defined... */</span>
00120 <span class="preprocessor">#endif</span>
00121 <span class="preprocessor">#ifndef LOG_PID</span>
00122 <span class="preprocessor">#define LOG_PID         0       </span><span class=
"comment">/* Don't bother if not defined... */</span>
00123 <span class="preprocessor">#endif</span>
00124 <span class="preprocessor">#ifndef LOG_LOCAL0</span>
00125 <span class="preprocessor">#define LOG_LOCAL0      0</span>
00126 <span class="preprocessor">#endif</span>
00127 <span class="preprocessor">#ifndef LOG_LOCAL1</span>
00128 <span class="preprocessor">#define LOG_LOCAL1      0</span>
00129 <span class="preprocessor">#endif</span>
00130 <span class="preprocessor">#ifndef LOG_LOCAL2</span>
00131 <span class="preprocessor">#define LOG_LOCAL2      0</span>
00132 <span class="preprocessor">#endif</span>
00133 <span class="preprocessor">#ifndef LOG_LOCAL3</span>
00134 <span class="preprocessor">#define LOG_LOCAL3      0</span>
00135 <span class="preprocessor">#endif</span>
00136 <span class="preprocessor">#ifndef LOG_LOCAL4</span>
00137 <span class="preprocessor">#define LOG_LOCAL4      0</span>
00138 <span class="preprocessor">#endif</span>
00139 <span class="preprocessor">#ifndef LOG_LOCAL5</span>
00140 <span class="preprocessor">#define LOG_LOCAL5      0</span>
00141 <span class="preprocessor">#endif</span>
00142 <span class="preprocessor">#ifndef LOG_LOCAL6</span>
00143 <span class="preprocessor">#define LOG_LOCAL6      0</span>
00144 <span class="preprocessor">#endif</span>
00145 <span class="preprocessor">#ifndef LOG_LOCAL7</span>
00146 <span class="preprocessor">#define LOG_LOCAL7      0</span>
00147 <span class="preprocessor">#endif</span>
00148 <span class="preprocessor">#ifndef LOG_DAEMON</span>
00149 <span class="preprocessor">#define LOG_DAEMON      0</span>
00150 <span class="preprocessor">#endif</span>
00151 <span class="preprocessor">#ifndef LOG_USER</span>
00152 <span class="preprocessor">#define LOG_USER        0</span>
00153 <span class="preprocessor">#endif</span>
00154 
00155 <span class="keywordtype">int</span>
00156 decode_priority( <span class="keywordtype">char</span> *optarg, <span class="keywordtype">int</span> *pri_max )
00157 {
00158     <span class="keywordtype">int</span> pri_low = LOG_DEBUG;
00159 
00160     <span class="keywordflow">switch</span> (*optarg) {
00161         <span class="keywordflow">case</span> <span class="charliteral">'0'</span>: 
00162         <span class="keywordflow">case</span> <span class="charliteral">'!'</span>: 
00163             pri_low = LOG_EMERG;
00164             <span class="keywordflow">break</span>;
00165         <span class="keywordflow">case</span> <span class="charliteral">'1'</span>: 
00166         <span class="keywordflow">case</span> <span class="charliteral">'a'</span>: 
00167         <span class="keywordflow">case</span> <span class="charliteral">'A'</span>: 
00168             pri_low = LOG_ALERT;
00169             <span class="keywordflow">break</span>;
00170         <span class="keywordflow">case</span> <span class="charliteral">'2'</span>: 
00171         <span class="keywordflow">case</span> <span class="charliteral">'c'</span>: 
00172         <span class="keywordflow">case</span> <span class="charliteral">'C'</span>: 
00173             pri_low = LOG_CRIT;
00174             <span class="keywordflow">break</span>;
00175         <span class="keywordflow">case</span> <span class="charliteral">'3'</span>: 
00176         <span class="keywordflow">case</span> <span class="charliteral">'e'</span>: 
00177         <span class="keywordflow">case</span> <span class="charliteral">'E'</span>: 
00178             pri_low = LOG_ERR;
00179             <span class="keywordflow">break</span>;
00180         <span class="keywordflow">case</span> <span class="charliteral">'4'</span>: 
00181         <span class="keywordflow">case</span> <span class="charliteral">'w'</span>: 
00182         <span class="keywordflow">case</span> <span class="charliteral">'W'</span>: 
00183             pri_low = LOG_WARNING;
00184             <span class="keywordflow">break</span>;
00185         <span class="keywordflow">case</span> <span class="charliteral">'5'</span>: 
00186         <span class="keywordflow">case</span> <span class="charliteral">'n'</span>: 
00187         <span class="keywordflow">case</span> <span class="charliteral">'N'</span>: 
00188             pri_low = LOG_NOTICE;
00189             <span class="keywordflow">break</span>;
00190         <span class="keywordflow">case</span> <span class="charliteral">'6'</span>: 
00191         <span class="keywordflow">case</span> <span class="charliteral">'i'</span>: 
00192         <span class="keywordflow">case</span> <span class="charliteral">'I'</span>: 
00193             pri_low = LOG_INFO;
00194             <span class="keywordflow">break</span>;
00195         <span class="keywordflow">case</span> <span class="charliteral">'7'</span>: 
00196         <span class="keywordflow">case</span> <span class="charliteral">'d'</span>: 
00197         <span class="keywordflow">case</span> <span class="charliteral">'D'</span>: 
00198             pri_low = LOG_DEBUG;
00199             <span class="keywordflow">break</span>;
00200         <span class="keywordflow">default</span>: 
00201             fprintf(stderr, <span class="stringliteral">"invalid priority: %c\n"</span>,*optarg);
00202             <span class="keywordflow">return</span> -1;
00203     }
00204 
00205     <span class="keywordflow">if</span> (pri_max &amp;&amp; *(optarg+1)==<span class="charliteral">'-'</span>) {
00206         *pri_max = decode_priority( optarg+2, NULL );
00207         <span class="keywordflow">if</span> (*pri_max == -1) <span class="keywordflow">return</span> -1;
00208     }
00209     <span class="keywordflow">return</span> pri_low;
00210 }
00211 
00212 <span class="keywordtype">int</span>
00213 decode_facility( <span class="keywordtype">char</span> *optarg )
00214 {
00215     <span class="keywordflow">if</span> (optarg == NULL)
00216         <span class="keywordflow">return</span> -1;
00217 
00218     <span class="keywordflow">switch</span> (*optarg) {
00219     <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
00220     <span class="keywordflow">case</span> <span class="charliteral">'D'</span>:
00221         <span class="keywordflow">return</span> LOG_DAEMON;
00222     <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
00223     <span class="keywordflow">case</span> <span class="charliteral">'U'</span>:
00224         <span class="keywordflow">return</span> LOG_USER;
00225     <span class="keywordflow">case</span> <span class="charliteral">'0'</span>:
00226         <span class="keywordflow">return</span> LOG_LOCAL0;
00227     <span class="keywordflow">case</span> <span class="charliteral">'1'</span>:
00228         <span class="keywordflow">return</span> LOG_LOCAL1;
00229     <span class="keywordflow">case</span> <span class="charliteral">'2'</span>:
00230         <span class="keywordflow">return</span> LOG_LOCAL2;
00231     <span class="keywordflow">case</span> <span class="charliteral">'3'</span>:
00232         <span class="keywordflow">return</span> LOG_LOCAL3;
00233     <span class="keywordflow">case</span> <span class="charliteral">'4'</span>:
00234         <span class="keywordflow">return</span> LOG_LOCAL4;
00235     <span class="keywordflow">case</span> <span class="charliteral">'5'</span>:
00236         <span class="keywordflow">return</span> LOG_LOCAL5;
00237     <span class="keywordflow">case</span> <span class="charliteral">'6'</span>:
00238         <span class="keywordflow">return</span> LOG_LOCAL6;
00239     <span class="keywordflow">case</span> <span class="charliteral">'7'</span>:
00240         <span class="keywordflow">return</span> LOG_LOCAL7;
00241     <span class="keywordflow">default</span>:
00242         fprintf(stderr, <span class="stringliteral">"invalid syslog facility: %c\n"</span>,*optarg);
00243         <span class="keywordflow">return</span> -1;
00244     }
00245 }
00246 
00247 <span class="keywordtype">int</span>
00248 snmp_log_options(<span class="keywordtype">char</span> *optarg, <span class="keywordtype">int</span> argc, <span class=
"keywordtype">char</span> *<span class="keyword">const</span> *argv)
00249 {
00250     <span class="keywordtype">char</span>           *cp = optarg;
00251         <span class="comment">/*</span>
00252 <span class="comment">         * Hmmm... this doesn't seem to work.</span>
00253 <span class="comment">         * The main agent 'getopt' handling assumes</span>
00254 <span class="comment">         *   that the -L option takes an argument,</span>
00255 <span class="comment">         *   and objects if this is missing.</span>
00256 <span class="comment">         * Trying to differentiate between</span>
00257 <span class="comment">         *   new-style "-Lx", and old-style "-L xx"</span>
00258 <span class="comment">         *   is likely to be a major headache.</span>
00259 <span class="comment">         */</span>
00260     <span class="keywordtype">char</span>            missing_opt = <span class="charliteral">'e'</span>;  <span class=
"comment">/* old -L is new -Le */</span>
00261     <span class="keywordtype">int</span>             priority = LOG_DEBUG;
00262     <span class="keywordtype">int</span>             pri_max  = LOG_EMERG;
00263     <span class="keywordtype">int</span>             inc_optind = 0;
00264     netsnmp_log_handler *logh;
00265 
00266     optarg++;
00267     <span class="keywordflow">if</span> (!*cp)
00268         cp = &amp;missing_opt;
00269 
00270     <span class="comment">/*</span>
00271 <span class="comment">     * Support '... -Lx=value ....' syntax</span>
00272 <span class="comment">     */</span>
00273     <span class="keywordflow">if</span> (*optarg == <span class="charliteral">'='</span>) {
00274         optarg++;
00275     }
00276     <span class="comment">/*</span>
00277 <span class="comment">     * and '.... "-Lx value" ....'  (*with* the quotes)</span>
00278 <span class="comment">     */</span>
00279     <span class="keywordflow">while</span> (*optarg &amp;&amp; isspace(*optarg)) {
00280         optarg++;
00281     }
00282     <span class="comment">/*</span>
00283 <span class="comment">     * Finally, handle ".... -Lx value ...." syntax</span>
00284 <span class="comment">     *   (*without* surrounding quotes)</span>
00285 <span class="comment">     */</span>
00286     <span class="keywordflow">if</span> (!*optarg) {
00287         <span class="comment">/*</span>
00288 <span class="comment">         * We've run off the end of the argument</span>
00289 <span class="comment">         *  so move on to the next.</span>
00290 <span class="comment">         * But we might not actually need it, so don't</span>
00291 <span class="comment">         *  increment optind just yet!</span>
00292 <span class="comment">         */</span>
00293         optarg = argv[optind];
00294         inc_optind = 1;
00295     }
00296 
00297     <span class="keywordflow">switch</span> (*cp) {
00298 
00299     <span class="comment">/*</span>
00300 <span class="comment">     * Log to Standard Error</span>
00301 <span class="comment">     */</span>
00302     <span class="keywordflow">case</span> <span class="charliteral">'E'</span>:
00303         priority = decode_priority( optarg, &amp;pri_max );
00304         <span class="keywordflow">if</span> (priority == -1)  <span class="keywordflow">return</span> -1;
00305         <span class="keywordflow">if</span> (inc_optind)
00306             optind++;
00307         <span class="comment">/* Fallthrough */</span>
00308     <span class="keywordflow">case</span> <span class="charliteral">'e'</span>:
00309         logh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_STDERR, priority);
00310         <span class="keywordflow">if</span> (logh) {
00311             logh-&gt;pri_max = pri_max;
00312             logh-&gt;token   = strdup(<span class="stringliteral">"stderr"</span>);
00313         }
00314         <span class="keywordflow">break</span>;
00315 
00316     <span class="comment">/*</span>
00317 <span class="comment">     * Log to Standard Output</span>
00318 <span class="comment">     */</span>
00319     <span class="keywordflow">case</span> <span class="charliteral">'O'</span>:
00320         priority = decode_priority( optarg, &amp;pri_max );
00321         <span class="keywordflow">if</span> (priority == -1)  <span class="keywordflow">return</span> -1;
00322         <span class="keywordflow">if</span> (inc_optind)
00323             optind++;
00324         <span class="comment">/* Fallthrough */</span>
00325     <span class="keywordflow">case</span> <span class="charliteral">'o'</span>:
00326         logh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_STDERR, priority);
00327         <span class="keywordflow">if</span> (logh) {
00328             logh-&gt;pri_max = pri_max;
00329             logh-&gt;token   = strdup(<span class="stringliteral">"stdout"</span>);
00330             logh-&gt;imagic  = 1;      <span class="comment">/* stdout, not stderr */</span>
00331         }
00332         <span class="keywordflow">break</span>;
00333 
00334     <span class="comment">/*</span>
00335 <span class="comment">     * Log to a named file</span>
00336 <span class="comment">     */</span>
00337     <span class="keywordflow">case</span> <span class="charliteral">'F'</span>:
00338         priority = decode_priority( optarg, &amp;pri_max );
00339         <span class="keywordflow">if</span> (priority == -1)  <span class="keywordflow">return</span> -1;
00340         optarg = argv[++optind];
00341         <span class="comment">/* Fallthrough */</span>
00342     <span class="keywordflow">case</span> <span class="charliteral">'f'</span>:
00343         <span class="keywordflow">if</span> (inc_optind)
00344             optind++;
00345         <span class="keywordflow">if</span> (!optarg) {
00346             fprintf(stderr, <span class="stringliteral">"Missing log file\n"</span>);
00347             <span class="keywordflow">return</span> -1;
00348         }
00349         logh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_FILE, priority);
00350         <span class="keywordflow">if</span> (logh) {
00351             logh-&gt;pri_max = pri_max;
00352             logh-&gt;token   = strdup(optarg);
00353         }
00354         <span class="keywordflow">break</span>;
00355 
00356     <span class="comment">/*</span>
00357 <span class="comment">     * Log to syslog</span>
00358 <span class="comment">     */</span>
00359     <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
00360         priority = decode_priority( optarg, &amp;pri_max );
00361         <span class="keywordflow">if</span> (priority == -1)  <span class="keywordflow">return</span> -1;
00362         optarg = argv[++optind];
00363         <span class="comment">/* Fallthrough */</span>
00364     <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
00365         <span class="keywordflow">if</span> (inc_optind)
00366             optind++;
00367         <span class="keywordflow">if</span> (!optarg) {
00368             fprintf(stderr, <span class="stringliteral">"Missing syslog facility\n"</span>);
00369             <span class="keywordflow">return</span> -1;
00370         }
00371         logh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_SYSLOG, priority);
00372         <span class="keywordflow">if</span> (logh) {
00373             <span class="keywordtype">int</span> facility = decode_facility(optarg);
00374             <span class="keywordflow">if</span> (facility == -1)  <span class="keywordflow">return</span> -1;
00375             logh-&gt;pri_max = pri_max;
00376             logh-&gt;token   = strdup(snmp_log_syslogname(0));
00377             logh-&gt;magic   = (<span class="keywordtype">void</span> *)facility;
00378             snmp_enable_syslog_ident(snmp_log_syslogname(0), facility);
00379         }
00380         <span class="keywordflow">break</span>;
00381 
00382     <span class="comment">/*</span>
00383 <span class="comment">     * Don't log </span>
00384 <span class="comment">     */</span>
00385     <span class="keywordflow">case</span> <span class="charliteral">'N'</span>:
00386         priority = decode_priority( optarg, &amp;pri_max );
00387         <span class="keywordflow">if</span> (priority == -1)  <span class="keywordflow">return</span> -1;
00388         <span class="keywordflow">if</span> (inc_optind)
00389             optind++;
00390         <span class="comment">/* Fallthrough */</span>
00391     <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
00392         logh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_NONE, priority);
00393         <span class="keywordflow">if</span> (logh) {
00394             logh-&gt;pri_max = pri_max;
00395         }
00396         <span class="keywordflow">break</span>;
00397 
00398     <span class="keywordflow">default</span>:
00399         fprintf(stderr, <span class="stringliteral">"Unknown logging option passed to -L: %c.\n"</span>, *cp);
00400         <span class="keywordflow">return</span> -1;
00401     }
00402     <span class="keywordflow">return</span> 0;
00403 }
00404 
00405 <span class="keywordtype">char</span> *
00406 snmp_log_syslogname(<span class="keywordtype">char</span> *pstr)
00407 {
00408   <span class="keywordflow">if</span> (pstr)
00409     strncpy (syslogname, pstr, <span class="keyword">sizeof</span>(syslogname));
00410 
00411   <span class="keywordflow">return</span> syslogname;
00412 }
00413 
00414 <span class="keywordtype">void</span>
00415 snmp_log_options_usage(<span class="keyword">const</span> <span class="keywordtype">char</span> *lead, FILE * outf)
00416 {
00417     <span class="keyword">const</span> <span class="keywordtype">char</span> *pri1_msg = <span class=
"stringliteral">" for level 'pri' and above"</span>;
00418     <span class="keyword">const</span> <span class="keywordtype">char</span> *pri2_msg = <span class=
"stringliteral">" for levels 'p1' to 'p2'"</span>;
00419     fprintf(outf, <span class="stringliteral">"%se:           log to standard error\n"</span>, lead);
00420     fprintf(outf, <span class="stringliteral">"%so:           log to standard output\n"</span>, lead);
00421     fprintf(outf, <span class="stringliteral">"%sn:           don't log at all\n"</span>, lead);
00422     fprintf(outf, <span class="stringliteral">"%sf file:      log to the specified file\n"</span>, lead);
00423     fprintf(outf, <span class="stringliteral">"%ss facility:  log to syslog (via the specified facility)\n"</span>, lead);
00424     fprintf(outf, <span class="stringliteral">"\n%s(variants)\n"</span>, lead);
00425     fprintf(outf, <span class=
"stringliteral">"%s[EON] pri:   log to standard error, output or /dev/null%s\n"</span>, lead, pri1_msg);
00426     fprintf(outf, <span class=
"stringliteral">"%s[EON] p1-p2: log to standard error, output or /dev/null%s\n"</span>, lead, pri2_msg);
00427     fprintf(outf, <span class="stringliteral">"%s[FS] pri token:    log to file/syslog%s\n"</span>, lead, pri1_msg);
00428     fprintf(outf, <span class="stringliteral">"%s[FS] p1-p2 token:  log to file/syslog%s\n"</span>, lead, pri2_msg);
00429 }
00430 
00462 <span class="keywordtype">int</span>
<a name="l00463" id="l00463"></a><a class="code" href="group__snmp__logging.html#ga11">00463</a> <a class="code" href=
"group__snmp__logging.html#ga11">snmp_get_do_logging</a>(<span class="keywordtype">void</span>)
00464 {
00465     netsnmp_log_handler *logh;
00466     <span class="keywordflow">for</span> (logh = logh_head; logh; logh = logh-&gt;next)
00467         <span class="keywordflow">if</span> (logh-&gt;enabled)
00468             <span class="keywordflow">return</span> 1;
00469     <span class="keywordflow">return</span> 0;
00470 }
00471 
00472 
00473 <span class="keyword">static</span> <span class="keywordtype">char</span>    *
00474 sprintf_stamp(time_t * now, <span class="keywordtype">char</span> *sbuf)
00475 {
00476     time_t          Now;
00477     <span class="keyword">struct </span>tm      *tm;
00478 
00479     <span class="keywordflow">if</span> (now == NULL) {
00480         now = &amp;Now;
00481         time(now);
00482     }
00483     tm = localtime(now);
00484     sprintf(sbuf, <span class="stringliteral">"%.4d-%.2d-%.2d %.2d:%.2d:%.2d "</span>,
00485             tm-&gt;tm_year + 1900, tm-&gt;tm_mon + 1, tm-&gt;tm_mday,
00486             tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);
00487     <span class="keywordflow">return</span> sbuf;
00488 }
00489 
00490 <span class="keywordtype">void</span>
00491 snmp_disable_syslog_entry(netsnmp_log_handler *logh)
00492 {
00493     <span class="keywordflow">if</span> (!logh || !logh-&gt;enabled || logh-&gt;type != NETSNMP_LOGHANDLER_SYSLOG)
00494         <span class="keywordflow">return</span>;
00495 
00496 <span class="preprocessor">#ifdef WIN32</span>
00497     <span class="keywordflow">if</span> (logh-&gt;magic) {
00498         HANDLE eventlog_h = (HANDLE)logh-&gt;magic;
00499         CloseEventLog(eventlog_h);
00500         logh-&gt;magic = NULL;
00501     }
00502 <span class="preprocessor">#else</span>
00503     closelog();
00504     logh-&gt;imagic  = 0;
00505 <span class="preprocessor">#endif</span>
00506 
00507     logh-&gt;enabled = 0;
00508 }
00509 
00510 <span class="keywordtype">void</span>
00511 snmp_disable_syslog(<span class="keywordtype">void</span>)
00512 {
00513     netsnmp_log_handler *logh;
00514 
00515     <span class="keywordflow">for</span> (logh = logh_head; logh; logh = logh-&gt;next)
00516         <span class="keywordflow">if</span> (logh-&gt;enabled &amp;&amp; logh-&gt;type == NETSNMP_LOGHANDLER_SYSLOG)
00517             snmp_disable_syslog_entry(logh);
00518 }
00519 
00520 <span class="keywordtype">void</span>
00521 snmp_disable_filelog_entry(netsnmp_log_handler *logh)
00522 {
00523     <span class="keywordflow">if</span> (!logh <span class=
"comment">/* || !logh-&gt;enabled */</span> || logh-&gt;type != NETSNMP_LOGHANDLER_FILE)
00524         <span class="keywordflow">return</span>;
00525 
00526     <span class="keywordflow">if</span> (logh-&gt;magic) {
00527         fputs(<span class="stringliteral">"\n"</span>, (FILE*)logh-&gt;magic);        <span class=
"comment">/* XXX - why? */</span>
00528         fclose((FILE*)logh-&gt;magic);
00529         logh-&gt;magic   = NULL;
00530     }
00531     logh-&gt;enabled = 0;
00532 }
00533 
00534 <span class="keywordtype">void</span>
00535 snmp_disable_filelog(<span class="keywordtype">void</span>)
00536 {
00537     netsnmp_log_handler *logh;
00538 
00539     <span class="keywordflow">for</span> (logh = logh_head; logh; logh = logh-&gt;next)
00540         <span class="keywordflow">if</span> (logh-&gt;enabled &amp;&amp; logh-&gt;type == NETSNMP_LOGHANDLER_FILE)
00541             snmp_disable_filelog_entry(logh);
00542 }
00543 
00544 <span class="keywordtype">void</span>
00545 snmp_disable_stderrlog(<span class="keywordtype">void</span>)
00546 {
00547     netsnmp_log_handler *logh;
00548 
00549     <span class="keywordflow">for</span> (logh = logh_head; logh; logh = logh-&gt;next)
00550         <span class="keywordflow">if</span> (logh-&gt;enabled &amp;&amp; (logh-&gt;type == NETSNMP_LOGHANDLER_STDOUT ||
00551                               logh-&gt;type == NETSNMP_LOGHANDLER_STDERR)) {
00552             logh-&gt;enabled = 0;
00553         }
00554 }
00555 
00556 <span class="keywordtype">void</span>
00557 snmp_disable_calllog(<span class="keywordtype">void</span>)
00558 {
00559     netsnmp_log_handler *logh;
00560 
00561     <span class="keywordflow">for</span> (logh = logh_head; logh; logh = logh-&gt;next)
00562         <span class="keywordflow">if</span> (logh-&gt;enabled &amp;&amp; logh-&gt;type == NETSNMP_LOGHANDLER_CALLBACK) {
00563             logh-&gt;enabled = 0;
00564         }
00565 }
00566 
00567 <span class="keywordtype">void</span>
00568 snmp_disable_log(<span class="keywordtype">void</span>)
00569 {
00570     netsnmp_log_handler *logh;
00571 
00572     <span class="keywordflow">for</span> (logh = logh_head; logh; logh = logh-&gt;next) {
00573         <span class="keywordflow">if</span> (logh-&gt;type == NETSNMP_LOGHANDLER_SYSLOG)
00574             snmp_disable_syslog_entry(logh);
00575         <span class="keywordflow">if</span> (logh-&gt;type == NETSNMP_LOGHANDLER_FILE)
00576             snmp_disable_filelog_entry(logh);
00577         logh-&gt;enabled = 0;
00578     }
00579 }
00580 
00581 <span class="comment">/* ================================================== */</span>
00582 
00583 <span class="keywordtype">void</span>
00584 snmp_enable_syslog(<span class="keywordtype">void</span>)
00585 {
00586     snmp_enable_syslog_ident(snmp_log_syslogname(0), LOG_DAEMON);
00587 }
00588 
00589 <span class="keywordtype">void</span>
00590 snmp_enable_syslog_ident(<span class="keyword">const</span> <span class="keywordtype">char</span> *ident, <span class=
"keyword">const</span> <span class="keywordtype">int</span> facility)
00591 {
00592     netsnmp_log_handler *logh;
00593     <span class="keywordtype">int</span>                  found = 0;
00594     <span class="keywordtype">int</span>                  enable = 1;
00595 <span class="preprocessor">#ifdef WIN32</span>
00596     HANDLE               eventlog_h;
00597 <span class="preprocessor">#else</span>
00598     <span class="keywordtype">void</span>                *eventlog_h = NULL;
00599 <span class="preprocessor">#endif</span>
00600 
00601     snmp_disable_syslog();      <span class="comment">/* ??? */</span>
00602 <span class="preprocessor">#ifdef WIN32</span>
00603     eventlog_h = OpenEventLog(NULL, ident);
00604     <span class="keywordflow">if</span> (eventlog_h == NULL) {
00605             <span class="comment">/*</span>
00606 <span class="comment">             * Hmmm.....</span>
00607 <span class="comment">             * Maybe disable this handler, and log the error ?</span>
00608 <span class="comment">             */</span>
00609         fprintf(stderr, <span class="stringliteral">"Could not open event log for %s. "</span>
00610                 <span class="stringliteral">"Last error: 0x%x\n"</span>, ident, GetLastError());
00611         enable = 0;
00612     }
00613 <span class="preprocessor">#else</span>
00614     openlog(snmp_log_syslogname(ident), LOG_CONS | LOG_PID, facility);
00615 <span class="preprocessor">#endif</span>
00616 
00617     <span class="keywordflow">for</span> (logh = logh_head; logh; logh = logh-&gt;next)
00618         <span class="keywordflow">if</span> (logh-&gt;type == NETSNMP_LOGHANDLER_SYSLOG) {
00619             logh-&gt;magic   = (<span class="keywordtype">void</span>*)eventlog_h;
00620             logh-&gt;imagic  = enable;     <span class="comment">/* syslog open */</span>
00621             logh-&gt;enabled = enable;
00622             found         = 1;
00623         }
00624 
00625     <span class="keywordflow">if</span> (!found) {
00626         logh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_SYSLOG,
00627                                            LOG_DEBUG );
00628         <span class="keywordflow">if</span> (logh) {
00629             logh-&gt;magic    = (<span class="keywordtype">void</span>*)eventlog_h;
00630             logh-&gt;token    = strdup(ident);
00631             logh-&gt;imagic   = enable;    <span class="comment">/* syslog open */</span>
00632             logh-&gt;enabled  = enable;
00633         }
00634     }
00635 }
00636 
00637 <span class="keywordtype">void</span>
00638 netsnmp_enable_filelog(netsnmp_log_handler *logh, <span class="keywordtype">int</span> dont_zero_log)
00639 {
00640     FILE *logfile;
00641 
00642     <span class="keywordflow">if</span> (!logh)
00643         <span class="keywordflow">return</span>;
00644 
00645     <span class="keywordflow">if</span> (!logh-&gt;magic) {
00646         logfile = fopen(logh-&gt;token, dont_zero_log ? <span class="stringliteral">"a"</span> : <span class=
"stringliteral">"w"</span>);
00647         <span class="keywordflow">if</span> (!logfile)
00648             <span class="keywordflow">return</span>;
00649         logh-&gt;magic = (<span class="keywordtype">void</span>*)logfile;
00650 <span class="preprocessor">#ifdef WIN32</span>
00651         <span class="comment">/*</span>
00652 <span class="comment">         * Apparently, "line buffering" under Windows is</span>
00653 <span class="comment">         *  actually implemented as "full buffering".</span>
00654 <span class="comment">         *  Let's try turning off buffering completely.</span>
00655 <span class="comment">         */</span>
00656         setvbuf(logfile, NULL, _IONBF, BUFSIZ);
00657 <span class="preprocessor">#else</span>
00658         setvbuf(logfile, NULL, _IOLBF, BUFSIZ);
00659 <span class="preprocessor">#endif</span>
00660     }
00661     logh-&gt;enabled = 1;
00662 }
00663 
00664 <span class="keywordtype">void</span>
00665 snmp_enable_filelog(<span class="keyword">const</span> <span class="keywordtype">char</span> *logfilename, <span class=
"keywordtype">int</span> dont_zero_log)
00666 {
00667     netsnmp_log_handler *logh;
00668 
00669     snmp_disable_filelog();     <span class="comment">/* XXX ??? */</span>
00670 
00671     <span class="keywordflow">if</span> (logfilename) {
00672         logh = netsnmp_find_loghandler( logfilename );
00673         <span class="keywordflow">if</span> (!logh) {
00674             logh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_FILE,
00675                                                LOG_DEBUG );
00676             <span class="keywordflow">if</span> (logh)
00677                 logh-&gt;token = strdup(logfilename);
00678         }
00679         <span class="keywordflow">if</span> (logh)
00680             netsnmp_enable_filelog(logh, dont_zero_log);
00681     } <span class="keywordflow">else</span> {
00682         <span class="keywordflow">for</span> (logh = logh_head; logh; logh = logh-&gt;next)
00683             <span class="keywordflow">if</span> (logh-&gt;type == NETSNMP_LOGHANDLER_FILE)
00684                 netsnmp_enable_filelog(logh, dont_zero_log);
00685     }
00686 }
00687 
00688 
00689 <span class="keywordtype">void</span>
00690 snmp_enable_stderrlog(<span class="keywordtype">void</span>)
00691 {
00692     netsnmp_log_handler *logh;
00693     <span class="keywordtype">int</span>                  found = 0;
00694 
00695     <span class="keywordflow">for</span> (logh = logh_head; logh; logh = logh-&gt;next)
00696         <span class="keywordflow">if</span> (logh-&gt;type == NETSNMP_LOGHANDLER_STDOUT ||
00697             logh-&gt;type == NETSNMP_LOGHANDLER_STDERR) {
00698             logh-&gt;enabled = 1;
00699             found         = 1;
00700         }
00701 
00702     <span class="keywordflow">if</span> (!found) {
00703         logh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_STDERR,
00704                                            LOG_DEBUG );
00705         <span class="keywordflow">if</span> (logh)
00706             logh-&gt;token    = strdup(<span class="stringliteral">"stderr"</span>);
00707     }
00708 }
00709 
00710 
00711 <span class="keywordtype">void</span>
00712 snmp_enable_calllog(<span class="keywordtype">void</span>)       <span class=
"comment">/* XXX - or take a callback routine ??? */</span>
00713 {
00714     netsnmp_log_handler *logh;
00715     <span class="keywordtype">int</span>                  found = 0;
00716 
00717     <span class="keywordflow">for</span> (logh = logh_head; logh; logh = logh-&gt;next) {
00718         <span class="keywordflow">if</span> (logh-&gt;type == NETSNMP_LOGHANDLER_CALLBACK)
00719             logh-&gt;enabled = 1;
00720             found         = 1;
00721         }
00722 
00723     <span class="keywordflow">if</span> (!found) {
00724         logh = netsnmp_register_loghandler(NETSNMP_LOGHANDLER_CALLBACK,
00725                                            LOG_DEBUG );
00726         <span class="keywordflow">if</span> (logh)
00727             logh-&gt;token    = strdup(<span class="stringliteral">"callback"</span>);
00728     }
00729 }
00730 
00731 
00732 
00733 <span class="comment">/* ==================================================== */</span>
00734 
00735 
00736 netsnmp_log_handler *
00737 netsnmp_find_loghandler( <span class="keyword">const</span> <span class="keywordtype">char</span> *token )
00738 {
00739     netsnmp_log_handler *logh;
00740     <span class="keywordflow">if</span> (!token)
00741         <span class="keywordflow">return</span> NULL;
00742 
00743     <span class="keywordflow">for</span> (logh = logh_head; logh; logh = logh-&gt;next)
00744         <span class="keywordflow">if</span> (logh-&gt;token &amp;&amp; !strcmp( token, logh-&gt;token ))
00745             <span class="keywordflow">break</span>;
00746 
00747     <span class="keywordflow">return</span> logh;
00748 }
00749 
00750 <span class="keywordtype">int</span>
00751 netsnmp_add_loghandler( netsnmp_log_handler *logh )
00752 {
00753     <span class="keywordtype">int</span> i;
00754     netsnmp_log_handler *logh2;
00755 
00756     <span class="keywordflow">if</span> (!logh)
00757         <span class="keywordflow">return</span> 0;
00758 
00759     <span class="comment">/*</span>
00760 <span class="comment">     * Find the appropriate point for the new entry...</span>
00761 <span class="comment">     *   (logh2 will point to the entry immediately following)</span>
00762 <span class="comment">     */</span>
00763     <span class="keywordflow">for</span> (logh2 = logh_head; logh2; logh2 = logh2-&gt;next)
00764         <span class="keywordflow">if</span> ( logh2-&gt;priority &gt;= logh-&gt;priority )
00765             <span class="keywordflow">break</span>;
00766 
00767     <span class="comment">/*</span>
00768 <span class="comment">     * ... and link it into the main list.</span>
00769 <span class="comment">     */</span>
00770     <span class="keywordflow">if</span> (logh2) {
00771         <span class="keywordflow">if</span> (logh2-&gt;prev)
00772             logh2-&gt;prev-&gt;next = logh;
00773         <span class="keywordflow">else</span>
00774             logh_head = logh;
00775         logh-&gt;next  = logh2;
00776         logh2-&gt;prev = logh;
00777     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (logh_head ) {
00778         <span class="comment">/*</span>
00779 <span class="comment">         * If logh2 is NULL, we're tagging on to the end</span>
00780 <span class="comment">         */</span>
00781         <span class="keywordflow">for</span> (logh2 = logh_head; logh2-&gt;next; logh2 = logh2-&gt;next)
00782             ;
00783         logh2-&gt;next = logh;
00784     } <span class="keywordflow">else</span> {
00785         logh_head = logh;
00786     }
00787 
00788     <span class="comment">/*</span>
00789 <span class="comment">     * Also tweak the relevant priority-'index' array.</span>
00790 <span class="comment">     */</span>
00791     <span class="keywordflow">for</span> (i=LOG_EMERG; i&lt;=logh-&gt;priority; i++)
00792         <span class="keywordflow">if</span> (!logh_priorities[i] ||
00793              logh_priorities[i]-&gt;priority &gt;= logh-&gt;priority)
00794              logh_priorities[i] = logh;
00795 
00796     <span class="keywordflow">return</span> 1;
00797 }
00798 
00799 netsnmp_log_handler *
00800 netsnmp_register_loghandler( <span class="keywordtype">int</span> type, <span class="keywordtype">int</span> priority )
00801 {
00802     netsnmp_log_handler *logh;
00803 
00804     logh = <a class="code" href="group__util.html#ga39">SNMP_MALLOC_TYPEDEF</a>(netsnmp_log_handler);
00805     <span class="keywordflow">if</span> (!logh)
00806         <span class="keywordflow">return</span> NULL;
00807 
00808     logh-&gt;type     = type;
00809     <span class="keywordflow">switch</span> ( type ) {
00810     <span class="keywordflow">case</span> NETSNMP_LOGHANDLER_STDOUT:
00811         logh-&gt;imagic  = 1;
00812         <span class="comment">/* fallthrough */</span>
00813     <span class="keywordflow">case</span> NETSNMP_LOGHANDLER_STDERR:
00814         logh-&gt;handler = log_handler_stdouterr;
00815         <span class="keywordflow">break</span>;
00816 
00817     <span class="keywordflow">case</span> NETSNMP_LOGHANDLER_FILE:
00818         logh-&gt;handler = log_handler_file;
00819         logh-&gt;imagic  = 1;
00820         <span class="keywordflow">break</span>;
00821     <span class="keywordflow">case</span> NETSNMP_LOGHANDLER_SYSLOG:
00822         logh-&gt;handler = log_handler_syslog;
00823         <span class="keywordflow">break</span>;
00824     <span class="keywordflow">case</span> NETSNMP_LOGHANDLER_CALLBACK:
00825         logh-&gt;handler = log_handler_callback;
00826         <span class="keywordflow">break</span>;
00827     <span class="keywordflow">case</span> NETSNMP_LOGHANDLER_NONE:
00828         logh-&gt;handler = log_handler_null;
00829         <span class="keywordflow">break</span>;
00830     <span class="keywordflow">default</span>:
00831         free(logh);
00832         <span class="keywordflow">return</span> NULL;
00833     }
00834     logh-&gt;priority = priority;
00835     logh-&gt;enabled  = 1;
00836     netsnmp_add_loghandler( logh );
00837     <span class="keywordflow">return</span> logh;
00838 }
00839 
00840 
00841 <span class="keywordtype">int</span>
00842 netsnmp_enable_loghandler( <span class="keyword">const</span> <span class="keywordtype">char</span> *token )
00843 {
00844     netsnmp_log_handler *logh;
00845 
00846     logh = netsnmp_find_loghandler( token );
00847     <span class="keywordflow">if</span> (!logh)
00848         <span class="keywordflow">return</span> 0;
00849     logh-&gt;enabled = 1;
00850     <span class="keywordflow">return</span> 1;
00851 }
00852 
00853 
00854 <span class="keywordtype">int</span>
00855 netsnmp_disable_loghandler( <span class="keyword">const</span> <span class="keywordtype">char</span> *token )
00856 {
00857     netsnmp_log_handler *logh;
00858 
00859     logh = netsnmp_find_loghandler( token );
00860     <span class="keywordflow">if</span> (!logh)
00861         <span class="keywordflow">return</span> 0;
00862     logh-&gt;enabled = 0;
00863     <span class="keywordflow">return</span> 1;
00864 }
00865 
00866 <span class="keywordtype">int</span>
00867 netsnmp_remove_loghandler( netsnmp_log_handler *logh )
00868 {
00869     <span class="keywordflow">if</span> (!logh)
00870         <span class="keywordflow">return</span> 0;
00871 
00872     <span class="keywordflow">if</span> (logh-&gt;prev)
00873         logh-&gt;prev-&gt;next = logh-&gt;next;
00874     <span class="keywordflow">else</span>
00875         logh_head = logh-&gt;next;
00876 
00877     <span class="keywordflow">if</span> (logh-&gt;next)
00878         logh-&gt;next-&gt;prev = logh-&gt;prev;
00879     <span class="keywordflow">return</span> 1;
00880 }
00881 
00882 <span class="comment">/* ==================================================== */</span>
00883 
00884 <span class="keywordtype">int</span>
00885 log_handler_stdouterr(  netsnmp_log_handler* logh, <span class="keywordtype">int</span> pri, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *string)
00886 {
00887     <span class="keywordtype">char</span>            sbuf[40];
00888 
00889     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
00890                                NETSNMP_DS_LIB_LOG_TIMESTAMP) &amp;&amp; newline) {
00891         sprintf_stamp(NULL, sbuf);
00892     } <span class="keywordflow">else</span> {
00893         strcpy(sbuf, <span class="stringliteral">""</span>);
00894     }
00895     newline = string[strlen(string) - 1] == <span class="charliteral">'\n'</span>;       <span class=
"comment">/* XXX - Eh ? */</span>
00896 
00897     <span class="keywordflow">if</span> (logh-&gt;imagic)
00898        printf(         <span class="stringliteral">"%s%s"</span>, sbuf, string);
00899     <span class="keywordflow">else</span>
00900        fprintf(stderr, <span class="stringliteral">"%s%s"</span>, sbuf, string);
00901 
00902     <span class="keywordflow">return</span> 1;
00903 }
00904 
00905 
00906 <span class="preprocessor">#ifdef WIN32</span>
00907 <span class="keywordtype">int</span>
00908 log_handler_syslog(  netsnmp_log_handler* logh, <span class="keywordtype">int</span> pri, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *string)
00909 {
00910     WORD            etype;
00911     LPCTSTR         event_msg[2];
00912     HANDLE          eventlog_h = logh-&gt;magic;
00913 
00914         <span class="comment">/*</span>
00915 <span class="comment">         **  EVENT TYPES:</span>
00916 <span class="comment">         **</span>
00917 <span class="comment">         **  Information (EVENTLOG_INFORMATION_TYPE)</span>
00918 <span class="comment">         **      Information events indicate infrequent but significant</span>
00919 <span class="comment">         **      successful operations.</span>
00920 <span class="comment">         **  Warning (EVENTLOG_WARNING_TYPE)</span>
00921 <span class="comment">         **      Warning events indicate problems that are not immediately</span>
00922 <span class="comment">         **      significant, but that may indicate conditions that could</span>
00923 <span class="comment">         **      cause future problems. Resource consumption is a good</span>
00924 <span class="comment">         **      candidate for a warning event.</span>
00925 <span class="comment">         **  Error (EVENTLOG_ERROR_TYPE)</span>
00926 <span class="comment">         **      Error events indicate significant problems that the user</span>
00927 <span class="comment">         **      should know about. Error events usually indicate a loss of</span>
00928 <span class="comment">         **      functionality or data.</span>
00929 <span class="comment">         */</span>
00930     <span class="keywordflow">switch</span> (pri) {
00931         <span class="keywordflow">case</span> LOG_EMERG:
00932         <span class="keywordflow">case</span> LOG_ALERT:
00933         <span class="keywordflow">case</span> LOG_CRIT:
00934         <span class="keywordflow">case</span> LOG_ERR:
00935             etype = EVENTLOG_ERROR_TYPE;
00936             <span class="keywordflow">break</span>;
00937         <span class="keywordflow">case</span> LOG_WARNING:
00938             etype = EVENTLOG_WARNING_TYPE;
00939             <span class="keywordflow">break</span>;
00940         <span class="keywordflow">case</span> LOG_NOTICE:
00941         <span class="keywordflow">case</span> LOG_INFO:
00942         <span class="keywordflow">case</span> LOG_DEBUG:
00943             etype = EVENTLOG_INFORMATION_TYPE;
00944             <span class="keywordflow">break</span>;
00945         <span class="keywordflow">default</span>:
00946             etype = EVENTLOG_INFORMATION_TYPE;
00947             <span class="keywordflow">break</span>;
00948     }
00949     event_msg[0] = string;
00950     event_msg[1] = NULL;
00951     <span class="comment">/* NOTE: 4th parameter must match winservice.mc:MessageId value */</span>
00952     <span class="keywordflow">if</span> (!ReportEvent(eventlog_h, etype, 0, 100, NULL, 1, 0, event_msg, NULL)) {
00953             <span class="comment">/*</span>
00954 <span class="comment">             * Hmmm.....</span>
00955 <span class="comment">             * Maybe disable this handler, and log the error ?</span>
00956 <span class="comment">             */</span>
00957         fprintf(stderr, <span class="stringliteral">"Could not report event.  Last error: 0x%x\n"</span>,
00958                         GetLastError());
00959         <span class="keywordflow">return</span> 0;
00960     }
00961     <span class="keywordflow">return</span> 1;
00962 }
00963 <span class="preprocessor">#else</span>
00964 <span class="keywordtype">int</span>
00965 log_handler_syslog(  netsnmp_log_handler* logh, <span class="keywordtype">int</span> pri, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *string)
00966 {
00967         <span class="comment">/*</span>
00968 <span class="comment">         * XXX</span>
00969 <span class="comment">         * We've got three items of information to work with:</span>
00970 <span class="comment">         *     Is the syslog currently open?</span>
00971 <span class="comment">         *     What ident string to use?</span>
00972 <span class="comment">         *     What facility to log to?</span>
00973 <span class="comment">         *</span>
00974 <span class="comment">         * We've got two "magic" locations (imagic &amp; magic) plus the token</span>
00975 <span class="comment">         */</span>
00976     <span class="keywordflow">if</span> (!(logh-&gt;imagic)) {
00977         <span class="keyword">const</span> <span class="keywordtype">char</span> *ident    = logh-&gt;token;
00978         <span class="keywordtype">int</span>   facility = (int)logh-&gt;magic;
00979         <span class="keywordflow">if</span> (!ident)
00980             ident = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
00981                                           NETSNMP_DS_LIB_APPTYPE);
00982         openlog(ident, LOG_CONS | LOG_PID, facility);
00983         logh-&gt;imagic = 1;
00984     }
00985     syslog( pri, <span class="stringliteral">"%s"</span>, string );
00986     <span class="keywordflow">return</span> 1;
00987 }
00988 <span class="preprocessor">#endif </span><span class="comment">/* !WIN32 */</span>
00989 
00990 
00991 <span class="keywordtype">int</span>
00992 log_handler_file(    netsnmp_log_handler* logh, <span class="keywordtype">int</span> pri, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *string)
00993 {
00994     FILE           *fhandle;
00995     <span class="keywordtype">char</span>            sbuf[40];
00996 
00997     <span class="comment">/*</span>
00998 <span class="comment">     * We use imagic to save information about whether the next output</span>
00999 <span class="comment">     * will start a new line, and thus might need a timestamp</span>
01000 <span class="comment">     */</span>
01001     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
01002                                NETSNMP_DS_LIB_LOG_TIMESTAMP) &amp;&amp; logh-&gt;imagic) {
01003         sprintf_stamp(NULL, sbuf);
01004     } <span class="keywordflow">else</span> {
01005         strcpy(sbuf, <span class="stringliteral">""</span>);
01006     }
01007 
01008     <span class="comment">/*</span>
01009 <span class="comment">     * If we haven't already opened the file, then do so.</span>
01010 <span class="comment">     * Save the filehandle pointer for next time.</span>
01011 <span class="comment">     *</span>
01012 <span class="comment">     * Note that this should still work, even if the file</span>
01013 <span class="comment">     * is closed in the meantime (e.g. a regular "cleanup" sweep)</span>
01014 <span class="comment">     */</span>
01015     fhandle = (FILE*)logh-&gt;magic;
01016     <span class="keywordflow">if</span> (!logh-&gt;magic) {
01017         fhandle = fopen(logh-&gt;token, <span class="stringliteral">"a+"</span>);
01018         <span class="keywordflow">if</span> (!fhandle)
01019             <span class="keywordflow">return</span> 0;
01020         logh-&gt;magic = (<span class="keywordtype">void</span>*)fhandle;
01021     }
01022     fprintf(fhandle, <span class="stringliteral">"%s%s"</span>, sbuf, string);
01023     fflush(fhandle);
01024     logh-&gt;imagic = string[strlen(string) - 1] == <span class="charliteral">'\n'</span>;
01025     <span class="keywordflow">return</span> 1;
01026 }
01027 
01028 <span class="keywordtype">int</span>
01029 log_handler_callback(netsnmp_log_handler* logh, <span class="keywordtype">int</span> pri, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *string)
01030 {
01031         <span class="comment">/*</span>
01032 <span class="comment">         * XXX - perhaps replace 'snmp_call_callbacks' processing</span>
01033 <span class="comment">         *       with individual callback log_handlers ??</span>
01034 <span class="comment">         */</span>
01035     <span class="keyword">struct </span>snmp_log_message slm;
01036     <span class="keywordtype">int</span>             dodebug = snmp_get_do_debugging();
01037 
01038     slm.priority = pri;
01039     slm.msg = string;
01040     <span class="keywordflow">if</span> (dodebug)            <span class=
"comment">/* turn off debugging inside the callbacks else will loop */</span>
01041         snmp_set_do_debugging(0);
01042     <a class="code" href=
"group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_LOGGING, &amp;slm);
01043     <span class="keywordflow">if</span> (dodebug)
01044         snmp_set_do_debugging(dodebug);
01045     <span class="keywordflow">return</span> 1;
01046 }
01047 
01048 <span class="keywordtype">int</span>
01049 log_handler_null(    netsnmp_log_handler* logh, <span class="keywordtype">int</span> pri, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *string)
01050 {
01051     <span class="comment">/*</span>
01052 <span class="comment">     * Dummy log handler - just throw away the error completely</span>
01053 <span class="comment">     * You probably don't really want to do this!</span>
01054 <span class="comment">     */</span>
01055     <span class="keywordflow">return</span> 1;
01056 }
01057 
01058 <span class="keywordtype">void</span>
01059 snmp_log_string(<span class="keywordtype">int</span> priority, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *string)
01060 {
01061     netsnmp_log_handler *logh;
01062 
01063     <span class="comment">/*</span>
01064 <span class="comment">     * We've got to be able to log messages *somewhere*!</span>
01065 <span class="comment">     * If you don't want stderr logging, then enable something else.</span>
01066 <span class="comment">     */</span>
01067     <span class="keywordflow">if</span> (!logh_head) {
01068         snmp_enable_stderrlog();
01069         snmp_log_string(LOG_WARNING,
01070                         <span class="stringliteral">"No log handling enabled - turning on stderr logging\n"</span>);
01071     }
01072 
01073     <span class="comment">/*</span>
01074 <span class="comment">     * Start at the given priority, and work "upwards"....</span>
01075 <span class="comment">     */</span>
01076     logh = logh_priorities[priority];
01077     <span class="keywordflow">for</span> ( ; logh; logh = logh-&gt;next ) {
01078         <span class="comment">/*</span>
01079 <span class="comment">         * ... but skipping any handlers with a "maximum priority"</span>
01080 <span class="comment">         *     that we have already exceeded.</span>
01081 <span class="comment">         */</span>
01082         <span class="keywordflow">if</span> (priority &gt;= logh-&gt;pri_max)
01083             logh-&gt;handler( logh, priority, string );
01084     }
01085 }
01086 
01087 <span class="comment">/* ==================================================== */</span>
01088 
01089 
01090 <span class="keywordtype">int</span>
01091 snmp_vlog(<span class="keywordtype">int</span> priority, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *format, va_list ap)
01092 {
01093     <span class="keywordtype">char</span>            buffer[LOGLENGTH];
01094     <span class="keywordtype">int</span>             length;
01095     <span class="keywordtype">char</span>           *dynamic;
01096 
01097     length = vsnprintf(buffer, LOGLENGTH, format, ap);
01098 
01099     <span class="keywordflow">if</span> (length == 0)
01100         <span class="keywordflow">return</span> (0);             <span class="comment">/* Empty string */</span>
01101 
01102     <span class="keywordflow">if</span> (length == -1) {
01103         snmp_log_string(LOG_ERR, <span class="stringliteral">"Could not format log-string\n"</span>);
01104         <span class="keywordflow">return</span> (-1);
01105     }
01106 
01107     <span class="keywordflow">if</span> (length &lt; LOGLENGTH) {
01108         snmp_log_string(priority, buffer);
01109         <span class="keywordflow">return</span> (0);
01110     }
01111 
01112     dynamic = (<span class="keywordtype">char</span> *) malloc(length + 1);
01113     <span class="keywordflow">if</span> (dynamic == NULL) {
01114         snmp_log_string(LOG_ERR,
01115                         <span class="stringliteral">"Could not allocate memory for log-message\n"</span>);
01116         snmp_log_string(priority, buffer);
01117         <span class="keywordflow">return</span> (-2);
01118     }
01119 
01120     vsnprintf(dynamic, length + 1, format, ap);
01121     snmp_log_string(priority, dynamic);
01122     free(dynamic);
01123     <span class="keywordflow">return</span> 0;
01124 }
01125 
01133 <span class="keywordtype">int</span>
01134 <span class="preprocessor">#if HAVE_STDARG_H</span>
01135 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(<span class=
"keywordtype">int</span> priority, <span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...)
01136 #<span class="keywordflow">else</span>
<a name="l01137" id="l01137"></a><a class="code" href="group__snmp__logging.html#ga39">01137</a> <a class="code" href=
"group__snmp__logging.html#ga39">snmp_log</a>(va_alist)
01138      va_dcl
01139 #endif
01140 {
01141     va_list         ap;
01142     <span class="keywordtype">int</span>             ret;
01143 <span class="preprocessor">#if HAVE_STDARG_H</span>
01144     va_start(ap, format);
01145 <span class="preprocessor">#else</span>
01146     <span class="keywordtype">int</span>             priority;
01147     <span class="keyword">const</span> <span class="keywordtype">char</span>     *format;
01148     va_start(ap);
01149 
01150     priority = va_arg(ap, <span class="keywordtype">int</span>);
01151     format = va_arg(ap, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
01152 <span class="preprocessor">#endif</span>
01153     ret = snmp_vlog(priority, format, ap);
01154     va_end(ap);
01155     <span class="keywordflow">return</span> (ret);
01156 }
01157 
01158 <span class="comment">/*</span>
01159 <span class="comment"> * log a critical error.</span>
01160 <span class="comment"> */</span>
01161 <span class="keywordtype">void</span>
01162 snmp_log_perror(<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
01163 {
01164     <span class="keywordtype">char</span>           *error = strerror(errno);
01165     <span class="keywordflow">if</span> (s) {
01166         <span class="keywordflow">if</span> (error)
01167             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"%s: %s\n"</span>, s, error);
01168         <span class="keywordflow">else</span>
01169             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"%s: Error %d out-of-range\n"</span>, s, errno);
01170     } <span class="keywordflow">else</span> {
01171         <span class="keywordflow">if</span> (error)
01172             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"%s\n"</span>, error);
01173         <span class="keywordflow">else</span>
01174             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Error %d out-of-range\n"</span>, errno);
01175     }
01176 }
01177 
01178 <span class="comment">/* external access to logh_head variable */</span>
01179 netsnmp_log_handler  *
01180 get_logh_head(<span class="keywordtype">void</span>)
01181 {
01182         <span class="keywordflow">return</span> logh_head;
01183 }
01184 
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small><!--#include virtual="/sfbutton.html" --><br />
    Generated on Thu Nov 25 17:51:41 2004 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

