<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <div class="navigation" id="top">
    <div class="tabs">
      <ul>
        <li><a href="index.html"><span>Main Page</span></a></li>

        <li><a href="pages.html"><span>Related Pages</span></a></li>

        <li><a href="modules.html"><span>Modules</span></a></li>

        <li><a href="annotated.html"><span>Data Structures</span></a></li>

        <li class="current"><a href="files.html"><span>Files</span></a></li>

        <li><a href="examples.html"><span>Examples</span></a></li>
      </ul>
    </div>

    <div class="tabs">
      <ul>
        <li><a href="files.html"><span>File List</span></a></li>

        <li><a href="globals.html"><span>Globals</span></a></li>
      </ul>
    </div>

    <h1>snmpDTLSUDPDomain.c</h1>

    <div class="fragment">
      <pre class="fragment">
<a name="l00001" id="l00001"></a>00001 <span class=
"comment">/* Portions of this file are subject to the following copyright(s).  See</span>
<a name="l00002" id="l00002"></a>00002 <span class=
"comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
<a name="l00003" id="l00003"></a>00003 <span class="comment"> * that may apply:</span>
<a name="l00004" id="l00004"></a>00004 <span class="comment"> */</span>
<a name="l00005" id="l00005"></a>00005 <span class="comment">/*</span>
<a name="l00006" id="l00006"></a>00006 <span class="comment"> * Portions of this file are copyrighted by:</span>
<a name="l00007" id="l00007"></a>00007 <span class=
"comment"> * Copyright Copyright 2003 Sun Microsystems, Inc. All rights reserved.</span>
<a name="l00008" id="l00008"></a>00008 <span class=
"comment"> * Use is subject to license terms specified in the COPYING file</span>
<a name="l00009" id="l00009"></a>00009 <span class="comment"> * distributed with the Net-SNMP package.</span>
<a name="l00010" id="l00010"></a>00010 <span class="comment"> */</span>
<a name="l00011" id="l00011"></a>00011 
<a name="l00012" id="l00012"></a>00012 <span class="comment">/*</span>
<a name="l00013" id="l00013"></a>00013 <span class=
"comment"> * NOTE: THIS IS AN EXPERIMENTAL IMPLEMENTATION AND NOT YET SUITABLE</span>
<a name="l00014" id="l00014"></a>00014 <span class="comment"> * FOR PRODUCTION USE</span>
<a name="l00015" id="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016" id="l00016"></a>00016 <span class="comment"> * THERE are KNOWN security ISSUES with THIS code!</span>
<a name="l00017" id="l00017"></a>00017 <span class=
"comment"> * (if nothing else, you can't tie certificates to certain hosts/users)</span>
<a name="l00018" id="l00018"></a>00018 <span class="comment"> */</span>
<a name="l00019" id="l00019"></a>00019 
<a name="l00020" id="l00020"></a>00020 <span class="comment">/*</span>
<a name="l00021" id="l00021"></a>00021 <span class="comment"> * ---------- Creating Certificates ----------</span>
<a name="l00022" id="l00022"></a>00022 <span class="comment"> *</span>
<a name="l00023" id="l00023"></a>00023 <span class=
"comment"> * Example pub/priv key creation steps using openssl (replace for-user</span>
<a name="l00024" id="l00024"></a>00024 <span class=
"comment"> * with the appropriate name, etc (e.g. for a user you might use their</span>
<a name="l00025" id="l00025"></a>00025 <span class=
"comment"> * first.last name and for a server, use it's hostname or something)</span>
<a name="l00026" id="l00026"></a>00026 <span class="comment"> *</span>
<a name="l00027" id="l00027"></a>00027 <span class="comment"> *   1) create the CSR file first:</span>
<a name="l00028" id="l00028"></a>00028 <span class="comment"> *</span>
<a name="l00029" id="l00029"></a>00029 <span class=
"comment"> *         openssl req -days 365 -new -out for-user.csr -keyout for-user.priv</span>
<a name="l00030" id="l00030"></a>00030 <span class="comment"> *</span>
<a name="l00031" id="l00031"></a>00031 <span class=
"comment"> *   2) Optionally remove the passphrase if you hate that sort of thing</span>
<a name="l00032" id="l00032"></a>00032 <span class=
"comment"> *      (obviously not recommended; useful on servers without password prompts)</span>
<a name="l00033" id="l00033"></a>00033 <span class="comment"> *</span>
<a name="l00034" id="l00034"></a>00034 <span class=
"comment"> *         openssl rsa -in for-user.priv -out for-user.insecure.priv</span>
<a name="l00035" id="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036" id="l00036"></a>00036 <span class="comment"> *   3) Create a self-signed key from the CSR:</span>
<a name="l00037" id="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038" id="l00038"></a>00038 <span class=
"comment"> *      openssl x509 -set_serial `date +%Y%m%d` -in for-user.csr -out for-user.cert -req -signkey for-user.insecure.priv -days 365</span>
<a name="l00039" id="l00039"></a>00039 <span class="comment"> *</span>
<a name="l00040" id="l00040"></a>00040 <span class="comment"> *</span>
<a name="l00041" id="l00041"></a>00041 <span class=
"comment"> * These can then be used by the config tokens for both the client and</span>
<a name="l00042" id="l00042"></a>00042 <span class="comment"> * the server:</span>
<a name="l00043" id="l00043"></a>00043 <span class="comment"> *</span>
<a name="l00044" id="l00044"></a>00044 <span class="comment"> * ---------- Creating a CA for issuing certs ----------</span>
<a name="l00045" id="l00045"></a>00045 <span class="comment"> *</span>
<a name="l00046" id="l00046"></a>00046 <span class="comment"> * TBD</span>
<a name="l00047" id="l00047"></a>00047 <span class="comment"> *</span>
<a name="l00048" id="l00048"></a>00048 <span class="comment"> * ---------- Configuration ----------</span>
<a name="l00049" id="l00049"></a>00049 <span class="comment"> *</span>
<a name="l00050" id="l00050"></a>00050 <span class="comment"> * In the snmp.conf file, you should specify the following</span>
<a name="l00051" id="l00051"></a>00051 <span class="comment"> * types of configuration lines:</span>
<a name="l00052" id="l00052"></a>00052 <span class="comment"> *</span>
<a name="l00053" id="l00053"></a>00053 <span class=
"comment"> * To tell the client which keys *it* should use to authenticate with:</span>
<a name="l00054" id="l00054"></a>00054 <span class="comment"> *</span>
<a name="l00055" id="l00055"></a>00055 <span class="comment"> *   defX509ClientPriv /path/to/for-user.insecure.priv</span>
<a name="l00056" id="l00056"></a>00056 <span class="comment"> *   defX509ClientPub  /path/to/for-user.insecure.cert</span>
<a name="l00057" id="l00057"></a>00057 <span class="comment"> *</span>
<a name="l00058" id="l00058"></a>00058 <span class="comment"> * To tell the client to only a list of servers:</span>
<a name="l00059" id="l00059"></a>00059 <span class="comment"> *</span>
<a name="l00060" id="l00060"></a>00060 <span class="comment"> *   defX509ServerCerts /path/to/server-certs.certs</span>
<a name="l00061" id="l00061"></a>00061 <span class="comment"> *</span>
<a name="l00062" id="l00062"></a>00062 <span class=
"comment"> *   (server-certs.certs can be created by simply cat'ing multiple</span>
<a name="l00063" id="l00063"></a>00063 <span class="comment"> *    server cert files into ones big file)</span>
<a name="l00064" id="l00064"></a>00064 <span class="comment"> *</span>
<a name="l00065" id="l00065"></a>00065 <span class="comment"> * To tell the server it's certs to offer:</span>
<a name="l00066" id="l00066"></a>00066 <span class="comment"> *</span>
<a name="l00067" id="l00067"></a>00067 <span class="comment"> *   defX509ServerPub  /path/to/server1.insecure.cert</span>
<a name="l00068" id="l00068"></a>00068 <span class="comment"> *   defX509ServerPriv /path/to/server1.insecure.priv</span>
<a name="l00069" id="l00069"></a>00069 <span class="comment"> *</span>
<a name="l00070" id="l00070"></a>00070 <span class=
"comment"> * To tell the server which keys it should accept from clients:</span>
<a name="l00071" id="l00071"></a>00071 <span class="comment"> *</span>
<a name="l00072" id="l00072"></a>00072 <span class="comment"> *   defX509ClientCerts /path/to/client-certs.certs</span>
<a name="l00073" id="l00073"></a>00073 <span class="comment"> *</span>
<a name="l00074" id="l00074"></a>00074 <span class=
"comment"> * To authorize for R/W a particular CommonName from those certs:</span>
<a name="l00075" id="l00075"></a>00075 <span class="comment"> *</span>
<a name="l00076" id="l00076"></a>00076 <span class="comment"> *   rwuser "John Doe"</span>
<a name="l00077" id="l00077"></a>00077 <span class="comment"> *</span>
<a name="l00078" id="l00078"></a>00078 <span class="comment"> */</span>
<a name="l00079" id="l00079"></a>00079 
<a name="l00080" id="l00080"></a>00080 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
<a name="l00081" id="l00081"></a>00081 
<a name="l00082" id="l00082"></a>00082 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00083" id="l00083"></a>00083 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00084" id="l00084"></a>00084 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
<a name="l00085" id="l00085"></a>00085 <span class="preprocessor">#include &lt;errno.h&gt;</span>
<a name="l00086" id="l00086"></a>00086 
<a name="l00087" id="l00087"></a>00087 <span class="preprocessor">#if HAVE_STRING_H</span>
<a name="l00088" id="l00088"></a>00088 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00089" id="l00089"></a>00089 <span class="preprocessor">#else</span>
<a name="l00090" id="l00090"></a>00090 <span class="preprocessor">#include &lt;strings.h&gt;</span>
<a name="l00091" id="l00091"></a>00091 <span class="preprocessor">#endif</span>
<a name="l00092" id="l00092"></a>00092 <span class="preprocessor">#if HAVE_STDLIB_H</span>
<a name="l00093" id="l00093"></a>00093 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00094" id="l00094"></a>00094 <span class="preprocessor">#endif</span>
<a name="l00095" id="l00095"></a>00095 <span class="preprocessor">#if HAVE_UNISTD_H</span>
<a name="l00096" id="l00096"></a>00096 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00097" id="l00097"></a>00097 <span class="preprocessor">#endif</span>
<a name="l00098" id="l00098"></a>00098 <span class="preprocessor">#if HAVE_SYS_SOCKET_H</span>
<a name="l00099" id="l00099"></a>00099 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
<a name="l00100" id="l00100"></a>00100 <span class="preprocessor">#endif</span>
<a name="l00101" id="l00101"></a>00101 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
<a name="l00102" id="l00102"></a>00102 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
<a name="l00103" id="l00103"></a>00103 <span class="preprocessor">#endif</span>
<a name="l00104" id="l00104"></a>00104 <span class="preprocessor">#if HAVE_ARPA_INET_H</span>
<a name="l00105" id="l00105"></a>00105 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
<a name="l00106" id="l00106"></a>00106 <span class="preprocessor">#endif</span>
<a name="l00107" id="l00107"></a>00107 <span class="preprocessor">#if HAVE_NETDB_H</span>
<a name="l00108" id="l00108"></a>00108 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
<a name="l00109" id="l00109"></a>00109 <span class="preprocessor">#endif</span>
<a name="l00110" id="l00110"></a>00110 <span class="preprocessor">#if HAVE_SYS_UIO_H</span>
<a name="l00111" id="l00111"></a>00111 <span class="preprocessor">#include &lt;sys/uio.h&gt;</span>
<a name="l00112" id="l00112"></a>00112 <span class="preprocessor">#endif</span>
<a name="l00113" id="l00113"></a>00113 
<a name="l00114" id="l00114"></a>00114 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
<a name="l00115" id="l00115"></a>00115 <span class="preprocessor">#include &lt;winsock2.h&gt;</span>
<a name="l00116" id="l00116"></a>00116 <span class="preprocessor">#include &lt;ws2tcpip.h&gt;</span>
<a name="l00117" id="l00117"></a>00117 <span class="preprocessor">#endif</span>
<a name="l00118" id="l00118"></a>00118 
<a name="l00119" id="l00119"></a>00119 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
<a name="l00120" id="l00120"></a>00120 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
<a name="l00121" id="l00121"></a>00121 <span class="preprocessor">#endif</span>
<a name="l00122" id="l00122"></a>00122 
<a name="l00123" id="l00123"></a>00123 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
<a name="l00124" id="l00124"></a>00124 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
<a name="l00125" id="l00125"></a>00125 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
<a name="l00126" id="l00126"></a>00126 
<a name="l00127" id="l00127"></a>00127 <span class="preprocessor">#include &lt;net-snmp/library/snmp_transport.h&gt;</span>
<a name="l00128" id="l00128"></a>00128 <span class="preprocessor">#include &lt;net-snmp/library/snmpDTLSUDPDomain.h&gt;</span>
<a name="l00129" id="l00129"></a>00129 <span class="preprocessor">#include &lt;net-snmp/library/snmpUDPDomain.h&gt;</span>
<a name="l00130" id="l00130"></a>00130 <span class="preprocessor">#include &lt;net-snmp/library/system.h&gt;</span>
<a name="l00131" id="l00131"></a>00131 <span class="preprocessor">#include &lt;<a class="code" href=
"tools_8h.html">net-snmp/library/tools.h</a>&gt;</span>
<a name="l00132" id="l00132"></a>00132 <span class="preprocessor">#include &lt;net-snmp/library/snmp_openssl.h&gt;</span>
<a name="l00133" id="l00133"></a>00133 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
<a name="l00134" id="l00134"></a>00134 
<a name="l00135" id="l00135"></a>00135 <span class="preprocessor">#include "openssl/bio.h"</span>
<a name="l00136" id="l00136"></a>00136 <span class="preprocessor">#include "openssl/ssl.h"</span>
<a name="l00137" id="l00137"></a>00137 <span class="preprocessor">#include "openssl/err.h"</span>
<a name="l00138" id="l00138"></a>00138 
<a name="l00139" id="l00139"></a>00139 <span class="preprocessor">#ifndef INADDR_NONE</span>
<a name="l00140" id="l00140"></a>00140 <span class="preprocessor">#define INADDR_NONE     -1</span>
<a name="l00141" id="l00141"></a>00141 <span class="preprocessor">#endif</span>
<a name="l00142" id="l00142"></a>00142 
<a name="l00143" id="l00143"></a>00143 <span class="preprocessor">#ifdef  MSG_DONTWAIT</span>
<a name="l00144" id="l00144"></a>00144 <span class="preprocessor">#define NETSNMP_DONTWAIT MSG_DONTWAIT</span>
<a name="l00145" id="l00145"></a>00145 <span class="preprocessor">#else</span>
<a name="l00146" id="l00146"></a>00146 <span class="preprocessor">#define NETSNMP_DONTWAIT 0</span>
<a name="l00147" id="l00147"></a>00147 <span class="preprocessor">#endif</span>
<a name="l00148" id="l00148"></a>00148 
<a name="l00149" id="l00149"></a>00149 <span class="preprocessor">#define WE_ARE_SERVER 0</span>
<a name="l00150" id="l00150"></a>00150 <span class="preprocessor">#define WE_ARE_CLIENT 1</span>
<a name="l00151" id="l00151"></a>00151 
<a name="l00152" id="l00152"></a>00152 oid             netsnmpDTLSUDPDomain[] = { TRANSPORT_DOMAIN_DTLS_UDP_IP };
<a name="l00153" id="l00153"></a>00153 <span class=
"keywordtype">size_t</span>          netsnmpDTLSUDPDomain_len = OID_LENGTH(netsnmpDTLSUDPDomain);
<a name="l00154" id="l00154"></a>00154 
<a name="l00155" id="l00155"></a>00155 <span class="keyword">static</span> <a class="code" href=
"structnetsnmp__tdomain__s.html">netsnmp_tdomain</a> dtlsudpDomain;
<a name="l00156" id="l00156"></a>00156 
<a name="l00157" id="l00157"></a>00157 <span class=
"comment">/* this stores openssl credentials for each connection since openssl</span>
<a name="l00158" id="l00158"></a>00158 <span class=
"comment">   can't do it for us at the moment; hopefully future versions will</span>
<a name="l00159" id="l00159"></a>00159 <span class="comment">   change */</span>
<a name="l00160" id="l00160"></a><a class="code" href="structbio__cache__s.html">00160</a> <span class=
"keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbio__cache__s.html">bio_cache_s</a> {
<a name="l00161" id="l00161"></a>00161    BIO *bio;
<a name="l00162" id="l00162"></a>00162    BIO *write_bio;
<a name="l00163" id="l00163"></a>00163    <span class="keyword">struct </span>sockaddr_in sockaddr;
<a name="l00164" id="l00164"></a>00164    uint32_t ipv4addr;
<a name="l00165" id="l00165"></a>00165    u_short portnum;
<a name="l00166" id="l00166"></a>00166    SSL *con;
<a name="l00167" id="l00167"></a>00167    SSL_CTX *ctx;
<a name="l00168" id="l00168"></a>00168    <span class="keyword">struct </span><a class="code" href=
"structbio__cache__s.html">bio_cache_s</a> *next;
<a name="l00169" id="l00169"></a>00169    <span class="keywordtype">int</span> msgnum;
<a name="l00170" id="l00170"></a>00170    <span class="keywordtype">int</span> sock;
<a name="l00171" id="l00171"></a>00171    <span class="keywordtype">char</span> *securityName;
<a name="l00172" id="l00172"></a>00172 } <a class="code" href="structbio__cache__s.html">bio_cache</a>;
<a name="l00173" id="l00173"></a>00173 
<a name="l00174" id="l00174"></a>00174 <a class="code" href="structbio__cache__s.html">bio_cache</a> *biocache = NULL;
<a name="l00175" id="l00175"></a>00175 
<a name="l00176" id="l00176"></a>00176 <span class="comment">/*</span>
<a name="l00177" id="l00177"></a>00177 <span class="comment"> * cached SSL context information</span>
<a name="l00178" id="l00178"></a>00178 <span class=
"comment"> * (in theory we may want more than one per client/server but it's</span>
<a name="l00179" id="l00179"></a>00179 <span class=
"comment"> * unlikely and a CPU and memory waste unless we do need more than one)</span>
<a name="l00180" id="l00180"></a>00180 <span class="comment"> */</span>
<a name="l00181" id="l00181"></a>00181 SSL_CTX *client_ctx, *server_ctx;
<a name="l00182" id="l00182"></a>00182 
<a name="l00183" id="l00183"></a>00183 <span class=
"comment">/* this stores remote connections in a list to search through */</span>
<a name="l00184" id="l00184"></a>00184 <span class="comment">/* XXX: optimize for searching */</span>
<a name="l00185" id="l00185"></a>00185 <span class=
"comment">/* XXX: handle state issues for new connections to reduce DOS issues */</span>
<a name="l00186" id="l00186"></a>00186 <span class=
"comment">/*      (TLS should do this, but openssl can't do more than one ctx per sock */</span>
<a name="l00187" id="l00187"></a>00187 <span class="comment">/* XXX: put a timer on the cache for expirary purposes */</span>
<a name="l00188" id="l00188"></a>00188 <span class="keyword">static</span> <a class="code" href=
"structbio__cache__s.html">bio_cache</a> *find_bio_cache(<span class="keyword">struct</span> sockaddr_in *from_addr) {
<a name="l00189" id="l00189"></a>00189     <a class="code" href="structbio__cache__s.html">bio_cache</a> *cachep = NULL;
<a name="l00190" id="l00190"></a>00190     cachep = biocache;
<a name="l00191" id="l00191"></a>00191     <span class="keywordflow">while</span>(cachep) {
<a name="l00192" id="l00192"></a>00192 
<a name="l00193" id="l00193"></a>00193         <span class=
"keywordflow">if</span> (cachep-&gt;ipv4addr == from_addr-&gt;sin_addr.s_addr &amp;&amp;
<a name="l00194" id="l00194"></a>00194             cachep-&gt;portnum == from_addr-&gt;sin_port) {
<a name="l00195" id="l00195"></a>00195             <span class="comment">/* found an existing connection */</span>
<a name="l00196" id="l00196"></a>00196             <span class="keywordflow">break</span>;
<a name="l00197" id="l00197"></a>00197         }
<a name="l00198" id="l00198"></a>00198             
<a name="l00199" id="l00199"></a>00199         cachep = cachep-&gt;next;
<a name="l00200" id="l00200"></a>00200     }
<a name="l00201" id="l00201"></a>00201     <span class="keywordflow">return</span> cachep;
<a name="l00202" id="l00202"></a>00202 }
<a name="l00203" id="l00203"></a>00203 
<a name="l00204" id="l00204"></a>00204 <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> * _x509_get_error(<span class="keywordtype">int</span> x509failvalue, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *location) {
<a name="l00205" id="l00205"></a>00205     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *reason = NULL;
<a name="l00206" id="l00206"></a>00206     
<a name="l00207" id="l00207"></a>00207     <span class=
"comment">/* XXX: use this instead: X509_verify_cert_error_string(err) */</span>
<a name="l00208" id="l00208"></a>00208 
<a name="l00209" id="l00209"></a>00209     <span class="keywordflow">switch</span> (x509failvalue) {
<a name="l00210" id="l00210"></a>00210     <span class="keywordflow">case</span> X509_V_OK:
<a name="l00211" id="l00211"></a>00211         reason = <span class="stringliteral">"X509_V_OK"</span>;
<a name="l00212" id="l00212"></a>00212         <span class="keywordflow">break</span>;
<a name="l00213" id="l00213"></a>00213     <span class="keywordflow">case</span> X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
<a name="l00214" id="l00214"></a>00214         reason = <span class=
"stringliteral">"X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT"</span>;
<a name="l00215" id="l00215"></a>00215         <span class="keywordflow">break</span>;
<a name="l00216" id="l00216"></a>00216     <span class="keywordflow">case</span> X509_V_ERR_UNABLE_TO_GET_CRL:
<a name="l00217" id="l00217"></a>00217         reason = <span class="stringliteral">"X509_V_ERR_UNABLE_TO_GET_CRL"</span>;
<a name="l00218" id="l00218"></a>00218         <span class="keywordflow">break</span>;
<a name="l00219" id="l00219"></a>00219     <span class="keywordflow">case</span> X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE:
<a name="l00220" id="l00220"></a>00220         reason = <span class=
"stringliteral">"X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE"</span>;
<a name="l00221" id="l00221"></a>00221         <span class="keywordflow">break</span>;
<a name="l00222" id="l00222"></a>00222     <span class="keywordflow">case</span> X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE:
<a name="l00223" id="l00223"></a>00223         reason = <span class=
"stringliteral">"X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE"</span>;
<a name="l00224" id="l00224"></a>00224         <span class="keywordflow">break</span>;
<a name="l00225" id="l00225"></a>00225     <span class="keywordflow">case</span> X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY:
<a name="l00226" id="l00226"></a>00226         reason = <span class=
"stringliteral">"X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY"</span>;
<a name="l00227" id="l00227"></a>00227         <span class="keywordflow">break</span>;
<a name="l00228" id="l00228"></a>00228     <span class="keywordflow">case</span> X509_V_ERR_CERT_SIGNATURE_FAILURE:
<a name="l00229" id="l00229"></a>00229         reason = <span class="stringliteral">"X509_V_ERR_CERT_SIGNATURE_FAILURE"</span>;
<a name="l00230" id="l00230"></a>00230         <span class="keywordflow">break</span>;
<a name="l00231" id="l00231"></a>00231     <span class="keywordflow">case</span> X509_V_ERR_CRL_SIGNATURE_FAILURE:
<a name="l00232" id="l00232"></a>00232         reason = <span class="stringliteral">"X509_V_ERR_CRL_SIGNATURE_FAILURE"</span>;
<a name="l00233" id="l00233"></a>00233         <span class="keywordflow">break</span>;
<a name="l00234" id="l00234"></a>00234     <span class="keywordflow">case</span> X509_V_ERR_CERT_NOT_YET_VALID:
<a name="l00235" id="l00235"></a>00235         reason = <span class="stringliteral">"X509_V_ERR_CERT_NOT_YET_VALID"</span>;
<a name="l00236" id="l00236"></a>00236         <span class="keywordflow">break</span>;
<a name="l00237" id="l00237"></a>00237     <span class="keywordflow">case</span> X509_V_ERR_CERT_HAS_EXPIRED:
<a name="l00238" id="l00238"></a>00238         reason = <span class="stringliteral">"X509_V_ERR_CERT_HAS_EXPIRED"</span>;
<a name="l00239" id="l00239"></a>00239         <span class="keywordflow">break</span>;
<a name="l00240" id="l00240"></a>00240     <span class="keywordflow">case</span> X509_V_ERR_CRL_NOT_YET_VALID:
<a name="l00241" id="l00241"></a>00241         reason = <span class="stringliteral">"X509_V_ERR_CRL_NOT_YET_VALID"</span>;
<a name="l00242" id="l00242"></a>00242         <span class="keywordflow">break</span>;
<a name="l00243" id="l00243"></a>00243     <span class="keywordflow">case</span> X509_V_ERR_CRL_HAS_EXPIRED:
<a name="l00244" id="l00244"></a>00244         reason = <span class="stringliteral">"X509_V_ERR_CRL_HAS_EXPIRED"</span>;
<a name="l00245" id="l00245"></a>00245         <span class="keywordflow">break</span>;
<a name="l00246" id="l00246"></a>00246     <span class="keywordflow">case</span> X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:
<a name="l00247" id="l00247"></a>00247         reason = <span class=
"stringliteral">"X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD"</span>;
<a name="l00248" id="l00248"></a>00248         <span class="keywordflow">break</span>;
<a name="l00249" id="l00249"></a>00249     <span class="keywordflow">case</span> X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:
<a name="l00250" id="l00250"></a>00250         reason = <span class=
"stringliteral">"X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD"</span>;
<a name="l00251" id="l00251"></a>00251         <span class="keywordflow">break</span>;
<a name="l00252" id="l00252"></a>00252     <span class="keywordflow">case</span> X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD:
<a name="l00253" id="l00253"></a>00253         reason = <span class=
"stringliteral">"X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD"</span>;
<a name="l00254" id="l00254"></a>00254         <span class="keywordflow">break</span>;
<a name="l00255" id="l00255"></a>00255     <span class="keywordflow">case</span> X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD:
<a name="l00256" id="l00256"></a>00256         reason = <span class=
"stringliteral">"X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD"</span>;
<a name="l00257" id="l00257"></a>00257         <span class="keywordflow">break</span>;
<a name="l00258" id="l00258"></a>00258     <span class="keywordflow">case</span> X509_V_ERR_OUT_OF_MEM:
<a name="l00259" id="l00259"></a>00259         reason = <span class="stringliteral">"X509_V_ERR_OUT_OF_MEM"</span>;
<a name="l00260" id="l00260"></a>00260         <span class="keywordflow">break</span>;
<a name="l00261" id="l00261"></a>00261     <span class="keywordflow">case</span> X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
<a name="l00262" id="l00262"></a>00262         reason = <span class=
"stringliteral">"X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT"</span>;
<a name="l00263" id="l00263"></a>00263         <span class="keywordflow">break</span>;
<a name="l00264" id="l00264"></a>00264     <span class="keywordflow">case</span> X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:
<a name="l00265" id="l00265"></a>00265         reason = <span class=
"stringliteral">"X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN"</span>;
<a name="l00266" id="l00266"></a>00266         <span class="keywordflow">break</span>;
<a name="l00267" id="l00267"></a>00267     <span class="keywordflow">case</span> X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:
<a name="l00268" id="l00268"></a>00268         reason = <span class=
"stringliteral">"X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY"</span>;
<a name="l00269" id="l00269"></a>00269         <span class="keywordflow">break</span>;
<a name="l00270" id="l00270"></a>00270     <span class="keywordflow">case</span> X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:
<a name="l00271" id="l00271"></a>00271         reason = <span class=
"stringliteral">"X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE"</span>;
<a name="l00272" id="l00272"></a>00272         <span class="keywordflow">break</span>;
<a name="l00273" id="l00273"></a>00273     <span class="keywordflow">case</span> X509_V_ERR_CERT_CHAIN_TOO_LONG:
<a name="l00274" id="l00274"></a>00274         reason = <span class="stringliteral">"X509_V_ERR_CERT_CHAIN_TOO_LONG"</span>;
<a name="l00275" id="l00275"></a>00275         <span class="keywordflow">break</span>;
<a name="l00276" id="l00276"></a>00276     <span class="keywordflow">case</span> X509_V_ERR_CERT_REVOKED:
<a name="l00277" id="l00277"></a>00277         reason = <span class="stringliteral">"X509_V_ERR_CERT_REVOKED"</span>;
<a name="l00278" id="l00278"></a>00278         <span class="keywordflow">break</span>;
<a name="l00279" id="l00279"></a>00279     <span class="keywordflow">case</span> X509_V_ERR_INVALID_CA:
<a name="l00280" id="l00280"></a>00280         reason = <span class="stringliteral">"X509_V_ERR_INVALID_CA"</span>;
<a name="l00281" id="l00281"></a>00281         <span class="keywordflow">break</span>;
<a name="l00282" id="l00282"></a>00282     <span class="keywordflow">case</span> X509_V_ERR_PATH_LENGTH_EXCEEDED:
<a name="l00283" id="l00283"></a>00283         reason = <span class="stringliteral">"X509_V_ERR_PATH_LENGTH_EXCEEDED"</span>;
<a name="l00284" id="l00284"></a>00284         <span class="keywordflow">break</span>;
<a name="l00285" id="l00285"></a>00285     <span class="keywordflow">case</span> X509_V_ERR_INVALID_PURPOSE:
<a name="l00286" id="l00286"></a>00286         reason = <span class="stringliteral">"X509_V_ERR_INVALID_PURPOSE"</span>;
<a name="l00287" id="l00287"></a>00287         <span class="keywordflow">break</span>;
<a name="l00288" id="l00288"></a>00288     <span class="keywordflow">case</span> X509_V_ERR_CERT_UNTRUSTED:
<a name="l00289" id="l00289"></a>00289         reason = <span class="stringliteral">"X509_V_ERR_CERT_UNTRUSTED"</span>;
<a name="l00290" id="l00290"></a>00290         <span class="keywordflow">break</span>;
<a name="l00291" id="l00291"></a>00291     <span class="keywordflow">case</span> X509_V_ERR_CERT_REJECTED:
<a name="l00292" id="l00292"></a>00292         reason = <span class="stringliteral">"X509_V_ERR_CERT_REJECTED"</span>;
<a name="l00293" id="l00293"></a>00293         <span class="keywordflow">break</span>;
<a name="l00294" id="l00294"></a>00294     <span class="keywordflow">case</span> X509_V_ERR_SUBJECT_ISSUER_MISMATCH:
<a name="l00295" id="l00295"></a>00295         reason = <span class="stringliteral">"X509_V_ERR_SUBJECT_ISSUER_MISMATCH"</span>;
<a name="l00296" id="l00296"></a>00296         <span class="keywordflow">break</span>;
<a name="l00297" id="l00297"></a>00297     <span class="keywordflow">case</span> X509_V_ERR_AKID_SKID_MISMATCH:
<a name="l00298" id="l00298"></a>00298         reason = <span class="stringliteral">"X509_V_ERR_AKID_SKID_MISMATCH"</span>;
<a name="l00299" id="l00299"></a>00299         <span class="keywordflow">break</span>;
<a name="l00300" id="l00300"></a>00300     <span class="keywordflow">case</span> X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH:
<a name="l00301" id="l00301"></a>00301         reason = <span class=
"stringliteral">"X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH"</span>;
<a name="l00302" id="l00302"></a>00302         <span class="keywordflow">break</span>;
<a name="l00303" id="l00303"></a>00303     <span class="keywordflow">case</span> X509_V_ERR_KEYUSAGE_NO_CERTSIGN:
<a name="l00304" id="l00304"></a>00304         reason = <span class="stringliteral">"X509_V_ERR_KEYUSAGE_NO_CERTSIGN"</span>;
<a name="l00305" id="l00305"></a>00305         <span class="keywordflow">break</span>;
<a name="l00306" id="l00306"></a>00306     <span class="keywordflow">case</span> X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER:
<a name="l00307" id="l00307"></a>00307         reason = <span class="stringliteral">"X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER"</span>;
<a name="l00308" id="l00308"></a>00308         <span class="keywordflow">break</span>;
<a name="l00309" id="l00309"></a>00309     <span class="keywordflow">case</span> X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION:
<a name="l00310" id="l00310"></a>00310         reason = <span class=
"stringliteral">"X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION"</span>;
<a name="l00311" id="l00311"></a>00311         <span class="keywordflow">break</span>;
<a name="l00312" id="l00312"></a>00312     <span class="keywordflow">case</span> X509_V_ERR_KEYUSAGE_NO_CRL_SIGN:
<a name="l00313" id="l00313"></a>00313         reason = <span class="stringliteral">"X509_V_ERR_KEYUSAGE_NO_CRL_SIGN"</span>;
<a name="l00314" id="l00314"></a>00314         <span class="keywordflow">break</span>;
<a name="l00315" id="l00315"></a>00315     <span class="keywordflow">case</span> X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION:
<a name="l00316" id="l00316"></a>00316         reason = <span class=
"stringliteral">"X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION"</span>;
<a name="l00317" id="l00317"></a>00317         <span class="keywordflow">break</span>;
<a name="l00318" id="l00318"></a>00318     <span class="keywordflow">case</span> X509_V_ERR_INVALID_NON_CA:
<a name="l00319" id="l00319"></a>00319         reason = <span class="stringliteral">"X509_V_ERR_INVALID_NON_CA"</span>;
<a name="l00320" id="l00320"></a>00320         <span class="keywordflow">break</span>;
<a name="l00321" id="l00321"></a>00321     <span class="keywordflow">case</span> X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED:
<a name="l00322" id="l00322"></a>00322         reason = <span class=
"stringliteral">"X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED"</span>;
<a name="l00323" id="l00323"></a>00323         <span class="keywordflow">break</span>;
<a name="l00324" id="l00324"></a>00324     <span class="keywordflow">case</span> X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE:
<a name="l00325" id="l00325"></a>00325         reason = <span class=
"stringliteral">"X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE"</span>;
<a name="l00326" id="l00326"></a>00326         <span class="keywordflow">break</span>;
<a name="l00327" id="l00327"></a>00327     <span class="keywordflow">case</span> X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED:
<a name="l00328" id="l00328"></a>00328         reason = <span class=
"stringliteral">"X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED"</span>;
<a name="l00329" id="l00329"></a>00329         <span class="keywordflow">break</span>;
<a name="l00330" id="l00330"></a>00330     <span class="keywordflow">case</span> X509_V_ERR_INVALID_EXTENSION:
<a name="l00331" id="l00331"></a>00331         reason = <span class="stringliteral">"X509_V_ERR_INVALID_EXTENSION"</span>;
<a name="l00332" id="l00332"></a>00332         <span class="keywordflow">break</span>;
<a name="l00333" id="l00333"></a>00333     <span class="keywordflow">case</span> X509_V_ERR_INVALID_POLICY_EXTENSION:
<a name="l00334" id="l00334"></a>00334         reason = <span class="stringliteral">"X509_V_ERR_INVALID_POLICY_EXTENSION"</span>;
<a name="l00335" id="l00335"></a>00335         <span class="keywordflow">break</span>;
<a name="l00336" id="l00336"></a>00336     <span class="keywordflow">case</span> X509_V_ERR_NO_EXPLICIT_POLICY:
<a name="l00337" id="l00337"></a>00337         reason = <span class="stringliteral">"X509_V_ERR_NO_EXPLICIT_POLICY"</span>;
<a name="l00338" id="l00338"></a>00338         <span class="keywordflow">break</span>;
<a name="l00339" id="l00339"></a>00339     <span class="keywordflow">case</span> X509_V_ERR_UNNESTED_RESOURCE:
<a name="l00340" id="l00340"></a>00340         reason = <span class="stringliteral">"X509_V_ERR_UNNESTED_RESOURCE"</span>;
<a name="l00341" id="l00341"></a>00341         <span class="keywordflow">break</span>;
<a name="l00342" id="l00342"></a>00342     <span class="keywordflow">case</span> X509_V_ERR_APPLICATION_VERIFICATION:
<a name="l00343" id="l00343"></a>00343         reason = <span class="stringliteral">"X509_V_ERR_APPLICATION_VERIFICATION"</span>;
<a name="l00344" id="l00344"></a>00344     <span class="keywordflow">default</span>:
<a name="l00345" id="l00345"></a>00345         reason = <span class="stringliteral">"unknown failure code"</span>;
<a name="l00346" id="l00346"></a>00346     }
<a name="l00347" id="l00347"></a>00347 
<a name="l00348" id="l00348"></a>00348     <span class="keywordflow">return</span> reason;
<a name="l00349" id="l00349"></a>00349 }
<a name="l00350" id="l00350"></a>00350 
<a name="l00351" id="l00351"></a>00351 <span class="keywordtype">int</span> verify_callback(<span class=
"keywordtype">int</span> ok, X509_STORE_CTX *ctx) {
<a name="l00352" id="l00352"></a>00352     <span class="keywordtype">int</span> err, depth;
<a name="l00353" id="l00353"></a>00353     <span class="keywordtype">char</span> buf[1024];
<a name="l00354" id="l00354"></a>00354     X509 *thecert;
<a name="l00355" id="l00355"></a>00355 
<a name="l00356" id="l00356"></a>00356     thecert = X509_STORE_CTX_get_current_cert(ctx);
<a name="l00357" id="l00357"></a>00357     err = X509_STORE_CTX_get_error(ctx);
<a name="l00358" id="l00358"></a>00358     depth = X509_STORE_CTX_get_error_depth(ctx);
<a name="l00359" id="l00359"></a>00359     
<a name="l00360" id="l00360"></a>00360     <span class="comment">/* things to do: */</span>
<a name="l00361" id="l00361"></a>00361 
<a name="l00362" id="l00362"></a>00362     X509_NAME_oneline(X509_get_subject_name(thecert), buf, <span class=
"keyword">sizeof</span>(buf));
<a name="l00363" id="l00363"></a>00363     DEBUGMSGTL((<span class="stringliteral">"dtlsudp_x509"</span>,
<a name="l00364" id="l00364"></a>00364                 <span class="stringliteral">"Cert: %s\n"</span>, buf));
<a name="l00365" id="l00365"></a>00365 
<a name="l00366" id="l00366"></a>00366 
<a name="l00367" id="l00367"></a>00367     DEBUGMSGTL((<span class="stringliteral">"dtlsudp_x509"</span>,
<a name="l00368" id="l00368"></a>00368                 <span class=
"stringliteral">" verify value: %d, depth=%d, error code=%d, error string=%s\n"</span>,
<a name="l00369" id="l00369"></a>00369                 ok, depth, err, _x509_get_error(err, <span class=
"stringliteral">"verify callback"</span>)));
<a name="l00370" id="l00370"></a>00370 
<a name="l00371" id="l00371"></a>00371     <span class="comment">/* check if we allow self-signed certs */</span>
<a name="l00372" id="l00372"></a>00372     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
<a name="l00373" id="l00373"></a>00373                                NETSNMP_DS_LIB_ALLOW_SELF_SIGNED) &amp;&amp;
<a name="l00374" id="l00374"></a>00374         (X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT == err ||
<a name="l00375" id="l00375"></a>00375          X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN == err)) {
<a name="l00376" id="l00376"></a>00376         DEBUGMSGTL((<span class="stringliteral">"dtlsudp_x509"</span>, <span class=
"stringliteral">"  accepting a self-signed certificate\n"</span>));
<a name="l00377" id="l00377"></a>00377         <span class="keywordflow">return</span> 1;
<a name="l00378" id="l00378"></a>00378     }
<a name="l00379" id="l00379"></a>00379     
<a name="l00380" id="l00380"></a>00380     
<a name="l00381" id="l00381"></a>00381     DEBUGMSGTL((<span class="stringliteral">"dtlsudp_x509"</span>, <span class=
"stringliteral">"  returing the passed in value of %d\n"</span>, ok));
<a name="l00382" id="l00382"></a>00382     <span class="keywordflow">return</span>(ok);
<a name="l00383" id="l00383"></a>00383 }
<a name="l00384" id="l00384"></a>00384 
<a name="l00385" id="l00385"></a>00385 <span class="keyword">static</span> <span class=
"keywordtype">void</span> _openssl_log_error(<span class="keywordtype">int</span> rc, SSL *con, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *location) {
<a name="l00386" id="l00386"></a>00386     <span class="keyword">const</span> <span class="keywordtype">char</span> *reason;
<a name="l00387" id="l00387"></a>00387 
<a name="l00388" id="l00388"></a>00388     <span class="keywordflow">if</span> (rc == -1) {
<a name="l00389" id="l00389"></a>00389         <span class="keywordtype">int</span> sslnum = SSL_get_error(con, rc);
<a name="l00390" id="l00390"></a>00390 
<a name="l00391" id="l00391"></a>00391         <span class="keywordflow">switch</span>(sslnum) {
<a name="l00392" id="l00392"></a>00392         <span class="keywordflow">case</span> SSL_ERROR_NONE:
<a name="l00393" id="l00393"></a>00393             reason = <span class="stringliteral">"SSL_ERROR_NONE"</span>;
<a name="l00394" id="l00394"></a>00394             <span class="keywordflow">break</span>;
<a name="l00395" id="l00395"></a>00395 
<a name="l00396" id="l00396"></a>00396         <span class="keywordflow">case</span> SSL_ERROR_SSL:
<a name="l00397" id="l00397"></a>00397             reason = <span class="stringliteral">"SSL_ERROR_SSL"</span>;
<a name="l00398" id="l00398"></a>00398             <span class="keywordflow">break</span>;
<a name="l00399" id="l00399"></a>00399 
<a name="l00400" id="l00400"></a>00400         <span class="keywordflow">case</span> SSL_ERROR_WANT_READ:
<a name="l00401" id="l00401"></a>00401             reason = <span class="stringliteral">"SSL_ERROR_WANT_READ"</span>;
<a name="l00402" id="l00402"></a>00402             <span class="keywordflow">break</span>;
<a name="l00403" id="l00403"></a>00403 
<a name="l00404" id="l00404"></a>00404         <span class="keywordflow">case</span> SSL_ERROR_WANT_WRITE:
<a name="l00405" id="l00405"></a>00405             reason = <span class="stringliteral">"SSL_ERROR_WANT_WRITE"</span>;
<a name="l00406" id="l00406"></a>00406             <span class="keywordflow">break</span>;
<a name="l00407" id="l00407"></a>00407 
<a name="l00408" id="l00408"></a>00408         <span class="keywordflow">case</span> SSL_ERROR_WANT_X509_LOOKUP:
<a name="l00409" id="l00409"></a>00409             reason = <span class="stringliteral">"SSL_ERROR_WANT_X509_LOOKUP"</span>;
<a name="l00410" id="l00410"></a>00410             <span class="keywordflow">break</span>;
<a name="l00411" id="l00411"></a>00411 
<a name="l00412" id="l00412"></a>00412         <span class="keywordflow">case</span> SSL_ERROR_SYSCALL:
<a name="l00413" id="l00413"></a>00413             reason = <span class="stringliteral">"SSL_ERROR_SYSCALL"</span>;
<a name="l00414" id="l00414"></a>00414             <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"DTLS error: %s: rc=%d, sslerror = %d (%s): system_error=%d (%s)\n"</span>,
<a name="l00415" id="l00415"></a>00415                      location, rc, sslnum, reason, errno, strerror(errno));
<a name="l00416" id="l00416"></a>00416             <span class="keywordflow">return</span>;
<a name="l00417" id="l00417"></a>00417 
<a name="l00418" id="l00418"></a>00418         <span class="keywordflow">case</span> SSL_ERROR_ZERO_RETURN:
<a name="l00419" id="l00419"></a>00419             reason = <span class="stringliteral">"SSL_ERROR_ZERO_RETURN"</span>;
<a name="l00420" id="l00420"></a>00420             <span class="keywordflow">break</span>;
<a name="l00421" id="l00421"></a>00421 
<a name="l00422" id="l00422"></a>00422         <span class="keywordflow">case</span> SSL_ERROR_WANT_CONNECT:
<a name="l00423" id="l00423"></a>00423             reason = <span class="stringliteral">"SSL_ERROR_WANT_CONNECT"</span>;
<a name="l00424" id="l00424"></a>00424             <span class="keywordflow">break</span>;
<a name="l00425" id="l00425"></a>00425 
<a name="l00426" id="l00426"></a>00426         <span class="keywordflow">case</span> SSL_ERROR_WANT_ACCEPT:
<a name="l00427" id="l00427"></a>00427             reason = <span class="stringliteral">"SSL_ERROR_WANT_ACCEPT"</span>;
<a name="l00428" id="l00428"></a>00428             <span class="keywordflow">break</span>;
<a name="l00429" id="l00429"></a>00429             
<a name="l00430" id="l00430"></a>00430         <span class="keywordflow">default</span>:
<a name="l00431" id="l00431"></a>00431             reason = <span class="stringliteral">"unknown"</span>;
<a name="l00432" id="l00432"></a>00432         }
<a name="l00433" id="l00433"></a>00433 
<a name="l00434" id="l00434"></a>00434         <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"DTLS error: %s: rc=%d, sslerror = %d (%s)\n"</span>,
<a name="l00435" id="l00435"></a>00435                  location, rc, sslnum, reason);
<a name="l00436" id="l00436"></a>00436     }
<a name="l00437" id="l00437"></a>00437 }
<a name="l00438" id="l00438"></a>00438 
<a name="l00439" id="l00439"></a>00439 <span class="comment">/* XXX: lots of malloc/state cleanup needed */</span>
<a name="l00440" id="l00440"></a>00440 <span class=
"preprocessor">#define DIEHERE(msg) { snmp_log(LOG_ERR, "%s\n", msg); return NULL; }</span>
<a name="l00441" id="l00441"></a>00441 
<a name="l00442" id="l00442"></a>00442 <span class="keyword">static</span> <a class="code" href=
"structbio__cache__s.html">bio_cache</a> *
<a name="l00443" id="l00443"></a>00443 start_new_cached_connection(<span class="keywordtype">int</span> sock, <span class=
"keyword">struct</span> sockaddr_in *remote_addr,
<a name="l00444" id="l00444"></a>00444                             <span class="keywordtype">int</span> we_are_client) {
<a name="l00445" id="l00445"></a>00445     <a class="code" href="structbio__cache__s.html">bio_cache</a> *cachep = NULL;
<a name="l00446" id="l00446"></a>00446 
<a name="l00447" id="l00447"></a>00447     <span class="keywordflow">if</span> (!sock)
<a name="l00448" id="l00448"></a>00448         DIEHERE(<span class=
"stringliteral">"no socket passed in to start_new_cached_connection\n"</span>);
<a name="l00449" id="l00449"></a>00449     <span class="keywordflow">if</span> (!remote_addr)
<a name="l00450" id="l00450"></a>00450         DIEHERE(<span class=
"stringliteral">"no remote_addr passed in to start_new_cached_connection\n"</span>);
<a name="l00451" id="l00451"></a>00451         
<a name="l00452" id="l00452"></a>00452     cachep = <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424"
title="Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href=
"structbio__cache__s.html">bio_cache</a>);
<a name="l00453" id="l00453"></a>00453     <span class="keywordflow">if</span> (!cachep)
<a name="l00454" id="l00454"></a>00454         <span class="keywordflow">return</span> NULL;
<a name="l00455" id="l00455"></a>00455     
<a name="l00456" id="l00456"></a>00456     DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"starting a new connection\n"</span>));
<a name="l00457" id="l00457"></a>00457     cachep-&gt;next = biocache;
<a name="l00458" id="l00458"></a>00458     biocache = cachep;
<a name="l00459" id="l00459"></a>00459 
<a name="l00460" id="l00460"></a>00460     cachep-&gt;ipv4addr = remote_addr-&gt;sin_addr.s_addr;
<a name="l00461" id="l00461"></a>00461     cachep-&gt;portnum = remote_addr-&gt;sin_port;
<a name="l00462" id="l00462"></a>00462     cachep-&gt;sock = sock;
<a name="l00463" id="l00463"></a>00463     memcpy(&amp;cachep-&gt;sockaddr, remote_addr, <span class=
"keyword">sizeof</span>(*remote_addr));
<a name="l00464" id="l00464"></a>00464 
<a name="l00465" id="l00465"></a>00465     <span class="keywordflow">if</span> (we_are_client) {
<a name="l00466" id="l00466"></a>00466         DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"starting a new connection as a client to sock: %d\n"</span>, sock));
<a name="l00467" id="l00467"></a>00467         cachep-&gt;con = SSL_new(client_ctx);
<a name="l00468" id="l00468"></a>00468 
<a name="l00469" id="l00469"></a>00469         <span class="comment">/* XXX: session setting 735 */</span>
<a name="l00470" id="l00470"></a>00470 
<a name="l00471" id="l00471"></a>00471         <span class="comment">/* create a bio */</span>
<a name="l00472" id="l00472"></a>00472 
<a name="l00473" id="l00473"></a>00473         cachep-&gt;bio = BIO_new(BIO_s_mem()); <span class=
"comment">/* The one openssl reads from */</span>
<a name="l00474" id="l00474"></a>00474         cachep-&gt;write_bio = BIO_new(BIO_s_mem()); <span class=
"comment">/* openssl writes to */</span>
<a name="l00475" id="l00475"></a>00475 
<a name="l00476" id="l00476"></a>00476         BIO_set_mem_eof_return(cachep-&gt;bio, -1);
<a name="l00477" id="l00477"></a>00477         BIO_set_mem_eof_return(cachep-&gt;write_bio, -1);
<a name="l00478" id="l00478"></a>00478 
<a name="l00479" id="l00479"></a>00479         SSL_set_bio(cachep-&gt;con, cachep-&gt;bio, cachep-&gt;write_bio);
<a name="l00480" id="l00480"></a>00480         SSL_set_connect_state(cachep-&gt;con);
<a name="l00481" id="l00481"></a>00481         
<a name="l00482" id="l00482"></a>00482     } <span class="keywordflow">else</span> {
<a name="l00483" id="l00483"></a>00483         <span class="comment">/* we're the server */</span>
<a name="l00484" id="l00484"></a>00484 
<a name="l00485" id="l00485"></a>00485         cachep-&gt;bio = BIO_new(BIO_s_mem()); <span class=
"comment">/* The one openssl reads from */</span>
<a name="l00486" id="l00486"></a>00486 
<a name="l00487" id="l00487"></a>00487         <span class="keywordflow">if</span> (!cachep-&gt;bio)
<a name="l00488" id="l00488"></a>00488             DIEHERE(<span class="stringliteral">"failed to create the read bio"</span>);
<a name="l00489" id="l00489"></a>00489 
<a name="l00490" id="l00490"></a>00490         cachep-&gt;write_bio = BIO_new(BIO_s_mem()); <span class=
"comment">/* openssl writes to */</span>
<a name="l00491" id="l00491"></a>00491 
<a name="l00492" id="l00492"></a>00492         <span class="keywordflow">if</span> (!cachep-&gt;write_bio) {
<a name="l00493" id="l00493"></a>00493             DIEHERE(<span class="stringliteral">"failed to create the write bio"</span>);
<a name="l00494" id="l00494"></a>00494             BIO_free(cachep-&gt;bio);
<a name="l00495" id="l00495"></a>00495         }
<a name="l00496" id="l00496"></a>00496 
<a name="l00497" id="l00497"></a>00497         BIO_set_mem_eof_return(cachep-&gt;bio, -1);
<a name="l00498" id="l00498"></a>00498         BIO_set_mem_eof_return(cachep-&gt;write_bio, -1);
<a name="l00499" id="l00499"></a>00499 
<a name="l00500" id="l00500"></a>00500         cachep-&gt;con = SSL_new(server_ctx);
<a name="l00501" id="l00501"></a>00501 
<a name="l00502" id="l00502"></a>00502         <span class="keywordflow">if</span> (!cachep-&gt;con) {
<a name="l00503" id="l00503"></a>00503             BIO_free(cachep-&gt;bio);
<a name="l00504" id="l00504"></a>00504             BIO_free(cachep-&gt;write_bio);
<a name="l00505" id="l00505"></a>00505             DIEHERE(<span class="stringliteral">"failed to create the write bio"</span>);
<a name="l00506" id="l00506"></a>00506         }
<a name="l00507" id="l00507"></a>00507         
<a name="l00508" id="l00508"></a>00508         <span class="comment">/* turn on cookie exchange */</span>
<a name="l00509" id="l00509"></a>00509         <span class=
"comment">/* XXX: we need to only create cache entries when cookies succeed */</span>
<a name="l00510" id="l00510"></a>00510         SSL_set_options(cachep-&gt;con, SSL_OP_COOKIE_EXCHANGE);
<a name="l00511" id="l00511"></a>00511 
<a name="l00512" id="l00512"></a>00512         <span class=
"comment">/* set the bios that openssl should read from and write to */</span>
<a name="l00513" id="l00513"></a>00513         <span class="comment">/* (and we'll do the opposite) */</span>
<a name="l00514" id="l00514"></a>00514         SSL_set_bio(cachep-&gt;con, cachep-&gt;bio, cachep-&gt;write_bio);
<a name="l00515" id="l00515"></a>00515         SSL_set_accept_state(cachep-&gt;con);
<a name="l00516" id="l00516"></a>00516 
<a name="l00517" id="l00517"></a>00517     }
<a name="l00518" id="l00518"></a>00518 
<a name="l00519" id="l00519"></a>00519     <span class="keywordflow">return</span> cachep;
<a name="l00520" id="l00520"></a>00520 }
<a name="l00521" id="l00521"></a>00521 
<a name="l00522" id="l00522"></a>00522 <span class="keyword">static</span> <a class="code" href=
"structbio__cache__s.html">bio_cache</a> *
<a name="l00523" id="l00523"></a>00523 find_or_create_bio_cache(<span class="keywordtype">int</span> sock, <span class=
"keyword">struct</span> sockaddr_in *from_addr,
<a name="l00524" id="l00524"></a>00524                          <span class="keywordtype">int</span> we_are_client) {
<a name="l00525" id="l00525"></a>00525     <a class="code" href=
"structbio__cache__s.html">bio_cache</a> *cachep = find_bio_cache(from_addr);
<a name="l00526" id="l00526"></a>00526     <span class="keywordflow">if</span> (NULL == cachep) {
<a name="l00527" id="l00527"></a>00527         <span class="comment">/* none found; need to start a new context */</span>
<a name="l00528" id="l00528"></a>00528         cachep = start_new_cached_connection(sock, from_addr, we_are_client);
<a name="l00529" id="l00529"></a>00529         <span class="keywordflow">if</span> (NULL == cachep) {
<a name="l00530" id="l00530"></a>00530             <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"failed to open a new dtls connection\n"</span>);
<a name="l00531" id="l00531"></a>00531         }
<a name="l00532" id="l00532"></a>00532     }
<a name="l00533" id="l00533"></a>00533     <span class="keywordflow">return</span> cachep;
<a name="l00534" id="l00534"></a>00534 }       
<a name="l00535" id="l00535"></a>00535 
<a name="l00536" id="l00536"></a>00536 <span class="comment">/*</span>
<a name="l00537" id="l00537"></a>00537 <span class=
"comment"> * You can write something into opaque that will subsequently get passed back </span>
<a name="l00538" id="l00538"></a>00538 <span class=
"comment"> * to your send function if you like.  For instance, you might want to</span>
<a name="l00539" id="l00539"></a>00539 <span class=
"comment"> * remember where a PDU came from, so that you can send a reply there...  </span>
<a name="l00540" id="l00540"></a>00540 <span class="comment"> */</span>
<a name="l00541" id="l00541"></a>00541 
<a name="l00542" id="l00542"></a>00542 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00543" id="l00543"></a>00543 netsnmp_dtlsudp_recv(<a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a> *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
<a name="l00544" id="l00544"></a>00544                  <span class="keywordtype">void</span> **opaque, <span class=
"keywordtype">int</span> *olength)
<a name="l00545" id="l00545"></a>00545 {
<a name="l00546" id="l00546"></a>00546     <span class="keywordtype">int</span>             rc = -1;
<a name="l00547" id="l00547"></a>00547     socklen_t       fromlen = <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr);
<a name="l00548" id="l00548"></a>00548     <a class="code" href=
"structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a> *addr_pair = NULL;
<a name="l00549" id="l00549"></a>00549     <span class="keyword">struct </span>sockaddr *from;
<a name="l00550" id="l00550"></a>00550     <a class="code" href=
"structnetsnmp__tmStateReference__s.html">netsnmp_tmStateReference</a> *tmStateRef = NULL;
<a name="l00551" id="l00551"></a>00551     X509            *peer;
<a name="l00552" id="l00552"></a>00552 
<a name="l00553" id="l00553"></a>00553     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
<a name="l00554" id="l00554"></a>00554         <span class="comment">/* create a tmStateRef cache for slow fill-in */</span>
<a name="l00555" id="l00555"></a>00555         tmStateRef = <a class="code" href=
"group__util.html#ga9cd013bb193de5048149afeb9d94e424" title=
"Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href=
"structnetsnmp__tmStateReference__s.html">netsnmp_tmStateReference</a>);
<a name="l00556" id="l00556"></a>00556 
<a name="l00557" id="l00557"></a>00557         <span class="keywordflow">if</span> (tmStateRef == NULL) {
<a name="l00558" id="l00558"></a>00558             *opaque = NULL;
<a name="l00559" id="l00559"></a>00559             *olength = 0;
<a name="l00560" id="l00560"></a>00560             <span class="keywordflow">return</span> -1;
<a name="l00561" id="l00561"></a>00561         }
<a name="l00562" id="l00562"></a>00562 
<a name="l00563" id="l00563"></a>00563         addr_pair = &amp;tmStateRef-&gt;addresses;
<a name="l00564" id="l00564"></a>00564         tmStateRef-&gt;have_addresses = 1;
<a name="l00565" id="l00565"></a>00565         from = (<span class=
"keyword">struct </span>sockaddr *) &amp;(addr_pair-&gt;remote_addr);
<a name="l00566" id="l00566"></a>00566 
<a name="l00567" id="l00567"></a>00567         <span class="keywordflow">while</span> (rc &lt; 0) {
<a name="l00568" id="l00568"></a>00568 <span class="preprocessor">#if defined(linux) &amp;&amp; defined(IP_PKTINFO)</span>
<a name="l00569" id=
"l00569"></a>00569             rc = netsnmp_udp_recvfrom(t-&gt;sock, buf, size, from, &amp;fromlen, &amp;(addr_pair-&gt;local_addr));
<a name="l00570" id="l00570"></a>00570 <span class="preprocessor">#else</span>
<a name="l00571" id="l00571"></a>00571             rc = recvfrom(t-&gt;sock, buf, size, NETSNMP_DONTWAIT, from, &amp;fromlen);
<a name="l00572" id="l00572"></a>00572 <span class="preprocessor">#endif </span><span class=
"comment">/* linux &amp;&amp; IP_PKTINFO */</span>
<a name="l00573" id="l00573"></a>00573             <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
<a name="l00574" id="l00574"></a>00574                 <span class="keywordflow">break</span>;
<a name="l00575" id="l00575"></a>00575             }
<a name="l00576" id="l00576"></a>00576         }
<a name="l00577" id="l00577"></a>00577 
<a name="l00578" id="l00578"></a>00578         DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"received %d raw bytes on way to dtls\n"</span>, rc));
<a name="l00579" id="l00579"></a>00579         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l00580" id="l00580"></a>00580             DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"recvfrom fd %d err %d (\"%s\")\n"</span>,
<a name="l00581" id="l00581"></a>00581                         t-&gt;sock, errno, strerror(errno)));
<a name="l00582" id="l00582"></a>00582             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6"
title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(tmStateRef);
<a name="l00583" id="l00583"></a>00583             <span class="keywordflow">return</span> -1;
<a name="l00584" id="l00584"></a>00584         }
<a name="l00585" id="l00585"></a>00585 
<a name="l00586" id="l00586"></a>00586         <span class="keywordflow">if</span> (rc &gt;= 0) {
<a name="l00587" id="l00587"></a>00587             <span class=
"comment">/* now that we have the from address filled in, we can look up</span>
<a name="l00588" id="l00588"></a>00588 <span class=
"comment">               the openssl context and have openssl read and process</span>
<a name="l00589" id="l00589"></a>00589 <span class="comment">               appropriately */</span>
<a name="l00590" id="l00590"></a>00590 
<a name="l00591" id="l00591"></a>00591             <span class=
"comment">/* if we don't have a cachep for this connection then</span>
<a name="l00592" id="l00592"></a>00592 <span class=
"comment">               we're receiving something new and are the server</span>
<a name="l00593" id="l00593"></a>00593 <span class="comment">               side */</span>
<a name="l00594" id="l00594"></a>00594             <span class=
"comment">/* XXX: allow for a SNMP client to never accept new conns? */</span>
<a name="l00595" id="l00595"></a>00595             <a class="code" href="structbio__cache__s.html">bio_cache</a> *cachep =
<a name="l00596" id="l00596"></a>00596                 find_or_create_bio_cache(t-&gt;sock, &amp;addr_pair-&gt;remote_addr,
<a name="l00597" id="l00597"></a>00597                                          WE_ARE_SERVER);
<a name="l00598" id="l00598"></a>00598             <span class="keywordflow">if</span> (NULL == cachep) {
<a name="l00599" id="l00599"></a>00599                 <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6"
title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(tmStateRef);
<a name="l00600" id="l00600"></a>00600                 <span class="keywordflow">return</span> -1;
<a name="l00601" id="l00601"></a>00601             }
<a name="l00602" id="l00602"></a>00602 
<a name="l00603" id="l00603"></a>00603             <span class=
"comment">/* write the received buffer to the memory-based input bio */</span>
<a name="l00604" id="l00604"></a>00604             BIO_write(cachep-&gt;bio, buf, rc);
<a name="l00605" id="l00605"></a>00605 
<a name="l00606" id="l00606"></a>00606             <span class=
"comment">/* XXX: in Wes' other example we do a SSL_pending() call</span>
<a name="l00607" id="l00607"></a>00607 <span class=
"comment">               too to ensure we're ready to read...  it's possible</span>
<a name="l00608" id="l00608"></a>00608 <span class=
"comment">               that buffered stuff in openssl won't be caught by the</span>
<a name="l00609" id="l00609"></a>00609 <span class=
"comment">               net-snmp select loop because it's already been pulled</span>
<a name="l00610" id="l00610"></a>00610 <span class="comment">               out; need to deal with this) */</span>
<a name="l00611" id="l00611"></a>00611             rc = SSL_read(cachep-&gt;con, buf, size);
<a name="l00612" id="l00612"></a>00612             
<a name="l00613" id="l00613"></a>00613             DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"received %d decoded bytes from dtls\n"</span>, rc));
<a name="l00614" id="l00614"></a>00614 
<a name="l00615" id="l00615"></a>00615             <span class=
"keywordflow">if</span> (BIO_ctrl_pending(cachep-&gt;write_bio) &gt; 0) {
<a name="l00616" id="l00616"></a>00616                 <span class=
"comment">/* we have outgoing data to send; probably DTLS negotation */</span>
<a name="l00617" id="l00617"></a>00617 
<a name="l00618" id="l00618"></a>00618                 u_char outbuf[65535];
<a name="l00619" id="l00619"></a>00619                 <span class="keywordtype">int</span> outsize;
<a name="l00620" id="l00620"></a>00620                 <span class="keywordtype">int</span> rc2;
<a name="l00621" id="l00621"></a>00621                 
<a name="l00622" id="l00622"></a>00622                 <span class=
"comment">/* for memory bios, we now read from openssl's write</span>
<a name="l00623" id="l00623"></a>00623 <span class=
"comment">                   buffer (ie, the packet to go out) and send it out</span>
<a name="l00624" id="l00624"></a>00624 <span class="comment">                   the udp port manually */</span>
<a name="l00625" id="l00625"></a>00625                 outsize = BIO_read(cachep-&gt;write_bio, outbuf, <span class=
"keyword">sizeof</span>(outbuf));
<a name="l00626" id="l00626"></a>00626                 <span class="keywordflow">if</span> (outsize &gt; 0) {
<a name="l00627" id="l00627"></a>00627                     <span class="comment">/* should always be true. */</span>
<a name="l00628" id="l00628"></a>00628 <span class=
"preprocessor">#if defined(XXXFIXME) &amp;&amp; defined(linux) &amp;&amp; defined(IP_PKTINFO)</span>
<a name="l00629" id="l00629"></a>00629                 <span class=
"comment">/* XXX: before this can work, we need to remember address we</span>
<a name="l00630" id="l00630"></a>00630 <span class="comment">                   received it from (addr_pair) */</span>
<a name="l00631" id=
"l00631"></a>00631                     rc2 = netsnmp_udp_sendto(cachep-&gt;sock, addr_pair-&gt;local_addr, addr_pair-&gt;remote_addr, outbuf, outsize);
<a name="l00632" id="l00632"></a>00632 <span class="preprocessor">#else</span>
<a name="l00633" id=
"l00633"></a>00633                     rc2 = sendto(t-&gt;sock, outbuf, outsize, 0, &amp;cachep-&gt;sockaddr, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));
<a name="l00634" id="l00634"></a>00634 <span class="preprocessor">#endif </span><span class=
"comment">/* linux &amp;&amp; IP_PKTINFO */</span>
<a name="l00635" id="l00635"></a>00635 
<a name="l00636" id="l00636"></a>00636                     <span class="keywordflow">if</span> (rc2 == -1) {
<a name="l00637" id="l00637"></a>00637                         <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"failed to send a DTLS specific packet\n"</span>);
<a name="l00638" id="l00638"></a>00638                     }
<a name="l00639" id="l00639"></a>00639                 }
<a name="l00640" id="l00640"></a>00640             }
<a name="l00641" id="l00641"></a>00641 
<a name="l00642" id="l00642"></a>00642             <span class="keywordflow">if</span> (SSL_pending(cachep-&gt;con)) {
<a name="l00643" id="l00643"></a>00643                 fprintf(stderr, <span class=
"stringliteral">"ack: got here...  pending\n"</span>);
<a name="l00644" id="l00644"></a>00644                 exit(1);
<a name="l00645" id="l00645"></a>00645             }
<a name="l00646" id="l00646"></a>00646 
<a name="l00647" id="l00647"></a>00647             <span class="keywordflow">if</span> (rc == -1) {
<a name="l00648" id="l00648"></a>00648                 _openssl_log_error(rc, cachep-&gt;con, <span class=
"stringliteral">"SSL_read"</span>);
<a name="l00649" id="l00649"></a>00649                 <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6"
title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(tmStateRef);
<a name="l00650" id="l00650"></a>00650 
<a name="l00651" id="l00651"></a>00651                 <span class=
"keywordflow">if</span> (SSL_get_error(cachep-&gt;con, rc) == SSL_ERROR_WANT_READ)
<a name="l00652" id="l00652"></a>00652                     <span class="keywordflow">return</span> -1; <span class=
"comment">/* XXX: it's ok, but what's the right return? */</span>
<a name="l00653" id="l00653"></a>00653                 <span class="keywordflow">return</span> rc;
<a name="l00654" id="l00654"></a>00654             }
<a name="l00655" id="l00655"></a>00655 
<a name="l00656" id="l00656"></a>00656             {
<a name="l00657" id="l00657"></a>00657                 <span class=
"keywordtype">char</span> *str = netsnmp_udp_fmtaddr(NULL, addr_pair, <span class="keyword">sizeof</span>(<a class="code" href=
"structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a>));
<a name="l00658" id="l00658"></a>00658                 DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>,
<a name="l00659" id="l00659"></a>00659                             <span class=
"stringliteral">"recvfrom fd %d got %d bytes (from %s)\n"</span>,
<a name="l00660" id="l00660"></a>00660                             t-&gt;sock, rc, str));
<a name="l00661" id="l00661"></a>00661                 free(str);
<a name="l00662" id="l00662"></a>00662             }
<a name="l00663" id="l00663"></a>00663 
<a name="l00664" id="l00664"></a>00664             <span class=
"comment">/* XXX: disallow NULL auth/encr algs in our implementations */</span>
<a name="l00665" id="l00665"></a>00665             tmStateRef-&gt;transportSecurityLevel = SNMP_SEC_LEVEL_AUTHPRIV;
<a name="l00666" id="l00666"></a>00666 
<a name="l00667" id="l00667"></a>00667             <span class=
"comment">/* use x509 cert to do lookup to secname if DNE in cachep yet */</span>
<a name="l00668" id="l00668"></a>00668             <span class="keywordflow">if</span> (!cachep-&gt;securityName) {
<a name="l00669" id="l00669"></a>00669                 <span class=
"keywordflow">if</span> (NULL != (peer = SSL_get_peer_certificate(cachep-&gt;con))) {
<a name="l00670" id="l00670"></a>00670                     X509_NAME *subname;
<a name="l00671" id="l00671"></a>00671                     <span class="keywordtype">char</span> namebuf[1024];
<a name="l00672" id="l00672"></a>00672                 
<a name="l00673" id="l00673"></a>00673                     <span class="comment">/* we have one */</span>
<a name="l00674" id="l00674"></a>00674                     subname = X509_get_subject_name(peer);
<a name="l00675" id="l00675"></a>00675                     X509_NAME_get_text_by_NID(subname, NID_commonName,
<a name="l00676" id="l00676"></a>00676                                               namebuf, <span class=
"keyword">sizeof</span>(namebuf));
<a name="l00677" id="l00677"></a>00677                     DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"got commonname: %s\n"</span>,
<a name="l00678" id="l00678"></a>00678                                 namebuf));
<a name="l00679" id="l00679"></a>00679                     cachep-&gt;securityName = strdup(namebuf);
<a name="l00680" id="l00680"></a>00680                     DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"set SecName to: %s\n"</span>,
<a name="l00681" id="l00681"></a>00681                                 cachep-&gt;securityName));
<a name="l00682" id="l00682"></a>00682                 } <span class="keywordflow">else</span> {
<a name="l00683" id="l00683"></a>00683                     <a class="code" href=
"group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(tmStateRef);
<a name="l00684" id="l00684"></a>00684                     <span class="keywordflow">return</span> -1;
<a name="l00685" id="l00685"></a>00685                 }
<a name="l00686" id="l00686"></a>00686             }
<a name="l00687" id="l00687"></a>00687 
<a name="l00688" id="l00688"></a>00688             <span class=
"comment">/* XXX: detect and throw out overflow secname sizes rather</span>
<a name="l00689" id="l00689"></a>00689 <span class="comment">               than truncating. */</span>
<a name="l00690" id="l00690"></a>00690             strncpy(tmStateRef-&gt;securityName, cachep-&gt;securityName,
<a name="l00691" id="l00691"></a>00691                     <span class="keyword">sizeof</span>(tmStateRef-&gt;securityName)-1);
<a name="l00692" id="l00692"></a>00692             tmStateRef-&gt;securityName[<span class=
"keyword">sizeof</span>(tmStateRef-&gt;securityName)-1] = <span class="charliteral">'\0'</span>;
<a name="l00693" id="l00693"></a>00693             tmStateRef-&gt;securityNameLen = strlen(tmStateRef-&gt;securityName);
<a name="l00694" id="l00694"></a>00694 
<a name="l00695" id="l00695"></a>00695             *opaque = tmStateRef;
<a name="l00696" id="l00696"></a>00696             *olength = <span class="keyword">sizeof</span>(<a class="code" href=
"structnetsnmp__tmStateReference__s.html">netsnmp_tmStateReference</a>);
<a name="l00697" id="l00697"></a>00697 
<a name="l00698" id="l00698"></a>00698         } <span class="keywordflow">else</span> {
<a name="l00699" id="l00699"></a>00699             DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"recvfrom fd %d err %d (\"%s\")\n"</span>,
<a name="l00700" id="l00700"></a>00700                         t-&gt;sock, errno, strerror(errno)));
<a name="l00701" id="l00701"></a>00701         }
<a name="l00702" id="l00702"></a>00702     }
<a name="l00703" id="l00703"></a>00703     <span class="keywordflow">return</span> rc;
<a name="l00704" id="l00704"></a>00704 }
<a name="l00705" id="l00705"></a>00705 
<a name="l00706" id="l00706"></a>00706 
<a name="l00707" id="l00707"></a>00707 
<a name="l00708" id="l00708"></a>00708 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00709" id="l00709"></a>00709 netsnmp_dtlsudp_send(<a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a> *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
<a name="l00710" id="l00710"></a>00710                  <span class="keywordtype">void</span> **opaque, <span class=
"keywordtype">int</span> *olength)
<a name="l00711" id="l00711"></a>00711 {
<a name="l00712" id="l00712"></a>00712     <span class="keywordtype">int</span> rc = -1;
<a name="l00713" id="l00713"></a>00713     <a class="code" href=
"structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a> *addr_pair = NULL;
<a name="l00714" id="l00714"></a>00714     <span class="keyword">struct </span>sockaddr *to = NULL;
<a name="l00715" id="l00715"></a>00715     <a class="code" href="structbio__cache__s.html">bio_cache</a> *cachep = NULL;
<a name="l00716" id="l00716"></a>00716     <a class="code" href=
"structnetsnmp__tmStateReference__s.html">netsnmp_tmStateReference</a> *tmStateRef = NULL;
<a name="l00717" id="l00717"></a>00717     u_char outbuf[65535];
<a name="l00718" id="l00718"></a>00718     
<a name="l00719" id="l00719"></a>00719     <span class=
"keywordflow">if</span> (opaque != NULL &amp;&amp; *opaque != NULL &amp;&amp;
<a name="l00720" id="l00720"></a>00720         *olength == <span class="keyword">sizeof</span>(<a class="code" href=
"structnetsnmp__tmStateReference__s.html">netsnmp_tmStateReference</a>)) {
<a name="l00721" id="l00721"></a>00721         tmStateRef = (<a class="code" href=
"structnetsnmp__tmStateReference__s.html">netsnmp_tmStateReference</a> *) *opaque;
<a name="l00722" id="l00722"></a>00722 
<a name="l00723" id="l00723"></a>00723         <span class="keywordflow">if</span> (tmStateRef-&gt;have_addresses)
<a name="l00724" id="l00724"></a>00724             addr_pair = &amp;(tmStateRef-&gt;addresses);
<a name="l00725" id="l00725"></a>00725         <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL &amp;&amp;
<a name="l00726" id="l00726"></a>00726                  t-&gt;data_length == <span class="keyword">sizeof</span>(<a class="code"
href="structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a>))
<a name="l00727" id="l00727"></a>00727             addr_pair = (<a class="code" href=
"structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a> *) (t-&gt;data);
<a name="l00728" id="l00728"></a>00728     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL &amp;&amp;
<a name="l00729" id="l00729"></a>00729                t-&gt;data_length == <span class="keyword">sizeof</span>(<a class="code"
href="structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a>)) {
<a name="l00730" id="l00730"></a>00730         addr_pair = (<a class="code" href=
"structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a> *) (t-&gt;data);
<a name="l00731" id="l00731"></a>00731     }
<a name="l00732" id="l00732"></a>00732 
<a name="l00733" id="l00733"></a>00733     <span class="keywordflow">if</span> (NULL == addr_pair) {
<a name="l00734" id="l00734"></a>00734         <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"dtlsudp_send: can't get address to send to\n"</span>);
<a name="l00735" id="l00735"></a>00735         <span class="keywordflow">return</span> -1;
<a name="l00736" id="l00736"></a>00736     }
<a name="l00737" id="l00737"></a>00737 
<a name="l00738" id="l00738"></a>00738     to = (<span class=
"keyword">struct </span>sockaddr *) &amp;(addr_pair-&gt;remote_addr);
<a name="l00739" id="l00739"></a>00739 
<a name="l00740" id="l00740"></a>00740     <span class="keywordflow">if</span> (NULL == to || NULL == t || t-&gt;sock &lt;= 0) {
<a name="l00741" id="l00741"></a>00741         <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"invalid netsnmp_dtlsudp_send usage\n"</span>);
<a name="l00742" id="l00742"></a>00742         <span class="keywordflow">return</span> -1;
<a name="l00743" id="l00743"></a>00743     }
<a name="l00744" id="l00744"></a>00744 
<a name="l00745" id="l00745"></a>00745     <span class=
"comment">/* we're always a client if we're sending to something unknown yet */</span>
<a name="l00746" id="l00746"></a>00746     <span class="keywordflow">if</span> (NULL ==
<a name="l00747" id="l00747"></a>00747         (cachep = find_or_create_bio_cache(t-&gt;sock, &amp;addr_pair-&gt;remote_addr,
<a name="l00748" id="l00748"></a>00748                                            WE_ARE_CLIENT)))
<a name="l00749" id="l00749"></a>00749         <span class="keywordflow">return</span> -1;
<a name="l00750" id="l00750"></a>00750 
<a name="l00751" id="l00751"></a>00751     <span class=
"keywordflow">if</span> (!cachep-&gt;securityName &amp;&amp; tmStateRef &amp;&amp; tmStateRef-&gt;securityNameLen &gt; 0)
<a name="l00752" id="l00752"></a>00752         cachep-&gt;securityName = strdup(tmStateRef-&gt;securityName);
<a name="l00753" id="l00753"></a>00753         
<a name="l00754" id="l00754"></a>00754         
<a name="l00755" id="l00755"></a>00755     {
<a name="l00756" id="l00756"></a>00756         <span class=
"keywordtype">char</span> *str = netsnmp_udp_fmtaddr(NULL, (<span class="keywordtype">void</span> *) addr_pair,
<a name="l00757" id="l00757"></a>00757                                         <span class="keyword">sizeof</span>(<a class=
"code" href="structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a>));
<a name="l00758" id="l00758"></a>00758         DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"send %d bytes from %p to %s on fd %d\n"</span>,
<a name="l00759" id="l00759"></a>00759                     size, buf, str, t-&gt;sock));
<a name="l00760" id="l00760"></a>00760         free(str);
<a name="l00761" id="l00761"></a>00761     }
<a name="l00762" id="l00762"></a>00762     rc = SSL_write(cachep-&gt;con, buf, size);
<a name="l00763" id="l00763"></a>00763     <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l00764" id="l00764"></a>00764         _openssl_log_error(rc, cachep-&gt;con, <span class=
"stringliteral">"SSL_write"</span>);
<a name="l00765" id="l00765"></a>00765     }
<a name="l00766" id="l00766"></a>00766 
<a name="l00767" id="l00767"></a>00767     <span class=
"comment">/* for memory bios, we now read from openssl's write buffer (ie,</span>
<a name="l00768" id="l00768"></a>00768 <span class=
"comment">       the packet to go out) and send it out the udp port manually */</span>
<a name="l00769" id="l00769"></a>00769     rc = BIO_read(cachep-&gt;write_bio, outbuf, <span class=
"keyword">sizeof</span>(outbuf));
<a name="l00770" id="l00770"></a>00770     <span class="keywordflow">if</span> (rc &lt;= 0) {
<a name="l00771" id="l00771"></a>00771         <span class="comment">/* in theory an ok thing */</span>
<a name="l00772" id="l00772"></a>00772         <span class="keywordflow">return</span> 0;
<a name="l00773" id="l00773"></a>00773     }
<a name="l00774" id="l00774"></a>00774 <span class=
"preprocessor">#if defined(FIXME) &amp;&amp; defined(linux) &amp;&amp; defined(IP_PKTINFO)</span>
<a name="l00775" id="l00775"></a>00775     <span class=
"comment">/* XXX: before this can work, we need to remember address we</span>
<a name="l00776" id="l00776"></a>00776 <span class="comment">       received it from (addr_pair) */</span>
<a name="l00777" id=
"l00777"></a>00777     rc = netsnmp_udp_sendto(cachep-&gt;sock, &amp;cachep-&gt;sockaddr  remote  addr_pair ? &amp;(addr_pair-&gt;local_addr) : NULL, to, outbuf, rc);
<a name="l00778" id="l00778"></a>00778 <span class="preprocessor">#else</span>
<a name="l00779" id="l00779"></a>00779     rc = sendto(t-&gt;sock, outbuf, rc, 0, &amp;cachep-&gt;sockaddr, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));
<a name="l00780" id="l00780"></a>00780 <span class="preprocessor">#endif </span><span class=
"comment">/* linux &amp;&amp; IP_PKTINFO */</span>
<a name="l00781" id="l00781"></a>00781 
<a name="l00782" id="l00782"></a>00782     <span class="keywordflow">return</span> rc;
<a name="l00783" id="l00783"></a>00783 }
<a name="l00784" id="l00784"></a>00784 
<a name="l00785" id="l00785"></a>00785 
<a name="l00786" id="l00786"></a>00786 
<a name="l00787" id="l00787"></a>00787 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00788" id="l00788"></a>00788 netsnmp_dtlsudp_close(<a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a> *t)
<a name="l00789" id="l00789"></a>00789 {
<a name="l00790" id="l00790"></a>00790     <span class="keywordtype">int</span> rc = -1;
<a name="l00791" id="l00791"></a>00791     <span class="comment">/* XXX: issue a proper dtls closure notification(s) */</span>
<a name="l00792" id="l00792"></a>00792     <span class="keywordflow">if</span> (t-&gt;sock &gt;= 0) {
<a name="l00793" id="l00793"></a>00793 <span class="preprocessor">#ifndef HAVE_CLOSESOCKET</span>
<a name="l00794" id="l00794"></a>00794         rc = close(t-&gt;sock);
<a name="l00795" id="l00795"></a>00795 <span class="preprocessor">#else</span>
<a name="l00796" id="l00796"></a>00796         rc = closesocket(t-&gt;sock);
<a name="l00797" id="l00797"></a>00797 <span class="preprocessor">#endif</span>
<a name="l00798" id="l00798"></a>00798         t-&gt;sock = -1;
<a name="l00799" id="l00799"></a>00799     }
<a name="l00800" id="l00800"></a>00800     <span class="keywordflow">return</span> rc;
<a name="l00801" id="l00801"></a>00801 }
<a name="l00802" id="l00802"></a>00802 
<a name="l00803" id="l00803"></a>00803 <span class="comment">/*</span>
<a name="l00804" id="l00804"></a>00804 <span class=
"comment"> * Open a DTLS-based transport for SNMP.  Local is TRUE if addr is the local</span>
<a name="l00805" id="l00805"></a>00805 <span class=
"comment"> * address to bind to (i.e. this is a server-type session); otherwise addr is </span>
<a name="l00806" id="l00806"></a>00806 <span class="comment"> * the remote address to send things to.  </span>
<a name="l00807" id="l00807"></a>00807 <span class="comment"> */</span>
<a name="l00808" id="l00808"></a>00808 
<a name="l00809" id="l00809"></a>00809 <a class="code" href="structnetsnmp__transport__s.html">netsnmp_transport</a> *
<a name="l00810" id="l00810"></a>00810 netsnmp_dtlsudp_transport(<span class=
"keyword">struct</span> sockaddr_in *addr, <span class="keywordtype">int</span> local)
<a name="l00811" id="l00811"></a>00811 {
<a name="l00812" id="l00812"></a>00812     <a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a> *t = NULL;
<a name="l00813" id="l00813"></a>00813     <span class="keywordtype">int</span>             rc = 0;
<a name="l00814" id="l00814"></a>00814     <span class="keywordtype">char</span>           *str = NULL;
<a name="l00815" id="l00815"></a>00815     <span class="keywordtype">char</span>           *client_socket = NULL;
<a name="l00816" id="l00816"></a>00816     <a class="code" href=
"structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a> addr_pair;
<a name="l00817" id="l00817"></a>00817 
<a name="l00818" id="l00818"></a>00818     <span class="keywordflow">if</span> (addr == NULL || addr-&gt;sin_family != AF_INET) {
<a name="l00819" id="l00819"></a>00819         <span class="keywordflow">return</span> NULL;
<a name="l00820" id="l00820"></a>00820     }
<a name="l00821" id="l00821"></a>00821 
<a name="l00822" id="l00822"></a>00822     memset(&amp;addr_pair, 0, <span class="keyword">sizeof</span>(<a class="code" href=
"structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a>));
<a name="l00823" id="l00823"></a>00823     memcpy(&amp;(addr_pair.remote_addr), addr, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));
<a name="l00824" id="l00824"></a>00824 
<a name="l00825" id="l00825"></a>00825     t = <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424" title=
"Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a>);
<a name="l00826" id="l00826"></a>00826     <span class="keywordflow">if</span> (t == NULL) {
<a name="l00827" id="l00827"></a>00827         <span class="keywordflow">return</span> NULL;
<a name="l00828" id="l00828"></a>00828     }
<a name="l00829" id="l00829"></a>00829 
<a name="l00830" id="l00830"></a>00830     str = netsnmp_udp_fmtaddr(NULL, (<span class=
"keywordtype">void</span> *)&amp;addr_pair,
<a name="l00831" id="l00831"></a>00831                                  <span class="keyword">sizeof</span>(<a class="code" href=
"structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a>));
<a name="l00832" id="l00832"></a>00832     DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"open %s %s\n"</span>, local ? <span class="stringliteral">"local"</span> : <span class=
"stringliteral">"remote"</span>,
<a name="l00833" id="l00833"></a>00833                 str));
<a name="l00834" id="l00834"></a>00834     free(str);
<a name="l00835" id="l00835"></a>00835 
<a name="l00836" id="l00836"></a>00836     t-&gt;domain = netsnmpDTLSUDPDomain;
<a name="l00837" id="l00837"></a>00837     t-&gt;domain_length = netsnmpDTLSUDPDomain_len;
<a name="l00838" id="l00838"></a>00838 
<a name="l00839" id="l00839"></a>00839     t-&gt;sock = socket(PF_INET, SOCK_DGRAM, 0);
<a name="l00840" id="l00840"></a>00840     DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"openned socket %d as local=%d\n"</span>, t-&gt;sock,
<a name="l00841" id="l00841"></a>00841                 local));
<a name="l00842" id="l00842"></a>00842     <span class="keywordflow">if</span> (t-&gt;sock &lt; 0) {
<a name="l00843" id="l00843"></a>00843         netsnmp_transport_free(t);
<a name="l00844" id="l00844"></a>00844         <span class="keywordflow">return</span> NULL;
<a name="l00845" id="l00845"></a>00845     }
<a name="l00846" id="l00846"></a>00846 
<a name="l00847" id="l00847"></a>00847     <span class=
"comment">/* XXX: Potentially set sock opts here (SO_SNDBUF/SO_RCV_BUF) */</span>
<a name="l00848" id="l00848"></a>00848     <span class="comment">/* XXX: and buf size */</span>
<a name="l00849" id="l00849"></a>00849     _netsnmp_udp_sockopt_set(t-&gt;sock, local);
<a name="l00850" id="l00850"></a>00850 
<a name="l00851" id="l00851"></a>00851     <span class="keywordflow">if</span> (local) {
<a name="l00852" id="l00852"></a>00852         <span class="comment">/*</span>
<a name="l00853" id="l00853"></a>00853 <span class=
"comment">         * This session is inteneded as a server, so we must bind on to the</span>
<a name="l00854" id="l00854"></a>00854 <span class=
"comment">         * given IP address, which may include an interface address, or could</span>
<a name="l00855" id="l00855"></a>00855 <span class=
"comment">         * be INADDR_ANY, but certainly includes a port number.</span>
<a name="l00856" id="l00856"></a>00856 <span class="comment">         */</span>
<a name="l00857" id="l00857"></a>00857 
<a name="l00858" id="l00858"></a>00858       t-&gt;local = (u_char *) malloc(6);
<a name="l00859" id="l00859"></a>00859         <span class="keywordflow">if</span> (t-&gt;local == NULL) {
<a name="l00860" id="l00860"></a>00860             netsnmp_transport_free(t);
<a name="l00861" id="l00861"></a>00861             <span class="keywordflow">return</span> NULL;
<a name="l00862" id="l00862"></a>00862         }
<a name="l00863" id="l00863"></a>00863         memcpy(t-&gt;local, (u_char *) &amp; (addr-&gt;sin_addr.s_addr), 4);
<a name="l00864" id="l00864"></a>00864         t-&gt;local[4] = (htons(addr-&gt;sin_port) &amp; 0xff00) &gt;&gt; 8;
<a name="l00865" id="l00865"></a>00865         t-&gt;local[5] = (htons(addr-&gt;sin_port) &amp; 0x00ff) &gt;&gt; 0;
<a name="l00866" id="l00866"></a>00866         t-&gt;local_length = 6;
<a name="l00867" id="l00867"></a>00867 
<a name="l00868" id="l00868"></a>00868 <span class="preprocessor">#if defined(linux) &amp;&amp; defined(IP_PKTINFO)</span>
<a name="l00869" id="l00869"></a>00869         { 
<a name="l00870" id="l00870"></a>00870             <span class="keywordtype">int</span> sockopt = 1;
<a name="l00871" id="l00871"></a>00871             <span class=
"keywordflow">if</span> (setsockopt(t-&gt;sock, SOL_IP, IP_PKTINFO, &amp;sockopt, <span class=
"keyword">sizeof</span> sockopt) == -1) {
<a name="l00872" id="l00872"></a>00872                 DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"couldn't set IP_PKTINFO: %s\n"</span>,
<a name="l00873" id="l00873"></a>00873                     strerror(errno)));
<a name="l00874" id="l00874"></a>00874                 netsnmp_transport_free(t);
<a name="l00875" id="l00875"></a>00875                 <span class="keywordflow">return</span> NULL;
<a name="l00876" id="l00876"></a>00876             }
<a name="l00877" id="l00877"></a>00877             DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"set IP_PKTINFO\n"</span>));
<a name="l00878" id="l00878"></a>00878         }
<a name="l00879" id="l00879"></a>00879 <span class="preprocessor">#endif</span>
<a name="l00880" id="l00880"></a>00880         rc = bind(t-&gt;sock, (<span class="keyword">struct</span> sockaddr *) addr,
<a name="l00881" id="l00881"></a>00881                   <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr));
<a name="l00882" id="l00882"></a>00882         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00883" id="l00883"></a>00883             netsnmp_dtlsudp_close(t);
<a name="l00884" id="l00884"></a>00884             netsnmp_transport_free(t);
<a name="l00885" id="l00885"></a>00885             <span class="keywordflow">return</span> NULL;
<a name="l00886" id="l00886"></a>00886         }
<a name="l00887" id="l00887"></a>00887         t-&gt;data = NULL;
<a name="l00888" id="l00888"></a>00888         t-&gt;data_length = 0;
<a name="l00889" id="l00889"></a>00889     } <span class="keywordflow">else</span> {
<a name="l00890" id="l00890"></a>00890         <span class="comment">/*</span>
<a name="l00891" id="l00891"></a>00891 <span class="comment">         * This is a client session.  If we've been given a</span>
<a name="l00892" id="l00892"></a>00892 <span class="comment">         * client address to send from, then bind to that.</span>
<a name="l00893" id="l00893"></a>00893 <span class="comment">         * Otherwise the send will use "something sensible".</span>
<a name="l00894" id="l00894"></a>00894 <span class="comment">         */</span>
<a name="l00895" id="l00895"></a>00895         client_socket = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
<a name="l00896" id="l00896"></a>00896                                               NETSNMP_DS_LIB_CLIENT_ADDR);
<a name="l00897" id="l00897"></a>00897         <span class="keywordflow">if</span> (client_socket) {
<a name="l00898" id="l00898"></a>00898             <span class="keyword">struct </span>sockaddr_in client_addr;
<a name="l00899" id="l00899"></a>00899             netsnmp_sockaddr_in2(&amp;client_addr, client_socket, NULL);
<a name="l00900" id="l00900"></a>00900             addr_pair.local_addr = client_addr.sin_addr;
<a name="l00901" id="l00901"></a>00901             client_addr.sin_port = 0;
<a name="l00902" id="l00902"></a>00902             DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"binding socket: %d\n"</span>, t-&gt;sock));
<a name="l00903" id="l00903"></a>00903             rc = bind(t-&gt;sock, (<span class=
"keyword">struct</span> sockaddr *)&amp;client_addr,
<a name="l00904" id="l00904"></a>00904                   <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr));
<a name="l00905" id="l00905"></a>00905             <span class="keywordflow">if</span> ( rc != 0 ) {
<a name="l00906" id="l00906"></a>00906                 DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"failed to bind for clientaddr: %d %s\n"</span>,
<a name="l00907" id="l00907"></a>00907                             errno, strerror(errno)));
<a name="l00908" id="l00908"></a>00908                 netsnmp_dtlsudp_close(t);
<a name="l00909" id="l00909"></a>00909                 netsnmp_transport_free(t);
<a name="l00910" id="l00910"></a>00910                 <span class="keywordflow">return</span> NULL;
<a name="l00911" id="l00911"></a>00911             }
<a name="l00912" id="l00912"></a>00912         }
<a name="l00913" id="l00913"></a>00913 
<a name="l00914" id="l00914"></a>00914         str = netsnmp_udp_fmtaddr(NULL, (<span class=
"keywordtype">void</span> *)&amp;addr_pair,
<a name="l00915" id="l00915"></a>00915                  <span class="keyword">sizeof</span>(<a class="code" href=
"structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a>));
<a name="l00916" id="l00916"></a>00916         DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"client open %s\n"</span>, str));
<a name="l00917" id="l00917"></a>00917         free(str);
<a name="l00918" id="l00918"></a>00918 
<a name="l00919" id="l00919"></a>00919         <span class="comment">/*</span>
<a name="l00920" id="l00920"></a>00920 <span class="comment">         * Save the (remote) address in the</span>
<a name="l00921" id="l00921"></a>00921 <span class=
"comment">         * transport-specific data pointer for later use by netsnmp_dtlsudp_send.</span>
<a name="l00922" id="l00922"></a>00922 <span class="comment">         */</span>
<a name="l00923" id="l00923"></a>00923 
<a name="l00924" id="l00924"></a>00924         t-&gt;data = <a class="code" href=
"group__util.html#ga9cd013bb193de5048149afeb9d94e424" title=
"Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href=
"structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a>);
<a name="l00925" id="l00925"></a>00925         t-&gt;remote = (u_char *)malloc(6);
<a name="l00926" id="l00926"></a>00926         <span class="keywordflow">if</span> (t-&gt;data == NULL || t-&gt;remote == NULL) {
<a name="l00927" id="l00927"></a>00927             netsnmp_transport_free(t);
<a name="l00928" id="l00928"></a>00928             <span class="keywordflow">return</span> NULL;
<a name="l00929" id="l00929"></a>00929         }
<a name="l00930" id="l00930"></a>00930         memcpy(t-&gt;remote, (u_char *) &amp; (addr-&gt;sin_addr.s_addr), 4);
<a name="l00931" id="l00931"></a>00931         t-&gt;remote[4] = (htons(addr-&gt;sin_port) &amp; 0xff00) &gt;&gt; 8;
<a name="l00932" id="l00932"></a>00932         t-&gt;remote[5] = (htons(addr-&gt;sin_port) &amp; 0x00ff) &gt;&gt; 0;
<a name="l00933" id="l00933"></a>00933         t-&gt;remote_length = 6;
<a name="l00934" id="l00934"></a>00934         memcpy(t-&gt;data, &amp;addr_pair, <span class="keyword">sizeof</span>(<a class=
"code" href="structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a>));
<a name="l00935" id="l00935"></a>00935         t-&gt;data_length = <span class="keyword">sizeof</span>(<a class="code" href=
"structnetsnmp__addr__pair__s.html">netsnmp_addr_pair</a>);
<a name="l00936" id="l00936"></a>00936 
<a name="l00937" id="l00937"></a>00937         <span class=
"comment">/* dtls needs to bind the socket for SSL_write to work */</span>
<a name="l00938" id="l00938"></a>00938         <span class="keywordflow">if</span> (connect(t-&gt;sock, (<span class=
"keyword">struct</span> sockaddr *) addr, <span class="keyword">sizeof</span>(*addr)) == -1)
<a name="l00939" id="l00939"></a>00939             <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"dtls: failed to connect\n"</span>);
<a name="l00940" id="l00940"></a>00940 
<a name="l00941" id="l00941"></a>00941     }
<a name="l00942" id="l00942"></a>00942 
<a name="l00943" id="l00943"></a>00943     <span class="comment">/*</span>
<a name="l00944" id="l00944"></a>00944 <span class=
"comment">     * 16-bit length field, 8 byte DTLS header, 20 byte IPv4 header  </span>
<a name="l00945" id="l00945"></a>00945 <span class="comment">     */</span>
<a name="l00946" id="l00946"></a>00946 
<a name="l00947" id="l00947"></a>00947     t-&gt;msgMaxSize = 0xffff - 8 - 20;
<a name="l00948" id="l00948"></a>00948     t-&gt;f_recv     = netsnmp_dtlsudp_recv;
<a name="l00949" id="l00949"></a>00949     t-&gt;f_send     = netsnmp_dtlsudp_send;
<a name="l00950" id="l00950"></a>00950     t-&gt;f_close    = netsnmp_dtlsudp_close;
<a name="l00951" id="l00951"></a>00951     t-&gt;f_accept   = NULL;
<a name="l00952" id="l00952"></a>00952     t-&gt;f_fmtaddr  = netsnmp_udp_fmtaddr;
<a name="l00953" id="l00953"></a>00953     t-&gt;flags = NETSNMP_TRANSPORT_FLAG_TUNNELED;
<a name="l00954" id="l00954"></a>00954 
<a name="l00955" id="l00955"></a>00955     <span class="keywordflow">return</span> t;
<a name="l00956" id="l00956"></a>00956 }
<a name="l00957" id="l00957"></a>00957 
<a name="l00958" id="l00958"></a>00958 
<a name="l00959" id="l00959"></a>00959 <span class="keywordtype">void</span>
<a name="l00960" id="l00960"></a>00960 netsnmp_dtlsudp_agent_config_tokens_register(<span class="keywordtype">void</span>)
<a name="l00961" id="l00961"></a>00961 {
<a name="l00962" id="l00962"></a>00962 }
<a name="l00963" id="l00963"></a>00963 
<a name="l00964" id="l00964"></a>00964 
<a name="l00965" id="l00965"></a>00965 
<a name="l00966" id="l00966"></a>00966 
<a name="l00967" id="l00967"></a>00967 <a class="code" href="structnetsnmp__transport__s.html">netsnmp_transport</a> *
<a name="l00968" id="l00968"></a>00968 netsnmp_dtlsudp_create_tstring(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *str, <span class="keywordtype">int</span> local,
<a name="l00969" id="l00969"></a>00969                            <span class="keyword">const</span> <span class=
"keywordtype">char</span> *default_target)
<a name="l00970" id="l00970"></a>00970 {
<a name="l00971" id="l00971"></a>00971     <span class="keyword">struct </span>sockaddr_in addr;
<a name="l00972" id="l00972"></a>00972 
<a name="l00973" id="l00973"></a>00973     <span class=
"keywordflow">if</span> (netsnmp_sockaddr_in2(&amp;addr, str, default_target)) {
<a name="l00974" id="l00974"></a>00974         <span class=
"keywordflow">return</span> netsnmp_dtlsudp_transport(&amp;addr, local);
<a name="l00975" id="l00975"></a>00975     } <span class="keywordflow">else</span> {
<a name="l00976" id="l00976"></a>00976         <span class="keywordflow">return</span> NULL;
<a name="l00977" id="l00977"></a>00977     }
<a name="l00978" id="l00978"></a>00978 }
<a name="l00979" id="l00979"></a>00979 
<a name="l00980" id="l00980"></a>00980 
<a name="l00981" id="l00981"></a>00981 <a class="code" href="structnetsnmp__transport__s.html">netsnmp_transport</a> *
<a name="l00982" id="l00982"></a>00982 netsnmp_dtlsudp_create_ostring(<span class="keyword">const</span> u_char * o, <span class=
"keywordtype">size_t</span> o_len, <span class="keywordtype">int</span> local)
<a name="l00983" id="l00983"></a>00983 {
<a name="l00984" id="l00984"></a>00984     <span class="keyword">struct </span>sockaddr_in addr;
<a name="l00985" id="l00985"></a>00985 
<a name="l00986" id="l00986"></a>00986     <span class="keywordflow">if</span> (o_len == 6) {
<a name="l00987" id="l00987"></a>00987         <span class="keywordtype">unsigned</span> <span class=
"keywordtype">short</span> porttmp = (o[4] &lt;&lt; 8) + o[5];
<a name="l00988" id="l00988"></a>00988         addr.sin_family = AF_INET;
<a name="l00989" id="l00989"></a>00989         memcpy((u_char *) &amp; (addr.sin_addr.s_addr), o, 4);
<a name="l00990" id="l00990"></a>00990         addr.sin_port = htons(porttmp);
<a name="l00991" id="l00991"></a>00991         <span class=
"keywordflow">return</span> netsnmp_dtlsudp_transport(&amp;addr, local);
<a name="l00992" id="l00992"></a>00992     }
<a name="l00993" id="l00993"></a>00993     <span class="keywordflow">return</span> NULL;
<a name="l00994" id="l00994"></a>00994 }
<a name="l00995" id="l00995"></a>00995 
<a name="l00996" id="l00996"></a>00996 <span class=
"preprocessor">#define LOGANDDIE(msg) { snmp_log(LOG_ERR, "%s\n", msg); return 0; }</span>
<a name="l00997" id="l00997"></a>00997 
<a name="l00998" id="l00998"></a>00998 <span class="keyword">static</span> <span class=
"keywordtype">int</span> have_done_init = 0;
<a name="l00999" id="l00999"></a>00999 
<a name="l01000" id="l01000"></a>01000 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l01001" id="l01001"></a>01001 dtlsudp_bootstrap(<span class="keywordtype">int</span> majorid, <span class=
"keywordtype">int</span> minorid, <span class="keywordtype">void</span> *serverarg, <span class=
"keywordtype">void</span> *clientarg) {
<a name="l01002" id="l01002"></a>01002     <span class="keyword">const</span> <span class="keywordtype">char</span> *certfile;
<a name="l01003" id="l01003"></a>01003     EVP_PKEY *key = NULL;
<a name="l01004" id="l01004"></a>01004     X509 *cert = NULL;
<a name="l01005" id="l01005"></a>01005     BIO *keybio = NULL;
<a name="l01006" id="l01006"></a>01006 
<a name="l01007" id="l01007"></a>01007     <span class="comment">/* don't do this more than once */</span>
<a name="l01008" id="l01008"></a>01008     <span class="keywordflow">if</span> (have_done_init)
<a name="l01009" id="l01009"></a>01009         <span class="keywordflow">return</span> 0;
<a name="l01010" id="l01010"></a>01010     have_done_init = 1;
<a name="l01011" id="l01011"></a>01011 
<a name="l01012" id="l01012"></a>01012     <span class=
"comment">/***********************************************************************</span>
<a name="l01013" id="l01013"></a>01013 <span class="comment">     * Set up the client context</span>
<a name="l01014" id="l01014"></a>01014 <span class="comment">     */</span>
<a name="l01015" id="l01015"></a>01015     client_ctx = SSL_CTX_new(DTLSv1_client_method());
<a name="l01016" id="l01016"></a>01016     <span class="keywordflow">if</span> (!client_ctx) {
<a name="l01017" id="l01017"></a>01017         LOGANDDIE(<span class="stringliteral">"can't create a new context"</span>);
<a name="l01018" id="l01018"></a>01018     }
<a name="l01019" id="l01019"></a>01019     SSL_CTX_set_read_ahead (client_ctx, 1); <span class=
"comment">/* Required for DTLS */</span>
<a name="l01020" id="l01020"></a>01020         
<a name="l01021" id="l01021"></a>01021     SSL_CTX_set_verify(client_ctx,
<a name="l01022" id="l01022"></a>01022                        SSL_VERIFY_PEER|
<a name="l01023" id="l01023"></a>01023                        SSL_VERIFY_FAIL_IF_NO_PEER_CERT|
<a name="l01024" id="l01024"></a>01024                        SSL_VERIFY_CLIENT_ONCE,
<a name="l01025" id="l01025"></a>01025                        &amp;verify_callback);
<a name="l01026" id="l01026"></a>01026 
<a name="l01027" id="l01027"></a>01027     keybio = BIO_new(BIO_s_file());
<a name="l01028" id="l01028"></a>01028     <span class="keywordflow">if</span> (!keybio)
<a name="l01029" id="l01029"></a>01029         LOGANDDIE (<span class=
"stringliteral">"error creating bio for reading public key"</span>);
<a name="l01030" id="l01030"></a>01030 
<a name="l01031" id="l01031"></a>01031     certfile = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
<a name="l01032" id="l01032"></a>01032                                      NETSNMP_DS_LIB_X509_CLIENT_PUB);
<a name="l01033" id="l01033"></a>01033 
<a name="l01034" id="l01034"></a>01034     DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"using public key: %s\n"</span>, certfile));
<a name="l01035" id="l01035"></a>01035     <span class="keywordflow">if</span> (BIO_read_filename(keybio, certfile) &lt;=0)
<a name="l01036" id="l01036"></a>01036         LOGANDDIE (<span class="stringliteral">"error reading public key"</span>);
<a name="l01037" id="l01037"></a>01037 
<a name="l01038" id="l01038"></a>01038     cert = PEM_read_bio_X509_AUX(keybio, NULL, NULL, NULL);
<a name="l01039" id="l01039"></a>01039     <span class="keywordflow">if</span> (!cert)
<a name="l01040" id="l01040"></a>01040         LOGANDDIE(<span class="stringliteral">"failed to load public key"</span>);
<a name="l01041" id="l01041"></a>01041 
<a name="l01042" id="l01042"></a>01042     <span class="comment">/* XXX: mem leak on previous keybio? */</span>
<a name="l01043" id="l01043"></a>01043 
<a name="l01044" id="l01044"></a>01044     certfile = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
<a name="l01045" id="l01045"></a>01045                                      NETSNMP_DS_LIB_X509_CLIENT_PRIV);
<a name="l01046" id="l01046"></a>01046 
<a name="l01047" id="l01047"></a>01047     keybio = BIO_new(BIO_s_file());
<a name="l01048" id="l01048"></a>01048     <span class="keywordflow">if</span> (!keybio)
<a name="l01049" id="l01049"></a>01049         LOGANDDIE (<span class=
"stringliteral">"error creating bio for reading private key"</span>);
<a name="l01050" id="l01050"></a>01050 
<a name="l01051" id="l01051"></a>01051     DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"using private key: %s\n"</span>, certfile));
<a name="l01052" id="l01052"></a>01052     <span class="keywordflow">if</span> (!keybio ||
<a name="l01053" id="l01053"></a>01053         BIO_read_filename(keybio, certfile) &lt;= 0)
<a name="l01054" id="l01054"></a>01054         LOGANDDIE (<span class="stringliteral">"error reading private key"</span>);
<a name="l01055" id="l01055"></a>01055 
<a name="l01056" id="l01056"></a>01056     key = PEM_read_bio_PrivateKey(keybio, NULL, NULL, NULL);
<a name="l01057" id="l01057"></a>01057     
<a name="l01058" id="l01058"></a>01058     <span class="keywordflow">if</span> (!key)
<a name="l01059" id="l01059"></a>01059         LOGANDDIE(<span class="stringliteral">"failed to load private key"</span>);
<a name="l01060" id="l01060"></a>01060 
<a name="l01061" id="l01061"></a>01061 
<a name="l01062" id="l01062"></a>01062     <span class=
"keywordflow">if</span> (SSL_CTX_use_certificate(client_ctx, cert) &lt;= 0)
<a name="l01063" id="l01063"></a>01063         LOGANDDIE(<span class=
"stringliteral">"failed to set the certificate to use"</span>);
<a name="l01064" id="l01064"></a>01064 
<a name="l01065" id="l01065"></a>01065     <span class="keywordflow">if</span> (SSL_CTX_use_PrivateKey(client_ctx, key) &lt;= 0)
<a name="l01066" id="l01066"></a>01066         LOGANDDIE(<span class=
"stringliteral">"failed to set the private key to use"</span>);
<a name="l01067" id="l01067"></a>01067 
<a name="l01068" id="l01068"></a>01068     <span class="keywordflow">if</span> (!SSL_CTX_check_private_key(client_ctx))
<a name="l01069" id="l01069"></a>01069         LOGANDDIE(<span class=
"stringliteral">"public and private keys incompatible"</span>);
<a name="l01070" id="l01070"></a>01070     
<a name="l01071" id="l01071"></a>01071 
<a name="l01072" id="l01072"></a>01072     certfile = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
<a name="l01073" id="l01073"></a>01073                                      NETSNMP_DS_LIB_X509_SERVER_CERTS);
<a name="l01074" id="l01074"></a>01074 
<a name="l01075" id="l01075"></a>01075     <span class=
"comment">/* XXX: also need to match individual cert to indiv. host */</span>
<a name="l01076" id="l01076"></a>01076 
<a name="l01077" id="l01077"></a>01077     <span class=
"keywordflow">if</span>(! SSL_CTX_load_verify_locations(client_ctx, certfile, NULL)) {
<a name="l01078" id="l01078"></a>01078         LOGANDDIE(<span class="stringliteral">"failed to load truststore"</span>);
<a name="l01079" id="l01079"></a>01079         <span class="comment">/* Handle failed load here */</span>
<a name="l01080" id="l01080"></a>01080     }
<a name="l01081" id="l01081"></a>01081 
<a name="l01082" id="l01082"></a>01082     <span class="keywordflow">if</span> (!SSL_CTX_set_default_verify_paths(client_ctx)) {
<a name="l01083" id="l01083"></a>01083         LOGANDDIE (<span class=
"stringliteral">"failed to set default verify path"</span>);
<a name="l01084" id="l01084"></a>01084     }
<a name="l01085" id="l01085"></a>01085 
<a name="l01086" id="l01086"></a>01086     <span class=
"comment">/***********************************************************************</span>
<a name="l01087" id="l01087"></a>01087 <span class="comment">     * Set up the server context</span>
<a name="l01088" id="l01088"></a>01088 <span class="comment">     */</span>
<a name="l01089" id="l01089"></a>01089     <span class="comment">/* setting up for ssl */</span>
<a name="l01090" id="l01090"></a>01090     server_ctx = SSL_CTX_new(DTLSv1_server_method());
<a name="l01091" id="l01091"></a>01091     <span class="keywordflow">if</span> (!server_ctx) {
<a name="l01092" id="l01092"></a>01092         LOGANDDIE(<span class="stringliteral">"can't create a new context"</span>);
<a name="l01093" id="l01093"></a>01093     }
<a name="l01094" id="l01094"></a>01094 
<a name="l01095" id="l01095"></a>01095     certfile = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
<a name="l01096" id="l01096"></a>01096                                      NETSNMP_DS_LIB_X509_SERVER_PUB);
<a name="l01097" id="l01097"></a>01097 
<a name="l01098" id="l01098"></a>01098     <span class=
"keywordflow">if</span> (SSL_CTX_use_certificate_file(server_ctx, certfile,
<a name="l01099" id="l01099"></a>01099                                      SSL_FILETYPE_PEM) &lt; 1) {
<a name="l01100" id="l01100"></a>01100         LOGANDDIE(<span class="stringliteral">"faild to load cert"</span>);
<a name="l01101" id="l01101"></a>01101     }
<a name="l01102" id="l01102"></a>01102     
<a name="l01103" id="l01103"></a>01103     certfile = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
<a name="l01104" id="l01104"></a>01104                                      NETSNMP_DS_LIB_X509_SERVER_PRIV);
<a name="l01105" id="l01105"></a>01105 
<a name="l01106" id="l01106"></a>01106     <span class=
"keywordflow">if</span> (SSL_CTX_use_PrivateKey_file(server_ctx, certfile, SSL_FILETYPE_PEM) &lt; 1) {
<a name="l01107" id="l01107"></a>01107         LOGANDDIE(<span class="stringliteral">"faild to load key"</span>);
<a name="l01108" id="l01108"></a>01108     }
<a name="l01109" id="l01109"></a>01109 
<a name="l01110" id="l01110"></a>01110     SSL_CTX_set_read_ahead(server_ctx, 1);
<a name="l01111" id="l01111"></a>01111 
<a name="l01112" id="l01112"></a>01112 
<a name="l01113" id="l01113"></a>01113     certfile = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
<a name="l01114" id="l01114"></a>01114                                      NETSNMP_DS_LIB_X509_CLIENT_CERTS);
<a name="l01115" id="l01115"></a>01115     <span class=
"keywordflow">if</span>(! SSL_CTX_load_verify_locations(server_ctx, certfile, NULL)) {
<a name="l01116" id="l01116"></a>01116         LOGANDDIE(<span class="stringliteral">"failed to load truststore"</span>);
<a name="l01117" id="l01117"></a>01117         <span class="comment">/* Handle failed load here */</span>
<a name="l01118" id="l01118"></a>01118     }
<a name="l01119" id="l01119"></a>01119 
<a name="l01120" id="l01120"></a>01120     SSL_CTX_set_verify(server_ctx,
<a name="l01121" id="l01121"></a>01121                        SSL_VERIFY_PEER|
<a name="l01122" id="l01122"></a>01122                        SSL_VERIFY_FAIL_IF_NO_PEER_CERT|
<a name="l01123" id="l01123"></a>01123                        SSL_VERIFY_CLIENT_ONCE,
<a name="l01124" id="l01124"></a>01124                        &amp;verify_callback);
<a name="l01125" id="l01125"></a>01125 
<a name="l01126" id="l01126"></a>01126     <span class="keywordflow">return</span> 0;
<a name="l01127" id="l01127"></a>01127 }
<a name="l01128" id="l01128"></a>01128 
<a name="l01129" id="l01129"></a>01129 
<a name="l01130" id="l01130"></a>01130 <span class="keywordtype">void</span>
<a name="l01131" id="l01131"></a>01131 netsnmp_dtlsudp_ctor(<span class="keywordtype">void</span>)
<a name="l01132" id="l01132"></a>01132 {
<a name="l01133" id="l01133"></a>01133     DEBUGMSGTL((<span class="stringliteral">"dtlsudp"</span>, <span class=
"stringliteral">"registering DTLS constructor\n"</span>));
<a name="l01134" id="l01134"></a>01134 
<a name="l01135" id="l01135"></a>01135     <span class="comment">/* config settings */</span>
<a name="l01136" id="l01136"></a>01136 
<a name="l01137" id="l01137"></a>01137     <span class="comment">/* bootstrap ssl since we'll need it */</span>
<a name="l01138" id="l01138"></a>01138     netsnmp_init_openssl();
<a name="l01139" id="l01139"></a>01139 
<a name="l01140" id="l01140"></a>01140     <span class="comment">/*</span>
<a name="l01141" id="l01141"></a>01141 <span class="comment">     * for the client</span>
<a name="l01142" id="l01142"></a>01142 <span class="comment">     */</span>
<a name="l01143" id="l01143"></a>01143 
<a name="l01144" id="l01144"></a>01144     <span class="comment">/* pem file of valid server CERT CAs */</span>
<a name="l01145" id="l01145"></a>01145     netsnmp_ds_register_config(ASN_OCTET_STR, <span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"defX509ServerCerts"</span>,
<a name="l01146" id="l01146"></a>01146                                NETSNMP_DS_LIBRARY_ID,
<a name="l01147" id="l01147"></a>01147                                NETSNMP_DS_LIB_X509_SERVER_CERTS);
<a name="l01148" id="l01148"></a>01148 
<a name="l01149" id="l01149"></a>01149     <span class="comment">/* the public client cert to authenticate with */</span>
<a name="l01150" id="l01150"></a>01150     netsnmp_ds_register_config(ASN_OCTET_STR, <span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"defX509ClientPub"</span>,
<a name="l01151" id="l01151"></a>01151                                NETSNMP_DS_LIBRARY_ID,
<a name="l01152" id="l01152"></a>01152                                NETSNMP_DS_LIB_X509_CLIENT_PUB);
<a name="l01153" id="l01153"></a>01153 
<a name="l01154" id="l01154"></a>01154     <span class="comment">/* the private client cert to authenticate with */</span>
<a name="l01155" id="l01155"></a>01155     netsnmp_ds_register_config(ASN_OCTET_STR, <span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"defX509ClientPriv"</span>,
<a name="l01156" id="l01156"></a>01156                                NETSNMP_DS_LIBRARY_ID,
<a name="l01157" id="l01157"></a>01157                                NETSNMP_DS_LIB_X509_CLIENT_PRIV);
<a name="l01158" id="l01158"></a>01158 
<a name="l01159" id="l01159"></a>01159     <span class="comment">/*</span>
<a name="l01160" id="l01160"></a>01160 <span class="comment">     * for the server</span>
<a name="l01161" id="l01161"></a>01161 <span class="comment">     */</span>
<a name="l01162" id="l01162"></a>01162 
<a name="l01163" id="l01163"></a>01163     <span class=
"comment">/* The list of valid client keys to accept (or CAs I think) */</span>
<a name="l01164" id="l01164"></a>01164     netsnmp_ds_register_config(ASN_OCTET_STR, <span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"defX509ClientCerts"</span>,
<a name="l01165" id="l01165"></a>01165                                NETSNMP_DS_LIBRARY_ID,
<a name="l01166" id="l01166"></a>01166                                NETSNMP_DS_LIB_X509_CLIENT_CERTS);
<a name="l01167" id="l01167"></a>01167 
<a name="l01168" id="l01168"></a>01168     <span class="comment">/* The X509 server key to use */</span>
<a name="l01169" id="l01169"></a>01169     netsnmp_ds_register_config(ASN_OCTET_STR, <span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"defX509ServerPub"</span>,
<a name="l01170" id="l01170"></a>01170                                NETSNMP_DS_LIBRARY_ID,
<a name="l01171" id="l01171"></a>01171                                NETSNMP_DS_LIB_X509_SERVER_PUB);
<a name="l01172" id="l01172"></a>01172 
<a name="l01173" id="l01173"></a>01173     netsnmp_ds_register_config(ASN_OCTET_STR, <span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"defX509ServerPriv"</span>,
<a name="l01174" id="l01174"></a>01174                                NETSNMP_DS_LIBRARY_ID,
<a name="l01175" id="l01175"></a>01175                                NETSNMP_DS_LIB_X509_SERVER_PRIV);
<a name="l01176" id="l01176"></a>01176 
<a name="l01177" id="l01177"></a>01177     netsnmp_ds_register_config(ASN_BOOLEAN, <span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"AllowSelfSignedX509"</span>,
<a name="l01178" id="l01178"></a>01178                                NETSNMP_DS_LIBRARY_ID,
<a name="l01179" id="l01179"></a>01179                                NETSNMP_DS_LIB_ALLOW_SELF_SIGNED);
<a name="l01180" id="l01180"></a>01180 
<a name="l01181" id="l01181"></a>01181     <span class="comment">/*</span>
<a name="l01182" id="l01182"></a>01182 <span class="comment">     * register our boot-strapping needs</span>
<a name="l01183" id="l01183"></a>01183 <span class="comment">     */</span>
<a name="l01184" id="l01184"></a>01184     <a class="code" href="group__callback.html#gaa74bcb0ea6a8b7270f5e26746ba1fff1" title=
"This function registers a generic callback function.">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
<a name="l01185" id="l01185"></a>01185                            SNMP_CALLBACK_POST_READ_CONFIG,
<a name="l01186" id="l01186"></a>01186                            dtlsudp_bootstrap, NULL);
<a name="l01187" id="l01187"></a>01187 
<a name="l01188" id="l01188"></a>01188     dtlsudpDomain.name = netsnmpDTLSUDPDomain;
<a name="l01189" id="l01189"></a>01189     dtlsudpDomain.name_length = netsnmpDTLSUDPDomain_len;
<a name="l01190" id="l01190"></a>01190     dtlsudpDomain.prefix = (<span class="keyword">const</span> <span class=
"keywordtype">char</span>**)calloc(2, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
<a name="l01191" id="l01191"></a>01191     dtlsudpDomain.prefix[0] = <span class="stringliteral">"dtlsudp"</span>;
<a name="l01192" id="l01192"></a>01192 
<a name="l01193" id="l01193"></a>01193     dtlsudpDomain.f_create_from_tstring_new = netsnmp_dtlsudp_create_tstring;
<a name="l01194" id="l01194"></a>01194     dtlsudpDomain.f_create_from_ostring = netsnmp_dtlsudp_create_ostring;
<a name="l01195" id="l01195"></a>01195 
<a name="l01196" id="l01196"></a>01196     netsnmp_tdomain_register(&amp;dtlsudpDomain);
<a name="l01197" id="l01197"></a>01197 }
</pre>
    </div>
  </div>
  <hr size="1" />

  <address style="text-align: right;">
    <small>Generated on 28 Sep 2009 for net-snmp by  <a href="http://www.doxygen.org/index.html"><img class="footer" src=
    "doxygen.png" alt="doxygen" /></a> 1.6.1</small>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

