<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>mib.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * mib.c</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * $Id$</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> * Update: 1998-07-17 &lt;jhy@gsu.edu&gt;</span>
00007 <span class="comment"> * Added print_oid_report* functions.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> */</span>
00010 <span class="comment">/* Portions of this file are subject to the following copyrights.  See</span>
00011 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00012 <span class="comment"> * that may apply:</span>
00013 <span class="comment"> */</span>
00014 <span class="comment">/**********************************************************************</span>
00015 <span class="comment">        Copyright 1988, 1989, 1991, 1992 by Carnegie Mellon University</span>
00016 
00017 <span class="comment">                      All Rights Reserved</span>
00018 
00019 <span class="comment">Permission to use, copy, modify, and distribute this software and its</span>
00020 <span class="comment">documentation for any purpose and without fee is hereby granted,</span>
00021 <span class="comment">provided that the above copyright notice appear in all copies and that</span>
00022 <span class="comment">both that copyright notice and this permission notice appear in</span>
00023 <span class="comment">supporting documentation, and that the name of CMU not be</span>
00024 <span class="comment">used in advertising or publicity pertaining to distribution of the</span>
00025 <span class="comment">software without specific, written prior permission.</span>
00026 
00027 <span class="comment">CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING</span>
00028 <span class="comment">ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL</span>
00029 <span class="comment">CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR</span>
00030 <span class="comment">ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</span>
00031 <span class="comment">WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,</span>
00032 <span class="comment">ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS</span>
00033 <span class="comment">SOFTWARE.</span>
00034 <span class="comment">******************************************************************/</span>
00035 <span class="comment">/*</span>
00036 <span class="comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
00037 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00038 <span class="comment"> * distributed with the Net-SNMP package.</span>
00039 <span class="comment"> */</span>
00040 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00041 
00042 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00043 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00044 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00045 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00046 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00047 <span class="preprocessor">#endif</span>
00048 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00049 <span class="preprocessor"># ifdef WIN32</span>
00050 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00051 <span class="preprocessor"># else</span>
00052 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00053 <span class="preprocessor"># endif</span>
00054 <span class="preprocessor"># include &lt;time.h&gt;</span>
00055 <span class="preprocessor">#else</span>
00056 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00057 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00058 <span class="preprocessor"># else</span>
00059 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00060 <span class="preprocessor"># endif</span>
00061 <span class="preprocessor">#endif</span>
00062 <span class="preprocessor">#if HAVE_STRING_H</span>
00063 <span class="preprocessor">#include &lt;string.h&gt;</span>
00064 <span class="preprocessor">#else</span>
00065 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00066 <span class="preprocessor">#endif</span>
00067 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00068 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00069 <span class="preprocessor">#endif</span>
00070 <span class="preprocessor">#if HAVE_SYS_SELECT_H</span>
00071 <span class="preprocessor">#include &lt;sys/select.h&gt;</span>
00072 <span class="preprocessor">#endif</span>
00073 
00074 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00075 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00076 <span class="preprocessor">#endif</span>
00077 
00078 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00079 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00080 <span class="preprocessor">#endif</span>
00081 
00082 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00083 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00084 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00085 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00086 
00087 <span class="preprocessor">#include &lt;net-snmp/library/asn1.h&gt;</span>
00088 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00089 <span class="preprocessor">#include &lt;net-snmp/library/mib.h&gt;</span>
00090 <span class="preprocessor">#include &lt;net-snmp/library/parse.h&gt;</span>
00091 <span class="preprocessor">#include &lt;net-snmp/library/int64.h&gt;</span>
00092 <span class="preprocessor">#include &lt;net-snmp/library/snmp_client.h&gt;</span>
00093 
00100 <span class="keyword">static</span> <span class="keywordtype">char</span>    *uptimeString(u_long, <span class=
"keywordtype">char</span> *);
00101 
00102 <span class="keyword">static</span> <span class="keyword">struct </span>tree *_get_realloc_symbol(<span class=
"keyword">const</span> oid * objid, size_t objidlen,
00103                                         <span class="keyword">struct</span> tree *subtree,
00104                                         u_char ** buf, size_t * buf_len,
00105                                         size_t * out_len,
00106                                         <span class="keywordtype">int</span> allow_realloc,
00107                                         <span class="keywordtype">int</span> *buf_overflow,
00108                                         <span class="keyword">struct</span> index_list *in_dices,
00109                                         size_t * end_of_known);
00110 
00111 <span class="keyword">static</span> <span class=
"keywordtype">int</span>      print_tree_node(u_char ** buf, size_t * buf_len,
00112                                 size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
00113                                 <span class="keyword">struct</span> tree *tp, <span class="keywordtype">int</span> width);
00114 <span class="keyword">static</span> <span class="keywordtype">void</span>     handle_mibdirs_conf(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keywordtype">char</span> *line);
00115 <span class="keyword">static</span> <span class="keywordtype">void</span>     handle_mibs_conf(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keywordtype">char</span> *line);
00116 <span class="keyword">static</span> <span class="keywordtype">void</span>     handle_mibfile_conf(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keywordtype">char</span> *line);
00117 
00118 <span class="keyword">static</span> <span class="keywordtype">void</span>     _oid_finish_printing(<span class=
"keyword">const</span> oid * objid, size_t objidlen,
00119                                      u_char ** buf, size_t * buf_len,
00120                                      size_t * out_len,
00121                                      <span class="keywordtype">int</span> allow_realloc, <span class=
"keywordtype">int</span> *buf_overflow);
00122 
00123 <span class="comment">/*</span>
00124 <span class="comment"> * helper functions for get_module_node </span>
00125 <span class="comment"> */</span>
00126 <span class="keyword">static</span> <span class="keywordtype">int</span>      node_to_oid(<span class=
"keyword">struct</span> tree *, oid *, size_t *);
00127 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
00128 <span class="keyword">static</span> <span class="keywordtype">int</span>      _add_strings_to_oid(<span class=
"keyword">struct</span> tree *, <span class="keywordtype">char</span> *,
00129                                     oid *, size_t *, size_t);
00130 <span class="preprocessor">#else</span>
00131 <span class="keyword">static</span> <span class="keywordtype">int</span>      _add_strings_to_oid(<span class=
"keywordtype">void</span> *, <span class="keywordtype">char</span> *,
00132                                     oid *, size_t *, size_t);
00133 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
00134 
00135 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
00136 <span class="keyword">extern</span> <span class="keyword">struct </span>tree *tree_head;
00137 <span class="keyword">static</span> <span class="keyword">struct </span>tree *tree_top;
00138 
00139 <span class="keyword">struct </span>tree    *Mib;            <span class="comment">/* Backwards compatibility */</span>
00140 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
00141 
00142 oid             RFC1213_MIB[] = { 1, 3, 6, 1, 2, 1 };
00143 <span class="keyword">static</span> <span class="keywordtype">char</span>     Standard_Prefix[] = <span class=
"stringliteral">".1.3.6.1.2.1"</span>;
00144 
00145 <span class="comment">/*</span>
00146 <span class="comment"> * Set default here as some uses of read_objid require valid pointer. </span>
00147 <span class="comment"> */</span>
00148 <span class="keyword">static</span> <span class="keywordtype">char</span>    *Prefix = &amp;Standard_Prefix[0];
00149 <span class="keyword">typedef</span> <span class="keyword">struct </span>_PrefixList {
00150     <span class="keyword">const</span> <span class="keywordtype">char</span>     *str;
00151     <span class="keywordtype">int</span>             len;
00152 }              *PrefixListPtr, PrefixList;
00153 
00154 <span class="comment">/*</span>
00155 <span class="comment"> * Here are the prefix strings.</span>
00156 <span class="comment"> * Note that the first one finds the value of Prefix or Standard_Prefix.</span>
00157 <span class="comment"> * Any of these MAY start with period; all will NOT end with period.</span>
00158 <span class="comment"> * Period is added where needed.  See use of Prefix in this module.</span>
00159 <span class="comment"> */</span>
00160 PrefixList      mib_prefixes[] = {
00161     {&amp;Standard_Prefix[0]},      <span class="comment">/* placeholder for Prefix data */</span>
00162     {<span class="stringliteral">".iso.org.dod.internet.mgmt.mib-2"</span>},
00163     {<span class="stringliteral">".iso.org.dod.internet.experimental"</span>},
00164     {<span class="stringliteral">".iso.org.dod.internet.private"</span>},
00165     {<span class="stringliteral">".iso.org.dod.internet.snmpParties"</span>},
00166     {<span class="stringliteral">".iso.org.dod.internet.snmpSecrets"</span>},
00167     {NULL, 0}                   <span class="comment">/* end of list */</span>
00168 };
00169 
00170 <span class="keyword">enum</span> inet_address_type {
00171     IPV4 = 1,
00172     IPV6 = 2,
00173     IPV4Z = 3,
00174     IPV6Z = 4,
00175     DNS = 16
00176 };
00177 
00178 
00189 <span class="keyword">static</span> <span class="keywordtype">char</span>    *
00190 uptimeString(u_long timeticks, <span class="keywordtype">char</span> *buf)
00191 {
00192     <span class="keywordtype">int</span>             centisecs, seconds, minutes, hours, days;
00193 
00194     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS)) {
00195         sprintf(buf, <span class="stringliteral">"%lu"</span>, timeticks);
00196         <span class="keywordflow">return</span> buf;
00197     }
00198 
00199 
00200     centisecs = timeticks % 100;
00201     timeticks /= 100;
00202     days = timeticks / (60 * 60 * 24);
00203     timeticks %= (60 * 60 * 24);
00204 
00205     hours = timeticks / (60 * 60);
00206     timeticks %= (60 * 60);
00207 
00208     minutes = timeticks / 60;
00209     seconds = timeticks % 60;
00210 
00211     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT))
00212         sprintf(buf, <span class="stringliteral">"%d:%d:%02d:%02d.%02d"</span>,
00213                 days, hours, minutes, seconds, centisecs);
00214     <span class="keywordflow">else</span> {
00215         <span class="keywordflow">if</span> (days == 0) {
00216             sprintf(buf, <span class="stringliteral">"%d:%02d:%02d.%02d"</span>,
00217                     hours, minutes, seconds, centisecs);
00218         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (days == 1) {
00219             sprintf(buf, <span class="stringliteral">"%d day, %d:%02d:%02d.%02d"</span>,
00220                     days, hours, minutes, seconds, centisecs);
00221         } <span class="keywordflow">else</span> {
00222             sprintf(buf, <span class="stringliteral">"%d days, %d:%02d:%02d.%02d"</span>,
00223                     days, hours, minutes, seconds, centisecs);
00224         }
00225     }
00226     <span class="keywordflow">return</span> buf;
00227 }
00228 
00229 
00230 
00239 <span class="keyword">static</span> <span class="keywordtype">void</span>
00240 sprint_char(<span class="keywordtype">char</span> *buf, <span class="keyword">const</span> u_char ch)
00241 {
00242     <span class="keywordflow">if</span> (isprint(ch)) {
00243         sprintf(buf, <span class="stringliteral">"%c"</span>, (<span class="keywordtype">int</span>) ch);
00244     } <span class="keywordflow">else</span> {
00245         sprintf(buf, <span class="stringliteral">"."</span>);
00246     }
00247 }
00248 
00249 
00250 
00270 <span class="keywordtype">int</span>
<a name="l00271" id="l00271"></a><a class="code" href="group__mib__utilities.html#ga25">00271</a> <a class="code" href=
"group__mib__utilities.html#ga25">_sprint_hexstring_line</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
00272                        <span class="keywordtype">int</span> allow_realloc, <span class=
"keyword">const</span> u_char * cp, size_t line_len)
00273 {
00274     <span class="keyword">const</span> u_char   *tp;
00275     <span class="keyword">const</span> u_char   *cp2 = cp;
00276     size_t          lenleft = line_len;
00277 
00278     <span class="comment">/*</span>
00279 <span class="comment">     * Make sure there's enough room for the hex output....</span>
00280 <span class="comment">     */</span>
00281     <span class="keywordflow">while</span> ((*out_len + line_len*3+1) &gt;= *buf_len) {
00282         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00283             <span class="keywordflow">return</span> 0;
00284         }
00285     }
00286 
00287     <span class="comment">/*</span>
00288 <span class="comment">     * .... and display the hex values themselves....</span>
00289 <span class="comment">     */</span>
00290     <span class="keywordflow">for</span> (; lenleft &gt;= 8; lenleft-=8) {
00291         sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len),
00292                 <span class="stringliteral">"%02X %02X %02X %02X %02X %02X %02X %02X "</span>, cp[0], cp[1],
00293                 cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
00294         *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
00295         cp       += 8;
00296     }
00297     <span class="keywordflow">for</span> (; lenleft &gt; 0; lenleft--) {
00298         sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class=
"stringliteral">"%02X "</span>, *cp++);
00299         *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
00300     }
00301 
00302     <span class="comment">/*</span>
00303 <span class="comment">     * .... plus (optionally) do the same for the ASCII equivalent.</span>
00304 <span class="comment">     */</span>
00305     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT)) {
00306         <span class="keywordflow">while</span> ((*out_len + line_len+5) &gt;= *buf_len) {
00307             <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00308                 <span class="keywordflow">return</span> 0;
00309             }
00310         }
00311         sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class="stringliteral">"  ["</span>);
00312         *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
00313         <span class="keywordflow">for</span> (tp = cp2; tp &lt; cp; tp++) {
00314             sprint_char((<span class="keywordtype">char</span> *) (*buf + *out_len), *tp);
00315             (*out_len)++;
00316         }
00317         sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class="stringliteral">"]"</span>);
00318         *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
00319     }
00320     *(*buf + (*out_len)++) = <span class="charliteral">'\n'</span>;
00321     *(*buf + *out_len) = 0;
00322     <span class="keywordflow">return</span> 1;
00323 }
00324 
00325 <span class="keywordtype">int</span>
00326 sprint_realloc_hexstring(u_char ** buf, size_t * buf_len, size_t * out_len,
00327                          <span class="keywordtype">int</span> allow_realloc, <span class=
"keyword">const</span> u_char * cp, size_t len)
00328 {
00329     <span class="keywordtype">int</span> line_len = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID,
00330                                       NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH);
00331     <span class="keywordflow">if</span> (!line_len)
00332         line_len=len;
00333 
00334     <span class="keywordflow">for</span> (; (int)len &gt; line_len; len -= line_len) {
00335         <a class="code" href=
"group__mib__utilities.html#ga25">_sprint_hexstring_line</a>(buf, buf_len, out_len, allow_realloc, cp, line_len);
00336         cp += line_len;
00337     }
00338     <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga25">_sprint_hexstring_line</a>(buf, buf_len, out_len, allow_realloc, cp, len);
00339 }
00340 
00341 
00342 
00362 <span class="keywordtype">int</span>
<a name="l00363" id="l00363"></a><a class="code" href="group__mib__utilities.html#ga27">00363</a> <a class="code" href=
"group__mib__utilities.html#ga27">sprint_realloc_asciistring</a>(u_char ** buf, size_t * buf_len,
00364                            size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
00365                            <span class="keyword">const</span> u_char * cp, size_t len)
00366 {
00367     <span class="keywordtype">int</span>             i;
00368 
00369     <span class="keywordflow">for</span> (i = 0; i &lt; (int) len; i++) {
00370         <span class="keywordflow">if</span> (isprint(*cp)) {
00371             <span class="keywordflow">if</span> (*cp == <span class="charliteral">'\\'</span> || *cp == <span class=
"charliteral">'"'</span>) {
00372                 <span class="keywordflow">if</span> ((*out_len &gt;= *buf_len) &amp;&amp;
00373                     !(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00374                     <span class="keywordflow">return</span> 0;
00375                 }
00376                 *(*buf + (*out_len)++) = <span class="charliteral">'\\'</span>;
00377             }
00378             <span class="keywordflow">if</span> ((*out_len &gt;= *buf_len) &amp;&amp;
00379                 !(allow_realloc &amp;&amp; <a class="code" href="group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00380                 <span class="keywordflow">return</span> 0;
00381             }
00382             *(*buf + (*out_len)++) = *cp++;
00383         } <span class="keywordflow">else</span> {
00384             <span class="keywordflow">if</span> ((*out_len &gt;= *buf_len) &amp;&amp;
00385                 !(allow_realloc &amp;&amp; <a class="code" href="group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00386                 <span class="keywordflow">return</span> 0;
00387             }
00388             *(*buf + (*out_len)++) = <span class="charliteral">'.'</span>;
00389             cp++;
00390         }
00391     }
00392     <span class="keywordflow">if</span> ((*out_len &gt;= *buf_len) &amp;&amp;
00393         !(allow_realloc &amp;&amp; <a class="code" href="group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00394         <span class="keywordflow">return</span> 0;
00395     }
00396     *(*buf + *out_len) = <span class="charliteral">'\0'</span>;
00397     <span class="keywordflow">return</span> 1;
00398 }
00399 
00422 <span class="keywordtype">int</span>
<a name="l00423" id="l00423"></a><a class="code" href="group__mib__utilities.html#ga28">00423</a> <a class="code" href=
"group__mib__utilities.html#ga28">sprint_realloc_octet_string</a>(u_char ** buf, size_t * buf_len,
00424                             size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
00425                             <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
00426                             <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums, <span class="keyword">const</span> <span class="keywordtype">char</span> *hint,
00427                             <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
00428 {
00429     size_t          saved_out_len = *out_len;
00430     <span class="keyword">const</span> <span class="keywordtype">char</span>     *saved_hint = hint;
00431     <span class="keywordtype">int</span>             hex = 0, x = 0;
00432     u_char         *cp;
00433     <span class="keywordtype">int</span>             output_format;
00434 
00435     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OCTET_STR) &amp;&amp; 
00436         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
00437         <span class="keyword">const</span> <span class="keywordtype">char</span>      str[] = <span class=
"stringliteral">"Wrong Type (should be OCTET STRING): "</span>;
00438         <span class="keywordflow">if</span> (snmp_strcat
00439             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) str)) {
00440             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
00441                                           allow_realloc, var, NULL, NULL,
00442                                           NULL);
00443         } <span class="keywordflow">else</span> {
00444             <span class="keywordflow">return</span> 0;
00445         }
00446     }
00447 
00448 
00449     <span class="keywordflow">if</span> (hint) {
00450         <span class="keywordtype">int</span>             repeat, width = 1;
00451         <span class="keywordtype">long</span>            value;
00452         <span class="keywordtype">char</span>            code = <span class=
"charliteral">'d'</span>, separ = 0, term = 0, ch, intbuf[16];
00453         u_char         *ecp;
00454 
00455         <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00456             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
00457                              (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"STRING: "</span>)) {
00458                 <span class="keywordflow">return</span> 0;
00459             }
00460         }
00461         cp = var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string;
00462         ecp = cp + var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>;
00463 
00464         <span class="keywordflow">while</span> (cp &lt; ecp) {
00465             repeat = 1;
00466             <span class="keywordflow">if</span> (*hint) {
00467                 <span class="keywordflow">if</span> (*hint == <span class="charliteral">'*'</span>) {
00468                     repeat = *cp++;
00469                     hint++;
00470                 }
00471                 width = 0;
00472                 <span class="keywordflow">while</span> (<span class=
"charliteral">'0'</span> &lt;= *hint &amp;&amp; *hint &lt;= <span class="charliteral">'9'</span>)
00473                     width = (width * 10) + (*hint++ - <span class="charliteral">'0'</span>);
00474                 code = *hint++;
00475                 <span class="keywordflow">if</span> ((ch = *hint) &amp;&amp; ch != <span class=
"charliteral">'*'</span> &amp;&amp; (ch &lt; '0' || ch &gt; <span class="charliteral">'9'</span>)
00476                     &amp;&amp; (width != 0
00477                         || (ch != <span class="charliteral">'x'</span> &amp;&amp; ch != <span class=
"charliteral">'d'</span> &amp;&amp; ch != <span class="charliteral">'o'</span>)))
00478                     separ = *hint++;
00479                 <span class="keywordflow">else</span>
00480                     separ = 0;
00481                 <span class="keywordflow">if</span> ((ch = *hint) &amp;&amp; ch != <span class=
"charliteral">'*'</span> &amp;&amp; (ch &lt; '0' || ch &gt; <span class="charliteral">'9'</span>)
00482                     &amp;&amp; (width != 0
00483                         || (ch != <span class="charliteral">'x'</span> &amp;&amp; ch != <span class=
"charliteral">'d'</span> &amp;&amp; ch != <span class="charliteral">'o'</span>)))
00484                     term = *hint++;
00485                 <span class="keywordflow">else</span>
00486                     term = 0;
00487                 <span class="keywordflow">if</span> (width == 0)
00488                     width = 1;
00489             }
00490 
00491             <span class="keywordflow">while</span> (repeat &amp;&amp; cp &lt; ecp) {
00492                 value = 0;
00493                 <span class="keywordflow">if</span> (code != <span class=
"charliteral">'a'</span> &amp;&amp; code != <span class="charliteral">'t'</span>) {
00494                     <span class="keywordflow">for</span> (x = 0; x &lt; width; x++) {
00495                         value = value * 256 + *cp++;
00496                     }
00497                 }
00498                 <span class="keywordflow">switch</span> (code) {
00499                 <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
00500                     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
00501                                                NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT)
00502                                        &amp;&amp; value &lt; 16) {
00503                         sprintf(intbuf, <span class="stringliteral">"0%lx"</span>, value);
00504                     } <span class="keywordflow">else</span> {
00505                         sprintf(intbuf, <span class="stringliteral">"%lx"</span>, value);
00506                     }
00507                     <span class="keywordflow">if</span> (!snmp_strcat
00508                         (buf, buf_len, out_len, allow_realloc,
00509                          (u_char *) intbuf)) {
00510                         <span class="keywordflow">return</span> 0;
00511                     }
00512                     <span class="keywordflow">break</span>;
00513                 <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
00514                     sprintf(intbuf, <span class="stringliteral">"%ld"</span>, value);
00515                     <span class="keywordflow">if</span> (!snmp_strcat
00516                         (buf, buf_len, out_len, allow_realloc,
00517                          (u_char *) intbuf)) {
00518                         <span class="keywordflow">return</span> 0;
00519                     }
00520                     <span class="keywordflow">break</span>;
00521                 <span class="keywordflow">case</span> <span class="charliteral">'o'</span>:
00522                     sprintf(intbuf, <span class="stringliteral">"%lo"</span>, value);
00523                     <span class="keywordflow">if</span> (!snmp_strcat
00524                         (buf, buf_len, out_len, allow_realloc,
00525                          (u_char *) intbuf)) {
00526                         <span class="keywordflow">return</span> 0;
00527                     }
00528                     <span class="keywordflow">break</span>;
00529                 <span class="keywordflow">case</span> <span class="charliteral">'t'</span>: <span class=
"comment">/* new in rfc 3411 */</span>
00530                 <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
00531                     <span class="keywordflow">while</span> ((*out_len + width + 1) &gt;= *buf_len) {
00532                         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00533                             <span class="keywordflow">return</span> 0;
00534                         }
00535                     }
00536                     <span class="keywordflow">for</span> (x = 0; x &lt; width &amp;&amp; cp &lt; ecp; x++) {
00537                         *(*buf + *out_len) = *cp++;
00538                         (*out_len)++;
00539                     }
00540                     *(*buf + *out_len) = <span class="charliteral">'\0'</span>;
00541                     <span class="keywordflow">break</span>;
00542                 <span class="keywordflow">default</span>:
00543                     *out_len = saved_out_len;
00544                     <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc,
00545                                     (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"(Bad hint ignored: "</span>)
00546                         &amp;&amp; snmp_strcat(buf, buf_len, out_len,
00547                                        allow_realloc,
00548                                        (<span class="keyword">const</span> u_char *) saved_hint)
00549                         &amp;&amp; snmp_strcat(buf, buf_len, out_len,
00550                                        allow_realloc,
00551                                        (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">") "</span>)) {
00552                         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga28">sprint_realloc_octet_string</a>(buf, buf_len,
00553                                                            out_len,
00554                                                            allow_realloc,
00555                                                            var, enums,
00556                                                            NULL, NULL);
00557                     } <span class="keywordflow">else</span> {
00558                         <span class="keywordflow">return</span> 0;
00559                     }
00560                 }
00561 
00562                 <span class="keywordflow">if</span> (cp &lt; ecp &amp;&amp; separ) {
00563                     <span class="keywordflow">while</span> ((*out_len + 1) &gt;= *buf_len) {
00564                         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00565                             <span class="keywordflow">return</span> 0;
00566                         }
00567                     }
00568                     *(*buf + *out_len) = separ;
00569                     (*out_len)++;
00570                     *(*buf + *out_len) = <span class="charliteral">'\0'</span>;
00571                 }
00572                 repeat--;
00573             }
00574 
00575             <span class="keywordflow">if</span> (term &amp;&amp; cp &lt; ecp) {
00576                 <span class="keywordflow">while</span> ((*out_len + 1) &gt;= *buf_len) {
00577                     <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00578                         <span class="keywordflow">return</span> 0;
00579                     }
00580                 }
00581                 *(*buf + *out_len) = term;
00582                 (*out_len)++;
00583                 *(*buf + *out_len) = <span class="charliteral">'\0'</span>;
00584             }
00585         }
00586 
00587         <span class="keywordflow">if</span> (units) {
00588             <span class="keywordflow">return</span> (snmp_strcat
00589                     (buf, buf_len, out_len, allow_realloc,
00590                      (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
00591                     &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
00592                                    (<span class="keyword">const</span> u_char *) units));
00593         }
00594         <span class="keywordflow">if</span> ((*out_len &gt;= *buf_len) &amp;&amp;
00595             !(allow_realloc &amp;&amp; <a class="code" href="group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00596             <span class="keywordflow">return</span> 0;
00597         }
00598         *(*buf + *out_len) = <span class="charliteral">'\0'</span>;
00599 
00600         <span class="keywordflow">return</span> 1;
00601     }
00602 
00603     output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT);
00604     <span class="keywordflow">if</span> (0 == output_format) {
00605         output_format = NETSNMP_STRING_OUTPUT_GUESS;
00606     }
00607     <span class="keywordflow">switch</span> (output_format) {
00608     <span class="keywordflow">case</span> NETSNMP_STRING_OUTPUT_GUESS:
00609         hex = 0;
00610         <span class="keywordflow">for</span> (cp = var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string, x = 0; x &lt; (int) var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>; x++, cp++) {
00611             <span class="keywordflow">if</span> (!isprint(*cp) &amp;&amp; !isspace(*cp)) {
00612                 hex = 1;
00613             }
00614         }
00615         <span class="keywordflow">break</span>;
00616 
00617     <span class="keywordflow">case</span> NETSNMP_STRING_OUTPUT_ASCII:
00618         hex = 0;
00619         <span class="keywordflow">break</span>;
00620 
00621     <span class="keywordflow">case</span> NETSNMP_STRING_OUTPUT_HEX:
00622         hex = 1;
00623         <span class="keywordflow">break</span>;
00624     }
00625 
00626     <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> == 0) {
00627         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
00628                            (<span class="keyword">const</span> u_char *) <span class="stringliteral">"\"\""</span>);
00629     }
00630 
00631     <span class="keywordflow">if</span> (hex) {
00632         <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00633             <span class="keywordflow">if</span> (!snmp_strcat
00634                 (buf, buf_len, out_len, allow_realloc,
00635                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"\""</span>)) {
00636                 <span class="keywordflow">return</span> 0;
00637             }
00638         } <span class="keywordflow">else</span> {
00639             <span class="keywordflow">if</span> (!snmp_strcat
00640                 (buf, buf_len, out_len, allow_realloc,
00641                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"Hex-STRING: "</span>)) {
00642                 <span class="keywordflow">return</span> 0;
00643             }
00644         }
00645 
00646         <span class="keywordflow">if</span> (!sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,
00647                                       var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string, var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>)) {
00648             <span class="keywordflow">return</span> 0;
00649         }
00650 
00651         <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00652             <span class="keywordflow">if</span> (!snmp_strcat
00653                 (buf, buf_len, out_len, allow_realloc,
00654                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"\""</span>)) {
00655                 <span class="keywordflow">return</span> 0;
00656             }
00657         }
00658     } <span class="keywordflow">else</span> {
00659         <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00660             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
00661                              (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"STRING: "</span>)) {
00662                 <span class="keywordflow">return</span> 0;
00663             }
00664         }
00665         <span class="keywordflow">if</span> (!snmp_strcat
00666             (buf, buf_len, out_len, allow_realloc,
00667              (<span class="keyword">const</span> u_char *) <span class="stringliteral">"\""</span>)) {
00668             <span class="keywordflow">return</span> 0;
00669         }
00670         <span class="keywordflow">if</span> (!<a class="code" href=
"group__mib__utilities.html#ga27">sprint_realloc_asciistring</a>
00671             (buf, buf_len, out_len, allow_realloc, var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string,
00672              var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>)) {
00673             <span class="keywordflow">return</span> 0;
00674         }
00675         <span class="keywordflow">if</span> (!snmp_strcat
00676             (buf, buf_len, out_len, allow_realloc,
00677              (<span class="keyword">const</span> u_char *) <span class="stringliteral">"\""</span>)) {
00678             <span class="keywordflow">return</span> 0;
00679         }
00680     }
00681 
00682     <span class="keywordflow">if</span> (units) {
00683         <span class="keywordflow">return</span> (snmp_strcat
00684                 (buf, buf_len, out_len, allow_realloc,
00685                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
00686                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
00687                                (<span class="keyword">const</span> u_char *) units));
00688     }
00689     <span class="keywordflow">return</span> 1;
00690 }
00691 
00692 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00693 
00716 <span class="keywordtype">int</span>
00717 sprint_realloc_float(u_char ** buf, size_t * buf_len,
00718                      size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
00719                      <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
00720                      <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
00721                      <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
00722 {
00723     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE_FLOAT) &amp;&amp;
00724         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
00725         u_char          str[] = <span class="stringliteral">"Wrong Type (should be Float): "</span>;
00726         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
00727             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
00728                                           allow_realloc, var, NULL, NULL,
00729                                           NULL);
00730         } <span class="keywordflow">else</span> {
00731             <span class="keywordflow">return</span> 0;
00732         }
00733     }
00734 
00735     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00736         <span class="keywordflow">if</span> (!snmp_strcat
00737             (buf, buf_len, out_len, allow_realloc,
00738              (<span class="keyword">const</span> u_char *) <span class="stringliteral">"Opaque: Float: "</span>)) {
00739             <span class="keywordflow">return</span> 0;
00740         }
00741     }
00742 
00743 
00744     <span class="comment">/*</span>
00745 <span class="comment">     * How much space needed for max. length float?  128 is overkill.  </span>
00746 <span class="comment">     */</span>
00747 
00748     <span class="keywordflow">while</span> ((*out_len + 128 + 1) &gt;= *buf_len) {
00749         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00750             <span class="keywordflow">return</span> 0;
00751         }
00752     }
00753 
00754     sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class=
"stringliteral">"%f"</span>, *var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.floatVal);
00755     *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
00756 
00757     <span class="keywordflow">if</span> (units) {
00758         <span class="keywordflow">return</span> (snmp_strcat
00759                 (buf, buf_len, out_len, allow_realloc,
00760                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
00761                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
00762                                (<span class="keyword">const</span> u_char *) units));
00763     }
00764     <span class="keywordflow">return</span> 1;
00765 }
00766 
00767 
00790 <span class="keywordtype">int</span>
00791 sprint_realloc_double(u_char ** buf, size_t * buf_len,
00792                       size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
00793                       <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
00794                       <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
00795                       <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
00796 {
00797     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE_DOUBLE) &amp;&amp; 
00798         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
00799         <span class="keyword">const</span> <span class="keywordtype">char</span>      str[] = <span class=
"stringliteral">"Wrong Type (should be Double): "</span>;
00800         <span class="keywordflow">if</span> (snmp_strcat
00801             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) str)) {
00802             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
00803                                           allow_realloc, var, NULL, NULL,
00804                                           NULL);
00805         } <span class="keywordflow">else</span> {
00806             <span class="keywordflow">return</span> 0;
00807         }
00808     }
00809 
00810     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00811         <span class="keywordflow">if</span> (!snmp_strcat
00812             (buf, buf_len, out_len, allow_realloc,
00813              (<span class="keyword">const</span> u_char *) <span class="stringliteral">"Opaque: Float: "</span>)) {
00814             <span class="keywordflow">return</span> 0;
00815         }
00816     }
00817 
00818     <span class="comment">/*</span>
00819 <span class="comment">     * How much space needed for max. length double?  128 is overkill.  </span>
00820 <span class="comment">     */</span>
00821 
00822     <span class="keywordflow">while</span> ((*out_len + 128 + 1) &gt;= *buf_len) {
00823         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00824             <span class="keywordflow">return</span> 0;
00825         }
00826     }
00827 
00828     sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class=
"stringliteral">"%f"</span>, *var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.doubleVal);
00829     *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
00830 
00831     <span class="keywordflow">if</span> (units) {
00832         <span class="keywordflow">return</span> (snmp_strcat
00833                 (buf, buf_len, out_len, allow_realloc,
00834                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
00835                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
00836                                (<span class="keyword">const</span> u_char *) units));
00837     }
00838     <span class="keywordflow">return</span> 1;
00839 }
00840 
00841 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
00842 
00843 
00866 <span class="keywordtype">int</span>
<a name="l00867" id="l00867"></a><a class="code" href="group__mib__utilities.html#ga29">00867</a> <a class="code" href=
"group__mib__utilities.html#ga29">sprint_realloc_counter64</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
00868                          <span class="keywordtype">int</span> allow_realloc,
00869                          <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
00870                          <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
00871                          <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
00872 {
00873     <span class="keywordtype">char</span>            a64buf[I64CHARSZ + 1];
00874 
00875     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_COUNTER64
00876 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00877         &amp;&amp; var-&gt;<a class="code" href="structvariable__list.html#o3">type</a> != ASN_OPAQUE_COUNTER64
00878         &amp;&amp; var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE_I64 &amp;&amp; var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE_U64
00879 <span class="preprocessor">#endif</span>
00880         ) &amp;&amp; (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
00881         u_char          str[] = <span class="stringliteral">"Wrong Type (should be Counter64): "</span>;
00882         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
00883             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
00884                                           allow_realloc, var, NULL, NULL,
00885                                           NULL);
00886         } <span class="keywordflow">else</span> {
00887             <span class="keywordflow">return</span> 0;
00888         }
00889     }
00890 
00891     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00892 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00893         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_COUNTER64) {
00894             <span class="keywordflow">if</span> (!snmp_strcat
00895                 (buf, buf_len, out_len, allow_realloc,
00896                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"Opaque: "</span>)) {
00897                 <span class="keywordflow">return</span> 0;
00898             }
00899         }
00900 <span class="preprocessor">#endif</span>
00901 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00902         <span class="keywordflow">switch</span> (var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>) {
00903         <span class="keywordflow">case</span> ASN_OPAQUE_U64:
00904             <span class="keywordflow">if</span> (!snmp_strcat
00905                 (buf, buf_len, out_len, allow_realloc,
00906                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"UInt64: "</span>)) {
00907                 <span class="keywordflow">return</span> 0;
00908             }
00909             <span class="keywordflow">break</span>;
00910         <span class="keywordflow">case</span> ASN_OPAQUE_I64:
00911             <span class="keywordflow">if</span> (!snmp_strcat
00912                 (buf, buf_len, out_len, allow_realloc,
00913                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"Int64: "</span>)) {
00914                 <span class="keywordflow">return</span> 0;
00915             }
00916             <span class="keywordflow">break</span>;
00917         <span class="keywordflow">case</span> ASN_COUNTER64:
00918         <span class="keywordflow">case</span> ASN_OPAQUE_COUNTER64:
00919 <span class="preprocessor">#endif</span>
00920             <span class="keywordflow">if</span> (!snmp_strcat
00921                 (buf, buf_len, out_len, allow_realloc,
00922                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"Counter64: "</span>)) {
00923                 <span class="keywordflow">return</span> 0;
00924             }
00925 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00926         }
00927 <span class="preprocessor">#endif</span>
00928     }
00929 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00930     <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == ASN_OPAQUE_I64) {
00931         printI64(a64buf, var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.counter64);
00932         <span class="keywordflow">if</span> (!snmp_strcat
00933             (buf, buf_len, out_len, allow_realloc,
00934              (<span class="keyword">const</span> u_char *) a64buf)) {
00935             <span class="keywordflow">return</span> 0;
00936         }
00937     } <span class="keywordflow">else</span> {
00938 <span class="preprocessor">#endif</span>
00939         printU64(a64buf, var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.counter64);
00940         <span class="keywordflow">if</span> (!snmp_strcat
00941             (buf, buf_len, out_len, allow_realloc,
00942              (<span class="keyword">const</span> u_char *) a64buf)) {
00943             <span class="keywordflow">return</span> 0;
00944         }
00945 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00946     }
00947 <span class="preprocessor">#endif</span>
00948 
00949     <span class="keywordflow">if</span> (units) {
00950         <span class="keywordflow">return</span> (snmp_strcat
00951                 (buf, buf_len, out_len, allow_realloc,
00952                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
00953                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
00954                                (<span class="keyword">const</span> u_char *) units));
00955     }
00956     <span class="keywordflow">return</span> 1;
00957 }
00958 
00959 
00980 <span class="keywordtype">int</span>
<a name="l00981" id="l00981"></a><a class="code" href="group__mib__utilities.html#ga30">00981</a> <a class="code" href=
"group__mib__utilities.html#ga30">sprint_realloc_opaque</a>(u_char ** buf, size_t * buf_len,
00982                       size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
00983                       <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
00984                       <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
00985                       <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
00986 {
00987     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE
00988 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00989         &amp;&amp; var-&gt;<a class="code" href="structvariable__list.html#o3">type</a> != ASN_OPAQUE_COUNTER64
00990         &amp;&amp; var-&gt;<a class="code" href="structvariable__list.html#o3">type</a> != ASN_OPAQUE_U64
00991         &amp;&amp; var-&gt;<a class="code" href="structvariable__list.html#o3">type</a> != ASN_OPAQUE_I64
00992         &amp;&amp; var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE_FLOAT &amp;&amp; var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE_DOUBLE
00993 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
00994         ) &amp;&amp; (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
00995         u_char          str[] = <span class="stringliteral">"Wrong Type (should be Opaque): "</span>;
00996         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
00997             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
00998                                           allow_realloc, var, NULL, NULL,
00999                                           NULL);
01000         } <span class="keywordflow">else</span> {
01001             <span class="keywordflow">return</span> 0;
01002         }
01003     }
01004 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
01005     <span class="keywordflow">switch</span> (var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>) {
01006     <span class="keywordflow">case</span> ASN_OPAQUE_COUNTER64:
01007     <span class="keywordflow">case</span> ASN_OPAQUE_U64:
01008     <span class="keywordflow">case</span> ASN_OPAQUE_I64:
01009         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga29">sprint_realloc_counter64</a>(buf, buf_len, out_len,
01010                                         allow_realloc, var, enums, hint,
01011                                         units);
01012         <span class="keywordflow">break</span>;
01013 
01014     <span class="keywordflow">case</span> ASN_OPAQUE_FLOAT:
01015         <span class="keywordflow">return</span> sprint_realloc_float(buf, buf_len, out_len, allow_realloc,
01016                                     var, enums, hint, units);
01017         <span class="keywordflow">break</span>;
01018 
01019     <span class="keywordflow">case</span> ASN_OPAQUE_DOUBLE:
01020         <span class="keywordflow">return</span> sprint_realloc_double(buf, buf_len, out_len, allow_realloc,
01021                                      var, enums, hint, units);
01022         <span class="keywordflow">break</span>;
01023 
01024     <span class="keywordflow">case</span> ASN_OPAQUE:
01025 <span class="preprocessor">#endif</span>
01026         <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01027             u_char          str[] = <span class="stringliteral">"OPAQUE: "</span>;
01028             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01029                 <span class="keywordflow">return</span> 0;
01030             }
01031         }
01032         <span class="keywordflow">if</span> (!sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,
01033                                       var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string, var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>)) {
01034             <span class="keywordflow">return</span> 0;
01035         }
01036 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
01037     }
01038 <span class="preprocessor">#endif</span>
01039     <span class="keywordflow">if</span> (units) {
01040         <span class="keywordflow">return</span> (snmp_strcat
01041                 (buf, buf_len, out_len, allow_realloc,
01042                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01043                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01044                                (<span class="keyword">const</span> u_char *) units));
01045     }
01046     <span class="keywordflow">return</span> 1;
01047 }
01048 
01049 
01070 <span class="keywordtype">int</span>
<a name="l01071" id="l01071"></a><a class="code" href="group__mib__utilities.html#ga31">01071</a> <a class="code" href=
"group__mib__utilities.html#ga31">sprint_realloc_object_identifier</a>(u_char ** buf, size_t * buf_len,
01072                                  size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
01073                                  <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01074                                  <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01075                                  <span class="keyword">const</span> <span class=
"keywordtype">char</span> *hint, <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
01076 {
01077     <span class="keywordtype">int</span>             buf_overflow = 0;
01078 
01079     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OBJECT_ID) &amp;&amp;
01080         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01081         u_char          str[] =
01082             <span class="stringliteral">"Wrong Type (should be OBJECT IDENTIFIER): "</span>;
01083         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01084             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01085                                           allow_realloc, var, NULL, NULL,
01086                                           NULL);
01087         } <span class="keywordflow">else</span> {
01088             <span class="keywordflow">return</span> 0;
01089         }
01090     }
01091 
01092     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01093         u_char          str[] = <span class="stringliteral">"OID: "</span>;
01094         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01095             <span class="keywordflow">return</span> 0;
01096         }
01097     }
01098 
01099     netsnmp_sprint_realloc_objid_tree(buf, buf_len, out_len, allow_realloc,
01100                                       &amp;buf_overflow,
01101                                       (oid *) (var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid),
01102                                       var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> / <span class="keyword">sizeof</span>(oid));
01103 
01104     <span class="keywordflow">if</span> (buf_overflow) {
01105         <span class="keywordflow">return</span> 0;
01106     }
01107 
01108     <span class="keywordflow">if</span> (units) {
01109         <span class="keywordflow">return</span> (snmp_strcat
01110                 (buf, buf_len, out_len, allow_realloc,
01111                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01112                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01113                                (<span class="keyword">const</span> u_char *) units));
01114     }
01115     <span class="keywordflow">return</span> 1;
01116 }
01117 
01118 
01119 
01140 <span class="keywordtype">int</span>
<a name="l01141" id="l01141"></a><a class="code" href="group__mib__utilities.html#ga32">01141</a> <a class="code" href=
"group__mib__utilities.html#ga32">sprint_realloc_timeticks</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01142                          <span class="keywordtype">int</span> allow_realloc,
01143                          <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01144                          <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01145                          <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01146 {
01147     <span class="keywordtype">char</span>            timebuf[40];
01148 
01149     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_TIMETICKS) &amp;&amp; 
01150         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01151         u_char          str[] = <span class="stringliteral">"Wrong Type (should be Timeticks): "</span>;
01152         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01153             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01154                                           allow_realloc, var, NULL, NULL,
01155                                           NULL);
01156         } <span class="keywordflow">else</span> {
01157             <span class="keywordflow">return</span> 0;
01158         }
01159     }
01160 
01161     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS)) {
01162         <span class="keywordtype">char</span>            str[16];
01163         sprintf(str, <span class="stringliteral">"%lu"</span>, *(u_long *) var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01164         <span class="keywordflow">if</span> (!snmp_strcat
01165             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) str)) {
01166             <span class="keywordflow">return</span> 0;
01167         }
01168         <span class="keywordflow">return</span> 1;
01169     }
01170     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01171         <span class="keywordtype">char</span>            str[32];
01172         sprintf(str, <span class="stringliteral">"Timeticks: (%lu) "</span>, *(u_long *) var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01173         <span class="keywordflow">if</span> (!snmp_strcat
01174             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) str)) {
01175             <span class="keywordflow">return</span> 0;
01176         }
01177     }
01178     uptimeString(*(u_long *) (var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.integer), timebuf);
01179     <span class="keywordflow">if</span> (!snmp_strcat
01180         (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) timebuf)) {
01181         <span class="keywordflow">return</span> 0;
01182     }
01183     <span class="keywordflow">if</span> (units) {
01184         <span class="keywordflow">return</span> (snmp_strcat
01185                 (buf, buf_len, out_len, allow_realloc,
01186                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01187                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01188                                (<span class="keyword">const</span> u_char *) units));
01189     }
01190     <span class="keywordflow">return</span> 1;
01191 }
01192 
01193 
01214 <span class="keywordtype">int</span>
<a name="l01215" id="l01215"></a><a class="code" href="group__mib__utilities.html#ga33">01215</a> <a class="code" href=
"group__mib__utilities.html#ga33">sprint_realloc_hinted_integer</a>(u_char ** buf, size_t * buf_len,
01216                               size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
01217                               <span class="keywordtype">long</span> val, <span class="keyword">const</span> <span class=
"keywordtype">char</span> decimaltype,
01218                               <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01219 {
01220     <span class="keywordtype">char</span>            fmt[10] = <span class="stringliteral">"%l@"</span>, tmp[256];
01221     <span class="keywordtype">int</span>             shift, len;
01222 
01223     <span class="keywordflow">if</span> (hint[1] == <span class="charliteral">'-'</span>) {
01224         shift = atoi(hint + 2);
01225     } <span class="keywordflow">else</span> {
01226         shift = 0;
01227     }
01228 
01229     <span class="keywordflow">if</span> (hint[0] == <span class="charliteral">'d'</span>) {
01230         <span class="comment">/*</span>
01231 <span class="comment">         * We might *actually* want a 'u' here.  </span>
01232 <span class="comment">         */</span>
01233         fmt[2] = decimaltype;
01234     } <span class="keywordflow">else</span> {
01235         <span class="comment">/*</span>
01236 <span class="comment">         * DISPLAY-HINT character is 'b', 'o', or 'x'.  </span>
01237 <span class="comment">         */</span>
01238         fmt[2] = hint[0];
01239     }
01240 
01241     sprintf(tmp, fmt, val);
01242     <span class="keywordflow">if</span> (shift != 0) {
01243         len = strlen(tmp);
01244         <span class="keywordflow">if</span> (shift &lt;= len) {
01245             tmp[len + 1] = 0;
01246             <span class="keywordflow">while</span> (shift--) {
01247                 tmp[len] = tmp[len - 1];
01248                 len--;
01249             }
01250             tmp[len] = <span class="charliteral">'.'</span>;
01251         } <span class="keywordflow">else</span> {
01252             tmp[shift + 1] = 0;
01253             <span class="keywordflow">while</span> (shift) {
01254                 <span class="keywordflow">if</span> (len-- &gt; 0) {
01255                     tmp[shift] = tmp[len];
01256                 } <span class="keywordflow">else</span> {
01257                     tmp[shift] = <span class="charliteral">'0'</span>;
01258                 }
01259                 shift--;
01260             }
01261             tmp[0] = <span class="charliteral">'.'</span>;
01262         }
01263     }
01264     <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc, tmp);
01265 }
01266 
01267 
01288 <span class="keywordtype">int</span>
<a name="l01289" id="l01289"></a><a class="code" href="group__mib__utilities.html#ga34">01289</a> <a class="code" href=
"group__mib__utilities.html#ga34">sprint_realloc_integer</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01290                        <span class="keywordtype">int</span> allow_realloc,
01291                        <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01292                        <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01293                        <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01294 {
01295     <span class="keywordtype">char</span>           *enum_string = NULL;
01296 
01297     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_INTEGER) &amp;&amp; 
01298         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01299         u_char          str[] = <span class="stringliteral">"Wrong Type (should be INTEGER): "</span>;
01300         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01301             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01302                                           allow_realloc, var, NULL, NULL,
01303                                           NULL);
01304         } <span class="keywordflow">else</span> {
01305             <span class="keywordflow">return</span> 0;
01306         }
01307     }
01308     <span class="keywordflow">for</span> (; enums; enums = enums-&gt;next) {
01309         <span class="keywordflow">if</span> (enums-&gt;value == *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer) {
01310             enum_string = enums-&gt;label;
01311             <span class="keywordflow">break</span>;
01312         }
01313     }
01314 
01315     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01316         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
01317                          (<span class="keyword">const</span> u_char *) <span class="stringliteral">"INTEGER: "</span>)) {
01318             <span class="keywordflow">return</span> 0;
01319         }
01320     }
01321 
01322     <span class="keywordflow">if</span> (enum_string == NULL ||
01323         netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM)) {
01324         <span class="keywordflow">if</span> (hint) {
01325             <span class="keywordflow">if</span> (!(<a class="code" href=
"group__mib__utilities.html#ga33">sprint_realloc_hinted_integer</a>(buf, buf_len, out_len,
01326                                                 allow_realloc,
01327                                                 *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer, <span class="charliteral">'d'</span>,
01328                                                 hint, units))) {
01329                 <span class="keywordflow">return</span> 0;
01330             }
01331         } <span class="keywordflow">else</span> {
01332             <span class="keywordtype">char</span>            str[16];
01333             sprintf(str, <span class="stringliteral">"%ld"</span>, *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01334             <span class="keywordflow">if</span> (!snmp_strcat
01335                 (buf, buf_len, out_len, allow_realloc,
01336                  (<span class="keyword">const</span> u_char *) str)) {
01337                 <span class="keywordflow">return</span> 0;
01338             }
01339         }
01340     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01341         <span class="keywordflow">if</span> (!snmp_strcat
01342             (buf, buf_len, out_len, allow_realloc,
01343              (<span class="keyword">const</span> u_char *) enum_string)) {
01344             <span class="keywordflow">return</span> 0;
01345         }
01346     } <span class="keywordflow">else</span> {
01347         <span class="keywordtype">char</span>            str[16];
01348         sprintf(str, <span class="stringliteral">"(%ld)"</span>, *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01349         <span class="keywordflow">if</span> (!snmp_strcat
01350             (buf, buf_len, out_len, allow_realloc,
01351              (<span class="keyword">const</span> u_char *) enum_string)) {
01352             <span class="keywordflow">return</span> 0;
01353         }
01354         <span class="keywordflow">if</span> (!snmp_strcat
01355             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) str)) {
01356             <span class="keywordflow">return</span> 0;
01357         }
01358     }
01359 
01360     <span class="keywordflow">if</span> (units) {
01361         <span class="keywordflow">return</span> (snmp_strcat
01362                 (buf, buf_len, out_len, allow_realloc,
01363                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01364                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01365                                (<span class="keyword">const</span> u_char *) units));
01366     }
01367     <span class="keywordflow">return</span> 1;
01368 }
01369 
01370 
01391 <span class="keywordtype">int</span>
<a name="l01392" id="l01392"></a><a class="code" href="group__mib__utilities.html#ga35">01392</a> <a class="code" href=
"group__mib__utilities.html#ga35">sprint_realloc_uinteger</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01393                         <span class="keywordtype">int</span> allow_realloc,
01394                         <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01395                         <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01396                         <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01397 {
01398     <span class="keywordtype">char</span>           *enum_string = NULL;
01399 
01400     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_UINTEGER) &amp;&amp; 
01401         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01402         u_char          str[] = <span class="stringliteral">"Wrong Type (should be UInteger32): "</span>;
01403         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01404             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01405                                           allow_realloc, var, NULL, NULL,
01406                                           NULL);
01407         } <span class="keywordflow">else</span> {
01408             <span class="keywordflow">return</span> 0;
01409         }
01410     }
01411 
01412     <span class="keywordflow">for</span> (; enums; enums = enums-&gt;next) {
01413         <span class="keywordflow">if</span> (enums-&gt;value == *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer) {
01414             enum_string = enums-&gt;label;
01415             <span class="keywordflow">break</span>;
01416         }
01417     }
01418 
01419     <span class="keywordflow">if</span> (enum_string == NULL ||
01420         netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM)) {
01421         <span class="keywordflow">if</span> (hint) {
01422             <span class="keywordflow">if</span> (!(<a class="code" href=
"group__mib__utilities.html#ga33">sprint_realloc_hinted_integer</a>(buf, buf_len, out_len,
01423                                                 allow_realloc,
01424                                                 *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer, <span class="charliteral">'u'</span>,
01425                                                 hint, units))) {
01426                 <span class="keywordflow">return</span> 0;
01427             }
01428         } <span class="keywordflow">else</span> {
01429             <span class="keywordtype">char</span>            str[16];
01430             sprintf(str, <span class="stringliteral">"%lu"</span>, *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01431             <span class="keywordflow">if</span> (!snmp_strcat
01432                 (buf, buf_len, out_len, allow_realloc,
01433                  (<span class="keyword">const</span> u_char *) str)) {
01434                 <span class="keywordflow">return</span> 0;
01435             }
01436         }
01437     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01438         <span class="keywordflow">if</span> (!snmp_strcat
01439             (buf, buf_len, out_len, allow_realloc,
01440              (<span class="keyword">const</span> u_char *) enum_string)) {
01441             <span class="keywordflow">return</span> 0;
01442         }
01443     } <span class="keywordflow">else</span> {
01444         <span class="keywordtype">char</span>            str[16];
01445         sprintf(str, <span class="stringliteral">"(%lu)"</span>, *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01446         <span class="keywordflow">if</span> (!snmp_strcat
01447             (buf, buf_len, out_len, allow_realloc,
01448              (<span class="keyword">const</span> u_char *) enum_string)) {
01449             <span class="keywordflow">return</span> 0;
01450         }
01451         <span class="keywordflow">if</span> (!snmp_strcat
01452             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) str)) {
01453             <span class="keywordflow">return</span> 0;
01454         }
01455     }
01456 
01457     <span class="keywordflow">if</span> (units) {
01458         <span class="keywordflow">return</span> (snmp_strcat
01459                 (buf, buf_len, out_len, allow_realloc,
01460                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01461                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01462                                (<span class="keyword">const</span> u_char *) units));
01463     }
01464     <span class="keywordflow">return</span> 1;
01465 }
01466 
01467 
01488 <span class="keywordtype">int</span>
<a name="l01489" id="l01489"></a><a class="code" href="group__mib__utilities.html#ga36">01489</a> <a class="code" href=
"group__mib__utilities.html#ga36">sprint_realloc_gauge</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01490                      <span class="keywordtype">int</span> allow_realloc,
01491                      <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01492                      <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01493                      <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01494 {
01495     <span class="keywordtype">char</span>            tmp[32];
01496 
01497     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_GAUGE) &amp;&amp; 
01498         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01499         u_char          str[] =
01500             <span class="stringliteral">"Wrong Type (should be Gauge32 or Unsigned32): "</span>;
01501         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01502             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01503                                           allow_realloc, var, NULL, NULL,
01504                                           NULL);
01505         } <span class="keywordflow">else</span> {
01506             <span class="keywordflow">return</span> 0;
01507         }
01508     }
01509 
01510     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01511         u_char          str[] = <span class="stringliteral">"Gauge32: "</span>;
01512         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01513             <span class="keywordflow">return</span> 0;
01514         }
01515     }
01516     <span class="keywordflow">if</span> (hint) {
01517         <span class="keywordflow">if</span> (!<a class="code" href=
"group__mib__utilities.html#ga33">sprint_realloc_hinted_integer</a>(buf, buf_len, out_len,
01518                                            allow_realloc,
01519                                            *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer, <span class="charliteral">'u'</span>, hint,
01520                                            units)) {
01521             <span class="keywordflow">return</span> 0;
01522         }
01523     } <span class="keywordflow">else</span> {
01524         sprintf(tmp, <span class="stringliteral">"%lu"</span>, *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01525         <span class="keywordflow">if</span> (!snmp_strcat
01526             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) tmp)) {
01527             <span class="keywordflow">return</span> 0;
01528         }
01529     }
01530     <span class="keywordflow">if</span> (units) {
01531         <span class="keywordflow">return</span> (snmp_strcat
01532                 (buf, buf_len, out_len, allow_realloc,
01533                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01534                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01535                                (<span class="keyword">const</span> u_char *) units));
01536     }
01537     <span class="keywordflow">return</span> 1;
01538 }
01539 
01540 
01561 <span class="keywordtype">int</span>
<a name="l01562" id="l01562"></a><a class="code" href="group__mib__utilities.html#ga37">01562</a> <a class="code" href=
"group__mib__utilities.html#ga37">sprint_realloc_counter</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01563                        <span class="keywordtype">int</span> allow_realloc,
01564                        <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01565                        <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01566                        <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01567 {
01568     <span class="keywordtype">char</span>            tmp[32];
01569 
01570     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_COUNTER) &amp;&amp; 
01571         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01572         u_char          str[] = <span class="stringliteral">"Wrong Type (should be Counter32): "</span>;
01573         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01574             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01575                                           allow_realloc, var, NULL, NULL,
01576                                           NULL);
01577         } <span class="keywordflow">else</span> {
01578             <span class="keywordflow">return</span> 0;
01579         }
01580     }
01581 
01582     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01583         u_char          str[] = <span class="stringliteral">"Counter32: "</span>;
01584         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01585             <span class="keywordflow">return</span> 0;
01586         }
01587     }
01588     sprintf(tmp, <span class="stringliteral">"%lu"</span>, *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01589     <span class="keywordflow">if</span> (!snmp_strcat
01590         (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) tmp)) {
01591         <span class="keywordflow">return</span> 0;
01592     }
01593     <span class="keywordflow">if</span> (units) {
01594         <span class="keywordflow">return</span> (snmp_strcat
01595                 (buf, buf_len, out_len, allow_realloc,
01596                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01597                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01598                                (<span class="keyword">const</span> u_char *) units));
01599     }
01600     <span class="keywordflow">return</span> 1;
01601 }
01602 
01603 
01624 <span class="keywordtype">int</span>
<a name="l01625" id="l01625"></a><a class="code" href="group__mib__utilities.html#ga38">01625</a> <a class="code" href=
"group__mib__utilities.html#ga38">sprint_realloc_networkaddress</a>(u_char ** buf, size_t * buf_len,
01626                               size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
01627                               <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01628                               <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums, <span class="keyword">const</span> <span class="keywordtype">char</span> *hint,
01629                               <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
01630 {
01631     size_t          i;
01632 
01633     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_IPADDRESS) &amp;&amp; 
01634         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01635         u_char          str[] = <span class="stringliteral">"Wrong Type (should be NetworkAddress): "</span>;
01636         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01637             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01638                                           allow_realloc, var, NULL, NULL,
01639                                           NULL);
01640         } <span class="keywordflow">else</span> {
01641             <span class="keywordflow">return</span> 0;
01642         }
01643     }
01644 
01645     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01646         u_char          str[] = <span class="stringliteral">"Network Address: "</span>;
01647         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01648             <span class="keywordflow">return</span> 0;
01649         }
01650     }
01651 
01652     <span class="keywordflow">while</span> ((*out_len + (var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> * 3) + 2) &gt;= *buf_len) {
01653         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
01654             <span class="keywordflow">return</span> 0;
01655         }
01656     }
01657 
01658     <span class="keywordflow">for</span> (i = 0; i &lt; var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>; i++) {
01659         sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class=
"stringliteral">"%02X"</span>, var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[i]);
01660         *out_len += 2;
01661         <span class="keywordflow">if</span> (i &lt; var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> - 1) {
01662             *(*buf + *out_len) = <span class="charliteral">':'</span>;
01663             (*out_len)++;
01664         }
01665     }
01666     <span class="keywordflow">return</span> 1;
01667 }
01668 
01669 
01690 <span class="keywordtype">int</span>
<a name="l01691" id="l01691"></a><a class="code" href="group__mib__utilities.html#ga39">01691</a> <a class="code" href=
"group__mib__utilities.html#ga39">sprint_realloc_ipaddress</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01692                          <span class="keywordtype">int</span> allow_realloc,
01693                          <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01694                          <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01695                          <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01696 {
01697     u_char         *ip = var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string;
01698 
01699     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_IPADDRESS) &amp;&amp; 
01700         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01701         u_char          str[] = <span class="stringliteral">"Wrong Type (should be IpAddress): "</span>;
01702         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01703             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01704                                           allow_realloc, var, NULL, NULL,
01705                                           NULL);
01706         } <span class="keywordflow">else</span> {
01707             <span class="keywordflow">return</span> 0;
01708         }
01709     }
01710 
01711     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01712         u_char          str[] = <span class="stringliteral">"IpAddress: "</span>;
01713         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01714             <span class="keywordflow">return</span> 0;
01715         }
01716     }
01717     <span class="keywordflow">while</span> ((*out_len + 17) &gt;= *buf_len) {
01718         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
01719             <span class="keywordflow">return</span> 0;
01720         }
01721     }
01722     <span class="keywordflow">if</span> (ip)
01723         sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class=
"stringliteral">"%d.%d.%d.%d"</span>,
01724                                             ip[0], ip[1], ip[2], ip[3]);
01725     *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
01726     <span class="keywordflow">return</span> 1;
01727 }
01728 
01729 
01750 <span class="keywordtype">int</span>
<a name="l01751" id="l01751"></a><a class="code" href="group__mib__utilities.html#ga40">01751</a> <a class="code" href=
"group__mib__utilities.html#ga40">sprint_realloc_null</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01752                     <span class="keywordtype">int</span> allow_realloc,
01753                     <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01754                     <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01755                     <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01756 {
01757     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_NULL) &amp;&amp; 
01758         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01759         u_char          str[] = <span class="stringliteral">"Wrong Type (should be NULL): "</span>;
01760         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01761             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01762                                           allow_realloc, var, NULL, NULL,
01763                                           NULL);
01764         } <span class="keywordflow">else</span> {
01765             <span class="keywordflow">return</span> 0;
01766         }
01767     } <span class="keywordflow">else</span> {
01768         u_char          str[] = <span class="stringliteral">"NULL"</span>;
01769         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc, str);
01770     }
01771 }
01772 
01773 
01794 <span class="keywordtype">int</span>
<a name="l01795" id="l01795"></a><a class="code" href="group__mib__utilities.html#ga41">01795</a> <a class="code" href=
"group__mib__utilities.html#ga41">sprint_realloc_bitstring</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01796                          <span class="keywordtype">int</span> allow_realloc,
01797                          <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01798                          <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01799                          <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01800 {
01801     <span class="keywordtype">int</span>             len, bit;
01802     u_char         *cp;
01803     <span class="keywordtype">char</span>           *enum_string;
01804 
01805     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_BIT_STR &amp;&amp; var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OCTET_STR) &amp;&amp;
01806         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01807         u_char          str[] = <span class="stringliteral">"Wrong Type (should be BITS): "</span>;
01808         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01809             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01810                                           allow_realloc, var, NULL, NULL,
01811                                           NULL);
01812         } <span class="keywordflow">else</span> {
01813             <span class="keywordflow">return</span> 0;
01814         }
01815     }
01816 
01817     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01818         u_char          str[] = <span class="stringliteral">"\""</span>;
01819         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01820             <span class="keywordflow">return</span> 0;
01821         }
01822     } <span class="keywordflow">else</span> {
01823         u_char          str[] = <span class="stringliteral">"BITS: "</span>;
01824         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01825             <span class="keywordflow">return</span> 0;
01826         }
01827     }
01828     <span class="keywordflow">if</span> (!sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,
01829                                   var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.bitstring, var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>)) {
01830         <span class="keywordflow">return</span> 0;
01831     }
01832 
01833     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01834         u_char          str[] = <span class="stringliteral">"\""</span>;
01835         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01836             <span class="keywordflow">return</span> 0;
01837         }
01838     } <span class="keywordflow">else</span> {
01839         cp = var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.bitstring;
01840         <span class="keywordflow">for</span> (len = 0; len &lt; (int) var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>; len++) {
01841             <span class="keywordflow">for</span> (bit = 0; bit &lt; 8; bit++) {
01842                 <span class="keywordflow">if</span> (*cp &amp; (0x80 &gt;&gt; bit)) {
01843                     enum_string = NULL;
01844                     <span class="keywordflow">for</span> (; enums; enums = enums-&gt;next) {
01845                         <span class="keywordflow">if</span> (enums-&gt;value == (len * 8) + bit) {
01846                             enum_string = enums-&gt;label;
01847                             <span class="keywordflow">break</span>;
01848                         }
01849                     }
01850                     <span class="keywordflow">if</span> (enum_string == NULL ||
01851                         netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
01852                                        NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM)) {
01853                         <span class="keywordtype">char</span>            str[16];
01854                         sprintf(str, <span class="stringliteral">"%d "</span>, (len * 8) + bit);
01855                         <span class="keywordflow">if</span> (!snmp_strcat
01856                             (buf, buf_len, out_len, allow_realloc,
01857                              (<span class="keyword">const</span> u_char *) str)) {
01858                             <span class="keywordflow">return</span> 0;
01859                         }
01860                     } <span class="keywordflow">else</span> {
01861                         <span class="keywordtype">char</span>            str[16];
01862                         sprintf(str, <span class="stringliteral">"(%d) "</span>, (len * 8) + bit);
01863                         <span class="keywordflow">if</span> (!snmp_strcat
01864                             (buf, buf_len, out_len, allow_realloc,
01865                              (<span class="keyword">const</span> u_char *) enum_string)) {
01866                             <span class="keywordflow">return</span> 0;
01867                         }
01868                         <span class="keywordflow">if</span> (!snmp_strcat
01869                             (buf, buf_len, out_len, allow_realloc,
01870                              (<span class="keyword">const</span> u_char *) str)) {
01871                             <span class="keywordflow">return</span> 0;
01872                         }
01873                     }
01874                 }
01875             }
01876             cp++;
01877         }
01878     }
01879     <span class="keywordflow">return</span> 1;
01880 }
01881 
01882 <span class="keywordtype">int</span>
01883 sprint_realloc_nsapaddress(u_char ** buf, size_t * buf_len,
01884                            size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
01885                            <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01886                            <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums, <span class="keyword">const</span> <span class="keywordtype">char</span> *hint,
01887                            <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
01888 {
01889     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_NSAP) &amp;&amp; 
01890         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01891         u_char          str[] = <span class="stringliteral">"Wrong Type (should be NsapAddress): "</span>;
01892         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01893             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01894                                           allow_realloc, var, NULL, NULL,
01895                                           NULL);
01896         } <span class="keywordflow">else</span> {
01897             <span class="keywordflow">return</span> 0;
01898         }
01899     }
01900 
01901     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01902         u_char          str[] = <span class="stringliteral">"NsapAddress: "</span>;
01903         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01904             <span class="keywordflow">return</span> 0;
01905         }
01906     }
01907 
01908     <span class="keywordflow">return</span> sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,
01909                                     var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string, var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
01910 }
01911 
01912 
01933 <span class="keywordtype">int</span>
<a name="l01934" id="l01934"></a><a class="code" href="group__mib__utilities.html#ga43">01934</a> <a class="code" href=
"group__mib__utilities.html#ga43">sprint_realloc_badtype</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01935                        <span class="keywordtype">int</span> allow_realloc,
01936                        <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01937                        <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01938                        <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01939 {
01940     u_char          str[] = <span class="stringliteral">"Variable has bad type"</span>;
01941 
01942     <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc, str);
01943 }
01944 
01945 
01946 
01968 <span class="keywordtype">int</span>
<a name="l01969" id="l01969"></a><a class="code" href="group__mib__utilities.html#ga44">01969</a> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01970                        <span class="keywordtype">int</span> allow_realloc,
01971                        <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01972                        <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01973                        <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01974 {
01975     DEBUGMSGTL((<span class="stringliteral">"output"</span>, <span class=
"stringliteral">"sprint_by_type, type %d\n"</span>, var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>));
01976 
01977     <span class="keywordflow">switch</span> (var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>) {
01978     <span class="keywordflow">case</span> ASN_INTEGER:
01979         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga34">sprint_realloc_integer</a>(buf, buf_len, out_len, allow_realloc,
01980                                       var, enums, hint, units);
01981     <span class="keywordflow">case</span> ASN_OCTET_STR:
01982         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga28">sprint_realloc_octet_string</a>(buf, buf_len, out_len,
01983                                            allow_realloc, var, enums, hint,
01984                                            units);
01985     <span class="keywordflow">case</span> ASN_BIT_STR:
01986         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga41">sprint_realloc_bitstring</a>(buf, buf_len, out_len,
01987                                         allow_realloc, var, enums, hint,
01988                                         units);
01989     <span class="keywordflow">case</span> ASN_OPAQUE:
01990         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga30">sprint_realloc_opaque</a>(buf, buf_len, out_len, allow_realloc,
01991                                      var, enums, hint, units);
01992     <span class="keywordflow">case</span> ASN_OBJECT_ID:
01993         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga31">sprint_realloc_object_identifier</a>(buf, buf_len, out_len,
01994                                                 allow_realloc, var, enums,
01995                                                 hint, units);
01996     <span class="keywordflow">case</span> ASN_TIMETICKS:
01997         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga32">sprint_realloc_timeticks</a>(buf, buf_len, out_len,
01998                                         allow_realloc, var, enums, hint,
01999                                         units);
02000     <span class="keywordflow">case</span> ASN_GAUGE:
02001         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga36">sprint_realloc_gauge</a>(buf, buf_len, out_len, allow_realloc,
02002                                     var, enums, hint, units);
02003     <span class="keywordflow">case</span> ASN_COUNTER:
02004         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga37">sprint_realloc_counter</a>(buf, buf_len, out_len, allow_realloc,
02005                                       var, enums, hint, units);
02006     <span class="keywordflow">case</span> ASN_IPADDRESS:
02007         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga39">sprint_realloc_ipaddress</a>(buf, buf_len, out_len,
02008                                         allow_realloc, var, enums, hint,
02009                                         units);
02010     <span class="keywordflow">case</span> ASN_NULL:
02011         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga40">sprint_realloc_null</a>(buf, buf_len, out_len, allow_realloc,
02012                                    var, enums, hint, units);
02013     <span class="keywordflow">case</span> ASN_UINTEGER:
02014         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga35">sprint_realloc_uinteger</a>(buf, buf_len, out_len,
02015                                        allow_realloc, var, enums, hint,
02016                                        units);
02017     <span class="keywordflow">case</span> ASN_COUNTER64:
02018 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
02019     <span class="keywordflow">case</span> ASN_OPAQUE_U64:
02020     <span class="keywordflow">case</span> ASN_OPAQUE_I64:
02021     <span class="keywordflow">case</span> ASN_OPAQUE_COUNTER64:
02022 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
02023         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga29">sprint_realloc_counter64</a>(buf, buf_len, out_len,
02024                                         allow_realloc, var, enums, hint,
02025                                         units);
02026 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
02027     <span class="keywordflow">case</span> ASN_OPAQUE_FLOAT:
02028         <span class="keywordflow">return</span> sprint_realloc_float(buf, buf_len, out_len, allow_realloc,
02029                                     var, enums, hint, units);
02030     <span class="keywordflow">case</span> ASN_OPAQUE_DOUBLE:
02031         <span class="keywordflow">return</span> sprint_realloc_double(buf, buf_len, out_len, allow_realloc,
02032                                      var, enums, hint, units);
02033 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
02034     <span class="keywordflow">default</span>:
02035         DEBUGMSGTL((<span class="stringliteral">"sprint_by_type"</span>, <span class=
"stringliteral">"bad type: %d\n"</span>, var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>));
02036         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga43">sprint_realloc_badtype</a>(buf, buf_len, out_len, allow_realloc,
02037                                       var, enums, hint, units);
02038     }
02039 }
02040 
02041 
02042 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02043 
02048 <span class="keyword">struct </span>tree    *
<a name="l02049" id="l02049"></a><a class="code" href="group__mib__utilities.html#ga45">02049</a> <a class="code" href=
"group__mib__utilities.html#ga45">get_tree_head</a>(<span class="keywordtype">void</span>)
02050 {
02051     <span class="keywordflow">return</span> (tree_head);
02052 }
02053 
02054 <span class="keyword">static</span> <span class="keywordtype">char</span>    *confmibdir = NULL;
02055 <span class="keyword">static</span> <span class="keywordtype">char</span>    *confmibs = NULL;
02056 
02057 <span class="keyword">static</span> <span class="keywordtype">void</span>
02058 handle_mibdirs_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
02059 {
02060     <span class="keywordtype">char</span>           *ctmp;
02061 
02062     <span class="keywordflow">if</span> (confmibdir) {
02063         <span class="keywordflow">if</span> ((*line == <span class="charliteral">'+'</span>) || (*line == <span class=
"charliteral">'-'</span>)) {
02064             ctmp = (<span class="keywordtype">char</span> *) malloc(strlen(confmibdir) + strlen(line) + 2);
02065             <span class="keywordflow">if</span> (!ctmp) {
02066                 DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>,
02067                             <span class="stringliteral">"mibdir conf malloc failed"</span>));
02068                 <span class="keywordflow">return</span>;
02069             }
02070             <span class="keywordflow">if</span>(*line++ == <span class="charliteral">'+'</span>)
02071                 sprintf(ctmp, <span class="stringliteral">"%s%c%s"</span>, confmibdir, ENV_SEPARATOR_CHAR, line);
02072             <span class="keywordflow">else</span>
02073                 sprintf(ctmp, <span class="stringliteral">"%s%c%s"</span>, line, ENV_SEPARATOR_CHAR, confmibdir);
02074         } <span class="keywordflow">else</span> {
02075             ctmp = strdup(line);
02076         }
02077         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(confmibdir);
02078         confmibdir = ctmp;
02079     } <span class="keywordflow">else</span> {
02080         confmibdir = strdup(line);
02081     }
02082     DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"using mibdirs: %s\n"</span>, confmibdir));
02083 }
02084 
02085 <span class="keyword">static</span> <span class="keywordtype">void</span>
02086 handle_mibs_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
02087 {
02088     <span class="keywordtype">char</span>           *ctmp;
02089 
02090     <span class="keywordflow">if</span> (confmibs) {
02091         ctmp = (<span class="keywordtype">char</span> *) malloc(strlen(confmibs) + strlen(line) + 2);
02092         <span class="keywordflow">if</span> (!ctmp) {
02093             DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"mibs conf malloc failed"</span>));
02094             <span class="keywordflow">return</span>;
02095         }
02096         <span class="keywordflow">if</span> (*line == <span class="charliteral">'+'</span>)
02097             line++;
02098         sprintf(ctmp, <span class="stringliteral">"%s%c%s"</span>, confmibs, ENV_SEPARATOR_CHAR, line);
02099         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(confmibs);
02100         confmibs = ctmp;
02101     } <span class="keywordflow">else</span> {
02102         confmibs = strdup(line);
02103     }
02104     DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"using mibs: %s\n"</span>, confmibs));
02105 }
02106 
02107 
02108 <span class="keyword">static</span> <span class="keywordtype">void</span>
02109 handle_mibfile_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
02110 {
02111     DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"reading mibfile: %s\n"</span>, line));
02112     read_mib(line);
02113 }
02114 <span class="preprocessor">#endif</span>
02115 
02116 <span class="keyword">static</span> <span class="keywordtype">void</span>
02117 handle_print_numeric(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
02118 {
02119     <span class="keyword">const</span> <span class="keywordtype">char</span> *value;
02120     <span class="keywordtype">char</span>       *st;
02121 
02122     value = strtok_r(line, <span class="stringliteral">" \t\n"</span>, &amp;st);
02123     <span class="keywordflow">if</span> ((strcasecmp(value, <span class="stringliteral">"yes"</span>)  == 0) || 
02124         (strcasecmp(value, <span class="stringliteral">"true"</span>) == 0) ||
02125         (*value == <span class="charliteral">'1'</span>)) {
02126 
02127         netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
02128                                                   NETSNMP_OID_OUTPUT_NUMERIC);
02129     }
02130 }
02131 
02132 <span class="keywordtype">char</span>           *
02133 snmp_out_toggle_options(<span class="keywordtype">char</span> *options)
02134 {
02135     <span class="keywordflow">while</span> (*options) {
02136         <span class="keywordflow">switch</span> (*options++) {
02137         <span class="keywordflow">case</span> <span class="charliteral">'0'</span>:
02138             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID,
02139                                       NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT);
02140             <span class="keywordflow">break</span>;
02141         <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
02142             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT,
02143                                                       NETSNMP_STRING_OUTPUT_ASCII);
02144             <span class="keywordflow">break</span>;
02145         <span class="keywordflow">case</span> <span class="charliteral">'b'</span>:
02146             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS);
02147             <span class="keywordflow">break</span>;
02148         <span class="keywordflow">case</span> <span class="charliteral">'e'</span>:
02149             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM);
02150             <span class="keywordflow">break</span>;
02151         <span class="keywordflow">case</span> <span class="charliteral">'E'</span>:
02152             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES);
02153             <span class="keywordflow">break</span>;
02154         <span class="keywordflow">case</span> <span class="charliteral">'f'</span>:
02155             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
02156                                                       NETSNMP_OID_OUTPUT_FULL);
02157             <span class="keywordflow">break</span>;
02158         <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
02159             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
02160                                                       NETSNMP_OID_OUTPUT_NUMERIC);
02161             <span class="keywordflow">break</span>;
02162         <span class="keywordflow">case</span> <span class="charliteral">'q'</span>:
02163             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);
02164             <span class="keywordflow">break</span>;
02165         <span class="keywordflow">case</span> <span class="charliteral">'Q'</span>:
02166             <a class="code" href=
"group__default__store.html#ga8">netsnmp_ds_set_boolean</a>(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT, 1);
02167             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);
02168             <span class="keywordflow">break</span>;
02169         <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
02170             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
02171                                                       NETSNMP_OID_OUTPUT_SUFFIX);
02172             <span class="keywordflow">break</span>;
02173         <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
02174             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
02175                                                       NETSNMP_OID_OUTPUT_MODULE);
02176             <span class="keywordflow">break</span>;
02177         <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:
02178             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS);
02179             <span class="keywordflow">break</span>;
02180         <span class="keywordflow">case</span> <span class="charliteral">'T'</span>:
02181             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT);
02182             <span class="keywordflow">break</span>;
02183         <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
02184             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
02185                                                       NETSNMP_OID_OUTPUT_UCD);
02186             <span class="keywordflow">break</span>;
02187         <span class="keywordflow">case</span> <span class="charliteral">'U'</span>:
02188             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PRINT_UNITS);
02189             <span class="keywordflow">break</span>;
02190         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02191             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE);
02192             <span class="keywordflow">break</span>;
02193         <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
02194             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT,
02195                                                       NETSNMP_STRING_OUTPUT_HEX);
02196             <span class="keywordflow">break</span>;
02197         <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
02198             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX);
02199             <span class="keywordflow">break</span>;
02200         <span class="keywordflow">default</span>:
02201             <span class="keywordflow">return</span> options - 1;
02202         }
02203     }
02204     <span class="keywordflow">return</span> NULL;
02205 }
02206 
02207 <span class="keywordtype">void</span>
02208 snmp_out_toggle_options_usage(<span class="keyword">const</span> <span class="keywordtype">char</span> *lead, FILE * outf)
02209 {
02210     fprintf(outf, <span class="stringliteral">"%s0:  print leading 0 for single-digit hex characters\n"</span>, lead);
02211     fprintf(outf, <span class="stringliteral">"%sa:  print all strings in ascii format\n"</span>, lead);
02212     fprintf(outf, <span class="stringliteral">"%sb:  do not break OID indexes down\n"</span>, lead);
02213     fprintf(outf, <span class="stringliteral">"%se:  print enums numerically\n"</span>, lead);
02214     fprintf(outf, <span class="stringliteral">"%sE:  escape quotes in string indices\n"</span>, lead);
02215     fprintf(outf, <span class="stringliteral">"%sf:  print full OIDs on output\n"</span>, lead);
02216     fprintf(outf, <span class="stringliteral">"%sn:  print OIDs numerically\n"</span>, lead);
02217     fprintf(outf, <span class="stringliteral">"%sq:  quick print for easier parsing\n"</span>, lead);
02218     fprintf(outf, <span class="stringliteral">"%sQ:  quick print with equal-signs\n"</span>, lead);    <span class=
"comment">/* @@JDW */</span>
02219     fprintf(outf, <span class="stringliteral">"%ss:  print only last symbolic element of OID\n"</span>, lead);
02220     fprintf(outf, <span class="stringliteral">"%sS:  print MIB module-id plus last element\n"</span>, lead);
02221     fprintf(outf, <span class="stringliteral">"%st:  print timeticks unparsed as numeric integers\n"</span>,
02222             lead);
02223     fprintf(outf,
02224             <span class="stringliteral">"%sT:  print human-readable text along with hex strings\n"</span>,
02225             lead);
02226     fprintf(outf, <span class="stringliteral">"%su:  print OIDs using UCD-style prefix suppression\n"</span>,
02227             lead);
02228     fprintf(outf, <span class="stringliteral">"%sU:  don't print units\n"</span>, lead);
02229     fprintf(outf, <span class="stringliteral">"%sv:  print values only (not OID = value)\n"</span>, lead);
02230     fprintf(outf, <span class="stringliteral">"%sx:  print all strings in hex format\n"</span>, lead);
02231     fprintf(outf, <span class="stringliteral">"%sX:  extended index format\n"</span>, lead);
02232 }
02233 
02234 <span class="keywordtype">char</span> *
02235 snmp_in_options(<span class="keywordtype">char</span> *optarg, <span class="keywordtype">int</span> argc, <span class=
"keywordtype">char</span> *<span class="keyword">const</span> *argv)
02236 {
02237     <span class="keywordtype">char</span> *cp;
02238 
02239     <span class="keywordflow">for</span> (cp = optarg; *cp; cp++) {
02240         <span class="keywordflow">switch</span> (*cp) {
02241         <span class="keywordflow">case</span> <span class="charliteral">'b'</span>:
02242             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REGEX_ACCESS);
02243             <span class="keywordflow">break</span>;
02244         <span class="keywordflow">case</span> <span class="charliteral">'R'</span>:
02245             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_RANDOM_ACCESS);
02246             <span class="keywordflow">break</span>;
02247         <span class="keywordflow">case</span> <span class="charliteral">'r'</span>:
02248             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_CHECK_RANGE);
02249             <span class="keywordflow">break</span>;
02250         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02251             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NO_DISPLAY_HINT);
02252             <span class="keywordflow">break</span>;
02253         <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
02254             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_READ_UCD_STYLE_OID);
02255             <span class="keywordflow">break</span>;
02256         <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
02257             <span class="comment">/* What if argc/argv are null ? */</span>
02258             <span class="keywordflow">if</span> (!*(++cp))
02259                 cp = argv[optind++];
02260             netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,
02261                                   NETSNMP_DS_LIB_OIDSUFFIX,
02262                                   cp);
02263             <span class="keywordflow">return</span> NULL;
02264 
02265         <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
02266             <span class="comment">/* What if argc/argv are null ? */</span>
02267             <span class="keywordflow">if</span> (!*(++cp))
02268                 cp = argv[optind++];
02269             netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,
02270                                   NETSNMP_DS_LIB_OIDPREFIX,
02271                                   cp);
02272             <span class="keywordflow">return</span> NULL;
02273 
02274         <span class="keywordflow">default</span>:
02275            <span class="comment">/*</span>
02276 <span class="comment">            *  Here?  Or in snmp_parse_args?</span>
02277 <span class="comment">            snmp_log(LOG_ERR, "Unknown input option passed to -I: %c.\n", *cp);</span>
02278 <span class="comment">            */</span>
02279             <span class="keywordflow">return</span> cp;
02280         }
02281     }
02282     <span class="keywordflow">return</span> NULL;
02283 }
02284 
02285 <span class="keywordtype">char</span>           *
02286 snmp_in_toggle_options(<span class="keywordtype">char</span> *options)
02287 {
02288     <span class="keywordflow">return</span> snmp_in_options( options, 0, NULL );
02289 }
02290 
02291 
02299 <span class="keywordtype">void</span>
<a name="l02300" id="l02300"></a><a class="code" href="group__mib__utilities.html#ga51">02300</a> <a class="code" href=
"group__mib__utilities.html#ga51">snmp_in_toggle_options_usage</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *lead, FILE * outf)
02301 {
02302     fprintf(outf, <span class="stringliteral">"%sb:  do best/regex matching to find a MIB node\n"</span>, lead);
02303     fprintf(outf, <span class="stringliteral">"%sh:  don't apply DISPLAY-HINTs\n"</span>, lead);
02304     fprintf(outf, <span class="stringliteral">"%sr:  do not check values for range/type legality\n"</span>, lead);
02305     fprintf(outf, <span class="stringliteral">"%sR:  do random access to OID labels\n"</span>, lead);
02306     fprintf(outf,
02307             <span class="stringliteral">"%su:  top-level OIDs must have '.' prefix (UCD-style)\n"</span>, lead);
02308     fprintf(outf,
02309             <span class="stringliteral">"%ss SUFFIX:  Append all textual OIDs with SUFFIX before parsing\n"</span>,
02310             lead);
02311     fprintf(outf,
02312             <span class="stringliteral">"%sS PREFIX:  Prepend all textual OIDs with PREFIX before parsing\n"</span>,
02313             lead);
02314 }
02315 
02316 <span class="comment">/***</span>
02317 <span class="comment"> *</span>
02318 <span class="comment"> */</span> 
02319 <span class="keywordtype">void</span>
02320 register_mib_handlers(<span class="keywordtype">void</span>)
02321 {
02322 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02323     register_prenetsnmp_mib_handler(<span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"mibdirs"</span>,
02324                                     handle_mibdirs_conf, NULL,
02325                                     <span class="stringliteral">"[mib-dirs|+mib-dirs|-mib-dirs]"</span>);
02326     register_prenetsnmp_mib_handler(<span class="stringliteral">"snmp"</span>, <span class="stringliteral">"mibs"</span>,
02327                                     handle_mibs_conf, NULL,
02328                                     <span class="stringliteral">"[mib-tokens|+mib-tokens]"</span>);
02329     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(<span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"mibfile"</span>,
02330                             handle_mibfile_conf, NULL, <span class="stringliteral">"mibfile-to-read"</span>);
02331     <span class="comment">/*</span>
02332 <span class="comment">     * register the snmp.conf configuration handlers for default</span>
02333 <span class="comment">     * parsing behaviour </span>
02334 <span class="comment">     */</span>
02335 
02336     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"showMibErrors"</span>,
02337                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_ERRORS);
02338     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"strictCommentTerm"</span>,
02339                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_COMMENT_TERM);
02340     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"mibAllowUnderline"</span>,
02341                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_PARSE_LABEL);
02342     netsnmp_ds_register_premib(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"mibWarningLevel"</span>,
02343                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_WARNINGS);
02344     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"mibReplaceWithLatest"</span>,
02345                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_REPLACE);
02346 <span class="preprocessor">#endif</span>
02347 
02348     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"printNumericEnums"</span>,
02349                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM);
02350     register_prenetsnmp_mib_handler(<span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"printNumericOids"</span>,
02351                        handle_print_numeric, NULL, <span class="stringliteral">"(1|yes|true|0|no|false)"</span>);
02352     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"escapeQuotes"</span>,
02353                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES);
02354     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"dontBreakdownOids"</span>,
02355                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS);
02356     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"quickPrinting"</span>,
02357                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);
02358     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"numericTimeticks"</span>,
02359                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS);
02360     netsnmp_ds_register_premib(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"oidOutputFormat"</span>,
02361                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);
02362     netsnmp_ds_register_premib(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"suffixPrinting"</span>,
02363                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);
02364     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"extendedIndex"</span>,
02365                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX);
02366     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"printHexText"</span>,
02367                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT);
02368     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"printValueOnly"</span>,
02369                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE);
02370     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"dontPrintUnits"</span>,
02371                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PRINT_UNITS);
02372     netsnmp_ds_register_premib(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"hexOutputLength"</span>,
02373                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH);
02374 }
02375 
02376 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02377 <span class="comment">/*</span>
02378 <span class="comment"> * function : netsnmp_set_mib_directory</span>
02379 <span class="comment"> *            - This function sets the string of the directories</span>
02380 <span class="comment"> *              from which the MIB modules will be searched or</span>
02381 <span class="comment"> *              loaded.</span>
02382 <span class="comment"> * arguments: const char *dir, which are the directories</span>
02383 <span class="comment"> *              from which the MIB modules will be searched or</span>
02384 <span class="comment"> *              loaded.</span>
02385 <span class="comment"> * returns  : -</span>
02386 <span class="comment"> */</span>
02387 <span class="keywordtype">void</span>
<a name="l02388" id="l02388"></a><a class="code" href="group__mib__utilities.html#ga53">02388</a> <a class="code" href=
"group__mib__utilities.html#ga53">netsnmp_set_mib_directory</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *dir)
02389 {
02390     <span class="keyword">const</span> <span class="keywordtype">char</span> *newdir;
02391     <span class="keywordtype">char</span> *olddir, *tmpdir = NULL;
02392 
02393     DEBUGTRACE;
02394     <span class="keywordflow">if</span> (NULL == dir) {
02395         <span class="keywordflow">return</span>;
02396     }
02397     
02398     olddir = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
02399                                    NETSNMP_DS_LIB_MIBDIRS);
02400     <span class="keywordflow">if</span> (olddir) {
02401         <span class="keywordflow">if</span> ((*dir == <span class="charliteral">'+'</span>) || (*dir == <span class=
"charliteral">'-'</span>)) {
02403             tmpdir = malloc(strlen(dir) + strlen(olddir) + 2);
02404             <span class="keywordflow">if</span> (!tmpdir) {
02405                 DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"set mibdir malloc failed"</span>));
02406                 <span class="keywordflow">return</span>;
02407             }
02408             <span class="keywordflow">if</span> (*dir++ == <span class="charliteral">'+'</span>)
02409                 sprintf(tmpdir, <span class="stringliteral">"%s%c%s"</span>, olddir, ENV_SEPARATOR_CHAR, dir);
02410             <span class="keywordflow">else</span>
02411                 sprintf(tmpdir, <span class="stringliteral">"%s%c%s"</span>, dir, ENV_SEPARATOR_CHAR, olddir);
02412             newdir = tmpdir;
02413         } <span class="keywordflow">else</span> {
02414             newdir = dir;
02415         }
02416     } <span class="keywordflow">else</span> {
02418         newdir = ((*dir == <span class="charliteral">'+'</span>) ? ++dir : dir);
02419     }
02420     netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIBDIRS,
02421                           newdir);
02422 
02424     <span class="keywordflow">if</span> (tmpdir == newdir) {
02425         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tmpdir);
02426     }
02427 }
02428 
02429 <span class="comment">/*</span>
02430 <span class="comment"> * function : netsnmp_get_mib_directory</span>
02431 <span class="comment"> *            - This function returns a string of the directories</span>
02432 <span class="comment"> *              from which the MIB modules will be searched or</span>
02433 <span class="comment"> *              loaded.</span>
02434 <span class="comment"> *              If the value still does not exists, it will be made</span>
02435 <span class="comment"> *              from the evironment variable 'MIBDIRS' and/or the</span>
02436 <span class="comment"> *              default.</span>
02437 <span class="comment"> * arguments: -</span>
02438 <span class="comment"> * returns  : char * of the directories in which the MIB modules</span>
02439 <span class="comment"> *            will be searched/loaded.</span>
02440 <span class="comment"> */</span>
02441 
02442 <span class="keywordtype">char</span> *
<a name="l02443" id="l02443"></a><a class="code" href="group__mib__utilities.html#ga54">02443</a> <a class="code" href=
"group__mib__utilities.html#ga54">netsnmp_get_mib_directory</a>(<span class="keywordtype">void</span>)
02444 {
02445     <span class="keywordtype">char</span> *dir;
02446 
02447     DEBUGTRACE;
02448     dir = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIBDIRS);
02449     <span class="keywordflow">if</span> (dir == NULL) {
02450         DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"no mib directories set\n"</span>));
02451 
02453         dir = <a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class=
"stringliteral">"MIBDIRS"</span>);
02454         <span class="keywordflow">if</span> (dir == NULL) {
02455             DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"no mib directories set by environment\n"</span>));
02457             <span class="keywordflow">if</span> (confmibdir == NULL) {
02458                 DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"no mib directories set by config\n"</span>));
02459                 <a class="code" href="group__mib__utilities.html#ga53">netsnmp_set_mib_directory</a>(DEFAULT_MIBDIRS);
02460             }
02461             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*confmibdir == <span class=
"charliteral">'+'</span>) || (*confmibdir == <span class="charliteral">'-'</span>)) {
02462                 DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"mib directories set by config (but added)\n"</span>));
02463                 <a class="code" href="group__mib__utilities.html#ga53">netsnmp_set_mib_directory</a>(DEFAULT_MIBDIRS);
02464                 <a class="code" href="group__mib__utilities.html#ga53">netsnmp_set_mib_directory</a>(confmibdir);
02465             }
02466             <span class="keywordflow">else</span> {
02467                 DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"mib directories set by config\n"</span>));
02468                 <a class="code" href="group__mib__utilities.html#ga53">netsnmp_set_mib_directory</a>(confmibdir);
02469             }
02470         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*dir == <span class=
"charliteral">'+'</span>) || (*dir == <span class="charliteral">'-'</span>)) {
02471             DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"mib directories set by environment (but added)\n"</span>));
02472             <a class="code" href="group__mib__utilities.html#ga53">netsnmp_set_mib_directory</a>(DEFAULT_MIBDIRS);
02473             <a class="code" href="group__mib__utilities.html#ga53">netsnmp_set_mib_directory</a>(dir);
02474         } <span class="keywordflow">else</span> {
02475             DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"mib directories set by environment\n"</span>));
02476             <a class="code" href="group__mib__utilities.html#ga53">netsnmp_set_mib_directory</a>(dir);
02477         }
02478         dir = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIBDIRS);
02479     }
02480     DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"mib directories set '%s'\n"</span>, dir));
02481     <span class="keywordflow">return</span>(dir);
02482 }
02483 
02484 <span class="comment">/*</span>
02485 <span class="comment"> * function : netsnmp_fixup_mib_directory</span>
02486 <span class="comment"> * arguments: -</span>
02487 <span class="comment"> * returns  : -</span>
02488 <span class="comment"> */</span>
02489 <span class="keywordtype">void</span>
<a name="l02490" id="l02490"></a><a class="code" href="group__mib__utilities.html#ga55">02490</a> <a class="code" href=
"group__mib__utilities.html#ga55">netsnmp_fixup_mib_directory</a>(<span class="keywordtype">void</span>)
02491 {
02492     <span class="keywordtype">char</span> *homepath = <a class="code" href=
"group__util.html#ga24">netsnmp_getenv</a>(<span class="stringliteral">"HOME"</span>);
02493     <span class="keywordtype">char</span> *mibpath = <a class="code" href=
"group__mib__utilities.html#ga54">netsnmp_get_mib_directory</a>();
02494     <span class="keywordtype">char</span> *oldmibpath = NULL;
02495     <span class="keywordtype">char</span> *ptr_home;
02496     <span class="keywordtype">char</span> *new_mibpath;
02497 
02498     DEBUGTRACE;
02499     <span class="keywordflow">if</span> (homepath &amp;&amp; mibpath) {
02500         DEBUGMSGTL((<span class="stringliteral">"fixup_mib_directory"</span>, <span class=
"stringliteral">"mib directories '%s'\n"</span>, mibpath));
02501         <span class="keywordflow">while</span> ((ptr_home = strstr(mibpath, <span class="stringliteral">"$HOME"</span>))) {
02502             new_mibpath = (<span class="keywordtype">char</span> *)malloc(strlen(mibpath) - strlen(<span class=
"stringliteral">"$HOME"</span>) +
02503                                          strlen(homepath)+1);
02504             <span class="keywordflow">if</span> (new_mibpath) {
02505                 *ptr_home = 0; <span class="comment">/* null out the spot where we stop copying */</span>
02506                 sprintf(new_mibpath, <span class="stringliteral">"%s%s%s"</span>, mibpath, homepath,
02507                         ptr_home + strlen(<span class="stringliteral">"$HOME"</span>));
02509                 mibpath = new_mibpath;
02510                 <span class="keywordflow">if</span> (oldmibpath != NULL) {
02511                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(oldmibpath);
02512                 }
02513                 oldmibpath = new_mibpath;
02514             } <span class="keywordflow">else</span> {
02515                 <span class="keywordflow">break</span>;
02516             }
02517         }
02518 
02519         <a class="code" href="group__mib__utilities.html#ga53">netsnmp_set_mib_directory</a>(mibpath);
02520         
02521         <span class="comment">/*  The above copies the mibpath for us, so...  */</span>
02522 
02523         <span class="keywordflow">if</span> (oldmibpath != NULL) {
02524             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(oldmibpath);
02525         }
02526 
02527     }
02528 
02529 }
02530 
02536 <span class="keywordtype">void</span>
<a name="l02537" id="l02537"></a><a class="code" href="group__mib__utilities.html#ga56">02537</a> <a class="code" href=
"group__mib__utilities.html#ga56">init_mib</a>(<span class="keywordtype">void</span>)
02538 {
02539     <span class="keyword">const</span> <span class="keywordtype">char</span>     *prefix;
02540     <span class="keywordtype">char</span>           *env_var, *entry;
02541     PrefixListPtr   pp = &amp;mib_prefixes[0];
02542     <span class="keywordtype">char</span>           *st;
02543 
02544     <span class="keywordflow">if</span> (Mib)
02545         <span class="keywordflow">return</span>;
02546     init_mib_internals();
02547 
02548     <span class="comment">/*</span>
02549 <span class="comment">     * Initialise the MIB directory/ies </span>
02550 <span class="comment">     */</span>
02551     <a class="code" href="group__mib__utilities.html#ga55">netsnmp_fixup_mib_directory</a>();
02552     env_var = strdup(<a class="code" href="group__mib__utilities.html#ga54">netsnmp_get_mib_directory</a>());
02553 
02554     DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>,
02555                 <span class="stringliteral">"Seen MIBDIRS: Looking in '%s' for mib dirs ...\n"</span>,
02556                 env_var));
02557 
02558     entry = strtok_r(env_var, ENV_SEPARATOR, &amp;st);
02559     <span class="keywordflow">while</span> (entry) {
02560         add_mibdir(entry);
02561         entry = strtok_r(NULL, ENV_SEPARATOR, &amp;st);
02562     }
02563     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(env_var);
02564 
02565     env_var = <a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class=
"stringliteral">"MIBFILES"</span>);
02566     <span class="keywordflow">if</span> (env_var != NULL) {
02567         <span class="keywordflow">if</span> (*env_var == <span class="charliteral">'+'</span>)
02568             entry = strtok_r(env_var+1, ENV_SEPARATOR, &amp;st);
02569         <span class="keywordflow">else</span>
02570             entry = strtok_r(env_var, ENV_SEPARATOR, &amp;st);
02571         <span class="keywordflow">while</span> (entry) {
02572             add_mibfile(entry, NULL, NULL);
02573             entry = strtok_r(NULL, ENV_SEPARATOR, &amp;st);
02574         }
02575     }
02576 
02577     init_mib_internals();
02578 
02579     <span class="comment">/*</span>
02580 <span class="comment">     * Read in any modules or mibs requested </span>
02581 <span class="comment">     */</span>
02582 
02583     env_var = <a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class="stringliteral">"MIBS"</span>);
02584     <span class="keywordflow">if</span> (env_var == NULL) {
02585         <span class="keywordflow">if</span> (confmibs != NULL)
02586             env_var = strdup(confmibs);
02587         <span class="keywordflow">else</span>
02588             env_var = strdup(DEFAULT_MIBS);
02589     } <span class="keywordflow">else</span> {
02590         env_var = strdup(env_var);
02591     }
02592     <span class="keywordflow">if</span> (env_var &amp;&amp; *env_var == <span class="charliteral">'+'</span>) {
02593         entry =
02594             (<span class="keywordtype">char</span> *) malloc(strlen(DEFAULT_MIBS) + strlen(env_var) + 2);
02595         <span class="keywordflow">if</span> (!entry) {
02596             DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>, <span class=
"stringliteral">"env mibs malloc failed"</span>));
02597             <span class="keywordflow">return</span>;
02598         } <span class="keywordflow">else</span>
02599             sprintf(entry, <span class="stringliteral">"%s%c%s"</span>, DEFAULT_MIBS, ENV_SEPARATOR_CHAR,
02600                 env_var + 1);
02601         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(env_var);
02602         env_var = entry;
02603     }
02604 
02605     DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>,
02606                 <span class="stringliteral">"Seen MIBS: Looking in '%s' for mib files ...\n"</span>,
02607                 env_var));
02608     entry = strtok_r(env_var, ENV_SEPARATOR, &amp;st);
02609     <span class="keywordflow">while</span> (entry) {
02610         <span class="keywordflow">if</span> (strcasecmp(entry, DEBUG_ALWAYS_TOKEN) == 0) {
02611             read_all_mibs();
02612         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strstr(entry, <span class=
"stringliteral">"/"</span>) != 0) {
02613             read_mib(entry);
02614         } <span class="keywordflow">else</span> {
02615             read_module(entry);
02616         }
02617         entry = strtok_r(NULL, ENV_SEPARATOR, &amp;st);
02618     }
02619     adopt_orphans();
02620     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(env_var);
02621 
02622     env_var = <a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class=
"stringliteral">"MIBFILES"</span>);
02623     <span class="keywordflow">if</span> (env_var != NULL) {
02624         <span class="keywordflow">if</span> (*env_var == <span class="charliteral">'+'</span>) {
02625 <span class="preprocessor">#ifdef DEFAULT_MIBFILES</span>
02626             entry =
02627                 (<span class="keywordtype">char</span> *) malloc(strlen(DEFAULT_MIBFILES) +
02628                                 strlen(env_var) + 2);
02629             <span class="keywordflow">if</span> (!entry) {
02630                 DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>, <span class=
"stringliteral">"env mibfiles malloc failed"</span>));
02631             } <span class="keywordflow">else</span>
02632                 sprintf(entry, <span class="stringliteral">"%s%c%s"</span>, DEFAULT_MIBFILES, ENV_SEPARATOR_CHAR,
02633                     env_var + 1);
02634             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(env_var);
02635             env_var = entry;
02636 <span class="preprocessor">#else</span>
02637             env_var = strdup(env_var + 1);
02638 <span class="preprocessor">#endif</span>
02639         } <span class="keywordflow">else</span> {
02640             env_var = strdup(env_var);
02641         }
02642     } <span class="keywordflow">else</span> {
02643 <span class="preprocessor">#ifdef DEFAULT_MIBFILES</span>
02644         env_var = strdup(DEFAULT_MIBFILES);
02645 <span class="preprocessor">#endif</span>
02646     }
02647 
02648     <span class="keywordflow">if</span> (env_var != 0) {
02649         DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>,
02650                     <span class="stringliteral">"Seen MIBFILES: Looking in '%s' for mib files ...\n"</span>,
02651                     env_var));
02652         entry = strtok_r(env_var, ENV_SEPARATOR, &amp;st);
02653         <span class="keywordflow">while</span> (entry) {
02654             read_mib(entry);
02655             entry = strtok_r(NULL, ENV_SEPARATOR, &amp;st);
02656         }
02657         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(env_var);
02658     }
02659 
02660     prefix = <a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class="stringliteral">"PREFIX"</span>);
02661 
02662     <span class="keywordflow">if</span> (!prefix)
02663         prefix = Standard_Prefix;
02664 
02665     Prefix = (<span class="keywordtype">char</span> *) malloc(strlen(prefix) + 2);
02666     <span class="keywordflow">if</span> (!Prefix)
02667         DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>, <span class=
"stringliteral">"Prefix malloc failed"</span>));
02668     <span class="keywordflow">else</span>
02669         strcpy(Prefix, prefix);
02670 
02671     DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>,
02672                 <span class="stringliteral">"Seen PREFIX: Looking in '%s' for prefix ...\n"</span>, Prefix));
02673 
02674     <span class="comment">/*</span>
02675 <span class="comment">     * remove trailing dot </span>
02676 <span class="comment">     */</span>
02677     <span class="keywordflow">if</span> (Prefix) {
02678         env_var = &amp;Prefix[strlen(Prefix) - 1];
02679         <span class="keywordflow">if</span> (*env_var == <span class="charliteral">'.'</span>)
02680             *env_var = <span class="charliteral">'\0'</span>;
02681     }
02682 
02683     pp-&gt;str = Prefix;           <span class="comment">/* fixup first mib_prefix entry */</span>
02684     <span class="comment">/*</span>
02685 <span class="comment">     * now that the list of prefixes is built, save each string length. </span>
02686 <span class="comment">     */</span>
02687     <span class="keywordflow">while</span> (pp-&gt;str) {
02688         pp-&gt;len = strlen(pp-&gt;str);
02689         pp++;
02690     }
02691 
02692     Mib = tree_head;            <span class="comment">/* Backwards compatibility */</span>
02693     tree_top = (<span class="keyword">struct </span>tree *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> tree));
02694     <span class="comment">/*</span>
02695 <span class="comment">     * XX error check ? </span>
02696 <span class="comment">     */</span>
02697     <span class="keywordflow">if</span> (tree_top) {
02698         tree_top-&gt;label = strdup(<span class="stringliteral">"(top)"</span>);
02699         tree_top-&gt;child_list = tree_head;
02700     }
02701 }
02702 
02706 <span class="keywordtype">void</span>
<a name="l02707" id="l02707"></a><a class="code" href="group__mib__utilities.html#ga57">02707</a> <a class="code" href=
"group__mib__utilities.html#ga57">shutdown_mib</a>(<span class="keywordtype">void</span>)
02708 {
02709     unload_all_mibs();
02710     <span class="keywordflow">if</span> (tree_top) {
02711         <span class="keywordflow">if</span> (tree_top-&gt;label)
02712             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tree_top-&gt;label);
02713         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tree_top);
02714         tree_top = NULL;
02715     }
02716     tree_head = NULL;
02717     Mib = NULL;
02718     <span class="keywordflow">if</span> (Prefix != NULL &amp;&amp; Prefix != &amp;Standard_Prefix[0])
02719         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(Prefix);
02720     <span class="keywordflow">if</span> (Prefix)
02721         Prefix = NULL;
02722 }
02723 
02729 <span class="keywordtype">void</span>
<a name="l02730" id="l02730"></a><a class="code" href="group__mib__utilities.html#ga58">02730</a> <a class="code" href=
"group__mib__utilities.html#ga58">print_mib</a>(FILE * fp)
02731 {
02732     print_subtree(fp, tree_head, 0);
02733 }
02734 
02735 <span class="keywordtype">void</span>
02736 print_ascii_dump(FILE * fp)
02737 {
02738     fprintf(fp, <span class="stringliteral">"dump DEFINITIONS ::= BEGIN\n"</span>);
02739     print_ascii_dump_tree(fp, tree_head, 0);
02740     fprintf(fp, <span class="stringliteral">"END\n"</span>);
02741 }
02742 
02743 
02750 <span class="keywordtype">void</span>
<a name="l02751" id="l02751"></a><a class="code" href="group__mib__utilities.html#ga60">02751</a> <a class="code" href=
"group__mib__utilities.html#ga60">set_function</a>(<span class="keyword">struct</span> tree *subtree)
02752 {
02753     subtree-&gt;printer = NULL;
02754     <span class="keywordflow">switch</span> (subtree-&gt;type) {
02755     <span class="keywordflow">case</span> TYPE_OBJID:
02756         subtree-&gt;printomat = sprint_realloc_object_identifier;
02757         <span class="keywordflow">break</span>;
02758     <span class="keywordflow">case</span> TYPE_OCTETSTR:
02759         subtree-&gt;printomat = sprint_realloc_octet_string;
02760         <span class="keywordflow">break</span>;
02761     <span class="keywordflow">case</span> TYPE_INTEGER:
02762         subtree-&gt;printomat = sprint_realloc_integer;
02763         <span class="keywordflow">break</span>;
02764     <span class="keywordflow">case</span> TYPE_INTEGER32:
02765         subtree-&gt;printomat = sprint_realloc_integer;
02766         <span class="keywordflow">break</span>;
02767     <span class="keywordflow">case</span> TYPE_NETADDR:
02768         subtree-&gt;printomat = sprint_realloc_networkaddress;
02769         <span class="keywordflow">break</span>;
02770     <span class="keywordflow">case</span> TYPE_IPADDR:
02771         subtree-&gt;printomat = sprint_realloc_ipaddress;
02772         <span class="keywordflow">break</span>;
02773     <span class="keywordflow">case</span> TYPE_COUNTER:
02774         subtree-&gt;printomat = sprint_realloc_counter;
02775         <span class="keywordflow">break</span>;
02776     <span class="keywordflow">case</span> TYPE_GAUGE:
02777         subtree-&gt;printomat = sprint_realloc_gauge;
02778         <span class="keywordflow">break</span>;
02779     <span class="keywordflow">case</span> TYPE_TIMETICKS:
02780         subtree-&gt;printomat = sprint_realloc_timeticks;
02781         <span class="keywordflow">break</span>;
02782     <span class="keywordflow">case</span> TYPE_OPAQUE:
02783         subtree-&gt;printomat = sprint_realloc_opaque;
02784         <span class="keywordflow">break</span>;
02785     <span class="keywordflow">case</span> TYPE_NULL:
02786         subtree-&gt;printomat = sprint_realloc_null;
02787         <span class="keywordflow">break</span>;
02788     <span class="keywordflow">case</span> TYPE_BITSTRING:
02789         subtree-&gt;printomat = sprint_realloc_bitstring;
02790         <span class="keywordflow">break</span>;
02791     <span class="keywordflow">case</span> TYPE_NSAPADDRESS:
02792         subtree-&gt;printomat = sprint_realloc_nsapaddress;
02793         <span class="keywordflow">break</span>;
02794     <span class="keywordflow">case</span> TYPE_COUNTER64:
02795         subtree-&gt;printomat = sprint_realloc_counter64;
02796         <span class="keywordflow">break</span>;
02797     <span class="keywordflow">case</span> TYPE_UINTEGER:
02798         subtree-&gt;printomat = sprint_realloc_uinteger;
02799         <span class="keywordflow">break</span>;
02800     <span class="keywordflow">case</span> TYPE_UNSIGNED32:
02801         subtree-&gt;printomat = sprint_realloc_gauge;
02802         <span class="keywordflow">break</span>;
02803     <span class="keywordflow">case</span> TYPE_OTHER:
02804     <span class="keywordflow">default</span>:
02805         subtree-&gt;printomat = sprint_realloc_by_type;
02806         <span class="keywordflow">break</span>;
02807     }
02808 }
02809 
02810 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
02811 
02827 <span class="keywordtype">int</span>
<a name="l02828" id="l02828"></a><a class="code" href="group__mib__utilities.html#ga61">02828</a> <a class="code" href=
"group__mib__utilities.html#ga61">read_objid</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *input, oid * output, size_t * out_len)
02829 {                               <span class="comment">/* number of subid's in "output" */</span>
02830 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02831     <span class="keyword">struct </span>tree    *root = tree_top;
02832 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
02833     <span class="keywordtype">char</span>            buf[SPRINT_MAX_LEN];
02834     <span class="keywordtype">int</span>             ret, max_out_len;
02835     <span class="keywordtype">char</span>           *name, ch;
02836     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp;
02837 
02838     cp = input;
02839     <span class="keywordflow">while</span> ((ch = *cp)) {
02840         <span class="keywordflow">if</span> ((<span class=
"charliteral">'0'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'9'</span>)
02841             || (<span class="charliteral">'a'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'z'</span>)
02842             || (<span class="charliteral">'A'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'Z'</span>)
02843             || ch == <span class="charliteral">'-'</span>)
02844             cp++;
02845         <span class="keywordflow">else</span>
02846             <span class="keywordflow">break</span>;
02847     }
02848 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02849     <span class="keywordflow">if</span> (ch == <span class="charliteral">':'</span>)
02850         <span class="keywordflow">return</span> get_node(input, output, out_len);
02851 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
02852 
02853     <span class="keywordflow">if</span> (*input == <span class="charliteral">'.'</span>)
02854         input++;
02855 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02856     <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_READ_UCD_STYLE_OID)) {
02857         <span class="comment">/*</span>
02858 <span class="comment">         * get past leading '.', append '.' to Prefix. </span>
02859 <span class="comment">         */</span>
02860         <span class="keywordflow">if</span> (*Prefix == <span class="charliteral">'.'</span>)
02861             strncpy(buf, Prefix + 1, <span class="keyword">sizeof</span>(buf)-1);
02862         <span class="keywordflow">else</span>
02863             strncpy(buf, Prefix, <span class="keyword">sizeof</span>(buf)-1);
02864         buf[ <span class="keyword">sizeof</span>(buf)-1 ] = 0;
02865         strcat(buf, <span class="stringliteral">"."</span>);
02866         buf[ <span class="keyword">sizeof</span>(buf)-1 ] = 0;
02867         strncat(buf, input, <span class="keyword">sizeof</span>(buf)-strlen(buf));
02868         buf[ <span class="keyword">sizeof</span>(buf)-1 ] = 0;
02869         input = buf;
02870     }
02871 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
02872 
02873 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02874     <span class="keywordflow">if</span> (root == NULL) {
02875         SET_SNMP_ERROR(SNMPERR_NOMIB);
02876         *out_len = 0;
02877         <span class="keywordflow">return</span> 0;
02878     }
02879 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
02880     name = strdup(input);
02881     max_out_len = *out_len;
02882     *out_len = 0;
02883 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02884     <span class="keywordflow">if</span> ((ret =
02885          _add_strings_to_oid(root, name, output, out_len,
02886                              max_out_len)) &lt;= 0)
02887 <span class="preprocessor">#else</span>
02888     <span class="keywordflow">if</span> ((ret =
02889          _add_strings_to_oid(NULL, name, output, out_len,
02890                              max_out_len)) &lt;= 0)
02891 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
02892     {
02893         <span class="keywordflow">if</span> (ret == 0)
02894             ret = SNMPERR_UNKNOWN_OBJID;
02895         SET_SNMP_ERROR(ret);
02896         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(name);
02897         <span class="keywordflow">return</span> 0;
02898     }
02899     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(name);
02900 
02901     <span class="keywordflow">return</span> 1;
02902 }
02903 
02907 <span class="keywordtype">void</span>
02908 netsnmp_sprint_realloc_objid(u_char ** buf, size_t * buf_len,
02909                              size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
02910                              <span class="keywordtype">int</span> *buf_overflow,
02911                              <span class="keyword">const</span> oid * objid, size_t objidlen)
02912 {
02913     u_char         *tbuf = NULL, *cp = NULL;
02914     size_t          tbuf_len = 256, tout_len = 0;
02915     <span class="keywordtype">int</span>             tbuf_overflow = 0;
02916     <span class="keywordtype">int</span>             output_format;
02917 
02918     <span class="keywordflow">if</span> ((tbuf = (u_char *) calloc(tbuf_len, 1)) == NULL) {
02919         tbuf_overflow = 1;
02920     } <span class="keywordflow">else</span> {
02921         *tbuf = <span class="charliteral">'.'</span>;
02922         tout_len = 1;
02923     }
02924 
02925     _oid_finish_printing(objid, objidlen,
02926                          &amp;tbuf, &amp;tbuf_len, &amp;tout_len,
02927                          allow_realloc, &amp;tbuf_overflow);
02928 
02929     <span class="keywordflow">if</span> (tbuf_overflow) {
02930         <span class="keywordflow">if</span> (!*buf_overflow) {
02931             snmp_strcat(buf, buf_len, out_len, allow_realloc, tbuf);
02932             *buf_overflow = 1;
02933         }
02934         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tbuf);
02935         <span class="keywordflow">return</span>;
02936     }
02937 
02938     output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);
02939     <span class="keywordflow">if</span> (0 == output_format) {
02940         output_format = NETSNMP_OID_OUTPUT_NUMERIC;
02941     }
02942     <span class="keywordflow">switch</span> (output_format) {
02943     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_FULL:
02944     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_NUMERIC:
02945     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_SUFFIX:
02946     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_MODULE:
02947         cp = tbuf;
02948         <span class="keywordflow">break</span>;
02949 
02950     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_NONE:
02951     <span class="keywordflow">default</span>:
02952         cp = NULL;
02953     }
02954 
02955     <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp;
02956         !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp)) {
02957         *buf_overflow = 1;
02958     }
02959     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tbuf);
02960 }
02961 
02965 <span class="preprocessor">#ifdef DISABLE_MIB_LOADING</span>
02966 <span class="keywordtype">void</span>
02967 netsnmp_sprint_realloc_objid_tree(u_char ** buf, size_t * buf_len,
02968                                   size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
02969                                   <span class="keywordtype">int</span> *buf_overflow,
02970                                   <span class="keyword">const</span> oid * objid, size_t objidlen)
02971 {
02972     netsnmp_sprint_realloc_objid(buf, buf_len, out_len, allow_realloc,
02973                                  buf_overflow, objid, objidlen);
02974 }
02975 <span class="preprocessor">#else</span>
02976 <span class="keyword">struct </span>tree    *
02977 netsnmp_sprint_realloc_objid_tree(u_char ** buf, size_t * buf_len,
02978                                   size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
02979                                   <span class="keywordtype">int</span> *buf_overflow,
02980                                   <span class="keyword">const</span> oid * objid, size_t objidlen)
02981 {
02982     u_char         *tbuf = NULL, *cp = NULL;
02983     size_t          tbuf_len = 512, tout_len = 0;
02984     <span class="keyword">struct </span>tree    *subtree = tree_head;
02985     size_t          midpoint_offset = 0;
02986     <span class="keywordtype">int</span>             tbuf_overflow = 0;
02987     <span class="keywordtype">int</span>             output_format;
02988 
02989     <span class="keywordflow">if</span> ((tbuf = (u_char *) calloc(tbuf_len, 1)) == NULL) {
02990         tbuf_overflow = 1;
02991     } <span class="keywordflow">else</span> {
02992         *tbuf = <span class="charliteral">'.'</span>;
02993         tout_len = 1;
02994     }
02995 
02996     subtree = _get_realloc_symbol(objid, objidlen, subtree,
02997                                   &amp;tbuf, &amp;tbuf_len, &amp;tout_len,
02998                                   allow_realloc, &amp;tbuf_overflow, NULL,
02999                                   &amp;midpoint_offset);
03000 
03001     <span class="keywordflow">if</span> (tbuf_overflow) {
03002         <span class="keywordflow">if</span> (!*buf_overflow) {
03003             snmp_strcat(buf, buf_len, out_len, allow_realloc, tbuf);
03004             *buf_overflow = 1;
03005         }
03006         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tbuf);
03007         <span class="keywordflow">return</span> subtree;
03008     }
03009 
03010     output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);
03011     <span class="keywordflow">if</span> (0 == output_format) {
03012         output_format = NETSNMP_OID_OUTPUT_MODULE;
03013     }
03014     <span class="keywordflow">switch</span> (output_format) {
03015     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_FULL:
03016     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_NUMERIC:
03017         cp = tbuf;
03018         <span class="keywordflow">break</span>;
03019 
03020     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_SUFFIX:
03021     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_MODULE:
03022         <span class="keywordflow">for</span> (cp = tbuf; *cp; cp++);
03023 
03024         <span class="keywordflow">if</span> (midpoint_offset != 0) {
03025             cp = tbuf + midpoint_offset - 2;    <span class="comment">/*  beyond the '.'  */</span>
03026         } <span class="keywordflow">else</span> {
03027             <span class="keywordflow">while</span> (cp &gt;= tbuf) {
03028                 <span class="keywordflow">if</span> (isalpha(*cp)) {
03029                     <span class="keywordflow">break</span>;
03030                 }
03031                 cp--;
03032             }
03033         }
03034 
03035         <span class="keywordflow">while</span> (cp &gt;= tbuf) {
03036             <span class="keywordflow">if</span> (*cp == <span class="charliteral">'.'</span>) {
03037                 <span class="keywordflow">break</span>;
03038             }
03039             cp--;
03040         }
03041 
03042         cp++;
03043 
03044         <span class="keywordflow">if</span> ((NETSNMP_OID_OUTPUT_MODULE == output_format)
03045             &amp;&amp; cp &gt; tbuf) {
03046             <span class="keywordtype">char</span>            modbuf[256] = { 0 }, *mod =
03047                 module_name(subtree-&gt;modid, modbuf);
03048 
03049             <span class="comment">/*</span>
03050 <span class="comment">             * Don't add the module ID if it's just numeric (i.e. we couldn't look</span>
03051 <span class="comment">             * it up properly.  </span>
03052 <span class="comment">             */</span>
03053 
03054             <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; modbuf[0] != <span class=
"charliteral">'#'</span>) {
03055                 <span class="keywordflow">if</span> (!snmp_strcat
03056                     (buf, buf_len, out_len, allow_realloc,
03057                      (<span class="keyword">const</span> u_char *) mod)
03058                     || !snmp_strcat(buf, buf_len, out_len, allow_realloc,
03059                                     (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"::"</span>)) {
03060                     *buf_overflow = 1;
03061                 }
03062             }
03063         }
03064         <span class="keywordflow">break</span>;
03065 
03066     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_UCD:
03067     {
03068         PrefixListPtr   pp = &amp;mib_prefixes[0];
03069         size_t          ilen, tlen;
03070         <span class="keyword">const</span> <span class="keywordtype">char</span>     *testcp;
03071 
03072         cp = tbuf;
03073         tlen = strlen((<span class="keywordtype">char</span> *) tbuf);
03074 
03075         <span class="keywordflow">while</span> (pp-&gt;str) {
03076             ilen = pp-&gt;len;
03077             testcp = pp-&gt;str;
03078 
03079             <span class="keywordflow">if</span> ((tlen &gt; ilen) &amp;&amp; memcmp(tbuf, testcp, ilen) == 0) {
03080                 cp += (ilen + 1);
03081                 <span class="keywordflow">break</span>;
03082             }
03083             pp++;
03084         }
03085         <span class="keywordflow">break</span>;
03086     }
03087 
03088     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_NONE:
03089     <span class="keywordflow">default</span>:
03090         cp = NULL;
03091     }
03092 
03093     <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp;
03094         !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp)) {
03095         *buf_overflow = 1;
03096     }
03097     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tbuf);
03098     <span class="keywordflow">return</span> subtree;
03099 }
03100 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
03101 
03102 <span class="keywordtype">int</span>
03103 sprint_realloc_objid(u_char ** buf, size_t * buf_len,
03104                      size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
03105                      <span class="keyword">const</span> oid * objid, size_t objidlen)
03106 {
03107     <span class="keywordtype">int</span>             buf_overflow = 0;
03108 
03109     netsnmp_sprint_realloc_objid_tree(buf, buf_len, out_len, allow_realloc,
03110                                       &amp;buf_overflow, objid, objidlen);
03111     <span class="keywordflow">return</span> !buf_overflow;
03112 }
03113 
03114 <span class="keywordtype">int</span>
03115 snprint_objid(<span class="keywordtype">char</span> *buf, size_t buf_len,
03116               <span class="keyword">const</span> oid * objid, size_t objidlen)
03117 {
03118     size_t          out_len = 0;
03119 
03120     <span class="keywordflow">if</span> (sprint_realloc_objid((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
03121                              objid, objidlen)) {
03122         <span class="keywordflow">return</span> (int) out_len;
03123     } <span class="keywordflow">else</span> {
03124         <span class="keywordflow">return</span> -1;
03125     }
03126 }
03127 
03134 <span class="keywordtype">void</span>
<a name="l03135" id="l03135"></a><a class="code" href="group__mib__utilities.html#ga66">03135</a> <a class="code" href=
"group__mib__utilities.html#ga66">print_objid</a>(<span class="keyword">const</span> oid * objid, size_t objidlen)
03136 {                               <span class="comment">/* number of subidentifiers */</span>
03137     <a class="code" href="group__mib__utilities.html#ga67">fprint_objid</a>(stdout, objid, objidlen);
03138 }
03139 
03140 
03148 <span class="keywordtype">void</span>
<a name="l03149" id="l03149"></a><a class="code" href="group__mib__utilities.html#ga67">03149</a> <a class="code" href=
"group__mib__utilities.html#ga67">fprint_objid</a>(FILE * f, <span class="keyword">const</span> oid * objid, size_t objidlen)
03150 {                               <span class="comment">/* number of subidentifiers */</span>
03151     u_char         *buf = NULL;
03152     size_t          buf_len = 256, out_len = 0;
03153     <span class="keywordtype">int</span>             buf_overflow = 0;
03154 
03155     <span class="keywordflow">if</span> ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {
03156         fprintf(f, <span class="stringliteral">"[TRUNCATED]\n"</span>);
03157         <span class="keywordflow">return</span>;
03158     } <span class="keywordflow">else</span> {
03159         netsnmp_sprint_realloc_objid_tree(&amp;buf, &amp;buf_len, &amp;out_len, 1,
03160                                           &amp;buf_overflow, objid, objidlen);
03161         <span class="keywordflow">if</span> (buf_overflow) {
03162             fprintf(f, <span class="stringliteral">"%s [TRUNCATED]\n"</span>, buf);
03163         } <span class="keywordflow">else</span> {
03164             fprintf(f, <span class="stringliteral">"%s\n"</span>, buf);
03165         }
03166     }
03167 
03168     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(buf);
03169 }
03170 
03171 <span class="keywordtype">int</span>
03172 sprint_realloc_variable(u_char ** buf, size_t * buf_len,
03173                         size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
03174                         <span class="keyword">const</span> oid * objid, size_t objidlen,
03175                         <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03176 {
03177     <span class="keywordtype">int</span>             buf_overflow = 0;
03178 
03179 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
03180     <span class="keyword">struct </span>tree    *subtree = tree_head;
03181 
03182     subtree =
03183 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
03184         netsnmp_sprint_realloc_objid_tree(buf, buf_len, out_len,
03185                                           allow_realloc, &amp;buf_overflow,
03186                                           objid, objidlen);
03187 
03188     <span class="keywordflow">if</span> (buf_overflow) {
03189         <span class="keywordflow">return</span> 0;
03190     }
03191     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE)) {
03192         <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {
03193             <span class="keywordflow">if</span> (!snmp_strcat
03194                 (buf, buf_len, out_len, allow_realloc,
03195                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" = "</span>)) {
03196                 <span class="keywordflow">return</span> 0;
03197             }
03198         } <span class="keywordflow">else</span> {
03199             <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
03200                 <span class="keywordflow">if</span> (!snmp_strcat
03201                     (buf, buf_len, out_len, allow_realloc,
03202                      (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)) {
03203                     <span class="keywordflow">return</span> 0;
03204                 }
03205             } <span class="keywordflow">else</span> {
03206                 <span class="keywordflow">if</span> (!snmp_strcat
03207                     (buf, buf_len, out_len, allow_realloc,
03208                      (<span class="keyword">const</span> u_char *) <span class="stringliteral">" = "</span>)) {
03209                     <span class="keywordflow">return</span> 0;
03210                 }
03211             }                   <span class="comment">/* end if-else NETSNMP_DS_LIB_QUICK_PRINT */</span>
03212         }                       <span class="comment">/* end if-else NETSNMP_DS_LIB_QUICKE_PRINT */</span>
03213     } <span class="keywordflow">else</span> {
03214         *out_len = 0;
03215     }
03216 
03217     <span class="keywordflow">if</span> (variable-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == SNMP_NOSUCHOBJECT) {
03218         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
03219                            (<span class="keyword">const</span> u_char *)
03220                            <span class="stringliteral">"No Such Object available on this agent at this OID"</span>);
03221     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (variable-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == SNMP_NOSUCHINSTANCE) {
03222         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
03223                            (<span class="keyword">const</span> u_char *)
03224                            <span class="stringliteral">"No Such Instance currently exists at this OID"</span>);
03225     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (variable-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == SNMP_ENDOFMIBVIEW) {
03226         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
03227                            (<span class="keyword">const</span> u_char *)
03228                            <span class=
"stringliteral">"No more variables left in this MIB View (It is past the end of the MIB tree)"</span>);
03229 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
03230     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (subtree) {
03231         <span class="keyword">const</span> <span class="keywordtype">char</span> *units = NULL;
03232         <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
03233                                     NETSNMP_DS_LIB_DONT_PRINT_UNITS)) {
03234             units = subtree-&gt;units;
03235         }
03236         <span class="keywordflow">if</span> (subtree-&gt;printomat) {
03237             <span class="keywordflow">return</span> (*subtree-&gt;printomat) (buf, buf_len, out_len,
03238                                           allow_realloc, variable,
03239                                           subtree-&gt;enums, subtree-&gt;hint,
03240                                           units);
03241         } <span class="keywordflow">else</span> {
03242             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
03243                                           allow_realloc, variable,
03244                                           subtree-&gt;enums, subtree-&gt;hint,
03245                                           units);
03246         }
03247 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
03248     } <span class="keywordflow">else</span> {
03249         <span class="comment">/*</span>
03250 <span class="comment">         * Handle rare case where tree is empty.  </span>
03251 <span class="comment">         */</span>
03252         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len, allow_realloc,
03253                                       variable, 0, 0, 0);
03254     }
03255 }
03256 
03257 <span class="keywordtype">int</span>
03258 snprint_variable(<span class="keywordtype">char</span> *buf, size_t buf_len,
03259                  <span class="keyword">const</span> oid * objid, size_t objidlen,
03260                  <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03261 {
03262     size_t          out_len = 0;
03263 
03264     <span class="keywordflow">if</span> (sprint_realloc_variable((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
03265                                 objid, objidlen, variable)) {
03266         <span class="keywordflow">return</span> (int) out_len;
03267     } <span class="keywordflow">else</span> {
03268         <span class="keywordflow">return</span> -1;
03269     }
03270 }
03271 
03279 <span class="keywordtype">void</span>
<a name="l03280" id="l03280"></a><a class="code" href="group__mib__utilities.html#ga70">03280</a> <a class="code" href=
"group__mib__utilities.html#ga70">print_variable</a>(<span class="keyword">const</span> oid * objid,
03281                size_t objidlen, <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03282 {
03283     <a class="code" href="group__mib__utilities.html#ga71">fprint_variable</a>(stdout, objid, objidlen, variable);
03284 }
03285 
03286 
03295 <span class="keywordtype">void</span>
<a name="l03296" id="l03296"></a><a class="code" href="group__mib__utilities.html#ga71">03296</a> <a class="code" href=
"group__mib__utilities.html#ga71">fprint_variable</a>(FILE * f,
03297                 <span class="keyword">const</span> oid * objid,
03298                 size_t objidlen, <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03299 {
03300     u_char         *buf = NULL;
03301     size_t          buf_len = 256, out_len = 0;
03302 
03303     <span class="keywordflow">if</span> ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {
03304         fprintf(f, <span class="stringliteral">"[TRUNCATED]\n"</span>);
03305         <span class="keywordflow">return</span>;
03306     } <span class="keywordflow">else</span> {
03307         <span class="keywordflow">if</span> (sprint_realloc_variable(&amp;buf, &amp;buf_len, &amp;out_len, 1,
03308                                     objid, objidlen, variable)) {
03309             fprintf(f, <span class="stringliteral">"%s\n"</span>, buf);
03310         } <span class="keywordflow">else</span> {
03311             fprintf(f, <span class="stringliteral">"%s [TRUNCATED]\n"</span>, buf);
03312         }
03313     }
03314 
03315     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(buf);
03316 }
03317 
03318 <span class="keywordtype">int</span>
03319 sprint_realloc_value(u_char ** buf, size_t * buf_len,
03320                      size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
03321                      <span class="keyword">const</span> oid * objid, size_t objidlen,
03322                      <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03323 {
03324 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
03325     <span class="keyword">struct </span>tree    *subtree = tree_head;
03326 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
03327 
03328     <span class="keywordflow">if</span> (variable-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == SNMP_NOSUCHOBJECT) {
03329         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
03330                            (<span class="keyword">const</span> u_char *)
03331                            <span class="stringliteral">"No Such Object available on this agent at this OID"</span>);
03332     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (variable-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == SNMP_NOSUCHINSTANCE) {
03333         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
03334                            (<span class="keyword">const</span> u_char *)
03335                            <span class="stringliteral">"No Such Instance currently exists at this OID"</span>);
03336     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (variable-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == SNMP_ENDOFMIBVIEW) {
03337         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
03338                            (<span class="keyword">const</span> u_char *)
03339                            <span class=
"stringliteral">"No more variables left in this MIB View (It is past the end of the MIB tree)"</span>);
03340     } <span class="keywordflow">else</span> {
03341 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
03342         <span class="keyword">const</span> <span class="keywordtype">char</span> *units = NULL;
03343         subtree = <a class="code" href="group__mib__utilities.html#ga83">get_tree</a>(objid, objidlen, subtree);
03344         <span class="keywordflow">if</span> (subtree &amp;&amp; !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
03345                                             NETSNMP_DS_LIB_DONT_PRINT_UNITS)) {
03346             units = subtree-&gt;units;
03347         }
03348         <span class="keywordflow">if</span> (subtree &amp;&amp; subtree-&gt;printomat) {
03349             <span class="keywordflow">return</span> (*subtree-&gt;printomat) (buf, buf_len, out_len,
03350                                           allow_realloc, variable,
03351                                           subtree-&gt;enums, subtree-&gt;hint,
03352                                           units);
03353         } <span class="keywordflow">else</span> {
03354             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
03355                                           allow_realloc, variable,
03356                                           subtree-&gt;enums, subtree-&gt;hint,
03357                                           units);
03358         }
03359 <span class="preprocessor">#else</span>
03360         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>(buf, buf_len, out_len,
03361                                       allow_realloc, variable,
03362                                       NULL, NULL, NULL);
03363 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
03364     }
03365 }
03366 
03367 <span class="keywordtype">int</span>
03368 snprint_value(<span class="keywordtype">char</span> *buf, size_t buf_len,
03369               <span class="keyword">const</span> oid * objid, size_t objidlen,
03370               <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03371 {
03372     size_t          out_len = 0;
03373 
03374     <span class="keywordflow">if</span> (sprint_realloc_value((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
03375                              objid, objidlen, variable)) {
03376         <span class="keywordflow">return</span> (int) out_len;
03377     } <span class="keywordflow">else</span> {
03378         <span class="keywordflow">return</span> -1;
03379     }
03380 }
03381 
03382 <span class="keywordtype">void</span>
03383 print_value(<span class="keyword">const</span> oid * objid,
03384             size_t objidlen, <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03385 {
03386     fprint_value(stdout, objid, objidlen, variable);
03387 }
03388 
03389 <span class="keywordtype">void</span>
03390 fprint_value(FILE * f,
03391              <span class="keyword">const</span> oid * objid,
03392              size_t objidlen, <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03393 {
03394     u_char         *buf = NULL;
03395     size_t          buf_len = 256, out_len = 0;
03396 
03397     <span class="keywordflow">if</span> ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {
03398         fprintf(f, <span class="stringliteral">"[TRUNCATED]\n"</span>);
03399         <span class="keywordflow">return</span>;
03400     } <span class="keywordflow">else</span> {
03401         <span class="keywordflow">if</span> (sprint_realloc_value(&amp;buf, &amp;buf_len, &amp;out_len, 1,
03402                                  objid, objidlen, variable)) {
03403             fprintf(f, <span class="stringliteral">"%s\n"</span>, buf);
03404         } <span class="keywordflow">else</span> {
03405             fprintf(f, <span class="stringliteral">"%s [TRUNCATED]\n"</span>, buf);
03406         }
03407     }
03408 
03409     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(buf);
03410 }
03411 
03412 
03420 <span class="keywordtype">int</span>
<a name="l03421" id="l03421"></a><a class="code" href="group__mib__utilities.html#ga76">03421</a> <a class="code" href=
"group__mib__utilities.html#ga76">build_oid_segment</a>(<a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var)
03422 {
03423     <span class="keywordtype">int</span>             i;
03424 
03425     <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a> &amp;&amp; var-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a> != var-&gt;<a class="code" href="structvariable__list.html#o6">name_loc</a>)
03426         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(var-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>);
03427     <span class="keywordflow">switch</span> (var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>) {
03428     <span class="keywordflow">case</span> ASN_INTEGER:
03429     <span class="keywordflow">case</span> ASN_COUNTER:
03430     <span class="keywordflow">case</span> ASN_GAUGE:
03431     <span class="keywordflow">case</span> ASN_TIMETICKS:
03432         var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = 1;
03433         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>;
03434         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[0] = *(var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
03435         <span class="keywordflow">break</span>;
03436 
03437     <span class="keywordflow">case</span> ASN_IPADDRESS:
03438         var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = 4;
03439         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>;
03440         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[0] =
03441             (((<span class="keywordtype">unsigned</span> int) *(var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer)) &amp; 0xff000000) &gt;&gt; 24;
03442         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[1] =
03443             (((<span class="keywordtype">unsigned</span> int) *(var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer)) &amp; 0x00ff0000) &gt;&gt; 16;
03444         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[2] =
03445             (((<span class="keywordtype">unsigned</span> int) *(var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer)) &amp; 0x0000ff00) &gt;&gt; 8;
03446         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[3] =
03447             (((<span class="keywordtype">unsigned</span> int) *(var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer)) &amp; 0x000000ff);
03448         <span class="keywordflow">break</span>;
03449         
03450     <span class="keywordflow">case</span> ASN_PRIV_IMPLIED_OBJECT_ID:
03451         var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> / <span class="keyword">sizeof</span>(oid);
03452         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> &gt; (<span class="keyword">sizeof</span>(var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>) / <span class="keyword">sizeof</span>(oid)))
03453             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = (oid *) malloc(<span class=
"keyword">sizeof</span>(oid) * (var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>));
03454         <span class="keywordflow">else</span>
03455             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>;
03456         <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> == NULL)
03457             <span class="keywordflow">return</span> SNMPERR_GENERR;
03458 
03459         <span class="keywordflow">for</span> (i = 0; i &lt; (int) var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a>; i++)
03460             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[i] = var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid[i];
03461         <span class="keywordflow">break</span>;
03462 
03463     <span class="keywordflow">case</span> ASN_OBJECT_ID:
03464         var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> / <span class="keyword">sizeof</span>(oid) + 1;
03465         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> &gt; (<span class="keyword">sizeof</span>(var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>) / <span class="keyword">sizeof</span>(oid)))
03466             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = (oid *) malloc(<span class=
"keyword">sizeof</span>(oid) * (var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>));
03467         <span class="keywordflow">else</span>
03468             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>;
03469         <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> == NULL)
03470             <span class="keywordflow">return</span> SNMPERR_GENERR;
03471 
03472         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[0] = var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> - 1;
03473         <span class="keywordflow">for</span> (i = 0; i &lt; (int) var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> - 1; i++)
03474             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[i + 1] = var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid[i];
03475         <span class="keywordflow">break</span>;
03476 
03477     <span class="keywordflow">case</span> ASN_PRIV_IMPLIED_OCTET_STR:
03478         var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>;
03479         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> &gt; (<span class="keyword">sizeof</span>(var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>) / <span class="keyword">sizeof</span>(oid)))
03480             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = (oid *) malloc(<span class=
"keyword">sizeof</span>(oid) * (var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>));
03481         <span class="keywordflow">else</span>
03482             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>;
03483         <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> == NULL)
03484             <span class="keywordflow">return</span> SNMPERR_GENERR;
03485 
03486         <span class="keywordflow">for</span> (i = 0; i &lt; (int) var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>; i++)
03487             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[i] = (oid) var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string[i];
03488         <span class="keywordflow">break</span>;
03489 
03490     <span class="keywordflow">case</span> ASN_OPAQUE:
03491     <span class="keywordflow">case</span> ASN_OCTET_STR:
03492         var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> + 1;
03493         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> &gt; (<span class="keyword">sizeof</span>(var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>) / <span class="keyword">sizeof</span>(oid)))
03494             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = (oid *) malloc(<span class=
"keyword">sizeof</span>(oid) * (var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>));
03495         <span class="keywordflow">else</span>
03496             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>;
03497         <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> == NULL)
03498             <span class="keywordflow">return</span> SNMPERR_GENERR;
03499 
03500         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[0] = (oid) var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>;
03501         <span class="keywordflow">for</span> (i = 0; i &lt; (int) var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>; i++)
03502             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[i + 1] = (oid) var-&gt;<a class="code"
href="structvariable__list.html#o4">val</a>.string[i];
03503         <span class="keywordflow">break</span>;
03504 
03505     <span class="keywordflow">default</span>:
03506         DEBUGMSGTL((<span class="stringliteral">"build_oid_segment"</span>,
03507                     <span class="stringliteral">"invalid asn type: %d\n"</span>, var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>));
03508         <span class="keywordflow">return</span> SNMPERR_GENERR;
03509     }
03510 
03511     <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> &gt; MAX_OID_LEN) {
03512         DEBUGMSGTL((<span class="stringliteral">"build_oid_segment"</span>,
03513                     <span class="stringliteral">"Something terribly wrong, namelen = %d\n"</span>,
03514                     var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>));
03515         <span class="keywordflow">return</span> SNMPERR_GENERR;
03516     }
03517 
03518     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03519 }
03520 
03521 
03522 <span class="keywordtype">int</span>
03523 build_oid_noalloc(oid * in, size_t in_len, size_t * out_len,
03524                   oid * prefix, size_t prefix_len,
03525                   <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * indexes)
03526 {
03527     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *var;
03528 
03529     <span class="keywordflow">if</span> (prefix) {
03530         <span class="keywordflow">if</span> (in_len &lt; prefix_len)
03531             <span class="keywordflow">return</span> SNMPERR_GENERR;
03532         memcpy(in, prefix, prefix_len * <span class="keyword">sizeof</span>(oid));
03533         *out_len = prefix_len;
03534     } <span class="keywordflow">else</span> {
03535         *out_len = 0;
03536     }
03537 
03538     <span class="keywordflow">for</span> (var = indexes; var != NULL; var = var-&gt;<a class="code" href=
"structvariable__list.html#o0">next_variable</a>) {
03539         <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga76">build_oid_segment</a>(var) != SNMPERR_SUCCESS)
03540             <span class="keywordflow">return</span> SNMPERR_GENERR;
03541         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> + *out_len &lt;= in_len) {
03542             memcpy(&amp;(in[*out_len]), var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>,
03543                    <span class="keyword">sizeof</span>(oid) * var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a>);
03544             *out_len += var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>;
03545         } <span class="keywordflow">else</span> {
03546             <span class="keywordflow">return</span> SNMPERR_GENERR;
03547         }
03548     }
03549 
03550     DEBUGMSGTL((<span class="stringliteral">"build_oid_noalloc"</span>, <span class="stringliteral">"generated: "</span>));
03551     DEBUGMSGOID((<span class="stringliteral">"build_oid_noalloc"</span>, in, *out_len));
03552     DEBUGMSG((<span class="stringliteral">"build_oid_noalloc"</span>, <span class="stringliteral">"\n"</span>));
03553     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03554 }
03555 
03556 <span class="keywordtype">int</span>
<a name="l03557" id="l03557"></a><a class="code" href="group__mib__utilities.html#ga78">03557</a> <a class="code" href=
"group__mib__utilities.html#ga78">build_oid</a>(oid ** out, size_t * out_len,
03558           oid * prefix, size_t prefix_len, <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * indexes)
03559 {
03560     oid             tmpout[MAX_OID_LEN];
03561 
03562     <span class="comment">/*</span>
03563 <span class="comment">     * xxx-rks: inefficent. try only building segments to find index len:</span>
03564 <span class="comment">     *   for (var = indexes; var != NULL; var = var-&gt;next_variable) {</span>
03565 <span class="comment">     *      if (build_oid_segment(var) != SNMPERR_SUCCESS)</span>
03566 <span class="comment">     *         return SNMPERR_GENERR;</span>
03567 <span class="comment">     *      *out_len += var-&gt;name_length;</span>
03568 <span class="comment">     *</span>
03569 <span class="comment">     * then see if it fits in existing buffer, or realloc buffer.</span>
03570 <span class="comment">     */</span>
03571     <span class="keywordflow">if</span> (build_oid_noalloc(tmpout, <span class="keyword">sizeof</span>(tmpout), out_len,
03572                           prefix, prefix_len, indexes) != SNMPERR_SUCCESS)
03573         <span class="keywordflow">return</span> SNMPERR_GENERR;
03574 
03576     snmp_clone_mem((<span class="keywordtype">void</span> **) out, (<span class=
"keywordtype">void</span> *) tmpout, *out_len * <span class="keyword">sizeof</span>(oid));
03577 
03578     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03579 }
03580 
03581 <span class="comment">/*</span>
03582 <span class="comment"> * vblist_out must contain a pre-allocated string of variables into</span>
03583 <span class="comment"> * which indexes can be extracted based on the previously existing</span>
03584 <span class="comment"> * types in the variable chain</span>
03585 <span class="comment"> * returns:</span>
03586 <span class="comment"> * SNMPERR_GENERR  on error</span>
03587 <span class="comment"> * SNMPERR_SUCCESS on success</span>
03588 <span class="comment"> */</span>
03589 
03590 <span class="keywordtype">int</span>
03591 parse_oid_indexes(oid * oidIndex, size_t oidLen,
03592                   <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * data)
03593 {
03594     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *var = data;
03595 
03596     <span class="keywordflow">while</span> (var &amp;&amp; oidLen &gt; 0) {
03597 
03598         <span class="keywordflow">if</span> (parse_one_oid_index(&amp;oidIndex, &amp;oidLen, var, 0) !=
03599             SNMPERR_SUCCESS)
03600             <span class="keywordflow">break</span>;
03601 
03602         var = var-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>;
03603     }
03604 
03605     <span class="keywordflow">if</span> (var != NULL || oidLen != 0)
03606         <span class="keywordflow">return</span> SNMPERR_GENERR;
03607     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03608 }
03609 
03610 
03611 <span class="keywordtype">int</span>
03612 parse_one_oid_index(oid ** oidStart, size_t * oidLen,
03613                     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * data, <span class=
"keywordtype">int</span> complete)
03614 {
03615     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *var = data;
03616     oid             tmpout[MAX_OID_LEN];
03617     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    i;
03618     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    uitmp = 0;
03619 
03620     oid            *oidIndex = *oidStart;
03621 
03622     <span class="keywordflow">if</span> (var == NULL || ((*oidLen == 0) &amp;&amp; (complete == 0)))
03623         <span class="keywordflow">return</span> SNMPERR_GENERR;
03624     <span class="keywordflow">else</span> {
03625         <span class="keywordflow">switch</span> (var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>) {
03626         <span class="keywordflow">case</span> ASN_INTEGER:
03627         <span class="keywordflow">case</span> ASN_COUNTER:
03628         <span class="keywordflow">case</span> ASN_GAUGE:
03629         <span class="keywordflow">case</span> ASN_TIMETICKS:
03630             <span class="keywordflow">if</span> (*oidLen) {
03631                 snmp_set_var_value(var, (u_char *) oidIndex++,
03632                                    <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
03633                 --(*oidLen);
03634             } <span class="keywordflow">else</span> {
03635                 snmp_set_var_value(var, (u_char *) oidLen, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
03636             }
03637             DEBUGMSGTL((<span class="stringliteral">"parse_oid_indexes"</span>,
03638                         <span class="stringliteral">"Parsed int(%d): %d\n"</span>, var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>,
03639                         *var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.integer));
03640             <span class="keywordflow">break</span>;
03641 
03642         <span class="keywordflow">case</span> ASN_IPADDRESS:
03643             <span class="keywordflow">if</span> ((4 &gt; *oidLen) &amp;&amp; (complete == 0))
03644                 <span class="keywordflow">return</span> SNMPERR_GENERR;
03645             
03646             <span class="keywordflow">for</span> (i = 0; i &lt; 4 &amp;&amp; i &lt; *oidLen; ++i) {
03647                 <span class="keywordflow">if</span> (oidIndex[i] &gt; 255) {
03648                     DEBUGMSGTL((<span class="stringliteral">"parse_oid_indexes"</span>,
03649                                 <span class="stringliteral">"illegal oid in index: %d\n"</span>, oidIndex[0]));
03650                         <span class="keywordflow">return</span> SNMPERR_GENERR;  <span class=
"comment">/* sub-identifier too large */</span>
03651                     }
03652                     uitmp = uitmp + (oidIndex[i] &lt;&lt; (8*(3-i)));
03653                 }
03654             <span class="keywordflow">if</span> (4 &gt; (int) (*oidLen)) {
03655                 oidIndex += *oidLen;
03656                 (*oidLen) = 0;
03657             } <span class="keywordflow">else</span> {
03658                 oidIndex += 4;
03659                 (*oidLen) -= 4;
03660             }
03661             uitmp = htonl(uitmp); <span class="comment">/* put it in proper order for byte copies */</span>
03662             uitmp = 
03663                 snmp_set_var_value(var, (u_char *) &amp;uitmp, 4);
03664             DEBUGMSGTL((<span class="stringliteral">"parse_oid_indexes"</span>,
03665                         <span class="stringliteral">"Parsed ipaddr(%d): %d.%d.%d.%d\n"</span>, var-&gt;<a class="code"
href="structvariable__list.html#o3">type</a>,
03666                         var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[0], var-&gt;<a class=
"code" href="structvariable__list.html#o4">val</a>.string[1],
03667                         var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[2], var-&gt;<a class=
"code" href="structvariable__list.html#o4">val</a>.string[3]));
03668             <span class="keywordflow">break</span>;
03669 
03670         <span class="keywordflow">case</span> ASN_OBJECT_ID:
03671         <span class="keywordflow">case</span> ASN_PRIV_IMPLIED_OBJECT_ID:
03672             <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == ASN_PRIV_IMPLIED_OBJECT_ID) {
03673                 uitmp = *oidLen;
03674             } <span class="keywordflow">else</span> {
03675                 <span class="keywordflow">if</span> (*oidLen) {
03676                     uitmp = *oidIndex++;
03677                     --(*oidLen);
03678                 } <span class="keywordflow">else</span> {
03679                     uitmp = 0;
03680                 }
03681                 <span class="keywordflow">if</span> ((uitmp &gt; *oidLen) &amp;&amp; (complete == 0))
03682                     <span class="keywordflow">return</span> SNMPERR_GENERR;
03683             }
03684 
03685             <span class="keywordflow">if</span> (uitmp &gt; MAX_OID_LEN)
03686                 <span class="keywordflow">return</span> SNMPERR_GENERR;  <span class=
"comment">/* too big and illegal */</span>
03687 
03688             <span class="keywordflow">if</span> (uitmp &gt; *oidLen) {
03689                 memcpy(tmpout, oidIndex, <span class="keyword">sizeof</span>(oid) * (*oidLen));
03690                 memset(&amp;tmpout[*oidLen], 0x00,
03691                        <span class="keyword">sizeof</span>(oid) * (uitmp - *oidLen));
03692                 snmp_set_var_value(var, (u_char *) tmpout,
03693                                    <span class="keyword">sizeof</span>(oid) * uitmp);
03694                 oidIndex += *oidLen;
03695                 (*oidLen) = 0;
03696             } <span class="keywordflow">else</span> {
03697                 snmp_set_var_value(var, (u_char *) oidIndex,
03698                                    <span class="keyword">sizeof</span>(oid) * uitmp);
03699                 oidIndex += uitmp;
03700                 (*oidLen) -= uitmp;
03701             }
03702 
03703             DEBUGMSGTL((<span class="stringliteral">"parse_oid_indexes"</span>, <span class=
"stringliteral">"Parsed oid: "</span>));
03704             DEBUGMSGOID((<span class="stringliteral">"parse_oid_indexes"</span>,
03705                          var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid, var-&gt;<a class="code"
href="structvariable__list.html#o5">val_len</a> / <span class="keyword">sizeof</span>(oid)));
03706             DEBUGMSG((<span class="stringliteral">"parse_oid_indexes"</span>, <span class="stringliteral">"\n"</span>));
03707             <span class="keywordflow">break</span>;
03708 
03709         <span class="keywordflow">case</span> ASN_OPAQUE:
03710         <span class="keywordflow">case</span> ASN_OCTET_STR:
03711         <span class="keywordflow">case</span> ASN_PRIV_IMPLIED_OCTET_STR:
03712             <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == ASN_PRIV_IMPLIED_OCTET_STR) {
03713                 uitmp = *oidLen;
03714             } <span class="keywordflow">else</span> {
03715                 <span class="keywordflow">if</span> (*oidLen) {
03716                     uitmp = *oidIndex++;
03717                     --(*oidLen);
03718                 } <span class="keywordflow">else</span> {
03719                     uitmp = 0;
03720                 }
03721                 <span class="keywordflow">if</span> ((uitmp &gt; *oidLen) &amp;&amp; (complete == 0))
03722                     <span class="keywordflow">return</span> SNMPERR_GENERR;
03723             }
03724 
03725             <span class="comment">/*</span>
03726 <span class="comment">             * we handle this one ourselves since we don't have</span>
03727 <span class="comment">             * pre-allocated memory to copy from using</span>
03728 <span class="comment">             * snmp_set_var_value() </span>
03729 <span class="comment">             */</span>
03730 
03731             <span class="keywordflow">if</span> (uitmp == 0)
03732                 <span class="keywordflow">break</span>;          <span class=
"comment">/* zero length strings shouldn't malloc */</span>
03733 
03734             <span class="keywordflow">if</span> (uitmp &gt; MAX_OID_LEN)
03735                 <span class="keywordflow">return</span> SNMPERR_GENERR;  <span class=
"comment">/* too big and illegal */</span>
03736 
03737             <span class="comment">/*</span>
03738 <span class="comment">             * malloc by size+1 to allow a null to be appended. </span>
03739 <span class="comment">             */</span>
03740             var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = uitmp;
03741             var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string = (u_char *) calloc(1, uitmp + 1);
03742             <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string == NULL)
03743                 <span class="keywordflow">return</span> SNMPERR_GENERR;
03744 
03745             <span class="keywordflow">if</span> (uitmp &gt; (int) (*oidLen)) {
03746                 <span class="keywordflow">for</span> (i = 0; i &lt; *oidLen; ++i)
03747                     var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[i] = (u_char) * oidIndex++;
03748                 <span class="keywordflow">for</span> (i = 0; i &lt; uitmp; ++i)
03749                     var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[i] = <span class=
"charliteral">'\0'</span>;
03750                 (*oidLen) = 0;
03751             } <span class="keywordflow">else</span> {
03752                 <span class="keywordflow">for</span> (i = 0; i &lt; uitmp; ++i)
03753                     var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[i] = (u_char) * oidIndex++;
03754                 (*oidLen) -= uitmp;
03755             }
03756             var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[uitmp] = <span class=
"charliteral">'\0'</span>;
03757 
03758             DEBUGMSGTL((<span class="stringliteral">"parse_oid_indexes"</span>,
03759                         <span class="stringliteral">"Parsed str(%d): %s\n"</span>, var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>,
03760                         var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string));
03761             <span class="keywordflow">break</span>;
03762 
03763         <span class="keywordflow">default</span>:
03764             DEBUGMSGTL((<span class="stringliteral">"parse_oid_indexes"</span>,
03765                         <span class="stringliteral">"invalid asn type: %d\n"</span>, var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>));
03766             <span class="keywordflow">return</span> SNMPERR_GENERR;
03767         }
03768     }
03769     (*oidStart) = oidIndex;
03770     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03771 }
03772 
03773 <span class="comment">/*</span>
03774 <span class="comment"> * dump_realloc_oid_to_inetaddress:</span>
03775 <span class="comment"> *   return 0 for failure,</span>
03776 <span class="comment"> *   return 1 for success,</span>
03777 <span class="comment"> *   return 2 for not handled</span>
03778 <span class="comment"> */</span>
03779 
03780 <span class="keywordtype">int</span> 
03781 dump_realloc_oid_to_inetaddress(<span class="keyword">const</span> <span class=
"keywordtype">int</span> addr_type, <span class="keyword">const</span> oid * objid, size_t objidlen, 
03782                                 u_char ** buf, size_t * buf_len,
03783                                 size_t * out_len, <span class="keywordtype">int</span> allow_realloc, 
03784                                 <span class="keywordtype">char</span> quotechar)
03785 {
03786     <span class="keywordflow">if</span> (buf) {
03787         <span class="keywordtype">int</span>             i, len;
03788         <span class="keywordtype">char</span>            intbuf[64], * p;
03789         <span class="keywordtype">int</span>             zone;
03790 
03791         memset(intbuf, 0, 64);
03792 
03793         p = intbuf;
03794         *p = quotechar;
03795         p++;
03796         <span class="keywordflow">switch</span> (addr_type) {
03797             <span class="keywordflow">case</span> IPV4:
03798             <span class="keywordflow">case</span> IPV4Z:
03799                 <span class="keywordflow">if</span> ((addr_type == IPV4  &amp;&amp; objidlen != 4) ||
03800                     (addr_type == IPV4Z &amp;&amp; objidlen != 8))
03801                     <span class="keywordflow">return</span> 2;
03802 
03803                 len = sprintf(p, <span class=
"stringliteral">"%lu.%lu.%lu.%lu"</span>, objid[0], objid[1], objid[2], objid[3]);
03804                 p += len;
03805                 <span class="keywordflow">if</span> (addr_type == IPV4Z) {
03806                     zone = ntohl(*((<span class="keywordtype">int</span> *) &amp;(objid[4])));
03807                     len = sprintf(p, <span class="stringliteral">"%%%lu"</span>, zone);
03808                     p += len;
03809                 }
03810 
03811                 <span class="keywordflow">break</span>;
03812 
03813             <span class="keywordflow">case</span> IPV6:
03814             <span class="keywordflow">case</span> IPV6Z:
03815                 <span class="keywordflow">if</span> ((addr_type == IPV6 &amp;&amp; objidlen != 16) ||
03816                     (addr_type == IPV6Z &amp;&amp; objidlen != 20))
03817                     <span class="keywordflow">return</span> 2;
03818 
03819                 len = 0;
03820                 <span class="keywordflow">for</span> (i = 0; i &lt; 16; i ++) {
03821                     len = snprintf(p, 4, <span class="stringliteral">"%02x:"</span>, objid[i]);
03822                     p += len;
03823                 }
03824                 p-- ; <span class="comment">/* do not include the last ':' */</span>
03825 
03826                 <span class="keywordflow">if</span> (addr_type == IPV6Z) {
03827                     zone = ntohl(*((<span class="keywordtype">int</span> *) &amp;(objid[16])));
03828                     len = sprintf(p, <span class="stringliteral">"%%%lu"</span>, zone);
03829                     p += len;
03830                 }
03831 
03832                 <span class="keywordflow">break</span>;
03833 
03834             <span class="keywordflow">case</span> DNS:
03835             <span class="keywordflow">default</span>: 
03836                 <span class="comment">/* DNS can just be handled by dump_realloc_oid_to_string() */</span>
03837                 <span class="keywordflow">return</span> 2;
03838         }
03839 
03840         *p = quotechar;
03841 
03842         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc, 
03843                                                (<span class="keyword">const</span> u_char *) intbuf);
03844     }
03845     <span class="keywordflow">return</span> 1;
03846 }
03847 
03848 <span class="keywordtype">int</span>
03849 dump_realloc_oid_to_string(<span class="keyword">const</span> oid * objid, size_t objidlen,
03850                            u_char ** buf, size_t * buf_len,
03851                            size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
03852                            <span class="keywordtype">char</span> quotechar)
03853 {
03854     <span class="keywordflow">if</span> (buf) {
03855         <span class="keywordtype">int</span>             i, alen;
03856 
03857         <span class="keywordflow">for</span> (i = 0, alen = 0; i &lt; (int) objidlen; i++) {
03858             oid             tst = objid[i];
03859             <span class="keywordflow">if</span> ((tst &gt; 254) || (!isprint(tst))) {
03860                 tst = (oid) <span class="charliteral">'.'</span>;
03861             }
03862 
03863             <span class="keywordflow">if</span> (alen == 0) {
03864                 <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {
03865                     <span class="keywordflow">while</span> ((*out_len + 2) &gt;= *buf_len) {
03866                         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
03867                             <span class="keywordflow">return</span> 0;
03868                         }
03869                     }
03870                     *(*buf + *out_len) = <span class="charliteral">'\\'</span>;
03871                     (*out_len)++;
03872                 }
03873                 <span class="keywordflow">while</span> ((*out_len + 2) &gt;= *buf_len) {
03874                     <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
03875                         <span class="keywordflow">return</span> 0;
03876                     }
03877                 }
03878                 *(*buf + *out_len) = quotechar;
03879                 (*out_len)++;
03880             }
03881 
03882             <span class="keywordflow">while</span> ((*out_len + 2) &gt;= *buf_len) {
03883                 <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
03884                     <span class="keywordflow">return</span> 0;
03885                 }
03886             }
03887             *(*buf + *out_len) = (char) tst;
03888             (*out_len)++;
03889             alen++;
03890         }
03891 
03892         <span class="keywordflow">if</span> (alen) {
03893             <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {
03894                 <span class="keywordflow">while</span> ((*out_len + 2) &gt;= *buf_len) {
03895                     <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
03896                         <span class="keywordflow">return</span> 0;
03897                     }
03898                 }
03899                 *(*buf + *out_len) = <span class="charliteral">'\\'</span>;
03900                 (*out_len)++;
03901             }
03902             <span class="keywordflow">while</span> ((*out_len + 2) &gt;= *buf_len) {
03903                 <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
03904                     <span class="keywordflow">return</span> 0;
03905                 }
03906             }
03907             *(*buf + *out_len) = quotechar;
03908             (*out_len)++;
03909         }
03910 
03911         *(*buf + *out_len) = <span class="charliteral">'\0'</span>;
03912     }
03913 
03914     <span class="keywordflow">return</span> 1;
03915 }
03916 
03917 <span class="keywordtype">void</span>
03918 _oid_finish_printing(<span class="keyword">const</span> oid * objid, size_t objidlen,
03919                      u_char ** buf, size_t * buf_len, size_t * out_len,
03920                      <span class="keywordtype">int</span> allow_realloc, <span class=
"keywordtype">int</span> *buf_overflow) {
03921     <span class="keywordtype">char</span>            intbuf[64];
03922     <span class="keywordflow">if</span> (*buf != NULL &amp;&amp; *(*buf + *out_len - 1) != <span class=
"charliteral">'.'</span>) {
03923         <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
03924                                            allow_realloc,
03925                                            (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"."</span>)) {
03926             *buf_overflow = 1;
03927         }
03928     }
03929 
03930     <span class="keywordflow">while</span> (objidlen-- &gt; 0) {    <span class=
"comment">/* output rest of name, uninterpreted */</span>
03931         sprintf(intbuf, <span class="stringliteral">"%lu."</span>, *objid++);
03932         <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
03933                                            allow_realloc,
03934                                            (<span class="keyword">const</span> u_char *) intbuf)) {
03935             *buf_overflow = 1;
03936         }
03937     }
03938 
03939     <span class="keywordflow">if</span> (*buf != NULL) {
03940         *(*buf + *out_len - 1) = <span class="charliteral">'\0'</span>;  <span class=
"comment">/* remove trailing dot */</span>
03941         *out_len = *out_len - 1;
03942     }
03943 }
03944 
03945 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
03946 <span class="keyword">static</span> <span class="keyword">struct </span>tree *
03947 _get_realloc_symbol(<span class="keyword">const</span> oid * objid, size_t objidlen,
03948                     <span class="keyword">struct</span> tree *subtree,
03949                     u_char ** buf, size_t * buf_len, size_t * out_len,
03950                     <span class="keywordtype">int</span> allow_realloc, <span class="keywordtype">int</span> *buf_overflow,
03951                     <span class="keyword">struct</span> index_list *in_dices, size_t * end_of_known)
03952 {
03953     <span class="keyword">struct </span>tree    *return_tree = NULL;
03954     <span class="keywordtype">int</span>             extended_index =
03955         netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX);
03956     <span class="keywordtype">int</span>             output_format =
03957         netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);
03958     <span class="keywordtype">char</span>            intbuf[64];
03959 
03960     <span class="keywordflow">if</span> (!objid || !buf) {
03961         <span class="keywordflow">return</span> NULL;
03962     }
03963 
03964     <span class="keywordflow">for</span> (; subtree; subtree = subtree-&gt;next_peer) {
03965         <span class="keywordflow">if</span> (*objid == subtree-&gt;subid) {
03966             <span class=
"keywordflow">while</span> (subtree-&gt;next_peer &amp;&amp; subtree-&gt;next_peer-&gt;subid == *objid)
03967                 subtree = subtree-&gt;next_peer;
03968             <span class="keywordflow">if</span> (subtree-&gt;indexes) {
03969                 in_dices = subtree-&gt;indexes;
03970             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (subtree-&gt;augments) {
03971                 <span class="keyword">struct </span>tree    *tp2 =
03972                     find_tree_node(subtree-&gt;augments, -1);
03973                 <span class="keywordflow">if</span> (tp2) {
03974                     in_dices = tp2-&gt;indexes;
03975                 }
03976             }
03977 
03978             <span class="keywordflow">if</span> (!strncmp(subtree-&gt;label, ANON, ANON_LEN) ||
03979                 (NETSNMP_OID_OUTPUT_NUMERIC == output_format)) {
03980                 sprintf(intbuf, <span class="stringliteral">"%lu"</span>, subtree-&gt;subid);
03981                 <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
03982                                                    allow_realloc,
03983                                                    (<span class="keyword">const</span> u_char *)
03984                                                    intbuf)) {
03985                     *buf_overflow = 1;
03986                 }
03987             } <span class="keywordflow">else</span> {
03988                 <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
03989                                                    allow_realloc,
03990                                                    (<span class="keyword">const</span> u_char *)
03991                                                    subtree-&gt;label)) {
03992                     *buf_overflow = 1;
03993                 }
03994             }
03995 
03996             <span class="keywordflow">if</span> (objidlen &gt; 1) {
03997                 <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
03998                                                    allow_realloc,
03999                                                    (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"."</span>)) {
04000                     *buf_overflow = 1;
04001                 }
04002 
04003                 return_tree = _get_realloc_symbol(objid + 1, objidlen - 1,
04004                                                   subtree-&gt;child_list,
04005                                                   buf, buf_len, out_len,
04006                                                   allow_realloc,
04007                                                   buf_overflow, in_dices,
04008                                                   end_of_known);
04009             }
04010 
04011             <span class="keywordflow">if</span> (return_tree != NULL) {
04012                 <span class="keywordflow">return</span> return_tree;
04013             } <span class="keywordflow">else</span> {
04014                 <span class="keywordflow">return</span> subtree;
04015             }
04016         }
04017     }
04018 
04019 
04020     <span class="keywordflow">if</span> (end_of_known) {
04021         *end_of_known = *out_len;
04022     }
04023 
04024     <span class="comment">/*</span>
04025 <span class="comment">     * Subtree not found.  </span>
04026 <span class="comment">     */</span>
04027 
04028     <span class="keywordflow">while</span> (in_dices &amp;&amp; (objidlen &gt; 0) &amp;&amp;
04029            (NETSNMP_OID_OUTPUT_NUMERIC != output_format) &amp;&amp;
04030            !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS)) {
04031         size_t          numids;
04032         <span class="keyword">struct </span>tree    *tp;
04033 
04034         tp = find_tree_node(in_dices-&gt;ilabel, -1);
04035 
04036         <span class="keywordflow">if</span> (!tp) {
04037             <span class="comment">/*</span>
04038 <span class="comment">             * Can't find an index in the mib tree.  Bail.  </span>
04039 <span class="comment">             */</span>
04040             <span class="keywordflow">goto</span> finish_it;
04041         }
04042 
04043         <span class="keywordflow">if</span> (extended_index) {
04044             <span class="keywordflow">if</span> (*buf != NULL &amp;&amp; *(*buf + *out_len - 1) == <span class=
"charliteral">'.'</span>) {
04045                 (*out_len)--;
04046             }
04047             <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04048                                                allow_realloc,
04049                                                (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"["</span>)) {
04050                 *buf_overflow = 1;
04051             }
04052         }
04053 
04054         <span class="keywordflow">switch</span> (tp-&gt;type) {
04055         <span class="keywordflow">case</span> TYPE_OCTETSTR:
04056             <span class="keywordflow">if</span> (extended_index &amp;&amp; tp-&gt;hint) {
04057                 <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> var;
04058                 u_char          buffer[1024];
04059                 <span class="keywordtype">int</span>             i;
04060 
04061                 memset(&amp;var, 0, <span class="keyword">sizeof</span> var);
04062                 <span class="keywordflow">if</span> (in_dices-&gt;isimplied) {
04063                     numids = objidlen;
04064                     <span class="keywordflow">if</span> (numids &gt; objidlen)
04065                         <span class="keywordflow">goto</span> finish_it;
04066                 } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (tp-&gt;ranges &amp;&amp; !tp-&gt;ranges-&gt;next
04067                            &amp;&amp; tp-&gt;ranges-&gt;low == tp-&gt;ranges-&gt;high) {
04068                     numids = tp-&gt;ranges-&gt;low;
04069                     <span class="keywordflow">if</span> (numids &gt; objidlen)
04070                         <span class="keywordflow">goto</span> finish_it;
04071                 } <span class="keywordflow">else</span> {
04072                     numids = *objid;
04073                     <span class="keywordflow">if</span> (numids &gt;= objidlen)
04074                         <span class="keywordflow">goto</span> finish_it;
04075                     objid++;
04076                     objidlen--;
04077                 }
04078                 <span class="keywordflow">if</span> (numids &gt; objidlen)
04079                     <span class="keywordflow">goto</span> finish_it;
04080                 <span class="keywordflow">for</span> (i = 0; i &lt; (int) numids; i++)
04081                     buffer[i] = (u_char) objid[i];
04082                 var.<a class="code" href="structvariable__list.html#o3">type</a> = ASN_OCTET_STR;
04083                 var.<a class="code" href="structvariable__list.html#o4">val</a>.string = buffer;
04084                 var.<a class="code" href="structvariable__list.html#o5">val_len</a> = numids;
04085                 <span class="keywordflow">if</span> (!*buf_overflow) {
04086                     <span class="keywordflow">if</span> (!<a class="code" href=
"group__mib__utilities.html#ga28">sprint_realloc_octet_string</a>(buf, buf_len, out_len,
04087                                                      allow_realloc, &amp;var,
04088                                                      NULL, tp-&gt;hint,
04089                                                      NULL)) {
04090                         *buf_overflow = 1;
04091                     }
04092                 }
04093             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in_dices-&gt;isimplied) {
04094                 numids = objidlen;
04095                 <span class="keywordflow">if</span> (numids &gt; objidlen)
04096                     <span class="keywordflow">goto</span> finish_it;
04097 
04098                 <span class="keywordflow">if</span> (!*buf_overflow) {
04099                     <span class="keywordflow">if</span> (!dump_realloc_oid_to_string
04100                         (objid, numids, buf, buf_len, out_len,
04101                          allow_realloc, <span class="charliteral">'\''</span>)) {
04102                         *buf_overflow = 1;
04103                     }
04104                 }
04105             } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (tp-&gt;ranges &amp;&amp; !tp-&gt;ranges-&gt;next
04106                        &amp;&amp; tp-&gt;ranges-&gt;low == tp-&gt;ranges-&gt;high) {
04107                 <span class="comment">/*</span>
04108 <span class="comment">                 * a fixed-length octet string </span>
04109 <span class="comment">                 */</span>
04110                 numids = tp-&gt;ranges-&gt;low;
04111                 <span class="keywordflow">if</span> (numids &gt; objidlen)
04112                     <span class="keywordflow">goto</span> finish_it;
04113 
04114                 <span class="keywordflow">if</span> (!*buf_overflow) {
04115                     <span class="keywordflow">if</span> (!dump_realloc_oid_to_string
04116                         (objid, numids, buf, buf_len, out_len,
04117                          allow_realloc, <span class="charliteral">'\''</span>)) {
04118                         *buf_overflow = 1;
04119                     }
04120                 }
04121             } <span class="keywordflow">else</span> {
04122                 numids = (size_t) * objid + 1;
04123                 <span class="keywordflow">if</span> (numids &gt; objidlen)
04124                     <span class="keywordflow">goto</span> finish_it;
04125                 <span class="keywordflow">if</span> (numids == 1) {
04126                     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean
04127                         (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {
04128                         <span class="keywordflow">if</span> (!*buf_overflow
04129                             &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04130                                             allow_realloc,
04131                                             (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"\\"</span>)) {
04132                             *buf_overflow = 1;
04133                         }
04134                     }
04135                     <span class="keywordflow">if</span> (!*buf_overflow
04136                         &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04137                                         allow_realloc,
04138                                         (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"\""</span>)) {
04139                         *buf_overflow = 1;
04140                     }
04141                     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean
04142                         (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {
04143                         <span class="keywordflow">if</span> (!*buf_overflow
04144                             &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04145                                             allow_realloc,
04146                                             (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"\\"</span>)) {
04147                             *buf_overflow = 1;
04148                         }
04149                     }
04150                     <span class="keywordflow">if</span> (!*buf_overflow
04151                         &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04152                                         allow_realloc,
04153                                         (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"\""</span>)) {
04154                         *buf_overflow = 1;
04155                     }
04156                 } <span class="keywordflow">else</span> {
04157                     <span class="keywordflow">if</span> (!*buf_overflow) {
04158                         <span class="keyword">struct </span>tree * next_peer;
04159                         <span class="keywordtype">int</span> normal_handling = 1;
04160 
04161                         <span class="keywordflow">if</span> (tp-&gt;next_peer) {
04162                             next_peer = tp-&gt;next_peer;
04163                         }
04164 
04165                         <span class="comment">/* Try handling the InetAddress in the OID, in case of failure,</span>
04166 <span class="comment">                         * use the normal_handling. </span>
04167 <span class="comment">                         */</span>
04168                         <span class="keywordflow">if</span> (tp-&gt;next_peer &amp;&amp;
04169                             strcmp(get_tc_descriptor(tp-&gt;tc_index), <span class=
"stringliteral">"InetAddress"</span>) == 0 &amp;&amp;
04170                             strcmp(get_tc_descriptor(next_peer-&gt;tc_index), 
04171                                     <span class="stringliteral">"InetAddressType"</span>) == 0 ) {
04172 
04173                             <span class="keywordtype">int</span> ret;
04174                             <span class="keywordtype">int</span> addr_type = *(objid - 1);
04175 
04176                             ret = dump_realloc_oid_to_inetaddress(addr_type, 
04177                                         objid + 1, numids - 1, buf, buf_len, out_len,
04178                                         allow_realloc, <span class="charliteral">'"'</span>);
04179                             <span class="keywordflow">if</span> (ret != 2) {
04180                                 normal_handling = 0;
04181                                 <span class="keywordflow">if</span> (ret == 0) {
04182                                     *buf_overflow = 1;
04183                                 }
04184 
04185                             }
04186                         } 
04187                         <span class="keywordflow">if</span> (normal_handling &amp;&amp; !dump_realloc_oid_to_string
04188                             (objid + 1, numids - 1, buf, buf_len, out_len,
04189                              allow_realloc, <span class="charliteral">'"'</span>)) {
04190                             *buf_overflow = 1;
04191                         }
04192                     }
04193                 }
04194             }
04195             objid += numids;
04196             objidlen -= numids;
04197             <span class="keywordflow">break</span>;
04198 
04199         <span class="keywordflow">case</span> TYPE_INTEGER32:
04200         <span class="keywordflow">case</span> TYPE_UINTEGER:
04201         <span class="keywordflow">case</span> TYPE_UNSIGNED32:
04202         <span class="keywordflow">case</span> TYPE_GAUGE:
04203         <span class="keywordflow">case</span> TYPE_INTEGER:
04204             <span class="keywordflow">if</span> (tp-&gt;enums) {
04205                 <span class="keyword">struct </span>enum_list *ep = tp-&gt;enums;
04206                 <span class="keywordflow">while</span> (ep &amp;&amp; ep-&gt;value != (int) (*objid)) {
04207                     ep = ep-&gt;next;
04208                 }
04209                 <span class="keywordflow">if</span> (ep) {
04210                     <span class="keywordflow">if</span> (!*buf_overflow
04211                         &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04212                                         allow_realloc,
04213                                         (<span class="keyword">const</span> u_char *) ep-&gt;label)) {
04214                         *buf_overflow = 1;
04215                     }
04216                 } <span class="keywordflow">else</span> {
04217                     sprintf(intbuf, <span class="stringliteral">"%lu"</span>, *objid);
04218                     <span class="keywordflow">if</span> (!*buf_overflow
04219                         &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04220                                         allow_realloc,
04221                                         (<span class="keyword">const</span> u_char *) intbuf)) {
04222                         *buf_overflow = 1;
04223                     }
04224                 }
04225             } <span class="keywordflow">else</span> {
04226                 sprintf(intbuf, <span class="stringliteral">"%lu"</span>, *objid);
04227                 <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04228                                                    allow_realloc,
04229                                                    (<span class="keyword">const</span> u_char *)
04230                                                    intbuf)) {
04231                     *buf_overflow = 1;
04232                 }
04233             }
04234             objid++;
04235             objidlen--;
04236             <span class="keywordflow">break</span>;
04237 
04238         <span class="keywordflow">case</span> TYPE_OBJID:
04239             <span class="keywordflow">if</span> (in_dices-&gt;isimplied) {
04240                 numids = objidlen;
04241             } <span class="keywordflow">else</span> {
04242                 numids = (size_t) * objid + 1;
04243             }
04244             <span class="keywordflow">if</span> (numids &gt; objidlen)
04245                 <span class="keywordflow">goto</span> finish_it;
04246             <span class="keywordflow">if</span> (extended_index) {
04247                 <span class="keywordflow">if</span> (in_dices-&gt;isimplied) {
04248                     <span class="keywordflow">if</span> (!*buf_overflow
04249                         &amp;&amp; !netsnmp_sprint_realloc_objid_tree(buf, buf_len,
04250                                                               out_len,
04251                                                               allow_realloc,
04252                                                               buf_overflow,
04253                                                               objid,
04254                                                               numids)) {
04255                         *buf_overflow = 1;
04256                     }
04257                 } <span class="keywordflow">else</span> {
04258                     <span class="keywordflow">if</span> (!*buf_overflow
04259                         &amp;&amp; !netsnmp_sprint_realloc_objid_tree(buf, buf_len,
04260                                                               out_len,
04261                                                               allow_realloc,
04262                                                               buf_overflow,
04263                                                               objid + 1,
04264                                                               numids -
04265                                                               1)) {
04266                         *buf_overflow = 1;
04267                     }
04268                 }
04269             } <span class="keywordflow">else</span> {
04270                 _get_realloc_symbol(objid, numids, NULL, buf, buf_len,
04271                                     out_len, allow_realloc, buf_overflow,
04272                                     NULL, NULL);
04273             }
04274             objid += (numids);
04275             objidlen -= (numids);
04276             <span class="keywordflow">break</span>;
04277 
04278         <span class="keywordflow">case</span> TYPE_IPADDR:
04279             <span class="keywordflow">if</span> (objidlen &lt; 4)
04280                 <span class="keywordflow">goto</span> finish_it;
04281             sprintf(intbuf, <span class="stringliteral">"%lu.%lu.%lu.%lu"</span>,
04282                     objid[0], objid[1], objid[2], objid[3]);
04283             objid += 4;
04284             objidlen -= 4;
04285             <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04286                                                allow_realloc,
04287                                                (<span class="keyword">const</span> u_char *) intbuf)) {
04288                 *buf_overflow = 1;
04289             }
04290             <span class="keywordflow">break</span>;
04291 
04292         <span class="keywordflow">case</span> TYPE_NETADDR:{
04293                 oid             ntype = *objid++;
04294 
04295                 objidlen--;
04296                 sprintf(intbuf, <span class="stringliteral">"%lu."</span>, ntype);
04297                 <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04298                                                    allow_realloc,
04299                                                    (<span class="keyword">const</span> u_char *)
04300                                                    intbuf)) {
04301                     *buf_overflow = 1;
04302                 }
04303 
04304                 <span class="keywordflow">if</span> (ntype == 1 &amp;&amp; objidlen &gt;= 4) {
04305                     sprintf(intbuf, <span class="stringliteral">"%lu.%lu.%lu.%lu"</span>,
04306                             objid[0], objid[1], objid[2], objid[3]);
04307                     <span class="keywordflow">if</span> (!*buf_overflow
04308                         &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04309                                         allow_realloc,
04310                                         (<span class="keyword">const</span> u_char *) intbuf)) {
04311                         *buf_overflow = 1;
04312                     }
04313                     objid += 4;
04314                     objidlen -= 4;
04315                 } <span class="keywordflow">else</span> {
04316                     <span class="keywordflow">goto</span> finish_it;
04317                 }
04318             }
04319             <span class="keywordflow">break</span>;
04320 
04321         <span class="keywordflow">case</span> TYPE_NSAPADDRESS:
04322         <span class="keywordflow">default</span>:
04323             <span class="keywordflow">goto</span> finish_it;
04324             <span class="keywordflow">break</span>;
04325         }
04326 
04327         <span class="keywordflow">if</span> (extended_index) {
04328             <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04329                                                allow_realloc,
04330                                                (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"]"</span>)) {
04331                 *buf_overflow = 1;
04332             }
04333         } <span class="keywordflow">else</span> {
04334             <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04335                                                allow_realloc,
04336                                                (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"."</span>)) {
04337                 *buf_overflow = 1;
04338             }
04339         }
04340         in_dices = in_dices-&gt;next;
04341     }
04342 
04343   finish_it:
04344     _oid_finish_printing(objid, objidlen,
04345                          buf, buf_len, out_len,
04346                          allow_realloc, buf_overflow);
04347     <span class="keywordflow">return</span> NULL;
04348 }
04349 
04355 <span class="keyword">struct </span>tree    *
<a name="l04356" id="l04356"></a><a class="code" href="group__mib__utilities.html#ga83">04356</a> <a class="code" href=
"group__mib__utilities.html#ga83">get_tree</a>(<span class="keyword">const</span> oid * objid, size_t objidlen, <span class=
"keyword">struct</span> tree *subtree)
04357 {
04358     <span class="keyword">struct </span>tree    *return_tree = NULL;
04359 
04360     <span class="keywordflow">for</span> (; subtree; subtree = subtree-&gt;next_peer) {
04361         <span class="keywordflow">if</span> (*objid == subtree-&gt;subid)
04362             <span class="keywordflow">goto</span> found;
04363     }
04364 
04365     <span class="keywordflow">return</span> NULL;
04366 
04367   found:
04368     <span class="keywordflow">while</span> (subtree-&gt;next_peer &amp;&amp; subtree-&gt;next_peer-&gt;subid == *objid)
04369         subtree = subtree-&gt;next_peer;
04370     <span class="keywordflow">if</span> (objidlen &gt; 1)
04371         return_tree =
04372             <a class="code" href=
"group__mib__utilities.html#ga83">get_tree</a>(objid + 1, objidlen - 1, subtree-&gt;child_list);
04373     <span class="keywordflow">if</span> (return_tree != NULL)
04374         <span class="keywordflow">return</span> return_tree;
04375     <span class="keywordflow">else</span>
04376         <span class="keywordflow">return</span> subtree;
04377 }
04378 
04384 <span class="keywordtype">void</span>
<a name="l04385" id="l04385"></a><a class="code" href="group__mib__utilities.html#ga84">04385</a> <a class="code" href=
"group__mib__utilities.html#ga84">print_description</a>(oid * objid, size_t objidlen, <span class=
"comment">/* number of subidentifiers */</span>
04386                   <span class="keywordtype">int</span> width)
04387 {
04388     <a class="code" href="group__mib__utilities.html#ga85">fprint_description</a>(stdout, objid, objidlen, width);
04389 }
04390 
04391 
04400 <span class="keywordtype">void</span>
<a name="l04401" id="l04401"></a><a class="code" href="group__mib__utilities.html#ga85">04401</a> <a class="code" href=
"group__mib__utilities.html#ga85">fprint_description</a>(FILE * f, oid * objid, size_t objidlen,
04402                    <span class="keywordtype">int</span> width)
04403 {
04404     u_char         *buf = NULL;
04405     size_t          buf_len = 256, out_len = 0;
04406 
04407     <span class="keywordflow">if</span> ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {
04408         fprintf(f, <span class="stringliteral">"[TRUNCATED]\n"</span>);
04409         <span class="keywordflow">return</span>;
04410     } <span class="keywordflow">else</span> {
04411         <span class="keywordflow">if</span> (!sprint_realloc_description(&amp;buf, &amp;buf_len, &amp;out_len, 1,
04412                                    objid, objidlen, width)) {
04413             fprintf(f, <span class="stringliteral">"%s [TRUNCATED]\n"</span>, buf);
04414         } <span class="keywordflow">else</span> {
04415             fprintf(f, <span class="stringliteral">"%s\n"</span>, buf);
04416         }
04417     }
04418 
04419     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(buf);
04420 }
04421 
04422 <span class="keywordtype">int</span>
04423 snprint_description(<span class="keywordtype">char</span> *buf, size_t buf_len,
04424                     oid * objid, size_t objidlen, <span class="keywordtype">int</span> width)
04425 {
04426     size_t          out_len = 0;
04427 
04428     <span class="keywordflow">if</span> (sprint_realloc_description((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
04429                                     objid, objidlen, width)) {
04430         <span class="keywordflow">return</span> (int) out_len;
04431     } <span class="keywordflow">else</span> {
04432         <span class="keywordflow">return</span> -1;
04433     }
04434 }
04435 
04436 <span class="keywordtype">int</span>
04437 sprint_realloc_description(u_char ** buf, size_t * buf_len,
04438                      size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
04439                      oid * objid, size_t objidlen, <span class="keywordtype">int</span> width)
04440 {
04441     <span class="keyword">struct </span>tree    *tp = <a class="code" href=
"group__mib__utilities.html#ga83">get_tree</a>(objid, objidlen, tree_head);
04442     <span class="keyword">struct </span>tree    *subtree = tree_head;
04443     <span class="keywordtype">int</span>             pos, len;
04444     <span class="keywordtype">char</span>            tmpbuf[128];
04445     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp;
04446 
04447     <span class="keywordflow">if</span> (NULL == tp)
04448         <span class="keywordflow">return</span> 0;
04449 
04450     <span class="keywordflow">if</span> (tp-&gt;type &lt;= TYPE_SIMPLE_LAST)
04451         cp = <span class="stringliteral">" OBJECT-TYPE"</span>;
04452     <span class="keywordflow">else</span>
04453         <span class="keywordflow">switch</span> (tp-&gt;type) {
04454         <span class="keywordflow">case</span> TYPE_TRAPTYPE:
04455             cp = <span class="stringliteral">" TRAP-TYPE"</span>;
04456             <span class="keywordflow">break</span>;
04457         <span class="keywordflow">case</span> TYPE_NOTIFTYPE:
04458             cp = <span class="stringliteral">" NOTIFICATION-TYPE"</span>;
04459             <span class="keywordflow">break</span>;
04460         <span class="keywordflow">case</span> TYPE_OBJGROUP:
04461             cp = <span class="stringliteral">" OBJECT-GROUP"</span>;
04462             <span class="keywordflow">break</span>;
04463         <span class="keywordflow">case</span> TYPE_AGENTCAP:
04464             cp = <span class="stringliteral">" AGENT-CAPABILITIES"</span>;
04465             <span class="keywordflow">break</span>;
04466         <span class="keywordflow">case</span> TYPE_MODID:
04467             cp = <span class="stringliteral">" MODULE-IDENTITY"</span>;
04468             <span class="keywordflow">break</span>;
04469         <span class="keywordflow">case</span> TYPE_MODCOMP:
04470             cp = <span class="stringliteral">" MODULE-COMPLIANCE"</span>;
04471             <span class="keywordflow">break</span>;
04472         <span class="keywordflow">default</span>:
04473             sprintf(tmpbuf, <span class="stringliteral">" type_%d"</span>, tp-&gt;type);
04474             cp = tmpbuf;
04475         }
04476 
04477     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, tp-&gt;label) ||
04478         !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp) ||
04479         !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\n"</span>)) {
04480         <span class="keywordflow">return</span> 0;
04481     }
04482     <span class="keywordflow">if</span> (!print_tree_node(buf, buf_len, out_len, allow_realloc, tp, width))
04483         <span class="keywordflow">return</span> 0;
04484     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"::= {"</span>))
04485         <span class="keywordflow">return</span> 0;
04486     pos = 5;
04487     <span class="keywordflow">while</span> (objidlen &gt; 1) {
04488         <span class="keywordflow">for</span> (; subtree; subtree = subtree-&gt;next_peer) {
04489             <span class="keywordflow">if</span> (*objid == subtree-&gt;subid) {
04490                 <span class=
"keywordflow">while</span> (subtree-&gt;next_peer &amp;&amp; subtree-&gt;next_peer-&gt;subid == *objid)
04491                     subtree = subtree-&gt;next_peer;
04492                 <span class="keywordflow">if</span> (strncmp(subtree-&gt;label, ANON, ANON_LEN)) {
04493                     snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf), <span class=
"stringliteral">" %s(%lu)"</span>, subtree-&gt;label, subtree-&gt;subid);
04494                     tmpbuf[ <span class="keyword">sizeof</span>(tmpbuf)-1 ] = 0;
04495                 } <span class="keywordflow">else</span>
04496                     sprintf(tmpbuf, <span class="stringliteral">" %lu"</span>, subtree-&gt;subid);
04497                 len = strlen(tmpbuf);
04498                 <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04499                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len,
04500                                      allow_realloc, <span class="stringliteral">"\n     "</span>))
04501                         <span class="keywordflow">return</span> 0;
04502                     pos = 5;
04503                 }
04504                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, tmpbuf))
04505                     <span class="keywordflow">return</span> 0;
04506                 pos += len;
04507                 objid++;
04508                 objidlen--;
04509                 <span class="keywordflow">break</span>;
04510             }
04511         }
04512         <span class="keywordflow">if</span> (subtree)
04513             subtree = subtree-&gt;child_list;
04514         <span class="keywordflow">else</span>
04515             <span class="keywordflow">break</span>;
04516     }
04517     <span class="keywordflow">while</span> (objidlen &gt; 1) {
04518         sprintf(tmpbuf, <span class="stringliteral">" %lu"</span>, *objid);
04519         len = strlen(tmpbuf);
04520         <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04521             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"\n     "</span>))
04522                 <span class="keywordflow">return</span> 0;
04523             pos = 5;
04524         }
04525         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, tmpbuf))
04526             <span class="keywordflow">return</span> 0;
04527         pos += len;
04528         objid++;
04529         objidlen--;
04530     }
04531     sprintf(tmpbuf, <span class="stringliteral">" %lu }"</span>, *objid);
04532     len = strlen(tmpbuf);
04533     <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04534         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"\n     "</span>))
04535             <span class="keywordflow">return</span> 0;
04536         pos = 5;
04537     }
04538     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, tmpbuf))
04539         <span class="keywordflow">return</span> 0;
04540     <span class="keywordflow">return</span> 1;
04541 }
04542 
04543 <span class="keyword">static</span> <span class="keywordtype">int</span>
04544 print_tree_node(u_char ** buf, size_t * buf_len,
04545                      size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
04546                      <span class="keyword">struct</span> tree *tp, <span class="keywordtype">int</span> width)
04547 {
04548     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp;
04549     <span class="keywordtype">char</span>            str[MAXTOKEN];
04550     <span class="keywordtype">int</span>             i, prevmod, pos, len;
04551 
04552     <span class="keywordflow">if</span> (tp) {
04553         module_name(tp-&gt;modid, str);
04554         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"  -- FROM\t"</span>) ||
04555             !snmp_strcat(buf, buf_len, out_len, allow_realloc, str))
04556             <span class="keywordflow">return</span> 0;
04557         pos = 16+strlen(str);
04558         <span class="keywordflow">for</span> (i = 1, prevmod = tp-&gt;modid; i &lt; tp-&gt;number_modules; i++) {
04559             <span class="keywordflow">if</span> (prevmod != tp-&gt;module_list[i]) {
04560                 module_name(tp-&gt;module_list[i], str);
04561                 len = strlen(str);
04562                 <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04563                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04564                                      <span class="stringliteral">",\n  --\t\t"</span>))
04565                         <span class="keywordflow">return</span> 0;
04566                     pos = 16;
04567                 }
04568                 <span class="keywordflow">else</span> {
04569                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">", "</span>))
04570                         <span class="keywordflow">return</span> 0;
04571                     pos += 2;
04572                 }
04573                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))
04574                     <span class="keywordflow">return</span> 0;
04575                 pos += len;
04576             }
04577             prevmod = tp-&gt;module_list[i];
04578         }
04579         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"\n"</span>))
04580             <span class="keywordflow">return</span> 0;
04581         <span class="keywordflow">if</span> (tp-&gt;tc_index != -1) {
04582             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04583                              <span class="stringliteral">"  -- TEXTUAL CONVENTION "</span>) ||
04584                 !snmp_strcat(buf, buf_len, out_len, allow_realloc,
04585                              get_tc_descriptor(tp-&gt;tc_index)) ||
04586                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\n"</span>))
04587                 <span class="keywordflow">return</span> 0;
04588         }
04589         <span class="keywordflow">switch</span> (tp-&gt;type) {
04590         <span class="keywordflow">case</span> TYPE_OBJID:
04591             cp = <span class="stringliteral">"OBJECT IDENTIFIER"</span>;
04592             <span class="keywordflow">break</span>;
04593         <span class="keywordflow">case</span> TYPE_OCTETSTR:
04594             cp = <span class="stringliteral">"OCTET STRING"</span>;
04595             <span class="keywordflow">break</span>;
04596         <span class="keywordflow">case</span> TYPE_INTEGER:
04597             cp = <span class="stringliteral">"INTEGER"</span>;
04598             <span class="keywordflow">break</span>;
04599         <span class="keywordflow">case</span> TYPE_NETADDR:
04600             cp = <span class="stringliteral">"NetworkAddress"</span>;
04601             <span class="keywordflow">break</span>;
04602         <span class="keywordflow">case</span> TYPE_IPADDR:
04603             cp = <span class="stringliteral">"IpAddress"</span>;
04604             <span class="keywordflow">break</span>;
04605         <span class="keywordflow">case</span> TYPE_COUNTER:
04606             cp = <span class="stringliteral">"Counter32"</span>;
04607             <span class="keywordflow">break</span>;
04608         <span class="keywordflow">case</span> TYPE_GAUGE:
04609             cp = <span class="stringliteral">"Gauge32"</span>;
04610             <span class="keywordflow">break</span>;
04611         <span class="keywordflow">case</span> TYPE_TIMETICKS:
04612             cp = <span class="stringliteral">"TimeTicks"</span>;
04613             <span class="keywordflow">break</span>;
04614         <span class="keywordflow">case</span> TYPE_OPAQUE:
04615             cp = <span class="stringliteral">"Opaque"</span>;
04616             <span class="keywordflow">break</span>;
04617         <span class="keywordflow">case</span> TYPE_NULL:
04618             cp = <span class="stringliteral">"NULL"</span>;
04619             <span class="keywordflow">break</span>;
04620         <span class="keywordflow">case</span> TYPE_COUNTER64:
04621             cp = <span class="stringliteral">"Counter64"</span>;
04622             <span class="keywordflow">break</span>;
04623         <span class="keywordflow">case</span> TYPE_BITSTRING:
04624             cp = <span class="stringliteral">"BITS"</span>;
04625             <span class="keywordflow">break</span>;
04626         <span class="keywordflow">case</span> TYPE_NSAPADDRESS:
04627             cp = <span class="stringliteral">"NsapAddress"</span>;
04628             <span class="keywordflow">break</span>;
04629         <span class="keywordflow">case</span> TYPE_UINTEGER:
04630             cp = <span class="stringliteral">"UInteger32"</span>;
04631             <span class="keywordflow">break</span>;
04632         <span class="keywordflow">case</span> TYPE_UNSIGNED32:
04633             cp = <span class="stringliteral">"Unsigned32"</span>;
04634             <span class="keywordflow">break</span>;
04635         <span class="keywordflow">case</span> TYPE_INTEGER32:
04636             cp = <span class="stringliteral">"Integer32"</span>;
04637             <span class="keywordflow">break</span>;
04638         <span class="keywordflow">default</span>:
04639             cp = NULL;
04640             <span class="keywordflow">break</span>;
04641         }
04642 <span class="preprocessor">#if SNMP_TESTING_CODE</span>
04643         <span class="keywordflow">if</span> (!cp &amp;&amp; (tp-&gt;ranges || tp-&gt;enums)) { <span class=
"comment">/* ranges without type ? */</span>
04644             sprintf(str, <span class="stringliteral">"?0 with %s %s ?"</span>,
04645                     tp-&gt;ranges ? <span class="stringliteral">"Range"</span> : <span class=
"stringliteral">""</span>, tp-&gt;enums ? <span class="stringliteral">"Enum"</span> : <span class="stringliteral">""</span>);
04646             cp = str;
04647         }
04648 <span class="preprocessor">#endif                          </span><span class="comment">/* SNMP_TESTING_CODE */</span>
04649         <span class="keywordflow">if</span> (cp)
04650             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04651                              <span class="stringliteral">"  SYNTAX\t"</span>) ||
04652                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp))
04653                 <span class="keywordflow">return</span> 0;
04654         <span class="keywordflow">if</span> (tp-&gt;ranges) {
04655             <span class="keyword">struct </span>range_list *rp = tp-&gt;ranges;
04656             <span class="keywordtype">int</span>             first = 1;
04657             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">" ("</span>))
04658                 <span class="keywordflow">return</span> 0;
04659             <span class="keywordflow">while</span> (rp) {
04660                 <span class="keywordflow">if</span> (rp-&gt;low == rp-&gt;high)
04661                     sprintf(str, <span class="stringliteral">"%s%d"</span>, (first ? <span class=
"stringliteral">""</span> : <span class="stringliteral">" | "</span>), rp-&gt;low );
04662                 <span class="keywordflow">else</span>
04663                     sprintf(str, <span class="stringliteral">"%s%d..%d"</span>, (first ? <span class=
"stringliteral">""</span> : <span class="stringliteral">" | "</span>),
04664                                               rp-&gt;low, rp-&gt;high);
04665                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))
04666                     <span class="keywordflow">return</span> 0;
04667                 <span class="keywordflow">if</span> (first)
04668                     first = 0;
04669                 rp = rp-&gt;next;
04670             }
04671             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">") "</span>))
04672                 <span class="keywordflow">return</span> 0;
04673         }
04674         <span class="keywordflow">if</span> (tp-&gt;enums) {
04675             <span class="keyword">struct </span>enum_list *ep = tp-&gt;enums;
04676             <span class="keywordtype">int</span>             first = 1;
04677             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">" {"</span>))
04678                 <span class="keywordflow">return</span> 0;
04679             pos = 16 + strlen(cp) + 2;
04680             <span class="keywordflow">while</span> (ep) {
04681                 <span class="keywordflow">if</span> (first)
04682                     first = 0;
04683                 <span class="keywordflow">else</span>
04684                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">", "</span>))
04685                         <span class="keywordflow">return</span> 0;
04686                 snprintf(str, <span class="keyword">sizeof</span>(str), <span class=
"stringliteral">"%s(%d)"</span>, ep-&gt;label, ep-&gt;value);
04687                 str[ <span class="keyword">sizeof</span>(str)-1 ] = 0;
04688                 len = strlen(str);
04689                 <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04690                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len,
04691                                      allow_realloc, <span class="stringliteral">"\n\t\t  "</span>))
04692                         <span class="keywordflow">return</span> 0;
04693                     pos = 18;
04694                 }
04695                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))
04696                     <span class="keywordflow">return</span> 0;
04697                 pos += len + 2;
04698                 ep = ep-&gt;next;
04699             }
04700             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"} "</span>))
04701                 <span class="keywordflow">return</span> 0;
04702         }
04703         <span class="keywordflow">if</span> (cp)
04704             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"\n"</span>))
04705                 <span class="keywordflow">return</span> 0;
04706         <span class="keywordflow">if</span> (tp-&gt;hint)
04707             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04708                              <span class="stringliteral">"  DISPLAY-HINT\t\""</span>) ||
04709                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, tp-&gt;hint) ||
04710                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\"\n"</span>))
04711                 <span class="keywordflow">return</span> 0;
04712         <span class="keywordflow">if</span> (tp-&gt;units)
04713             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04714                              <span class="stringliteral">"  UNITS\t\""</span>) ||
04715                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, tp-&gt;hint) ||
04716                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\"\n"</span>))
04717                 <span class="keywordflow">return</span> 0;
04718         <span class="keywordflow">switch</span> (tp-&gt;access) {
04719         <span class="keywordflow">case</span> MIB_ACCESS_READONLY:
04720             cp = <span class="stringliteral">"read-only"</span>;
04721             <span class="keywordflow">break</span>;
04722         <span class="keywordflow">case</span> MIB_ACCESS_READWRITE:
04723             cp = <span class="stringliteral">"read-write"</span>;
04724             <span class="keywordflow">break</span>;
04725         <span class="keywordflow">case</span> MIB_ACCESS_WRITEONLY:
04726             cp = <span class="stringliteral">"write-only"</span>;
04727             <span class="keywordflow">break</span>;
04728         <span class="keywordflow">case</span> MIB_ACCESS_NOACCESS:
04729             cp = <span class="stringliteral">"not-accessible"</span>;
04730             <span class="keywordflow">break</span>;
04731         <span class="keywordflow">case</span> MIB_ACCESS_NOTIFY:
04732             cp = <span class="stringliteral">"accessible-for-notify"</span>;
04733             <span class="keywordflow">break</span>;
04734         <span class="keywordflow">case</span> MIB_ACCESS_CREATE:
04735             cp = <span class="stringliteral">"read-create"</span>;
04736             <span class="keywordflow">break</span>;
04737         <span class="keywordflow">case</span> 0:
04738             cp = NULL;
04739             <span class="keywordflow">break</span>;
04740         <span class="keywordflow">default</span>:
04741             sprintf(str, <span class="stringliteral">"access_%d"</span>, tp-&gt;access);
04742             cp = str;
04743         }
04744         <span class="keywordflow">if</span> (cp)
04745             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04746                              <span class="stringliteral">"  MAX-ACCESS\t"</span>) ||
04747                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp) ||
04748                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\n"</span>))
04749                 <span class="keywordflow">return</span> 0;
04750         <span class="keywordflow">switch</span> (tp-&gt;status) {
04751         <span class="keywordflow">case</span> MIB_STATUS_MANDATORY:
04752             cp = <span class="stringliteral">"mandatory"</span>;
04753             <span class="keywordflow">break</span>;
04754         <span class="keywordflow">case</span> MIB_STATUS_OPTIONAL:
04755             cp = <span class="stringliteral">"optional"</span>;
04756             <span class="keywordflow">break</span>;
04757         <span class="keywordflow">case</span> MIB_STATUS_OBSOLETE:
04758             cp = <span class="stringliteral">"obsolete"</span>;
04759             <span class="keywordflow">break</span>;
04760         <span class="keywordflow">case</span> MIB_STATUS_DEPRECATED:
04761             cp = <span class="stringliteral">"deprecated"</span>;
04762             <span class="keywordflow">break</span>;
04763         <span class="keywordflow">case</span> MIB_STATUS_CURRENT:
04764             cp = <span class="stringliteral">"current"</span>;
04765             <span class="keywordflow">break</span>;
04766         <span class="keywordflow">case</span> 0:
04767             cp = NULL;
04768             <span class="keywordflow">break</span>;
04769         <span class="keywordflow">default</span>:
04770             sprintf(str, <span class="stringliteral">"status_%d"</span>, tp-&gt;status);
04771             cp = str;
04772         }
04773 <span class="preprocessor">#if SNMP_TESTING_CODE</span>
04774         <span class="keywordflow">if</span> (!cp &amp;&amp; (tp-&gt;indexes)) {     <span class=
"comment">/* index without status ? */</span>
04775             sprintf(str, <span class="stringliteral">"?0 with %s ?"</span>, tp-&gt;indexes ? <span class=
"stringliteral">"Index"</span> : <span class="stringliteral">""</span>);
04776             cp = str;
04777         }
04778 <span class="preprocessor">#endif                          </span><span class="comment">/* SNMP_TESTING_CODE */</span>
04779         <span class="keywordflow">if</span> (cp)
04780             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04781                              <span class="stringliteral">"  STATUS\t"</span>) ||
04782                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp) ||
04783                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\n"</span>))
04784                 <span class="keywordflow">return</span> 0;
04785         <span class="keywordflow">if</span> (tp-&gt;augments)
04786             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04787                              <span class="stringliteral">"  AUGMENTS\t{ "</span>) ||
04788                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, tp-&gt;augments) ||
04789                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">" }\n"</span>))
04790                 <span class="keywordflow">return</span> 0;
04791         <span class="keywordflow">if</span> (tp-&gt;indexes) {
04792             <span class="keyword">struct </span>index_list *ip = tp-&gt;indexes;
04793             <span class="keywordtype">int</span>             first = 1;
04794             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04795                              <span class="stringliteral">"  INDEX\t\t{ "</span>))
04796                 <span class="keywordflow">return</span> 0;
04797             pos = 16 + 2;
04798             <span class="keywordflow">while</span> (ip) {
04799                 <span class="keywordflow">if</span> (first)
04800                     first = 0;
04801                 <span class="keywordflow">else</span>
04802                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">", "</span>))
04803                         <span class="keywordflow">return</span> 0;
04804                 snprintf(str, <span class="keyword">sizeof</span>(str), <span class="stringliteral">"%s%s"</span>,
04805                         ip-&gt;isimplied ? <span class="stringliteral">"IMPLIED "</span> : <span class=
"stringliteral">""</span>,
04806                         ip-&gt;ilabel);
04807                 str[ <span class="keyword">sizeof</span>(str)-1 ] = 0;
04808                 len = strlen(str);
04809                 <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04810                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"\n\t\t  "</span>))
04811                         <span class="keywordflow">return</span> 0;
04812                     pos = 16 + 2;
04813                 }
04814                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))
04815                     <span class="keywordflow">return</span> 0;
04816                 pos += len + 2;
04817                 ip = ip-&gt;next;
04818             }
04819             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">" }\n"</span>))
04820                 <span class="keywordflow">return</span> 0;
04821         }
04822         <span class="keywordflow">if</span> (tp-&gt;varbinds) {
04823             <span class="keyword">struct </span>varbind_list *vp = tp-&gt;varbinds;
04824             <span class="keywordtype">int</span>             first = 1;
04825 
04826             <span class="keywordflow">if</span> (tp-&gt;type == TYPE_TRAPTYPE) {
04827                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04828                     <span class="stringliteral">"  VARIABLES\t{ "</span>))
04829                     <span class="keywordflow">return</span> 0;
04830             } <span class="keywordflow">else</span> {
04831                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04832                     <span class="stringliteral">"  OBJECTS\t{ "</span>))
04833                     <span class="keywordflow">return</span> 0;
04834             }
04835             pos = 16 + 2;
04836             <span class="keywordflow">while</span> (vp) {
04837                 <span class="keywordflow">if</span> (first)
04838                     first = 0;
04839                 <span class="keywordflow">else</span>
04840                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">", "</span>))
04841                         <span class="keywordflow">return</span> 0;
04842                 snprintf(str, <span class="keyword">sizeof</span>(str), <span class=
"stringliteral">"%s"</span>, vp-&gt;vblabel);
04843                 str[ <span class="keyword">sizeof</span>(str)-1 ] = 0;
04844                 len = strlen(str);
04845                 <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04846                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04847                                     <span class="stringliteral">"\n\t\t  "</span>))
04848                         <span class="keywordflow">return</span> 0;
04849                     pos = 16 + 2;
04850                 }
04851                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))
04852                     <span class="keywordflow">return</span> 0;
04853                 pos += len + 2;
04854                 vp = vp-&gt;next;
04855             }
04856             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">" }\n"</span>))
04857                 <span class="keywordflow">return</span> 0;
04858         }
04859         <span class="keywordflow">if</span> (tp-&gt;description)
04860             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04861                              <span class="stringliteral">"  DESCRIPTION\t\""</span>) ||
04862                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, tp-&gt;description) ||
04863                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\"\n"</span>))
04864                 <span class="keywordflow">return</span> 0;
04865         <span class="keywordflow">if</span> (tp-&gt;defaultValue)
04866             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04867                              <span class="stringliteral">"  DEFVAL\t{ "</span>) ||
04868                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, tp-&gt;defaultValue) ||
04869                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">" }\n"</span>))
04870                 <span class="keywordflow">return</span> 0;
04871     } <span class="keywordflow">else</span>
04872         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"No description\n"</span>))
04873             <span class="keywordflow">return</span> 0;
04874     <span class="keywordflow">return</span> 1;
04875 }
04876 
04877 <span class="keywordtype">int</span>
04878 get_module_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *fname,
04879                 <span class="keyword">const</span> <span class=
"keywordtype">char</span> *module, oid * objid, size_t * objidlen)
04880 {
04881     <span class="keywordtype">int</span>             modid, rc = 0;
04882     <span class="keyword">struct </span>tree    *tp;
04883     <span class="keywordtype">char</span>           *name, *cp;
04884 
04885     <span class="keywordflow">if</span> (!strcmp(module, <span class="stringliteral">"ANY"</span>))
04886         modid = -1;
04887     <span class="keywordflow">else</span> {
04888         read_module(module);
04889         modid = which_module(module);
04890         <span class="keywordflow">if</span> (modid == -1)
04891             <span class="keywordflow">return</span> 0;
04892     }
04893 
04894     <span class="comment">/*</span>
04895 <span class="comment">     * Isolate the first component of the name ... </span>
04896 <span class="comment">     */</span>
04897     name = strdup(fname);
04898     cp = strchr(name, <span class="charliteral">'.'</span>);
04899     <span class="keywordflow">if</span> (cp != NULL) {
04900         *cp = <span class="charliteral">'\0'</span>;
04901         cp++;
04902     }
04903     <span class="comment">/*</span>
04904 <span class="comment">     * ... and locate it in the tree. </span>
04905 <span class="comment">     */</span>
04906     tp = find_tree_node(name, modid);
04907     <span class="keywordflow">if</span> (tp) {
04908         size_t          maxlen = *objidlen;
04909 
04910         <span class="comment">/*</span>
04911 <span class="comment">         * Set the first element of the object ID </span>
04912 <span class="comment">         */</span>
04913         <span class="keywordflow">if</span> (node_to_oid(tp, objid, objidlen)) {
04914             rc = 1;
04915 
04916             <span class="comment">/*</span>
04917 <span class="comment">             * If the name requested was more than one element,</span>
04918 <span class="comment">             * tag on the rest of the components </span>
04919 <span class="comment">             */</span>
04920             <span class="keywordflow">if</span> (cp != NULL)
04921                 rc = _add_strings_to_oid(tp, cp, objid, objidlen, maxlen);
04922         }
04923     }
04924 
04925     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(name);
04926     <span class="keywordflow">return</span> (rc);
04927 }
04928 
04929 
04947 <span class="keyword">static</span> <span class="keywordtype">int</span>
04948 node_to_oid(<span class="keyword">struct</span> tree *tp, oid * objid, size_t * objidlen)
04949 {
04950     <span class="keywordtype">int</span>             numids, lenids;
04951     oid            *op;
04952 
04953     <span class="keywordflow">if</span> (!tp || !objid || !objidlen)
04954         <span class="keywordflow">return</span> 0;
04955 
04956     lenids = (int) *objidlen;
04957     op = objid + lenids;        <span class="comment">/* points after the last element */</span>
04958 
04959     <span class="keywordflow">for</span> (numids = 0; tp; tp = tp-&gt;parent, numids++) {
04960         <span class="keywordflow">if</span> (numids &gt;= lenids)
04961             <span class="keywordflow">continue</span>;
04962         --op;
04963         *op = tp-&gt;subid;
04964     }
04965 
04966     *objidlen = (size_t) numids;
04967     <span class="keywordflow">if</span> (numids &gt; lenids) {
04968         <span class="keywordflow">return</span> 0;
04969     }
04970 
04971     <span class="keywordflow">if</span> (numids &lt; lenids)
04972         memmove(objid, op, numids * <span class="keyword">sizeof</span>(oid));
04973 
04974     <span class="keywordflow">return</span> (numids);
04975 }
04976 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
04977 
04978 <span class="comment">/*</span>
04979 <span class="comment"> * Replace \x with x stop at eos_marker</span>
04980 <span class="comment"> * return NULL if eos_marker not found</span>
04981 <span class="comment"> */</span>
04982 <span class="keyword">static</span> <span class="keywordtype">char</span> *_apply_escapes(<span class=
"keywordtype">char</span> *src, <span class="keywordtype">char</span> eos_marker)
04983 {
04984     <span class="keywordtype">char</span> *dst;
04985     <span class="keywordtype">int</span> backslash = 0;
04986     
04987     dst = src;
04988     <span class="keywordflow">while</span> (*src) {
04989         <span class="keywordflow">if</span> (backslash) {
04990             backslash = 0;
04991             *dst++ = *src;
04992         } <span class="keywordflow">else</span> {
04993             <span class="keywordflow">if</span> (eos_marker == *src) <span class="keywordflow">break</span>;
04994             <span class="keywordflow">if</span> (<span class="charliteral">'\\'</span> == *src) {
04995                 backslash = 1;
04996             } <span class="keywordflow">else</span> {
04997                 *dst++ = *src;
04998             }
04999         }
05000         src++;
05001     }
05002     <span class="keywordflow">if</span> (!*src) {
05003         <span class="comment">/* never found eos_marker */</span>
05004         <span class="keywordflow">return</span> NULL;
05005     } <span class="keywordflow">else</span> {
05006         *dst = 0;
05007         <span class="keywordflow">return</span> src;
05008     }
05009 }
05010 
05011 <span class="keyword">static</span> <span class="keywordtype">int</span>
05012 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05013 _add_strings_to_oid(<span class="keyword">struct</span> tree *tp, <span class="keywordtype">char</span> *cp,
05014                     oid * objid, size_t * objidlen, size_t maxlen)
05015 #<span class="keywordflow">else</span>
05016 _add_strings_to_oid(<span class="keywordtype">void</span> *tp, <span class="keywordtype">char</span> *cp,
05017                     oid * objid, size_t * objidlen, size_t maxlen)
05018 #endif <span class="comment">/* DISABLE_MIB_LOADING */</span>
05019 {
05020     oid             subid;
05021     <span class="keywordtype">int</span>             len_index = 1000000;
05022 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05023     <span class="keyword">struct </span>tree    *tp2 = NULL;
05024     <span class="keyword">struct </span>index_list *in_dices = NULL;
05025 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05026     <span class="keywordtype">char</span>           *fcp, *ecp, *cp2 = NULL;
05027     <span class="keywordtype">char</span>            doingquote;
05028     <span class="keywordtype">int</span>             len = -1, pos = -1;
05029 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05030     <span class="keywordtype">int</span>             check =
05031         !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_CHECK_RANGE);
05032     <span class=
"keywordtype">int</span>             do_hint = !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NO_DISPLAY_HINT);
05033 
05034     <span class="keywordflow">while</span> (cp &amp;&amp; tp &amp;&amp; tp-&gt;child_list) {
05035         fcp = cp;
05036         tp2 = tp-&gt;child_list;
05037         <span class="comment">/*</span>
05038 <span class="comment">         * Isolate the next entry </span>
05039 <span class="comment">         */</span>
05040         cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05041         <span class="keywordflow">if</span> (cp2)
05042             *cp2++ = <span class="charliteral">'\0'</span>;
05043 
05044         <span class="comment">/*</span>
05045 <span class="comment">         * Search for the appropriate child </span>
05046 <span class="comment">         */</span>
05047         <span class="keywordflow">if</span> (isdigit(*cp)) {
05048             subid = strtoul(cp, &amp;ecp, 0);
05049             <span class="keywordflow">if</span> (*ecp)
05050                 <span class="keywordflow">goto</span> bad_id;
05051             <span class="keywordflow">while</span> (tp2 &amp;&amp; tp2-&gt;subid != subid)
05052                 tp2 = tp2-&gt;next_peer;
05053         } <span class="keywordflow">else</span> {
05054             <span class="keywordflow">while</span> (tp2 &amp;&amp; strcmp(tp2-&gt;label, fcp))
05055                 tp2 = tp2-&gt;next_peer;
05056             <span class="keywordflow">if</span> (!tp2)
05057                 <span class="keywordflow">goto</span> bad_id;
05058             subid = tp2-&gt;subid;
05059         }
05060         <span class="keywordflow">if</span> (*objidlen &gt;= maxlen)
05061             <span class="keywordflow">goto</span> bad_id;
05062         <span class=
"keywordflow">while</span> (tp2 &amp;&amp; tp2-&gt;next_peer &amp;&amp; tp2-&gt;next_peer-&gt;subid == subid)
05063             tp2 = tp2-&gt;next_peer;
05064         objid[*objidlen] = subid;
05065         (*objidlen)++;
05066 
05067         cp = cp2;
05068         <span class="keywordflow">if</span> (!tp2)
05069             <span class="keywordflow">break</span>;
05070         tp = tp2;
05071     }
05072 
05073     <span class="keywordflow">if</span> (tp &amp;&amp; !tp-&gt;child_list) {
05074         <span class="keywordflow">if</span> ((tp2 = tp-&gt;parent)) {
05075             <span class="keywordflow">if</span> (tp2-&gt;indexes)
05076                 in_dices = tp2-&gt;indexes;
05077             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tp2-&gt;augments) {
05078                 tp2 = find_tree_node(tp2-&gt;augments, -1);
05079                 <span class="keywordflow">if</span> (tp2)
05080                     in_dices = tp2-&gt;indexes;
05081             }
05082         }
05083         tp = NULL;
05084     }
05085 
05086     <span class="keywordflow">while</span> (cp &amp;&amp; in_dices) {
05087         fcp = cp;
05088 
05089         tp = find_tree_node(in_dices-&gt;ilabel, -1);
05090         <span class="keywordflow">if</span> (!tp)
05091             <span class="keywordflow">break</span>;
05092         <span class="keywordflow">switch</span> (tp-&gt;type) {
05093         <span class="keywordflow">case</span> TYPE_INTEGER:
05094         <span class="keywordflow">case</span> TYPE_INTEGER32:
05095         <span class="keywordflow">case</span> TYPE_UINTEGER:
05096         <span class="keywordflow">case</span> TYPE_UNSIGNED32:
05097         <span class="keywordflow">case</span> TYPE_TIMETICKS:
05098             <span class="comment">/*</span>
05099 <span class="comment">             * Isolate the next entry </span>
05100 <span class="comment">             */</span>
05101             cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05102             <span class="keywordflow">if</span> (cp2)
05103                 *cp2++ = <span class="charliteral">'\0'</span>;
05104             <span class="keywordflow">if</span> (isdigit(*cp)) {
05105                 subid = strtoul(cp, &amp;ecp, 0);
05106                 <span class="keywordflow">if</span> (*ecp)
05107                     <span class="keywordflow">goto</span> bad_id;
05108             } <span class="keywordflow">else</span> {
05109                 <span class="keywordflow">if</span> (tp-&gt;enums) {
05110                     <span class="keyword">struct </span>enum_list *ep = tp-&gt;enums;
05111                     <span class="keywordflow">while</span> (ep &amp;&amp; strcmp(ep-&gt;label, cp))
05112                         ep = ep-&gt;next;
05113                     <span class="keywordflow">if</span> (!ep)
05114                         <span class="keywordflow">goto</span> bad_id;
05115                     subid = ep-&gt;value;
05116                 } <span class="keywordflow">else</span>
05117                     <span class="keywordflow">goto</span> bad_id;
05118             }
05119             <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;ranges) {
05120                 <span class="keyword">struct </span>range_list *rp = tp-&gt;ranges;
05121                 <span class="keywordtype">int</span>             ok = 0;
05122                 <span class="keywordflow">while</span> (!ok &amp;&amp; rp)
05123                     <span class="keywordflow">if</span> ((rp-&gt;low &lt;= (int) subid)
05124                         &amp;&amp; ((int) subid &lt;= rp-&gt;high))
05125                         ok = 1;
05126                     <span class="keywordflow">else</span>
05127                         rp = rp-&gt;next;
05128                 <span class="keywordflow">if</span> (!ok)
05129                     <span class="keywordflow">goto</span> bad_id;
05130             }
05131             <span class="keywordflow">if</span> (*objidlen &gt;= maxlen)
05132                 <span class="keywordflow">goto</span> bad_id;
05133             objid[*objidlen] = subid;
05134             (*objidlen)++;
05135             <span class="keywordflow">break</span>;
05136         <span class="keywordflow">case</span> TYPE_IPADDR:
05137             <span class="keywordflow">if</span> (*objidlen + 4 &gt; maxlen)
05138                 <span class="keywordflow">goto</span> bad_id;
05139             <span class="keywordflow">for</span> (subid = 0; cp &amp;&amp; subid &lt; 4; subid++) {
05140                 fcp = cp;
05141                 cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05142                 <span class="keywordflow">if</span> (cp2)
05143                     *cp2++ = 0;
05144                 objid[*objidlen] = strtoul(cp, &amp;ecp, 0);
05145                 <span class="keywordflow">if</span> (*ecp)
05146                     <span class="keywordflow">goto</span> bad_id;
05147                 <span class="keywordflow">if</span> (check &amp;&amp; objid[*objidlen] &gt; 255)
05148                     <span class="keywordflow">goto</span> bad_id;
05149                 (*objidlen)++;
05150                 cp = cp2;
05151             }
05152             <span class="keywordflow">break</span>;
05153         <span class="keywordflow">case</span> TYPE_OCTETSTR:
05154             <span class="keywordflow">if</span> (tp-&gt;ranges &amp;&amp; !tp-&gt;ranges-&gt;next
05155                 &amp;&amp; tp-&gt;ranges-&gt;low == tp-&gt;ranges-&gt;high)
05156                 len = tp-&gt;ranges-&gt;low;
05157             <span class="keywordflow">else</span>
05158                 len = -1;
05159             pos = 0;
05160             <span class="keywordflow">if</span> (*cp == <span class="charliteral">'"'</span> || *cp == <span class=
"charliteral">'\''</span>) {
05161                 doingquote = *cp++;
05162                 <span class="comment">/*</span>
05163 <span class="comment">                 * insert length if requested </span>
05164 <span class="comment">                 */</span>
05165                 <span class="keywordflow">if</span> (!in_dices-&gt;isimplied &amp;&amp; len == -1) {
05166                     <span class="keywordflow">if</span> (doingquote == <span class="charliteral">'\''</span>) {
05167                         snmp_set_detail
05168                             (<span class="stringliteral">"'-quote is for fixed length strings"</span>);
05169                         <span class="keywordflow">return</span> 0;
05170                     }
05171                     <span class="keywordflow">if</span> (*objidlen &gt;= maxlen)
05172                         <span class="keywordflow">goto</span> bad_id;
05173                     len_index = *objidlen;
05174                     (*objidlen)++;
05175                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (doingquote == <span class=
"charliteral">'"'</span>) {
05176                     snmp_set_detail
05177                         (<span class="stringliteral">"\"-quote is for variable length strings"</span>);
05178                     <span class="keywordflow">return</span> 0;
05179                 }
05180 
05181                 cp2 = _apply_escapes(cp, doingquote);
05182                 <span class="keywordflow">if</span> (!cp2) <span class="keywordflow">goto</span> bad_id;
05183                 <span class="keywordflow">else</span> {
05184                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *new_val;
05185                     <span class="keywordtype">int</span> new_val_len;
05186                     <span class="keywordtype">int</span> parsed_hint = 0;
05187                     <span class="keyword">const</span> <span class="keywordtype">char</span> *parsed_value;
05188 
05189                     <span class="keywordflow">if</span> (do_hint &amp;&amp; tp-&gt;hint) {
05190                         parsed_value = parse_octet_hint(tp-&gt;hint, cp,
05191                                                         &amp;new_val, &amp;new_val_len);
05192                         parsed_hint = parsed_value == NULL;
05193                     }
05194                     <span class="keywordflow">if</span> (parsed_hint) {
05195                         <span class="keywordtype">int</span> i;
05196                         <span class="keywordflow">for</span> (i = 0; i &lt; new_val_len; i++) {
05197                             <span class="keywordflow">if</span> (*objidlen &gt;= maxlen) <span class=
"keywordflow">goto</span> bad_id;
05198                             objid[ *objidlen ] = new_val[i];
05199                             (*objidlen)++;
05200                             pos++;
05201                         }
05202                         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(new_val);
05203                     } <span class="keywordflow">else</span> {
05204                         <span class="keywordflow">while</span>(*cp) {
05205                             <span class="keywordflow">if</span> (*objidlen &gt;= maxlen) <span class=
"keywordflow">goto</span> bad_id;
05206                             objid[ *objidlen ] = *cp++;
05207                             (*objidlen)++;
05208                             pos++;
05209                         }
05210                     }
05211                 }
05212                 
05213                 cp2++;
05214                 <span class="keywordflow">if</span> (!*cp2)
05215                     cp2 = NULL;
05216                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*cp2 != <span class=
"charliteral">'.'</span>)
05217                     <span class="keywordflow">goto</span> bad_id;
05218                 <span class="keywordflow">else</span>
05219                     cp2++;
05220                 <span class="keywordflow">if</span> (check) {
05221                     <span class="keywordflow">if</span> (len == -1) {
05222                         <span class="keyword">struct </span>range_list *rp = tp-&gt;ranges;
05223                         <span class="keywordtype">int</span>             ok = 0;
05224                         <span class="keywordflow">while</span> (rp &amp;&amp; !ok)
05225                             <span class="keywordflow">if</span> (rp-&gt;low &lt;= pos &amp;&amp; pos &lt;= rp-&gt;high)
05226                                 ok = 1;
05227                             <span class="keywordflow">else</span>
05228                                 rp = rp-&gt;next;
05229                         <span class="keywordflow">if</span> (!ok)
05230                             <span class="keywordflow">goto</span> bad_id;
05231                         <span class="keywordflow">if</span> (!in_dices-&gt;isimplied)
05232                             objid[len_index] = pos;
05233                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pos != len)
05234                         <span class="keywordflow">goto</span> bad_id;
05235                 }
05236                 <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (len == -1 &amp;&amp; !in_dices-&gt;isimplied)
05237                     objid[len_index] = pos;
05238             } <span class="keywordflow">else</span> {
05239                 <span class="keywordflow">if</span> (!in_dices-&gt;isimplied &amp;&amp; len == -1) {
05240                     fcp = cp;
05241                     cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05242                     <span class="keywordflow">if</span> (cp2)
05243                         *cp2++ = 0;
05244                     len = strtoul(cp, &amp;ecp, 0);
05245                     <span class="keywordflow">if</span> (*ecp)
05246                         <span class="keywordflow">goto</span> bad_id;
05247                     <span class="keywordflow">if</span> (*objidlen + len + 1 &gt;= maxlen)
05248                         <span class="keywordflow">goto</span> bad_id;
05249                     objid[*objidlen] = len;
05250                     (*objidlen)++;
05251                     cp = cp2;
05252                 }
05253                 <span class="keywordflow">while</span> (len &amp;&amp; cp) {
05254                     fcp = cp;
05255                     cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05256                     <span class="keywordflow">if</span> (cp2)
05257                         *cp2++ = 0;
05258                     objid[*objidlen] = strtoul(cp, &amp;ecp, 0);
05259                     <span class="keywordflow">if</span> (*ecp)
05260                         <span class="keywordflow">goto</span> bad_id;
05261                     <span class="keywordflow">if</span> (check &amp;&amp; objid[*objidlen] &gt; 255)
05262                         <span class="keywordflow">goto</span> bad_id;
05263                     (*objidlen)++;
05264                     len--;
05265                     cp = cp2;
05266                 }
05267             }
05268             <span class="keywordflow">break</span>;
05269         <span class="keywordflow">case</span> TYPE_OBJID:
05270             in_dices = NULL;
05271             cp2 = cp;
05272             <span class="keywordflow">break</span>;
05273         <span class="keywordflow">case</span> TYPE_NETADDR:
05274             fcp = cp;
05275             cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05276             <span class="keywordflow">if</span> (cp2)
05277                 *cp2++ = 0;
05278             subid = strtoul(cp, &amp;ecp, 0);
05279             <span class="keywordflow">if</span> (*ecp)
05280                 <span class="keywordflow">goto</span> bad_id;
05281             <span class="keywordflow">if</span> (*objidlen + 1 &gt;= maxlen)
05282                 <span class="keywordflow">goto</span> bad_id;
05283             objid[*objidlen] = subid;
05284             (*objidlen)++;
05285             cp = cp2;
05286             <span class="keywordflow">if</span> (subid == 1) {
05287                 <span class="keywordflow">for</span> (len = 0; cp &amp;&amp; len &lt; 4; len++) {
05288                     fcp = cp;
05289                     cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05290                     <span class="keywordflow">if</span> (cp2)
05291                         *cp2++ = 0;
05292                     subid = strtoul(cp, &amp;ecp, 0);
05293                     <span class="keywordflow">if</span> (*ecp)
05294                         <span class="keywordflow">goto</span> bad_id;
05295                     <span class="keywordflow">if</span> (*objidlen + 1 &gt;= maxlen)
05296                         <span class="keywordflow">goto</span> bad_id;
05297                     <span class="keywordflow">if</span> (check &amp;&amp; subid &gt; 255)
05298                         <span class="keywordflow">goto</span> bad_id;
05299                     objid[*objidlen] = subid;
05300                     (*objidlen)++;
05301                     cp = cp2;
05302                 }
05303             }
05304             <span class="keywordflow">else</span> {
05305                 in_dices = NULL;
05306             }
05307             <span class="keywordflow">break</span>;
05308         <span class="keywordflow">default</span>:
05309             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Unexpected index type: %d %s %s\n"</span>,
05310                      tp-&gt;type, in_dices-&gt;ilabel, cp);
05311             in_dices = NULL;
05312             cp2 = cp;
05313             <span class="keywordflow">break</span>;
05314         }
05315         cp = cp2;
05316         <span class="keywordflow">if</span> (in_dices)
05317             in_dices = in_dices-&gt;next;
05318     }
05319 
05320 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05321     <span class="keywordflow">while</span> (cp) {
05322         fcp = cp;
05323         <span class="keywordflow">switch</span> (*cp) {
05324         <span class="keywordflow">case</span> <span class="charliteral">'0'</span>:
05325         <span class="keywordflow">case</span> <span class="charliteral">'1'</span>:
05326         <span class="keywordflow">case</span> <span class="charliteral">'2'</span>:
05327         <span class="keywordflow">case</span> <span class="charliteral">'3'</span>:
05328         <span class="keywordflow">case</span> <span class="charliteral">'4'</span>:
05329         <span class="keywordflow">case</span> <span class="charliteral">'5'</span>:
05330         <span class="keywordflow">case</span> <span class="charliteral">'6'</span>:
05331         <span class="keywordflow">case</span> <span class="charliteral">'7'</span>:
05332         <span class="keywordflow">case</span> <span class="charliteral">'8'</span>:
05333         <span class="keywordflow">case</span> <span class="charliteral">'9'</span>:
05334             cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05335             <span class="keywordflow">if</span> (cp2)
05336                 *cp2++ = 0;
05337             subid = strtoul(cp, &amp;ecp, 0);
05338             <span class="keywordflow">if</span> (*ecp)
05339                 <span class="keywordflow">goto</span> bad_id;
05340             <span class="keywordflow">if</span> (*objidlen &gt;= maxlen)
05341                 <span class="keywordflow">goto</span> bad_id;
05342             objid[*objidlen] = subid;
05343             (*objidlen)++;
05344             <span class="keywordflow">break</span>;
05345         <span class="keywordflow">case</span> <span class="charliteral">'"'</span>:
05346         <span class="keywordflow">case</span> <span class="charliteral">'\''</span>:
05347             doingquote = *cp++;
05348             <span class="comment">/*</span>
05349 <span class="comment">             * insert length if requested </span>
05350 <span class="comment">             */</span>
05351             <span class="keywordflow">if</span> (doingquote == <span class="charliteral">'"'</span>) {
05352                 <span class="keywordflow">if</span> (*objidlen &gt;= maxlen)
05353                     <span class="keywordflow">goto</span> bad_id;
05354                 objid[*objidlen] = len = strchr(cp, doingquote) - cp;
05355                 (*objidlen)++;
05356             }
05357 
05358             <span class="keywordflow">while</span> (*cp &amp;&amp; *cp != doingquote) {
05359                 <span class="keywordflow">if</span> (*objidlen &gt;= maxlen)
05360                     <span class="keywordflow">goto</span> bad_id;
05361                 objid[*objidlen] = *cp++;
05362                 (*objidlen)++;
05363             }
05364             <span class="keywordflow">if</span> (!cp)
05365                 <span class="keywordflow">goto</span> bad_id;
05366             cp2 = cp + 1;
05367             <span class="keywordflow">if</span> (!*cp2)
05368                 cp2 = NULL;
05369             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*cp2 == <span class=
"charliteral">'.'</span>)
05370                 cp2++;
05371             <span class="keywordflow">else</span>
05372                 <span class="keywordflow">goto</span> bad_id;
05373             <span class="keywordflow">break</span>;
05374         <span class="keywordflow">default</span>:
05375             <span class="keywordflow">goto</span> bad_id;
05376         }
05377         cp = cp2;
05378     }
05379     <span class="keywordflow">return</span> 1;
05380 
05381   bad_id:
05382     {
05383         <span class="keywordtype">char</span>            buf[256];
05384 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05385         <span class="keywordflow">if</span> (in_dices)
05386             snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class=
"stringliteral">"Index out of range: %s (%s)"</span>,
05387                     fcp, in_dices-&gt;ilabel);
05388         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tp)
05389             snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class=
"stringliteral">"Sub-id not found: %s -&gt; %s"</span>, tp-&gt;label, fcp);
05390         <span class="keywordflow">else</span>
05391 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05392             snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">"%s"</span>, fcp);
05393         buf[ <span class="keyword">sizeof</span>(buf)-1 ] = 0;
05394 
05395         snmp_set_detail(buf);
05396     }
05397     <span class="keywordflow">return</span> 0;
05398 }
05399 
05400 
05401 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05402 
05405 <span class="keywordtype">int</span>
<a name="l05406" id="l05406"></a><a class="code" href="group__mib__utilities.html#ga90">05406</a> <a class="code" href=
"group__mib__utilities.html#ga90">get_wild_node</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *name, oid * objid, size_t * objidlen)
05407 {
05408     <span class="keyword">struct </span>tree    *tp = find_best_tree_node(name, tree_head, NULL);
05409     <span class="keywordflow">if</span> (!tp)
05410         <span class="keywordflow">return</span> 0;
05411     <span class="keywordflow">return</span> get_node(tp-&gt;label, objid, objidlen);
05412 }
05413 
05414 <span class="keywordtype">int</span>
05415 get_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, oid * objid, size_t * objidlen)
05416 {
05417     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp;
05418     <span class="keywordtype">char</span>            ch;
05419     <span class="keywordtype">int</span>             res;
05420 
05421     cp = name;
05422     <span class="keywordflow">while</span> ((ch = *cp))
05423         <span class="keywordflow">if</span> ((<span class=
"charliteral">'0'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'9'</span>)
05424             || (<span class="charliteral">'a'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'z'</span>)
05425             || (<span class="charliteral">'A'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'Z'</span>)
05426             || ch == <span class="charliteral">'-'</span>)
05427             cp++;
05428         <span class="keywordflow">else</span>
05429             <span class="keywordflow">break</span>;
05430     <span class="keywordflow">if</span> (ch != <span class="charliteral">':'</span>)
05431         <span class="keywordflow">if</span> (*name == <span class="charliteral">'.'</span>)
05432             res = get_module_node(name + 1, <span class="stringliteral">"ANY"</span>, objid, objidlen);
05433         <span class="keywordflow">else</span>
05434             res = get_module_node(name, <span class="stringliteral">"ANY"</span>, objid, objidlen);
05435     <span class="keywordflow">else</span> {
05436         <span class="keywordtype">char</span>           *module;
05437         <span class="comment">/*</span>
05438 <span class="comment">         *  requested name is of the form</span>
05439 <span class="comment">         *      "module:subidentifier"</span>
05440 <span class="comment">         */</span>
05441         module = (<span class="keywordtype">char</span> *) malloc((size_t) (cp - name + 1));
05442         <span class="keywordflow">if</span> (!module)
05443             <span class="keywordflow">return</span> SNMPERR_GENERR;
05444         memcpy(module, name, (size_t) (cp - name));
05445         module[cp - name] = 0;
05446         cp++;                   <span class="comment">/* cp now point to the subidentifier */</span>
05447         <span class="keywordflow">if</span> (*cp == <span class="charliteral">':'</span>)
05448             cp++;
05449 
05450         <span class="comment">/*</span>
05451 <span class="comment">         * 'cp' and 'name' *do* go that way round! </span>
05452 <span class="comment">         */</span>
05453         res = get_module_node(cp, module, objid, objidlen);
05454         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(module);
05455     }
05456     <span class="keywordflow">if</span> (res == 0) {
05457         SET_SNMP_ERROR(SNMPERR_UNKNOWN_OBJID);
05458     }
05459 
05460     <span class="keywordflow">return</span> res;
05461 }
05462 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05463 
05464 <span class="preprocessor">#ifdef testing</span>
05465 
05466 main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
05467 {
05468     oid             objid[MAX_OID_LEN];
05469     <span class="keywordtype">int</span>             objidlen = MAX_OID_LEN;
05470     <span class="keywordtype">int</span>             count;
05471     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> variable;
05472 
05473     <a class="code" href="group__mib__utilities.html#ga56">init_mib</a>();
05474     <span class="keywordflow">if</span> (argc &lt; 2)
05475         print_subtree(stdout, tree_head, 0);
05476     variable.<a class="code" href="structvariable__list.html#o3">type</a> = ASN_INTEGER;
05477     variable.<a class="code" href="structvariable__list.html#o4">val</a>.integer = 3;
05478     variable.<a class="code" href="structvariable__list.html#o5">val_len</a> = 4;
05479     <span class="keywordflow">for</span> (argc--; argc; argc--, argv++) {
05480         objidlen = MAX_OID_LEN;
05481         printf(<span class="stringliteral">"read_objid(%s) = %d\n"</span>,
05482                argv[1], <a class="code" href=
"group__mib__utilities.html#ga61">read_objid</a>(argv[1], objid, &amp;objidlen));
05483         <span class="keywordflow">for</span> (count = 0; count &lt; objidlen; count++)
05484             printf(<span class="stringliteral">"%d."</span>, objid[count]);
05485         printf(<span class="stringliteral">"\n"</span>);
05486         <a class="code" href="group__mib__utilities.html#ga70">print_variable</a>(objid, objidlen, &amp;variable);
05487     }
05488 }
05489 
05490 <span class="preprocessor">#endif                          </span><span class="comment">/* testing */</span>
05491 
05492 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05493 <span class="comment">/*</span>
05494 <span class="comment"> * initialize: no peers included in the report. </span>
05495 <span class="comment"> */</span>
05496 <span class="keywordtype">void</span>
05497 clear_tree_flags(<span class="keyword">register</span> <span class="keyword">struct</span> tree *tp)
05498 {
05499     <span class="keywordflow">for</span> (; tp; tp = tp-&gt;next_peer) {
05500         tp-&gt;reported = 0;
05501         <span class="keywordflow">if</span> (tp-&gt;child_list)
05502             clear_tree_flags(tp-&gt;child_list);
05503      <span class="comment">/*RECURSE*/</span>}
05504 }
05505 
05506 <span class="comment">/*</span>
05507 <span class="comment"> * Update: 1998-07-17 &lt;jhy@gsu.edu&gt;</span>
05508 <span class="comment"> * Added print_oid_report* functions.</span>
05509 <span class="comment"> */</span>
05510 <span class="keyword">static</span> <span class="keywordtype">int</span>      print_subtree_oid_report_labeledoid = 0;
05511 <span class="keyword">static</span> <span class="keywordtype">int</span>      print_subtree_oid_report_oid = 0;
05512 <span class="keyword">static</span> <span class="keywordtype">int</span>      print_subtree_oid_report_symbolic = 0;
05513 <span class="keyword">static</span> <span class="keywordtype">int</span>      print_subtree_oid_report_suffix = 0;
05514 
05515 <span class="comment">/*</span>
05516 <span class="comment"> * These methods recurse. </span>
05517 <span class="comment"> */</span>
05518 <span class="keyword">static</span> <span class="keywordtype">void</span>     print_parent_labeledoid(FILE *, <span class=
"keyword">struct</span> tree *);
05519 <span class="keyword">static</span> <span class="keywordtype">void</span>     print_parent_oid(FILE *, <span class=
"keyword">struct</span> tree *);
05520 <span class="keyword">static</span> <span class="keywordtype">void</span>     print_parent_label(FILE *, <span class=
"keyword">struct</span> tree *);
05521 <span class="keyword">static</span> <span class="keywordtype">void</span>     print_subtree_oid_report(FILE *, <span class=
"keyword">struct</span> tree *, <span class="keywordtype">int</span>);
05522 
05523 
05524 <span class="keywordtype">void</span>
05525 print_oid_report(FILE * fp)
05526 {
05527     <span class="keyword">struct </span>tree    *tp;
05528     clear_tree_flags(tree_head);
05529     <span class="keywordflow">for</span> (tp = tree_head; tp; tp = tp-&gt;next_peer)
05530         print_subtree_oid_report(fp, tp, 0);
05531 }
05532 
05533 <span class="keywordtype">void</span>
05534 print_oid_report_enable_labeledoid(<span class="keywordtype">void</span>)
05535 {
05536     print_subtree_oid_report_labeledoid = 1;
05537 }
05538 
05539 <span class="keywordtype">void</span>
05540 print_oid_report_enable_oid(<span class="keywordtype">void</span>)
05541 {
05542     print_subtree_oid_report_oid = 1;
05543 }
05544 
05545 <span class="keywordtype">void</span>
05546 print_oid_report_enable_suffix(<span class="keywordtype">void</span>)
05547 {
05548     print_subtree_oid_report_suffix = 1;
05549 }
05550 
05551 <span class="keywordtype">void</span>
05552 print_oid_report_enable_symbolic(<span class="keywordtype">void</span>)
05553 {
05554     print_subtree_oid_report_symbolic = 1;
05555 }
05556 
05557 <span class="comment">/*</span>
05558 <span class="comment"> * helper methods for print_subtree_oid_report()</span>
05559 <span class="comment"> * each one traverses back up the node tree</span>
05560 <span class="comment"> * until there is no parent.  Then, the label combination</span>
05561 <span class="comment"> * is output, such that the parent is displayed first.</span>
05562 <span class="comment"> *</span>
05563 <span class="comment"> * Warning: these methods are all recursive.</span>
05564 <span class="comment"> */</span>
05565 
05566 <span class="keyword">static</span> <span class="keywordtype">void</span>
05567 print_parent_labeledoid(FILE * f, <span class="keyword">struct</span> tree *tp)
05568 {
05569     <span class="keywordflow">if</span> (tp) {
05570         <span class="keywordflow">if</span> (tp-&gt;parent) {
05571             print_parent_labeledoid(f, tp-&gt;parent);
05572          <span class="comment">/*RECURSE*/</span>}
05573         fprintf(f, <span class="stringliteral">".%s(%lu)"</span>, tp-&gt;label, tp-&gt;subid);
05574     }
05575 }
05576 
05577 <span class="keyword">static</span> <span class="keywordtype">void</span>
05578 print_parent_oid(FILE * f, <span class="keyword">struct</span> tree *tp)
05579 {
05580     <span class="keywordflow">if</span> (tp) {
05581         <span class="keywordflow">if</span> (tp-&gt;parent) {
05582             print_parent_oid(f, tp-&gt;parent);
05583          <span class="comment">/*RECURSE*/</span>}
05584         fprintf(f, <span class="stringliteral">".%lu"</span>, tp-&gt;subid);
05585     }
05586 }
05587 
05588 <span class="keyword">static</span> <span class="keywordtype">void</span>
05589 print_parent_label(FILE * f, <span class="keyword">struct</span> tree *tp)
05590 {
05591     <span class="keywordflow">if</span> (tp) {
05592         <span class="keywordflow">if</span> (tp-&gt;parent) {
05593             print_parent_label(f, tp-&gt;parent);
05594          <span class="comment">/*RECURSE*/</span>}
05595         fprintf(f, <span class="stringliteral">".%s"</span>, tp-&gt;label);
05596     }
05597 }
05598 
05610 <span class="keyword">static</span> <span class="keywordtype">void</span>
05611 print_subtree_oid_report(FILE * f, <span class="keyword">struct</span> tree *tree, <span class=
"keywordtype">int</span> count)
05612 {
05613     <span class="keyword">struct </span>tree    *tp;
05614 
05615     count++;
05616 
05617     <span class="comment">/*</span>
05618 <span class="comment">     * sanity check </span>
05619 <span class="comment">     */</span>
05620     <span class="keywordflow">if</span> (!tree) {
05621         <span class="keywordflow">return</span>;
05622     }
05623 
05624     <span class="comment">/*</span>
05625 <span class="comment">     * find the not reported peer with the lowest sub-identifier.</span>
05626 <span class="comment">     * if no more, break the loop and cleanup.</span>
05627 <span class="comment">     * set "reported" flag, and create report for this peer.</span>
05628 <span class="comment">     * recurse using the children of this peer, if any.</span>
05629 <span class="comment">     */</span>
05630     <span class="keywordflow">while</span> (1) {
05631         <span class="keyword">register</span> <span class="keyword">struct </span>tree *ntp;
05632 
05633         tp = 0;
05634         <span class="keywordflow">for</span> (ntp = tree-&gt;child_list; ntp; ntp = ntp-&gt;next_peer) {
05635             <span class="keywordflow">if</span> (ntp-&gt;reported)
05636                 <span class="keywordflow">continue</span>;
05637 
05638             <span class="keywordflow">if</span> (!tp || (tp-&gt;subid &gt; ntp-&gt;subid))
05639                 tp = ntp;
05640         }
05641         <span class="keywordflow">if</span> (!tp)
05642             <span class="keywordflow">break</span>;
05643 
05644         tp-&gt;reported = 1;
05645 
05646         <span class="keywordflow">if</span> (print_subtree_oid_report_labeledoid) {
05647             print_parent_labeledoid(f, tp);
05648             fprintf(f, <span class="stringliteral">"\n"</span>);
05649         }
05650         <span class="keywordflow">if</span> (print_subtree_oid_report_oid) {
05651             print_parent_oid(f, tp);
05652             fprintf(f, <span class="stringliteral">"\n"</span>);
05653         }
05654         <span class="keywordflow">if</span> (print_subtree_oid_report_symbolic) {
05655             print_parent_label(f, tp);
05656             fprintf(f, <span class="stringliteral">"\n"</span>);
05657         }
05658         <span class="keywordflow">if</span> (print_subtree_oid_report_suffix) {
05659             <span class="keywordtype">int</span>             i;
05660             <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
05661                 fprintf(f, <span class="stringliteral">"  "</span>);
05662             fprintf(f, <span class="stringliteral">"%s(%ld) type=%d"</span>, tp-&gt;label, tp-&gt;subid, tp-&gt;type);
05663             <span class="keywordflow">if</span> (tp-&gt;tc_index != -1)
05664                 fprintf(f, <span class="stringliteral">" tc=%d"</span>, tp-&gt;tc_index);
05665             <span class="keywordflow">if</span> (tp-&gt;hint)
05666                 fprintf(f, <span class="stringliteral">" hint=%s"</span>, tp-&gt;hint);
05667             <span class="keywordflow">if</span> (tp-&gt;units)
05668                 fprintf(f, <span class="stringliteral">" units=%s"</span>, tp-&gt;units);
05669 
05670             fprintf(f, <span class="stringliteral">"\n"</span>);
05671         }
05672         print_subtree_oid_report(f, tp, count);
05673      <span class="comment">/*RECURSE*/</span>}
05674 }
05675 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05676 
05677 
05690 <span class="keywordtype">char</span>           *
<a name="l05691" id="l05691"></a><a class="code" href="group__mib__utilities.html#ga102">05691</a> <a class="code" href=
"group__mib__utilities.html#ga102">uptime_string</a>(u_long timeticks, <span class="keywordtype">char</span> *buf)
05692 {
05693     uptimeString(timeticks, buf);
05694 <span class="preprocessor">#ifdef CMU_COMPATIBLE</span>
05695     {
05696     <span class="keywordtype">char</span> *cp = strrchr(buf, <span class="charliteral">'.'</span>);
05697     <span class="keywordflow">if</span> (cp)
05698         *cp = <span class="charliteral">'\0'</span>;
05699     }
05700 <span class="preprocessor">#endif</span>
05701     <span class="keywordflow">return</span> buf;
05702 }
05703 
05719 oid            *
<a name="l05720" id="l05720"></a><a class="code" href="group__mib__utilities.html#ga103">05720</a> <a class="code" href=
"group__mib__utilities.html#ga103">snmp_parse_oid</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *argv, oid * root, size_t * rootlen)
05721 {
05722     size_t          savlen = *rootlen;
05723     <span class="keyword">static</span> size_t   tmpbuf_len = 0;
05724     <span class="keyword">static</span> <span class="keywordtype">char</span>    *tmpbuf;
05725     <span class="keyword">const</span> <span class="keywordtype">char</span>     *suffix, *prefix;
05726 
05727     suffix = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
05728                                    NETSNMP_DS_LIB_OIDSUFFIX);
05729     prefix = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
05730                                    NETSNMP_DS_LIB_OIDPREFIX);
05731     <span class="keywordflow">if</span> ((suffix &amp;&amp; suffix[0]) || (prefix &amp;&amp; prefix[0])) {
05732         <span class="keywordflow">if</span> (!suffix)
05733             suffix = <span class="stringliteral">""</span>;
05734         <span class="keywordflow">if</span> (!prefix)
05735             prefix = <span class="stringliteral">""</span>;
05736         <span class="keywordflow">if</span> ((strlen(suffix) + strlen(prefix) + strlen(argv) + 2) &gt; tmpbuf_len) {
05737             tmpbuf_len = strlen(suffix) + strlen(argv) + strlen(prefix) + 2;
05738             tmpbuf = realloc(tmpbuf, tmpbuf_len);
05739         }
05740         snprintf(tmpbuf, tmpbuf_len, <span class="stringliteral">"%s%s%s%s"</span>, prefix, argv,
05741                  ((suffix[0] == <span class="charliteral">'.'</span> || suffix[0] == <span class=
"charliteral">'\0'</span>) ? <span class="stringliteral">""</span> : <span class="stringliteral">"."</span>),
05742                  suffix);
05743         argv = tmpbuf;
05744         DEBUGMSGTL((<span class="stringliteral">"snmp_parse_oid"</span>,<span class=
"stringliteral">"Parsing: %s\n"</span>,argv));
05745     }
05746 
05747 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05748     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_RANDOM_ACCESS)
05749         || strchr(argv, <span class="charliteral">':'</span>)) {
05750         <span class="keywordflow">if</span> (get_node(argv, root, rootlen)) {
05751             <span class="keywordflow">return</span> root;
05752         }
05753     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REGEX_ACCESS)) {
05754         clear_tree_flags(tree_head);
05755         <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga90">get_wild_node</a>(argv, root, rootlen)) {
05756             <span class="keywordflow">return</span> root;
05757         }
05758     } <span class="keywordflow">else</span> {
05759 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05760         <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga61">read_objid</a>(argv, root, rootlen)) {
05761             <span class="keywordflow">return</span> root;
05762         }
05763 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05764         *rootlen = savlen;
05765         <span class="keywordflow">if</span> (get_node(argv, root, rootlen)) {
05766             <span class="keywordflow">return</span> root;
05767         }
05768         *rootlen = savlen;
05769         DEBUGMSGTL((<span class="stringliteral">"parse_oid"</span>, <span class=
"stringliteral">"wildly parsing\n"</span>));
05770         clear_tree_flags(tree_head);
05771         <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga90">get_wild_node</a>(argv, root, rootlen)) {
05772             <span class="keywordflow">return</span> root;
05773         }
05774     }
05775 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05776     <span class="keywordflow">return</span> NULL;
05777 }
05778 
05779 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05780 <span class="comment">/*</span>
05781 <span class="comment"> * Use DISPLAY-HINT to parse a value into an octet string.</span>
05782 <span class="comment"> *</span>
05783 <span class="comment"> * note that "1d1d", "11" could have come from an octet string that</span>
05784 <span class="comment"> * looked like { 1, 1 } or an octet string that looked like { 11 }</span>
05785 <span class="comment"> * because of this, it's doubtful that anyone would use such a display</span>
05786 <span class="comment"> * string. Therefore, the parser ignores this case.</span>
05787 <span class="comment"> */</span>
05788 
05789 <span class="keyword">struct </span>parse_hints {
05790     <span class="keywordtype">int</span> length;
05791     <span class="keywordtype">int</span> repeat;
05792     <span class="keywordtype">int</span> format;
05793     <span class="keywordtype">int</span> separator;
05794     <span class="keywordtype">int</span> terminator;
05795     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *result;
05796     <span class="keywordtype">int</span> result_max;
05797     <span class="keywordtype">int</span> result_len;
05798 };
05799 
05800 <span class="keyword">static</span> <span class="keywordtype">void</span> parse_hints_reset(<span class=
"keyword">struct</span> parse_hints *ph)
05801 {
05802     ph-&gt;length = 0;
05803     ph-&gt;repeat = 0;
05804     ph-&gt;format = 0;
05805     ph-&gt;separator = 0;
05806     ph-&gt;terminator = 0;
05807 }
05808 
05809 <span class="keyword">static</span> <span class="keywordtype">void</span> parse_hints_ctor(<span class=
"keyword">struct</span> parse_hints *ph)
05810 {
05811     parse_hints_reset(ph);
05812     ph-&gt;result = NULL;
05813     ph-&gt;result_max = 0;
05814     ph-&gt;result_len = 0;
05815 }
05816 
05817 <span class="keyword">static</span> <span class="keywordtype">int</span> parse_hints_add_result_octet(<span class=
"keyword">struct</span> parse_hints *ph, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> octet)
05818 {
05819     <span class="keywordflow">if</span> (!(ph-&gt;result_len &lt; ph-&gt;result_max)) {
05820         ph-&gt;result_max = ph-&gt;result_len + 32;
05821         <span class="keywordflow">if</span> (!ph-&gt;result) {
05822             ph-&gt;result = (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">char</span> *)malloc(ph-&gt;result_max);
05823         } <span class="keywordflow">else</span> {
05824             ph-&gt;result = (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">char</span> *)realloc(ph-&gt;result, ph-&gt;result_max);
05825         }
05826     }
05827     
05828     <span class="keywordflow">if</span> (!ph-&gt;result) {
05829         <span class="keywordflow">return</span> 0;               <span class="comment">/* failed */</span>
05830     }
05831 
05832     ph-&gt;result[ph-&gt;result_len++] = octet;
05833     <span class="keywordflow">return</span> 1;                   <span class="comment">/* success */</span>
05834 }
05835 
05836 <span class="keyword">static</span> <span class="keywordtype">int</span> parse_hints_parse(<span class=
"keyword">struct</span> parse_hints *ph, <span class="keyword">const</span> <span class="keywordtype">char</span> **v_in_out)
05837 {
05838     <span class="keyword">const</span> <span class="keywordtype">char</span> *v = *v_in_out;
05839     <span class="keywordtype">char</span> *nv;
05840     <span class="keywordtype">int</span> base;
05841     <span class="keywordtype">int</span> repeats = 0;
05842     <span class="keywordtype">int</span> repeat_fixup = ph-&gt;result_len;
05843     
05844     <span class="keywordflow">if</span> (ph-&gt;repeat) {
05845         <span class="keywordflow">if</span> (!parse_hints_add_result_octet(ph, 0)) {
05846             <span class="keywordflow">return</span> 0;
05847         }
05848     }
05849     <span class="keywordflow">do</span> {
05850         base = 0;
05851         <span class="keywordflow">switch</span> (ph-&gt;format) {
05852         <span class="keywordflow">case</span> <span class="charliteral">'x'</span>: base += 6;    <span class=
"comment">/* fall through */</span>
05853         <span class="keywordflow">case</span> <span class="charliteral">'d'</span>: base += 2;    <span class=
"comment">/* fall through */</span>
05854         <span class="keywordflow">case</span> <span class="charliteral">'o'</span>: base += 8;    <span class=
"comment">/* fall through */</span>
05855             {
05856                 <span class="keywordtype">int</span> i;
05857                 <span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span> number = strtol(v, &amp;nv, base);
05858                 <span class="keywordflow">if</span> (nv == v) <span class="keywordflow">return</span> 0;
05859                 v = nv;
05860                 <span class="keywordflow">for</span> (i = 0; i &lt; ph-&gt;length; i++) {
05861                     <span class="keywordtype">int</span> shift = 8 * (ph-&gt;length - 1 - i);
05862                     <span class=
"keywordflow">if</span> (!parse_hints_add_result_octet(ph, (u_char)(number &gt;&gt; shift) )) {
05863                         <span class="keywordflow">return</span> 0; <span class="comment">/* failed */</span>
05864                     }
05865                 }
05866             }
05867             <span class="keywordflow">break</span>;
05868 
05869         <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
05870             {
05871                 <span class="keywordtype">int</span> i;
05872                     
05873                 <span class="keywordflow">for</span> (i = 0; i &lt; ph-&gt;length &amp;&amp; *v; i++) {
05874                     <span class="keywordflow">if</span> (!parse_hints_add_result_octet(ph, *v++)) {
05875                         <span class="keywordflow">return</span> 0;       <span class="comment">/* failed */</span>
05876                     }
05877                 }
05878             }
05879             <span class="keywordflow">break</span>;
05880         }
05881 
05882         repeats++;
05883 
05884         <span class="keywordflow">if</span> (ph-&gt;separator &amp;&amp; *v) {
05885             <span class="keywordflow">if</span> (*v == ph-&gt;separator) {
05886                 v++;
05887             } <span class="keywordflow">else</span> {
05888                 <span class="keywordflow">return</span> 0;               <span class="comment">/* failed */</span>
05889             }
05890         }
05891 
05892         <span class="keywordflow">if</span> (ph-&gt;terminator) {
05893             <span class="keywordflow">if</span> (*v == ph-&gt;terminator) {
05894                 v++;
05895                 <span class="keywordflow">break</span>;
05896             }
05897         }
05898     } <span class="keywordflow">while</span> (ph-&gt;repeat &amp;&amp; *v);
05899     <span class="keywordflow">if</span> (ph-&gt;repeat) {
05900         ph-&gt;result[repeat_fixup] = repeats;
05901     }
05902 
05903     *v_in_out = v;
05904     <span class="keywordflow">return</span> 1;
05905 }
05906 
05907 <span class="keyword">static</span> <span class="keywordtype">void</span> parse_hints_length_add_digit(<span class=
"keyword">struct</span> parse_hints *ph, <span class="keywordtype">int</span> digit)
05908 {
05909     ph-&gt;length *= 10;
05910     ph-&gt;length += digit - <span class="charliteral">'0'</span>;
05911 }
05912 
05913 <span class="keyword">const</span> <span class="keywordtype">char</span> *parse_octet_hint(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *hint, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *value, <span class="keywordtype">unsigned</span> <span class=
"keywordtype">char</span> **new_val, <span class="keywordtype">int</span> *new_val_len)
05914 {
05915     <span class="keyword">const</span> <span class="keywordtype">char</span> *h = hint;
05916     <span class="keyword">const</span> <span class="keywordtype">char</span> *v = value;
05917     <span class="keyword">struct </span>parse_hints ph;
05918     <span class="keywordtype">int</span> retval = 1;
05919     <span class="comment">/* See RFC 1443 */</span>
05920     <span class="keyword">enum</span> {
05921         HINT_1_2,
05922         HINT_2_3,
05923         HINT_1_2_4,
05924         HINT_1_2_5
05925     } state = HINT_1_2;
05926 
05927     parse_hints_ctor(&amp;ph);
05928     <span class="keywordflow">while</span> (*h &amp;&amp; *v &amp;&amp; retval) {
05929         <span class="keywordflow">switch</span> (state) {
05930         <span class="keywordflow">case</span> HINT_1_2:
05931             <span class="keywordflow">if</span> (<span class="charliteral">'*'</span> == *h) {
05932                 ph.repeat = 1;
05933                 state = HINT_2_3;
05934             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isdigit(*h)) {
05935                 parse_hints_length_add_digit(&amp;ph, *h);
05936                 state = HINT_2_3;
05937             } <span class="keywordflow">else</span> {
05938                 <span class="keywordflow">return</span> v;       <span class="comment">/* failed */</span>
05939             }
05940             <span class="keywordflow">break</span>;
05941 
05942         <span class="keywordflow">case</span> HINT_2_3:
05943             <span class="keywordflow">if</span> (isdigit(*h)) {
05944                 parse_hints_length_add_digit(&amp;ph, *h);
05945                 <span class="comment">/* state = HINT_2_3 */</span>
05946             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class=
"charliteral">'x'</span> == *h || <span class="charliteral">'d'</span> == *h || <span class=
"charliteral">'o'</span> == *h || <span class="charliteral">'a'</span> == *h) {
05947                 ph.format = *h;
05948                 state = HINT_1_2_4;
05949             } <span class="keywordflow">else</span> {
05950                 <span class="keywordflow">return</span> v;       <span class="comment">/* failed */</span>
05951             }
05952             <span class="keywordflow">break</span>;
05953 
05954         <span class="keywordflow">case</span> HINT_1_2_4:
05955             <span class="keywordflow">if</span> (<span class="charliteral">'*'</span> == *h) {
05956                 retval = parse_hints_parse(&amp;ph, &amp;v);
05957                 parse_hints_reset(&amp;ph);
05958                 
05959                 ph.repeat = 1;
05960                 state = HINT_2_3;
05961             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isdigit(*h)) {
05962                 retval = parse_hints_parse(&amp;ph, &amp;v);
05963                 parse_hints_reset(&amp;ph);
05964                 
05965                 parse_hints_length_add_digit(&amp;ph, *h);
05966                 state = HINT_2_3;
05967             } <span class="keywordflow">else</span> {
05968                 ph.separator = *h;
05969                 state = HINT_1_2_5;
05970             }
05971             <span class="keywordflow">break</span>;
05972 
05973         <span class="keywordflow">case</span> HINT_1_2_5:
05974             <span class="keywordflow">if</span> (<span class="charliteral">'*'</span> == *h) {
05975                 retval = parse_hints_parse(&amp;ph, &amp;v);
05976                 parse_hints_reset(&amp;ph);
05977                 
05978                 ph.repeat = 1;
05979                 state = HINT_2_3;
05980             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isdigit(*h)) {
05981                 retval = parse_hints_parse(&amp;ph, &amp;v);
05982                 parse_hints_reset(&amp;ph);
05983                 
05984                 parse_hints_length_add_digit(&amp;ph, *h);
05985                 state = HINT_2_3;
05986             } <span class="keywordflow">else</span> {
05987                 ph.terminator = *h;
05988 
05989                 retval = parse_hints_parse(&amp;ph, &amp;v);
05990                 parse_hints_reset(&amp;ph);
05991 
05992                 state = HINT_1_2;
05993             }
05994             <span class="keywordflow">break</span>;
05995         }
05996         h++;
05997     }
05998     <span class="keywordflow">while</span> (*v &amp;&amp; retval) {
05999         retval = parse_hints_parse(&amp;ph, &amp;v);
06000     }
06001     <span class="keywordflow">if</span> (retval) {
06002         *new_val = ph.result;
06003         *new_val_len = ph.result_len;
06004     } <span class="keywordflow">else</span> {
06005         <span class="keywordflow">if</span> (ph.result) {
06006             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ph.result);
06007         }
06008         *new_val = NULL;
06009         *new_val_len = 0;
06010     }
06011     <span class="keywordflow">return</span> retval ? NULL : v;
06012 }
06013 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06014 
06015 <span class="preprocessor">#ifdef test_display_hint</span>
06016 
06017 <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class=
"keyword">const</span> <span class="keywordtype">char</span> **argv)
06018 {
06019     <span class="keyword">const</span> <span class="keywordtype">char</span> *hint;
06020     <span class="keyword">const</span> <span class="keywordtype">char</span> *value;
06021     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *new_val;
06022     <span class="keywordtype">int</span> new_val_len;
06023     <span class="keywordtype">char</span> *r;
06024     
06025     <span class="keywordflow">if</span> (argc &lt; 3) {
06026         fprintf(stderr, <span class="stringliteral">"usage: dh &lt;hint&gt; &lt;value&gt;\n"</span>);
06027         exit(2);
06028     }
06029     hint = argv[1];
06030     value = argv[2];
06031     r = parse_octet_hint(hint, value, &amp;new_val, &amp;new_val_len);
06032     printf(<span class="stringliteral">"{\"%s\", \"%s\"}: \n\t"</span>, hint, value);
06033     <span class="keywordflow">if</span> (r) {
06034         *r = 0;
06035         printf(<span class="stringliteral">"returned failed\n"</span>);
06036         printf(<span class="stringliteral">"value syntax error at: %s\n"</span>, value);
06037     }
06038     <span class="keywordflow">else</span> {
06039         <span class="keywordtype">int</span> i;
06040         printf(<span class="stringliteral">"returned success\n"</span>);
06041         <span class="keywordflow">for</span> (i = 0; i &lt; new_val_len; i++) {
06042             <span class="keywordtype">int</span> c = new_val[i] &amp; 0xFF;
06043             printf(<span class="stringliteral">"%02X(%c) "</span>, c, isprint(c) ? c : <span class=
"charliteral">' '</span>);
06044         }
06045         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(new_val);
06046     }
06047     printf(<span class="stringliteral">"\n"</span>);
06048     exit(0);
06049 }
06050 
06051 <span class="preprocessor">#endif </span><span class="comment">/* test_display_hint */</span>
06052 
06053 u_char
06054 mib_to_asn_type(<span class="keywordtype">int</span> mib_type)
06055 {
06056     <span class="keywordflow">switch</span> (mib_type) {
06057     <span class="keywordflow">case</span> TYPE_OBJID:
06058         <span class="keywordflow">return</span> ASN_OBJECT_ID;
06059 
06060     <span class="keywordflow">case</span> TYPE_OCTETSTR:
06061         <span class="keywordflow">return</span> ASN_OCTET_STR;
06062 
06063     <span class="keywordflow">case</span> TYPE_NETADDR:
06064     <span class="keywordflow">case</span> TYPE_IPADDR:
06065         <span class="keywordflow">return</span> ASN_IPADDRESS;
06066 
06067     <span class="keywordflow">case</span> TYPE_INTEGER32:
06068     <span class="keywordflow">case</span> TYPE_INTEGER:
06069         <span class="keywordflow">return</span> ASN_INTEGER;
06070 
06071     <span class="keywordflow">case</span> TYPE_COUNTER:
06072         <span class="keywordflow">return</span> ASN_COUNTER;
06073 
06074     <span class="keywordflow">case</span> TYPE_GAUGE:
06075         <span class="keywordflow">return</span> ASN_GAUGE;
06076 
06077     <span class="keywordflow">case</span> TYPE_TIMETICKS:
06078         <span class="keywordflow">return</span> ASN_TIMETICKS;
06079 
06080     <span class="keywordflow">case</span> TYPE_OPAQUE:
06081         <span class="keywordflow">return</span> ASN_OPAQUE;
06082 
06083     <span class="keywordflow">case</span> TYPE_NULL:
06084         <span class="keywordflow">return</span> ASN_NULL;
06085 
06086     <span class="keywordflow">case</span> TYPE_COUNTER64:
06087         <span class="keywordflow">return</span> ASN_COUNTER64;
06088 
06089     <span class="keywordflow">case</span> TYPE_BITSTRING:
06090         <span class="keywordflow">return</span> ASN_BIT_STR;
06091 
06092     <span class="keywordflow">case</span> TYPE_UINTEGER:
06093     <span class="keywordflow">case</span> TYPE_UNSIGNED32:
06094         <span class="keywordflow">return</span> ASN_UNSIGNED;
06095 
06096     <span class="keywordflow">case</span> TYPE_NSAPADDRESS:
06097         <span class="keywordflow">return</span> ASN_NSAP;
06098 
06099     }
06100     <span class="keywordflow">return</span> -1;
06101 }
06102 
06113 <span class="keywordtype">int</span>
<a name="l06114" id="l06114"></a><a class="code" href="group__mib__utilities.html#ga111">06114</a> <a class="code" href=
"group__mib__utilities.html#ga111">netsnmp_str2oid</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *S, oid * O, <span class="keywordtype">int</span> L)
06115 {
06116     <span class="keyword">const</span> <span class="keywordtype">char</span>     *c = S;
06117     oid            *o = &amp;O[1];
06118 
06119     --L;                        <span class="comment">/* leave room for length prefix */</span>
06120 
06121     <span class="keywordflow">for</span> (; *c &amp;&amp; L; --L, ++o, ++c)
06122         *o = *c;
06123 
06124     <span class="comment">/*</span>
06125 <span class="comment">     * make sure we got to the end of the string </span>
06126 <span class="comment">     */</span>
06127     <span class="keywordflow">if</span> (*c != 0)
06128         <span class="keywordflow">return</span> 1;
06129 
06130     <span class="comment">/*</span>
06131 <span class="comment">     * set the length of the oid </span>
06132 <span class="comment">     */</span>
06133     *O = c - S;
06134 
06135     <span class="keywordflow">return</span> 0;
06136 }
06137 
06148 <span class="keywordtype">int</span>
<a name="l06149" id="l06149"></a><a class="code" href="group__mib__utilities.html#ga112">06149</a> <a class="code" href=
"group__mib__utilities.html#ga112">netsnmp_oid2chars</a>(<span class="keywordtype">char</span> *C, <span class=
"keywordtype">int</span> L, <span class="keyword">const</span> oid * O)
06150 {
06151     <span class="keywordtype">char</span>           *c = C;
06152     <span class="keyword">const</span> oid      *o = &amp;O[1];
06153 
06154     <span class="keywordflow">if</span> (L &lt; (int)*O)
06155         <span class="keywordflow">return</span> 1;
06156 
06157     L = *O; 
06158     <span class="keywordflow">for</span> (; L; --L, ++o, ++c) {
06159         <span class="keywordflow">if</span> (*o &gt; 0xFF)
06160             <span class="keywordflow">return</span> 1;
06161         *c = (char)*o;
06162     }
06163     <span class="keywordflow">return</span> 0;
06164 }
06165 
06176 <span class="keywordtype">int</span>
<a name="l06177" id="l06177"></a><a class="code" href="group__mib__utilities.html#ga113">06177</a> <a class="code" href=
"group__mib__utilities.html#ga113">netsnmp_oid2str</a>(<span class="keywordtype">char</span> *S, <span class=
"keywordtype">int</span> L, oid * O)
06178 {
06179     <span class="keywordtype">int</span>            rc;
06180 
06181     <span class="keywordflow">if</span> (L &lt;= (int)*O)
06182         <span class="keywordflow">return</span> 1;
06183 
06184     rc = <a class="code" href="group__mib__utilities.html#ga112">netsnmp_oid2chars</a>(S, L, O);
06185     <span class="keywordflow">if</span> (rc)
06186         <span class="keywordflow">return</span> 1;
06187 
06188     S[ *O ] = 0;
06189 
06190     <span class="keywordflow">return</span> 0;
06191 }
06192 
06193 <span class="keywordtype">int</span>
06194 snprint_by_type(<span class="keywordtype">char</span> *buf, size_t buf_len,
06195                 <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * var,
06196                 <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
06197                 <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06198 {
06199     size_t          out_len = 0;
06200     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_by_type</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06201                                var, enums, hint, units))
06202         <span class="keywordflow">return</span> (int) out_len;
06203     <span class="keywordflow">else</span>
06204         <span class="keywordflow">return</span> -1;
06205 }
06206 
06207 <span class="keywordtype">int</span>
06208 snprint_hexstring(<span class="keywordtype">char</span> *buf, size_t buf_len, <span class=
"keyword">const</span> u_char * cp, size_t len)
06209 {
06210     size_t          out_len = 0;
06211     <span class="keywordflow">if</span> (sprint_realloc_hexstring((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06212                                  cp, len))
06213         <span class="keywordflow">return</span> (int) out_len;
06214     <span class="keywordflow">else</span>
06215         <span class="keywordflow">return</span> -1;
06216 }
06217 
06218 <span class="keywordtype">int</span>
06219 snprint_asciistring(<span class="keywordtype">char</span> *buf, size_t buf_len,
06220                     <span class="keyword">const</span> u_char * cp, size_t len)
06221 {
06222     size_t          out_len = 0;
06223     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga27">sprint_realloc_asciistring</a>
06224         ((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0, cp, len))
06225         <span class="keywordflow">return</span> (int) out_len;
06226     <span class="keywordflow">else</span>
06227         <span class="keywordflow">return</span> -1;
06228 }
06229 
06230 <span class="keywordtype">int</span>
06231 snprint_octet_string(<span class="keywordtype">char</span> *buf, size_t buf_len,
06232                      <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06233                      <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06234 {
06235     size_t          out_len = 0;
06236     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga28">sprint_realloc_octet_string</a>
06237         ((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0, var, enums, hint,
06238          units))
06239         <span class="keywordflow">return</span> (int) out_len;
06240     <span class="keywordflow">else</span>
06241         <span class="keywordflow">return</span> -1;
06242 }
06243 
06244 <span class="keywordtype">int</span>
06245 snprint_opaque(<span class="keywordtype">char</span> *buf, size_t buf_len,
06246                <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06247                <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06248 {
06249     size_t          out_len = 0;
06250     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga30">sprint_realloc_opaque</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06251                               var, enums, hint, units))
06252         <span class="keywordflow">return</span> (int) out_len;
06253     <span class="keywordflow">else</span>
06254         <span class="keywordflow">return</span> -1;
06255 }
06256 
06257 <span class="keywordtype">int</span>
06258 snprint_object_identifier(<span class="keywordtype">char</span> *buf, size_t buf_len,
06259                           <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
06260                           <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums, <span class="keyword">const</span> <span class="keywordtype">char</span> *hint,
06261                           <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
06262 {
06263     size_t          out_len = 0;
06264     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga31">sprint_realloc_object_identifier</a>
06265         ((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0, var, enums, hint,
06266          units))
06267         <span class="keywordflow">return</span> (int) out_len;
06268     <span class="keywordflow">else</span>
06269         <span class="keywordflow">return</span> -1;
06270 }
06271 
06272 <span class="keywordtype">int</span>
06273 snprint_timeticks(<span class="keywordtype">char</span> *buf, size_t buf_len,
06274                   <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06275                   <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06276 {
06277     size_t          out_len = 0;
06278     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga32">sprint_realloc_timeticks</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06279                                  var, enums, hint, units))
06280         <span class="keywordflow">return</span> (int) out_len;
06281     <span class="keywordflow">else</span>
06282         <span class="keywordflow">return</span> -1;
06283 }
06284 
06285 <span class="keywordtype">int</span>
06286 snprint_hinted_integer(<span class="keywordtype">char</span> *buf, size_t buf_len,
06287                        <span class="keywordtype">long</span> val, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *hint, <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
06288 {
06289     size_t          out_len = 0;
06290     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga33">sprint_realloc_hinted_integer</a>
06291         ((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0, val, <span class="charliteral">'d'</span>, hint, units))
06292         <span class="keywordflow">return</span> (int) out_len;
06293     <span class="keywordflow">else</span>
06294         <span class="keywordflow">return</span> -1;
06295 }
06296 
06297 <span class="keywordtype">int</span>
06298 snprint_integer(<span class="keywordtype">char</span> *buf, size_t buf_len,
06299                 <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06300                 <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06301 {
06302     size_t          out_len = 0;
06303     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga34">sprint_realloc_integer</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06304                                var, enums, hint, units))
06305         <span class="keywordflow">return</span> (int) out_len;
06306     <span class="keywordflow">else</span>
06307         <span class="keywordflow">return</span> -1;
06308 }
06309 
06310 <span class="keywordtype">int</span>
06311 snprint_uinteger(<span class="keywordtype">char</span> *buf, size_t buf_len,
06312                  <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06313                  <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06314 {
06315     size_t          out_len = 0;
06316     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga35">sprint_realloc_uinteger</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06317                                 var, enums, hint, units))
06318         <span class="keywordflow">return</span> (int) out_len;
06319     <span class="keywordflow">else</span>
06320         <span class="keywordflow">return</span> -1;
06321 }
06322 
06323 <span class="keywordtype">int</span>
06324 snprint_gauge(<span class="keywordtype">char</span> *buf, size_t buf_len,
06325               <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06326               <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06327 {
06328     size_t          out_len = 0;
06329     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga36">sprint_realloc_gauge</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06330                              var, enums, hint, units))
06331         <span class="keywordflow">return</span> (int) out_len;
06332     <span class="keywordflow">else</span>
06333         <span class="keywordflow">return</span> -1;
06334 }
06335 
06336 <span class="keywordtype">int</span>
06337 snprint_counter(<span class="keywordtype">char</span> *buf, size_t buf_len,
06338                 <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06339                 <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06340 {
06341     size_t          out_len = 0;
06342     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga37">sprint_realloc_counter</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06343                                var, enums, hint, units))
06344         <span class="keywordflow">return</span> (int) out_len;
06345     <span class="keywordflow">else</span>
06346         <span class="keywordflow">return</span> -1;
06347 }
06348 
06349 <span class="keywordtype">int</span>
06350 snprint_networkaddress(<span class="keywordtype">char</span> *buf, size_t buf_len,
06351                        <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
06352                        <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums, <span class="keyword">const</span> <span class="keywordtype">char</span> *hint,
06353                        <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
06354 {
06355     size_t          out_len = 0;
06356     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga38">sprint_realloc_networkaddress</a>
06357         ((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0, var, enums, hint,
06358          units))
06359         <span class="keywordflow">return</span> (int) out_len;
06360     <span class="keywordflow">else</span>
06361         <span class="keywordflow">return</span> -1;
06362 }
06363 
06364 <span class="keywordtype">int</span>
06365 snprint_ipaddress(<span class="keywordtype">char</span> *buf, size_t buf_len,
06366                   <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06367                   <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06368 {
06369     size_t          out_len = 0;
06370     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga39">sprint_realloc_ipaddress</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06371                                  var, enums, hint, units))
06372         <span class="keywordflow">return</span> (int) out_len;
06373     <span class="keywordflow">else</span>
06374         <span class="keywordflow">return</span> -1;
06375 }
06376 
06377 <span class="keywordtype">int</span>
06378 snprint_null(<span class="keywordtype">char</span> *buf, size_t buf_len,
06379              <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06380              <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06381 {
06382     size_t          out_len = 0;
06383     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga40">sprint_realloc_null</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06384                             var, enums, hint, units))
06385         <span class="keywordflow">return</span> (int) out_len;
06386     <span class="keywordflow">else</span>
06387         <span class="keywordflow">return</span> -1;
06388 }
06389 
06390 <span class="keywordtype">int</span>
06391 snprint_bitstring(<span class="keywordtype">char</span> *buf, size_t buf_len,
06392                   <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06393                   <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06394 {
06395     size_t          out_len = 0;
06396     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga41">sprint_realloc_bitstring</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06397                                  var, enums, hint, units))
06398         <span class="keywordflow">return</span> (int) out_len;
06399     <span class="keywordflow">else</span>
06400         <span class="keywordflow">return</span> -1;
06401 }
06402 
06403 <span class="keywordtype">int</span>
06404 snprint_nsapaddress(<span class="keywordtype">char</span> *buf, size_t buf_len,
06405                     <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06406                     <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06407 {
06408     size_t          out_len = 0;
06409     <span class="keywordflow">if</span> (sprint_realloc_nsapaddress
06410         ((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0, var, enums, hint,
06411          units))
06412         <span class="keywordflow">return</span> (int) out_len;
06413     <span class="keywordflow">else</span>
06414         <span class="keywordflow">return</span> -1;
06415 }
06416 
06417 <span class="keywordtype">int</span>
06418 snprint_counter64(<span class="keywordtype">char</span> *buf, size_t buf_len,
06419                   <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06420                   <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06421 {
06422     size_t          out_len = 0;
06423     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga29">sprint_realloc_counter64</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06424                                  var, enums, hint, units))
06425         <span class="keywordflow">return</span> (int) out_len;
06426     <span class="keywordflow">else</span>
06427         <span class="keywordflow">return</span> -1;
06428 }
06429 
06430 <span class="keywordtype">int</span>
06431 snprint_badtype(<span class="keywordtype">char</span> *buf, size_t buf_len,
06432                 <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06433                 <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06434 {
06435     size_t          out_len = 0;
06436     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga43">sprint_realloc_badtype</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06437                                var, enums, hint, units))
06438         <span class="keywordflow">return</span> (int) out_len;
06439     <span class="keywordflow">else</span>
06440         <span class="keywordflow">return</span> -1;
06441 }
06442 
06443 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
06444 <span class="keywordtype">int</span>
06445 snprint_float(<span class="keywordtype">char</span> *buf, size_t buf_len,
06446               <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06447               <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06448 {
06449     size_t          out_len = 0;
06450     <span class="keywordflow">if</span> (sprint_realloc_float((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06451                              var, enums, hint, units))
06452         <span class="keywordflow">return</span> (int) out_len;
06453     <span class="keywordflow">else</span>
06454         <span class="keywordflow">return</span> -1;
06455 }
06456 
06457 <span class="keywordtype">int</span>
06458 snprint_double(<span class="keywordtype">char</span> *buf, size_t buf_len,
06459                <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06460                <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06461 {
06462     size_t          out_len = 0;
06463     <span class="keywordflow">if</span> (sprint_realloc_double((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06464                               var, enums, hint, units))
06465         <span class="keywordflow">return</span> (int) out_len;
06466     <span class="keywordflow">else</span>
06467         <span class="keywordflow">return</span> -1;
06468 }
06469 <span class="preprocessor">#endif</span>
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small><!--#include virtual="/sfbutton.html" --><br />
    Generated on Thu Oct 28 21:46:57 2004 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

