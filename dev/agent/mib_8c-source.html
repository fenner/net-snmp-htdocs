<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>mib.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * mib.c</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * $Id$</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> * Update: 1998-07-17 &lt;jhy@gsu.edu&gt;</span>
00007 <span class="comment"> * Added print_oid_report* functions.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> */</span>
00010 <span class="comment">/* Portions of this file are subject to the following copyrights.  See</span>
00011 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00012 <span class="comment"> * that may apply:</span>
00013 <span class="comment"> */</span>
00014 <span class="comment">/**********************************************************************</span>
00015 <span class="comment">        Copyright 1988, 1989, 1991, 1992 by Carnegie Mellon University</span>
00016 
00017 <span class="comment">                      All Rights Reserved</span>
00018 
00019 <span class="comment">Permission to use, copy, modify, and distribute this software and its</span>
00020 <span class="comment">documentation for any purpose and without fee is hereby granted,</span>
00021 <span class="comment">provided that the above copyright notice appear in all copies and that</span>
00022 <span class="comment">both that copyright notice and this permission notice appear in</span>
00023 <span class="comment">supporting documentation, and that the name of CMU not be</span>
00024 <span class="comment">used in advertising or publicity pertaining to distribution of the</span>
00025 <span class="comment">software without specific, written prior permission.</span>
00026 
00027 <span class="comment">CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING</span>
00028 <span class="comment">ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL</span>
00029 <span class="comment">CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR</span>
00030 <span class="comment">ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</span>
00031 <span class="comment">WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,</span>
00032 <span class="comment">ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS</span>
00033 <span class="comment">SOFTWARE.</span>
00034 <span class="comment">******************************************************************/</span>
00035 <span class="comment">/*</span>
00036 <span class="comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
00037 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00038 <span class="comment"> * distributed with the Net-SNMP package.</span>
00039 <span class="comment"> */</span>
00040 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00041 
00042 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00043 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00044 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00045 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00046 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00047 <span class="preprocessor">#endif</span>
00048 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00049 <span class="preprocessor"># ifdef WIN32</span>
00050 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00051 <span class="preprocessor"># else</span>
00052 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00053 <span class="preprocessor"># endif</span>
00054 <span class="preprocessor"># include &lt;time.h&gt;</span>
00055 <span class="preprocessor">#else</span>
00056 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00057 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00058 <span class="preprocessor"># else</span>
00059 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00060 <span class="preprocessor"># endif</span>
00061 <span class="preprocessor">#endif</span>
00062 <span class="preprocessor">#if HAVE_STRING_H</span>
00063 <span class="preprocessor">#include &lt;string.h&gt;</span>
00064 <span class="preprocessor">#else</span>
00065 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00066 <span class="preprocessor">#endif</span>
00067 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00068 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00069 <span class="preprocessor">#endif</span>
00070 <span class="preprocessor">#if HAVE_SYS_SELECT_H</span>
00071 <span class="preprocessor">#include &lt;sys/select.h&gt;</span>
00072 <span class="preprocessor">#endif</span>
00073 
00074 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00075 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00076 <span class="preprocessor">#endif</span>
00077 
00078 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00079 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00080 <span class="preprocessor">#endif</span>
00081 
00082 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00083 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00084 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00085 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00086 
00087 <span class="preprocessor">#include &lt;net-snmp/library/asn1.h&gt;</span>
00088 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00089 <span class="preprocessor">#include &lt;net-snmp/library/mib.h&gt;</span>
00090 <span class="preprocessor">#include &lt;net-snmp/library/parse.h&gt;</span>
00091 <span class="preprocessor">#include &lt;net-snmp/library/int64.h&gt;</span>
00092 <span class="preprocessor">#include &lt;net-snmp/library/snmp_client.h&gt;</span>
00093 
00100 <span class="keyword">static</span> <span class="keywordtype">char</span>    *uptimeString(u_long, <span class=
"keywordtype">char</span> *, size_t);
00101 
00102 <span class="keyword">static</span> <span class="keyword">struct </span>tree *_get_realloc_symbol(<span class=
"keyword">const</span> oid * objid, size_t objidlen,
00103                                         <span class="keyword">struct</span> tree *subtree,
00104                                         u_char ** buf, size_t * buf_len,
00105                                         size_t * out_len,
00106                                         <span class="keywordtype">int</span> allow_realloc,
00107                                         <span class="keywordtype">int</span> *buf_overflow,
00108                                         <span class="keyword">struct</span> index_list *in_dices,
00109                                         size_t * end_of_known);
00110 
00111 <span class="keyword">static</span> <span class=
"keywordtype">int</span>      print_tree_node(u_char ** buf, size_t * buf_len,
00112                                 size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
00113                                 <span class="keyword">struct</span> tree *tp, <span class="keywordtype">int</span> width);
00114 <span class="keyword">static</span> <span class="keywordtype">void</span>     handle_mibdirs_conf(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keywordtype">char</span> *line);
00115 <span class="keyword">static</span> <span class="keywordtype">void</span>     handle_mibs_conf(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keywordtype">char</span> *line);
00116 <span class="keyword">static</span> <span class="keywordtype">void</span>     handle_mibfile_conf(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keywordtype">char</span> *line);
00117 
00118 <span class="keyword">static</span> <span class="keywordtype">void</span>     _oid_finish_printing(<span class=
"keyword">const</span> oid * objid, size_t objidlen,
00119                                      u_char ** buf, size_t * buf_len,
00120                                      size_t * out_len,
00121                                      <span class="keywordtype">int</span> allow_realloc, <span class=
"keywordtype">int</span> *buf_overflow);
00122 
00123 <span class="comment">/*</span>
00124 <span class="comment"> * helper functions for get_module_node </span>
00125 <span class="comment"> */</span>
00126 <span class="keyword">static</span> <span class="keywordtype">int</span>      node_to_oid(<span class=
"keyword">struct</span> tree *, oid *, size_t *);
00127 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
00128 <span class="keyword">static</span> <span class="keywordtype">int</span>      _add_strings_to_oid(<span class=
"keyword">struct</span> tree *, <span class="keywordtype">char</span> *,
00129                                     oid *, size_t *, size_t);
00130 <span class="preprocessor">#else</span>
00131 <span class="keyword">static</span> <span class="keywordtype">int</span>      _add_strings_to_oid(<span class=
"keywordtype">void</span> *, <span class="keywordtype">char</span> *,
00132                                     oid *, size_t *, size_t);
00133 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
00134 
00135 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
00136 <span class="keyword">extern</span> <span class="keyword">struct </span>tree *tree_head;
00137 <span class="keyword">static</span> <span class="keyword">struct </span>tree *tree_top;
00138 
00139 <span class="keyword">struct </span>tree    *Mib;            <span class="comment">/* Backwards compatibility */</span>
00140 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
00141 
00142 oid             RFC1213_MIB[] = { 1, 3, 6, 1, 2, 1 };
00143 <span class="keyword">static</span> <span class="keywordtype">char</span>     Standard_Prefix[] = <span class=
"stringliteral">".1.3.6.1.2.1"</span>;
00144 
00145 <span class="comment">/*</span>
00146 <span class="comment"> * Set default here as some uses of read_objid require valid pointer. </span>
00147 <span class="comment"> */</span>
00148 <span class="keyword">static</span> <span class="keywordtype">char</span>    *Prefix = &amp;Standard_Prefix[0];
00149 <span class="keyword">typedef</span> <span class="keyword">struct </span>_PrefixList {
00150     <span class="keyword">const</span> <span class="keywordtype">char</span>     *str;
00151     <span class="keywordtype">int</span>             len;
00152 }              *PrefixListPtr, PrefixList;
00153 
00154 <span class="comment">/*</span>
00155 <span class="comment"> * Here are the prefix strings.</span>
00156 <span class="comment"> * Note that the first one finds the value of Prefix or Standard_Prefix.</span>
00157 <span class="comment"> * Any of these MAY start with period; all will NOT end with period.</span>
00158 <span class="comment"> * Period is added where needed.  See use of Prefix in this module.</span>
00159 <span class="comment"> */</span>
00160 PrefixList      mib_prefixes[] = {
00161     {&amp;Standard_Prefix[0]},      <span class="comment">/* placeholder for Prefix data */</span>
00162     {<span class="stringliteral">".iso.org.dod.internet.mgmt.mib-2"</span>},
00163     {<span class="stringliteral">".iso.org.dod.internet.experimental"</span>},
00164     {<span class="stringliteral">".iso.org.dod.internet.private"</span>},
00165     {<span class="stringliteral">".iso.org.dod.internet.snmpParties"</span>},
00166     {<span class="stringliteral">".iso.org.dod.internet.snmpSecrets"</span>},
00167     {NULL, 0}                   <span class="comment">/* end of list */</span>
00168 };
00169 
00170 <span class="keyword">enum</span> inet_address_type {
00171     IPV4 = 1,
00172     IPV6 = 2,
00173     IPV4Z = 3,
00174     IPV6Z = 4,
00175     DNS = 16
00176 };
00177 
00178 
00189 <span class="keyword">static</span> <span class="keywordtype">char</span>    *
00190 uptimeString(u_long timeticks, <span class="keywordtype">char</span> *buf, size_t buflen)
00191 {
00192     <span class="keywordtype">int</span>             centisecs, seconds, minutes, hours, days;
00193 
00194     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS)) {
00195         snprintf(buf, buflen, <span class="stringliteral">"%lu"</span>, timeticks);
00196         <span class="keywordflow">return</span> buf;
00197     }
00198 
00199 
00200     centisecs = timeticks % 100;
00201     timeticks /= 100;
00202     days = timeticks / (60 * 60 * 24);
00203     timeticks %= (60 * 60 * 24);
00204 
00205     hours = timeticks / (60 * 60);
00206     timeticks %= (60 * 60);
00207 
00208     minutes = timeticks / 60;
00209     seconds = timeticks % 60;
00210 
00211     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT))
00212         snprintf(buf, buflen, <span class="stringliteral">"%d:%d:%02d:%02d.%02d"</span>,
00213                 days, hours, minutes, seconds, centisecs);
00214     <span class="keywordflow">else</span> {
00215         <span class="keywordflow">if</span> (days == 0) {
00216             snprintf(buf, buflen, <span class="stringliteral">"%d:%02d:%02d.%02d"</span>,
00217                     hours, minutes, seconds, centisecs);
00218         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (days == 1) {
00219             snprintf(buf, buflen, <span class="stringliteral">"%d day, %d:%02d:%02d.%02d"</span>,
00220                     days, hours, minutes, seconds, centisecs);
00221         } <span class="keywordflow">else</span> {
00222             snprintf(buf, buflen, <span class="stringliteral">"%d days, %d:%02d:%02d.%02d"</span>,
00223                     days, hours, minutes, seconds, centisecs);
00224         }
00225     }
00226     <span class="keywordflow">return</span> buf;
00227 }
00228 
00229 
00230 
00239 <span class="keyword">static</span> <span class="keywordtype">void</span>
00240 sprint_char(<span class="keywordtype">char</span> *buf, <span class="keyword">const</span> u_char ch)
00241 {
00242     <span class="keywordflow">if</span> (isprint(ch) || isspace(ch)) {
00243         sprintf(buf, <span class="stringliteral">"%c"</span>, (<span class="keywordtype">int</span>) ch);
00244     } <span class="keywordflow">else</span> {
00245         sprintf(buf, <span class="stringliteral">"."</span>);
00246     }
00247 }
00248 
00249 
00250 
00270 <span class="keywordtype">int</span>
<a name="l00271" id="l00271"></a><a class="code" href="group__mib__utilities.html#ga26">00271</a> <a class="code" href=
"group__mib__utilities.html#ga26">_sprint_hexstring_line</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
00272                        <span class="keywordtype">int</span> allow_realloc, <span class=
"keyword">const</span> u_char * cp, size_t line_len)
00273 {
00274     <span class="keyword">const</span> u_char   *tp;
00275     <span class="keyword">const</span> u_char   *cp2 = cp;
00276     size_t          lenleft = line_len;
00277 
00278     <span class="comment">/*</span>
00279 <span class="comment">     * Make sure there's enough room for the hex output....</span>
00280 <span class="comment">     */</span>
00281     <span class="keywordflow">while</span> ((*out_len + line_len*3+1) &gt;= *buf_len) {
00282         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00283             <span class="keywordflow">return</span> 0;
00284         }
00285     }
00286 
00287     <span class="comment">/*</span>
00288 <span class="comment">     * .... and display the hex values themselves....</span>
00289 <span class="comment">     */</span>
00290     <span class="keywordflow">for</span> (; lenleft &gt;= 8; lenleft-=8) {
00291         sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len),
00292                 <span class="stringliteral">"%02X %02X %02X %02X %02X %02X %02X %02X "</span>, cp[0], cp[1],
00293                 cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
00294         *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
00295         cp       += 8;
00296     }
00297     <span class="keywordflow">for</span> (; lenleft &gt; 0; lenleft--) {
00298         sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class=
"stringliteral">"%02X "</span>, *cp++);
00299         *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
00300     }
00301 
00302     <span class="comment">/*</span>
00303 <span class="comment">     * .... plus (optionally) do the same for the ASCII equivalent.</span>
00304 <span class="comment">     */</span>
00305     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT)) {
00306         <span class="keywordflow">while</span> ((*out_len + line_len+5) &gt;= *buf_len) {
00307             <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00308                 <span class="keywordflow">return</span> 0;
00309             }
00310         }
00311         sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class="stringliteral">"  ["</span>);
00312         *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
00313         <span class="keywordflow">for</span> (tp = cp2; tp &lt; cp; tp++) {
00314             sprint_char((<span class="keywordtype">char</span> *) (*buf + *out_len), *tp);
00315             (*out_len)++;
00316         }
00317         sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class="stringliteral">"]"</span>);
00318         *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
00319     }
00320     <span class="keywordflow">return</span> 1;
00321 }
00322 
00323 <span class="keywordtype">int</span>
00324 sprint_realloc_hexstring(u_char ** buf, size_t * buf_len, size_t * out_len,
00325                          <span class="keywordtype">int</span> allow_realloc, <span class=
"keyword">const</span> u_char * cp, size_t len)
00326 {
00327     <span class="keywordtype">int</span> line_len = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID,
00328                                       NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH);
00329     <span class="keywordflow">if</span> (!line_len)
00330         line_len=len;
00331 
00332     <span class="keywordflow">for</span> (; (int)len &gt; line_len; len -= line_len) {
00333         <span class="keywordflow">if</span>(!<a class="code" href=
"group__mib__utilities.html#ga26">_sprint_hexstring_line</a>(buf, buf_len, out_len, allow_realloc, cp, line_len))
00334             <span class="keywordflow">return</span> 0;
00335         *(*buf + (*out_len)++) = <span class="charliteral">'\n'</span>;
00336         *(*buf + *out_len) = 0;
00337         cp += line_len;
00338     }
00339     <span class="keywordflow">if</span>(!<a class="code" href=
"group__mib__utilities.html#ga26">_sprint_hexstring_line</a>(buf, buf_len, out_len, allow_realloc, cp, len))
00340         <span class="keywordflow">return</span> 0;
00341     *(*buf + *out_len) = 0;
00342     <span class="keywordflow">return</span> 1;
00343 }
00344 
00345 
00346 
00366 <span class="keywordtype">int</span>
<a name="l00367" id="l00367"></a><a class="code" href="group__mib__utilities.html#ga28">00367</a> <a class="code" href=
"group__mib__utilities.html#ga28">sprint_realloc_asciistring</a>(u_char ** buf, size_t * buf_len,
00368                            size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
00369                            <span class="keyword">const</span> u_char * cp, size_t len)
00370 {
00371     <span class="keywordtype">int</span>             i;
00372 
00373     <span class="keywordflow">for</span> (i = 0; i &lt; (int) len; i++) {
00374         <span class="keywordflow">if</span> (isprint(*cp) || isspace(*cp)) {
00375             <span class="keywordflow">if</span> (*cp == <span class="charliteral">'\\'</span> || *cp == <span class=
"charliteral">'"'</span>) {
00376                 <span class="keywordflow">if</span> ((*out_len &gt;= *buf_len) &amp;&amp;
00377                     !(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00378                     <span class="keywordflow">return</span> 0;
00379                 }
00380                 *(*buf + (*out_len)++) = <span class="charliteral">'\\'</span>;
00381             }
00382             <span class="keywordflow">if</span> ((*out_len &gt;= *buf_len) &amp;&amp;
00383                 !(allow_realloc &amp;&amp; <a class="code" href="group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00384                 <span class="keywordflow">return</span> 0;
00385             }
00386             *(*buf + (*out_len)++) = *cp++;
00387         } <span class="keywordflow">else</span> {
00388             <span class="keywordflow">if</span> ((*out_len &gt;= *buf_len) &amp;&amp;
00389                 !(allow_realloc &amp;&amp; <a class="code" href="group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00390                 <span class="keywordflow">return</span> 0;
00391             }
00392             *(*buf + (*out_len)++) = <span class="charliteral">'.'</span>;
00393             cp++;
00394         }
00395     }
00396     <span class="keywordflow">if</span> ((*out_len &gt;= *buf_len) &amp;&amp;
00397         !(allow_realloc &amp;&amp; <a class="code" href="group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00398         <span class="keywordflow">return</span> 0;
00399     }
00400     *(*buf + *out_len) = <span class="charliteral">'\0'</span>;
00401     <span class="keywordflow">return</span> 1;
00402 }
00403 
00426 <span class="keywordtype">int</span>
<a name="l00427" id="l00427"></a><a class="code" href="group__mib__utilities.html#ga29">00427</a> <a class="code" href=
"group__mib__utilities.html#ga29">sprint_realloc_octet_string</a>(u_char ** buf, size_t * buf_len,
00428                             size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
00429                             <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
00430                             <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums, <span class="keyword">const</span> <span class="keywordtype">char</span> *hint,
00431                             <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
00432 {
00433     size_t          saved_out_len = *out_len;
00434     <span class="keyword">const</span> <span class="keywordtype">char</span>     *saved_hint = hint;
00435     <span class="keywordtype">int</span>             hex = 0, x = 0;
00436     u_char         *cp;
00437     <span class="keywordtype">int</span>             output_format;
00438 
00439     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OCTET_STR) &amp;&amp; 
00440         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
00441         <span class="keyword">const</span> <span class="keywordtype">char</span>      str[] = <span class=
"stringliteral">"Wrong Type (should be OCTET STRING): "</span>;
00442         <span class="keywordflow">if</span> (snmp_strcat
00443             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) str)) {
00444             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
00445                                           allow_realloc, var, NULL, NULL,
00446                                           NULL);
00447         } <span class="keywordflow">else</span> {
00448             <span class="keywordflow">return</span> 0;
00449         }
00450     }
00451 
00452 
00453     <span class="keywordflow">if</span> (hint) {
00454         <span class="keywordtype">int</span>             repeat, width = 1;
00455         <span class="keywordtype">long</span>            value;
00456         <span class="keywordtype">char</span>            code = <span class=
"charliteral">'d'</span>, separ = 0, term = 0, ch, intbuf[16];
00457         u_char         *ecp;
00458 
00459         <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00460             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
00461                              (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"STRING: "</span>)) {
00462                 <span class="keywordflow">return</span> 0;
00463             }
00464         }
00465         cp = var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string;
00466         ecp = cp + var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>;
00467 
00468         <span class="keywordflow">while</span> (cp &lt; ecp) {
00469             repeat = 1;
00470             <span class="keywordflow">if</span> (*hint) {
00471                 <span class="keywordflow">if</span> (*hint == <span class="charliteral">'*'</span>) {
00472                     repeat = *cp++;
00473                     hint++;
00474                 }
00475                 width = 0;
00476                 <span class="keywordflow">while</span> (<span class=
"charliteral">'0'</span> &lt;= *hint &amp;&amp; *hint &lt;= <span class="charliteral">'9'</span>)
00477                     width = (width * 10) + (*hint++ - <span class="charliteral">'0'</span>);
00478                 code = *hint++;
00479                 <span class="keywordflow">if</span> ((ch = *hint) &amp;&amp; ch != <span class=
"charliteral">'*'</span> &amp;&amp; (ch &lt; '0' || ch &gt; <span class="charliteral">'9'</span>)
00480                     &amp;&amp; (width != 0
00481                         || (ch != <span class="charliteral">'x'</span> &amp;&amp; ch != <span class=
"charliteral">'d'</span> &amp;&amp; ch != <span class="charliteral">'o'</span>)))
00482                     separ = *hint++;
00483                 <span class="keywordflow">else</span>
00484                     separ = 0;
00485                 <span class="keywordflow">if</span> ((ch = *hint) &amp;&amp; ch != <span class=
"charliteral">'*'</span> &amp;&amp; (ch &lt; '0' || ch &gt; <span class="charliteral">'9'</span>)
00486                     &amp;&amp; (width != 0
00487                         || (ch != <span class="charliteral">'x'</span> &amp;&amp; ch != <span class=
"charliteral">'d'</span> &amp;&amp; ch != <span class="charliteral">'o'</span>)))
00488                     term = *hint++;
00489                 <span class="keywordflow">else</span>
00490                     term = 0;
00491             }
00492 
00493             <span class="keywordflow">while</span> (repeat &amp;&amp; cp &lt; ecp) {
00494                 value = 0;
00495                 <span class="keywordflow">if</span> (code != <span class=
"charliteral">'a'</span> &amp;&amp; code != <span class="charliteral">'t'</span>) {
00496                     <span class="keywordflow">for</span> (x = 0; x &lt; width; x++) {
00497                         value = value * 256 + *cp++;
00498                     }
00499                 }
00500                 <span class="keywordflow">switch</span> (code) {
00501                 <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
00502                     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
00503                                                NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT)
00504                                        &amp;&amp; value &lt; 16) {
00505                         sprintf(intbuf, <span class="stringliteral">"0%lx"</span>, value);
00506                     } <span class="keywordflow">else</span> {
00507                         sprintf(intbuf, <span class="stringliteral">"%lx"</span>, value);
00508                     }
00509                     <span class="keywordflow">if</span> (!snmp_strcat
00510                         (buf, buf_len, out_len, allow_realloc,
00511                          (u_char *) intbuf)) {
00512                         <span class="keywordflow">return</span> 0;
00513                     }
00514                     <span class="keywordflow">break</span>;
00515                 <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
00516                     sprintf(intbuf, <span class="stringliteral">"%ld"</span>, value);
00517                     <span class="keywordflow">if</span> (!snmp_strcat
00518                         (buf, buf_len, out_len, allow_realloc,
00519                          (u_char *) intbuf)) {
00520                         <span class="keywordflow">return</span> 0;
00521                     }
00522                     <span class="keywordflow">break</span>;
00523                 <span class="keywordflow">case</span> <span class="charliteral">'o'</span>:
00524                     sprintf(intbuf, <span class="stringliteral">"%lo"</span>, value);
00525                     <span class="keywordflow">if</span> (!snmp_strcat
00526                         (buf, buf_len, out_len, allow_realloc,
00527                          (u_char *) intbuf)) {
00528                         <span class="keywordflow">return</span> 0;
00529                     }
00530                     <span class="keywordflow">break</span>;
00531                 <span class="keywordflow">case</span> <span class="charliteral">'t'</span>: <span class=
"comment">/* new in rfc 3411 */</span>
00532                 <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
00533                     <span class="keywordflow">while</span> ((*out_len + width + 1) &gt;= *buf_len) {
00534                         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00535                             <span class="keywordflow">return</span> 0;
00536                         }
00537                     }
00538                     <span class="keywordflow">for</span> (x = 0; x &lt; width &amp;&amp; cp &lt; ecp; x++) {
00539                         *(*buf + *out_len) = *cp++;
00540                         (*out_len)++;
00541                     }
00542                     *(*buf + *out_len) = <span class="charliteral">'\0'</span>;
00543                     <span class="keywordflow">break</span>;
00544                 <span class="keywordflow">default</span>:
00545                     *out_len = saved_out_len;
00546                     <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc,
00547                                     (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"(Bad hint ignored: "</span>)
00548                         &amp;&amp; snmp_strcat(buf, buf_len, out_len,
00549                                        allow_realloc,
00550                                        (<span class="keyword">const</span> u_char *) saved_hint)
00551                         &amp;&amp; snmp_strcat(buf, buf_len, out_len,
00552                                        allow_realloc,
00553                                        (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">") "</span>)) {
00554                         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga29">sprint_realloc_octet_string</a>(buf, buf_len,
00555                                                            out_len,
00556                                                            allow_realloc,
00557                                                            var, enums,
00558                                                            NULL, NULL);
00559                     } <span class="keywordflow">else</span> {
00560                         <span class="keywordflow">return</span> 0;
00561                     }
00562                 }
00563 
00564                 <span class="keywordflow">if</span> (cp &lt; ecp &amp;&amp; separ) {
00565                     <span class="keywordflow">while</span> ((*out_len + 1) &gt;= *buf_len) {
00566                         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00567                             <span class="keywordflow">return</span> 0;
00568                         }
00569                     }
00570                     *(*buf + *out_len) = separ;
00571                     (*out_len)++;
00572                     *(*buf + *out_len) = <span class="charliteral">'\0'</span>;
00573                 }
00574                 repeat--;
00575             }
00576 
00577             <span class="keywordflow">if</span> (term &amp;&amp; cp &lt; ecp) {
00578                 <span class="keywordflow">while</span> ((*out_len + 1) &gt;= *buf_len) {
00579                     <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00580                         <span class="keywordflow">return</span> 0;
00581                     }
00582                 }
00583                 *(*buf + *out_len) = term;
00584                 (*out_len)++;
00585                 *(*buf + *out_len) = <span class="charliteral">'\0'</span>;
00586             }
00587         }
00588 
00589         <span class="keywordflow">if</span> (units) {
00590             <span class="keywordflow">return</span> (snmp_strcat
00591                     (buf, buf_len, out_len, allow_realloc,
00592                      (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
00593                     &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
00594                                    (<span class="keyword">const</span> u_char *) units));
00595         }
00596         <span class="keywordflow">if</span> ((*out_len &gt;= *buf_len) &amp;&amp;
00597             !(allow_realloc &amp;&amp; <a class="code" href="group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00598             <span class="keywordflow">return</span> 0;
00599         }
00600         *(*buf + *out_len) = <span class="charliteral">'\0'</span>;
00601 
00602         <span class="keywordflow">return</span> 1;
00603     }
00604 
00605     output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT);
00606     <span class="keywordflow">if</span> (0 == output_format) {
00607         output_format = NETSNMP_STRING_OUTPUT_GUESS;
00608     }
00609     <span class="keywordflow">switch</span> (output_format) {
00610     <span class="keywordflow">case</span> NETSNMP_STRING_OUTPUT_GUESS:
00611         hex = 0;
00612         <span class="keywordflow">for</span> (cp = var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string, x = 0; x &lt; (int) var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>; x++, cp++) {
00613             <span class="keywordflow">if</span> (!isprint(*cp) &amp;&amp; !isspace(*cp)) {
00614                 hex = 1;
00615             }
00616         }
00617         <span class="keywordflow">break</span>;
00618 
00619     <span class="keywordflow">case</span> NETSNMP_STRING_OUTPUT_ASCII:
00620         hex = 0;
00621         <span class="keywordflow">break</span>;
00622 
00623     <span class="keywordflow">case</span> NETSNMP_STRING_OUTPUT_HEX:
00624         hex = 1;
00625         <span class="keywordflow">break</span>;
00626     }
00627 
00628     <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> == 0) {
00629         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
00630                            (<span class="keyword">const</span> u_char *) <span class="stringliteral">"\"\""</span>);
00631     }
00632 
00633     <span class="keywordflow">if</span> (hex) {
00634         <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00635             <span class="keywordflow">if</span> (!snmp_strcat
00636                 (buf, buf_len, out_len, allow_realloc,
00637                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"\""</span>)) {
00638                 <span class="keywordflow">return</span> 0;
00639             }
00640         } <span class="keywordflow">else</span> {
00641             <span class="keywordflow">if</span> (!snmp_strcat
00642                 (buf, buf_len, out_len, allow_realloc,
00643                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"Hex-STRING: "</span>)) {
00644                 <span class="keywordflow">return</span> 0;
00645             }
00646         }
00647 
00648         <span class="keywordflow">if</span> (!sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,
00649                                       var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string, var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>)) {
00650             <span class="keywordflow">return</span> 0;
00651         }
00652 
00653         <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00654             <span class="keywordflow">if</span> (!snmp_strcat
00655                 (buf, buf_len, out_len, allow_realloc,
00656                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"\""</span>)) {
00657                 <span class="keywordflow">return</span> 0;
00658             }
00659         }
00660     } <span class="keywordflow">else</span> {
00661         <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00662             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
00663                              (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"STRING: "</span>)) {
00664                 <span class="keywordflow">return</span> 0;
00665             }
00666         }
00667         <span class="keywordflow">if</span> (!snmp_strcat
00668             (buf, buf_len, out_len, allow_realloc,
00669              (<span class="keyword">const</span> u_char *) <span class="stringliteral">"\""</span>)) {
00670             <span class="keywordflow">return</span> 0;
00671         }
00672         <span class="keywordflow">if</span> (!<a class="code" href=
"group__mib__utilities.html#ga28">sprint_realloc_asciistring</a>
00673             (buf, buf_len, out_len, allow_realloc, var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string,
00674              var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>)) {
00675             <span class="keywordflow">return</span> 0;
00676         }
00677         <span class="keywordflow">if</span> (!snmp_strcat
00678             (buf, buf_len, out_len, allow_realloc,
00679              (<span class="keyword">const</span> u_char *) <span class="stringliteral">"\""</span>)) {
00680             <span class="keywordflow">return</span> 0;
00681         }
00682     }
00683 
00684     <span class="keywordflow">if</span> (units) {
00685         <span class="keywordflow">return</span> (snmp_strcat
00686                 (buf, buf_len, out_len, allow_realloc,
00687                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
00688                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
00689                                (<span class="keyword">const</span> u_char *) units));
00690     }
00691     <span class="keywordflow">return</span> 1;
00692 }
00693 
00694 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00695 
00718 <span class="keywordtype">int</span>
00719 sprint_realloc_float(u_char ** buf, size_t * buf_len,
00720                      size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
00721                      <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
00722                      <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
00723                      <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
00724 {
00725     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE_FLOAT) &amp;&amp;
00726         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
00727         u_char          str[] = <span class="stringliteral">"Wrong Type (should be Float): "</span>;
00728         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
00729             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
00730                                           allow_realloc, var, NULL, NULL,
00731                                           NULL);
00732         } <span class="keywordflow">else</span> {
00733             <span class="keywordflow">return</span> 0;
00734         }
00735     }
00736 
00737     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00738         <span class="keywordflow">if</span> (!snmp_strcat
00739             (buf, buf_len, out_len, allow_realloc,
00740              (<span class="keyword">const</span> u_char *) <span class="stringliteral">"Opaque: Float: "</span>)) {
00741             <span class="keywordflow">return</span> 0;
00742         }
00743     }
00744 
00745 
00746     <span class="comment">/*</span>
00747 <span class="comment">     * How much space needed for max. length float?  128 is overkill.  </span>
00748 <span class="comment">     */</span>
00749 
00750     <span class="keywordflow">while</span> ((*out_len + 128 + 1) &gt;= *buf_len) {
00751         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00752             <span class="keywordflow">return</span> 0;
00753         }
00754     }
00755 
00756     sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class=
"stringliteral">"%f"</span>, *var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.floatVal);
00757     *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
00758 
00759     <span class="keywordflow">if</span> (units) {
00760         <span class="keywordflow">return</span> (snmp_strcat
00761                 (buf, buf_len, out_len, allow_realloc,
00762                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
00763                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
00764                                (<span class="keyword">const</span> u_char *) units));
00765     }
00766     <span class="keywordflow">return</span> 1;
00767 }
00768 
00769 
00792 <span class="keywordtype">int</span>
00793 sprint_realloc_double(u_char ** buf, size_t * buf_len,
00794                       size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
00795                       <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
00796                       <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
00797                       <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
00798 {
00799     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE_DOUBLE) &amp;&amp; 
00800         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
00801         <span class="keyword">const</span> <span class="keywordtype">char</span>      str[] = <span class=
"stringliteral">"Wrong Type (should be Double): "</span>;
00802         <span class="keywordflow">if</span> (snmp_strcat
00803             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) str)) {
00804             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
00805                                           allow_realloc, var, NULL, NULL,
00806                                           NULL);
00807         } <span class="keywordflow">else</span> {
00808             <span class="keywordflow">return</span> 0;
00809         }
00810     }
00811 
00812     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00813         <span class="keywordflow">if</span> (!snmp_strcat
00814             (buf, buf_len, out_len, allow_realloc,
00815              (<span class="keyword">const</span> u_char *) <span class="stringliteral">"Opaque: Float: "</span>)) {
00816             <span class="keywordflow">return</span> 0;
00817         }
00818     }
00819 
00820     <span class="comment">/*</span>
00821 <span class="comment">     * How much space needed for max. length double?  128 is overkill.  </span>
00822 <span class="comment">     */</span>
00823 
00824     <span class="keywordflow">while</span> ((*out_len + 128 + 1) &gt;= *buf_len) {
00825         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00826             <span class="keywordflow">return</span> 0;
00827         }
00828     }
00829 
00830     sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class=
"stringliteral">"%f"</span>, *var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.doubleVal);
00831     *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
00832 
00833     <span class="keywordflow">if</span> (units) {
00834         <span class="keywordflow">return</span> (snmp_strcat
00835                 (buf, buf_len, out_len, allow_realloc,
00836                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
00837                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
00838                                (<span class="keyword">const</span> u_char *) units));
00839     }
00840     <span class="keywordflow">return</span> 1;
00841 }
00842 
00843 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
00844 
00845 
00868 <span class="keywordtype">int</span>
<a name="l00869" id="l00869"></a><a class="code" href="group__mib__utilities.html#ga30">00869</a> <a class="code" href=
"group__mib__utilities.html#ga30">sprint_realloc_counter64</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
00870                          <span class="keywordtype">int</span> allow_realloc,
00871                          <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
00872                          <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
00873                          <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
00874 {
00875     <span class="keywordtype">char</span>            a64buf[I64CHARSZ + 1];
00876 
00877     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_COUNTER64
00878 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00879         &amp;&amp; var-&gt;<a class="code" href="structvariable__list.html#o3">type</a> != ASN_OPAQUE_COUNTER64
00880         &amp;&amp; var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE_I64 &amp;&amp; var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE_U64
00881 <span class="preprocessor">#endif</span>
00882         ) &amp;&amp; (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
00883         u_char          str[] = <span class="stringliteral">"Wrong Type (should be Counter64): "</span>;
00884         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
00885             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
00886                                           allow_realloc, var, NULL, NULL,
00887                                           NULL);
00888         } <span class="keywordflow">else</span> {
00889             <span class="keywordflow">return</span> 0;
00890         }
00891     }
00892 
00893     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
00894 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00895         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_COUNTER64) {
00896             <span class="keywordflow">if</span> (!snmp_strcat
00897                 (buf, buf_len, out_len, allow_realloc,
00898                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"Opaque: "</span>)) {
00899                 <span class="keywordflow">return</span> 0;
00900             }
00901         }
00902 <span class="preprocessor">#endif</span>
00903 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00904         <span class="keywordflow">switch</span> (var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>) {
00905         <span class="keywordflow">case</span> ASN_OPAQUE_U64:
00906             <span class="keywordflow">if</span> (!snmp_strcat
00907                 (buf, buf_len, out_len, allow_realloc,
00908                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"UInt64: "</span>)) {
00909                 <span class="keywordflow">return</span> 0;
00910             }
00911             <span class="keywordflow">break</span>;
00912         <span class="keywordflow">case</span> ASN_OPAQUE_I64:
00913             <span class="keywordflow">if</span> (!snmp_strcat
00914                 (buf, buf_len, out_len, allow_realloc,
00915                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"Int64: "</span>)) {
00916                 <span class="keywordflow">return</span> 0;
00917             }
00918             <span class="keywordflow">break</span>;
00919         <span class="keywordflow">case</span> ASN_COUNTER64:
00920         <span class="keywordflow">case</span> ASN_OPAQUE_COUNTER64:
00921 <span class="preprocessor">#endif</span>
00922             <span class="keywordflow">if</span> (!snmp_strcat
00923                 (buf, buf_len, out_len, allow_realloc,
00924                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">"Counter64: "</span>)) {
00925                 <span class="keywordflow">return</span> 0;
00926             }
00927 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00928         }
00929 <span class="preprocessor">#endif</span>
00930     }
00931 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00932     <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == ASN_OPAQUE_I64) {
00933         printI64(a64buf, var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.counter64);
00934         <span class="keywordflow">if</span> (!snmp_strcat
00935             (buf, buf_len, out_len, allow_realloc,
00936              (<span class="keyword">const</span> u_char *) a64buf)) {
00937             <span class="keywordflow">return</span> 0;
00938         }
00939     } <span class="keywordflow">else</span> {
00940 <span class="preprocessor">#endif</span>
00941         printU64(a64buf, var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.counter64);
00942         <span class="keywordflow">if</span> (!snmp_strcat
00943             (buf, buf_len, out_len, allow_realloc,
00944              (<span class="keyword">const</span> u_char *) a64buf)) {
00945             <span class="keywordflow">return</span> 0;
00946         }
00947 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00948     }
00949 <span class="preprocessor">#endif</span>
00950 
00951     <span class="keywordflow">if</span> (units) {
00952         <span class="keywordflow">return</span> (snmp_strcat
00953                 (buf, buf_len, out_len, allow_realloc,
00954                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
00955                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
00956                                (<span class="keyword">const</span> u_char *) units));
00957     }
00958     <span class="keywordflow">return</span> 1;
00959 }
00960 
00961 
00982 <span class="keywordtype">int</span>
<a name="l00983" id="l00983"></a><a class="code" href="group__mib__utilities.html#ga31">00983</a> <a class="code" href=
"group__mib__utilities.html#ga31">sprint_realloc_opaque</a>(u_char ** buf, size_t * buf_len,
00984                       size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
00985                       <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
00986                       <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
00987                       <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
00988 {
00989     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE
00990 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00991         &amp;&amp; var-&gt;<a class="code" href="structvariable__list.html#o3">type</a> != ASN_OPAQUE_COUNTER64
00992         &amp;&amp; var-&gt;<a class="code" href="structvariable__list.html#o3">type</a> != ASN_OPAQUE_U64
00993         &amp;&amp; var-&gt;<a class="code" href="structvariable__list.html#o3">type</a> != ASN_OPAQUE_I64
00994         &amp;&amp; var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE_FLOAT &amp;&amp; var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OPAQUE_DOUBLE
00995 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
00996         ) &amp;&amp; (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
00997         u_char          str[] = <span class="stringliteral">"Wrong Type (should be Opaque): "</span>;
00998         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
00999             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01000                                           allow_realloc, var, NULL, NULL,
01001                                           NULL);
01002         } <span class="keywordflow">else</span> {
01003             <span class="keywordflow">return</span> 0;
01004         }
01005     }
01006 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
01007     <span class="keywordflow">switch</span> (var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>) {
01008     <span class="keywordflow">case</span> ASN_OPAQUE_COUNTER64:
01009     <span class="keywordflow">case</span> ASN_OPAQUE_U64:
01010     <span class="keywordflow">case</span> ASN_OPAQUE_I64:
01011         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga30">sprint_realloc_counter64</a>(buf, buf_len, out_len,
01012                                         allow_realloc, var, enums, hint,
01013                                         units);
01014         <span class="keywordflow">break</span>;
01015 
01016     <span class="keywordflow">case</span> ASN_OPAQUE_FLOAT:
01017         <span class="keywordflow">return</span> sprint_realloc_float(buf, buf_len, out_len, allow_realloc,
01018                                     var, enums, hint, units);
01019         <span class="keywordflow">break</span>;
01020 
01021     <span class="keywordflow">case</span> ASN_OPAQUE_DOUBLE:
01022         <span class="keywordflow">return</span> sprint_realloc_double(buf, buf_len, out_len, allow_realloc,
01023                                      var, enums, hint, units);
01024         <span class="keywordflow">break</span>;
01025 
01026     <span class="keywordflow">case</span> ASN_OPAQUE:
01027 <span class="preprocessor">#endif</span>
01028         <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01029             u_char          str[] = <span class="stringliteral">"OPAQUE: "</span>;
01030             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01031                 <span class="keywordflow">return</span> 0;
01032             }
01033         }
01034         <span class="keywordflow">if</span> (!sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,
01035                                       var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string, var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>)) {
01036             <span class="keywordflow">return</span> 0;
01037         }
01038 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
01039     }
01040 <span class="preprocessor">#endif</span>
01041     <span class="keywordflow">if</span> (units) {
01042         <span class="keywordflow">return</span> (snmp_strcat
01043                 (buf, buf_len, out_len, allow_realloc,
01044                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01045                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01046                                (<span class="keyword">const</span> u_char *) units));
01047     }
01048     <span class="keywordflow">return</span> 1;
01049 }
01050 
01051 
01072 <span class="keywordtype">int</span>
<a name="l01073" id="l01073"></a><a class="code" href="group__mib__utilities.html#ga32">01073</a> <a class="code" href=
"group__mib__utilities.html#ga32">sprint_realloc_object_identifier</a>(u_char ** buf, size_t * buf_len,
01074                                  size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
01075                                  <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01076                                  <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01077                                  <span class="keyword">const</span> <span class=
"keywordtype">char</span> *hint, <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
01078 {
01079     <span class="keywordtype">int</span>             buf_overflow = 0;
01080 
01081     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OBJECT_ID) &amp;&amp;
01082         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01083         u_char          str[] =
01084             <span class="stringliteral">"Wrong Type (should be OBJECT IDENTIFIER): "</span>;
01085         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01086             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01087                                           allow_realloc, var, NULL, NULL,
01088                                           NULL);
01089         } <span class="keywordflow">else</span> {
01090             <span class="keywordflow">return</span> 0;
01091         }
01092     }
01093 
01094     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01095         u_char          str[] = <span class="stringliteral">"OID: "</span>;
01096         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01097             <span class="keywordflow">return</span> 0;
01098         }
01099     }
01100 
01101     netsnmp_sprint_realloc_objid_tree(buf, buf_len, out_len, allow_realloc,
01102                                       &amp;buf_overflow,
01103                                       (oid *) (var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid),
01104                                       var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> / <span class="keyword">sizeof</span>(oid));
01105 
01106     <span class="keywordflow">if</span> (buf_overflow) {
01107         <span class="keywordflow">return</span> 0;
01108     }
01109 
01110     <span class="keywordflow">if</span> (units) {
01111         <span class="keywordflow">return</span> (snmp_strcat
01112                 (buf, buf_len, out_len, allow_realloc,
01113                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01114                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01115                                (<span class="keyword">const</span> u_char *) units));
01116     }
01117     <span class="keywordflow">return</span> 1;
01118 }
01119 
01120 
01121 
01142 <span class="keywordtype">int</span>
<a name="l01143" id="l01143"></a><a class="code" href="group__mib__utilities.html#ga33">01143</a> <a class="code" href=
"group__mib__utilities.html#ga33">sprint_realloc_timeticks</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01144                          <span class="keywordtype">int</span> allow_realloc,
01145                          <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01146                          <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01147                          <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01148 {
01149     <span class="keywordtype">char</span>            timebuf[40];
01150 
01151     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_TIMETICKS) &amp;&amp; 
01152         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01153         u_char          str[] = <span class="stringliteral">"Wrong Type (should be Timeticks): "</span>;
01154         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01155             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01156                                           allow_realloc, var, NULL, NULL,
01157                                           NULL);
01158         } <span class="keywordflow">else</span> {
01159             <span class="keywordflow">return</span> 0;
01160         }
01161     }
01162 
01163     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS)) {
01164         <span class="keywordtype">char</span>            str[16];
01165         sprintf(str, <span class="stringliteral">"%lu"</span>, *(u_long *) var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01166         <span class="keywordflow">if</span> (!snmp_strcat
01167             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) str)) {
01168             <span class="keywordflow">return</span> 0;
01169         }
01170         <span class="keywordflow">return</span> 1;
01171     }
01172     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01173         <span class="keywordtype">char</span>            str[32];
01174         sprintf(str, <span class="stringliteral">"Timeticks: (%lu) "</span>, *(u_long *) var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01175         <span class="keywordflow">if</span> (!snmp_strcat
01176             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) str)) {
01177             <span class="keywordflow">return</span> 0;
01178         }
01179     }
01180     uptimeString(*(u_long *) (var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer), timebuf, <span class="keyword">sizeof</span>(timebuf));
01181     <span class="keywordflow">if</span> (!snmp_strcat
01182         (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) timebuf)) {
01183         <span class="keywordflow">return</span> 0;
01184     }
01185     <span class="keywordflow">if</span> (units) {
01186         <span class="keywordflow">return</span> (snmp_strcat
01187                 (buf, buf_len, out_len, allow_realloc,
01188                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01189                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01190                                (<span class="keyword">const</span> u_char *) units));
01191     }
01192     <span class="keywordflow">return</span> 1;
01193 }
01194 
01195 
01216 <span class="keywordtype">int</span>
<a name="l01217" id="l01217"></a><a class="code" href="group__mib__utilities.html#ga34">01217</a> <a class="code" href=
"group__mib__utilities.html#ga34">sprint_realloc_hinted_integer</a>(u_char ** buf, size_t * buf_len,
01218                               size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
01219                               <span class="keywordtype">long</span> val, <span class="keyword">const</span> <span class=
"keywordtype">char</span> decimaltype,
01220                               <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01221 {
01222     <span class="keywordtype">char</span>            fmt[10] = <span class="stringliteral">"%l@"</span>, tmp[256];
01223     <span class="keywordtype">int</span>             shift, len;
01224 
01225     <span class="keywordflow">if</span> (hint[1] == <span class="charliteral">'-'</span>) {
01226         shift = atoi(hint + 2);
01227     } <span class="keywordflow">else</span> {
01228         shift = 0;
01229     }
01230 
01231     <span class="keywordflow">if</span> (hint[0] == <span class="charliteral">'d'</span>) {
01232         <span class="comment">/*</span>
01233 <span class="comment">         * We might *actually* want a 'u' here.  </span>
01234 <span class="comment">         */</span>
01235         fmt[2] = decimaltype;
01236     } <span class="keywordflow">else</span> {
01237         <span class="comment">/*</span>
01238 <span class="comment">         * DISPLAY-HINT character is 'b', 'o', or 'x'.  </span>
01239 <span class="comment">         */</span>
01240         fmt[2] = hint[0];
01241     }
01242 
01243     sprintf(tmp, fmt, val);
01244     <span class="keywordflow">if</span> (shift != 0) {
01245         len = strlen(tmp);
01246         <span class="keywordflow">if</span> (shift &lt;= len) {
01247             tmp[len + 1] = 0;
01248             <span class="keywordflow">while</span> (shift--) {
01249                 tmp[len] = tmp[len - 1];
01250                 len--;
01251             }
01252             tmp[len] = <span class="charliteral">'.'</span>;
01253         } <span class="keywordflow">else</span> {
01254             tmp[shift + 1] = 0;
01255             <span class="keywordflow">while</span> (shift) {
01256                 <span class="keywordflow">if</span> (len-- &gt; 0) {
01257                     tmp[shift] = tmp[len];
01258                 } <span class="keywordflow">else</span> {
01259                     tmp[shift] = <span class="charliteral">'0'</span>;
01260                 }
01261                 shift--;
01262             }
01263             tmp[0] = <span class="charliteral">'.'</span>;
01264         }
01265     }
01266     <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc, tmp);
01267 }
01268 
01269 
01290 <span class="keywordtype">int</span>
<a name="l01291" id="l01291"></a><a class="code" href="group__mib__utilities.html#ga35">01291</a> <a class="code" href=
"group__mib__utilities.html#ga35">sprint_realloc_integer</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01292                        <span class="keywordtype">int</span> allow_realloc,
01293                        <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01294                        <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01295                        <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01296 {
01297     <span class="keywordtype">char</span>           *enum_string = NULL;
01298 
01299     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_INTEGER) &amp;&amp; 
01300         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01301         u_char          str[] = <span class="stringliteral">"Wrong Type (should be INTEGER): "</span>;
01302         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01303             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01304                                           allow_realloc, var, NULL, NULL,
01305                                           NULL);
01306         } <span class="keywordflow">else</span> {
01307             <span class="keywordflow">return</span> 0;
01308         }
01309     }
01310     <span class="keywordflow">for</span> (; enums; enums = enums-&gt;next) {
01311         <span class="keywordflow">if</span> (enums-&gt;value == *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer) {
01312             enum_string = enums-&gt;label;
01313             <span class="keywordflow">break</span>;
01314         }
01315     }
01316 
01317     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01318         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
01319                          (<span class="keyword">const</span> u_char *) <span class="stringliteral">"INTEGER: "</span>)) {
01320             <span class="keywordflow">return</span> 0;
01321         }
01322     }
01323 
01324     <span class="keywordflow">if</span> (enum_string == NULL ||
01325         netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM)) {
01326         <span class="keywordflow">if</span> (hint) {
01327             <span class="keywordflow">if</span> (!(<a class="code" href=
"group__mib__utilities.html#ga34">sprint_realloc_hinted_integer</a>(buf, buf_len, out_len,
01328                                                 allow_realloc,
01329                                                 *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer, <span class="charliteral">'d'</span>,
01330                                                 hint, units))) {
01331                 <span class="keywordflow">return</span> 0;
01332             }
01333         } <span class="keywordflow">else</span> {
01334             <span class="keywordtype">char</span>            str[16];
01335             sprintf(str, <span class="stringliteral">"%ld"</span>, *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01336             <span class="keywordflow">if</span> (!snmp_strcat
01337                 (buf, buf_len, out_len, allow_realloc,
01338                  (<span class="keyword">const</span> u_char *) str)) {
01339                 <span class="keywordflow">return</span> 0;
01340             }
01341         }
01342     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01343         <span class="keywordflow">if</span> (!snmp_strcat
01344             (buf, buf_len, out_len, allow_realloc,
01345              (<span class="keyword">const</span> u_char *) enum_string)) {
01346             <span class="keywordflow">return</span> 0;
01347         }
01348     } <span class="keywordflow">else</span> {
01349         <span class="keywordtype">char</span>            str[16];
01350         sprintf(str, <span class="stringliteral">"(%ld)"</span>, *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01351         <span class="keywordflow">if</span> (!snmp_strcat
01352             (buf, buf_len, out_len, allow_realloc,
01353              (<span class="keyword">const</span> u_char *) enum_string)) {
01354             <span class="keywordflow">return</span> 0;
01355         }
01356         <span class="keywordflow">if</span> (!snmp_strcat
01357             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) str)) {
01358             <span class="keywordflow">return</span> 0;
01359         }
01360     }
01361 
01362     <span class="keywordflow">if</span> (units) {
01363         <span class="keywordflow">return</span> (snmp_strcat
01364                 (buf, buf_len, out_len, allow_realloc,
01365                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01366                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01367                                (<span class="keyword">const</span> u_char *) units));
01368     }
01369     <span class="keywordflow">return</span> 1;
01370 }
01371 
01372 
01393 <span class="keywordtype">int</span>
<a name="l01394" id="l01394"></a><a class="code" href="group__mib__utilities.html#ga36">01394</a> <a class="code" href=
"group__mib__utilities.html#ga36">sprint_realloc_uinteger</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01395                         <span class="keywordtype">int</span> allow_realloc,
01396                         <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01397                         <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01398                         <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01399 {
01400     <span class="keywordtype">char</span>           *enum_string = NULL;
01401 
01402     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_UINTEGER) &amp;&amp; 
01403         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01404         u_char          str[] = <span class="stringliteral">"Wrong Type (should be UInteger32): "</span>;
01405         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01406             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01407                                           allow_realloc, var, NULL, NULL,
01408                                           NULL);
01409         } <span class="keywordflow">else</span> {
01410             <span class="keywordflow">return</span> 0;
01411         }
01412     }
01413 
01414     <span class="keywordflow">for</span> (; enums; enums = enums-&gt;next) {
01415         <span class="keywordflow">if</span> (enums-&gt;value == *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer) {
01416             enum_string = enums-&gt;label;
01417             <span class="keywordflow">break</span>;
01418         }
01419     }
01420 
01421     <span class="keywordflow">if</span> (enum_string == NULL ||
01422         netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM)) {
01423         <span class="keywordflow">if</span> (hint) {
01424             <span class="keywordflow">if</span> (!(<a class="code" href=
"group__mib__utilities.html#ga34">sprint_realloc_hinted_integer</a>(buf, buf_len, out_len,
01425                                                 allow_realloc,
01426                                                 *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer, <span class="charliteral">'u'</span>,
01427                                                 hint, units))) {
01428                 <span class="keywordflow">return</span> 0;
01429             }
01430         } <span class="keywordflow">else</span> {
01431             <span class="keywordtype">char</span>            str[16];
01432             sprintf(str, <span class="stringliteral">"%lu"</span>, *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01433             <span class="keywordflow">if</span> (!snmp_strcat
01434                 (buf, buf_len, out_len, allow_realloc,
01435                  (<span class="keyword">const</span> u_char *) str)) {
01436                 <span class="keywordflow">return</span> 0;
01437             }
01438         }
01439     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01440         <span class="keywordflow">if</span> (!snmp_strcat
01441             (buf, buf_len, out_len, allow_realloc,
01442              (<span class="keyword">const</span> u_char *) enum_string)) {
01443             <span class="keywordflow">return</span> 0;
01444         }
01445     } <span class="keywordflow">else</span> {
01446         <span class="keywordtype">char</span>            str[16];
01447         sprintf(str, <span class="stringliteral">"(%lu)"</span>, *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01448         <span class="keywordflow">if</span> (!snmp_strcat
01449             (buf, buf_len, out_len, allow_realloc,
01450              (<span class="keyword">const</span> u_char *) enum_string)) {
01451             <span class="keywordflow">return</span> 0;
01452         }
01453         <span class="keywordflow">if</span> (!snmp_strcat
01454             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) str)) {
01455             <span class="keywordflow">return</span> 0;
01456         }
01457     }
01458 
01459     <span class="keywordflow">if</span> (units) {
01460         <span class="keywordflow">return</span> (snmp_strcat
01461                 (buf, buf_len, out_len, allow_realloc,
01462                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01463                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01464                                (<span class="keyword">const</span> u_char *) units));
01465     }
01466     <span class="keywordflow">return</span> 1;
01467 }
01468 
01469 
01490 <span class="keywordtype">int</span>
<a name="l01491" id="l01491"></a><a class="code" href="group__mib__utilities.html#ga37">01491</a> <a class="code" href=
"group__mib__utilities.html#ga37">sprint_realloc_gauge</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01492                      <span class="keywordtype">int</span> allow_realloc,
01493                      <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01494                      <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01495                      <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01496 {
01497     <span class="keywordtype">char</span>            tmp[32];
01498 
01499     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_GAUGE) &amp;&amp; 
01500         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01501         u_char          str[] =
01502             <span class="stringliteral">"Wrong Type (should be Gauge32 or Unsigned32): "</span>;
01503         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01504             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01505                                           allow_realloc, var, NULL, NULL,
01506                                           NULL);
01507         } <span class="keywordflow">else</span> {
01508             <span class="keywordflow">return</span> 0;
01509         }
01510     }
01511 
01512     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01513         u_char          str[] = <span class="stringliteral">"Gauge32: "</span>;
01514         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01515             <span class="keywordflow">return</span> 0;
01516         }
01517     }
01518     <span class="keywordflow">if</span> (hint) {
01519         <span class="keywordflow">if</span> (!<a class="code" href=
"group__mib__utilities.html#ga34">sprint_realloc_hinted_integer</a>(buf, buf_len, out_len,
01520                                            allow_realloc,
01521                                            *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer, <span class="charliteral">'u'</span>, hint,
01522                                            units)) {
01523             <span class="keywordflow">return</span> 0;
01524         }
01525     } <span class="keywordflow">else</span> {
01526         sprintf(tmp, <span class="stringliteral">"%lu"</span>, *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01527         <span class="keywordflow">if</span> (!snmp_strcat
01528             (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) tmp)) {
01529             <span class="keywordflow">return</span> 0;
01530         }
01531     }
01532     <span class="keywordflow">if</span> (units) {
01533         <span class="keywordflow">return</span> (snmp_strcat
01534                 (buf, buf_len, out_len, allow_realloc,
01535                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01536                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01537                                (<span class="keyword">const</span> u_char *) units));
01538     }
01539     <span class="keywordflow">return</span> 1;
01540 }
01541 
01542 
01563 <span class="keywordtype">int</span>
<a name="l01564" id="l01564"></a><a class="code" href="group__mib__utilities.html#ga38">01564</a> <a class="code" href=
"group__mib__utilities.html#ga38">sprint_realloc_counter</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01565                        <span class="keywordtype">int</span> allow_realloc,
01566                        <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01567                        <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01568                        <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01569 {
01570     <span class="keywordtype">char</span>            tmp[32];
01571 
01572     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_COUNTER) &amp;&amp; 
01573         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01574         u_char          str[] = <span class="stringliteral">"Wrong Type (should be Counter32): "</span>;
01575         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01576             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01577                                           allow_realloc, var, NULL, NULL,
01578                                           NULL);
01579         } <span class="keywordflow">else</span> {
01580             <span class="keywordflow">return</span> 0;
01581         }
01582     }
01583 
01584     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01585         u_char          str[] = <span class="stringliteral">"Counter32: "</span>;
01586         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01587             <span class="keywordflow">return</span> 0;
01588         }
01589     }
01590     sprintf(tmp, <span class="stringliteral">"%lu"</span>, *var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
01591     <span class="keywordflow">if</span> (!snmp_strcat
01592         (buf, buf_len, out_len, allow_realloc, (<span class="keyword">const</span> u_char *) tmp)) {
01593         <span class="keywordflow">return</span> 0;
01594     }
01595     <span class="keywordflow">if</span> (units) {
01596         <span class="keywordflow">return</span> (snmp_strcat
01597                 (buf, buf_len, out_len, allow_realloc,
01598                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)
01599                 &amp;&amp; snmp_strcat(buf, buf_len, out_len, allow_realloc,
01600                                (<span class="keyword">const</span> u_char *) units));
01601     }
01602     <span class="keywordflow">return</span> 1;
01603 }
01604 
01605 
01626 <span class="keywordtype">int</span>
<a name="l01627" id="l01627"></a><a class="code" href="group__mib__utilities.html#ga39">01627</a> <a class="code" href=
"group__mib__utilities.html#ga39">sprint_realloc_networkaddress</a>(u_char ** buf, size_t * buf_len,
01628                               size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
01629                               <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01630                               <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums, <span class="keyword">const</span> <span class="keywordtype">char</span> *hint,
01631                               <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
01632 {
01633     size_t          i;
01634 
01635     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_IPADDRESS) &amp;&amp; 
01636         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01637         u_char          str[] = <span class="stringliteral">"Wrong Type (should be NetworkAddress): "</span>;
01638         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01639             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01640                                           allow_realloc, var, NULL, NULL,
01641                                           NULL);
01642         } <span class="keywordflow">else</span> {
01643             <span class="keywordflow">return</span> 0;
01644         }
01645     }
01646 
01647     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01648         u_char          str[] = <span class="stringliteral">"Network Address: "</span>;
01649         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01650             <span class="keywordflow">return</span> 0;
01651         }
01652     }
01653 
01654     <span class="keywordflow">while</span> ((*out_len + (var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> * 3) + 2) &gt;= *buf_len) {
01655         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
01656             <span class="keywordflow">return</span> 0;
01657         }
01658     }
01659 
01660     <span class="keywordflow">for</span> (i = 0; i &lt; var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>; i++) {
01661         sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class=
"stringliteral">"%02X"</span>, var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[i]);
01662         *out_len += 2;
01663         <span class="keywordflow">if</span> (i &lt; var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> - 1) {
01664             *(*buf + *out_len) = <span class="charliteral">':'</span>;
01665             (*out_len)++;
01666         }
01667     }
01668     <span class="keywordflow">return</span> 1;
01669 }
01670 
01671 
01692 <span class="keywordtype">int</span>
<a name="l01693" id="l01693"></a><a class="code" href="group__mib__utilities.html#ga40">01693</a> <a class="code" href=
"group__mib__utilities.html#ga40">sprint_realloc_ipaddress</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01694                          <span class="keywordtype">int</span> allow_realloc,
01695                          <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01696                          <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01697                          <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01698 {
01699     u_char         *ip = var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string;
01700 
01701     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_IPADDRESS) &amp;&amp; 
01702         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01703         u_char          str[] = <span class="stringliteral">"Wrong Type (should be IpAddress): "</span>;
01704         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01705             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01706                                           allow_realloc, var, NULL, NULL,
01707                                           NULL);
01708         } <span class="keywordflow">else</span> {
01709             <span class="keywordflow">return</span> 0;
01710         }
01711     }
01712 
01713     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01714         u_char          str[] = <span class="stringliteral">"IpAddress: "</span>;
01715         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01716             <span class="keywordflow">return</span> 0;
01717         }
01718     }
01719     <span class="keywordflow">while</span> ((*out_len + 17) &gt;= *buf_len) {
01720         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
01721             <span class="keywordflow">return</span> 0;
01722         }
01723     }
01724     <span class="keywordflow">if</span> (ip)
01725         sprintf((<span class="keywordtype">char</span> *) (*buf + *out_len), <span class=
"stringliteral">"%d.%d.%d.%d"</span>,
01726                                             ip[0], ip[1], ip[2], ip[3]);
01727     *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
01728     <span class="keywordflow">return</span> 1;
01729 }
01730 
01731 
01752 <span class="keywordtype">int</span>
<a name="l01753" id="l01753"></a><a class="code" href="group__mib__utilities.html#ga41">01753</a> <a class="code" href=
"group__mib__utilities.html#ga41">sprint_realloc_null</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01754                     <span class="keywordtype">int</span> allow_realloc,
01755                     <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01756                     <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01757                     <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01758 {
01759     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_NULL) &amp;&amp; 
01760         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01761         u_char          str[] = <span class="stringliteral">"Wrong Type (should be NULL): "</span>;
01762         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01763             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01764                                           allow_realloc, var, NULL, NULL,
01765                                           NULL);
01766         } <span class="keywordflow">else</span> {
01767             <span class="keywordflow">return</span> 0;
01768         }
01769     } <span class="keywordflow">else</span> {
01770         u_char          str[] = <span class="stringliteral">"NULL"</span>;
01771         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc, str);
01772     }
01773 }
01774 
01775 
01796 <span class="keywordtype">int</span>
<a name="l01797" id="l01797"></a><a class="code" href="group__mib__utilities.html#ga42">01797</a> <a class="code" href=
"group__mib__utilities.html#ga42">sprint_realloc_bitstring</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01798                          <span class="keywordtype">int</span> allow_realloc,
01799                          <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01800                          <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01801                          <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01802 {
01803     <span class="keywordtype">int</span>             len, bit;
01804     u_char         *cp;
01805     <span class="keywordtype">char</span>           *enum_string;
01806 
01807     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_BIT_STR &amp;&amp; var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_OCTET_STR) &amp;&amp;
01808         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01809         u_char          str[] = <span class="stringliteral">"Wrong Type (should be BITS): "</span>;
01810         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01811             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01812                                           allow_realloc, var, NULL, NULL,
01813                                           NULL);
01814         } <span class="keywordflow">else</span> {
01815             <span class="keywordflow">return</span> 0;
01816         }
01817     }
01818 
01819     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01820         u_char          str[] = <span class="stringliteral">"\""</span>;
01821         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01822             <span class="keywordflow">return</span> 0;
01823         }
01824     } <span class="keywordflow">else</span> {
01825         u_char          str[] = <span class="stringliteral">"BITS: "</span>;
01826         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01827             <span class="keywordflow">return</span> 0;
01828         }
01829     }
01830     <span class="keywordflow">if</span> (!sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,
01831                                   var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.bitstring, var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>)) {
01832         <span class="keywordflow">return</span> 0;
01833     }
01834 
01835     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01836         u_char          str[] = <span class="stringliteral">"\""</span>;
01837         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01838             <span class="keywordflow">return</span> 0;
01839         }
01840     } <span class="keywordflow">else</span> {
01841         cp = var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.bitstring;
01842         <span class="keywordflow">for</span> (len = 0; len &lt; (int) var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>; len++) {
01843             <span class="keywordflow">for</span> (bit = 0; bit &lt; 8; bit++) {
01844                 <span class="keywordflow">if</span> (*cp &amp; (0x80 &gt;&gt; bit)) {
01845                     enum_string = NULL;
01846                     <span class="keywordflow">for</span> (; enums; enums = enums-&gt;next) {
01847                         <span class="keywordflow">if</span> (enums-&gt;value == (len * 8) + bit) {
01848                             enum_string = enums-&gt;label;
01849                             <span class="keywordflow">break</span>;
01850                         }
01851                     }
01852                     <span class="keywordflow">if</span> (enum_string == NULL ||
01853                         netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
01854                                        NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM)) {
01855                         <span class="keywordtype">char</span>            str[16];
01856                         sprintf(str, <span class="stringliteral">"%d "</span>, (len * 8) + bit);
01857                         <span class="keywordflow">if</span> (!snmp_strcat
01858                             (buf, buf_len, out_len, allow_realloc,
01859                              (<span class="keyword">const</span> u_char *) str)) {
01860                             <span class="keywordflow">return</span> 0;
01861                         }
01862                     } <span class="keywordflow">else</span> {
01863                         <span class="keywordtype">char</span>            str[16];
01864                         sprintf(str, <span class="stringliteral">"(%d) "</span>, (len * 8) + bit);
01865                         <span class="keywordflow">if</span> (!snmp_strcat
01866                             (buf, buf_len, out_len, allow_realloc,
01867                              (<span class="keyword">const</span> u_char *) enum_string)) {
01868                             <span class="keywordflow">return</span> 0;
01869                         }
01870                         <span class="keywordflow">if</span> (!snmp_strcat
01871                             (buf, buf_len, out_len, allow_realloc,
01872                              (<span class="keyword">const</span> u_char *) str)) {
01873                             <span class="keywordflow">return</span> 0;
01874                         }
01875                     }
01876                 }
01877             }
01878             cp++;
01879         }
01880     }
01881     <span class="keywordflow">return</span> 1;
01882 }
01883 
01884 <span class="keywordtype">int</span>
01885 sprint_realloc_nsapaddress(u_char ** buf, size_t * buf_len,
01886                            size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
01887                            <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01888                            <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums, <span class="keyword">const</span> <span class="keywordtype">char</span> *hint,
01889                            <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
01890 {
01891     <span class="keywordflow">if</span> ((var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> != ASN_NSAP) &amp;&amp; 
01892         (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT))) {
01893         u_char          str[] = <span class="stringliteral">"Wrong Type (should be NsapAddress): "</span>;
01894         <span class="keywordflow">if</span> (snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01895             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
01896                                           allow_realloc, var, NULL, NULL,
01897                                           NULL);
01898         } <span class="keywordflow">else</span> {
01899             <span class="keywordflow">return</span> 0;
01900         }
01901     }
01902 
01903     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
01904         u_char          str[] = <span class="stringliteral">"NsapAddress: "</span>;
01905         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {
01906             <span class="keywordflow">return</span> 0;
01907         }
01908     }
01909 
01910     <span class="keywordflow">return</span> sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,
01911                                     var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string, var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
01912 }
01913 
01914 
01935 <span class="keywordtype">int</span>
<a name="l01936" id="l01936"></a><a class="code" href="group__mib__utilities.html#ga44">01936</a> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_badtype</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01937                        <span class="keywordtype">int</span> allow_realloc,
01938                        <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01939                        <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01940                        <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01941 {
01942     u_char          str[] = <span class="stringliteral">"Variable has bad type"</span>;
01943 
01944     <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc, str);
01945 }
01946 
01947 
01948 
01970 <span class="keywordtype">int</span>
<a name="l01971" id="l01971"></a><a class="code" href="group__mib__utilities.html#ga45">01971</a> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(u_char ** buf, size_t * buf_len, size_t * out_len,
01972                        <span class="keywordtype">int</span> allow_realloc,
01973                        <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
01974                        <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
01975                        <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
01976 {
01977     DEBUGMSGTL((<span class="stringliteral">"output"</span>, <span class=
"stringliteral">"sprint_by_type, type %d\n"</span>, var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>));
01978 
01979     <span class="keywordflow">switch</span> (var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>) {
01980     <span class="keywordflow">case</span> ASN_INTEGER:
01981         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga35">sprint_realloc_integer</a>(buf, buf_len, out_len, allow_realloc,
01982                                       var, enums, hint, units);
01983     <span class="keywordflow">case</span> ASN_OCTET_STR:
01984         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga29">sprint_realloc_octet_string</a>(buf, buf_len, out_len,
01985                                            allow_realloc, var, enums, hint,
01986                                            units);
01987     <span class="keywordflow">case</span> ASN_BIT_STR:
01988         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga42">sprint_realloc_bitstring</a>(buf, buf_len, out_len,
01989                                         allow_realloc, var, enums, hint,
01990                                         units);
01991     <span class="keywordflow">case</span> ASN_OPAQUE:
01992         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga31">sprint_realloc_opaque</a>(buf, buf_len, out_len, allow_realloc,
01993                                      var, enums, hint, units);
01994     <span class="keywordflow">case</span> ASN_OBJECT_ID:
01995         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga32">sprint_realloc_object_identifier</a>(buf, buf_len, out_len,
01996                                                 allow_realloc, var, enums,
01997                                                 hint, units);
01998     <span class="keywordflow">case</span> ASN_TIMETICKS:
01999         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga33">sprint_realloc_timeticks</a>(buf, buf_len, out_len,
02000                                         allow_realloc, var, enums, hint,
02001                                         units);
02002     <span class="keywordflow">case</span> ASN_GAUGE:
02003         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga37">sprint_realloc_gauge</a>(buf, buf_len, out_len, allow_realloc,
02004                                     var, enums, hint, units);
02005     <span class="keywordflow">case</span> ASN_COUNTER:
02006         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga38">sprint_realloc_counter</a>(buf, buf_len, out_len, allow_realloc,
02007                                       var, enums, hint, units);
02008     <span class="keywordflow">case</span> ASN_IPADDRESS:
02009         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga40">sprint_realloc_ipaddress</a>(buf, buf_len, out_len,
02010                                         allow_realloc, var, enums, hint,
02011                                         units);
02012     <span class="keywordflow">case</span> ASN_NULL:
02013         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga41">sprint_realloc_null</a>(buf, buf_len, out_len, allow_realloc,
02014                                    var, enums, hint, units);
02015     <span class="keywordflow">case</span> ASN_UINTEGER:
02016         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga36">sprint_realloc_uinteger</a>(buf, buf_len, out_len,
02017                                        allow_realloc, var, enums, hint,
02018                                        units);
02019     <span class="keywordflow">case</span> ASN_COUNTER64:
02020 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
02021     <span class="keywordflow">case</span> ASN_OPAQUE_U64:
02022     <span class="keywordflow">case</span> ASN_OPAQUE_I64:
02023     <span class="keywordflow">case</span> ASN_OPAQUE_COUNTER64:
02024 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
02025         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga30">sprint_realloc_counter64</a>(buf, buf_len, out_len,
02026                                         allow_realloc, var, enums, hint,
02027                                         units);
02028 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
02029     <span class="keywordflow">case</span> ASN_OPAQUE_FLOAT:
02030         <span class="keywordflow">return</span> sprint_realloc_float(buf, buf_len, out_len, allow_realloc,
02031                                     var, enums, hint, units);
02032     <span class="keywordflow">case</span> ASN_OPAQUE_DOUBLE:
02033         <span class="keywordflow">return</span> sprint_realloc_double(buf, buf_len, out_len, allow_realloc,
02034                                      var, enums, hint, units);
02035 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
02036     <span class="keywordflow">default</span>:
02037         DEBUGMSGTL((<span class="stringliteral">"sprint_by_type"</span>, <span class=
"stringliteral">"bad type: %d\n"</span>, var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>));
02038         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_badtype</a>(buf, buf_len, out_len, allow_realloc,
02039                                       var, enums, hint, units);
02040     }
02041 }
02042 
02043 
02044 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02045 
02050 <span class="keyword">struct </span>tree    *
<a name="l02051" id="l02051"></a><a class="code" href="group__mib__utilities.html#ga46">02051</a> <a class="code" href=
"group__mib__utilities.html#ga46">get_tree_head</a>(<span class="keywordtype">void</span>)
02052 {
02053     <span class="keywordflow">return</span> (tree_head);
02054 }
02055 
02056 <span class="keyword">static</span> <span class="keywordtype">char</span>    *confmibdir = NULL;
02057 <span class="keyword">static</span> <span class="keywordtype">char</span>    *confmibs = NULL;
02058 
02059 <span class="keyword">static</span> <span class="keywordtype">void</span>
02060 handle_mibdirs_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
02061 {
02062     <span class="keywordtype">char</span>           *ctmp;
02063 
02064     <span class="keywordflow">if</span> (confmibdir) {
02065         <span class="keywordflow">if</span> ((*line == <span class="charliteral">'+'</span>) || (*line == <span class=
"charliteral">'-'</span>)) {
02066             ctmp = (<span class="keywordtype">char</span> *) malloc(strlen(confmibdir) + strlen(line) + 2);
02067             <span class="keywordflow">if</span> (!ctmp) {
02068                 DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>,
02069                             <span class="stringliteral">"mibdir conf malloc failed"</span>));
02070                 <span class="keywordflow">return</span>;
02071             }
02072             <span class="keywordflow">if</span>(*line++ == <span class="charliteral">'+'</span>)
02073                 sprintf(ctmp, <span class="stringliteral">"%s%c%s"</span>, confmibdir, ENV_SEPARATOR_CHAR, line);
02074             <span class="keywordflow">else</span>
02075                 sprintf(ctmp, <span class="stringliteral">"%s%c%s"</span>, line, ENV_SEPARATOR_CHAR, confmibdir);
02076         } <span class="keywordflow">else</span> {
02077             ctmp = strdup(line);
02078             <span class="keywordflow">if</span> (!ctmp) {
02079                 DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"mibs conf malloc failed"</span>));
02080                 <span class="keywordflow">return</span>;
02081             }
02082         }
02083         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(confmibdir);
02084     } <span class="keywordflow">else</span> {
02085         ctmp = strdup(line);
02086         <span class="keywordflow">if</span> (!ctmp) {
02087             DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"mibs conf malloc failed"</span>));
02088             <span class="keywordflow">return</span>;
02089         }
02090     }
02091     confmibdir = ctmp;
02092     DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"using mibdirs: %s\n"</span>, confmibdir));
02093 }
02094 
02095 <span class="keyword">static</span> <span class="keywordtype">void</span>
02096 handle_mibs_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
02097 {
02098     <span class="keywordtype">char</span>           *ctmp;
02099 
02100     <span class="keywordflow">if</span> (confmibs) {
02101         <span class="keywordflow">if</span> ((*line == <span class="charliteral">'+'</span>) || (*line == <span class=
"charliteral">'-'</span>)) {
02102             ctmp = (<span class="keywordtype">char</span> *) malloc(strlen(confmibs) + strlen(line) + 2);
02103             <span class="keywordflow">if</span> (!ctmp) {
02104                 DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"mibs conf malloc failed"</span>));
02105                 <span class="keywordflow">return</span>;
02106             }
02107             <span class="keywordflow">if</span>(*line++ == <span class="charliteral">'+'</span>)
02108                 sprintf(ctmp, <span class="stringliteral">"%s%c%s"</span>, confmibs, ENV_SEPARATOR_CHAR, line);
02109             <span class="keywordflow">else</span>
02110                 sprintf(ctmp, <span class="stringliteral">"%s%c%s"</span>, line, ENV_SEPARATOR_CHAR, confmibdir);
02111         } <span class="keywordflow">else</span> {
02112             ctmp = strdup(line);
02113             <span class="keywordflow">if</span> (!ctmp) {
02114                 DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"mibs conf malloc failed"</span>));
02115                 <span class="keywordflow">return</span>;
02116             }
02117         }
02118         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(confmibs);
02119     } <span class="keywordflow">else</span> {
02120         ctmp = strdup(line);
02121         <span class="keywordflow">if</span> (!ctmp) {
02122             DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"mibs conf malloc failed"</span>));
02123             <span class="keywordflow">return</span>;
02124         }
02125     }
02126     confmibs = ctmp;
02127     DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"using mibs: %s\n"</span>, confmibs));
02128 }
02129 
02130 
02131 <span class="keyword">static</span> <span class="keywordtype">void</span>
02132 handle_mibfile_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
02133 {
02134     DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"reading mibfile: %s\n"</span>, line));
02135     read_mib(line);
02136 }
02137 <span class="preprocessor">#endif</span>
02138 
02139 <span class="keyword">static</span> <span class="keywordtype">void</span>
02140 handle_print_numeric(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
02141 {
02142     <span class="keyword">const</span> <span class="keywordtype">char</span> *value;
02143     <span class="keywordtype">char</span>       *st;
02144 
02145     value = strtok_r(line, <span class="stringliteral">" \t\n"</span>, &amp;st);
02146     <span class="keywordflow">if</span> ((strcasecmp(value, <span class="stringliteral">"yes"</span>)  == 0) || 
02147         (strcasecmp(value, <span class="stringliteral">"true"</span>) == 0) ||
02148         (*value == <span class="charliteral">'1'</span>)) {
02149 
02150         netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
02151                                                   NETSNMP_OID_OUTPUT_NUMERIC);
02152     }
02153 }
02154 
02155 <span class="keywordtype">char</span>           *
02156 snmp_out_toggle_options(<span class="keywordtype">char</span> *options)
02157 {
02158     <span class="keywordflow">while</span> (*options) {
02159         <span class="keywordflow">switch</span> (*options++) {
02160         <span class="keywordflow">case</span> <span class="charliteral">'0'</span>:
02161             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID,
02162                                       NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT);
02163             <span class="keywordflow">break</span>;
02164         <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
02165             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT,
02166                                                       NETSNMP_STRING_OUTPUT_ASCII);
02167             <span class="keywordflow">break</span>;
02168         <span class="keywordflow">case</span> <span class="charliteral">'b'</span>:
02169             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS);
02170             <span class="keywordflow">break</span>;
02171         <span class="keywordflow">case</span> <span class="charliteral">'e'</span>:
02172             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM);
02173             <span class="keywordflow">break</span>;
02174         <span class="keywordflow">case</span> <span class="charliteral">'E'</span>:
02175             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES);
02176             <span class="keywordflow">break</span>;
02177         <span class="keywordflow">case</span> <span class="charliteral">'f'</span>:
02178             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
02179                                                       NETSNMP_OID_OUTPUT_FULL);
02180             <span class="keywordflow">break</span>;
02181         <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
02182             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
02183                                                       NETSNMP_OID_OUTPUT_NUMERIC);
02184             <span class="keywordflow">break</span>;
02185         <span class="keywordflow">case</span> <span class="charliteral">'q'</span>:
02186             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);
02187             <span class="keywordflow">break</span>;
02188         <span class="keywordflow">case</span> <span class="charliteral">'Q'</span>:
02189             <a class="code" href=
"group__default__store.html#ga8">netsnmp_ds_set_boolean</a>(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT, 1);
02190             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);
02191             <span class="keywordflow">break</span>;
02192         <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
02193             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
02194                                                       NETSNMP_OID_OUTPUT_SUFFIX);
02195             <span class="keywordflow">break</span>;
02196         <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
02197             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
02198                                                       NETSNMP_OID_OUTPUT_MODULE);
02199             <span class="keywordflow">break</span>;
02200         <span class="keywordflow">case</span> <span class="charliteral">'t'</span>:
02201             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS);
02202             <span class="keywordflow">break</span>;
02203         <span class="keywordflow">case</span> <span class="charliteral">'T'</span>:
02204             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT);
02205             <span class="keywordflow">break</span>;
02206         <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
02207             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,
02208                                                       NETSNMP_OID_OUTPUT_UCD);
02209             <span class="keywordflow">break</span>;
02210         <span class="keywordflow">case</span> <span class="charliteral">'U'</span>:
02211             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PRINT_UNITS);
02212             <span class="keywordflow">break</span>;
02213         <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
02214             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE);
02215             <span class="keywordflow">break</span>;
02216         <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
02217             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT,
02218                                                       NETSNMP_STRING_OUTPUT_HEX);
02219             <span class="keywordflow">break</span>;
02220         <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
02221             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX);
02222             <span class="keywordflow">break</span>;
02223         <span class="keywordflow">default</span>:
02224             <span class="keywordflow">return</span> options - 1;
02225         }
02226     }
02227     <span class="keywordflow">return</span> NULL;
02228 }
02229 
02230 <span class="keywordtype">void</span>
02231 snmp_out_toggle_options_usage(<span class="keyword">const</span> <span class="keywordtype">char</span> *lead, FILE * outf)
02232 {
02233     fprintf(outf, <span class="stringliteral">"%s0:  print leading 0 for single-digit hex characters\n"</span>, lead);
02234     fprintf(outf, <span class="stringliteral">"%sa:  print all strings in ascii format\n"</span>, lead);
02235     fprintf(outf, <span class="stringliteral">"%sb:  do not break OID indexes down\n"</span>, lead);
02236     fprintf(outf, <span class="stringliteral">"%se:  print enums numerically\n"</span>, lead);
02237     fprintf(outf, <span class="stringliteral">"%sE:  escape quotes in string indices\n"</span>, lead);
02238     fprintf(outf, <span class="stringliteral">"%sf:  print full OIDs on output\n"</span>, lead);
02239     fprintf(outf, <span class="stringliteral">"%sn:  print OIDs numerically\n"</span>, lead);
02240     fprintf(outf, <span class="stringliteral">"%sq:  quick print for easier parsing\n"</span>, lead);
02241     fprintf(outf, <span class="stringliteral">"%sQ:  quick print with equal-signs\n"</span>, lead);    <span class=
"comment">/* @@JDW */</span>
02242     fprintf(outf, <span class="stringliteral">"%ss:  print only last symbolic element of OID\n"</span>, lead);
02243     fprintf(outf, <span class="stringliteral">"%sS:  print MIB module-id plus last element\n"</span>, lead);
02244     fprintf(outf, <span class="stringliteral">"%st:  print timeticks unparsed as numeric integers\n"</span>,
02245             lead);
02246     fprintf(outf,
02247             <span class="stringliteral">"%sT:  print human-readable text along with hex strings\n"</span>,
02248             lead);
02249     fprintf(outf, <span class="stringliteral">"%su:  print OIDs using UCD-style prefix suppression\n"</span>,
02250             lead);
02251     fprintf(outf, <span class="stringliteral">"%sU:  don't print units\n"</span>, lead);
02252     fprintf(outf, <span class="stringliteral">"%sv:  print values only (not OID = value)\n"</span>, lead);
02253     fprintf(outf, <span class="stringliteral">"%sx:  print all strings in hex format\n"</span>, lead);
02254     fprintf(outf, <span class="stringliteral">"%sX:  extended index format\n"</span>, lead);
02255 }
02256 
02257 <span class="keywordtype">char</span> *
02258 snmp_in_options(<span class="keywordtype">char</span> *optarg, <span class="keywordtype">int</span> argc, <span class=
"keywordtype">char</span> *<span class="keyword">const</span> *argv)
02259 {
02260     <span class="keywordtype">char</span> *cp;
02261 
02262     <span class="keywordflow">for</span> (cp = optarg; *cp; cp++) {
02263         <span class="keywordflow">switch</span> (*cp) {
02264         <span class="keywordflow">case</span> <span class="charliteral">'b'</span>:
02265             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REGEX_ACCESS);
02266             <span class="keywordflow">break</span>;
02267         <span class="keywordflow">case</span> <span class="charliteral">'R'</span>:
02268             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_RANDOM_ACCESS);
02269             <span class="keywordflow">break</span>;
02270         <span class="keywordflow">case</span> <span class="charliteral">'r'</span>:
02271             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_CHECK_RANGE);
02272             <span class="keywordflow">break</span>;
02273         <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
02274             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NO_DISPLAY_HINT);
02275             <span class="keywordflow">break</span>;
02276         <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
02277             netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_READ_UCD_STYLE_OID);
02278             <span class="keywordflow">break</span>;
02279         <span class="keywordflow">case</span> <span class="charliteral">'s'</span>:
02280             <span class="comment">/* What if argc/argv are null ? */</span>
02281             <span class="keywordflow">if</span> (!*(++cp))
02282                 cp = argv[optind++];
02283             netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,
02284                                   NETSNMP_DS_LIB_OIDSUFFIX,
02285                                   cp);
02286             <span class="keywordflow">return</span> NULL;
02287 
02288         <span class="keywordflow">case</span> <span class="charliteral">'S'</span>:
02289             <span class="comment">/* What if argc/argv are null ? */</span>
02290             <span class="keywordflow">if</span> (!*(++cp))
02291                 cp = argv[optind++];
02292             netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,
02293                                   NETSNMP_DS_LIB_OIDPREFIX,
02294                                   cp);
02295             <span class="keywordflow">return</span> NULL;
02296 
02297         <span class="keywordflow">default</span>:
02298            <span class="comment">/*</span>
02299 <span class="comment">            *  Here?  Or in snmp_parse_args?</span>
02300 <span class="comment">            snmp_log(LOG_ERR, "Unknown input option passed to -I: %c.\n", *cp);</span>
02301 <span class="comment">            */</span>
02302             <span class="keywordflow">return</span> cp;
02303         }
02304     }
02305     <span class="keywordflow">return</span> NULL;
02306 }
02307 
02308 <span class="keywordtype">char</span>           *
02309 snmp_in_toggle_options(<span class="keywordtype">char</span> *options)
02310 {
02311     <span class="keywordflow">return</span> snmp_in_options( options, 0, NULL );
02312 }
02313 
02314 
02322 <span class="keywordtype">void</span>
<a name="l02323" id="l02323"></a><a class="code" href="group__mib__utilities.html#ga52">02323</a> <a class="code" href=
"group__mib__utilities.html#ga52">snmp_in_toggle_options_usage</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *lead, FILE * outf)
02324 {
02325     fprintf(outf, <span class="stringliteral">"%sb:  do best/regex matching to find a MIB node\n"</span>, lead);
02326     fprintf(outf, <span class="stringliteral">"%sh:  don't apply DISPLAY-HINTs\n"</span>, lead);
02327     fprintf(outf, <span class="stringliteral">"%sr:  do not check values for range/type legality\n"</span>, lead);
02328     fprintf(outf, <span class="stringliteral">"%sR:  do random access to OID labels\n"</span>, lead);
02329     fprintf(outf,
02330             <span class="stringliteral">"%su:  top-level OIDs must have '.' prefix (UCD-style)\n"</span>, lead);
02331     fprintf(outf,
02332             <span class="stringliteral">"%ss SUFFIX:  Append all textual OIDs with SUFFIX before parsing\n"</span>,
02333             lead);
02334     fprintf(outf,
02335             <span class="stringliteral">"%sS PREFIX:  Prepend all textual OIDs with PREFIX before parsing\n"</span>,
02336             lead);
02337 }
02338 
02339 <span class="comment">/***</span>
02340 <span class="comment"> *</span>
02341 <span class="comment"> */</span> 
02342 <span class="keywordtype">void</span>
02343 register_mib_handlers(<span class="keywordtype">void</span>)
02344 {
02345 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02346     register_prenetsnmp_mib_handler(<span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"mibdirs"</span>,
02347                                     handle_mibdirs_conf, NULL,
02348                                     <span class="stringliteral">"[mib-dirs|+mib-dirs|-mib-dirs]"</span>);
02349     register_prenetsnmp_mib_handler(<span class="stringliteral">"snmp"</span>, <span class="stringliteral">"mibs"</span>,
02350                                     handle_mibs_conf, NULL,
02351                                     <span class="stringliteral">"[mib-tokens|+mib-tokens]"</span>);
02352     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(<span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"mibfile"</span>,
02353                             handle_mibfile_conf, NULL, <span class="stringliteral">"mibfile-to-read"</span>);
02354     <span class="comment">/*</span>
02355 <span class="comment">     * register the snmp.conf configuration handlers for default</span>
02356 <span class="comment">     * parsing behaviour </span>
02357 <span class="comment">     */</span>
02358 
02359     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"showMibErrors"</span>,
02360                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_ERRORS);
02361     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"strictCommentTerm"</span>,
02362                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_COMMENT_TERM);
02363     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"mibAllowUnderline"</span>,
02364                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_PARSE_LABEL);
02365     netsnmp_ds_register_premib(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"mibWarningLevel"</span>,
02366                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_WARNINGS);
02367     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"mibReplaceWithLatest"</span>,
02368                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_REPLACE);
02369 <span class="preprocessor">#endif</span>
02370 
02371     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"printNumericEnums"</span>,
02372                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM);
02373     register_prenetsnmp_mib_handler(<span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"printNumericOids"</span>,
02374                        handle_print_numeric, NULL, <span class="stringliteral">"(1|yes|true|0|no|false)"</span>);
02375     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"escapeQuotes"</span>,
02376                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES);
02377     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"dontBreakdownOids"</span>,
02378                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS);
02379     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"quickPrinting"</span>,
02380                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);
02381     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"numericTimeticks"</span>,
02382                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS);
02383     netsnmp_ds_register_premib(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"oidOutputFormat"</span>,
02384                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);
02385     netsnmp_ds_register_premib(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"suffixPrinting"</span>,
02386                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);
02387     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"extendedIndex"</span>,
02388                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX);
02389     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"printHexText"</span>,
02390                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT);
02391     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"printValueOnly"</span>,
02392                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE);
02393     netsnmp_ds_register_premib(ASN_BOOLEAN, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"dontPrintUnits"</span>,
02394                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PRINT_UNITS);
02395     netsnmp_ds_register_premib(ASN_INTEGER, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"hexOutputLength"</span>,
02396                        NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH);
02397 }
02398 
02399 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02400 <span class="comment">/*</span>
02401 <span class="comment"> * function : netsnmp_set_mib_directory</span>
02402 <span class="comment"> *            - This function sets the string of the directories</span>
02403 <span class="comment"> *              from which the MIB modules will be searched or</span>
02404 <span class="comment"> *              loaded.</span>
02405 <span class="comment"> * arguments: const char *dir, which are the directories</span>
02406 <span class="comment"> *              from which the MIB modules will be searched or</span>
02407 <span class="comment"> *              loaded.</span>
02408 <span class="comment"> * returns  : -</span>
02409 <span class="comment"> */</span>
02410 <span class="keywordtype">void</span>
<a name="l02411" id="l02411"></a><a class="code" href="group__mib__utilities.html#ga54">02411</a> <a class="code" href=
"group__mib__utilities.html#ga54">netsnmp_set_mib_directory</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *dir)
02412 {
02413     <span class="keyword">const</span> <span class="keywordtype">char</span> *newdir;
02414     <span class="keywordtype">char</span> *olddir, *tmpdir = NULL;
02415 
02416     DEBUGTRACE;
02417     <span class="keywordflow">if</span> (NULL == dir) {
02418         <span class="keywordflow">return</span>;
02419     }
02420     
02421     olddir = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
02422                                    NETSNMP_DS_LIB_MIBDIRS);
02423     <span class="keywordflow">if</span> (olddir) {
02424         <span class="keywordflow">if</span> ((*dir == <span class="charliteral">'+'</span>) || (*dir == <span class=
"charliteral">'-'</span>)) {
02426             tmpdir = malloc(strlen(dir) + strlen(olddir) + 2);
02427             <span class="keywordflow">if</span> (!tmpdir) {
02428                 DEBUGMSGTL((<span class="stringliteral">"read_config:initmib"</span>, <span class=
"stringliteral">"set mibdir malloc failed"</span>));
02429                 <span class="keywordflow">return</span>;
02430             }
02431             <span class="keywordflow">if</span> (*dir++ == <span class="charliteral">'+'</span>)
02432                 sprintf(tmpdir, <span class="stringliteral">"%s%c%s"</span>, olddir, ENV_SEPARATOR_CHAR, dir);
02433             <span class="keywordflow">else</span>
02434                 sprintf(tmpdir, <span class="stringliteral">"%s%c%s"</span>, dir, ENV_SEPARATOR_CHAR, olddir);
02435             newdir = tmpdir;
02436         } <span class="keywordflow">else</span> {
02437             newdir = dir;
02438         }
02439     } <span class="keywordflow">else</span> {
02441         newdir = ((*dir == <span class="charliteral">'+'</span>) ? ++dir : dir);
02442     }
02443     netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIBDIRS,
02444                           newdir);
02445 
02447     <span class="keywordflow">if</span> (tmpdir == newdir) {
02448         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tmpdir);
02449     }
02450 }
02451 
02452 <span class="comment">/*</span>
02453 <span class="comment"> * function : netsnmp_get_mib_directory</span>
02454 <span class="comment"> *            - This function returns a string of the directories</span>
02455 <span class="comment"> *              from which the MIB modules will be searched or</span>
02456 <span class="comment"> *              loaded.</span>
02457 <span class="comment"> *              If the value still does not exists, it will be made</span>
02458 <span class="comment"> *              from the evironment variable 'MIBDIRS' and/or the</span>
02459 <span class="comment"> *              default.</span>
02460 <span class="comment"> * arguments: -</span>
02461 <span class="comment"> * returns  : char * of the directories in which the MIB modules</span>
02462 <span class="comment"> *            will be searched/loaded.</span>
02463 <span class="comment"> */</span>
02464 
02465 <span class="keywordtype">char</span> *
<a name="l02466" id="l02466"></a><a class="code" href="group__mib__utilities.html#ga55">02466</a> <a class="code" href=
"group__mib__utilities.html#ga55">netsnmp_get_mib_directory</a>(<span class="keywordtype">void</span>)
02467 {
02468     <span class="keywordtype">char</span> *dir;
02469 
02470     DEBUGTRACE;
02471     dir = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIBDIRS);
02472     <span class="keywordflow">if</span> (dir == NULL) {
02473         DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"no mib directories set\n"</span>));
02474 
02476         dir = <a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class=
"stringliteral">"MIBDIRS"</span>);
02477         <span class="keywordflow">if</span> (dir == NULL) {
02478             DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"no mib directories set by environment\n"</span>));
02480             <span class="keywordflow">if</span> (confmibdir == NULL) {
02481                 DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"no mib directories set by config\n"</span>));
02482                 <a class="code" href="group__mib__utilities.html#ga54">netsnmp_set_mib_directory</a>(DEFAULT_MIBDIRS);
02483             }
02484             <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*confmibdir == <span class=
"charliteral">'+'</span>) || (*confmibdir == <span class="charliteral">'-'</span>)) {
02485                 DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"mib directories set by config (but added)\n"</span>));
02486                 <a class="code" href="group__mib__utilities.html#ga54">netsnmp_set_mib_directory</a>(DEFAULT_MIBDIRS);
02487                 <a class="code" href="group__mib__utilities.html#ga54">netsnmp_set_mib_directory</a>(confmibdir);
02488             }
02489             <span class="keywordflow">else</span> {
02490                 DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"mib directories set by config\n"</span>));
02491                 <a class="code" href="group__mib__utilities.html#ga54">netsnmp_set_mib_directory</a>(confmibdir);
02492             }
02493         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*dir == <span class=
"charliteral">'+'</span>) || (*dir == <span class="charliteral">'-'</span>)) {
02494             DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"mib directories set by environment (but added)\n"</span>));
02495             <a class="code" href="group__mib__utilities.html#ga54">netsnmp_set_mib_directory</a>(DEFAULT_MIBDIRS);
02496             <a class="code" href="group__mib__utilities.html#ga54">netsnmp_set_mib_directory</a>(dir);
02497         } <span class="keywordflow">else</span> {
02498             DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"mib directories set by environment\n"</span>));
02499             <a class="code" href="group__mib__utilities.html#ga54">netsnmp_set_mib_directory</a>(dir);
02500         }
02501         dir = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIBDIRS);
02502     }
02503     DEBUGMSGTL((<span class="stringliteral">"get_mib_directory"</span>, <span class=
"stringliteral">"mib directories set '%s'\n"</span>, dir));
02504     <span class="keywordflow">return</span>(dir);
02505 }
02506 
02507 <span class="comment">/*</span>
02508 <span class="comment"> * function : netsnmp_fixup_mib_directory</span>
02509 <span class="comment"> * arguments: -</span>
02510 <span class="comment"> * returns  : -</span>
02511 <span class="comment"> */</span>
02512 <span class="keywordtype">void</span>
<a name="l02513" id="l02513"></a><a class="code" href="group__mib__utilities.html#ga56">02513</a> <a class="code" href=
"group__mib__utilities.html#ga56">netsnmp_fixup_mib_directory</a>(<span class="keywordtype">void</span>)
02514 {
02515     <span class="keywordtype">char</span> *homepath = <a class="code" href=
"group__util.html#ga24">netsnmp_getenv</a>(<span class="stringliteral">"HOME"</span>);
02516     <span class="keywordtype">char</span> *mibpath = <a class="code" href=
"group__mib__utilities.html#ga55">netsnmp_get_mib_directory</a>();
02517     <span class="keywordtype">char</span> *oldmibpath = NULL;
02518     <span class="keywordtype">char</span> *ptr_home;
02519     <span class="keywordtype">char</span> *new_mibpath;
02520 
02521     DEBUGTRACE;
02522     <span class="keywordflow">if</span> (homepath &amp;&amp; mibpath) {
02523         DEBUGMSGTL((<span class="stringliteral">"fixup_mib_directory"</span>, <span class=
"stringliteral">"mib directories '%s'\n"</span>, mibpath));
02524         <span class="keywordflow">while</span> ((ptr_home = strstr(mibpath, <span class="stringliteral">"$HOME"</span>))) {
02525             new_mibpath = (<span class="keywordtype">char</span> *)malloc(strlen(mibpath) - strlen(<span class=
"stringliteral">"$HOME"</span>) +
02526                                          strlen(homepath)+1);
02527             <span class="keywordflow">if</span> (new_mibpath) {
02528                 *ptr_home = 0; <span class="comment">/* null out the spot where we stop copying */</span>
02529                 sprintf(new_mibpath, <span class="stringliteral">"%s%s%s"</span>, mibpath, homepath,
02530                         ptr_home + strlen(<span class="stringliteral">"$HOME"</span>));
02532                 mibpath = new_mibpath;
02533                 <span class="keywordflow">if</span> (oldmibpath != NULL) {
02534                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(oldmibpath);
02535                 }
02536                 oldmibpath = new_mibpath;
02537             } <span class="keywordflow">else</span> {
02538                 <span class="keywordflow">break</span>;
02539             }
02540         }
02541 
02542         <a class="code" href="group__mib__utilities.html#ga54">netsnmp_set_mib_directory</a>(mibpath);
02543         
02544         <span class="comment">/*  The above copies the mibpath for us, so...  */</span>
02545 
02546         <span class="keywordflow">if</span> (oldmibpath != NULL) {
02547             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(oldmibpath);
02548         }
02549 
02550     }
02551 
02552 }
02553 
02559 <span class="keywordtype">void</span>
<a name="l02560" id="l02560"></a><a class="code" href="group__mib__utilities.html#ga57">02560</a> <a class="code" href=
"group__mib__utilities.html#ga57">init_mib</a>(<span class="keywordtype">void</span>)
02561 {
02562     <span class="keyword">const</span> <span class="keywordtype">char</span>     *prefix;
02563     <span class="keywordtype">char</span>           *env_var, *entry;
02564     PrefixListPtr   pp = &amp;mib_prefixes[0];
02565     <span class="keywordtype">char</span>           *st;
02566 
02567     <span class="keywordflow">if</span> (Mib)
02568         <span class="keywordflow">return</span>;
02569     init_mib_internals();
02570 
02571     <span class="comment">/*</span>
02572 <span class="comment">     * Initialise the MIB directory/ies </span>
02573 <span class="comment">     */</span>
02574     <a class="code" href="group__mib__utilities.html#ga56">netsnmp_fixup_mib_directory</a>();
02575     env_var = strdup(<a class="code" href="group__mib__utilities.html#ga55">netsnmp_get_mib_directory</a>());
02576 
02577     DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>,
02578                 <span class="stringliteral">"Seen MIBDIRS: Looking in '%s' for mib dirs ...\n"</span>,
02579                 env_var));
02580 
02581     entry = strtok_r(env_var, ENV_SEPARATOR, &amp;st);
02582     <span class="keywordflow">while</span> (entry) {
02583         add_mibdir(entry);
02584         entry = strtok_r(NULL, ENV_SEPARATOR, &amp;st);
02585     }
02586     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(env_var);
02587 
02588     env_var = <a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class=
"stringliteral">"MIBFILES"</span>);
02589     <span class="keywordflow">if</span> (env_var != NULL) {
02590         <span class="keywordflow">if</span> (*env_var == <span class="charliteral">'+'</span>)
02591             entry = strtok_r(env_var+1, ENV_SEPARATOR, &amp;st);
02592         <span class="keywordflow">else</span>
02593             entry = strtok_r(env_var, ENV_SEPARATOR, &amp;st);
02594         <span class="keywordflow">while</span> (entry) {
02595             add_mibfile(entry, NULL, NULL);
02596             entry = strtok_r(NULL, ENV_SEPARATOR, &amp;st);
02597         }
02598     }
02599 
02600     init_mib_internals();
02601 
02602     <span class="comment">/*</span>
02603 <span class="comment">     * Read in any modules or mibs requested </span>
02604 <span class="comment">     */</span>
02605 
02606     env_var = <a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class="stringliteral">"MIBS"</span>);
02607     <span class="keywordflow">if</span> (env_var == NULL) {
02608         <span class="keywordflow">if</span> (confmibs != NULL)
02609             env_var = strdup(confmibs);
02610         <span class="keywordflow">else</span>
02611             env_var = strdup(DEFAULT_MIBS);
02612     } <span class="keywordflow">else</span> {
02613         env_var = strdup(env_var);
02614     }
02615     <span class="keywordflow">if</span> (env_var &amp;&amp; ((*env_var == <span class=
"charliteral">'+'</span>) || (*env_var == <span class="charliteral">'-'</span>))) {
02616         entry =
02617             (<span class="keywordtype">char</span> *) malloc(strlen(DEFAULT_MIBS) + strlen(env_var) + 2);
02618         <span class="keywordflow">if</span> (!entry) {
02619             DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>, <span class=
"stringliteral">"env mibs malloc failed"</span>));
02620             <span class="keywordflow">return</span>;
02621         } <span class="keywordflow">else</span> {
02622             <span class="keywordflow">if</span> (*env_var == <span class="charliteral">'+'</span>)
02623                 sprintf(entry, <span class="stringliteral">"%s%c%s"</span>, DEFAULT_MIBS, ENV_SEPARATOR_CHAR,
02624                         env_var+1);
02625             <span class="keywordflow">else</span>
02626                 sprintf(entry, <span class="stringliteral">"%s%c%s"</span>, env_var+1, ENV_SEPARATOR_CHAR,
02627                         DEFAULT_MIBS );
02628         }
02629         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(env_var);
02630         env_var = entry;
02631     }
02632 
02633     DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>,
02634                 <span class="stringliteral">"Seen MIBS: Looking in '%s' for mib files ...\n"</span>,
02635                 env_var));
02636     entry = strtok_r(env_var, ENV_SEPARATOR, &amp;st);
02637     <span class="keywordflow">while</span> (entry) {
02638         <span class="keywordflow">if</span> (strcasecmp(entry, DEBUG_ALWAYS_TOKEN) == 0) {
02639             read_all_mibs();
02640         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strstr(entry, <span class=
"stringliteral">"/"</span>) != 0) {
02641             read_mib(entry);
02642         } <span class="keywordflow">else</span> {
02643             netsnmp_read_module(entry);
02644         }
02645         entry = strtok_r(NULL, ENV_SEPARATOR, &amp;st);
02646     }
02647     adopt_orphans();
02648     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(env_var);
02649 
02650     env_var = <a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class=
"stringliteral">"MIBFILES"</span>);
02651     <span class="keywordflow">if</span> (env_var != NULL) {
02652         <span class="keywordflow">if</span> ((*env_var == <span class=
"charliteral">'+'</span>) || (*env_var == <span class="charliteral">'-'</span>)) {
02653 <span class="preprocessor">#ifdef DEFAULT_MIBFILES</span>
02654             entry =
02655                 (<span class="keywordtype">char</span> *) malloc(strlen(DEFAULT_MIBFILES) +
02656                                 strlen(env_var) + 2);
02657             <span class="keywordflow">if</span> (!entry) {
02658                 DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>, <span class=
"stringliteral">"env mibfiles malloc failed"</span>));
02659             } <span class="keywordflow">else</span> {
02660                 <span class="keywordflow">if</span> (*env_var++ == <span class="charliteral">'+'</span>)
02661                     sprintf(entry, <span class="stringliteral">"%s%c%s"</span>, DEFAULT_MIBFILES, ENV_SEPARATOR_CHAR,
02662                             env_var );
02663                 <span class="keywordflow">else</span>
02664                     sprintf(entry, <span class="stringliteral">"%s%c%s"</span>, env_var, ENV_SEPARATOR_CHAR,
02665                             DEFAULT_MIBFILES );
02666             }
02667             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(env_var);
02668             env_var = entry;
02669 <span class="preprocessor">#else</span>
02670             env_var = strdup(env_var + 1);
02671 <span class="preprocessor">#endif</span>
02672         } <span class="keywordflow">else</span> {
02673             env_var = strdup(env_var);
02674         }
02675     } <span class="keywordflow">else</span> {
02676 <span class="preprocessor">#ifdef DEFAULT_MIBFILES</span>
02677         env_var = strdup(DEFAULT_MIBFILES);
02678 <span class="preprocessor">#endif</span>
02679     }
02680 
02681     <span class="keywordflow">if</span> (env_var != 0) {
02682         DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>,
02683                     <span class="stringliteral">"Seen MIBFILES: Looking in '%s' for mib files ...\n"</span>,
02684                     env_var));
02685         entry = strtok_r(env_var, ENV_SEPARATOR, &amp;st);
02686         <span class="keywordflow">while</span> (entry) {
02687             read_mib(entry);
02688             entry = strtok_r(NULL, ENV_SEPARATOR, &amp;st);
02689         }
02690         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(env_var);
02691     }
02692 
02693     prefix = <a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class="stringliteral">"PREFIX"</span>);
02694 
02695     <span class="keywordflow">if</span> (!prefix)
02696         prefix = Standard_Prefix;
02697 
02698     Prefix = (<span class="keywordtype">char</span> *) malloc(strlen(prefix) + 2);
02699     <span class="keywordflow">if</span> (!Prefix)
02700         DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>, <span class=
"stringliteral">"Prefix malloc failed"</span>));
02701     <span class="keywordflow">else</span>
02702         strcpy(Prefix, prefix);
02703 
02704     DEBUGMSGTL((<span class="stringliteral">"init_mib"</span>,
02705                 <span class="stringliteral">"Seen PREFIX: Looking in '%s' for prefix ...\n"</span>, Prefix));
02706 
02707     <span class="comment">/*</span>
02708 <span class="comment">     * remove trailing dot </span>
02709 <span class="comment">     */</span>
02710     <span class="keywordflow">if</span> (Prefix) {
02711         env_var = &amp;Prefix[strlen(Prefix) - 1];
02712         <span class="keywordflow">if</span> (*env_var == <span class="charliteral">'.'</span>)
02713             *env_var = <span class="charliteral">'\0'</span>;
02714     }
02715 
02716     pp-&gt;str = Prefix;           <span class="comment">/* fixup first mib_prefix entry */</span>
02717     <span class="comment">/*</span>
02718 <span class="comment">     * now that the list of prefixes is built, save each string length. </span>
02719 <span class="comment">     */</span>
02720     <span class="keywordflow">while</span> (pp-&gt;str) {
02721         pp-&gt;len = strlen(pp-&gt;str);
02722         pp++;
02723     }
02724 
02725     Mib = tree_head;            <span class="comment">/* Backwards compatibility */</span>
02726     tree_top = (<span class="keyword">struct </span>tree *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> tree));
02727     <span class="comment">/*</span>
02728 <span class="comment">     * XX error check ? </span>
02729 <span class="comment">     */</span>
02730     <span class="keywordflow">if</span> (tree_top) {
02731         tree_top-&gt;label = strdup(<span class="stringliteral">"(top)"</span>);
02732         tree_top-&gt;child_list = tree_head;
02733     }
02734 }
02735 
02739 <span class="keywordtype">void</span>
<a name="l02740" id="l02740"></a><a class="code" href="group__mib__utilities.html#ga58">02740</a> <a class="code" href=
"group__mib__utilities.html#ga58">shutdown_mib</a>(<span class="keywordtype">void</span>)
02741 {
02742     unload_all_mibs();
02743     <span class="keywordflow">if</span> (tree_top) {
02744         <span class="keywordflow">if</span> (tree_top-&gt;label)
02745             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tree_top-&gt;label);
02746         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tree_top);
02747         tree_top = NULL;
02748     }
02749     tree_head = NULL;
02750     Mib = NULL;
02751     <span class="keywordflow">if</span> (Prefix != NULL &amp;&amp; Prefix != &amp;Standard_Prefix[0])
02752         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(Prefix);
02753     <span class="keywordflow">if</span> (Prefix)
02754         Prefix = NULL;
02755 }
02756 
02762 <span class="keywordtype">void</span>
<a name="l02763" id="l02763"></a><a class="code" href="group__mib__utilities.html#ga59">02763</a> <a class="code" href=
"group__mib__utilities.html#ga59">print_mib</a>(FILE * fp)
02764 {
02765     print_subtree(fp, tree_head, 0);
02766 }
02767 
02768 <span class="keywordtype">void</span>
02769 print_ascii_dump(FILE * fp)
02770 {
02771     fprintf(fp, <span class="stringliteral">"dump DEFINITIONS ::= BEGIN\n"</span>);
02772     print_ascii_dump_tree(fp, tree_head, 0);
02773     fprintf(fp, <span class="stringliteral">"END\n"</span>);
02774 }
02775 
02776 
02783 <span class="keywordtype">void</span>
<a name="l02784" id="l02784"></a><a class="code" href="group__mib__utilities.html#ga61">02784</a> <a class="code" href=
"group__mib__utilities.html#ga61">set_function</a>(<span class="keyword">struct</span> tree *subtree)
02785 {
02786     subtree-&gt;printer = NULL;
02787     <span class="keywordflow">switch</span> (subtree-&gt;type) {
02788     <span class="keywordflow">case</span> TYPE_OBJID:
02789         subtree-&gt;printomat = sprint_realloc_object_identifier;
02790         <span class="keywordflow">break</span>;
02791     <span class="keywordflow">case</span> TYPE_OCTETSTR:
02792         subtree-&gt;printomat = sprint_realloc_octet_string;
02793         <span class="keywordflow">break</span>;
02794     <span class="keywordflow">case</span> TYPE_INTEGER:
02795         subtree-&gt;printomat = sprint_realloc_integer;
02796         <span class="keywordflow">break</span>;
02797     <span class="keywordflow">case</span> TYPE_INTEGER32:
02798         subtree-&gt;printomat = sprint_realloc_integer;
02799         <span class="keywordflow">break</span>;
02800     <span class="keywordflow">case</span> TYPE_NETADDR:
02801         subtree-&gt;printomat = sprint_realloc_networkaddress;
02802         <span class="keywordflow">break</span>;
02803     <span class="keywordflow">case</span> TYPE_IPADDR:
02804         subtree-&gt;printomat = sprint_realloc_ipaddress;
02805         <span class="keywordflow">break</span>;
02806     <span class="keywordflow">case</span> TYPE_COUNTER:
02807         subtree-&gt;printomat = sprint_realloc_counter;
02808         <span class="keywordflow">break</span>;
02809     <span class="keywordflow">case</span> TYPE_GAUGE:
02810         subtree-&gt;printomat = sprint_realloc_gauge;
02811         <span class="keywordflow">break</span>;
02812     <span class="keywordflow">case</span> TYPE_TIMETICKS:
02813         subtree-&gt;printomat = sprint_realloc_timeticks;
02814         <span class="keywordflow">break</span>;
02815     <span class="keywordflow">case</span> TYPE_OPAQUE:
02816         subtree-&gt;printomat = sprint_realloc_opaque;
02817         <span class="keywordflow">break</span>;
02818     <span class="keywordflow">case</span> TYPE_NULL:
02819         subtree-&gt;printomat = sprint_realloc_null;
02820         <span class="keywordflow">break</span>;
02821     <span class="keywordflow">case</span> TYPE_BITSTRING:
02822         subtree-&gt;printomat = sprint_realloc_bitstring;
02823         <span class="keywordflow">break</span>;
02824     <span class="keywordflow">case</span> TYPE_NSAPADDRESS:
02825         subtree-&gt;printomat = sprint_realloc_nsapaddress;
02826         <span class="keywordflow">break</span>;
02827     <span class="keywordflow">case</span> TYPE_COUNTER64:
02828         subtree-&gt;printomat = sprint_realloc_counter64;
02829         <span class="keywordflow">break</span>;
02830     <span class="keywordflow">case</span> TYPE_UINTEGER:
02831         subtree-&gt;printomat = sprint_realloc_uinteger;
02832         <span class="keywordflow">break</span>;
02833     <span class="keywordflow">case</span> TYPE_UNSIGNED32:
02834         subtree-&gt;printomat = sprint_realloc_gauge;
02835         <span class="keywordflow">break</span>;
02836     <span class="keywordflow">case</span> TYPE_OTHER:
02837     <span class="keywordflow">default</span>:
02838         subtree-&gt;printomat = sprint_realloc_by_type;
02839         <span class="keywordflow">break</span>;
02840     }
02841 }
02842 
02843 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
02844 
02860 <span class="keywordtype">int</span>
<a name="l02861" id="l02861"></a><a class="code" href="group__mib__utilities.html#ga62">02861</a> <a class="code" href=
"group__mib__utilities.html#ga62">read_objid</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *input, oid * output, size_t * out_len)
02862 {                               <span class="comment">/* number of subid's in "output" */</span>
02863 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02864     <span class="keyword">struct </span>tree    *root = tree_head;
02865 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
02866     <span class="keywordtype">char</span>            buf[SPRINT_MAX_LEN];
02867     <span class="keywordtype">int</span>             ret, max_out_len;
02868     <span class="keywordtype">char</span>           *name, ch;
02869     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp;
02870 
02871     cp = input;
02872     <span class="keywordflow">while</span> ((ch = *cp)) {
02873         <span class="keywordflow">if</span> ((<span class=
"charliteral">'0'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'9'</span>)
02874             || (<span class="charliteral">'a'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'z'</span>)
02875             || (<span class="charliteral">'A'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'Z'</span>)
02876             || ch == <span class="charliteral">'-'</span>)
02877             cp++;
02878         <span class="keywordflow">else</span>
02879             <span class="keywordflow">break</span>;
02880     }
02881 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02882     <span class="keywordflow">if</span> (ch == <span class="charliteral">':'</span>)
02883         <span class="keywordflow">return</span> get_node(input, output, out_len);
02884 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
02885 
02886     <span class="keywordflow">if</span> (*input == <span class="charliteral">'.'</span>)
02887         input++;
02888 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02889     <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_READ_UCD_STYLE_OID)) {
02890         <span class="comment">/*</span>
02891 <span class="comment">         * get past leading '.', append '.' to Prefix. </span>
02892 <span class="comment">         */</span>
02893         <span class="keywordflow">if</span> (*Prefix == <span class="charliteral">'.'</span>)
02894             strncpy(buf, Prefix + 1, <span class="keyword">sizeof</span>(buf)-1);
02895         <span class="keywordflow">else</span>
02896             strncpy(buf, Prefix, <span class="keyword">sizeof</span>(buf)-1);
02897         buf[ <span class="keyword">sizeof</span>(buf)-1 ] = 0;
02898         strcat(buf, <span class="stringliteral">"."</span>);
02899         buf[ <span class="keyword">sizeof</span>(buf)-1 ] = 0;
02900         strncat(buf, input, <span class="keyword">sizeof</span>(buf)-strlen(buf));
02901         buf[ <span class="keyword">sizeof</span>(buf)-1 ] = 0;
02902         input = buf;
02903     }
02904 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
02905 
02906 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02907     <span class="keywordflow">if</span> (root == NULL) {
02908         SET_SNMP_ERROR(SNMPERR_NOMIB);
02909         *out_len = 0;
02910         <span class="keywordflow">return</span> 0;
02911     }
02912 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
02913     name = strdup(input);
02914     max_out_len = *out_len;
02915     *out_len = 0;
02916 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
02917     <span class="keywordflow">if</span> ((ret =
02918          _add_strings_to_oid(root, name, output, out_len,
02919                              max_out_len)) &lt;= 0)
02920 <span class="preprocessor">#else</span>
02921     <span class="keywordflow">if</span> ((ret =
02922          _add_strings_to_oid(NULL, name, output, out_len,
02923                              max_out_len)) &lt;= 0)
02924 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
02925     {
02926         <span class="keywordflow">if</span> (ret == 0)
02927             ret = SNMPERR_UNKNOWN_OBJID;
02928         SET_SNMP_ERROR(ret);
02929         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(name);
02930         <span class="keywordflow">return</span> 0;
02931     }
02932     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(name);
02933 
02934     <span class="keywordflow">return</span> 1;
02935 }
02936 
02940 <span class="keywordtype">void</span>
02941 netsnmp_sprint_realloc_objid(u_char ** buf, size_t * buf_len,
02942                              size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
02943                              <span class="keywordtype">int</span> *buf_overflow,
02944                              <span class="keyword">const</span> oid * objid, size_t objidlen)
02945 {
02946     u_char         *tbuf = NULL, *cp = NULL;
02947     size_t          tbuf_len = 256, tout_len = 0;
02948     <span class="keywordtype">int</span>             tbuf_overflow = 0;
02949     <span class="keywordtype">int</span>             output_format;
02950 
02951     <span class="keywordflow">if</span> ((tbuf = (u_char *) calloc(tbuf_len, 1)) == NULL) {
02952         tbuf_overflow = 1;
02953     } <span class="keywordflow">else</span> {
02954         *tbuf = <span class="charliteral">'.'</span>;
02955         tout_len = 1;
02956     }
02957 
02958     _oid_finish_printing(objid, objidlen,
02959                          &amp;tbuf, &amp;tbuf_len, &amp;tout_len,
02960                          allow_realloc, &amp;tbuf_overflow);
02961 
02962     <span class="keywordflow">if</span> (tbuf_overflow) {
02963         <span class="keywordflow">if</span> (!*buf_overflow) {
02964             snmp_strcat(buf, buf_len, out_len, allow_realloc, tbuf);
02965             *buf_overflow = 1;
02966         }
02967         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tbuf);
02968         <span class="keywordflow">return</span>;
02969     }
02970 
02971     output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);
02972     <span class="keywordflow">if</span> (0 == output_format) {
02973         output_format = NETSNMP_OID_OUTPUT_NUMERIC;
02974     }
02975     <span class="keywordflow">switch</span> (output_format) {
02976     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_FULL:
02977     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_NUMERIC:
02978     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_SUFFIX:
02979     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_MODULE:
02980         cp = tbuf;
02981         <span class="keywordflow">break</span>;
02982 
02983     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_NONE:
02984     <span class="keywordflow">default</span>:
02985         cp = NULL;
02986     }
02987 
02988     <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp;
02989         !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp)) {
02990         *buf_overflow = 1;
02991     }
02992     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tbuf);
02993 }
02994 
02998 <span class="preprocessor">#ifdef DISABLE_MIB_LOADING</span>
02999 <span class="keywordtype">void</span>
03000 netsnmp_sprint_realloc_objid_tree(u_char ** buf, size_t * buf_len,
03001                                   size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
03002                                   <span class="keywordtype">int</span> *buf_overflow,
03003                                   <span class="keyword">const</span> oid * objid, size_t objidlen)
03004 {
03005     netsnmp_sprint_realloc_objid(buf, buf_len, out_len, allow_realloc,
03006                                  buf_overflow, objid, objidlen);
03007 }
03008 <span class="preprocessor">#else</span>
03009 <span class="keyword">struct </span>tree    *
03010 netsnmp_sprint_realloc_objid_tree(u_char ** buf, size_t * buf_len,
03011                                   size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
03012                                   <span class="keywordtype">int</span> *buf_overflow,
03013                                   <span class="keyword">const</span> oid * objid, size_t objidlen)
03014 {
03015     u_char         *tbuf = NULL, *cp = NULL;
03016     size_t          tbuf_len = 512, tout_len = 0;
03017     <span class="keyword">struct </span>tree    *subtree = tree_head;
03018     size_t          midpoint_offset = 0;
03019     <span class="keywordtype">int</span>             tbuf_overflow = 0;
03020     <span class="keywordtype">int</span>             output_format;
03021 
03022     <span class="keywordflow">if</span> ((tbuf = (u_char *) calloc(tbuf_len, 1)) == NULL) {
03023         tbuf_overflow = 1;
03024     } <span class="keywordflow">else</span> {
03025         *tbuf = <span class="charliteral">'.'</span>;
03026         tout_len = 1;
03027     }
03028 
03029     subtree = _get_realloc_symbol(objid, objidlen, subtree,
03030                                   &amp;tbuf, &amp;tbuf_len, &amp;tout_len,
03031                                   allow_realloc, &amp;tbuf_overflow, NULL,
03032                                   &amp;midpoint_offset);
03033 
03034     <span class="keywordflow">if</span> (tbuf_overflow) {
03035         <span class="keywordflow">if</span> (!*buf_overflow) {
03036             snmp_strcat(buf, buf_len, out_len, allow_realloc, tbuf);
03037             *buf_overflow = 1;
03038         }
03039         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tbuf);
03040         <span class="keywordflow">return</span> subtree;
03041     }
03042 
03043     output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);
03044     <span class="keywordflow">if</span> (0 == output_format) {
03045         output_format = NETSNMP_OID_OUTPUT_MODULE;
03046     }
03047     <span class="keywordflow">switch</span> (output_format) {
03048     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_FULL:
03049     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_NUMERIC:
03050         cp = tbuf;
03051         <span class="keywordflow">break</span>;
03052 
03053     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_SUFFIX:
03054     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_MODULE:
03055         <span class="keywordflow">for</span> (cp = tbuf; *cp; cp++);
03056 
03057         <span class="keywordflow">if</span> (midpoint_offset != 0) {
03058             cp = tbuf + midpoint_offset - 2;    <span class="comment">/*  beyond the '.'  */</span>
03059         } <span class="keywordflow">else</span> {
03060             <span class="keywordflow">while</span> (cp &gt;= tbuf) {
03061                 <span class="keywordflow">if</span> (isalpha(*cp)) {
03062                     <span class="keywordflow">break</span>;
03063                 }
03064                 cp--;
03065             }
03066         }
03067 
03068         <span class="keywordflow">while</span> (cp &gt;= tbuf) {
03069             <span class="keywordflow">if</span> (*cp == <span class="charliteral">'.'</span>) {
03070                 <span class="keywordflow">break</span>;
03071             }
03072             cp--;
03073         }
03074 
03075         cp++;
03076 
03077         <span class="keywordflow">if</span> ((NETSNMP_OID_OUTPUT_MODULE == output_format)
03078             &amp;&amp; cp &gt; tbuf) {
03079             <span class="keywordtype">char</span>            modbuf[256] = { 0 }, *mod =
03080                 module_name(subtree-&gt;modid, modbuf);
03081 
03082             <span class="comment">/*</span>
03083 <span class="comment">             * Don't add the module ID if it's just numeric (i.e. we couldn't look</span>
03084 <span class="comment">             * it up properly.  </span>
03085 <span class="comment">             */</span>
03086 
03087             <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; modbuf[0] != <span class=
"charliteral">'#'</span>) {
03088                 <span class="keywordflow">if</span> (!snmp_strcat
03089                     (buf, buf_len, out_len, allow_realloc,
03090                      (<span class="keyword">const</span> u_char *) mod)
03091                     || !snmp_strcat(buf, buf_len, out_len, allow_realloc,
03092                                     (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"::"</span>)) {
03093                     *buf_overflow = 1;
03094                 }
03095             }
03096         }
03097         <span class="keywordflow">break</span>;
03098 
03099     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_UCD:
03100     {
03101         PrefixListPtr   pp = &amp;mib_prefixes[0];
03102         size_t          ilen, tlen;
03103         <span class="keyword">const</span> <span class="keywordtype">char</span>     *testcp;
03104 
03105         cp = tbuf;
03106         tlen = strlen((<span class="keywordtype">char</span> *) tbuf);
03107 
03108         <span class="keywordflow">while</span> (pp-&gt;str) {
03109             ilen = pp-&gt;len;
03110             testcp = pp-&gt;str;
03111 
03112             <span class="keywordflow">if</span> ((tlen &gt; ilen) &amp;&amp; memcmp(tbuf, testcp, ilen) == 0) {
03113                 cp += (ilen + 1);
03114                 <span class="keywordflow">break</span>;
03115             }
03116             pp++;
03117         }
03118         <span class="keywordflow">break</span>;
03119     }
03120 
03121     <span class="keywordflow">case</span> NETSNMP_OID_OUTPUT_NONE:
03122     <span class="keywordflow">default</span>:
03123         cp = NULL;
03124     }
03125 
03126     <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp;
03127         !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp)) {
03128         *buf_overflow = 1;
03129     }
03130     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tbuf);
03131     <span class="keywordflow">return</span> subtree;
03132 }
03133 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
03134 
03135 <span class="keywordtype">int</span>
03136 sprint_realloc_objid(u_char ** buf, size_t * buf_len,
03137                      size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
03138                      <span class="keyword">const</span> oid * objid, size_t objidlen)
03139 {
03140     <span class="keywordtype">int</span>             buf_overflow = 0;
03141 
03142     netsnmp_sprint_realloc_objid_tree(buf, buf_len, out_len, allow_realloc,
03143                                       &amp;buf_overflow, objid, objidlen);
03144     <span class="keywordflow">return</span> !buf_overflow;
03145 }
03146 
03147 <span class="keywordtype">int</span>
03148 snprint_objid(<span class="keywordtype">char</span> *buf, size_t buf_len,
03149               <span class="keyword">const</span> oid * objid, size_t objidlen)
03150 {
03151     size_t          out_len = 0;
03152 
03153     <span class="keywordflow">if</span> (sprint_realloc_objid((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
03154                              objid, objidlen)) {
03155         <span class="keywordflow">return</span> (int) out_len;
03156     } <span class="keywordflow">else</span> {
03157         <span class="keywordflow">return</span> -1;
03158     }
03159 }
03160 
03167 <span class="keywordtype">void</span>
<a name="l03168" id="l03168"></a><a class="code" href="group__mib__utilities.html#ga67">03168</a> <a class="code" href=
"group__mib__utilities.html#ga67">print_objid</a>(<span class="keyword">const</span> oid * objid, size_t objidlen)
03169 {                               <span class="comment">/* number of subidentifiers */</span>
03170     <a class="code" href="group__mib__utilities.html#ga68">fprint_objid</a>(stdout, objid, objidlen);
03171 }
03172 
03173 
03181 <span class="keywordtype">void</span>
<a name="l03182" id="l03182"></a><a class="code" href="group__mib__utilities.html#ga68">03182</a> <a class="code" href=
"group__mib__utilities.html#ga68">fprint_objid</a>(FILE * f, <span class="keyword">const</span> oid * objid, size_t objidlen)
03183 {                               <span class="comment">/* number of subidentifiers */</span>
03184     u_char         *buf = NULL;
03185     size_t          buf_len = 256, out_len = 0;
03186     <span class="keywordtype">int</span>             buf_overflow = 0;
03187 
03188     <span class="keywordflow">if</span> ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {
03189         fprintf(f, <span class="stringliteral">"[TRUNCATED]\n"</span>);
03190         <span class="keywordflow">return</span>;
03191     } <span class="keywordflow">else</span> {
03192         netsnmp_sprint_realloc_objid_tree(&amp;buf, &amp;buf_len, &amp;out_len, 1,
03193                                           &amp;buf_overflow, objid, objidlen);
03194         <span class="keywordflow">if</span> (buf_overflow) {
03195             fprintf(f, <span class="stringliteral">"%s [TRUNCATED]\n"</span>, buf);
03196         } <span class="keywordflow">else</span> {
03197             fprintf(f, <span class="stringliteral">"%s\n"</span>, buf);
03198         }
03199     }
03200 
03201     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(buf);
03202 }
03203 
03204 <span class="keywordtype">int</span>
03205 sprint_realloc_variable(u_char ** buf, size_t * buf_len,
03206                         size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
03207                         <span class="keyword">const</span> oid * objid, size_t objidlen,
03208                         <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03209 {
03210     <span class="keywordtype">int</span>             buf_overflow = 0;
03211 
03212 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
03213     <span class="keyword">struct </span>tree    *subtree = tree_head;
03214 
03215     subtree =
03216 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
03217         netsnmp_sprint_realloc_objid_tree(buf, buf_len, out_len,
03218                                           allow_realloc, &amp;buf_overflow,
03219                                           objid, objidlen);
03220 
03221     <span class="keywordflow">if</span> (buf_overflow) {
03222         <span class="keywordflow">return</span> 0;
03223     }
03224     <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE)) {
03225         <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {
03226             <span class="keywordflow">if</span> (!snmp_strcat
03227                 (buf, buf_len, out_len, allow_realloc,
03228                  (<span class="keyword">const</span> u_char *) <span class="stringliteral">" = "</span>)) {
03229                 <span class="keywordflow">return</span> 0;
03230             }
03231         } <span class="keywordflow">else</span> {
03232             <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {
03233                 <span class="keywordflow">if</span> (!snmp_strcat
03234                     (buf, buf_len, out_len, allow_realloc,
03235                      (<span class="keyword">const</span> u_char *) <span class="stringliteral">" "</span>)) {
03236                     <span class="keywordflow">return</span> 0;
03237                 }
03238             } <span class="keywordflow">else</span> {
03239                 <span class="keywordflow">if</span> (!snmp_strcat
03240                     (buf, buf_len, out_len, allow_realloc,
03241                      (<span class="keyword">const</span> u_char *) <span class="stringliteral">" = "</span>)) {
03242                     <span class="keywordflow">return</span> 0;
03243                 }
03244             }                   <span class="comment">/* end if-else NETSNMP_DS_LIB_QUICK_PRINT */</span>
03245         }                       <span class="comment">/* end if-else NETSNMP_DS_LIB_QUICKE_PRINT */</span>
03246     } <span class="keywordflow">else</span> {
03247         *out_len = 0;
03248     }
03249 
03250     <span class="keywordflow">if</span> (variable-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == SNMP_NOSUCHOBJECT) {
03251         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
03252                            (<span class="keyword">const</span> u_char *)
03253                            <span class="stringliteral">"No Such Object available on this agent at this OID"</span>);
03254     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (variable-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == SNMP_NOSUCHINSTANCE) {
03255         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
03256                            (<span class="keyword">const</span> u_char *)
03257                            <span class="stringliteral">"No Such Instance currently exists at this OID"</span>);
03258     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (variable-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == SNMP_ENDOFMIBVIEW) {
03259         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
03260                            (<span class="keyword">const</span> u_char *)
03261                            <span class=
"stringliteral">"No more variables left in this MIB View (It is past the end of the MIB tree)"</span>);
03262 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
03263     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (subtree) {
03264         <span class="keyword">const</span> <span class="keywordtype">char</span> *units = NULL;
03265         <span class="keywordflow">if</span> (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
03266                                     NETSNMP_DS_LIB_DONT_PRINT_UNITS)) {
03267             units = subtree-&gt;units;
03268         }
03269         <span class="keywordflow">if</span> (subtree-&gt;printomat) {
03270             <span class="keywordflow">return</span> (*subtree-&gt;printomat) (buf, buf_len, out_len,
03271                                           allow_realloc, variable,
03272                                           subtree-&gt;enums, subtree-&gt;hint,
03273                                           units);
03274         } <span class="keywordflow">else</span> {
03275             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
03276                                           allow_realloc, variable,
03277                                           subtree-&gt;enums, subtree-&gt;hint,
03278                                           units);
03279         }
03280 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
03281     } <span class="keywordflow">else</span> {
03282         <span class="comment">/*</span>
03283 <span class="comment">         * Handle rare case where tree is empty.  </span>
03284 <span class="comment">         */</span>
03285         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len, allow_realloc,
03286                                       variable, 0, 0, 0);
03287     }
03288 }
03289 
03290 <span class="keywordtype">int</span>
03291 snprint_variable(<span class="keywordtype">char</span> *buf, size_t buf_len,
03292                  <span class="keyword">const</span> oid * objid, size_t objidlen,
03293                  <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03294 {
03295     size_t          out_len = 0;
03296 
03297     <span class="keywordflow">if</span> (sprint_realloc_variable((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
03298                                 objid, objidlen, variable)) {
03299         <span class="keywordflow">return</span> (int) out_len;
03300     } <span class="keywordflow">else</span> {
03301         <span class="keywordflow">return</span> -1;
03302     }
03303 }
03304 
03312 <span class="keywordtype">void</span>
<a name="l03313" id="l03313"></a><a class="code" href="group__mib__utilities.html#ga71">03313</a> <a class="code" href=
"group__mib__utilities.html#ga71">print_variable</a>(<span class="keyword">const</span> oid * objid,
03314                size_t objidlen, <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03315 {
03316     <a class="code" href="group__mib__utilities.html#ga72">fprint_variable</a>(stdout, objid, objidlen, variable);
03317 }
03318 
03319 
03328 <span class="keywordtype">void</span>
<a name="l03329" id="l03329"></a><a class="code" href="group__mib__utilities.html#ga72">03329</a> <a class="code" href=
"group__mib__utilities.html#ga72">fprint_variable</a>(FILE * f,
03330                 <span class="keyword">const</span> oid * objid,
03331                 size_t objidlen, <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03332 {
03333     u_char         *buf = NULL;
03334     size_t          buf_len = 256, out_len = 0;
03335 
03336     <span class="keywordflow">if</span> ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {
03337         fprintf(f, <span class="stringliteral">"[TRUNCATED]\n"</span>);
03338         <span class="keywordflow">return</span>;
03339     } <span class="keywordflow">else</span> {
03340         <span class="keywordflow">if</span> (sprint_realloc_variable(&amp;buf, &amp;buf_len, &amp;out_len, 1,
03341                                     objid, objidlen, variable)) {
03342             fprintf(f, <span class="stringliteral">"%s\n"</span>, buf);
03343         } <span class="keywordflow">else</span> {
03344             fprintf(f, <span class="stringliteral">"%s [TRUNCATED]\n"</span>, buf);
03345         }
03346     }
03347 
03348     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(buf);
03349 }
03350 
03351 <span class="keywordtype">int</span>
03352 sprint_realloc_value(u_char ** buf, size_t * buf_len,
03353                      size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
03354                      <span class="keyword">const</span> oid * objid, size_t objidlen,
03355                      <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03356 {
03357 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
03358     <span class="keyword">struct </span>tree    *subtree = tree_head;
03359 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
03360 
03361     <span class="keywordflow">if</span> (variable-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == SNMP_NOSUCHOBJECT) {
03362         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
03363                            (<span class="keyword">const</span> u_char *)
03364                            <span class="stringliteral">"No Such Object available on this agent at this OID"</span>);
03365     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (variable-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == SNMP_NOSUCHINSTANCE) {
03366         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
03367                            (<span class="keyword">const</span> u_char *)
03368                            <span class="stringliteral">"No Such Instance currently exists at this OID"</span>);
03369     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (variable-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == SNMP_ENDOFMIBVIEW) {
03370         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc,
03371                            (<span class="keyword">const</span> u_char *)
03372                            <span class=
"stringliteral">"No more variables left in this MIB View (It is past the end of the MIB tree)"</span>);
03373     } <span class="keywordflow">else</span> {
03374 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
03375         <span class="keyword">const</span> <span class="keywordtype">char</span> *units = NULL;
03376         subtree = <a class="code" href="group__mib__utilities.html#ga84">get_tree</a>(objid, objidlen, subtree);
03377         <span class="keywordflow">if</span> (subtree &amp;&amp; !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
03378                                             NETSNMP_DS_LIB_DONT_PRINT_UNITS)) {
03379             units = subtree-&gt;units;
03380         }
03381         <span class="keywordflow">if</span> (subtree &amp;&amp; subtree-&gt;printomat) {
03382             <span class="keywordflow">return</span> (*subtree-&gt;printomat) (buf, buf_len, out_len,
03383                                           allow_realloc, variable,
03384                                           subtree-&gt;enums, subtree-&gt;hint,
03385                                           units);
03386         } <span class="keywordflow">else</span> {
03387             <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
03388                                           allow_realloc, variable,
03389                                           subtree-&gt;enums, subtree-&gt;hint,
03390                                           units);
03391         }
03392 <span class="preprocessor">#else</span>
03393         <span class="keywordflow">return</span> <a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>(buf, buf_len, out_len,
03394                                       allow_realloc, variable,
03395                                       NULL, NULL, NULL);
03396 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
03397     }
03398 }
03399 
03400 <span class="keywordtype">int</span>
03401 snprint_value(<span class="keywordtype">char</span> *buf, size_t buf_len,
03402               <span class="keyword">const</span> oid * objid, size_t objidlen,
03403               <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03404 {
03405     size_t          out_len = 0;
03406 
03407     <span class="keywordflow">if</span> (sprint_realloc_value((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
03408                              objid, objidlen, variable)) {
03409         <span class="keywordflow">return</span> (int) out_len;
03410     } <span class="keywordflow">else</span> {
03411         <span class="keywordflow">return</span> -1;
03412     }
03413 }
03414 
03415 <span class="keywordtype">void</span>
03416 print_value(<span class="keyword">const</span> oid * objid,
03417             size_t objidlen, <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03418 {
03419     fprint_value(stdout, objid, objidlen, variable);
03420 }
03421 
03422 <span class="keywordtype">void</span>
03423 fprint_value(FILE * f,
03424              <span class="keyword">const</span> oid * objid,
03425              size_t objidlen, <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * variable)
03426 {
03427     u_char         *buf = NULL;
03428     size_t          buf_len = 256, out_len = 0;
03429 
03430     <span class="keywordflow">if</span> ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {
03431         fprintf(f, <span class="stringliteral">"[TRUNCATED]\n"</span>);
03432         <span class="keywordflow">return</span>;
03433     } <span class="keywordflow">else</span> {
03434         <span class="keywordflow">if</span> (sprint_realloc_value(&amp;buf, &amp;buf_len, &amp;out_len, 1,
03435                                  objid, objidlen, variable)) {
03436             fprintf(f, <span class="stringliteral">"%s\n"</span>, buf);
03437         } <span class="keywordflow">else</span> {
03438             fprintf(f, <span class="stringliteral">"%s [TRUNCATED]\n"</span>, buf);
03439         }
03440     }
03441 
03442     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(buf);
03443 }
03444 
03445 
03453 <span class="keywordtype">int</span>
<a name="l03454" id="l03454"></a><a class="code" href="group__mib__utilities.html#ga77">03454</a> <a class="code" href=
"group__mib__utilities.html#ga77">build_oid_segment</a>(<a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var)
03455 {
03456     <span class="keywordtype">int</span>             i;
03457 
03458     <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a> &amp;&amp; var-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a> != var-&gt;<a class="code" href="structvariable__list.html#o6">name_loc</a>)
03459         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(var-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>);
03460     <span class="keywordflow">switch</span> (var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>) {
03461     <span class="keywordflow">case</span> ASN_INTEGER:
03462     <span class="keywordflow">case</span> ASN_COUNTER:
03463     <span class="keywordflow">case</span> ASN_GAUGE:
03464     <span class="keywordflow">case</span> ASN_TIMETICKS:
03465         var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = 1;
03466         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>;
03467         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[0] = *(var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer);
03468         <span class="keywordflow">break</span>;
03469 
03470     <span class="keywordflow">case</span> ASN_IPADDRESS:
03471         var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = 4;
03472         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>;
03473         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[0] =
03474             (((<span class="keywordtype">unsigned</span> int) *(var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer)) &amp; 0xff000000) &gt;&gt; 24;
03475         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[1] =
03476             (((<span class="keywordtype">unsigned</span> int) *(var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer)) &amp; 0x00ff0000) &gt;&gt; 16;
03477         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[2] =
03478             (((<span class="keywordtype">unsigned</span> int) *(var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer)) &amp; 0x0000ff00) &gt;&gt; 8;
03479         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[3] =
03480             (((<span class="keywordtype">unsigned</span> int) *(var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer)) &amp; 0x000000ff);
03481         <span class="keywordflow">break</span>;
03482         
03483     <span class="keywordflow">case</span> ASN_PRIV_IMPLIED_OBJECT_ID:
03484         var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> / <span class="keyword">sizeof</span>(oid);
03485         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> &gt; (<span class="keyword">sizeof</span>(var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>) / <span class="keyword">sizeof</span>(oid)))
03486             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = (oid *) malloc(<span class=
"keyword">sizeof</span>(oid) * (var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>));
03487         <span class="keywordflow">else</span>
03488             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>;
03489         <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> == NULL)
03490             <span class="keywordflow">return</span> SNMPERR_GENERR;
03491 
03492         <span class="keywordflow">for</span> (i = 0; i &lt; (int) var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a>; i++)
03493             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[i] = var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid[i];
03494         <span class="keywordflow">break</span>;
03495 
03496     <span class="keywordflow">case</span> ASN_OBJECT_ID:
03497         var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> / <span class="keyword">sizeof</span>(oid) + 1;
03498         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> &gt; (<span class="keyword">sizeof</span>(var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>) / <span class="keyword">sizeof</span>(oid)))
03499             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = (oid *) malloc(<span class=
"keyword">sizeof</span>(oid) * (var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>));
03500         <span class="keywordflow">else</span>
03501             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>;
03502         <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> == NULL)
03503             <span class="keywordflow">return</span> SNMPERR_GENERR;
03504 
03505         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[0] = var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> - 1;
03506         <span class="keywordflow">for</span> (i = 0; i &lt; (int) var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> - 1; i++)
03507             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[i + 1] = var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid[i];
03508         <span class="keywordflow">break</span>;
03509 
03510     <span class="keywordflow">case</span> ASN_PRIV_IMPLIED_OCTET_STR:
03511         var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>;
03512         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> &gt; (<span class="keyword">sizeof</span>(var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>) / <span class="keyword">sizeof</span>(oid)))
03513             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = (oid *) malloc(<span class=
"keyword">sizeof</span>(oid) * (var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>));
03514         <span class="keywordflow">else</span>
03515             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>;
03516         <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> == NULL)
03517             <span class="keywordflow">return</span> SNMPERR_GENERR;
03518 
03519         <span class="keywordflow">for</span> (i = 0; i &lt; (int) var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>; i++)
03520             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[i] = (oid) var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string[i];
03521         <span class="keywordflow">break</span>;
03522 
03523     <span class="keywordflow">case</span> ASN_OPAQUE:
03524     <span class="keywordflow">case</span> ASN_OCTET_STR:
03525         var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a> + 1;
03526         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> &gt; (<span class="keyword">sizeof</span>(var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>) / <span class="keyword">sizeof</span>(oid)))
03527             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = (oid *) malloc(<span class=
"keyword">sizeof</span>(oid) * (var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>));
03528         <span class="keywordflow">else</span>
03529             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> = var-&gt;<a class="code" href=
"structvariable__list.html#o6">name_loc</a>;
03530         <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#o1">name</a> == NULL)
03531             <span class="keywordflow">return</span> SNMPERR_GENERR;
03532 
03533         var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[0] = (oid) var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>;
03534         <span class="keywordflow">for</span> (i = 0; i &lt; (int) var-&gt;<a class="code" href=
"structvariable__list.html#o5">val_len</a>; i++)
03535             var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>[i + 1] = (oid) var-&gt;<a class="code"
href="structvariable__list.html#o4">val</a>.string[i];
03536         <span class="keywordflow">break</span>;
03537 
03538     <span class="keywordflow">default</span>:
03539         DEBUGMSGTL((<span class="stringliteral">"build_oid_segment"</span>,
03540                     <span class="stringliteral">"invalid asn type: %d\n"</span>, var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>));
03541         <span class="keywordflow">return</span> SNMPERR_GENERR;
03542     }
03543 
03544     <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> &gt; MAX_OID_LEN) {
03545         DEBUGMSGTL((<span class="stringliteral">"build_oid_segment"</span>,
03546                     <span class="stringliteral">"Something terribly wrong, namelen = %d\n"</span>,
03547                     var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>));
03548         <span class="keywordflow">return</span> SNMPERR_GENERR;
03549     }
03550 
03551     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03552 }
03553 
03554 
03555 <span class="keywordtype">int</span>
03556 build_oid_noalloc(oid * in, size_t in_len, size_t * out_len,
03557                   oid * prefix, size_t prefix_len,
03558                   <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * indexes)
03559 {
03560     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *var;
03561 
03562     <span class="keywordflow">if</span> (prefix) {
03563         <span class="keywordflow">if</span> (in_len &lt; prefix_len)
03564             <span class="keywordflow">return</span> SNMPERR_GENERR;
03565         memcpy(in, prefix, prefix_len * <span class="keyword">sizeof</span>(oid));
03566         *out_len = prefix_len;
03567     } <span class="keywordflow">else</span> {
03568         *out_len = 0;
03569     }
03570 
03571     <span class="keywordflow">for</span> (var = indexes; var != NULL; var = var-&gt;<a class="code" href=
"structvariable__list.html#o0">next_variable</a>) {
03572         <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga77">build_oid_segment</a>(var) != SNMPERR_SUCCESS)
03573             <span class="keywordflow">return</span> SNMPERR_GENERR;
03574         <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a> + *out_len &lt;= in_len) {
03575             memcpy(&amp;(in[*out_len]), var-&gt;<a class="code" href="structvariable__list.html#o1">name</a>,
03576                    <span class="keyword">sizeof</span>(oid) * var-&gt;<a class="code" href=
"structvariable__list.html#o2">name_length</a>);
03577             *out_len += var-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>;
03578         } <span class="keywordflow">else</span> {
03579             <span class="keywordflow">return</span> SNMPERR_GENERR;
03580         }
03581     }
03582 
03583     DEBUGMSGTL((<span class="stringliteral">"build_oid_noalloc"</span>, <span class="stringliteral">"generated: "</span>));
03584     DEBUGMSGOID((<span class="stringliteral">"build_oid_noalloc"</span>, in, *out_len));
03585     DEBUGMSG((<span class="stringliteral">"build_oid_noalloc"</span>, <span class="stringliteral">"\n"</span>));
03586     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03587 }
03588 
03589 <span class="keywordtype">int</span>
<a name="l03590" id="l03590"></a><a class="code" href="group__mib__utilities.html#ga79">03590</a> <a class="code" href=
"group__mib__utilities.html#ga79">build_oid</a>(oid ** out, size_t * out_len,
03591           oid * prefix, size_t prefix_len, <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * indexes)
03592 {
03593     oid             tmpout[MAX_OID_LEN];
03594 
03595     <span class="comment">/*</span>
03596 <span class="comment">     * xxx-rks: inefficent. try only building segments to find index len:</span>
03597 <span class="comment">     *   for (var = indexes; var != NULL; var = var-&gt;next_variable) {</span>
03598 <span class="comment">     *      if (build_oid_segment(var) != SNMPERR_SUCCESS)</span>
03599 <span class="comment">     *         return SNMPERR_GENERR;</span>
03600 <span class="comment">     *      *out_len += var-&gt;name_length;</span>
03601 <span class="comment">     *</span>
03602 <span class="comment">     * then see if it fits in existing buffer, or realloc buffer.</span>
03603 <span class="comment">     */</span>
03604     <span class="keywordflow">if</span> (build_oid_noalloc(tmpout, <span class="keyword">sizeof</span>(tmpout), out_len,
03605                           prefix, prefix_len, indexes) != SNMPERR_SUCCESS)
03606         <span class="keywordflow">return</span> SNMPERR_GENERR;
03607 
03609     snmp_clone_mem((<span class="keywordtype">void</span> **) out, (<span class=
"keywordtype">void</span> *) tmpout, *out_len * <span class="keyword">sizeof</span>(oid));
03610 
03611     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03612 }
03613 
03614 <span class="comment">/*</span>
03615 <span class="comment"> * vblist_out must contain a pre-allocated string of variables into</span>
03616 <span class="comment"> * which indexes can be extracted based on the previously existing</span>
03617 <span class="comment"> * types in the variable chain</span>
03618 <span class="comment"> * returns:</span>
03619 <span class="comment"> * SNMPERR_GENERR  on error</span>
03620 <span class="comment"> * SNMPERR_SUCCESS on success</span>
03621 <span class="comment"> */</span>
03622 
03623 <span class="keywordtype">int</span>
03624 parse_oid_indexes(oid * oidIndex, size_t oidLen,
03625                   <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * data)
03626 {
03627     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *var = data;
03628 
03629     <span class="keywordflow">while</span> (var &amp;&amp; oidLen &gt; 0) {
03630 
03631         <span class="keywordflow">if</span> (parse_one_oid_index(&amp;oidIndex, &amp;oidLen, var, 0) !=
03632             SNMPERR_SUCCESS)
03633             <span class="keywordflow">break</span>;
03634 
03635         var = var-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>;
03636     }
03637 
03638     <span class="keywordflow">if</span> (var != NULL || oidLen != 0)
03639         <span class="keywordflow">return</span> SNMPERR_GENERR;
03640     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03641 }
03642 
03643 
03644 <span class="keywordtype">int</span>
03645 parse_one_oid_index(oid ** oidStart, size_t * oidLen,
03646                     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * data, <span class=
"keywordtype">int</span> complete)
03647 {
03648     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *var = data;
03649     oid             tmpout[MAX_OID_LEN];
03650     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    i;
03651     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    uitmp = 0;
03652 
03653     oid            *oidIndex = *oidStart;
03654 
03655     <span class="keywordflow">if</span> (var == NULL || ((*oidLen == 0) &amp;&amp; (complete == 0)))
03656         <span class="keywordflow">return</span> SNMPERR_GENERR;
03657     <span class="keywordflow">else</span> {
03658         <span class="keywordflow">switch</span> (var-&gt;<a class="code" href="structvariable__list.html#o3">type</a>) {
03659         <span class="keywordflow">case</span> ASN_INTEGER:
03660         <span class="keywordflow">case</span> ASN_COUNTER:
03661         <span class="keywordflow">case</span> ASN_GAUGE:
03662         <span class="keywordflow">case</span> ASN_TIMETICKS:
03663             <span class="keywordflow">if</span> (*oidLen) {
03664                 <a class="code" href="group__snmp__client.html#ga25">snmp_set_var_value</a>(var, (u_char *) oidIndex++,
03665                                    <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
03666                 --(*oidLen);
03667             } <span class="keywordflow">else</span> {
03668                 <a class="code" href=
"group__snmp__client.html#ga25">snmp_set_var_value</a>(var, (u_char *) oidLen, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
03669             }
03670             DEBUGMSGTL((<span class="stringliteral">"parse_oid_indexes"</span>,
03671                         <span class="stringliteral">"Parsed int(%d): %d\n"</span>, var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>,
03672                         *var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.integer));
03673             <span class="keywordflow">break</span>;
03674 
03675         <span class="keywordflow">case</span> ASN_IPADDRESS:
03676             <span class="keywordflow">if</span> ((4 &gt; *oidLen) &amp;&amp; (complete == 0))
03677                 <span class="keywordflow">return</span> SNMPERR_GENERR;
03678             
03679             <span class="keywordflow">for</span> (i = 0; i &lt; 4 &amp;&amp; i &lt; *oidLen; ++i) {
03680                 <span class="keywordflow">if</span> (oidIndex[i] &gt; 255) {
03681                     DEBUGMSGTL((<span class="stringliteral">"parse_oid_indexes"</span>,
03682                                 <span class="stringliteral">"illegal oid in index: %d\n"</span>, oidIndex[0]));
03683                         <span class="keywordflow">return</span> SNMPERR_GENERR;  <span class=
"comment">/* sub-identifier too large */</span>
03684                     }
03685                     uitmp = uitmp + (oidIndex[i] &lt;&lt; (8*(3-i)));
03686                 }
03687             <span class="keywordflow">if</span> (4 &gt; (int) (*oidLen)) {
03688                 oidIndex += *oidLen;
03689                 (*oidLen) = 0;
03690             } <span class="keywordflow">else</span> {
03691                 oidIndex += 4;
03692                 (*oidLen) -= 4;
03693             }
03694             uitmp = htonl(uitmp); <span class="comment">/* put it in proper order for byte copies */</span>
03695             uitmp = 
03696                 <a class="code" href="group__snmp__client.html#ga25">snmp_set_var_value</a>(var, (u_char *) &amp;uitmp, 4);
03697             DEBUGMSGTL((<span class="stringliteral">"parse_oid_indexes"</span>,
03698                         <span class="stringliteral">"Parsed ipaddr(%d): %d.%d.%d.%d\n"</span>, var-&gt;<a class="code"
href="structvariable__list.html#o3">type</a>,
03699                         var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[0], var-&gt;<a class=
"code" href="structvariable__list.html#o4">val</a>.string[1],
03700                         var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[2], var-&gt;<a class=
"code" href="structvariable__list.html#o4">val</a>.string[3]));
03701             <span class="keywordflow">break</span>;
03702 
03703         <span class="keywordflow">case</span> ASN_OBJECT_ID:
03704         <span class="keywordflow">case</span> ASN_PRIV_IMPLIED_OBJECT_ID:
03705             <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == ASN_PRIV_IMPLIED_OBJECT_ID) {
03706                 uitmp = *oidLen;
03707             } <span class="keywordflow">else</span> {
03708                 <span class="keywordflow">if</span> (*oidLen) {
03709                     uitmp = *oidIndex++;
03710                     --(*oidLen);
03711                 } <span class="keywordflow">else</span> {
03712                     uitmp = 0;
03713                 }
03714                 <span class="keywordflow">if</span> ((uitmp &gt; *oidLen) &amp;&amp; (complete == 0))
03715                     <span class="keywordflow">return</span> SNMPERR_GENERR;
03716             }
03717 
03718             <span class="keywordflow">if</span> (uitmp &gt; MAX_OID_LEN)
03719                 <span class="keywordflow">return</span> SNMPERR_GENERR;  <span class=
"comment">/* too big and illegal */</span>
03720 
03721             <span class="keywordflow">if</span> (uitmp &gt; *oidLen) {
03722                 memcpy(tmpout, oidIndex, <span class="keyword">sizeof</span>(oid) * (*oidLen));
03723                 memset(&amp;tmpout[*oidLen], 0x00,
03724                        <span class="keyword">sizeof</span>(oid) * (uitmp - *oidLen));
03725                 <a class="code" href="group__snmp__client.html#ga25">snmp_set_var_value</a>(var, (u_char *) tmpout,
03726                                    <span class="keyword">sizeof</span>(oid) * uitmp);
03727                 oidIndex += *oidLen;
03728                 (*oidLen) = 0;
03729             } <span class="keywordflow">else</span> {
03730                 <a class="code" href="group__snmp__client.html#ga25">snmp_set_var_value</a>(var, (u_char *) oidIndex,
03731                                    <span class="keyword">sizeof</span>(oid) * uitmp);
03732                 oidIndex += uitmp;
03733                 (*oidLen) -= uitmp;
03734             }
03735 
03736             DEBUGMSGTL((<span class="stringliteral">"parse_oid_indexes"</span>, <span class=
"stringliteral">"Parsed oid: "</span>));
03737             DEBUGMSGOID((<span class="stringliteral">"parse_oid_indexes"</span>,
03738                          var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid, var-&gt;<a class="code"
href="structvariable__list.html#o5">val_len</a> / <span class="keyword">sizeof</span>(oid)));
03739             DEBUGMSG((<span class="stringliteral">"parse_oid_indexes"</span>, <span class="stringliteral">"\n"</span>));
03740             <span class="keywordflow">break</span>;
03741 
03742         <span class="keywordflow">case</span> ASN_OPAQUE:
03743         <span class="keywordflow">case</span> ASN_OCTET_STR:
03744         <span class="keywordflow">case</span> ASN_PRIV_IMPLIED_OCTET_STR:
03745             <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a> == ASN_PRIV_IMPLIED_OCTET_STR) {
03746                 uitmp = *oidLen;
03747             } <span class="keywordflow">else</span> {
03748                 <span class="keywordflow">if</span> (*oidLen) {
03749                     uitmp = *oidIndex++;
03750                     --(*oidLen);
03751                 } <span class="keywordflow">else</span> {
03752                     uitmp = 0;
03753                 }
03754                 <span class="keywordflow">if</span> ((uitmp &gt; *oidLen) &amp;&amp; (complete == 0))
03755                     <span class="keywordflow">return</span> SNMPERR_GENERR;
03756             }
03757 
03758             <span class="comment">/*</span>
03759 <span class="comment">             * we handle this one ourselves since we don't have</span>
03760 <span class="comment">             * pre-allocated memory to copy from using</span>
03761 <span class="comment">             * snmp_set_var_value() </span>
03762 <span class="comment">             */</span>
03763 
03764             <span class="keywordflow">if</span> (uitmp == 0)
03765                 <span class="keywordflow">break</span>;          <span class=
"comment">/* zero length strings shouldn't malloc */</span>
03766 
03767             <span class="keywordflow">if</span> (uitmp &gt; MAX_OID_LEN)
03768                 <span class="keywordflow">return</span> SNMPERR_GENERR;  <span class=
"comment">/* too big and illegal */</span>
03769 
03770             <span class="comment">/*</span>
03771 <span class="comment">             * malloc by size+1 to allow a null to be appended. </span>
03772 <span class="comment">             */</span>
03773             var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> = uitmp;
03774             var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string = (u_char *) calloc(1, uitmp + 1);
03775             <span class="keywordflow">if</span> (var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.string == NULL)
03776                 <span class="keywordflow">return</span> SNMPERR_GENERR;
03777 
03778             <span class="keywordflow">if</span> (uitmp &gt; (int) (*oidLen)) {
03779                 <span class="keywordflow">for</span> (i = 0; i &lt; *oidLen; ++i)
03780                     var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[i] = (u_char) * oidIndex++;
03781                 <span class="keywordflow">for</span> (i = 0; i &lt; uitmp; ++i)
03782                     var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[i] = <span class=
"charliteral">'\0'</span>;
03783                 (*oidLen) = 0;
03784             } <span class="keywordflow">else</span> {
03785                 <span class="keywordflow">for</span> (i = 0; i &lt; uitmp; ++i)
03786                     var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[i] = (u_char) * oidIndex++;
03787                 (*oidLen) -= uitmp;
03788             }
03789             var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string[uitmp] = <span class=
"charliteral">'\0'</span>;
03790 
03791             DEBUGMSGTL((<span class="stringliteral">"parse_oid_indexes"</span>,
03792                         <span class="stringliteral">"Parsed str(%d): %s\n"</span>, var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>,
03793                         var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string));
03794             <span class="keywordflow">break</span>;
03795 
03796         <span class="keywordflow">default</span>:
03797             DEBUGMSGTL((<span class="stringliteral">"parse_oid_indexes"</span>,
03798                         <span class="stringliteral">"invalid asn type: %d\n"</span>, var-&gt;<a class="code" href=
"structvariable__list.html#o3">type</a>));
03799             <span class="keywordflow">return</span> SNMPERR_GENERR;
03800         }
03801     }
03802     (*oidStart) = oidIndex;
03803     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03804 }
03805 
03806 <span class="comment">/*</span>
03807 <span class="comment"> * dump_realloc_oid_to_inetaddress:</span>
03808 <span class="comment"> *   return 0 for failure,</span>
03809 <span class="comment"> *   return 1 for success,</span>
03810 <span class="comment"> *   return 2 for not handled</span>
03811 <span class="comment"> */</span>
03812 
03813 <span class="keywordtype">int</span> 
03814 dump_realloc_oid_to_inetaddress(<span class="keyword">const</span> <span class=
"keywordtype">int</span> addr_type, <span class="keyword">const</span> oid * objid, size_t objidlen, 
03815                                 u_char ** buf, size_t * buf_len,
03816                                 size_t * out_len, <span class="keywordtype">int</span> allow_realloc, 
03817                                 <span class="keywordtype">char</span> quotechar)
03818 {
03819     <span class="keywordflow">if</span> (buf) {
03820         <span class="keywordtype">int</span>             i, len;
03821         <span class="keywordtype">char</span>            intbuf[64], * p;
03822         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   zone;
03823 
03824         memset(intbuf, 0, 64);
03825 
03826         p = intbuf;
03827         *p = quotechar;
03828         p++;
03829         <span class="keywordflow">switch</span> (addr_type) {
03830             <span class="keywordflow">case</span> IPV4:
03831             <span class="keywordflow">case</span> IPV4Z:
03832                 <span class="keywordflow">if</span> ((addr_type == IPV4  &amp;&amp; objidlen != 4) ||
03833                     (addr_type == IPV4Z &amp;&amp; objidlen != 8))
03834                     <span class="keywordflow">return</span> 2;
03835 
03836                 len = sprintf(p, <span class=
"stringliteral">"%lu.%lu.%lu.%lu"</span>, objid[0], objid[1], objid[2], objid[3]);
03837                 p += len;
03838                 <span class="keywordflow">if</span> (addr_type == IPV4Z) {
03839                     zone = ntohl((<span class="keywordtype">long</span>)objid[4]);
03840                     len = sprintf(p, <span class="stringliteral">"%%%lu"</span>, zone);
03841                     p += len;
03842                 }
03843 
03844                 <span class="keywordflow">break</span>;
03845 
03846             <span class="keywordflow">case</span> IPV6:
03847             <span class="keywordflow">case</span> IPV6Z:
03848                 <span class="keywordflow">if</span> ((addr_type == IPV6 &amp;&amp; objidlen != 16) ||
03849                     (addr_type == IPV6Z &amp;&amp; objidlen != 20))
03850                     <span class="keywordflow">return</span> 2;
03851 
03852                 len = 0;
03853                 <span class="keywordflow">for</span> (i = 0; i &lt; 16; i ++) {
03854                     len = snprintf(p, 4, <span class="stringliteral">"%02lx:"</span>, objid[i]);
03855                     p += len;
03856                 }
03857                 p-- ; <span class="comment">/* do not include the last ':' */</span>
03858 
03859                 <span class="keywordflow">if</span> (addr_type == IPV6Z) {
03860                     zone = ntohl((<span class="keywordtype">long</span>)objid[16]);
03861                     len = sprintf(p, <span class="stringliteral">"%%%lu"</span>, zone);
03862                     p += len;
03863                 }
03864 
03865                 <span class="keywordflow">break</span>;
03866 
03867             <span class="keywordflow">case</span> DNS:
03868             <span class="keywordflow">default</span>: 
03869                 <span class="comment">/* DNS can just be handled by dump_realloc_oid_to_string() */</span>
03870                 <span class="keywordflow">return</span> 2;
03871         }
03872 
03873         *p = quotechar;
03874 
03875         <span class="keywordflow">return</span> snmp_strcat(buf, buf_len, out_len, allow_realloc, 
03876                                                (<span class="keyword">const</span> u_char *) intbuf);
03877     }
03878     <span class="keywordflow">return</span> 1;
03879 }
03880 
03881 <span class="keywordtype">int</span>
03882 dump_realloc_oid_to_string(<span class="keyword">const</span> oid * objid, size_t objidlen,
03883                            u_char ** buf, size_t * buf_len,
03884                            size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
03885                            <span class="keywordtype">char</span> quotechar)
03886 {
03887     <span class="keywordflow">if</span> (buf) {
03888         <span class="keywordtype">int</span>             i, alen;
03889 
03890         <span class="keywordflow">for</span> (i = 0, alen = 0; i &lt; (int) objidlen; i++) {
03891             oid             tst = objid[i];
03892             <span class="keywordflow">if</span> ((tst &gt; 254) || (!isprint(tst))) {
03893                 tst = (oid) <span class="charliteral">'.'</span>;
03894             }
03895 
03896             <span class="keywordflow">if</span> (alen == 0) {
03897                 <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {
03898                     <span class="keywordflow">while</span> ((*out_len + 2) &gt;= *buf_len) {
03899                         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
03900                             <span class="keywordflow">return</span> 0;
03901                         }
03902                     }
03903                     *(*buf + *out_len) = <span class="charliteral">'\\'</span>;
03904                     (*out_len)++;
03905                 }
03906                 <span class="keywordflow">while</span> ((*out_len + 2) &gt;= *buf_len) {
03907                     <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
03908                         <span class="keywordflow">return</span> 0;
03909                     }
03910                 }
03911                 *(*buf + *out_len) = quotechar;
03912                 (*out_len)++;
03913             }
03914 
03915             <span class="keywordflow">while</span> ((*out_len + 2) &gt;= *buf_len) {
03916                 <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
03917                     <span class="keywordflow">return</span> 0;
03918                 }
03919             }
03920             *(*buf + *out_len) = (char) tst;
03921             (*out_len)++;
03922             alen++;
03923         }
03924 
03925         <span class="keywordflow">if</span> (alen) {
03926             <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {
03927                 <span class="keywordflow">while</span> ((*out_len + 2) &gt;= *buf_len) {
03928                     <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
03929                         <span class="keywordflow">return</span> 0;
03930                     }
03931                 }
03932                 *(*buf + *out_len) = <span class="charliteral">'\\'</span>;
03933                 (*out_len)++;
03934             }
03935             <span class="keywordflow">while</span> ((*out_len + 2) &gt;= *buf_len) {
03936                 <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
03937                     <span class="keywordflow">return</span> 0;
03938                 }
03939             }
03940             *(*buf + *out_len) = quotechar;
03941             (*out_len)++;
03942         }
03943 
03944         *(*buf + *out_len) = <span class="charliteral">'\0'</span>;
03945     }
03946 
03947     <span class="keywordflow">return</span> 1;
03948 }
03949 
03950 <span class="keywordtype">void</span>
03951 _oid_finish_printing(<span class="keyword">const</span> oid * objid, size_t objidlen,
03952                      u_char ** buf, size_t * buf_len, size_t * out_len,
03953                      <span class="keywordtype">int</span> allow_realloc, <span class=
"keywordtype">int</span> *buf_overflow) {
03954     <span class="keywordtype">char</span>            intbuf[64];
03955     <span class="keywordflow">if</span> (*buf != NULL &amp;&amp; *(*buf + *out_len - 1) != <span class=
"charliteral">'.'</span>) {
03956         <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
03957                                            allow_realloc,
03958                                            (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"."</span>)) {
03959             *buf_overflow = 1;
03960         }
03961     }
03962 
03963     <span class="keywordflow">while</span> (objidlen-- &gt; 0) {    <span class=
"comment">/* output rest of name, uninterpreted */</span>
03964         sprintf(intbuf, <span class="stringliteral">"%lu."</span>, *objid++);
03965         <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
03966                                            allow_realloc,
03967                                            (<span class="keyword">const</span> u_char *) intbuf)) {
03968             *buf_overflow = 1;
03969         }
03970     }
03971 
03972     <span class="keywordflow">if</span> (*buf != NULL) {
03973         *(*buf + *out_len - 1) = <span class="charliteral">'\0'</span>;  <span class=
"comment">/* remove trailing dot */</span>
03974         *out_len = *out_len - 1;
03975     }
03976 }
03977 
03978 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
03979 <span class="keyword">static</span> <span class="keyword">struct </span>tree *
03980 _get_realloc_symbol(<span class="keyword">const</span> oid * objid, size_t objidlen,
03981                     <span class="keyword">struct</span> tree *subtree,
03982                     u_char ** buf, size_t * buf_len, size_t * out_len,
03983                     <span class="keywordtype">int</span> allow_realloc, <span class="keywordtype">int</span> *buf_overflow,
03984                     <span class="keyword">struct</span> index_list *in_dices, size_t * end_of_known)
03985 {
03986     <span class="keyword">struct </span>tree    *return_tree = NULL;
03987     <span class="keywordtype">int</span>             extended_index =
03988         netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX);
03989     <span class="keywordtype">int</span>             output_format =
03990         netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);
03991     <span class="keywordtype">char</span>            intbuf[64];
03992 
03993     <span class="keywordflow">if</span> (!objid || !buf) {
03994         <span class="keywordflow">return</span> NULL;
03995     }
03996 
03997     <span class="keywordflow">for</span> (; subtree; subtree = subtree-&gt;next_peer) {
03998         <span class="keywordflow">if</span> (*objid == subtree-&gt;subid) {
03999             <span class=
"keywordflow">while</span> (subtree-&gt;next_peer &amp;&amp; subtree-&gt;next_peer-&gt;subid == *objid)
04000                 subtree = subtree-&gt;next_peer;
04001             <span class="keywordflow">if</span> (subtree-&gt;indexes) {
04002                 in_dices = subtree-&gt;indexes;
04003             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (subtree-&gt;augments) {
04004                 <span class="keyword">struct </span>tree    *tp2 =
04005                     find_tree_node(subtree-&gt;augments, -1);
04006                 <span class="keywordflow">if</span> (tp2) {
04007                     in_dices = tp2-&gt;indexes;
04008                 }
04009             }
04010 
04011             <span class="keywordflow">if</span> (!strncmp(subtree-&gt;label, ANON, ANON_LEN) ||
04012                 (NETSNMP_OID_OUTPUT_NUMERIC == output_format)) {
04013                 sprintf(intbuf, <span class="stringliteral">"%lu"</span>, subtree-&gt;subid);
04014                 <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04015                                                    allow_realloc,
04016                                                    (<span class="keyword">const</span> u_char *)
04017                                                    intbuf)) {
04018                     *buf_overflow = 1;
04019                 }
04020             } <span class="keywordflow">else</span> {
04021                 <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04022                                                    allow_realloc,
04023                                                    (<span class="keyword">const</span> u_char *)
04024                                                    subtree-&gt;label)) {
04025                     *buf_overflow = 1;
04026                 }
04027             }
04028 
04029             <span class="keywordflow">if</span> (objidlen &gt; 1) {
04030                 <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04031                                                    allow_realloc,
04032                                                    (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"."</span>)) {
04033                     *buf_overflow = 1;
04034                 }
04035 
04036                 return_tree = _get_realloc_symbol(objid + 1, objidlen - 1,
04037                                                   subtree-&gt;child_list,
04038                                                   buf, buf_len, out_len,
04039                                                   allow_realloc,
04040                                                   buf_overflow, in_dices,
04041                                                   end_of_known);
04042             }
04043 
04044             <span class="keywordflow">if</span> (return_tree != NULL) {
04045                 <span class="keywordflow">return</span> return_tree;
04046             } <span class="keywordflow">else</span> {
04047                 <span class="keywordflow">return</span> subtree;
04048             }
04049         }
04050     }
04051 
04052 
04053     <span class="keywordflow">if</span> (end_of_known) {
04054         *end_of_known = *out_len;
04055     }
04056 
04057     <span class="comment">/*</span>
04058 <span class="comment">     * Subtree not found.  </span>
04059 <span class="comment">     */</span>
04060 
04061     <span class="keywordflow">while</span> (in_dices &amp;&amp; (objidlen &gt; 0) &amp;&amp;
04062            (NETSNMP_OID_OUTPUT_NUMERIC != output_format) &amp;&amp;
04063            !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS)) {
04064         size_t          numids;
04065         <span class="keyword">struct </span>tree    *tp;
04066 
04067         tp = find_tree_node(in_dices-&gt;ilabel, -1);
04068 
04069         <span class="keywordflow">if</span> (!tp) {
04070             <span class="comment">/*</span>
04071 <span class="comment">             * Can't find an index in the mib tree.  Bail.  </span>
04072 <span class="comment">             */</span>
04073             <span class="keywordflow">goto</span> finish_it;
04074         }
04075 
04076         <span class="keywordflow">if</span> (extended_index) {
04077             <span class="keywordflow">if</span> (*buf != NULL &amp;&amp; *(*buf + *out_len - 1) == <span class=
"charliteral">'.'</span>) {
04078                 (*out_len)--;
04079             }
04080             <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04081                                                allow_realloc,
04082                                                (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"["</span>)) {
04083                 *buf_overflow = 1;
04084             }
04085         }
04086 
04087         <span class="keywordflow">switch</span> (tp-&gt;type) {
04088         <span class="keywordflow">case</span> TYPE_OCTETSTR:
04089             <span class="keywordflow">if</span> (extended_index &amp;&amp; tp-&gt;hint) {
04090                 <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> var;
04091                 u_char          buffer[1024];
04092                 <span class="keywordtype">int</span>             i;
04093 
04094                 memset(&amp;var, 0, <span class="keyword">sizeof</span> var);
04095                 <span class="keywordflow">if</span> (in_dices-&gt;isimplied) {
04096                     numids = objidlen;
04097                     <span class="keywordflow">if</span> (numids &gt; objidlen)
04098                         <span class="keywordflow">goto</span> finish_it;
04099                 } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (tp-&gt;ranges &amp;&amp; !tp-&gt;ranges-&gt;next
04100                            &amp;&amp; tp-&gt;ranges-&gt;low == tp-&gt;ranges-&gt;high) {
04101                     numids = tp-&gt;ranges-&gt;low;
04102                     <span class="keywordflow">if</span> (numids &gt; objidlen)
04103                         <span class="keywordflow">goto</span> finish_it;
04104                 } <span class="keywordflow">else</span> {
04105                     numids = *objid;
04106                     <span class="keywordflow">if</span> (numids &gt;= objidlen)
04107                         <span class="keywordflow">goto</span> finish_it;
04108                     objid++;
04109                     objidlen--;
04110                 }
04111                 <span class="keywordflow">if</span> (numids &gt; objidlen)
04112                     <span class="keywordflow">goto</span> finish_it;
04113                 <span class="keywordflow">for</span> (i = 0; i &lt; (int) numids; i++)
04114                     buffer[i] = (u_char) objid[i];
04115                 var.<a class="code" href="structvariable__list.html#o3">type</a> = ASN_OCTET_STR;
04116                 var.<a class="code" href="structvariable__list.html#o4">val</a>.string = buffer;
04117                 var.<a class="code" href="structvariable__list.html#o5">val_len</a> = numids;
04118                 <span class="keywordflow">if</span> (!*buf_overflow) {
04119                     <span class="keywordflow">if</span> (!<a class="code" href=
"group__mib__utilities.html#ga29">sprint_realloc_octet_string</a>(buf, buf_len, out_len,
04120                                                      allow_realloc, &amp;var,
04121                                                      NULL, tp-&gt;hint,
04122                                                      NULL)) {
04123                         *buf_overflow = 1;
04124                     }
04125                 }
04126             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in_dices-&gt;isimplied) {
04127                 numids = objidlen;
04128                 <span class="keywordflow">if</span> (numids &gt; objidlen)
04129                     <span class="keywordflow">goto</span> finish_it;
04130 
04131                 <span class="keywordflow">if</span> (!*buf_overflow) {
04132                     <span class="keywordflow">if</span> (!dump_realloc_oid_to_string
04133                         (objid, numids, buf, buf_len, out_len,
04134                          allow_realloc, <span class="charliteral">'\''</span>)) {
04135                         *buf_overflow = 1;
04136                     }
04137                 }
04138             } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (tp-&gt;ranges &amp;&amp; !tp-&gt;ranges-&gt;next
04139                        &amp;&amp; tp-&gt;ranges-&gt;low == tp-&gt;ranges-&gt;high) {
04140                 <span class="comment">/*</span>
04141 <span class="comment">                 * a fixed-length octet string </span>
04142 <span class="comment">                 */</span>
04143                 numids = tp-&gt;ranges-&gt;low;
04144                 <span class="keywordflow">if</span> (numids &gt; objidlen)
04145                     <span class="keywordflow">goto</span> finish_it;
04146 
04147                 <span class="keywordflow">if</span> (!*buf_overflow) {
04148                     <span class="keywordflow">if</span> (!dump_realloc_oid_to_string
04149                         (objid, numids, buf, buf_len, out_len,
04150                          allow_realloc, <span class="charliteral">'\''</span>)) {
04151                         *buf_overflow = 1;
04152                     }
04153                 }
04154             } <span class="keywordflow">else</span> {
04155                 numids = (size_t) * objid + 1;
04156                 <span class="keywordflow">if</span> (numids &gt; objidlen)
04157                     <span class="keywordflow">goto</span> finish_it;
04158                 <span class="keywordflow">if</span> (numids == 1) {
04159                     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean
04160                         (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {
04161                         <span class="keywordflow">if</span> (!*buf_overflow
04162                             &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04163                                             allow_realloc,
04164                                             (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"\\"</span>)) {
04165                             *buf_overflow = 1;
04166                         }
04167                     }
04168                     <span class="keywordflow">if</span> (!*buf_overflow
04169                         &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04170                                         allow_realloc,
04171                                         (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"\""</span>)) {
04172                         *buf_overflow = 1;
04173                     }
04174                     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean
04175                         (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {
04176                         <span class="keywordflow">if</span> (!*buf_overflow
04177                             &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04178                                             allow_realloc,
04179                                             (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"\\"</span>)) {
04180                             *buf_overflow = 1;
04181                         }
04182                     }
04183                     <span class="keywordflow">if</span> (!*buf_overflow
04184                         &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04185                                         allow_realloc,
04186                                         (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"\""</span>)) {
04187                         *buf_overflow = 1;
04188                     }
04189                 } <span class="keywordflow">else</span> {
04190                     <span class="keywordflow">if</span> (!*buf_overflow) {
04191                         <span class="keyword">struct </span>tree * next_peer;
04192                         <span class="keywordtype">int</span> normal_handling = 1;
04193 
04194                         <span class="keywordflow">if</span> (tp-&gt;next_peer) {
04195                             next_peer = tp-&gt;next_peer;
04196                         }
04197 
04198                         <span class="comment">/* Try handling the InetAddress in the OID, in case of failure,</span>
04199 <span class="comment">                         * use the normal_handling. </span>
04200 <span class="comment">                         */</span>
04201                         <span class="keywordflow">if</span> (tp-&gt;next_peer &amp;&amp;
04202                             tp-&gt;tc_index != -1 &amp;&amp;
04203                             next_peer-&gt;tc_index != -1 &amp;&amp;
04204                             strcmp(get_tc_descriptor(tp-&gt;tc_index), <span class=
"stringliteral">"InetAddress"</span>) == 0 &amp;&amp;
04205                             strcmp(get_tc_descriptor(next_peer-&gt;tc_index), 
04206                                     <span class="stringliteral">"InetAddressType"</span>) == 0 ) {
04207 
04208                             <span class="keywordtype">int</span> ret;
04209                             <span class="keywordtype">int</span> addr_type = *(objid - 1);
04210 
04211                             ret = dump_realloc_oid_to_inetaddress(addr_type, 
04212                                         objid + 1, numids - 1, buf, buf_len, out_len,
04213                                         allow_realloc, <span class="charliteral">'"'</span>);
04214                             <span class="keywordflow">if</span> (ret != 2) {
04215                                 normal_handling = 0;
04216                                 <span class="keywordflow">if</span> (ret == 0) {
04217                                     *buf_overflow = 1;
04218                                 }
04219 
04220                             }
04221                         } 
04222                         <span class="keywordflow">if</span> (normal_handling &amp;&amp; !dump_realloc_oid_to_string
04223                             (objid + 1, numids - 1, buf, buf_len, out_len,
04224                              allow_realloc, <span class="charliteral">'"'</span>)) {
04225                             *buf_overflow = 1;
04226                         }
04227                     }
04228                 }
04229             }
04230             objid += numids;
04231             objidlen -= numids;
04232             <span class="keywordflow">break</span>;
04233 
04234         <span class="keywordflow">case</span> TYPE_INTEGER32:
04235         <span class="keywordflow">case</span> TYPE_UINTEGER:
04236         <span class="keywordflow">case</span> TYPE_UNSIGNED32:
04237         <span class="keywordflow">case</span> TYPE_GAUGE:
04238         <span class="keywordflow">case</span> TYPE_INTEGER:
04239             <span class="keywordflow">if</span> (tp-&gt;enums) {
04240                 <span class="keyword">struct </span>enum_list *ep = tp-&gt;enums;
04241                 <span class="keywordflow">while</span> (ep &amp;&amp; ep-&gt;value != (int) (*objid)) {
04242                     ep = ep-&gt;next;
04243                 }
04244                 <span class="keywordflow">if</span> (ep) {
04245                     <span class="keywordflow">if</span> (!*buf_overflow
04246                         &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04247                                         allow_realloc,
04248                                         (<span class="keyword">const</span> u_char *) ep-&gt;label)) {
04249                         *buf_overflow = 1;
04250                     }
04251                 } <span class="keywordflow">else</span> {
04252                     sprintf(intbuf, <span class="stringliteral">"%lu"</span>, *objid);
04253                     <span class="keywordflow">if</span> (!*buf_overflow
04254                         &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04255                                         allow_realloc,
04256                                         (<span class="keyword">const</span> u_char *) intbuf)) {
04257                         *buf_overflow = 1;
04258                     }
04259                 }
04260             } <span class="keywordflow">else</span> {
04261                 sprintf(intbuf, <span class="stringliteral">"%lu"</span>, *objid);
04262                 <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04263                                                    allow_realloc,
04264                                                    (<span class="keyword">const</span> u_char *)
04265                                                    intbuf)) {
04266                     *buf_overflow = 1;
04267                 }
04268             }
04269             objid++;
04270             objidlen--;
04271             <span class="keywordflow">break</span>;
04272 
04273         <span class="keywordflow">case</span> TYPE_OBJID:
04274             <span class="keywordflow">if</span> (in_dices-&gt;isimplied) {
04275                 numids = objidlen;
04276             } <span class="keywordflow">else</span> {
04277                 numids = (size_t) * objid + 1;
04278             }
04279             <span class="keywordflow">if</span> (numids &gt; objidlen)
04280                 <span class="keywordflow">goto</span> finish_it;
04281             <span class="keywordflow">if</span> (extended_index) {
04282                 <span class="keywordflow">if</span> (in_dices-&gt;isimplied) {
04283                     <span class="keywordflow">if</span> (!*buf_overflow
04284                         &amp;&amp; !netsnmp_sprint_realloc_objid_tree(buf, buf_len,
04285                                                               out_len,
04286                                                               allow_realloc,
04287                                                               buf_overflow,
04288                                                               objid,
04289                                                               numids)) {
04290                         *buf_overflow = 1;
04291                     }
04292                 } <span class="keywordflow">else</span> {
04293                     <span class="keywordflow">if</span> (!*buf_overflow
04294                         &amp;&amp; !netsnmp_sprint_realloc_objid_tree(buf, buf_len,
04295                                                               out_len,
04296                                                               allow_realloc,
04297                                                               buf_overflow,
04298                                                               objid + 1,
04299                                                               numids -
04300                                                               1)) {
04301                         *buf_overflow = 1;
04302                     }
04303                 }
04304             } <span class="keywordflow">else</span> {
04305                 _get_realloc_symbol(objid, numids, NULL, buf, buf_len,
04306                                     out_len, allow_realloc, buf_overflow,
04307                                     NULL, NULL);
04308             }
04309             objid += (numids);
04310             objidlen -= (numids);
04311             <span class="keywordflow">break</span>;
04312 
04313         <span class="keywordflow">case</span> TYPE_IPADDR:
04314             <span class="keywordflow">if</span> (objidlen &lt; 4)
04315                 <span class="keywordflow">goto</span> finish_it;
04316             sprintf(intbuf, <span class="stringliteral">"%lu.%lu.%lu.%lu"</span>,
04317                     objid[0], objid[1], objid[2], objid[3]);
04318             objid += 4;
04319             objidlen -= 4;
04320             <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04321                                                allow_realloc,
04322                                                (<span class="keyword">const</span> u_char *) intbuf)) {
04323                 *buf_overflow = 1;
04324             }
04325             <span class="keywordflow">break</span>;
04326 
04327         <span class="keywordflow">case</span> TYPE_NETADDR:{
04328                 oid             ntype = *objid++;
04329 
04330                 objidlen--;
04331                 sprintf(intbuf, <span class="stringliteral">"%lu."</span>, ntype);
04332                 <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04333                                                    allow_realloc,
04334                                                    (<span class="keyword">const</span> u_char *)
04335                                                    intbuf)) {
04336                     *buf_overflow = 1;
04337                 }
04338 
04339                 <span class="keywordflow">if</span> (ntype == 1 &amp;&amp; objidlen &gt;= 4) {
04340                     sprintf(intbuf, <span class="stringliteral">"%lu.%lu.%lu.%lu"</span>,
04341                             objid[0], objid[1], objid[2], objid[3]);
04342                     <span class="keywordflow">if</span> (!*buf_overflow
04343                         &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04344                                         allow_realloc,
04345                                         (<span class="keyword">const</span> u_char *) intbuf)) {
04346                         *buf_overflow = 1;
04347                     }
04348                     objid += 4;
04349                     objidlen -= 4;
04350                 } <span class="keywordflow">else</span> {
04351                     <span class="keywordflow">goto</span> finish_it;
04352                 }
04353             }
04354             <span class="keywordflow">break</span>;
04355 
04356         <span class="keywordflow">case</span> TYPE_NSAPADDRESS:
04357         <span class="keywordflow">default</span>:
04358             <span class="keywordflow">goto</span> finish_it;
04359             <span class="keywordflow">break</span>;
04360         }
04361 
04362         <span class="keywordflow">if</span> (extended_index) {
04363             <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04364                                                allow_realloc,
04365                                                (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"]"</span>)) {
04366                 *buf_overflow = 1;
04367             }
04368         } <span class="keywordflow">else</span> {
04369             <span class="keywordflow">if</span> (!*buf_overflow &amp;&amp; !snmp_strcat(buf, buf_len, out_len,
04370                                                allow_realloc,
04371                                                (<span class="keyword">const</span> u_char *) <span class=
"stringliteral">"."</span>)) {
04372                 *buf_overflow = 1;
04373             }
04374         }
04375         in_dices = in_dices-&gt;next;
04376     }
04377 
04378   finish_it:
04379     _oid_finish_printing(objid, objidlen,
04380                          buf, buf_len, out_len,
04381                          allow_realloc, buf_overflow);
04382     <span class="keywordflow">return</span> NULL;
04383 }
04384 
04390 <span class="keyword">struct </span>tree    *
<a name="l04391" id="l04391"></a><a class="code" href="group__mib__utilities.html#ga84">04391</a> <a class="code" href=
"group__mib__utilities.html#ga84">get_tree</a>(<span class="keyword">const</span> oid * objid, size_t objidlen, <span class=
"keyword">struct</span> tree *subtree)
04392 {
04393     <span class="keyword">struct </span>tree    *return_tree = NULL;
04394 
04395     <span class="keywordflow">for</span> (; subtree; subtree = subtree-&gt;next_peer) {
04396         <span class="keywordflow">if</span> (*objid == subtree-&gt;subid)
04397             <span class="keywordflow">goto</span> found;
04398     }
04399 
04400     <span class="keywordflow">return</span> NULL;
04401 
04402   found:
04403     <span class="keywordflow">while</span> (subtree-&gt;next_peer &amp;&amp; subtree-&gt;next_peer-&gt;subid == *objid)
04404         subtree = subtree-&gt;next_peer;
04405     <span class="keywordflow">if</span> (objidlen &gt; 1)
04406         return_tree =
04407             <a class="code" href=
"group__mib__utilities.html#ga84">get_tree</a>(objid + 1, objidlen - 1, subtree-&gt;child_list);
04408     <span class="keywordflow">if</span> (return_tree != NULL)
04409         <span class="keywordflow">return</span> return_tree;
04410     <span class="keywordflow">else</span>
04411         <span class="keywordflow">return</span> subtree;
04412 }
04413 
04419 <span class="keywordtype">void</span>
<a name="l04420" id="l04420"></a><a class="code" href="group__mib__utilities.html#ga85">04420</a> <a class="code" href=
"group__mib__utilities.html#ga85">print_description</a>(oid * objid, size_t objidlen, <span class=
"comment">/* number of subidentifiers */</span>
04421                   <span class="keywordtype">int</span> width)
04422 {
04423     <a class="code" href="group__mib__utilities.html#ga86">fprint_description</a>(stdout, objid, objidlen, width);
04424 }
04425 
04426 
04435 <span class="keywordtype">void</span>
<a name="l04436" id="l04436"></a><a class="code" href="group__mib__utilities.html#ga86">04436</a> <a class="code" href=
"group__mib__utilities.html#ga86">fprint_description</a>(FILE * f, oid * objid, size_t objidlen,
04437                    <span class="keywordtype">int</span> width)
04438 {
04439     u_char         *buf = NULL;
04440     size_t          buf_len = 256, out_len = 0;
04441 
04442     <span class="keywordflow">if</span> ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {
04443         fprintf(f, <span class="stringliteral">"[TRUNCATED]\n"</span>);
04444         <span class="keywordflow">return</span>;
04445     } <span class="keywordflow">else</span> {
04446         <span class="keywordflow">if</span> (!sprint_realloc_description(&amp;buf, &amp;buf_len, &amp;out_len, 1,
04447                                    objid, objidlen, width)) {
04448             fprintf(f, <span class="stringliteral">"%s [TRUNCATED]\n"</span>, buf);
04449         } <span class="keywordflow">else</span> {
04450             fprintf(f, <span class="stringliteral">"%s\n"</span>, buf);
04451         }
04452     }
04453 
04454     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(buf);
04455 }
04456 
04457 <span class="keywordtype">int</span>
04458 snprint_description(<span class="keywordtype">char</span> *buf, size_t buf_len,
04459                     oid * objid, size_t objidlen, <span class="keywordtype">int</span> width)
04460 {
04461     size_t          out_len = 0;
04462 
04463     <span class="keywordflow">if</span> (sprint_realloc_description((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
04464                                     objid, objidlen, width)) {
04465         <span class="keywordflow">return</span> (int) out_len;
04466     } <span class="keywordflow">else</span> {
04467         <span class="keywordflow">return</span> -1;
04468     }
04469 }
04470 
04471 <span class="keywordtype">int</span>
04472 sprint_realloc_description(u_char ** buf, size_t * buf_len,
04473                      size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
04474                      oid * objid, size_t objidlen, <span class="keywordtype">int</span> width)
04475 {
04476     <span class="keyword">struct </span>tree    *tp = <a class="code" href=
"group__mib__utilities.html#ga84">get_tree</a>(objid, objidlen, tree_head);
04477     <span class="keyword">struct </span>tree    *subtree = tree_head;
04478     <span class="keywordtype">int</span>             pos, len;
04479     <span class="keywordtype">char</span>            tmpbuf[128];
04480     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp;
04481 
04482     <span class="keywordflow">if</span> (NULL == tp)
04483         <span class="keywordflow">return</span> 0;
04484 
04485     <span class="keywordflow">if</span> (tp-&gt;type &lt;= TYPE_SIMPLE_LAST)
04486         cp = <span class="stringliteral">" OBJECT-TYPE"</span>;
04487     <span class="keywordflow">else</span>
04488         <span class="keywordflow">switch</span> (tp-&gt;type) {
04489         <span class="keywordflow">case</span> TYPE_TRAPTYPE:
04490             cp = <span class="stringliteral">" TRAP-TYPE"</span>;
04491             <span class="keywordflow">break</span>;
04492         <span class="keywordflow">case</span> TYPE_NOTIFTYPE:
04493             cp = <span class="stringliteral">" NOTIFICATION-TYPE"</span>;
04494             <span class="keywordflow">break</span>;
04495         <span class="keywordflow">case</span> TYPE_OBJGROUP:
04496             cp = <span class="stringliteral">" OBJECT-GROUP"</span>;
04497             <span class="keywordflow">break</span>;
04498         <span class="keywordflow">case</span> TYPE_AGENTCAP:
04499             cp = <span class="stringliteral">" AGENT-CAPABILITIES"</span>;
04500             <span class="keywordflow">break</span>;
04501         <span class="keywordflow">case</span> TYPE_MODID:
04502             cp = <span class="stringliteral">" MODULE-IDENTITY"</span>;
04503             <span class="keywordflow">break</span>;
04504         <span class="keywordflow">case</span> TYPE_MODCOMP:
04505             cp = <span class="stringliteral">" MODULE-COMPLIANCE"</span>;
04506             <span class="keywordflow">break</span>;
04507         <span class="keywordflow">default</span>:
04508             sprintf(tmpbuf, <span class="stringliteral">" type_%d"</span>, tp-&gt;type);
04509             cp = tmpbuf;
04510         }
04511 
04512     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, tp-&gt;label) ||
04513         !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp) ||
04514         !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\n"</span>)) {
04515         <span class="keywordflow">return</span> 0;
04516     }
04517     <span class="keywordflow">if</span> (!print_tree_node(buf, buf_len, out_len, allow_realloc, tp, width))
04518         <span class="keywordflow">return</span> 0;
04519     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"::= {"</span>))
04520         <span class="keywordflow">return</span> 0;
04521     pos = 5;
04522     <span class="keywordflow">while</span> (objidlen &gt; 1) {
04523         <span class="keywordflow">for</span> (; subtree; subtree = subtree-&gt;next_peer) {
04524             <span class="keywordflow">if</span> (*objid == subtree-&gt;subid) {
04525                 <span class=
"keywordflow">while</span> (subtree-&gt;next_peer &amp;&amp; subtree-&gt;next_peer-&gt;subid == *objid)
04526                     subtree = subtree-&gt;next_peer;
04527                 <span class="keywordflow">if</span> (strncmp(subtree-&gt;label, ANON, ANON_LEN)) {
04528                     snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf), <span class=
"stringliteral">" %s(%lu)"</span>, subtree-&gt;label, subtree-&gt;subid);
04529                     tmpbuf[ <span class="keyword">sizeof</span>(tmpbuf)-1 ] = 0;
04530                 } <span class="keywordflow">else</span>
04531                     sprintf(tmpbuf, <span class="stringliteral">" %lu"</span>, subtree-&gt;subid);
04532                 len = strlen(tmpbuf);
04533                 <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04534                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len,
04535                                      allow_realloc, <span class="stringliteral">"\n     "</span>))
04536                         <span class="keywordflow">return</span> 0;
04537                     pos = 5;
04538                 }
04539                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, tmpbuf))
04540                     <span class="keywordflow">return</span> 0;
04541                 pos += len;
04542                 objid++;
04543                 objidlen--;
04544                 <span class="keywordflow">break</span>;
04545             }
04546         }
04547         <span class="keywordflow">if</span> (subtree)
04548             subtree = subtree-&gt;child_list;
04549         <span class="keywordflow">else</span>
04550             <span class="keywordflow">break</span>;
04551     }
04552     <span class="keywordflow">while</span> (objidlen &gt; 1) {
04553         sprintf(tmpbuf, <span class="stringliteral">" %lu"</span>, *objid);
04554         len = strlen(tmpbuf);
04555         <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04556             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"\n     "</span>))
04557                 <span class="keywordflow">return</span> 0;
04558             pos = 5;
04559         }
04560         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, tmpbuf))
04561             <span class="keywordflow">return</span> 0;
04562         pos += len;
04563         objid++;
04564         objidlen--;
04565     }
04566     sprintf(tmpbuf, <span class="stringliteral">" %lu }"</span>, *objid);
04567     len = strlen(tmpbuf);
04568     <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04569         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"\n     "</span>))
04570             <span class="keywordflow">return</span> 0;
04571         pos = 5;
04572     }
04573     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, tmpbuf))
04574         <span class="keywordflow">return</span> 0;
04575     <span class="keywordflow">return</span> 1;
04576 }
04577 
04578 <span class="keyword">static</span> <span class="keywordtype">int</span>
04579 print_tree_node(u_char ** buf, size_t * buf_len,
04580                      size_t * out_len, <span class="keywordtype">int</span> allow_realloc,
04581                      <span class="keyword">struct</span> tree *tp, <span class="keywordtype">int</span> width)
04582 {
04583     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp;
04584     <span class="keywordtype">char</span>            str[MAXTOKEN];
04585     <span class="keywordtype">int</span>             i, prevmod, pos, len;
04586 
04587     <span class="keywordflow">if</span> (tp) {
04588         module_name(tp-&gt;modid, str);
04589         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"  -- FROM\t"</span>) ||
04590             !snmp_strcat(buf, buf_len, out_len, allow_realloc, str))
04591             <span class="keywordflow">return</span> 0;
04592         pos = 16+strlen(str);
04593         <span class="keywordflow">for</span> (i = 1, prevmod = tp-&gt;modid; i &lt; tp-&gt;number_modules; i++) {
04594             <span class="keywordflow">if</span> (prevmod != tp-&gt;module_list[i]) {
04595                 module_name(tp-&gt;module_list[i], str);
04596                 len = strlen(str);
04597                 <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04598                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04599                                      <span class="stringliteral">",\n  --\t\t"</span>))
04600                         <span class="keywordflow">return</span> 0;
04601                     pos = 16;
04602                 }
04603                 <span class="keywordflow">else</span> {
04604                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">", "</span>))
04605                         <span class="keywordflow">return</span> 0;
04606                     pos += 2;
04607                 }
04608                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))
04609                     <span class="keywordflow">return</span> 0;
04610                 pos += len;
04611             }
04612             prevmod = tp-&gt;module_list[i];
04613         }
04614         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"\n"</span>))
04615             <span class="keywordflow">return</span> 0;
04616         <span class="keywordflow">if</span> (tp-&gt;tc_index != -1) {
04617             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04618                              <span class="stringliteral">"  -- TEXTUAL CONVENTION "</span>) ||
04619                 !snmp_strcat(buf, buf_len, out_len, allow_realloc,
04620                              get_tc_descriptor(tp-&gt;tc_index)) ||
04621                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\n"</span>))
04622                 <span class="keywordflow">return</span> 0;
04623         }
04624         <span class="keywordflow">switch</span> (tp-&gt;type) {
04625         <span class="keywordflow">case</span> TYPE_OBJID:
04626             cp = <span class="stringliteral">"OBJECT IDENTIFIER"</span>;
04627             <span class="keywordflow">break</span>;
04628         <span class="keywordflow">case</span> TYPE_OCTETSTR:
04629             cp = <span class="stringliteral">"OCTET STRING"</span>;
04630             <span class="keywordflow">break</span>;
04631         <span class="keywordflow">case</span> TYPE_INTEGER:
04632             cp = <span class="stringliteral">"INTEGER"</span>;
04633             <span class="keywordflow">break</span>;
04634         <span class="keywordflow">case</span> TYPE_NETADDR:
04635             cp = <span class="stringliteral">"NetworkAddress"</span>;
04636             <span class="keywordflow">break</span>;
04637         <span class="keywordflow">case</span> TYPE_IPADDR:
04638             cp = <span class="stringliteral">"IpAddress"</span>;
04639             <span class="keywordflow">break</span>;
04640         <span class="keywordflow">case</span> TYPE_COUNTER:
04641             cp = <span class="stringliteral">"Counter32"</span>;
04642             <span class="keywordflow">break</span>;
04643         <span class="keywordflow">case</span> TYPE_GAUGE:
04644             cp = <span class="stringliteral">"Gauge32"</span>;
04645             <span class="keywordflow">break</span>;
04646         <span class="keywordflow">case</span> TYPE_TIMETICKS:
04647             cp = <span class="stringliteral">"TimeTicks"</span>;
04648             <span class="keywordflow">break</span>;
04649         <span class="keywordflow">case</span> TYPE_OPAQUE:
04650             cp = <span class="stringliteral">"Opaque"</span>;
04651             <span class="keywordflow">break</span>;
04652         <span class="keywordflow">case</span> TYPE_NULL:
04653             cp = <span class="stringliteral">"NULL"</span>;
04654             <span class="keywordflow">break</span>;
04655         <span class="keywordflow">case</span> TYPE_COUNTER64:
04656             cp = <span class="stringliteral">"Counter64"</span>;
04657             <span class="keywordflow">break</span>;
04658         <span class="keywordflow">case</span> TYPE_BITSTRING:
04659             cp = <span class="stringliteral">"BITS"</span>;
04660             <span class="keywordflow">break</span>;
04661         <span class="keywordflow">case</span> TYPE_NSAPADDRESS:
04662             cp = <span class="stringliteral">"NsapAddress"</span>;
04663             <span class="keywordflow">break</span>;
04664         <span class="keywordflow">case</span> TYPE_UINTEGER:
04665             cp = <span class="stringliteral">"UInteger32"</span>;
04666             <span class="keywordflow">break</span>;
04667         <span class="keywordflow">case</span> TYPE_UNSIGNED32:
04668             cp = <span class="stringliteral">"Unsigned32"</span>;
04669             <span class="keywordflow">break</span>;
04670         <span class="keywordflow">case</span> TYPE_INTEGER32:
04671             cp = <span class="stringliteral">"Integer32"</span>;
04672             <span class="keywordflow">break</span>;
04673         <span class="keywordflow">default</span>:
04674             cp = NULL;
04675             <span class="keywordflow">break</span>;
04676         }
04677 <span class="preprocessor">#if SNMP_TESTING_CODE</span>
04678         <span class="keywordflow">if</span> (!cp &amp;&amp; (tp-&gt;ranges || tp-&gt;enums)) { <span class=
"comment">/* ranges without type ? */</span>
04679             sprintf(str, <span class="stringliteral">"?0 with %s %s ?"</span>,
04680                     tp-&gt;ranges ? <span class="stringliteral">"Range"</span> : <span class=
"stringliteral">""</span>, tp-&gt;enums ? <span class="stringliteral">"Enum"</span> : <span class="stringliteral">""</span>);
04681             cp = str;
04682         }
04683 <span class="preprocessor">#endif                          </span><span class="comment">/* SNMP_TESTING_CODE */</span>
04684         <span class="keywordflow">if</span> (cp)
04685             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04686                              <span class="stringliteral">"  SYNTAX\t"</span>) ||
04687                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp))
04688                 <span class="keywordflow">return</span> 0;
04689         <span class="keywordflow">if</span> (tp-&gt;ranges) {
04690             <span class="keyword">struct </span>range_list *rp = tp-&gt;ranges;
04691             <span class="keywordtype">int</span>             first = 1;
04692             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">" ("</span>))
04693                 <span class="keywordflow">return</span> 0;
04694             <span class="keywordflow">while</span> (rp) {
04695                 <span class="keywordflow">if</span> (rp-&gt;low == rp-&gt;high)
04696                     sprintf(str, <span class="stringliteral">"%s%d"</span>, (first ? <span class=
"stringliteral">""</span> : <span class="stringliteral">" | "</span>), rp-&gt;low );
04697                 <span class="keywordflow">else</span>
04698                     sprintf(str, <span class="stringliteral">"%s%d..%d"</span>, (first ? <span class=
"stringliteral">""</span> : <span class="stringliteral">" | "</span>),
04699                                               rp-&gt;low, rp-&gt;high);
04700                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))
04701                     <span class="keywordflow">return</span> 0;
04702                 <span class="keywordflow">if</span> (first)
04703                     first = 0;
04704                 rp = rp-&gt;next;
04705             }
04706             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">") "</span>))
04707                 <span class="keywordflow">return</span> 0;
04708         }
04709         <span class="keywordflow">if</span> (tp-&gt;enums) {
04710             <span class="keyword">struct </span>enum_list *ep = tp-&gt;enums;
04711             <span class="keywordtype">int</span>             first = 1;
04712             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">" {"</span>))
04713                 <span class="keywordflow">return</span> 0;
04714             pos = 16 + strlen(cp) + 2;
04715             <span class="keywordflow">while</span> (ep) {
04716                 <span class="keywordflow">if</span> (first)
04717                     first = 0;
04718                 <span class="keywordflow">else</span>
04719                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">", "</span>))
04720                         <span class="keywordflow">return</span> 0;
04721                 snprintf(str, <span class="keyword">sizeof</span>(str), <span class=
"stringliteral">"%s(%d)"</span>, ep-&gt;label, ep-&gt;value);
04722                 str[ <span class="keyword">sizeof</span>(str)-1 ] = 0;
04723                 len = strlen(str);
04724                 <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04725                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len,
04726                                      allow_realloc, <span class="stringliteral">"\n\t\t  "</span>))
04727                         <span class="keywordflow">return</span> 0;
04728                     pos = 18;
04729                 }
04730                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))
04731                     <span class="keywordflow">return</span> 0;
04732                 pos += len + 2;
04733                 ep = ep-&gt;next;
04734             }
04735             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"} "</span>))
04736                 <span class="keywordflow">return</span> 0;
04737         }
04738         <span class="keywordflow">if</span> (cp)
04739             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"\n"</span>))
04740                 <span class="keywordflow">return</span> 0;
04741         <span class="keywordflow">if</span> (tp-&gt;hint)
04742             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04743                              <span class="stringliteral">"  DISPLAY-HINT\t\""</span>) ||
04744                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, tp-&gt;hint) ||
04745                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\"\n"</span>))
04746                 <span class="keywordflow">return</span> 0;
04747         <span class="keywordflow">if</span> (tp-&gt;units)
04748             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04749                              <span class="stringliteral">"  UNITS\t\t\""</span>) ||
04750                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, tp-&gt;units) ||
04751                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\"\n"</span>))
04752                 <span class="keywordflow">return</span> 0;
04753         <span class="keywordflow">switch</span> (tp-&gt;access) {
04754         <span class="keywordflow">case</span> MIB_ACCESS_READONLY:
04755             cp = <span class="stringliteral">"read-only"</span>;
04756             <span class="keywordflow">break</span>;
04757         <span class="keywordflow">case</span> MIB_ACCESS_READWRITE:
04758             cp = <span class="stringliteral">"read-write"</span>;
04759             <span class="keywordflow">break</span>;
04760         <span class="keywordflow">case</span> MIB_ACCESS_WRITEONLY:
04761             cp = <span class="stringliteral">"write-only"</span>;
04762             <span class="keywordflow">break</span>;
04763         <span class="keywordflow">case</span> MIB_ACCESS_NOACCESS:
04764             cp = <span class="stringliteral">"not-accessible"</span>;
04765             <span class="keywordflow">break</span>;
04766         <span class="keywordflow">case</span> MIB_ACCESS_NOTIFY:
04767             cp = <span class="stringliteral">"accessible-for-notify"</span>;
04768             <span class="keywordflow">break</span>;
04769         <span class="keywordflow">case</span> MIB_ACCESS_CREATE:
04770             cp = <span class="stringliteral">"read-create"</span>;
04771             <span class="keywordflow">break</span>;
04772         <span class="keywordflow">case</span> 0:
04773             cp = NULL;
04774             <span class="keywordflow">break</span>;
04775         <span class="keywordflow">default</span>:
04776             sprintf(str, <span class="stringliteral">"access_%d"</span>, tp-&gt;access);
04777             cp = str;
04778         }
04779         <span class="keywordflow">if</span> (cp)
04780             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04781                              <span class="stringliteral">"  MAX-ACCESS\t"</span>) ||
04782                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp) ||
04783                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\n"</span>))
04784                 <span class="keywordflow">return</span> 0;
04785         <span class="keywordflow">switch</span> (tp-&gt;status) {
04786         <span class="keywordflow">case</span> MIB_STATUS_MANDATORY:
04787             cp = <span class="stringliteral">"mandatory"</span>;
04788             <span class="keywordflow">break</span>;
04789         <span class="keywordflow">case</span> MIB_STATUS_OPTIONAL:
04790             cp = <span class="stringliteral">"optional"</span>;
04791             <span class="keywordflow">break</span>;
04792         <span class="keywordflow">case</span> MIB_STATUS_OBSOLETE:
04793             cp = <span class="stringliteral">"obsolete"</span>;
04794             <span class="keywordflow">break</span>;
04795         <span class="keywordflow">case</span> MIB_STATUS_DEPRECATED:
04796             cp = <span class="stringliteral">"deprecated"</span>;
04797             <span class="keywordflow">break</span>;
04798         <span class="keywordflow">case</span> MIB_STATUS_CURRENT:
04799             cp = <span class="stringliteral">"current"</span>;
04800             <span class="keywordflow">break</span>;
04801         <span class="keywordflow">case</span> 0:
04802             cp = NULL;
04803             <span class="keywordflow">break</span>;
04804         <span class="keywordflow">default</span>:
04805             sprintf(str, <span class="stringliteral">"status_%d"</span>, tp-&gt;status);
04806             cp = str;
04807         }
04808 <span class="preprocessor">#if SNMP_TESTING_CODE</span>
04809         <span class="keywordflow">if</span> (!cp &amp;&amp; (tp-&gt;indexes)) {     <span class=
"comment">/* index without status ? */</span>
04810             sprintf(str, <span class="stringliteral">"?0 with %s ?"</span>, tp-&gt;indexes ? <span class=
"stringliteral">"Index"</span> : <span class="stringliteral">""</span>);
04811             cp = str;
04812         }
04813 <span class="preprocessor">#endif                          </span><span class="comment">/* SNMP_TESTING_CODE */</span>
04814         <span class="keywordflow">if</span> (cp)
04815             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04816                              <span class="stringliteral">"  STATUS\t"</span>) ||
04817                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp) ||
04818                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\n"</span>))
04819                 <span class="keywordflow">return</span> 0;
04820         <span class="keywordflow">if</span> (tp-&gt;augments)
04821             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04822                              <span class="stringliteral">"  AUGMENTS\t{ "</span>) ||
04823                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, tp-&gt;augments) ||
04824                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">" }\n"</span>))
04825                 <span class="keywordflow">return</span> 0;
04826         <span class="keywordflow">if</span> (tp-&gt;indexes) {
04827             <span class="keyword">struct </span>index_list *ip = tp-&gt;indexes;
04828             <span class="keywordtype">int</span>             first = 1;
04829             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04830                              <span class="stringliteral">"  INDEX\t\t{ "</span>))
04831                 <span class="keywordflow">return</span> 0;
04832             pos = 16 + 2;
04833             <span class="keywordflow">while</span> (ip) {
04834                 <span class="keywordflow">if</span> (first)
04835                     first = 0;
04836                 <span class="keywordflow">else</span>
04837                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">", "</span>))
04838                         <span class="keywordflow">return</span> 0;
04839                 snprintf(str, <span class="keyword">sizeof</span>(str), <span class="stringliteral">"%s%s"</span>,
04840                         ip-&gt;isimplied ? <span class="stringliteral">"IMPLIED "</span> : <span class=
"stringliteral">""</span>,
04841                         ip-&gt;ilabel);
04842                 str[ <span class="keyword">sizeof</span>(str)-1 ] = 0;
04843                 len = strlen(str);
04844                 <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04845                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"\n\t\t  "</span>))
04846                         <span class="keywordflow">return</span> 0;
04847                     pos = 16 + 2;
04848                 }
04849                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))
04850                     <span class="keywordflow">return</span> 0;
04851                 pos += len + 2;
04852                 ip = ip-&gt;next;
04853             }
04854             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">" }\n"</span>))
04855                 <span class="keywordflow">return</span> 0;
04856         }
04857         <span class="keywordflow">if</span> (tp-&gt;varbinds) {
04858             <span class="keyword">struct </span>varbind_list *vp = tp-&gt;varbinds;
04859             <span class="keywordtype">int</span>             first = 1;
04860 
04861             <span class="keywordflow">if</span> (tp-&gt;type == TYPE_TRAPTYPE) {
04862                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04863                     <span class="stringliteral">"  VARIABLES\t{ "</span>))
04864                     <span class="keywordflow">return</span> 0;
04865             } <span class="keywordflow">else</span> {
04866                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04867                     <span class="stringliteral">"  OBJECTS\t{ "</span>))
04868                     <span class="keywordflow">return</span> 0;
04869             }
04870             pos = 16 + 2;
04871             <span class="keywordflow">while</span> (vp) {
04872                 <span class="keywordflow">if</span> (first)
04873                     first = 0;
04874                 <span class="keywordflow">else</span>
04875                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">", "</span>))
04876                         <span class="keywordflow">return</span> 0;
04877                 snprintf(str, <span class="keyword">sizeof</span>(str), <span class=
"stringliteral">"%s"</span>, vp-&gt;vblabel);
04878                 str[ <span class="keyword">sizeof</span>(str)-1 ] = 0;
04879                 len = strlen(str);
04880                 <span class="keywordflow">if</span> (pos + len + 2 &gt; width) {
04881                     <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04882                                     <span class="stringliteral">"\n\t\t  "</span>))
04883                         <span class="keywordflow">return</span> 0;
04884                     pos = 16 + 2;
04885                 }
04886                 <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))
04887                     <span class="keywordflow">return</span> 0;
04888                 pos += len + 2;
04889                 vp = vp-&gt;next;
04890             }
04891             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">" }\n"</span>))
04892                 <span class="keywordflow">return</span> 0;
04893         }
04894         <span class="keywordflow">if</span> (tp-&gt;description)
04895             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04896                              <span class="stringliteral">"  DESCRIPTION\t\""</span>) ||
04897                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, tp-&gt;description) ||
04898                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">"\"\n"</span>))
04899                 <span class="keywordflow">return</span> 0;
04900         <span class="keywordflow">if</span> (tp-&gt;defaultValue)
04901             <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc,
04902                              <span class="stringliteral">"  DEFVAL\t{ "</span>) ||
04903                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, tp-&gt;defaultValue) ||
04904                 !snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class="stringliteral">" }\n"</span>))
04905                 <span class="keywordflow">return</span> 0;
04906     } <span class="keywordflow">else</span>
04907         <span class="keywordflow">if</span> (!snmp_strcat(buf, buf_len, out_len, allow_realloc, <span class=
"stringliteral">"No description\n"</span>))
04908             <span class="keywordflow">return</span> 0;
04909     <span class="keywordflow">return</span> 1;
04910 }
04911 
04912 <span class="keywordtype">int</span>
04913 get_module_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *fname,
04914                 <span class="keyword">const</span> <span class=
"keywordtype">char</span> *module, oid * objid, size_t * objidlen)
04915 {
04916     <span class="keywordtype">int</span>             modid, rc = 0;
04917     <span class="keyword">struct </span>tree    *tp;
04918     <span class="keywordtype">char</span>           *name, *cp;
04919 
04920     <span class="keywordflow">if</span> (!strcmp(module, <span class="stringliteral">"ANY"</span>))
04921         modid = -1;
04922     <span class="keywordflow">else</span> {
04923         netsnmp_read_module(module);
04924         modid = which_module(module);
04925         <span class="keywordflow">if</span> (modid == -1)
04926             <span class="keywordflow">return</span> 0;
04927     }
04928 
04929     <span class="comment">/*</span>
04930 <span class="comment">     * Isolate the first component of the name ... </span>
04931 <span class="comment">     */</span>
04932     name = strdup(fname);
04933     cp = strchr(name, <span class="charliteral">'.'</span>);
04934     <span class="keywordflow">if</span> (cp != NULL) {
04935         *cp = <span class="charliteral">'\0'</span>;
04936         cp++;
04937     }
04938     <span class="comment">/*</span>
04939 <span class="comment">     * ... and locate it in the tree. </span>
04940 <span class="comment">     */</span>
04941     tp = find_tree_node(name, modid);
04942     <span class="keywordflow">if</span> (tp) {
04943         size_t          maxlen = *objidlen;
04944 
04945         <span class="comment">/*</span>
04946 <span class="comment">         * Set the first element of the object ID </span>
04947 <span class="comment">         */</span>
04948         <span class="keywordflow">if</span> (node_to_oid(tp, objid, objidlen)) {
04949             rc = 1;
04950 
04951             <span class="comment">/*</span>
04952 <span class="comment">             * If the name requested was more than one element,</span>
04953 <span class="comment">             * tag on the rest of the components </span>
04954 <span class="comment">             */</span>
04955             <span class="keywordflow">if</span> (cp != NULL)
04956                 rc = _add_strings_to_oid(tp, cp, objid, objidlen, maxlen);
04957         }
04958     }
04959 
04960     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(name);
04961     <span class="keywordflow">return</span> (rc);
04962 }
04963 
04964 
04982 <span class="keyword">static</span> <span class="keywordtype">int</span>
04983 node_to_oid(<span class="keyword">struct</span> tree *tp, oid * objid, size_t * objidlen)
04984 {
04985     <span class="keywordtype">int</span>             numids, lenids;
04986     oid            *op;
04987 
04988     <span class="keywordflow">if</span> (!tp || !objid || !objidlen)
04989         <span class="keywordflow">return</span> 0;
04990 
04991     lenids = (int) *objidlen;
04992     op = objid + lenids;        <span class="comment">/* points after the last element */</span>
04993 
04994     <span class="keywordflow">for</span> (numids = 0; tp; tp = tp-&gt;parent, numids++) {
04995         <span class="keywordflow">if</span> (numids &gt;= lenids)
04996             <span class="keywordflow">continue</span>;
04997         --op;
04998         *op = tp-&gt;subid;
04999     }
05000 
05001     *objidlen = (size_t) numids;
05002     <span class="keywordflow">if</span> (numids &gt; lenids) {
05003         <span class="keywordflow">return</span> 0;
05004     }
05005 
05006     <span class="keywordflow">if</span> (numids &lt; lenids)
05007         memmove(objid, op, numids * <span class="keyword">sizeof</span>(oid));
05008 
05009     <span class="keywordflow">return</span> (numids);
05010 }
05011 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05012 
05013 <span class="comment">/*</span>
05014 <span class="comment"> * Replace \x with x stop at eos_marker</span>
05015 <span class="comment"> * return NULL if eos_marker not found</span>
05016 <span class="comment"> */</span>
05017 <span class="keyword">static</span> <span class="keywordtype">char</span> *_apply_escapes(<span class=
"keywordtype">char</span> *src, <span class="keywordtype">char</span> eos_marker)
05018 {
05019     <span class="keywordtype">char</span> *dst;
05020     <span class="keywordtype">int</span> backslash = 0;
05021     
05022     dst = src;
05023     <span class="keywordflow">while</span> (*src) {
05024         <span class="keywordflow">if</span> (backslash) {
05025             backslash = 0;
05026             *dst++ = *src;
05027         } <span class="keywordflow">else</span> {
05028             <span class="keywordflow">if</span> (eos_marker == *src) <span class="keywordflow">break</span>;
05029             <span class="keywordflow">if</span> (<span class="charliteral">'\\'</span> == *src) {
05030                 backslash = 1;
05031             } <span class="keywordflow">else</span> {
05032                 *dst++ = *src;
05033             }
05034         }
05035         src++;
05036     }
05037     <span class="keywordflow">if</span> (!*src) {
05038         <span class="comment">/* never found eos_marker */</span>
05039         <span class="keywordflow">return</span> NULL;
05040     } <span class="keywordflow">else</span> {
05041         *dst = 0;
05042         <span class="keywordflow">return</span> src;
05043     }
05044 }
05045 
05046 <span class="keyword">static</span> <span class="keywordtype">int</span>
05047 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05048 _add_strings_to_oid(<span class="keyword">struct</span> tree *tp, <span class="keywordtype">char</span> *cp,
05049                     oid * objid, size_t * objidlen, size_t maxlen)
05050 #<span class="keywordflow">else</span>
05051 _add_strings_to_oid(<span class="keywordtype">void</span> *tp, <span class="keywordtype">char</span> *cp,
05052                     oid * objid, size_t * objidlen, size_t maxlen)
05053 #endif <span class="comment">/* DISABLE_MIB_LOADING */</span>
05054 {
05055     oid             subid;
05056     <span class="keywordtype">int</span>             len_index = 1000000;
05057 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05058     <span class="keyword">struct </span>tree    *tp2 = NULL;
05059     <span class="keyword">struct </span>index_list *in_dices = NULL;
05060 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05061     <span class="keywordtype">char</span>           *fcp, *ecp, *cp2 = NULL;
05062     <span class="keywordtype">char</span>            doingquote;
05063     <span class="keywordtype">int</span>             len = -1, pos = -1;
05064 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05065     <span class="keywordtype">int</span>             check =
05066         !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_CHECK_RANGE);
05067     <span class=
"keywordtype">int</span>             do_hint = !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NO_DISPLAY_HINT);
05068 
05069     <span class="keywordflow">while</span> (cp &amp;&amp; tp &amp;&amp; tp-&gt;child_list) {
05070         fcp = cp;
05071         tp2 = tp-&gt;child_list;
05072         <span class="comment">/*</span>
05073 <span class="comment">         * Isolate the next entry </span>
05074 <span class="comment">         */</span>
05075         cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05076         <span class="keywordflow">if</span> (cp2)
05077             *cp2++ = <span class="charliteral">'\0'</span>;
05078 
05079         <span class="comment">/*</span>
05080 <span class="comment">         * Search for the appropriate child </span>
05081 <span class="comment">         */</span>
05082         <span class="keywordflow">if</span> (isdigit(*cp)) {
05083             subid = strtoul(cp, &amp;ecp, 0);
05084             <span class="keywordflow">if</span> (*ecp)
05085                 <span class="keywordflow">goto</span> bad_id;
05086             <span class="keywordflow">while</span> (tp2 &amp;&amp; tp2-&gt;subid != subid)
05087                 tp2 = tp2-&gt;next_peer;
05088         } <span class="keywordflow">else</span> {
05089             <span class="keywordflow">while</span> (tp2 &amp;&amp; strcmp(tp2-&gt;label, fcp))
05090                 tp2 = tp2-&gt;next_peer;
05091             <span class="keywordflow">if</span> (!tp2)
05092                 <span class="keywordflow">goto</span> bad_id;
05093             subid = tp2-&gt;subid;
05094         }
05095         <span class="keywordflow">if</span> (*objidlen &gt;= maxlen)
05096             <span class="keywordflow">goto</span> bad_id;
05097         <span class=
"keywordflow">while</span> (tp2 &amp;&amp; tp2-&gt;next_peer &amp;&amp; tp2-&gt;next_peer-&gt;subid == subid)
05098             tp2 = tp2-&gt;next_peer;
05099         objid[*objidlen] = subid;
05100         (*objidlen)++;
05101 
05102         cp = cp2;
05103         <span class="keywordflow">if</span> (!tp2)
05104             <span class="keywordflow">break</span>;
05105         tp = tp2;
05106     }
05107 
05108     <span class="keywordflow">if</span> (tp &amp;&amp; !tp-&gt;child_list) {
05109         <span class="keywordflow">if</span> ((tp2 = tp-&gt;parent)) {
05110             <span class="keywordflow">if</span> (tp2-&gt;indexes)
05111                 in_dices = tp2-&gt;indexes;
05112             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tp2-&gt;augments) {
05113                 tp2 = find_tree_node(tp2-&gt;augments, -1);
05114                 <span class="keywordflow">if</span> (tp2)
05115                     in_dices = tp2-&gt;indexes;
05116             }
05117         }
05118         tp = NULL;
05119     }
05120 
05121     <span class="keywordflow">while</span> (cp &amp;&amp; in_dices) {
05122         fcp = cp;
05123 
05124         tp = find_tree_node(in_dices-&gt;ilabel, -1);
05125         <span class="keywordflow">if</span> (!tp)
05126             <span class="keywordflow">break</span>;
05127         <span class="keywordflow">switch</span> (tp-&gt;type) {
05128         <span class="keywordflow">case</span> TYPE_INTEGER:
05129         <span class="keywordflow">case</span> TYPE_INTEGER32:
05130         <span class="keywordflow">case</span> TYPE_UINTEGER:
05131         <span class="keywordflow">case</span> TYPE_UNSIGNED32:
05132         <span class="keywordflow">case</span> TYPE_TIMETICKS:
05133             <span class="comment">/*</span>
05134 <span class="comment">             * Isolate the next entry </span>
05135 <span class="comment">             */</span>
05136             cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05137             <span class="keywordflow">if</span> (cp2)
05138                 *cp2++ = <span class="charliteral">'\0'</span>;
05139             <span class="keywordflow">if</span> (isdigit(*cp)) {
05140                 subid = strtoul(cp, &amp;ecp, 0);
05141                 <span class="keywordflow">if</span> (*ecp)
05142                     <span class="keywordflow">goto</span> bad_id;
05143             } <span class="keywordflow">else</span> {
05144                 <span class="keywordflow">if</span> (tp-&gt;enums) {
05145                     <span class="keyword">struct </span>enum_list *ep = tp-&gt;enums;
05146                     <span class="keywordflow">while</span> (ep &amp;&amp; strcmp(ep-&gt;label, cp))
05147                         ep = ep-&gt;next;
05148                     <span class="keywordflow">if</span> (!ep)
05149                         <span class="keywordflow">goto</span> bad_id;
05150                     subid = ep-&gt;value;
05151                 } <span class="keywordflow">else</span>
05152                     <span class="keywordflow">goto</span> bad_id;
05153             }
05154             <span class="keywordflow">if</span> (check &amp;&amp; tp-&gt;ranges) {
05155                 <span class="keyword">struct </span>range_list *rp = tp-&gt;ranges;
05156                 <span class="keywordtype">int</span>             ok = 0;
05157                 <span class="keywordflow">while</span> (!ok &amp;&amp; rp)
05158                     <span class="keywordflow">if</span> ((rp-&gt;low &lt;= (int) subid)
05159                         &amp;&amp; ((int) subid &lt;= rp-&gt;high))
05160                         ok = 1;
05161                     <span class="keywordflow">else</span>
05162                         rp = rp-&gt;next;
05163                 <span class="keywordflow">if</span> (!ok)
05164                     <span class="keywordflow">goto</span> bad_id;
05165             }
05166             <span class="keywordflow">if</span> (*objidlen &gt;= maxlen)
05167                 <span class="keywordflow">goto</span> bad_id;
05168             objid[*objidlen] = subid;
05169             (*objidlen)++;
05170             <span class="keywordflow">break</span>;
05171         <span class="keywordflow">case</span> TYPE_IPADDR:
05172             <span class="keywordflow">if</span> (*objidlen + 4 &gt; maxlen)
05173                 <span class="keywordflow">goto</span> bad_id;
05174             <span class="keywordflow">for</span> (subid = 0; cp &amp;&amp; subid &lt; 4; subid++) {
05175                 fcp = cp;
05176                 cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05177                 <span class="keywordflow">if</span> (cp2)
05178                     *cp2++ = 0;
05179                 objid[*objidlen] = strtoul(cp, &amp;ecp, 0);
05180                 <span class="keywordflow">if</span> (*ecp)
05181                     <span class="keywordflow">goto</span> bad_id;
05182                 <span class="keywordflow">if</span> (check &amp;&amp; objid[*objidlen] &gt; 255)
05183                     <span class="keywordflow">goto</span> bad_id;
05184                 (*objidlen)++;
05185                 cp = cp2;
05186             }
05187             <span class="keywordflow">break</span>;
05188         <span class="keywordflow">case</span> TYPE_OCTETSTR:
05189             <span class="keywordflow">if</span> (tp-&gt;ranges &amp;&amp; !tp-&gt;ranges-&gt;next
05190                 &amp;&amp; tp-&gt;ranges-&gt;low == tp-&gt;ranges-&gt;high)
05191                 len = tp-&gt;ranges-&gt;low;
05192             <span class="keywordflow">else</span>
05193                 len = -1;
05194             pos = 0;
05195             <span class="keywordflow">if</span> (*cp == <span class="charliteral">'"'</span> || *cp == <span class=
"charliteral">'\''</span>) {
05196                 doingquote = *cp++;
05197                 <span class="comment">/*</span>
05198 <span class="comment">                 * insert length if requested </span>
05199 <span class="comment">                 */</span>
05200                 <span class="keywordflow">if</span> (!in_dices-&gt;isimplied &amp;&amp; len == -1) {
05201                     <span class="keywordflow">if</span> (doingquote == <span class="charliteral">'\''</span>) {
05202                         snmp_set_detail
05203                             (<span class="stringliteral">"'-quote is for fixed length strings"</span>);
05204                         <span class="keywordflow">return</span> 0;
05205                     }
05206                     <span class="keywordflow">if</span> (*objidlen &gt;= maxlen)
05207                         <span class="keywordflow">goto</span> bad_id;
05208                     len_index = *objidlen;
05209                     (*objidlen)++;
05210                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (doingquote == <span class=
"charliteral">'"'</span>) {
05211                     snmp_set_detail
05212                         (<span class="stringliteral">"\"-quote is for variable length strings"</span>);
05213                     <span class="keywordflow">return</span> 0;
05214                 }
05215 
05216                 cp2 = _apply_escapes(cp, doingquote);
05217                 <span class="keywordflow">if</span> (!cp2) <span class="keywordflow">goto</span> bad_id;
05218                 <span class="keywordflow">else</span> {
05219                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *new_val;
05220                     <span class="keywordtype">int</span> new_val_len;
05221                     <span class="keywordtype">int</span> parsed_hint = 0;
05222                     <span class="keyword">const</span> <span class="keywordtype">char</span> *parsed_value;
05223 
05224                     <span class="keywordflow">if</span> (do_hint &amp;&amp; tp-&gt;hint) {
05225                         parsed_value = parse_octet_hint(tp-&gt;hint, cp,
05226                                                         &amp;new_val, &amp;new_val_len);
05227                         parsed_hint = parsed_value == NULL;
05228                     }
05229                     <span class="keywordflow">if</span> (parsed_hint) {
05230                         <span class="keywordtype">int</span> i;
05231                         <span class="keywordflow">for</span> (i = 0; i &lt; new_val_len; i++) {
05232                             <span class="keywordflow">if</span> (*objidlen &gt;= maxlen) <span class=
"keywordflow">goto</span> bad_id;
05233                             objid[ *objidlen ] = new_val[i];
05234                             (*objidlen)++;
05235                             pos++;
05236                         }
05237                         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(new_val);
05238                     } <span class="keywordflow">else</span> {
05239                         <span class="keywordflow">while</span>(*cp) {
05240                             <span class="keywordflow">if</span> (*objidlen &gt;= maxlen) <span class=
"keywordflow">goto</span> bad_id;
05241                             objid[ *objidlen ] = *cp++;
05242                             (*objidlen)++;
05243                             pos++;
05244                         }
05245                     }
05246                 }
05247                 
05248                 cp2++;
05249                 <span class="keywordflow">if</span> (!*cp2)
05250                     cp2 = NULL;
05251                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*cp2 != <span class=
"charliteral">'.'</span>)
05252                     <span class="keywordflow">goto</span> bad_id;
05253                 <span class="keywordflow">else</span>
05254                     cp2++;
05255                 <span class="keywordflow">if</span> (check) {
05256                     <span class="keywordflow">if</span> (len == -1) {
05257                         <span class="keyword">struct </span>range_list *rp = tp-&gt;ranges;
05258                         <span class="keywordtype">int</span>             ok = 0;
05259                         <span class="keywordflow">while</span> (rp &amp;&amp; !ok)
05260                             <span class="keywordflow">if</span> (rp-&gt;low &lt;= pos &amp;&amp; pos &lt;= rp-&gt;high)
05261                                 ok = 1;
05262                             <span class="keywordflow">else</span>
05263                                 rp = rp-&gt;next;
05264                         <span class="keywordflow">if</span> (!ok)
05265                             <span class="keywordflow">goto</span> bad_id;
05266                         <span class="keywordflow">if</span> (!in_dices-&gt;isimplied)
05267                             objid[len_index] = pos;
05268                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pos != len)
05269                         <span class="keywordflow">goto</span> bad_id;
05270                 }
05271                 <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (len == -1 &amp;&amp; !in_dices-&gt;isimplied)
05272                     objid[len_index] = pos;
05273             } <span class="keywordflow">else</span> {
05274                 <span class="keywordflow">if</span> (!in_dices-&gt;isimplied &amp;&amp; len == -1) {
05275                     fcp = cp;
05276                     cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05277                     <span class="keywordflow">if</span> (cp2)
05278                         *cp2++ = 0;
05279                     len = strtoul(cp, &amp;ecp, 0);
05280                     <span class="keywordflow">if</span> (*ecp)
05281                         <span class="keywordflow">goto</span> bad_id;
05282                     <span class="keywordflow">if</span> (*objidlen + len + 1 &gt;= maxlen)
05283                         <span class="keywordflow">goto</span> bad_id;
05284                     objid[*objidlen] = len;
05285                     (*objidlen)++;
05286                     cp = cp2;
05287                 }
05288                 <span class="keywordflow">while</span> (len &amp;&amp; cp) {
05289                     fcp = cp;
05290                     cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05291                     <span class="keywordflow">if</span> (cp2)
05292                         *cp2++ = 0;
05293                     objid[*objidlen] = strtoul(cp, &amp;ecp, 0);
05294                     <span class="keywordflow">if</span> (*ecp)
05295                         <span class="keywordflow">goto</span> bad_id;
05296                     <span class="keywordflow">if</span> (check &amp;&amp; objid[*objidlen] &gt; 255)
05297                         <span class="keywordflow">goto</span> bad_id;
05298                     (*objidlen)++;
05299                     len--;
05300                     cp = cp2;
05301                 }
05302             }
05303             <span class="keywordflow">break</span>;
05304         <span class="keywordflow">case</span> TYPE_OBJID:
05305             in_dices = NULL;
05306             cp2 = cp;
05307             <span class="keywordflow">break</span>;
05308         <span class="keywordflow">case</span> TYPE_NETADDR:
05309             fcp = cp;
05310             cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05311             <span class="keywordflow">if</span> (cp2)
05312                 *cp2++ = 0;
05313             subid = strtoul(cp, &amp;ecp, 0);
05314             <span class="keywordflow">if</span> (*ecp)
05315                 <span class="keywordflow">goto</span> bad_id;
05316             <span class="keywordflow">if</span> (*objidlen + 1 &gt;= maxlen)
05317                 <span class="keywordflow">goto</span> bad_id;
05318             objid[*objidlen] = subid;
05319             (*objidlen)++;
05320             cp = cp2;
05321             <span class="keywordflow">if</span> (subid == 1) {
05322                 <span class="keywordflow">for</span> (len = 0; cp &amp;&amp; len &lt; 4; len++) {
05323                     fcp = cp;
05324                     cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05325                     <span class="keywordflow">if</span> (cp2)
05326                         *cp2++ = 0;
05327                     subid = strtoul(cp, &amp;ecp, 0);
05328                     <span class="keywordflow">if</span> (*ecp)
05329                         <span class="keywordflow">goto</span> bad_id;
05330                     <span class="keywordflow">if</span> (*objidlen + 1 &gt;= maxlen)
05331                         <span class="keywordflow">goto</span> bad_id;
05332                     <span class="keywordflow">if</span> (check &amp;&amp; subid &gt; 255)
05333                         <span class="keywordflow">goto</span> bad_id;
05334                     objid[*objidlen] = subid;
05335                     (*objidlen)++;
05336                     cp = cp2;
05337                 }
05338             }
05339             <span class="keywordflow">else</span> {
05340                 in_dices = NULL;
05341             }
05342             <span class="keywordflow">break</span>;
05343         <span class="keywordflow">default</span>:
05344             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Unexpected index type: %d %s %s\n"</span>,
05345                      tp-&gt;type, in_dices-&gt;ilabel, cp);
05346             in_dices = NULL;
05347             cp2 = cp;
05348             <span class="keywordflow">break</span>;
05349         }
05350         cp = cp2;
05351         <span class="keywordflow">if</span> (in_dices)
05352             in_dices = in_dices-&gt;next;
05353     }
05354 
05355 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05356     <span class="keywordflow">while</span> (cp) {
05357         fcp = cp;
05358         <span class="keywordflow">switch</span> (*cp) {
05359         <span class="keywordflow">case</span> <span class="charliteral">'0'</span>:
05360         <span class="keywordflow">case</span> <span class="charliteral">'1'</span>:
05361         <span class="keywordflow">case</span> <span class="charliteral">'2'</span>:
05362         <span class="keywordflow">case</span> <span class="charliteral">'3'</span>:
05363         <span class="keywordflow">case</span> <span class="charliteral">'4'</span>:
05364         <span class="keywordflow">case</span> <span class="charliteral">'5'</span>:
05365         <span class="keywordflow">case</span> <span class="charliteral">'6'</span>:
05366         <span class="keywordflow">case</span> <span class="charliteral">'7'</span>:
05367         <span class="keywordflow">case</span> <span class="charliteral">'8'</span>:
05368         <span class="keywordflow">case</span> <span class="charliteral">'9'</span>:
05369             cp2 = strchr(cp, <span class="charliteral">'.'</span>);
05370             <span class="keywordflow">if</span> (cp2)
05371                 *cp2++ = 0;
05372             subid = strtoul(cp, &amp;ecp, 0);
05373             <span class="keywordflow">if</span> (*ecp)
05374                 <span class="keywordflow">goto</span> bad_id;
05375             <span class="keywordflow">if</span> (*objidlen &gt;= maxlen)
05376                 <span class="keywordflow">goto</span> bad_id;
05377             objid[*objidlen] = subid;
05378             (*objidlen)++;
05379             <span class="keywordflow">break</span>;
05380         <span class="keywordflow">case</span> <span class="charliteral">'"'</span>:
05381         <span class="keywordflow">case</span> <span class="charliteral">'\''</span>:
05382             doingquote = *cp++;
05383             <span class="comment">/*</span>
05384 <span class="comment">             * insert length if requested </span>
05385 <span class="comment">             */</span>
05386             <span class="keywordflow">if</span> (doingquote == <span class="charliteral">'"'</span>) {
05387                 <span class="keywordflow">if</span> (*objidlen &gt;= maxlen)
05388                     <span class="keywordflow">goto</span> bad_id;
05389                 objid[*objidlen] = len = strchr(cp, doingquote) - cp;
05390                 (*objidlen)++;
05391             }
05392 
05393             <span class="keywordflow">while</span> (*cp &amp;&amp; *cp != doingquote) {
05394                 <span class="keywordflow">if</span> (*objidlen &gt;= maxlen)
05395                     <span class="keywordflow">goto</span> bad_id;
05396                 objid[*objidlen] = *cp++;
05397                 (*objidlen)++;
05398             }
05399             <span class="keywordflow">if</span> (!cp)
05400                 <span class="keywordflow">goto</span> bad_id;
05401             cp2 = cp + 1;
05402             <span class="keywordflow">if</span> (!*cp2)
05403                 cp2 = NULL;
05404             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*cp2 == <span class=
"charliteral">'.'</span>)
05405                 cp2++;
05406             <span class="keywordflow">else</span>
05407                 <span class="keywordflow">goto</span> bad_id;
05408             <span class="keywordflow">break</span>;
05409         <span class="keywordflow">default</span>:
05410             <span class="keywordflow">goto</span> bad_id;
05411         }
05412         cp = cp2;
05413     }
05414     <span class="keywordflow">return</span> 1;
05415 
05416   bad_id:
05417     {
05418         <span class="keywordtype">char</span>            buf[256];
05419 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05420         <span class="keywordflow">if</span> (in_dices)
05421             snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class=
"stringliteral">"Index out of range: %s (%s)"</span>,
05422                     fcp, in_dices-&gt;ilabel);
05423         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tp)
05424             snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class=
"stringliteral">"Sub-id not found: %s -&gt; %s"</span>, tp-&gt;label, fcp);
05425         <span class="keywordflow">else</span>
05426 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05427             snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">"%s"</span>, fcp);
05428         buf[ <span class="keyword">sizeof</span>(buf)-1 ] = 0;
05429 
05430         snmp_set_detail(buf);
05431     }
05432     <span class="keywordflow">return</span> 0;
05433 }
05434 
05435 
05436 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05437 
05440 <span class="keywordtype">int</span>
<a name="l05441" id="l05441"></a><a class="code" href="group__mib__utilities.html#ga91">05441</a> <a class="code" href=
"group__mib__utilities.html#ga91">get_wild_node</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *name, oid * objid, size_t * objidlen)
05442 {
05443     <span class="keyword">struct </span>tree    *tp = find_best_tree_node(name, tree_head, NULL);
05444     <span class="keywordflow">if</span> (!tp)
05445         <span class="keywordflow">return</span> 0;
05446     <span class="keywordflow">return</span> get_node(tp-&gt;label, objid, objidlen);
05447 }
05448 
05449 <span class="keywordtype">int</span>
05450 get_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, oid * objid, size_t * objidlen)
05451 {
05452     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp;
05453     <span class="keywordtype">char</span>            ch;
05454     <span class="keywordtype">int</span>             res;
05455 
05456     cp = name;
05457     <span class="keywordflow">while</span> ((ch = *cp))
05458         <span class="keywordflow">if</span> ((<span class=
"charliteral">'0'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'9'</span>)
05459             || (<span class="charliteral">'a'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'z'</span>)
05460             || (<span class="charliteral">'A'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'Z'</span>)
05461             || ch == <span class="charliteral">'-'</span>)
05462             cp++;
05463         <span class="keywordflow">else</span>
05464             <span class="keywordflow">break</span>;
05465     <span class="keywordflow">if</span> (ch != <span class="charliteral">':'</span>)
05466         <span class="keywordflow">if</span> (*name == <span class="charliteral">'.'</span>)
05467             res = get_module_node(name + 1, <span class="stringliteral">"ANY"</span>, objid, objidlen);
05468         <span class="keywordflow">else</span>
05469             res = get_module_node(name, <span class="stringliteral">"ANY"</span>, objid, objidlen);
05470     <span class="keywordflow">else</span> {
05471         <span class="keywordtype">char</span>           *module;
05472         <span class="comment">/*</span>
05473 <span class="comment">         *  requested name is of the form</span>
05474 <span class="comment">         *      "module:subidentifier"</span>
05475 <span class="comment">         */</span>
05476         module = (<span class="keywordtype">char</span> *) malloc((size_t) (cp - name + 1));
05477         <span class="keywordflow">if</span> (!module)
05478             <span class="keywordflow">return</span> SNMPERR_GENERR;
05479         memcpy(module, name, (size_t) (cp - name));
05480         module[cp - name] = 0;
05481         cp++;                   <span class="comment">/* cp now point to the subidentifier */</span>
05482         <span class="keywordflow">if</span> (*cp == <span class="charliteral">':'</span>)
05483             cp++;
05484 
05485         <span class="comment">/*</span>
05486 <span class="comment">         * 'cp' and 'name' *do* go that way round! </span>
05487 <span class="comment">         */</span>
05488         res = get_module_node(cp, module, objid, objidlen);
05489         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(module);
05490     }
05491     <span class="keywordflow">if</span> (res == 0) {
05492         SET_SNMP_ERROR(SNMPERR_UNKNOWN_OBJID);
05493     }
05494 
05495     <span class="keywordflow">return</span> res;
05496 }
05497 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05498 
05499 <span class="preprocessor">#ifdef testing</span>
05500 
05501 main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
05502 {
05503     oid             objid[MAX_OID_LEN];
05504     <span class="keywordtype">int</span>             objidlen = MAX_OID_LEN;
05505     <span class="keywordtype">int</span>             count;
05506     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> variable;
05507 
05508     <a class="code" href="group__mib__utilities.html#ga57">init_mib</a>();
05509     <span class="keywordflow">if</span> (argc &lt; 2)
05510         print_subtree(stdout, tree_head, 0);
05511     variable.<a class="code" href="structvariable__list.html#o3">type</a> = ASN_INTEGER;
05512     variable.<a class="code" href="structvariable__list.html#o4">val</a>.integer = 3;
05513     variable.<a class="code" href="structvariable__list.html#o5">val_len</a> = 4;
05514     <span class="keywordflow">for</span> (argc--; argc; argc--, argv++) {
05515         objidlen = MAX_OID_LEN;
05516         printf(<span class="stringliteral">"read_objid(%s) = %d\n"</span>,
05517                argv[1], <a class="code" href=
"group__mib__utilities.html#ga62">read_objid</a>(argv[1], objid, &amp;objidlen));
05518         <span class="keywordflow">for</span> (count = 0; count &lt; objidlen; count++)
05519             printf(<span class="stringliteral">"%d."</span>, objid[count]);
05520         printf(<span class="stringliteral">"\n"</span>);
05521         <a class="code" href="group__mib__utilities.html#ga71">print_variable</a>(objid, objidlen, &amp;variable);
05522     }
05523 }
05524 
05525 <span class="preprocessor">#endif                          </span><span class="comment">/* testing */</span>
05526 
05527 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05528 <span class="comment">/*</span>
05529 <span class="comment"> * initialize: no peers included in the report. </span>
05530 <span class="comment"> */</span>
05531 <span class="keywordtype">void</span>
05532 clear_tree_flags(<span class="keyword">register</span> <span class="keyword">struct</span> tree *tp)
05533 {
05534     <span class="keywordflow">for</span> (; tp; tp = tp-&gt;next_peer) {
05535         tp-&gt;reported = 0;
05536         <span class="keywordflow">if</span> (tp-&gt;child_list)
05537             clear_tree_flags(tp-&gt;child_list);
05538      <span class="comment">/*RECURSE*/</span>}
05539 }
05540 
05541 <span class="comment">/*</span>
05542 <span class="comment"> * Update: 1998-07-17 &lt;jhy@gsu.edu&gt;</span>
05543 <span class="comment"> * Added print_oid_report* functions.</span>
05544 <span class="comment"> */</span>
05545 <span class="keyword">static</span> <span class="keywordtype">int</span>      print_subtree_oid_report_labeledoid = 0;
05546 <span class="keyword">static</span> <span class="keywordtype">int</span>      print_subtree_oid_report_oid = 0;
05547 <span class="keyword">static</span> <span class="keywordtype">int</span>      print_subtree_oid_report_symbolic = 0;
05548 <span class="keyword">static</span> <span class="keywordtype">int</span>      print_subtree_oid_report_mibchildoid = 0;
05549 <span class="keyword">static</span> <span class="keywordtype">int</span>      print_subtree_oid_report_suffix = 0;
05550 
05551 <span class="comment">/*</span>
05552 <span class="comment"> * These methods recurse. </span>
05553 <span class="comment"> */</span>
05554 <span class="keyword">static</span> <span class="keywordtype">void</span>     print_parent_labeledoid(FILE *, <span class=
"keyword">struct</span> tree *);
05555 <span class="keyword">static</span> <span class="keywordtype">void</span>     print_parent_oid(FILE *, <span class=
"keyword">struct</span> tree *);
05556 <span class="keyword">static</span> <span class="keywordtype">void</span>     print_parent_mibchildoid(FILE *, <span class=
"keyword">struct</span> tree *);
05557 <span class="keyword">static</span> <span class="keywordtype">void</span>     print_parent_label(FILE *, <span class=
"keyword">struct</span> tree *);
05558 <span class="keyword">static</span> <span class="keywordtype">void</span>     print_subtree_oid_report(FILE *, <span class=
"keyword">struct</span> tree *, <span class="keywordtype">int</span>);
05559 
05560 
05561 <span class="keywordtype">void</span>
05562 print_oid_report(FILE * fp)
05563 {
05564     <span class="keyword">struct </span>tree    *tp;
05565     clear_tree_flags(tree_head);
05566     <span class="keywordflow">for</span> (tp = tree_head; tp; tp = tp-&gt;next_peer)
05567         print_subtree_oid_report(fp, tp, 0);
05568 }
05569 
05570 <span class="keywordtype">void</span>
05571 print_oid_report_enable_labeledoid(<span class="keywordtype">void</span>)
05572 {
05573     print_subtree_oid_report_labeledoid = 1;
05574 }
05575 
05576 <span class="keywordtype">void</span>
05577 print_oid_report_enable_oid(<span class="keywordtype">void</span>)
05578 {
05579     print_subtree_oid_report_oid = 1;
05580 }
05581 
05582 <span class="keywordtype">void</span>
05583 print_oid_report_enable_suffix(<span class="keywordtype">void</span>)
05584 {
05585     print_subtree_oid_report_suffix = 1;
05586 }
05587 
05588 <span class="keywordtype">void</span>
05589 print_oid_report_enable_symbolic(<span class="keywordtype">void</span>)
05590 {
05591     print_subtree_oid_report_symbolic = 1;
05592 }
05593 
05594 <span class="keywordtype">void</span>
05595 print_oid_report_enable_mibchildoid(<span class="keywordtype">void</span>)
05596 {
05597     print_subtree_oid_report_mibchildoid = 1;
05598 }
05599 
05600 <span class="comment">/*</span>
05601 <span class="comment"> * helper methods for print_subtree_oid_report()</span>
05602 <span class="comment"> * each one traverses back up the node tree</span>
05603 <span class="comment"> * until there is no parent.  Then, the label combination</span>
05604 <span class="comment"> * is output, such that the parent is displayed first.</span>
05605 <span class="comment"> *</span>
05606 <span class="comment"> * Warning: these methods are all recursive.</span>
05607 <span class="comment"> */</span>
05608 
05609 <span class="keyword">static</span> <span class="keywordtype">void</span>
05610 print_parent_labeledoid(FILE * f, <span class="keyword">struct</span> tree *tp)
05611 {
05612     <span class="keywordflow">if</span> (tp) {
05613         <span class="keywordflow">if</span> (tp-&gt;parent) {
05614             print_parent_labeledoid(f, tp-&gt;parent);
05615          <span class="comment">/*RECURSE*/</span>}
05616         fprintf(f, <span class="stringliteral">".%s(%lu)"</span>, tp-&gt;label, tp-&gt;subid);
05617     }
05618 }
05619 
05620 <span class="keyword">static</span> <span class="keywordtype">void</span>
05621 print_parent_oid(FILE * f, <span class="keyword">struct</span> tree *tp)
05622 {
05623     <span class="keywordflow">if</span> (tp) {
05624         <span class="keywordflow">if</span> (tp-&gt;parent) {
05625             print_parent_oid(f, tp-&gt;parent);
05626          <span class="comment">/*RECURSE*/</span>}
05627         fprintf(f, <span class="stringliteral">".%lu"</span>, tp-&gt;subid);
05628     }
05629 }
05630 
05631 
05632 <span class="keyword">static</span> <span class="keywordtype">void</span> print_parent_mibchildoid(FILE * f, <span class=
"keyword">struct</span> tree *tp)
05633 {
05634     <span class="keyword">static</span> <span class="keyword">struct </span>tree *temp;
05635     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> elems[100];
05636     <span class="keywordtype">int</span> elem_cnt = 0;
05637     <span class="keywordtype">int</span> i = 0;
05638     temp = tp;
05639     <span class="keywordflow">if</span> (temp) {
05640         <span class="keywordflow">while</span> (temp-&gt;parent) {
05641                 elems[elem_cnt++] = temp-&gt;subid;
05642                 temp = temp-&gt;parent;
05643         }
05644         elems[elem_cnt++] = temp-&gt;subid;
05645     }
05646     <span class="keywordflow">for</span> (i = elem_cnt - 1; i &gt;= 0; i--) {
05647         <span class="keywordflow">if</span> (i == elem_cnt - 1) {
05648             fprintf(f, <span class="stringliteral">"%lu"</span>, elems[i]);           
05649             } <span class="keywordflow">else</span> {
05650             fprintf(f, <span class="stringliteral">".%lu"</span>, elems[i]);          
05651         }
05652     }
05653 }
05654 
05655 <span class="keyword">static</span> <span class="keywordtype">void</span>
05656 print_parent_label(FILE * f, <span class="keyword">struct</span> tree *tp)
05657 {
05658     <span class="keywordflow">if</span> (tp) {
05659         <span class="keywordflow">if</span> (tp-&gt;parent) {
05660             print_parent_label(f, tp-&gt;parent);
05661          <span class="comment">/*RECURSE*/</span>}
05662         fprintf(f, <span class="stringliteral">".%s"</span>, tp-&gt;label);
05663     }
05664 }
05665 
05677 <span class="keyword">static</span> <span class="keywordtype">void</span>
05678 print_subtree_oid_report(FILE * f, <span class="keyword">struct</span> tree *tree, <span class=
"keywordtype">int</span> count)
05679 {
05680     <span class="keyword">struct </span>tree    *tp;
05681 
05682     count++;
05683 
05684     <span class="comment">/*</span>
05685 <span class="comment">     * sanity check </span>
05686 <span class="comment">     */</span>
05687     <span class="keywordflow">if</span> (!tree) {
05688         <span class="keywordflow">return</span>;
05689     }
05690 
05691     <span class="comment">/*</span>
05692 <span class="comment">     * find the not reported peer with the lowest sub-identifier.</span>
05693 <span class="comment">     * if no more, break the loop and cleanup.</span>
05694 <span class="comment">     * set "reported" flag, and create report for this peer.</span>
05695 <span class="comment">     * recurse using the children of this peer, if any.</span>
05696 <span class="comment">     */</span>
05697     <span class="keywordflow">while</span> (1) {
05698         <span class="keyword">register</span> <span class="keyword">struct </span>tree *ntp;
05699 
05700         tp = 0;
05701         <span class="keywordflow">for</span> (ntp = tree-&gt;child_list; ntp; ntp = ntp-&gt;next_peer) {
05702             <span class="keywordflow">if</span> (ntp-&gt;reported)
05703                 <span class="keywordflow">continue</span>;
05704 
05705             <span class="keywordflow">if</span> (!tp || (tp-&gt;subid &gt; ntp-&gt;subid))
05706                 tp = ntp;
05707         }
05708         <span class="keywordflow">if</span> (!tp)
05709             <span class="keywordflow">break</span>;
05710 
05711         tp-&gt;reported = 1;
05712 
05713         <span class="keywordflow">if</span> (print_subtree_oid_report_labeledoid) {
05714             print_parent_labeledoid(f, tp);
05715             fprintf(f, <span class="stringliteral">"\n"</span>);
05716         }
05717         <span class="keywordflow">if</span> (print_subtree_oid_report_oid) {
05718             print_parent_oid(f, tp);
05719             fprintf(f, <span class="stringliteral">"\n"</span>);
05720         }
05721         <span class="keywordflow">if</span> (print_subtree_oid_report_symbolic) {
05722             print_parent_label(f, tp);
05723             fprintf(f, <span class="stringliteral">"\n"</span>);
05724         }
05725         <span class="keywordflow">if</span> (print_subtree_oid_report_mibchildoid) {
05726             fprintf(f, <span class="stringliteral">"\"%s\"\t"</span>, tp-&gt;label);
05727             fprintf(f, <span class="stringliteral">"\t\t\""</span>);
05728             print_parent_mibchildoid(f, tp);
05729             fprintf(f, <span class="stringliteral">"\"\n"</span>);
05730         }
05731         <span class="keywordflow">if</span> (print_subtree_oid_report_suffix) {
05732             <span class="keywordtype">int</span>             i;
05733             <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
05734                 fprintf(f, <span class="stringliteral">"  "</span>);
05735             fprintf(f, <span class="stringliteral">"%s(%ld) type=%d"</span>, tp-&gt;label, tp-&gt;subid, tp-&gt;type);
05736             <span class="keywordflow">if</span> (tp-&gt;tc_index != -1)
05737                 fprintf(f, <span class="stringliteral">" tc=%d"</span>, tp-&gt;tc_index);
05738             <span class="keywordflow">if</span> (tp-&gt;hint)
05739                 fprintf(f, <span class="stringliteral">" hint=%s"</span>, tp-&gt;hint);
05740             <span class="keywordflow">if</span> (tp-&gt;units)
05741                 fprintf(f, <span class="stringliteral">" units=%s"</span>, tp-&gt;units);
05742 
05743             fprintf(f, <span class="stringliteral">"\n"</span>);
05744         }
05745         print_subtree_oid_report(f, tp, count);
05746      <span class="comment">/*RECURSE*/</span>}
05747 }
05748 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05749 
05750 
05763 <span class="keywordtype">char</span>           *
<a name="l05764" id="l05764"></a><a class="code" href="group__mib__utilities.html#ga105">05764</a> <a class="code" href=
"group__mib__utilities.html#ga105">uptime_string</a>(u_long timeticks, <span class="keywordtype">char</span> *buf)
05765 {
05766     <span class="keywordflow">return</span> uptime_string_n( timeticks, buf, 40);
05767 }
05768 
05769 <span class="keywordtype">char</span>           *
05770 uptime_string_n(u_long timeticks, <span class="keywordtype">char</span> *buf, size_t buflen)
05771 {
05772     uptimeString(timeticks, buf, buflen);
05773 <span class="preprocessor">#ifdef CMU_COMPATIBLE</span>
05774     {
05775     <span class="keywordtype">char</span> *cp = strrchr(buf, <span class="charliteral">'.'</span>);
05776     <span class="keywordflow">if</span> (cp)
05777         *cp = <span class="charliteral">'\0'</span>;
05778     }
05779 <span class="preprocessor">#endif</span>
05780     <span class="keywordflow">return</span> buf;
05781 }
05782 
05798 oid            *
<a name="l05799" id="l05799"></a><a class="code" href="group__mib__utilities.html#ga107">05799</a> <a class="code" href=
"group__mib__utilities.html#ga107">snmp_parse_oid</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *argv, oid * root, size_t * rootlen)
05800 {
05801     size_t          savlen = *rootlen;
05802     <span class="keyword">static</span> size_t   tmpbuf_len = 0;
05803     <span class="keyword">static</span> <span class="keywordtype">char</span>    *tmpbuf;
05804     <span class="keyword">const</span> <span class="keywordtype">char</span>     *suffix, *prefix;
05805 
05806     suffix = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
05807                                    NETSNMP_DS_LIB_OIDSUFFIX);
05808     prefix = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
05809                                    NETSNMP_DS_LIB_OIDPREFIX);
05810     <span class="keywordflow">if</span> ((suffix &amp;&amp; suffix[0]) || (prefix &amp;&amp; prefix[0])) {
05811         <span class="keywordflow">if</span> (!suffix)
05812             suffix = <span class="stringliteral">""</span>;
05813         <span class="keywordflow">if</span> (!prefix)
05814             prefix = <span class="stringliteral">""</span>;
05815         <span class="keywordflow">if</span> ((strlen(suffix) + strlen(prefix) + strlen(argv) + 2) &gt; tmpbuf_len) {
05816             tmpbuf_len = strlen(suffix) + strlen(argv) + strlen(prefix) + 2;
05817             tmpbuf = realloc(tmpbuf, tmpbuf_len);
05818         }
05819         snprintf(tmpbuf, tmpbuf_len, <span class="stringliteral">"%s%s%s%s"</span>, prefix, argv,
05820                  ((suffix[0] == <span class="charliteral">'.'</span> || suffix[0] == <span class=
"charliteral">'\0'</span>) ? <span class="stringliteral">""</span> : <span class="stringliteral">"."</span>),
05821                  suffix);
05822         argv = tmpbuf;
05823         DEBUGMSGTL((<span class="stringliteral">"snmp_parse_oid"</span>,<span class=
"stringliteral">"Parsing: %s\n"</span>,argv));
05824     }
05825 
05826 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05827     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_RANDOM_ACCESS)
05828         || strchr(argv, <span class="charliteral">':'</span>)) {
05829         <span class="keywordflow">if</span> (get_node(argv, root, rootlen)) {
05830             <span class="keywordflow">return</span> root;
05831         }
05832     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REGEX_ACCESS)) {
05833         clear_tree_flags(tree_head);
05834         <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga91">get_wild_node</a>(argv, root, rootlen)) {
05835             <span class="keywordflow">return</span> root;
05836         }
05837     } <span class="keywordflow">else</span> {
05838 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05839         <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga62">read_objid</a>(argv, root, rootlen)) {
05840             <span class="keywordflow">return</span> root;
05841         }
05842 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05843         *rootlen = savlen;
05844         <span class="keywordflow">if</span> (get_node(argv, root, rootlen)) {
05845             <span class="keywordflow">return</span> root;
05846         }
05847         *rootlen = savlen;
05848         DEBUGMSGTL((<span class="stringliteral">"parse_oid"</span>, <span class=
"stringliteral">"wildly parsing\n"</span>));
05849         clear_tree_flags(tree_head);
05850         <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga91">get_wild_node</a>(argv, root, rootlen)) {
05851             <span class="keywordflow">return</span> root;
05852         }
05853     }
05854 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
05855     <span class="keywordflow">return</span> NULL;
05856 }
05857 
05858 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
05859 <span class="comment">/*</span>
05860 <span class="comment"> * Use DISPLAY-HINT to parse a value into an octet string.</span>
05861 <span class="comment"> *</span>
05862 <span class="comment"> * note that "1d1d", "11" could have come from an octet string that</span>
05863 <span class="comment"> * looked like { 1, 1 } or an octet string that looked like { 11 }</span>
05864 <span class="comment"> * because of this, it's doubtful that anyone would use such a display</span>
05865 <span class="comment"> * string. Therefore, the parser ignores this case.</span>
05866 <span class="comment"> */</span>
05867 
05868 <span class="keyword">struct </span>parse_hints {
05869     <span class="keywordtype">int</span> length;
05870     <span class="keywordtype">int</span> repeat;
05871     <span class="keywordtype">int</span> format;
05872     <span class="keywordtype">int</span> separator;
05873     <span class="keywordtype">int</span> terminator;
05874     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *result;
05875     <span class="keywordtype">int</span> result_max;
05876     <span class="keywordtype">int</span> result_len;
05877 };
05878 
05879 <span class="keyword">static</span> <span class="keywordtype">void</span> parse_hints_reset(<span class=
"keyword">struct</span> parse_hints *ph)
05880 {
05881     ph-&gt;length = 0;
05882     ph-&gt;repeat = 0;
05883     ph-&gt;format = 0;
05884     ph-&gt;separator = 0;
05885     ph-&gt;terminator = 0;
05886 }
05887 
05888 <span class="keyword">static</span> <span class="keywordtype">void</span> parse_hints_ctor(<span class=
"keyword">struct</span> parse_hints *ph)
05889 {
05890     parse_hints_reset(ph);
05891     ph-&gt;result = NULL;
05892     ph-&gt;result_max = 0;
05893     ph-&gt;result_len = 0;
05894 }
05895 
05896 <span class="keyword">static</span> <span class="keywordtype">int</span> parse_hints_add_result_octet(<span class=
"keyword">struct</span> parse_hints *ph, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> octet)
05897 {
05898     <span class="keywordflow">if</span> (!(ph-&gt;result_len &lt; ph-&gt;result_max)) {
05899         ph-&gt;result_max = ph-&gt;result_len + 32;
05900         <span class="keywordflow">if</span> (!ph-&gt;result) {
05901             ph-&gt;result = (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">char</span> *)malloc(ph-&gt;result_max);
05902         } <span class="keywordflow">else</span> {
05903             ph-&gt;result = (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">char</span> *)realloc(ph-&gt;result, ph-&gt;result_max);
05904         }
05905     }
05906     
05907     <span class="keywordflow">if</span> (!ph-&gt;result) {
05908         <span class="keywordflow">return</span> 0;               <span class="comment">/* failed */</span>
05909     }
05910 
05911     ph-&gt;result[ph-&gt;result_len++] = octet;
05912     <span class="keywordflow">return</span> 1;                   <span class="comment">/* success */</span>
05913 }
05914 
05915 <span class="keyword">static</span> <span class="keywordtype">int</span> parse_hints_parse(<span class=
"keyword">struct</span> parse_hints *ph, <span class="keyword">const</span> <span class="keywordtype">char</span> **v_in_out)
05916 {
05917     <span class="keyword">const</span> <span class="keywordtype">char</span> *v = *v_in_out;
05918     <span class="keywordtype">char</span> *nv;
05919     <span class="keywordtype">int</span> base;
05920     <span class="keywordtype">int</span> repeats = 0;
05921     <span class="keywordtype">int</span> repeat_fixup = ph-&gt;result_len;
05922     
05923     <span class="keywordflow">if</span> (ph-&gt;repeat) {
05924         <span class="keywordflow">if</span> (!parse_hints_add_result_octet(ph, 0)) {
05925             <span class="keywordflow">return</span> 0;
05926         }
05927     }
05928     <span class="keywordflow">do</span> {
05929         base = 0;
05930         <span class="keywordflow">switch</span> (ph-&gt;format) {
05931         <span class="keywordflow">case</span> <span class="charliteral">'x'</span>: base += 6;    <span class=
"comment">/* fall through */</span>
05932         <span class="keywordflow">case</span> <span class="charliteral">'d'</span>: base += 2;    <span class=
"comment">/* fall through */</span>
05933         <span class="keywordflow">case</span> <span class="charliteral">'o'</span>: base += 8;    <span class=
"comment">/* fall through */</span>
05934             {
05935                 <span class="keywordtype">int</span> i;
05936                 <span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span> number = strtol(v, &amp;nv, base);
05937                 <span class="keywordflow">if</span> (nv == v) <span class="keywordflow">return</span> 0;
05938                 v = nv;
05939                 <span class="keywordflow">for</span> (i = 0; i &lt; ph-&gt;length; i++) {
05940                     <span class="keywordtype">int</span> shift = 8 * (ph-&gt;length - 1 - i);
05941                     <span class=
"keywordflow">if</span> (!parse_hints_add_result_octet(ph, (u_char)(number &gt;&gt; shift) )) {
05942                         <span class="keywordflow">return</span> 0; <span class="comment">/* failed */</span>
05943                     }
05944                 }
05945             }
05946             <span class="keywordflow">break</span>;
05947 
05948         <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
05949             {
05950                 <span class="keywordtype">int</span> i;
05951                     
05952                 <span class="keywordflow">for</span> (i = 0; i &lt; ph-&gt;length &amp;&amp; *v; i++) {
05953                     <span class="keywordflow">if</span> (!parse_hints_add_result_octet(ph, *v++)) {
05954                         <span class="keywordflow">return</span> 0;       <span class="comment">/* failed */</span>
05955                     }
05956                 }
05957             }
05958             <span class="keywordflow">break</span>;
05959         }
05960 
05961         repeats++;
05962 
05963         <span class="keywordflow">if</span> (ph-&gt;separator &amp;&amp; *v) {
05964             <span class="keywordflow">if</span> (*v == ph-&gt;separator) {
05965                 v++;
05966             } <span class="keywordflow">else</span> {
05967                 <span class="keywordflow">return</span> 0;               <span class="comment">/* failed */</span>
05968             }
05969         }
05970 
05971         <span class="keywordflow">if</span> (ph-&gt;terminator) {
05972             <span class="keywordflow">if</span> (*v == ph-&gt;terminator) {
05973                 v++;
05974                 <span class="keywordflow">break</span>;
05975             }
05976         }
05977     } <span class="keywordflow">while</span> (ph-&gt;repeat &amp;&amp; *v);
05978     <span class="keywordflow">if</span> (ph-&gt;repeat) {
05979         ph-&gt;result[repeat_fixup] = repeats;
05980     }
05981 
05982     *v_in_out = v;
05983     <span class="keywordflow">return</span> 1;
05984 }
05985 
05986 <span class="keyword">static</span> <span class="keywordtype">void</span> parse_hints_length_add_digit(<span class=
"keyword">struct</span> parse_hints *ph, <span class="keywordtype">int</span> digit)
05987 {
05988     ph-&gt;length *= 10;
05989     ph-&gt;length += digit - <span class="charliteral">'0'</span>;
05990 }
05991 
05992 <span class="keyword">const</span> <span class="keywordtype">char</span> *parse_octet_hint(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *hint, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *value, <span class="keywordtype">unsigned</span> <span class=
"keywordtype">char</span> **new_val, <span class="keywordtype">int</span> *new_val_len)
05993 {
05994     <span class="keyword">const</span> <span class="keywordtype">char</span> *h = hint;
05995     <span class="keyword">const</span> <span class="keywordtype">char</span> *v = value;
05996     <span class="keyword">struct </span>parse_hints ph;
05997     <span class="keywordtype">int</span> retval = 1;
05998     <span class="comment">/* See RFC 1443 */</span>
05999     <span class="keyword">enum</span> {
06000         HINT_1_2,
06001         HINT_2_3,
06002         HINT_1_2_4,
06003         HINT_1_2_5
06004     } state = HINT_1_2;
06005 
06006     parse_hints_ctor(&amp;ph);
06007     <span class="keywordflow">while</span> (*h &amp;&amp; *v &amp;&amp; retval) {
06008         <span class="keywordflow">switch</span> (state) {
06009         <span class="keywordflow">case</span> HINT_1_2:
06010             <span class="keywordflow">if</span> (<span class="charliteral">'*'</span> == *h) {
06011                 ph.repeat = 1;
06012                 state = HINT_2_3;
06013             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isdigit(*h)) {
06014                 parse_hints_length_add_digit(&amp;ph, *h);
06015                 state = HINT_2_3;
06016             } <span class="keywordflow">else</span> {
06017                 <span class="keywordflow">return</span> v;       <span class="comment">/* failed */</span>
06018             }
06019             <span class="keywordflow">break</span>;
06020 
06021         <span class="keywordflow">case</span> HINT_2_3:
06022             <span class="keywordflow">if</span> (isdigit(*h)) {
06023                 parse_hints_length_add_digit(&amp;ph, *h);
06024                 <span class="comment">/* state = HINT_2_3 */</span>
06025             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class=
"charliteral">'x'</span> == *h || <span class="charliteral">'d'</span> == *h || <span class=
"charliteral">'o'</span> == *h || <span class="charliteral">'a'</span> == *h) {
06026                 ph.format = *h;
06027                 state = HINT_1_2_4;
06028             } <span class="keywordflow">else</span> {
06029                 <span class="keywordflow">return</span> v;       <span class="comment">/* failed */</span>
06030             }
06031             <span class="keywordflow">break</span>;
06032 
06033         <span class="keywordflow">case</span> HINT_1_2_4:
06034             <span class="keywordflow">if</span> (<span class="charliteral">'*'</span> == *h) {
06035                 retval = parse_hints_parse(&amp;ph, &amp;v);
06036                 parse_hints_reset(&amp;ph);
06037                 
06038                 ph.repeat = 1;
06039                 state = HINT_2_3;
06040             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isdigit(*h)) {
06041                 retval = parse_hints_parse(&amp;ph, &amp;v);
06042                 parse_hints_reset(&amp;ph);
06043                 
06044                 parse_hints_length_add_digit(&amp;ph, *h);
06045                 state = HINT_2_3;
06046             } <span class="keywordflow">else</span> {
06047                 ph.separator = *h;
06048                 state = HINT_1_2_5;
06049             }
06050             <span class="keywordflow">break</span>;
06051 
06052         <span class="keywordflow">case</span> HINT_1_2_5:
06053             <span class="keywordflow">if</span> (<span class="charliteral">'*'</span> == *h) {
06054                 retval = parse_hints_parse(&amp;ph, &amp;v);
06055                 parse_hints_reset(&amp;ph);
06056                 
06057                 ph.repeat = 1;
06058                 state = HINT_2_3;
06059             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isdigit(*h)) {
06060                 retval = parse_hints_parse(&amp;ph, &amp;v);
06061                 parse_hints_reset(&amp;ph);
06062                 
06063                 parse_hints_length_add_digit(&amp;ph, *h);
06064                 state = HINT_2_3;
06065             } <span class="keywordflow">else</span> {
06066                 ph.terminator = *h;
06067 
06068                 retval = parse_hints_parse(&amp;ph, &amp;v);
06069                 parse_hints_reset(&amp;ph);
06070 
06071                 state = HINT_1_2;
06072             }
06073             <span class="keywordflow">break</span>;
06074         }
06075         h++;
06076     }
06077     <span class="keywordflow">while</span> (*v &amp;&amp; retval) {
06078         retval = parse_hints_parse(&amp;ph, &amp;v);
06079     }
06080     <span class="keywordflow">if</span> (retval) {
06081         *new_val = ph.result;
06082         *new_val_len = ph.result_len;
06083     } <span class="keywordflow">else</span> {
06084         <span class="keywordflow">if</span> (ph.result) {
06085             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ph.result);
06086         }
06087         *new_val = NULL;
06088         *new_val_len = 0;
06089     }
06090     <span class="keywordflow">return</span> retval ? NULL : v;
06091 }
06092 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
06093 
06094 <span class="preprocessor">#ifdef test_display_hint</span>
06095 
06096 <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class=
"keyword">const</span> <span class="keywordtype">char</span> **argv)
06097 {
06098     <span class="keyword">const</span> <span class="keywordtype">char</span> *hint;
06099     <span class="keyword">const</span> <span class="keywordtype">char</span> *value;
06100     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *new_val;
06101     <span class="keywordtype">int</span> new_val_len;
06102     <span class="keywordtype">char</span> *r;
06103     
06104     <span class="keywordflow">if</span> (argc &lt; 3) {
06105         fprintf(stderr, <span class="stringliteral">"usage: dh &lt;hint&gt; &lt;value&gt;\n"</span>);
06106         exit(2);
06107     }
06108     hint = argv[1];
06109     value = argv[2];
06110     r = parse_octet_hint(hint, value, &amp;new_val, &amp;new_val_len);
06111     printf(<span class="stringliteral">"{\"%s\", \"%s\"}: \n\t"</span>, hint, value);
06112     <span class="keywordflow">if</span> (r) {
06113         *r = 0;
06114         printf(<span class="stringliteral">"returned failed\n"</span>);
06115         printf(<span class="stringliteral">"value syntax error at: %s\n"</span>, value);
06116     }
06117     <span class="keywordflow">else</span> {
06118         <span class="keywordtype">int</span> i;
06119         printf(<span class="stringliteral">"returned success\n"</span>);
06120         <span class="keywordflow">for</span> (i = 0; i &lt; new_val_len; i++) {
06121             <span class="keywordtype">int</span> c = new_val[i] &amp; 0xFF;
06122             printf(<span class="stringliteral">"%02X(%c) "</span>, c, isprint(c) ? c : <span class=
"charliteral">' '</span>);
06123         }
06124         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(new_val);
06125     }
06126     printf(<span class="stringliteral">"\n"</span>);
06127     exit(0);
06128 }
06129 
06130 <span class="preprocessor">#endif </span><span class="comment">/* test_display_hint */</span>
06131 
06132 u_char
06133 mib_to_asn_type(<span class="keywordtype">int</span> mib_type)
06134 {
06135     <span class="keywordflow">switch</span> (mib_type) {
06136     <span class="keywordflow">case</span> TYPE_OBJID:
06137         <span class="keywordflow">return</span> ASN_OBJECT_ID;
06138 
06139     <span class="keywordflow">case</span> TYPE_OCTETSTR:
06140         <span class="keywordflow">return</span> ASN_OCTET_STR;
06141 
06142     <span class="keywordflow">case</span> TYPE_NETADDR:
06143     <span class="keywordflow">case</span> TYPE_IPADDR:
06144         <span class="keywordflow">return</span> ASN_IPADDRESS;
06145 
06146     <span class="keywordflow">case</span> TYPE_INTEGER32:
06147     <span class="keywordflow">case</span> TYPE_INTEGER:
06148         <span class="keywordflow">return</span> ASN_INTEGER;
06149 
06150     <span class="keywordflow">case</span> TYPE_COUNTER:
06151         <span class="keywordflow">return</span> ASN_COUNTER;
06152 
06153     <span class="keywordflow">case</span> TYPE_GAUGE:
06154         <span class="keywordflow">return</span> ASN_GAUGE;
06155 
06156     <span class="keywordflow">case</span> TYPE_TIMETICKS:
06157         <span class="keywordflow">return</span> ASN_TIMETICKS;
06158 
06159     <span class="keywordflow">case</span> TYPE_OPAQUE:
06160         <span class="keywordflow">return</span> ASN_OPAQUE;
06161 
06162     <span class="keywordflow">case</span> TYPE_NULL:
06163         <span class="keywordflow">return</span> ASN_NULL;
06164 
06165     <span class="keywordflow">case</span> TYPE_COUNTER64:
06166         <span class="keywordflow">return</span> ASN_COUNTER64;
06167 
06168     <span class="keywordflow">case</span> TYPE_BITSTRING:
06169         <span class="keywordflow">return</span> ASN_BIT_STR;
06170 
06171     <span class="keywordflow">case</span> TYPE_UINTEGER:
06172     <span class="keywordflow">case</span> TYPE_UNSIGNED32:
06173         <span class="keywordflow">return</span> ASN_UNSIGNED;
06174 
06175     <span class="keywordflow">case</span> TYPE_NSAPADDRESS:
06176         <span class="keywordflow">return</span> ASN_NSAP;
06177 
06178     }
06179     <span class="keywordflow">return</span> -1;
06180 }
06181 
06192 <span class="keywordtype">int</span>
<a name="l06193" id="l06193"></a><a class="code" href="group__mib__utilities.html#ga115">06193</a> <a class="code" href=
"group__mib__utilities.html#ga115">netsnmp_str2oid</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *S, oid * O, <span class="keywordtype">int</span> L)
06194 {
06195     <span class="keyword">const</span> <span class="keywordtype">char</span>     *c = S;
06196     oid            *o = &amp;O[1];
06197 
06198     --L;                        <span class="comment">/* leave room for length prefix */</span>
06199 
06200     <span class="keywordflow">for</span> (; *c &amp;&amp; L; --L, ++o, ++c)
06201         *o = *c;
06202 
06203     <span class="comment">/*</span>
06204 <span class="comment">     * make sure we got to the end of the string </span>
06205 <span class="comment">     */</span>
06206     <span class="keywordflow">if</span> (*c != 0)
06207         <span class="keywordflow">return</span> 1;
06208 
06209     <span class="comment">/*</span>
06210 <span class="comment">     * set the length of the oid </span>
06211 <span class="comment">     */</span>
06212     *O = c - S;
06213 
06214     <span class="keywordflow">return</span> 0;
06215 }
06216 
06227 <span class="keywordtype">int</span>
<a name="l06228" id="l06228"></a><a class="code" href="group__mib__utilities.html#ga116">06228</a> <a class="code" href=
"group__mib__utilities.html#ga116">netsnmp_oid2chars</a>(<span class="keywordtype">char</span> *C, <span class=
"keywordtype">int</span> L, <span class="keyword">const</span> oid * O)
06229 {
06230     <span class="keywordtype">char</span>           *c = C;
06231     <span class="keyword">const</span> oid      *o = &amp;O[1];
06232 
06233     <span class="keywordflow">if</span> (L &lt; (int)*O)
06234         <span class="keywordflow">return</span> 1;
06235 
06236     L = *O; 
06237     <span class="keywordflow">for</span> (; L; --L, ++o, ++c) {
06238         <span class="keywordflow">if</span> (*o &gt; 0xFF)
06239             <span class="keywordflow">return</span> 1;
06240         *c = (char)*o;
06241     }
06242     <span class="keywordflow">return</span> 0;
06243 }
06244 
06255 <span class="keywordtype">int</span>
<a name="l06256" id="l06256"></a><a class="code" href="group__mib__utilities.html#ga117">06256</a> <a class="code" href=
"group__mib__utilities.html#ga117">netsnmp_oid2str</a>(<span class="keywordtype">char</span> *S, <span class=
"keywordtype">int</span> L, oid * O)
06257 {
06258     <span class="keywordtype">int</span>            rc;
06259 
06260     <span class="keywordflow">if</span> (L &lt;= (int)*O)
06261         <span class="keywordflow">return</span> 1;
06262 
06263     rc = <a class="code" href="group__mib__utilities.html#ga116">netsnmp_oid2chars</a>(S, L, O);
06264     <span class="keywordflow">if</span> (rc)
06265         <span class="keywordflow">return</span> 1;
06266 
06267     S[ *O ] = 0;
06268 
06269     <span class="keywordflow">return</span> 0;
06270 }
06271 
06272 <span class="keywordtype">int</span>
06273 snprint_by_type(<span class="keywordtype">char</span> *buf, size_t buf_len,
06274                 <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * var,
06275                 <span class="keyword">const</span> <span class="keyword">struct</span> enum_list *enums,
06276                 <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06277 {
06278     size_t          out_len = 0;
06279     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga45">sprint_realloc_by_type</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06280                                var, enums, hint, units))
06281         <span class="keywordflow">return</span> (int) out_len;
06282     <span class="keywordflow">else</span>
06283         <span class="keywordflow">return</span> -1;
06284 }
06285 
06286 <span class="keywordtype">int</span>
06287 snprint_hexstring(<span class="keywordtype">char</span> *buf, size_t buf_len, <span class=
"keyword">const</span> u_char * cp, size_t len)
06288 {
06289     size_t          out_len = 0;
06290     <span class="keywordflow">if</span> (sprint_realloc_hexstring((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06291                                  cp, len))
06292         <span class="keywordflow">return</span> (int) out_len;
06293     <span class="keywordflow">else</span>
06294         <span class="keywordflow">return</span> -1;
06295 }
06296 
06297 <span class="keywordtype">int</span>
06298 snprint_asciistring(<span class="keywordtype">char</span> *buf, size_t buf_len,
06299                     <span class="keyword">const</span> u_char * cp, size_t len)
06300 {
06301     size_t          out_len = 0;
06302     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga28">sprint_realloc_asciistring</a>
06303         ((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0, cp, len))
06304         <span class="keywordflow">return</span> (int) out_len;
06305     <span class="keywordflow">else</span>
06306         <span class="keywordflow">return</span> -1;
06307 }
06308 
06309 <span class="keywordtype">int</span>
06310 snprint_octet_string(<span class="keywordtype">char</span> *buf, size_t buf_len,
06311                      <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06312                      <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06313 {
06314     size_t          out_len = 0;
06315     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga29">sprint_realloc_octet_string</a>
06316         ((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0, var, enums, hint,
06317          units))
06318         <span class="keywordflow">return</span> (int) out_len;
06319     <span class="keywordflow">else</span>
06320         <span class="keywordflow">return</span> -1;
06321 }
06322 
06323 <span class="keywordtype">int</span>
06324 snprint_opaque(<span class="keywordtype">char</span> *buf, size_t buf_len,
06325                <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06326                <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06327 {
06328     size_t          out_len = 0;
06329     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga31">sprint_realloc_opaque</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06330                               var, enums, hint, units))
06331         <span class="keywordflow">return</span> (int) out_len;
06332     <span class="keywordflow">else</span>
06333         <span class="keywordflow">return</span> -1;
06334 }
06335 
06336 <span class="keywordtype">int</span>
06337 snprint_object_identifier(<span class="keywordtype">char</span> *buf, size_t buf_len,
06338                           <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
06339                           <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums, <span class="keyword">const</span> <span class="keywordtype">char</span> *hint,
06340                           <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
06341 {
06342     size_t          out_len = 0;
06343     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga32">sprint_realloc_object_identifier</a>
06344         ((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0, var, enums, hint,
06345          units))
06346         <span class="keywordflow">return</span> (int) out_len;
06347     <span class="keywordflow">else</span>
06348         <span class="keywordflow">return</span> -1;
06349 }
06350 
06351 <span class="keywordtype">int</span>
06352 snprint_timeticks(<span class="keywordtype">char</span> *buf, size_t buf_len,
06353                   <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06354                   <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06355 {
06356     size_t          out_len = 0;
06357     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga33">sprint_realloc_timeticks</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06358                                  var, enums, hint, units))
06359         <span class="keywordflow">return</span> (int) out_len;
06360     <span class="keywordflow">else</span>
06361         <span class="keywordflow">return</span> -1;
06362 }
06363 
06364 <span class="keywordtype">int</span>
06365 snprint_hinted_integer(<span class="keywordtype">char</span> *buf, size_t buf_len,
06366                        <span class="keywordtype">long</span> val, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *hint, <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
06367 {
06368     size_t          out_len = 0;
06369     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga34">sprint_realloc_hinted_integer</a>
06370         ((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0, val, <span class="charliteral">'d'</span>, hint, units))
06371         <span class="keywordflow">return</span> (int) out_len;
06372     <span class="keywordflow">else</span>
06373         <span class="keywordflow">return</span> -1;
06374 }
06375 
06376 <span class="keywordtype">int</span>
06377 snprint_integer(<span class="keywordtype">char</span> *buf, size_t buf_len,
06378                 <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06379                 <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06380 {
06381     size_t          out_len = 0;
06382     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga35">sprint_realloc_integer</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06383                                var, enums, hint, units))
06384         <span class="keywordflow">return</span> (int) out_len;
06385     <span class="keywordflow">else</span>
06386         <span class="keywordflow">return</span> -1;
06387 }
06388 
06389 <span class="keywordtype">int</span>
06390 snprint_uinteger(<span class="keywordtype">char</span> *buf, size_t buf_len,
06391                  <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06392                  <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06393 {
06394     size_t          out_len = 0;
06395     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga36">sprint_realloc_uinteger</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06396                                 var, enums, hint, units))
06397         <span class="keywordflow">return</span> (int) out_len;
06398     <span class="keywordflow">else</span>
06399         <span class="keywordflow">return</span> -1;
06400 }
06401 
06402 <span class="keywordtype">int</span>
06403 snprint_gauge(<span class="keywordtype">char</span> *buf, size_t buf_len,
06404               <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06405               <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06406 {
06407     size_t          out_len = 0;
06408     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga37">sprint_realloc_gauge</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06409                              var, enums, hint, units))
06410         <span class="keywordflow">return</span> (int) out_len;
06411     <span class="keywordflow">else</span>
06412         <span class="keywordflow">return</span> -1;
06413 }
06414 
06415 <span class="keywordtype">int</span>
06416 snprint_counter(<span class="keywordtype">char</span> *buf, size_t buf_len,
06417                 <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06418                 <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06419 {
06420     size_t          out_len = 0;
06421     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga38">sprint_realloc_counter</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06422                                var, enums, hint, units))
06423         <span class="keywordflow">return</span> (int) out_len;
06424     <span class="keywordflow">else</span>
06425         <span class="keywordflow">return</span> -1;
06426 }
06427 
06428 <span class="keywordtype">int</span>
06429 snprint_networkaddress(<span class="keywordtype">char</span> *buf, size_t buf_len,
06430                        <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var,
06431                        <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums, <span class="keyword">const</span> <span class="keywordtype">char</span> *hint,
06432                        <span class="keyword">const</span> <span class="keywordtype">char</span> *units)
06433 {
06434     size_t          out_len = 0;
06435     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga39">sprint_realloc_networkaddress</a>
06436         ((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0, var, enums, hint,
06437          units))
06438         <span class="keywordflow">return</span> (int) out_len;
06439     <span class="keywordflow">else</span>
06440         <span class="keywordflow">return</span> -1;
06441 }
06442 
06443 <span class="keywordtype">int</span>
06444 snprint_ipaddress(<span class="keywordtype">char</span> *buf, size_t buf_len,
06445                   <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06446                   <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06447 {
06448     size_t          out_len = 0;
06449     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga40">sprint_realloc_ipaddress</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06450                                  var, enums, hint, units))
06451         <span class="keywordflow">return</span> (int) out_len;
06452     <span class="keywordflow">else</span>
06453         <span class="keywordflow">return</span> -1;
06454 }
06455 
06456 <span class="keywordtype">int</span>
06457 snprint_null(<span class="keywordtype">char</span> *buf, size_t buf_len,
06458              <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06459              <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06460 {
06461     size_t          out_len = 0;
06462     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga41">sprint_realloc_null</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06463                             var, enums, hint, units))
06464         <span class="keywordflow">return</span> (int) out_len;
06465     <span class="keywordflow">else</span>
06466         <span class="keywordflow">return</span> -1;
06467 }
06468 
06469 <span class="keywordtype">int</span>
06470 snprint_bitstring(<span class="keywordtype">char</span> *buf, size_t buf_len,
06471                   <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06472                   <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06473 {
06474     size_t          out_len = 0;
06475     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga42">sprint_realloc_bitstring</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06476                                  var, enums, hint, units))
06477         <span class="keywordflow">return</span> (int) out_len;
06478     <span class="keywordflow">else</span>
06479         <span class="keywordflow">return</span> -1;
06480 }
06481 
06482 <span class="keywordtype">int</span>
06483 snprint_nsapaddress(<span class="keywordtype">char</span> *buf, size_t buf_len,
06484                     <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06485                     <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06486 {
06487     size_t          out_len = 0;
06488     <span class="keywordflow">if</span> (sprint_realloc_nsapaddress
06489         ((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0, var, enums, hint,
06490          units))
06491         <span class="keywordflow">return</span> (int) out_len;
06492     <span class="keywordflow">else</span>
06493         <span class="keywordflow">return</span> -1;
06494 }
06495 
06496 <span class="keywordtype">int</span>
06497 snprint_counter64(<span class="keywordtype">char</span> *buf, size_t buf_len,
06498                   <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06499                   <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06500 {
06501     size_t          out_len = 0;
06502     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga30">sprint_realloc_counter64</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06503                                  var, enums, hint, units))
06504         <span class="keywordflow">return</span> (int) out_len;
06505     <span class="keywordflow">else</span>
06506         <span class="keywordflow">return</span> -1;
06507 }
06508 
06509 <span class="keywordtype">int</span>
06510 snprint_badtype(<span class="keywordtype">char</span> *buf, size_t buf_len,
06511                 <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06512                 <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06513 {
06514     size_t          out_len = 0;
06515     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga44">sprint_realloc_badtype</a>((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06516                                var, enums, hint, units))
06517         <span class="keywordflow">return</span> (int) out_len;
06518     <span class="keywordflow">else</span>
06519         <span class="keywordflow">return</span> -1;
06520 }
06521 
06522 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
06523 <span class="keywordtype">int</span>
06524 snprint_float(<span class="keywordtype">char</span> *buf, size_t buf_len,
06525               <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06526               <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06527 {
06528     size_t          out_len = 0;
06529     <span class="keywordflow">if</span> (sprint_realloc_float((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06530                              var, enums, hint, units))
06531         <span class="keywordflow">return</span> (int) out_len;
06532     <span class="keywordflow">else</span>
06533         <span class="keywordflow">return</span> -1;
06534 }
06535 
06536 <span class="keywordtype">int</span>
06537 snprint_double(<span class="keywordtype">char</span> *buf, size_t buf_len,
06538                <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> * var, <span class="keyword">const</span> <span class=
"keyword">struct</span> enum_list *enums,
06539                <span class="keyword">const</span> <span class="keywordtype">char</span> *hint, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *units)
06540 {
06541     size_t          out_len = 0;
06542     <span class="keywordflow">if</span> (sprint_realloc_double((u_char **) &amp; buf, &amp;buf_len, &amp;out_len, 0,
06543                               var, enums, hint, units))
06544         <span class="keywordflow">return</span> (int) out_len;
06545     <span class="keywordflow">else</span>
06546         <span class="keywordflow">return</span> -1;
06547 }
06548 <span class="preprocessor">#endif</span>
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small>Generated on Fri Dec 30 13:47:45 2005 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

