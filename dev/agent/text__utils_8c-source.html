<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>text_utils.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00002 <span class="preprocessor">#include &lt;net-snmp/net-snmp-includes.h&gt;</span>
00003 
00004 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00005 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00006 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00007 <span class="preprocessor">#   include &lt;stdlib.h&gt;</span>
00008 <span class="preprocessor">#endif</span>
00009 <span class="preprocessor">#if HAVE_UNISTD_H</span>
00010 <span class="preprocessor">#   include &lt;unistd.h&gt;</span>
00011 <span class="preprocessor">#endif</span>
00012 <span class="preprocessor">#if HAVE_STRING_H</span>
00013 <span class="preprocessor">#   include &lt;string.h&gt;</span>
00014 <span class="preprocessor">#else</span>
00015 <span class="preprocessor">#  include &lt;strings.h&gt;</span>
00016 <span class="preprocessor">#endif</span>
00017 
00018 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00019 
00020 <span class="preprocessor">#if HAVE_LIMITS_H</span>
00021 <span class="preprocessor">#   include &lt;limits.h&gt;</span>
00022 <span class="preprocessor">#endif</span>
00023 <span class="preprocessor">#if HAVE_SYS_PARAM_H</span>
00024 <span class="preprocessor">#   include &lt;sys/param.h&gt;</span>
00025 <span class="preprocessor">#endif</span>
00026 <span class="preprocessor">#ifdef HAVE_SYS_STAT_H</span>
00027 <span class="preprocessor">#   include &lt;sys/stat.h&gt;</span>
00028 <span class="preprocessor">#endif</span>
00029 <span class="preprocessor">#ifdef HAVE_FCNTL_H</span>
00030 <span class="preprocessor">#   include &lt;fcntl.h&gt;</span>
00031 <span class="preprocessor">#endif</span>
00032 
00033 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00034 
00035 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00036 <span class="preprocessor">#  include &lt;dmalloc.h&gt;</span>
00037 <span class="preprocessor">#endif</span>
00038 
00039 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00040 <span class="preprocessor">#include &lt;net-snmp/library/snmp_debug.h&gt;</span>
00041 <span class="preprocessor">#include &lt;net-snmp/library/container.h&gt;</span>
00042 <span class="preprocessor">#include &lt;net-snmp/library/file_utils.h&gt;</span>
00043 <span class="preprocessor">#include &lt;net-snmp/library/text_utils.h&gt;</span>
00044 
00045 
00046 <span class="comment">/*------------------------------------------------------------------</span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * Prototypes</span>
00049 <span class="comment"> *</span>
00050 <span class="comment"> */</span>
00051 <span class="comment">/*</span>
00052 <span class="comment"> * parse methods</span>
00053 <span class="comment"> */</span>
00054 <span class="keywordtype">void</span>
00055 _pm_save_index_string_string(FILE *f, netsnmp_container *cin,
00056                              <span class="keywordtype">int</span> flags);
00057 <span class="keywordtype">void</span>
00058 _pm_save_everything(FILE *f, netsnmp_container *cin, <span class="keywordtype">int</span> flags);
00059 <span class="keywordtype">void</span>
00060 _pm_user_function(FILE *f, netsnmp_container *cin,
00061                   netsnmp_line_process_info *lpi, <span class="keywordtype">int</span> flags);
00062 
00063 
00064 <span class="comment">/*</span>
00065 <span class="comment"> * line processors</span>
00066 <span class="comment"> */</span>
00067 <span class="keywordtype">int</span> _process_line_tvi(netsnmp_line_info *line_info, <span class=
"keywordtype">void</span> *mem,
00068                       <span class="keyword">struct</span> netsnmp_line_process_info_s* lpi);
00069 
00070 
00071 
00072 <span class="comment">/*------------------------------------------------------------------</span>
00073 <span class="comment"> *</span>
00074 <span class="comment"> * Text file processing functions</span>
00075 <span class="comment"> *</span>
00076 <span class="comment"> */</span>
00077 
00081 netsnmp_container *
00082 netsnmp_file_text_parse(netsnmp_file *f, netsnmp_container *cin,
00083                         <span class="keywordtype">int</span> parse_mode, u_int flags, <span class=
"keywordtype">void</span> *context)
00084 {
00085     netsnmp_container *c = cin;
00086     FILE              *fin;
00087     <span class="keywordtype">int</span>                rc;
00088 
00089     <span class="keywordflow">if</span> (NULL == f)
00090         <span class="keywordflow">return</span> NULL;
00091 
00092     <span class="keywordflow">if</span> ((NULL == c) &amp;&amp; (!(flags &amp; PM_FLAG_NO_CONTAINER))) {
00093         c = netsnmp_container_find(<span class="stringliteral">"text_parse:binary_array"</span>);
00094         <span class="keywordflow">if</span> (NULL == c)
00095             <span class="keywordflow">return</span> NULL;
00096     }
00097 
00098     rc = netsnmp_file_open(f);
00099     <span class="keywordflow">if</span> (rc &lt; 0) { 
00100         <span class="keywordflow">if</span> ((NULL !=c) &amp;&amp; (c != cin))
00101             CONTAINER_FREE(c);
00102         <span class="keywordflow">return</span> NULL;
00103     }
00104     
00105     <span class="comment">/*</span>
00106 <span class="comment">     * get a stream from the file descriptor. This DOES NOT rewind the</span>
00107 <span class="comment">     * file (if fd was previously opened).</span>
00108 <span class="comment">     */</span>
00109     fin = fdopen(f-&gt;fd, <span class="stringliteral">"r"</span>);
00110     <span class="keywordflow">if</span> (NULL == fin) {
00111         <span class="keywordflow">if</span> (NS_FI_AUTOCLOSE(f-&gt;ns_flags))
00112             close(f-&gt;fd);
00113         <span class="keywordflow">if</span> ((NULL !=c) &amp;&amp; (c != cin))
00114             CONTAINER_FREE(c);
00115         <span class="keywordflow">return</span> NULL;
00116     }
00117 
00118     <span class="keywordflow">switch</span> (parse_mode) {
00119 
00120         <span class="keywordflow">case</span> PM_SAVE_EVERYTHING:
00121             _pm_save_everything(fin, c, flags);
00122             <span class="keywordflow">break</span>;
00123 
00124         <span class="keywordflow">case</span> PM_INDEX_STRING_STRING:
00125             _pm_save_index_string_string(fin, c, flags);
00126             <span class="keywordflow">break</span>;
00127 
00128         <span class="keywordflow">case</span> PM_USER_FUNCTION:
00129             <span class="keywordflow">if</span> (NULL != context)
00130                 _pm_user_function(fin, c, (netsnmp_line_process_info*)context,
00131                                   flags);
00132             <span class="keywordflow">break</span>;
00133 
00134         <span class="keywordflow">default</span>:
00135             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"unknown parse mode %d\n"</span>, parse_mode);
00136             <span class="keywordflow">break</span>;
00137     }
00138 
00139 
00140     <span class="comment">/*</span>
00141 <span class="comment">     * close the stream, which will have the side effect of also closing</span>
00142 <span class="comment">     * the file descriptor, so we need to reset it.</span>
00143 <span class="comment">     */</span>
00144     fclose(fin);
00145     f-&gt;fd = -1;
00146 
00147     <span class="keywordflow">return</span> c;
00148 }
00149 
00150 netsnmp_container *
00151 netsnmp_text_token_container_from_file(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *file, u_int flags,
00152                                        netsnmp_container *cin, <span class="keywordtype">void</span> *context)
00153 {
00154     netsnmp_line_process_info  lpi;
00155     netsnmp_container         *c = cin, *c_rc;
00156     netsnmp_file              *fp;
00157 
00158     <span class="keywordflow">if</span> (NULL == file)
00159         <span class="keywordflow">return</span> NULL;
00160 
00161     <span class="comment">/*</span>
00162 <span class="comment">     * allocate file resources</span>
00163 <span class="comment">     */</span>
00164     fp = netsnmp_file_fill(NULL, file, O_RDONLY, 0, 0);
00165     <span class="keywordflow">if</span> (NULL == fp) 
00166         <span class="keywordflow">return</span> NULL;
00167 
00168     memset(&amp;lpi, 0x0, <span class="keyword">sizeof</span>(lpi));
00169     lpi.mem_size = <span class="keyword">sizeof</span>(netsnmp_token_value_index);
00170     lpi.process = _process_line_tvi;
00171     lpi.user_context = context;
00172 
00173     <span class="keywordflow">if</span> (NULL == c) {
00174         c = netsnmp_container_find(<span class="stringliteral">"string:binary_array"</span>);
00175         <span class="keywordflow">if</span> (NULL == c) {
00176             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"malloc failed\n"</span>);
00177             netsnmp_file_release(fp);
00178             <span class="keywordflow">return</span> NULL;
00179         }
00180     }
00181 
00182     c_rc = netsnmp_file_text_parse(fp, c, PM_USER_FUNCTION, 0, &amp;lpi);
00183 
00184     <span class="comment">/*</span>
00185 <span class="comment">     * if we got a bad return and the user didn't pass us a container,</span>
00186 <span class="comment">     * we need to release the container we allocated.</span>
00187 <span class="comment">     */</span>
00188     <span class="keywordflow">if</span> ((NULL == c_rc) &amp;&amp; (NULL == cin)) {
00189         CONTAINER_FREE(c);
00190         c = NULL;
00191     }
00192     <span class="keywordflow">else</span>
00193         c = c_rc;
00194 
00195     <span class="comment">/*</span>
00196 <span class="comment">     * release file resources</span>
00197 <span class="comment">     */</span>
00198     netsnmp_file_release(fp);
00199     
00200     <span class="keywordflow">return</span> c;
00201 }
00202 
00203 
00204 <span class="comment">/*------------------------------------------------------------------</span>
00205 <span class="comment"> *</span>
00206 <span class="comment"> * Text file process modes helper functions</span>
00207 <span class="comment"> *</span>
00208 <span class="comment"> */</span>
00209 
00214 <span class="keywordtype">void</span>
00215 _pm_save_everything(FILE *f, netsnmp_container *cin, <span class="keywordtype">int</span> flags)
00216 {
00217     <span class="keywordtype">char</span>               line[STRINGMAX], *ptr;
00218     size_t             len;
00219 
00220     netsnmp_assert(NULL != f);
00221     netsnmp_assert(NULL != cin);
00222 
00223     <span class="keywordflow">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), f) != NULL) {
00224 
00225         ptr = line;
00226         len = strlen(line) - 1;
00227         <span class="keywordflow">if</span> (line[len] == <span class="charliteral">'\n'</span>)
00228             line[len] = 0;
00229 
00230         <span class="comment">/*</span>
00231 <span class="comment">         * save blank line or comment?</span>
00232 <span class="comment">         */</span>
00233         <span class="keywordflow">if</span> (flags &amp; PM_FLAG_SKIP_WHITESPACE) {
00234             <span class="keywordflow">if</span> (NULL == (ptr = skip_white(ptr)))
00235                 <span class="keywordflow">continue</span>;
00236         }
00237 
00238         ptr = strdup(line);
00239         <span class="keywordflow">if</span> (NULL == ptr) {
00240             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"malloc failed\n"</span>);
00241             <span class="keywordflow">break</span>;
00242         }
00243 
00244         CONTAINER_INSERT(cin,ptr);
00245     }
00246 }
00247 
00252 <span class="keywordtype">void</span>
00253 _pm_save_index_string_string(FILE *f, netsnmp_container *cin,
00254                              <span class="keywordtype">int</span> flags)
00255 {
00256     <span class="keywordtype">char</span>                        line[STRINGMAX], *ptr;
00257     netsnmp_token_value_index  *tvi;
00258     size_t                      count = 0, len;
00259 
00260     netsnmp_assert(NULL != f);
00261     netsnmp_assert(NULL != cin);
00262 
00263     <span class="keywordflow">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), f) != NULL) {
00264 
00265         ++count;
00266         ptr = line;
00267         len = strlen(line) - 1;
00268         <span class="keywordflow">if</span> (line[len] == <span class="charliteral">'\n'</span>)
00269             line[len] = 0;
00270 
00271         <span class="comment">/*</span>
00272 <span class="comment">         * save blank line or comment?</span>
00273 <span class="comment">         */</span>
00274         <span class="keywordflow">if</span> (flags &amp; PM_FLAG_SKIP_WHITESPACE) {
00275             <span class="keywordflow">if</span> (NULL == (ptr = skip_white(ptr)))
00276                 <span class="keywordflow">continue</span>;
00277         }
00278 
00279         tvi = <a class="code" href="group__util.html#ga39">SNMP_MALLOC_TYPEDEF</a>(netsnmp_token_value_index);
00280         <span class="keywordflow">if</span> (NULL == tvi) {
00281             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"malloc failed\n"</span>);
00282             <span class="keywordflow">break</span>;
00283         }
00284             
00285         <span class="comment">/*</span>
00286 <span class="comment">         * copy whole line, then set second pointer to</span>
00287 <span class="comment">         * after token. One malloc, 2 strings!</span>
00288 <span class="comment">         */</span>
00289         tvi-&gt;index = count;
00290         tvi-&gt;token = strdup(line);
00291         <span class="keywordflow">if</span> (NULL == tvi-&gt;token) {
00292             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"malloc failed\n"</span>);
00293             free(tvi);
00294             <span class="keywordflow">break</span>;
00295         }
00296         tvi-&gt;value.cp = skip_not_white(tvi-&gt;token);
00297         <span class="keywordflow">if</span> (NULL != tvi-&gt;value.cp) {
00298             *(tvi-&gt;value.cp) = 0;
00299             ++(tvi-&gt;value.cp);
00300         }
00301         CONTAINER_INSERT(cin, tvi);
00302     }
00303 }
00304 
00309 <span class="keywordtype">void</span>
00310 _pm_user_function(FILE *f, netsnmp_container *cin,
00311                   netsnmp_line_process_info *lpi, <span class="keywordtype">int</span> flags)
00312 {
00313     <span class="keywordtype">char</span>                        buf[STRINGMAX];
00314     netsnmp_line_info           li;
00315     <span class="keywordtype">void</span>                       *mem = NULL;
00316     <span class="keywordtype">int</span>                         rc;
00317 
00318     netsnmp_assert(NULL != f);
00319     netsnmp_assert(NULL != cin);
00320 
00321     <span class="comment">/*</span>
00322 <span class="comment">     * static buf, or does the user want the memory?</span>
00323 <span class="comment">     */</span>
00324     <span class="keywordflow">if</span> (flags &amp; PMLP_FLAG_ALLOC_LINE) {
00325         <span class="keywordflow">if</span> (0 != lpi-&gt;line_max)
00326             li.line_max =  lpi-&gt;line_max;
00327         <span class="keywordflow">else</span>
00328             li.line_max = STRINGMAX;
00329         li.line = calloc(li.line_max, 1);
00330         <span class="keywordflow">if</span> (NULL == li.line) {
00331             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"malloc failed\n"</span>);
00332             <span class="keywordflow">return</span>;
00333         }
00334     }
00335     <span class="keywordflow">else</span> {
00336         li.line = buf;
00337         li.line_max = <span class="keyword">sizeof</span>(buf);
00338     }
00339         
00340     li.index = 0;
00341     <span class="keywordflow">while</span> (fgets(li.line, li.line_max, f) != NULL) {
00342 
00343         ++li.index;
00344         li.start = li.line;
00345         li.line_len = strlen(li.line) - 1;
00346         <span class="keywordflow">if</span> ((!(lpi-&gt;flags &amp; PMLP_FLAG_LEAVE_NEWLINE)) &amp;&amp;
00347             (li.line[li.line_len] == <span class="charliteral">'\n'</span>))
00348             li.line[li.line_len] = 0;
00349         
00350         <span class="comment">/*</span>
00351 <span class="comment">         * save blank line or comment?</span>
00352 <span class="comment">         */</span>
00353         <span class="keywordflow">if</span> (!(lpi-&gt;flags &amp; PMLP_FLAG_PROCESS_WHITESPACE)) {
00354             <span class="keywordflow">if</span> (NULL == (li.start = skip_white(li.start)))
00355                 <span class="keywordflow">continue</span>;
00356         }
00357 
00358         <span class="comment">/*</span>
00359 <span class="comment">         *  do we need to allocate memory for the use?</span>
00360 <span class="comment">         * if the last call didn't use the memory we allocated,</span>
00361 <span class="comment">         * re-use it. Otherwise, allocate new chunk.</span>
00362 <span class="comment">         */</span>
00363         <span class="keywordflow">if</span> ((0 != lpi-&gt;mem_size) &amp;&amp; (NULL == mem)) {
00364             mem = calloc(lpi-&gt;mem_size, 1);
00365             <span class="keywordflow">if</span> (NULL == mem) {
00366                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"malloc failed\n"</span>);
00367                 <span class="keywordflow">break</span>;
00368             }
00369         }
00370 
00371         <span class="comment">/*</span>
00372 <span class="comment">         * do they want a copy ot the line?</span>
00373 <span class="comment">         */</span>
00374         <span class="keywordflow">if</span> (lpi-&gt;flags &amp; PMLP_FLAG_STRDUP_LINE) {
00375             li.start = strdup(li.start);
00376             <span class="keywordflow">if</span> (NULL == li.start) {
00377                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"malloc failed\n"</span>);
00378                 <span class="keywordflow">break</span>;
00379             }
00380         }
00381         <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (lpi-&gt;flags &amp; PMLP_FLAG_ALLOC_LINE) {
00382             li.start = li.line;
00383         }
00384 
00385         <span class="comment">/*</span>
00386 <span class="comment">         * call the user function. If the function wants to save</span>
00387 <span class="comment">         * the memory chunk, insert it in the container, the clear</span>
00388 <span class="comment">         * pointer so we reallocate next time.</span>
00389 <span class="comment">         */</span>
00390         li.start_len = strlen(li.start);
00391         rc = (*lpi-&gt;process)(&amp;li, mem, lpi);
00392         <span class="keywordflow">if</span> (PMLP_RC_MEMORY_USED == rc) {
00393 
00394             <span class="keywordflow">if</span> (!(lpi-&gt;flags &amp; PMLP_FLAG_NO_CONTAINER))
00395                 CONTAINER_INSERT(cin, mem);
00396             
00397             mem = NULL;
00398             
00399             <span class="keywordflow">if</span> (lpi-&gt;flags &amp; PMLP_FLAG_ALLOC_LINE) {
00400                 li.line = calloc(li.line_max, 1);
00401                 <span class="keywordflow">if</span> (NULL == li.line) {
00402                     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"malloc failed\n"</span>);
00403                     <span class="keywordflow">break</span>;
00404                 }
00405             }
00406         }
00407         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PMLP_RC_MEMORY_UNUSED == rc ) {
00408             <span class="comment">/*</span>
00409 <span class="comment">             * they didn't use the memory. if li.start was a strdup, we have</span>
00410 <span class="comment">             * to release it. leave mem, we can re-use it (its a fixed size).</span>
00411 <span class="comment">             */</span>
00412             <span class="keywordflow">if</span> (lpi-&gt;flags &amp; PMLP_FLAG_STRDUP_LINE)
00413                 free(li.start); <span class="comment">/* no point in SNMP_FREE */</span>
00414         }
00415         <span class="keywordflow">else</span> {
00416             <span class="keywordflow">if</span> (PMLP_RC_STOP_PROCESSING != rc )
00417                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"unknown rc %d from text processor\n"</span>, rc);
00418             <span class="keywordflow">break</span>;
00419         }
00420     }
00421 }
00422 
00423 <span class="comment">/*------------------------------------------------------------------</span>
00424 <span class="comment"> *</span>
00425 <span class="comment"> * Test line process helper functions</span>
00426 <span class="comment"> *</span>
00427 <span class="comment"> */</span>
00432 <span class="keywordtype">int</span>
00433 _process_line_tvi(netsnmp_line_info *line_info, <span class="keywordtype">void</span> *mem,
00434                   <span class="keyword">struct</span> netsnmp_line_process_info_s* lpi)
00435 {
00436     netsnmp_token_value_index *tvi = (netsnmp_token_value_index *)mem;
00437     <span class="keywordtype">char</span>                      *ptr;
00438 
00439     <span class="comment">/*</span>
00440 <span class="comment">     * get token</span>
00441 <span class="comment">     */</span>
00442     ptr = skip_not_white(line_info-&gt;start);
00443     <span class="keywordflow">if</span> (NULL == ptr) {
00444         DEBUGMSGTL((<span class="stringliteral">"text:util:tvi"</span>, <span class=
"stringliteral">"no value after token '%s'\n"</span>,
00445                     line_info-&gt;start));
00446         <span class="keywordflow">return</span> PMLP_RC_MEMORY_UNUSED;
00447     }
00448 
00449     <span class="comment">/*</span>
00450 <span class="comment">     * null terminate, search for value;</span>
00451 <span class="comment">     */</span>
00452     *(ptr++) = 0;
00453     ptr = skip_white(ptr);
00454     <span class="keywordflow">if</span> (NULL == ptr) {
00455         DEBUGMSGTL((<span class="stringliteral">"text:util:tvi"</span>, <span class=
"stringliteral">"no value after token '%s'\n"</span>,
00456                     line_info-&gt;start));
00457         <span class="keywordflow">return</span> PMLP_RC_MEMORY_UNUSED;
00458     }
00459 
00460     <span class="comment">/*</span>
00461 <span class="comment">     * get value</span>
00462 <span class="comment">     */</span>
00463     <span class="keywordflow">switch</span>((int)lpi-&gt;user_context) {
00464 
00465         <span class="keywordflow">case</span> PMLP_TYPE_UNSIGNED:
00466             tvi-&gt;value.ul = strtoul(ptr, NULL, 0);
00467             <span class="keywordflow">if</span> ((errno == ERANGE) &amp;&amp;(ULONG_MAX == tvi-&gt;value.sl))
00468                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,<span class=
"stringliteral">"value overflow\n"</span>);
00469             <span class="keywordflow">break</span>;
00470 
00471 
00472         <span class="keywordflow">case</span> PMLP_TYPE_INTEGER:
00473             tvi-&gt;value.ul = strtol(ptr, NULL, 0);
00474             <span class="keywordflow">if</span> ((errno == ERANGE) &amp;&amp;
00475                 ((LONG_MAX == tvi-&gt;value.sl) ||
00476                  (LONG_MIN == tvi-&gt;value.sl)))
00477                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,<span class=
"stringliteral">"value over/under-flow\n"</span>);
00478             <span class="keywordflow">break</span>;
00479 
00480         <span class="keywordflow">case</span> PMLP_TYPE_STRING:
00481             tvi-&gt;value.cp = strdup(ptr);
00482             <span class="keywordflow">break</span>;
00483 
00484         <span class="keywordflow">case</span> PMLP_TYPE_BOOLEAN:
00485             <span class="keywordflow">if</span> (isdigit(*ptr))
00486                 tvi-&gt;value.ul = strtoul(ptr, NULL, 0);
00487             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(ptr,<span class=
"stringliteral">"true"</span>) == 0)
00488                 tvi-&gt;value.ul = 1;
00489             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(ptr,<span class=
"stringliteral">"false"</span>) == 0)
00490                 tvi-&gt;value.ul = 0;
00491             <span class="keywordflow">else</span> {
00492                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,<span class=
"stringliteral">"bad value for boolean\n"</span>);
00493                 <span class="keywordflow">return</span> PMLP_RC_MEMORY_UNUSED;
00494             }
00495             <span class="keywordflow">break</span>;
00496 
00497         <span class="keywordflow">default</span>:
00498             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"unsupported value type %d\n"</span>,
00499                      (<span class="keywordtype">int</span>)lpi-&gt;user_context);
00500             <span class="keywordflow">break</span>;
00501     }
00502     
00503     <span class="comment">/*</span>
00504 <span class="comment">     * save token and value</span>
00505 <span class="comment">     */</span>
00506     tvi-&gt;token = strdup(line_info-&gt;start);
00507     tvi-&gt;index = line_info-&gt;index;
00508 
00509     <span class="keywordflow">return</span> PMLP_RC_MEMORY_USED;
00510 }
00511 
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small>Generated on Fri Dec 30 13:47:51 2005 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

