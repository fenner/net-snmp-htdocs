<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>callback.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * callback.c: A generic callback mechanism </span>
00003 <span class="comment"> */</span>
00004 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
00005 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00006 <span class="comment"> * that may apply:</span>
00007 <span class="comment"> */</span>
00008 <span class="comment">/*</span>
00009 <span class="comment"> * Portions of this file are copyrighted by:</span>
00010 <span class="comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
00011 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00012 <span class="comment"> * distributed with the Net-SNMP package.</span>
00013 <span class="comment"> */</span>
00019 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00020 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00021 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00022 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00023 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00024 <span class="preprocessor">#endif</span>
00025 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00026 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00027 <span class="preprocessor">#endif</span>
00028 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00029 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00030 <span class="preprocessor">#endif</span>
00031 <span class="preprocessor">#if HAVE_STRING_H</span>
00032 <span class="preprocessor">#include &lt;string.h&gt;</span>
00033 <span class="preprocessor">#else</span>
00034 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00035 <span class="preprocessor">#endif</span>
00036 
00037 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00038 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00039 <span class="preprocessor">#endif</span>
00040 
00041 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00042 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00043 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00044 
00045 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
00046 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00047 
00048 <span class="keyword">static</span> <span class="keyword">struct </span>snmp_gen_callback
00049                *thecallbacks[MAX_CALLBACK_IDS][MAX_CALLBACK_SUBIDS];
00050 
00051 <span class="comment">/*</span>
00052 <span class="comment"> * extermely simplistic locking, just to find problems were the</span>
00053 <span class="comment"> * callback list is modified while being traversed. Not intended</span>
00054 <span class="comment"> * to do any real protection, or in any way imply that this code</span>
00055 <span class="comment"> * has been evaluated for use in a multi-threaded environment.</span>
00056 <span class="comment"> */</span>
00057 <span class="keyword">static</span> <span class="keywordtype">int</span> _lock = 0;
00058 
00059 
00060 <span class="comment">/*</span>
00061 <span class="comment"> * the chicken. or the egg.  You pick. </span>
00062 <span class="comment"> */</span>
00063 <span class="keywordtype">void</span>
00064 init_callbacks(<span class="keywordtype">void</span>)
00065 {
00066     <span class="comment">/*</span>
00067 <span class="comment">     * probably not needed? Should be full of 0's anyway? </span>
00068 <span class="comment">     */</span>
00069     <span class="comment">/*</span>
00070 <span class="comment">     * (poses a problem if you put init_callbacks() inside of</span>
00071 <span class="comment">     * init_snmp() and then want the app to register a callback before</span>
00072 <span class="comment">     * init_snmp() is called in the first place.  -- Wes </span>
00073 <span class="comment">     */</span>
00074     <span class="comment">/*</span>
00075 <span class="comment">     * memset(thecallbacks, 0, sizeof(thecallbacks)); </span>
00076 <span class="comment">     */</span>
00077     DEBUGMSGTL((<span class="stringliteral">"callback"</span>, <span class="stringliteral">"initialized\n"</span>));
00078 }
00079 
00114 <span class="keywordtype">int</span>
<a name="l00115" id="l00115"></a><a class="code" href="group__callback.html#ga3">00115</a> <a class="code" href=
"group__callback.html#ga3">snmp_register_callback</a>(<span class="keywordtype">int</span> major, <span class=
"keywordtype">int</span> minor, SNMPCallback * new_callback,
00116                        <span class="keywordtype">void</span> *arg)
00117 {
00118     <span class="keywordflow">return</span> netsnmp_register_callback( major, minor, new_callback, arg, 0);
00119 }
00120 
00121 <span class="keywordtype">int</span>
00122 netsnmp_register_callback(<span class="keywordtype">int</span> major, <span class=
"keywordtype">int</span> minor, SNMPCallback * new_callback,
00123                           <span class="keywordtype">void</span> *arg, <span class="keywordtype">int</span> priority)
00124 {
00125     <span class="keyword">struct </span>snmp_gen_callback *newscp = NULL, *scp = NULL;
00126     <span class="keyword">struct </span>snmp_gen_callback **prevNext = &amp;(thecallbacks[major][minor]);
00127 
00128     <span class="keywordflow">if</span> (major &gt;= MAX_CALLBACK_IDS || minor &gt;= MAX_CALLBACK_SUBIDS) {
00129         <span class="keywordflow">return</span> SNMPERR_GENERR;
00130     }
00131     <span class="keywordflow">if</span>(++_lock &gt; 1) {
00132         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00133                  <span class="stringliteral">"netsnmp_register_callback called while callbacks _locked\n"</span>);
00134         netsnmp_assert(1==_lock);
00135     }
00136 
00137     <span class="keywordflow">if</span> ((newscp = <a class="code" href=
"group__util.html#ga38">SNMP_MALLOC_STRUCT</a>(snmp_gen_callback)) == NULL) {
00138         --_lock;
00139         <span class="keywordflow">return</span> SNMPERR_GENERR;
00140     } <span class="keywordflow">else</span> {
00141         newscp-&gt;priority = priority;
00142         newscp-&gt;sc_client_arg = arg;
00143         newscp-&gt;sc_callback = new_callback;
00144         newscp-&gt;next = NULL;
00145 
00146         <span class="keywordflow">for</span> (scp = thecallbacks[major][minor]; scp != NULL;
00147              scp = scp-&gt;next) {
00148             <span class="keywordflow">if</span> (newscp-&gt;priority &lt; scp-&gt;priority) {
00149                 newscp-&gt;next = scp;
00150                 <span class="keywordflow">break</span>;
00151             }
00152             prevNext = &amp;(scp-&gt;next);
00153         }
00154 
00155         *prevNext = newscp;
00156 
00157         DEBUGMSGTL((<span class="stringliteral">"callback"</span>, <span class=
"stringliteral">"registered (%d,%d) at %p with priority %d\n"</span>,
00158                     major, minor, newscp, priority));
00159         --_lock;
00160         <span class="keywordflow">return</span> SNMPERR_SUCCESS;
00161     }
00162 }
00163 
00181 <span class="keywordtype">int</span>
<a name="l00182" id="l00182"></a><a class="code" href="group__callback.html#ga5">00182</a> <a class="code" href=
"group__callback.html#ga5">snmp_call_callbacks</a>(<span class="keywordtype">int</span> major, <span class=
"keywordtype">int</span> minor, <span class="keywordtype">void</span> *caller_arg)
00183 {
00184     <span class="keyword">struct </span>snmp_gen_callback *scp;
00185     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    count = 0;
00186 
00187     <span class="keywordflow">if</span> (major &gt;= MAX_CALLBACK_IDS || minor &gt;= MAX_CALLBACK_SUBIDS) {
00188         <span class="keywordflow">return</span> SNMPERR_GENERR;
00189     }
00190 
00191     <span class="keywordflow">if</span>(++_lock &gt; 1) {
00192 <span class="preprocessor">#ifdef NETSNMP_PARANOID_LEVEL_HIGH</span>
00193         <span class="comment">/*</span>
00194 <span class="comment">         * Notes:</span>
00195 <span class="comment">         * - this gets hit the first time a trap is sent after a new trap</span>
00196 <span class="comment">         *   destination has been added (session init cb during send trap cb)</span>
00197 <span class="comment">         */</span>
00198         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00199                  <span class="stringliteral">"snmp_call_callbacks called while callbacks _locked\n"</span>);
00200         netsnmp_assert(1==_lock);
00201 <span class="preprocessor">#endif</span>
00202     }
00203 
00204     DEBUGMSGTL((<span class="stringliteral">"callback"</span>, <span class=
"stringliteral">"START calling callbacks for maj=%d min=%d\n"</span>,
00205                 major, minor));
00206 
00207     <span class="comment">/*</span>
00208 <span class="comment">     * for each registered callback of type major and minor </span>
00209 <span class="comment">     */</span>
00210     <span class="keywordflow">for</span> (scp = thecallbacks[major][minor]; scp != NULL; scp = scp-&gt;next) {
00211 
00212         <span class="comment">/*</span>
00213 <span class="comment">         * skip unregistered callbacks</span>
00214 <span class="comment">         */</span>
00215         <span class="keywordflow">if</span>(NULL == scp-&gt;sc_callback)
00216             <span class="keywordflow">continue</span>;
00217 
00218         DEBUGMSGTL((<span class="stringliteral">"callback"</span>, <span class=
"stringliteral">"calling a callback for maj=%d min=%d\n"</span>,
00219                     major, minor));
00220 
00221         <span class="comment">/*</span>
00222 <span class="comment">         * call them </span>
00223 <span class="comment">         */</span>
00224         (*(scp-&gt;sc_callback)) (major, minor, caller_arg,
00225                                scp-&gt;sc_client_arg);
00226         count++;
00227     }
00228 
00229     DEBUGMSGTL((<span class="stringliteral">"callback"</span>,
00230                 <span class="stringliteral">"END calling callbacks for maj=%d min=%d (%d called)\n"</span>,
00231                 major, minor, count));
00232 
00233     --_lock;
00234     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
00235 }
00236 
00237 <span class="keywordtype">int</span>
00238 snmp_count_callbacks(<span class="keywordtype">int</span> major, <span class="keywordtype">int</span> minor)
00239 {
00240     <span class="keywordtype">int</span>             count = 0;
00241     <span class="keyword">struct </span>snmp_gen_callback *scp;
00242 
00243     <span class="keywordflow">if</span> (major &gt;= MAX_CALLBACK_IDS || minor &gt;= MAX_CALLBACK_SUBIDS) {
00244         <span class="keywordflow">return</span> SNMPERR_GENERR;
00245     }
00246 
00247     <span class="keywordflow">for</span> (scp = thecallbacks[major][minor]; scp != NULL; scp = scp-&gt;next) {
00248         count++;
00249     }
00250 
00251     <span class="keywordflow">return</span> count;
00252 }
00253 
00254 <span class="keywordtype">int</span>
00255 snmp_callback_available(<span class="keywordtype">int</span> major, <span class="keywordtype">int</span> minor)
00256 {
00257     <span class="keywordflow">if</span> (major &gt;= MAX_CALLBACK_IDS || minor &gt;= MAX_CALLBACK_SUBIDS) {
00258         <span class="keywordflow">return</span> SNMPERR_GENERR;
00259     }
00260 
00261     <span class="keywordflow">if</span> (thecallbacks[major][minor] != NULL) {
00262         <span class="keywordflow">return</span> SNMPERR_SUCCESS;
00263     }
00264 
00265     <span class="keywordflow">return</span> SNMPERR_GENERR;
00266 }
00267 
00294 <span class="keywordtype">int</span>
<a name="l00295" id="l00295"></a><a class="code" href="group__callback.html#ga8">00295</a> <a class="code" href=
"group__callback.html#ga8">snmp_unregister_callback</a>(<span class="keywordtype">int</span> major, <span class=
"keywordtype">int</span> minor, SNMPCallback * target,
00296                          <span class="keywordtype">void</span> *arg, <span class="keywordtype">int</span> matchargs)
00297 {
00298     <span class="keyword">struct </span>snmp_gen_callback *scp = thecallbacks[major][minor];
00299     <span class="keyword">struct </span>snmp_gen_callback **prevNext = &amp;(thecallbacks[major][minor]);
00300     <span class="keywordtype">int</span>             count = 0;
00301 
00302     <span class="keywordflow">if</span>(++_lock &gt; 1) {
00303         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00304                  <span class="stringliteral">"snmp_unregister_callback called while callbacks _locked\n"</span>);
00305 <span class="preprocessor">#ifdef NETSNMP_PARANOID_LEVEL_HIGH</span>
00306         <span class="comment">/*</span>
00307 <span class="comment">         * Notes;</span>
00308 <span class="comment">         * - this gets hit at shutdown, during cleanup. No easy fix.</span>
00309 <span class="comment">         */</span>
00310         netsnmp_assert(1==_lock);
00311 <span class="preprocessor">#endif</span>
00312     }
00313     <span class="keywordflow">while</span> (scp != NULL) {
00314         <span class="keywordflow">if</span> ((scp-&gt;sc_callback == target) &amp;&amp;
00315             (!matchargs || (scp-&gt;sc_client_arg == arg))) {
00316             DEBUGMSGTL((<span class="stringliteral">"callback"</span>, <span class=
"stringliteral">"unregistering (%d,%d) at %p\n"</span>, major,
00317                         minor, scp));
00318             <span class="keywordflow">if</span>(_lock == 1) {
00319                 *prevNext = scp-&gt;next;
00320                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(scp);
00321                 scp = *prevNext;
00322             }
00323             <span class="keywordflow">else</span> {
00324                 scp-&gt;sc_callback = NULL;
00326             }
00327             count++;
00328         } <span class="keywordflow">else</span> {
00329             prevNext = &amp;(scp-&gt;next);
00330             scp = scp-&gt;next;
00331         }
00332     }
00333 
00334     --_lock;
00335     <span class="keywordflow">return</span> count;
00336 }
00337 
00338 <span class="keywordtype">void</span>
00339 clear_callback(<span class="keywordtype">void</span>)
00340 {
00341     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0, j = 0; 
00342     <span class="keyword">struct </span>snmp_gen_callback *scp = NULL, *next = NULL;
00343 
00344     <span class="keywordflow">if</span>(++_lock &gt; 1) {
00345         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00346                  <span class="stringliteral">"clear_callback called while callbacks _locked\n"</span>);
00347         netsnmp_assert(1==_lock);
00348     }
00349     DEBUGMSGTL((<span class="stringliteral">"callback"</span>, <span class="stringliteral">"clear callback\n"</span>));
00350     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_CALLBACK_IDS; i++) {
00351         <span class="keywordflow">for</span> (j = 0; j &lt; MAX_CALLBACK_SUBIDS; j++) {
00352             scp = thecallbacks[i][j]; 
00353             <span class="keywordflow">while</span> (scp != NULL) {
00354                 next = scp-&gt;next;
00355                 <span class=
"keywordflow">if</span> ((NULL != scp-&gt;sc_callback) &amp;&amp; (scp-&gt;sc_client_arg != NULL))
00356                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(scp-&gt;sc_client_arg);
00357                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(scp);
00358                 scp = next;
00359             }
00360             thecallbacks[i][j] = NULL;
00361         }
00362     }
00363     --_lock;
00364 }
00365 
00366 <span class="keyword">struct </span>snmp_gen_callback *
00367 snmp_callback_list(<span class="keywordtype">int</span> major, <span class="keywordtype">int</span> minor)
00368 {
00369     <span class="keywordflow">return</span> (thecallbacks[major][minor]);
00370 }
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small><!--#include virtual="/sfbutton.html" --><br />
    Generated on Thu Oct 28 21:46:56 2004 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

