<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>net-snmp: container_binary_array.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">net-snmp&#160;<span id="projectnumber">5.7</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">container_binary_array.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * container_binary_array.c</span>
<a name="l00003"></a>00003 <span class="comment"> * $Id$</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * see comments in header file.</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> */</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#if HAVE_IO_H</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span><span class="preprocessor">#include &lt;io.h&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#endif</span>
<a name="l00014"></a>00014 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#if HAVE_STDLIB_H</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#endif</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span><span class="preprocessor">#if HAVE_MALLOC_H</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span><span class="preprocessor">#include &lt;malloc.h&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#endif</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#if HAVE_STRING_H</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#else</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#include &lt;strings.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#endif</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;net-snmp/net-snmp-includes.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;net-snmp/library/container.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;net-snmp/library/container_binary_array.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="tools_8h.html">net-snmp/library/tools.h</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;net-snmp/library/snmp_assert.h&gt;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a><a class="code" href="structbinary__array__table__s.html">00036</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbinary__array__table__s.html">binary_array_table_s</a> {
<a name="l00037"></a>00037     <span class="keywordtype">size_t</span>                     max_size;   <span class="comment">/* Size of the current data table */</span>
<a name="l00038"></a>00038     <span class="keywordtype">size_t</span>                     count;      <span class="comment">/* Index of the next free entry */</span>
<a name="l00039"></a>00039     <span class="keywordtype">int</span>                        dirty;
<a name="l00040"></a>00040     <span class="keywordtype">void</span>                     **data;       <span class="comment">/* The table itself */</span>
<a name="l00041"></a>00041 } <a class="code" href="structbinary__array__table__s.html">binary_array_table</a>;
<a name="l00042"></a>00042 
<a name="l00043"></a><a class="code" href="structbinary__array__iterator__s.html">00043</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structbinary__array__iterator__s.html">binary_array_iterator_s</a> {
<a name="l00044"></a>00044     <a class="code" href="structnetsnmp__iterator__s.html">netsnmp_iterator</a> base;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     <span class="keywordtype">size_t</span>           pos;
<a name="l00047"></a>00047 } <a class="code" href="structbinary__array__iterator__s.html">binary_array_iterator</a>;
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="keyword">static</span> <a class="code" href="structnetsnmp__iterator__s.html">netsnmp_iterator</a> *_ba_iterator_get(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c);
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="comment">/**********************************************************************</span>
<a name="l00052"></a>00052 <span class="comment"> *</span>
<a name="l00053"></a>00053 <span class="comment"> * </span>
<a name="l00054"></a>00054 <span class="comment"> *</span>
<a name="l00055"></a>00055 <span class="comment"> */</span>
<a name="l00056"></a>00056 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00057"></a>00057 array_qsort(<span class="keywordtype">void</span> **data, <span class="keywordtype">int</span> first, <span class="keywordtype">int</span> last, netsnmp_container_compare *f)
<a name="l00058"></a>00058 {
<a name="l00059"></a>00059     <span class="keywordtype">int</span> i, j;
<a name="l00060"></a>00060     <span class="keywordtype">void</span> *mid, *tmp;
<a name="l00061"></a>00061     
<a name="l00062"></a>00062     i = first;
<a name="l00063"></a>00063     j = last;
<a name="l00064"></a>00064     mid = data[(first+last)/2];
<a name="l00065"></a>00065     
<a name="l00066"></a>00066     <span class="keywordflow">do</span> {
<a name="l00067"></a>00067         <span class="keywordflow">while</span> (i &lt; last &amp;&amp; (*f)(data[i], mid) &lt; 0)
<a name="l00068"></a>00068             ++i;
<a name="l00069"></a>00069         <span class="keywordflow">while</span> (j &gt; first &amp;&amp; (*f)(mid, data[j]) &lt; 0)
<a name="l00070"></a>00070             --j;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072         <span class="keywordflow">if</span>(i &lt; j) {
<a name="l00073"></a>00073             tmp = data[i];
<a name="l00074"></a>00074             data[i] = data[j];
<a name="l00075"></a>00075             data[j] = tmp;
<a name="l00076"></a>00076             ++i;
<a name="l00077"></a>00077             --j;
<a name="l00078"></a>00078         }
<a name="l00079"></a>00079         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == j) {
<a name="l00080"></a>00080             ++i;
<a name="l00081"></a>00081             --j;
<a name="l00082"></a>00082             <span class="keywordflow">break</span>;
<a name="l00083"></a>00083         }
<a name="l00084"></a>00084     } <span class="keywordflow">while</span>(i &lt;= j);
<a name="l00085"></a>00085 
<a name="l00086"></a>00086     <span class="keywordflow">if</span> (j &gt; first)
<a name="l00087"></a>00087         array_qsort(data, first, j, f);
<a name="l00088"></a>00088     
<a name="l00089"></a>00089     <span class="keywordflow">if</span> (i &lt; last)
<a name="l00090"></a>00090         array_qsort(data, i, last, f);
<a name="l00091"></a>00091 }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00094"></a>00094 Sort_Array(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c)
<a name="l00095"></a>00095 {
<a name="l00096"></a>00096     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00097"></a>00097     netsnmp_assert(t!=NULL);
<a name="l00098"></a>00098     netsnmp_assert(c-&gt;compare!=NULL);
<a name="l00099"></a>00099 
<a name="l00100"></a>00100     <span class="keywordflow">if</span> (c-&gt;flags &amp; CONTAINER_KEY_UNSORTED)
<a name="l00101"></a>00101         <span class="keywordflow">return</span> 0;
<a name="l00102"></a>00102 
<a name="l00103"></a>00103     <span class="keywordflow">if</span> (t-&gt;dirty) {
<a name="l00104"></a>00104         <span class="comment">/*</span>
<a name="l00105"></a>00105 <span class="comment">         * Sort the table </span>
<a name="l00106"></a>00106 <span class="comment">         */</span>
<a name="l00107"></a>00107         <span class="keywordflow">if</span> (t-&gt;count &gt; 1)
<a name="l00108"></a>00108             array_qsort(t-&gt;data, 0, t-&gt;count - 1, c-&gt;compare);
<a name="l00109"></a>00109         t-&gt;dirty = 0;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111         <span class="comment">/*</span>
<a name="l00112"></a>00112 <span class="comment">         * no way to know if it actually changed... just assume so.</span>
<a name="l00113"></a>00113 <span class="comment">         */</span>
<a name="l00114"></a>00114         ++c-&gt;sync;
<a name="l00115"></a>00115     }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117     <span class="keywordflow">return</span> 1;
<a name="l00118"></a>00118 }
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00121"></a>00121 linear_search(<span class="keyword">const</span> <span class="keywordtype">void</span> *val, <a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c)
<a name="l00122"></a>00122 {
<a name="l00123"></a>00123     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00124"></a>00124     <span class="keywordtype">size_t</span>             pos = 0;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126     if (!t-&gt;count)
<a name="l00127"></a>00127         <span class="keywordflow">return</span> -1;
<a name="l00128"></a>00128 
<a name="l00129"></a>00129     <span class="keywordflow">if</span> (! (c-&gt;flags &amp; CONTAINER_KEY_UNSORTED)) {
<a name="l00130"></a>00130         <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_ERR, <span class="stringliteral">&quot;linear search on sorted container %s?!?\n&quot;</span>,
<a name="l00131"></a>00131                  c-&gt;container_name);
<a name="l00132"></a>00132         <span class="keywordflow">return</span> -1;
<a name="l00133"></a>00133     }
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     <span class="keywordflow">for</span> (; pos &lt; t-&gt;count; ++pos) {
<a name="l00136"></a>00136         <span class="keywordflow">if</span> (c-&gt;compare(t-&gt;data[pos], val) == 0)
<a name="l00137"></a>00137             <span class="keywordflow">break</span>;
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139 
<a name="l00140"></a>00140     <span class="keywordflow">if</span> (pos &gt;= t-&gt;count)
<a name="l00141"></a>00141         <span class="keywordflow">return</span> -1;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143     <span class="keywordflow">return</span> pos;
<a name="l00144"></a>00144 }
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00147"></a>00147 binary_search(<span class="keyword">const</span> <span class="keywordtype">void</span> *val, <a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c, <span class="keywordtype">int</span> exact)
<a name="l00148"></a>00148 {
<a name="l00149"></a>00149     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00150"></a>00150     <span class="keywordtype">size_t</span>             len = t-&gt;count;
<a name="l00151"></a>00151     <span class="keywordtype">size_t</span>             half;
<a name="l00152"></a>00152     <span class="keywordtype">size_t</span>             middle = 0;
<a name="l00153"></a>00153     <span class="keywordtype">size_t</span>             first = 0;
<a name="l00154"></a>00154     <span class="keywordtype">int</span>                result = 0;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156     if (!len)
<a name="l00157"></a>00157         <span class="keywordflow">return</span> -1;
<a name="l00158"></a>00158 
<a name="l00159"></a>00159     <span class="keywordflow">if</span> (c-&gt;flags &amp; CONTAINER_KEY_UNSORTED) {
<a name="l00160"></a>00160         <span class="keywordflow">if</span> (!exact) {
<a name="l00161"></a>00161             <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_ERR, <span class="stringliteral">&quot;non-exact search on unsorted container %s?!?\n&quot;</span>,
<a name="l00162"></a>00162                      c-&gt;container_name);
<a name="l00163"></a>00163             <span class="keywordflow">return</span> -1;
<a name="l00164"></a>00164         }
<a name="l00165"></a>00165         <span class="keywordflow">return</span> linear_search(val, c);
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168     <span class="keywordflow">if</span> (t-&gt;dirty)
<a name="l00169"></a>00169         Sort_Array(c);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     <span class="keywordflow">while</span> (len &gt; 0) {
<a name="l00172"></a>00172         half = len &gt;&gt; 1;
<a name="l00173"></a>00173         middle = first;
<a name="l00174"></a>00174         middle += half;
<a name="l00175"></a>00175         <span class="keywordflow">if</span> ((result =
<a name="l00176"></a>00176              c-&gt;compare(t-&gt;data[middle], val)) &lt; 0) {
<a name="l00177"></a>00177             first = middle;
<a name="l00178"></a>00178             ++first;
<a name="l00179"></a>00179             len = len - half - 1;
<a name="l00180"></a>00180         } <span class="keywordflow">else</span> {
<a name="l00181"></a>00181             <span class="keywordflow">if</span>(result == 0) {
<a name="l00182"></a>00182                 first = middle;
<a name="l00183"></a>00183                 <span class="keywordflow">break</span>;
<a name="l00184"></a>00184             }
<a name="l00185"></a>00185             len = half;
<a name="l00186"></a>00186         }
<a name="l00187"></a>00187     }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189     <span class="keywordflow">if</span> (first &gt;= t-&gt;count)
<a name="l00190"></a>00190         <span class="keywordflow">return</span> -1;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192     <span class="keywordflow">if</span>(first != middle) {
<a name="l00193"></a>00193         <span class="comment">/* last compare wasn&#39;t against first, so get actual result */</span>
<a name="l00194"></a>00194         result = c-&gt;compare(t-&gt;data[first], val);
<a name="l00195"></a>00195     }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197     <span class="keywordflow">if</span>(result == 0) {
<a name="l00198"></a>00198         <span class="keywordflow">if</span> (!exact) {
<a name="l00199"></a>00199             <span class="keywordflow">if</span> (++first == t-&gt;count)
<a name="l00200"></a>00200                first = -1;
<a name="l00201"></a>00201         }
<a name="l00202"></a>00202     }
<a name="l00203"></a>00203     <span class="keywordflow">else</span> {
<a name="l00204"></a>00204         <span class="keywordflow">if</span>(exact)
<a name="l00205"></a>00205             first = -1;
<a name="l00206"></a>00206     }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208     <span class="keywordflow">return</span> first;
<a name="l00209"></a>00209 }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 NETSNMP_STATIC_INLINE <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *
<a name="l00212"></a>00212 netsnmp_binary_array_initialize(<span class="keywordtype">void</span>)
<a name="l00213"></a>00213 {
<a name="l00214"></a>00214     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     t = <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424" title="Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>);
<a name="l00217"></a>00217     <span class="keywordflow">if</span> (t == NULL)
<a name="l00218"></a>00218         <span class="keywordflow">return</span> NULL;
<a name="l00219"></a>00219 
<a name="l00220"></a>00220     t-&gt;max_size = 0;
<a name="l00221"></a>00221     t-&gt;count = 0;
<a name="l00222"></a>00222     t-&gt;dirty = 0;
<a name="l00223"></a>00223     t-&gt;data = NULL;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225     <span class="keywordflow">return</span> t;
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="keywordtype">void</span>
<a name="l00229"></a>00229 netsnmp_binary_array_release(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c)
<a name="l00230"></a>00230 {
<a name="l00231"></a>00231     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00232"></a>00232     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(t-&gt;data);
<a name="l00233"></a>00233     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(t);
<a name="l00234"></a>00234     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(c);
<a name="l00235"></a>00235 }
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 <span class="keywordtype">int</span>
<a name="l00238"></a>00238 netsnmp_binary_array_options_set(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c, <span class="keywordtype">int</span> <span class="keyword">set</span>, u_int flags)
<a name="l00239"></a>00239 {
<a name="l00240"></a>00240 <span class="preprocessor">#define BA_FLAGS (CONTAINER_KEY_ALLOW_DUPLICATES|CONTAINER_KEY_UNSORTED)</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span>
<a name="l00242"></a>00242     <span class="keywordflow">if</span> (<span class="keyword">set</span>) {
<a name="l00243"></a>00243         <span class="keywordflow">if</span> ((flags &amp; BA_FLAGS) == flags)
<a name="l00244"></a>00244             c-&gt;flags = flags;
<a name="l00245"></a>00245         <span class="keywordflow">else</span>
<a name="l00246"></a>00246             flags = (u_int)-1; <span class="comment">/* unsupported flag */</span>
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248     <span class="keywordflow">else</span>
<a name="l00249"></a>00249         <span class="keywordflow">return</span> ((c-&gt;flags &amp; flags) == flags);
<a name="l00250"></a>00250     <span class="keywordflow">return</span> flags;
<a name="l00251"></a>00251 }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 NETSNMP_STATIC_INLINE <span class="keywordtype">size_t</span>
<a name="l00254"></a>00254 netsnmp_binary_array_count(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c)
<a name="l00255"></a>00255 {
<a name="l00256"></a>00256     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00257"></a>00257     <span class="comment">/*</span>
<a name="l00258"></a>00258 <span class="comment">     * return count</span>
<a name="l00259"></a>00259 <span class="comment">     */</span>
<a name="l00260"></a>00260     <span class="keywordflow">return</span> t ? t-&gt;count : 0;
<a name="l00261"></a>00261 }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 NETSNMP_STATIC_INLINE <span class="keywordtype">void</span>           *
<a name="l00264"></a>00264 netsnmp_binary_array_get(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c, <span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">int</span> exact)
<a name="l00265"></a>00265 {
<a name="l00266"></a>00266     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00267"></a>00267     <span class="keywordtype">int</span>             index = 0;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269     <span class="comment">/*</span>
<a name="l00270"></a>00270 <span class="comment">     * if there is no data, return NULL;</span>
<a name="l00271"></a>00271 <span class="comment">     */</span>
<a name="l00272"></a>00272     if (!t-&gt;count)
<a name="l00273"></a>00273         <span class="keywordflow">return</span> NULL;
<a name="l00274"></a>00274 
<a name="l00275"></a>00275     <span class="comment">/*</span>
<a name="l00276"></a>00276 <span class="comment">     * if the table is dirty, sort it.</span>
<a name="l00277"></a>00277 <span class="comment">     */</span>
<a name="l00278"></a>00278     <span class="keywordflow">if</span> (t-&gt;dirty)
<a name="l00279"></a>00279         Sort_Array(c);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     <span class="comment">/*</span>
<a name="l00282"></a>00282 <span class="comment">     * if there is a key, search. Otherwise default is 0;</span>
<a name="l00283"></a>00283 <span class="comment">     */</span>
<a name="l00284"></a>00284     <span class="keywordflow">if</span> (key) {
<a name="l00285"></a>00285         <span class="keywordflow">if</span> ((index = binary_search(key, c, exact)) == -1)
<a name="l00286"></a>00286             <span class="keywordflow">return</span> NULL;
<a name="l00287"></a>00287     }
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     <span class="keywordflow">return</span> t-&gt;data[index];
<a name="l00290"></a>00290 }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 <span class="keywordtype">int</span>
<a name="l00293"></a>00293 netsnmp_binary_array_remove_at(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c, <span class="keywordtype">size_t</span> index, <span class="keywordtype">void</span> **save)
<a name="l00294"></a>00294 {
<a name="l00295"></a>00295     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     if (save)
<a name="l00298"></a>00298         *save = NULL;
<a name="l00299"></a>00299     
<a name="l00300"></a>00300     <span class="comment">/*</span>
<a name="l00301"></a>00301 <span class="comment">     * if there is no data, return NULL;</span>
<a name="l00302"></a>00302 <span class="comment">     */</span>
<a name="l00303"></a>00303     <span class="keywordflow">if</span> (!t-&gt;count)
<a name="l00304"></a>00304         <span class="keywordflow">return</span> 0;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306     <span class="comment">/*</span>
<a name="l00307"></a>00307 <span class="comment">     * find old data and save it, if ptr provided</span>
<a name="l00308"></a>00308 <span class="comment">     */</span>
<a name="l00309"></a>00309     <span class="keywordflow">if</span> (save)
<a name="l00310"></a>00310         *save = t-&gt;data[index];
<a name="l00311"></a>00311 
<a name="l00312"></a>00312     <span class="comment">/*</span>
<a name="l00313"></a>00313 <span class="comment">     * if entry was last item, just decrement count</span>
<a name="l00314"></a>00314 <span class="comment">     */</span>
<a name="l00315"></a>00315     --t-&gt;count;
<a name="l00316"></a>00316     <span class="keywordflow">if</span> (index != t-&gt;count) {
<a name="l00317"></a>00317         <span class="comment">/*</span>
<a name="l00318"></a>00318 <span class="comment">         * otherwise, shift array down</span>
<a name="l00319"></a>00319 <span class="comment">         */</span>
<a name="l00320"></a>00320         memmove(&amp;t-&gt;data[index], &amp;t-&gt;data[index+1],
<a name="l00321"></a>00321                 <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) * (t-&gt;count - index));
<a name="l00322"></a>00322 
<a name="l00323"></a>00323         ++c-&gt;sync;
<a name="l00324"></a>00324     }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326     <span class="keywordflow">return</span> 0;
<a name="l00327"></a>00327 }
<a name="l00328"></a>00328 <span class="keywordtype">int</span>
<a name="l00329"></a>00329 netsnmp_binary_array_remove(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c, <span class="keyword">const</span> <span class="keywordtype">void</span> *key, <span class="keywordtype">void</span> **save)
<a name="l00330"></a>00330 {
<a name="l00331"></a>00331     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00332"></a>00332     <span class="keywordtype">int</span>                index = 0;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334     if (save)
<a name="l00335"></a>00335         *save = NULL;
<a name="l00336"></a>00336     
<a name="l00337"></a>00337     <span class="comment">/*</span>
<a name="l00338"></a>00338 <span class="comment">     * if there is no data, return NULL;</span>
<a name="l00339"></a>00339 <span class="comment">     */</span>
<a name="l00340"></a>00340     <span class="keywordflow">if</span> (!t-&gt;count)
<a name="l00341"></a>00341         <span class="keywordflow">return</span> 0;
<a name="l00342"></a>00342 
<a name="l00343"></a>00343     <span class="comment">/*</span>
<a name="l00344"></a>00344 <span class="comment">     * if the table is dirty, sort it.</span>
<a name="l00345"></a>00345 <span class="comment">     */</span>
<a name="l00346"></a>00346     <span class="keywordflow">if</span> (t-&gt;dirty)
<a name="l00347"></a>00347         Sort_Array(c);
<a name="l00348"></a>00348 
<a name="l00349"></a>00349     <span class="comment">/*</span>
<a name="l00350"></a>00350 <span class="comment">     * search</span>
<a name="l00351"></a>00351 <span class="comment">     */</span>
<a name="l00352"></a>00352     <span class="keywordflow">if</span> ((index = binary_search(key, c, 1)) == -1)
<a name="l00353"></a>00353         <span class="keywordflow">return</span> -1;
<a name="l00354"></a>00354 
<a name="l00355"></a>00355     <span class="keywordflow">return</span> netsnmp_binary_array_remove_at(c, (<span class="keywordtype">size_t</span>)index, save);
<a name="l00356"></a>00356 }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 NETSNMP_STATIC_INLINE <span class="keywordtype">void</span>
<a name="l00359"></a>00359 netsnmp_binary_array_for_each(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c,
<a name="l00360"></a>00360                               netsnmp_container_obj_func *fe,
<a name="l00361"></a>00361                               <span class="keywordtype">void</span> *context, <span class="keywordtype">int</span> sort)
<a name="l00362"></a>00362 {
<a name="l00363"></a>00363     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00364"></a>00364     <span class="keywordtype">size_t</span>             i;
<a name="l00365"></a>00365 
<a name="l00366"></a>00366     if (sort &amp;&amp; t-&gt;dirty)
<a name="l00367"></a>00367         Sort_Array(c);
<a name="l00368"></a>00368 
<a name="l00369"></a>00369     <span class="keywordflow">for</span> (i = 0; i &lt; t-&gt;count; ++i)
<a name="l00370"></a>00370         (*fe) (t-&gt;data[i], context);
<a name="l00371"></a>00371 }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 NETSNMP_STATIC_INLINE <span class="keywordtype">void</span>
<a name="l00374"></a>00374 netsnmp_binary_array_clear(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c,
<a name="l00375"></a>00375                            netsnmp_container_obj_func *fe,
<a name="l00376"></a>00376                            <span class="keywordtype">void</span> *context)
<a name="l00377"></a>00377 {
<a name="l00378"></a>00378     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380     <span class="keywordflow">if</span>( NULL != fe ) {
<a name="l00381"></a>00381         <span class="keywordtype">size_t</span>             i;
<a name="l00382"></a>00382 
<a name="l00383"></a>00383         <span class="keywordflow">for</span> (i = 0; i &lt; t-&gt;count; ++i)
<a name="l00384"></a>00384             (*fe) (t-&gt;data[i], context);
<a name="l00385"></a>00385     }
<a name="l00386"></a>00386 
<a name="l00387"></a>00387     t-&gt;count = 0;
<a name="l00388"></a>00388     t-&gt;dirty = 0;
<a name="l00389"></a>00389     ++c-&gt;sync;
<a name="l00390"></a>00390 }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392 NETSNMP_STATIC_INLINE <span class="keywordtype">int</span>
<a name="l00393"></a>00393 netsnmp_binary_array_insert(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c, <span class="keyword">const</span> <span class="keywordtype">void</span> *entry)
<a name="l00394"></a>00394 {
<a name="l00395"></a>00395     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00396"></a>00396     <span class="keywordtype">int</span>             was_dirty = 0;
<a name="l00397"></a>00397     <span class="comment">/*</span>
<a name="l00398"></a>00398 <span class="comment">     * check for duplicates</span>
<a name="l00399"></a>00399 <span class="comment">     */</span>
<a name="l00400"></a>00400     if (! (c-&gt;flags &amp; CONTAINER_KEY_ALLOW_DUPLICATES)) {
<a name="l00401"></a>00401         was_dirty = t-&gt;dirty;
<a name="l00402"></a>00402         <span class="keywordflow">if</span> (NULL != netsnmp_binary_array_get(c, entry, 1)) {
<a name="l00403"></a>00403             DEBUGMSGTL((<span class="stringliteral">&quot;container&quot;</span>,<span class="stringliteral">&quot;not inserting duplicate key\n&quot;</span>));
<a name="l00404"></a>00404             <span class="keywordflow">return</span> -1;
<a name="l00405"></a>00405         }
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407     
<a name="l00408"></a>00408     <span class="comment">/*</span>
<a name="l00409"></a>00409 <span class="comment">     * check if we need to resize the array</span>
<a name="l00410"></a>00410 <span class="comment">     */</span>
<a name="l00411"></a>00411     <span class="keywordflow">if</span> (t-&gt;max_size &lt;= t-&gt;count) {
<a name="l00412"></a>00412         <span class="comment">/*</span>
<a name="l00413"></a>00413 <span class="comment">         * Table is full, so extend it to double the size, or use 10 elements</span>
<a name="l00414"></a>00414 <span class="comment">         * if it is empty.</span>
<a name="l00415"></a>00415 <span class="comment">         */</span>
<a name="l00416"></a>00416         <span class="keywordtype">size_t</span> <span class="keyword">const</span> new_max = t-&gt;max_size &gt; 0 ? 2 * t-&gt;max_size : 10;
<a name="l00417"></a>00417         <span class="keywordtype">void</span> ** <span class="keyword">const</span> new_data =
<a name="l00418"></a>00418             (<span class="keywordtype">void</span>**) realloc(t-&gt;data, new_max * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00419"></a>00419 
<a name="l00420"></a>00420         <span class="keywordflow">if</span> (new_data == NULL)
<a name="l00421"></a>00421             <span class="keywordflow">return</span> -1;
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         memset(new_data + t-&gt;max_size, 0x0,
<a name="l00424"></a>00424                (new_max - t-&gt;max_size) * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00425"></a>00425 
<a name="l00426"></a>00426         t-&gt;data = new_data;
<a name="l00427"></a>00427         t-&gt;max_size = new_max;
<a name="l00428"></a>00428     }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430     <span class="comment">/*</span>
<a name="l00431"></a>00431 <span class="comment">     * Insert the new entry into the data array</span>
<a name="l00432"></a>00432 <span class="comment">     */</span>
<a name="l00433"></a>00433     t-&gt;data[t-&gt;count++] = <a class="code" href="group__util.html#ga6310fec832043acba37f99871097b137" title="Cast away constness without that gcc -Wcast-qual prints a compiler warning, similar to const_cast&lt;&gt; i...">NETSNMP_REMOVE_CONST</a>(<span class="keywordtype">void</span> *, entry);
<a name="l00434"></a>00434     t-&gt;dirty = 1;
<a name="l00435"></a>00435 
<a name="l00436"></a>00436     <span class="comment">/*</span>
<a name="l00437"></a>00437 <span class="comment">     * if array was dirty before we called get, sync was incremented when</span>
<a name="l00438"></a>00438 <span class="comment">     * get called SortArray. If we didn&#39;t call get or the array wasn&#39;t dirty,</span>
<a name="l00439"></a>00439 <span class="comment">     * bump sync now.</span>
<a name="l00440"></a>00440 <span class="comment">     */</span>
<a name="l00441"></a>00441     <span class="keywordflow">if</span> (!was_dirty)
<a name="l00442"></a>00442         ++c-&gt;sync;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444     <span class="keywordflow">return</span> 0;
<a name="l00445"></a>00445 }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="comment">/**********************************************************************</span>
<a name="l00448"></a>00448 <span class="comment"> *</span>
<a name="l00449"></a>00449 <span class="comment"> * Special case support for subsets</span>
<a name="l00450"></a>00450 <span class="comment"> *</span>
<a name="l00451"></a>00451 <span class="comment"> */</span>
<a name="l00452"></a>00452 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00453"></a>00453 binary_search_for_start(<a class="code" href="structnetsnmp__index__s.html">netsnmp_index</a> *val, <a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c)
<a name="l00454"></a>00454 {
<a name="l00455"></a>00455     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00456"></a>00456     <span class="keywordtype">size_t</span>             len = t-&gt;count;
<a name="l00457"></a>00457     <span class="keywordtype">size_t</span>             half;
<a name="l00458"></a>00458     <span class="keywordtype">size_t</span>             middle;
<a name="l00459"></a>00459     <span class="keywordtype">size_t</span>             first = 0;
<a name="l00460"></a>00460     <span class="keywordtype">int</span>                result = 0;
<a name="l00461"></a>00461 
<a name="l00462"></a>00462     if (!len)
<a name="l00463"></a>00463         <span class="keywordflow">return</span> -1;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465     <span class="keywordflow">if</span> (t-&gt;dirty)
<a name="l00466"></a>00466         Sort_Array(c);
<a name="l00467"></a>00467 
<a name="l00468"></a>00468     <span class="keywordflow">while</span> (len &gt; 0) {
<a name="l00469"></a>00469         half = len &gt;&gt; 1;
<a name="l00470"></a>00470         middle = first;
<a name="l00471"></a>00471         middle += half;
<a name="l00472"></a>00472         <span class="keywordflow">if</span> ((result = c-&gt;ncompare(t-&gt;data[middle], val)) &lt; 0) {
<a name="l00473"></a>00473             first = middle;
<a name="l00474"></a>00474             ++first;
<a name="l00475"></a>00475             len = len - half - 1;
<a name="l00476"></a>00476         } <span class="keywordflow">else</span>
<a name="l00477"></a>00477             len = half;
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479 
<a name="l00480"></a>00480     <span class="keywordflow">if</span> ((first &gt;= t-&gt;count) ||
<a name="l00481"></a>00481         c-&gt;ncompare(t-&gt;data[first], val) != 0)
<a name="l00482"></a>00482         <span class="keywordflow">return</span> -1;
<a name="l00483"></a>00483 
<a name="l00484"></a>00484     <span class="keywordflow">return</span> first;
<a name="l00485"></a>00485 }
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 <span class="keywordtype">void</span>          **
<a name="l00488"></a>00488 netsnmp_binary_array_get_subset(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c, <span class="keywordtype">void</span> *key, <span class="keywordtype">int</span> *len)
<a name="l00489"></a>00489 {
<a name="l00490"></a>00490     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00491"></a>00491     <span class="keywordtype">void</span>          **subset;
<a name="l00492"></a>00492     <span class="keywordtype">int</span>             start, end;
<a name="l00493"></a>00493     <span class="keywordtype">size_t</span>          i;
<a name="l00494"></a>00494 
<a name="l00495"></a>00495     <span class="comment">/*</span>
<a name="l00496"></a>00496 <span class="comment">     * if there is no data, return NULL;</span>
<a name="l00497"></a>00497 <span class="comment">     */</span>
<a name="l00498"></a>00498     if (!c || !key)
<a name="l00499"></a>00499         <span class="keywordflow">return</span> NULL;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501     t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00502"></a>00502     netsnmp_assert(c-&gt;ncompare);
<a name="l00503"></a>00503     <span class="keywordflow">if</span> (!t-&gt;count | !c-&gt;ncompare)
<a name="l00504"></a>00504         <span class="keywordflow">return</span> NULL;
<a name="l00505"></a>00505 
<a name="l00506"></a>00506     <span class="comment">/*</span>
<a name="l00507"></a>00507 <span class="comment">     * if the table is dirty, sort it.</span>
<a name="l00508"></a>00508 <span class="comment">     */</span>
<a name="l00509"></a>00509     <span class="keywordflow">if</span> (t-&gt;dirty)
<a name="l00510"></a>00510         Sort_Array(c);
<a name="l00511"></a>00511 
<a name="l00512"></a>00512     <span class="comment">/*</span>
<a name="l00513"></a>00513 <span class="comment">     * find matching items</span>
<a name="l00514"></a>00514 <span class="comment">     */</span>
<a name="l00515"></a>00515     start = end = binary_search_for_start((<a class="code" href="structnetsnmp__index__s.html">netsnmp_index</a> *)key, c);
<a name="l00516"></a>00516     <span class="keywordflow">if</span> (start == -1)
<a name="l00517"></a>00517         <span class="keywordflow">return</span> NULL;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519     <span class="keywordflow">for</span> (i = start + 1; i &lt; t-&gt;count; ++i) {
<a name="l00520"></a>00520         <span class="keywordflow">if</span> (0 != c-&gt;ncompare(t-&gt;data[i], key))
<a name="l00521"></a>00521             <span class="keywordflow">break</span>;
<a name="l00522"></a>00522         ++end;
<a name="l00523"></a>00523     }
<a name="l00524"></a>00524 
<a name="l00525"></a>00525     *len = end - start + 1;
<a name="l00526"></a>00526     subset = (<span class="keywordtype">void</span> **)malloc((*len) * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00527"></a>00527     <span class="keywordflow">if</span> (subset)
<a name="l00528"></a>00528         memcpy(subset, &amp;t-&gt;data[start], <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) * (*len));
<a name="l00529"></a>00529 
<a name="l00530"></a>00530     <span class="keywordflow">return</span> subset;
<a name="l00531"></a>00531 }
<a name="l00532"></a>00532 
<a name="l00533"></a>00533 <span class="comment">/**********************************************************************</span>
<a name="l00534"></a>00534 <span class="comment"> *</span>
<a name="l00535"></a>00535 <span class="comment"> * container</span>
<a name="l00536"></a>00536 <span class="comment"> *</span>
<a name="l00537"></a>00537 <span class="comment"> */</span>
<a name="l00538"></a>00538 <span class="keyword">static</span> <span class="keywordtype">void</span> *
<a name="l00539"></a>00539 _ba_find(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *container, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)
<a name="l00540"></a>00540 {
<a name="l00541"></a>00541     <span class="keywordflow">return</span> netsnmp_binary_array_get(container, data, 1);
<a name="l00542"></a>00542 }
<a name="l00543"></a>00543 
<a name="l00544"></a>00544 <span class="keyword">static</span> <span class="keywordtype">void</span> *
<a name="l00545"></a>00545 _ba_find_next(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *container, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)
<a name="l00546"></a>00546 {
<a name="l00547"></a>00547     <span class="keywordflow">return</span> netsnmp_binary_array_get(container, data, 0);
<a name="l00548"></a>00548 }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00551"></a>00551 _ba_insert(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *container, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)
<a name="l00552"></a>00552 {
<a name="l00553"></a>00553     <span class="keywordflow">return</span> netsnmp_binary_array_insert(container, data);
<a name="l00554"></a>00554 }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00557"></a>00557 _ba_remove(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *container, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)
<a name="l00558"></a>00558 {
<a name="l00559"></a>00559     <span class="keywordflow">return</span> netsnmp_binary_array_remove(container,data, NULL);
<a name="l00560"></a>00560 }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00563"></a>00563 _ba_free(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *container)
<a name="l00564"></a>00564 {
<a name="l00565"></a>00565     netsnmp_binary_array_release(container);
<a name="l00566"></a>00566     <span class="keywordflow">return</span> 0;
<a name="l00567"></a>00567 }
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 <span class="keyword">static</span> <span class="keywordtype">size_t</span>
<a name="l00570"></a>00570 _ba_size(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *container)
<a name="l00571"></a>00571 {
<a name="l00572"></a>00572     <span class="keywordflow">return</span> netsnmp_binary_array_count(container);
<a name="l00573"></a>00573 }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00576"></a>00576 _ba_for_each(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *container, netsnmp_container_obj_func *f,
<a name="l00577"></a>00577              <span class="keywordtype">void</span> *context)
<a name="l00578"></a>00578 {
<a name="l00579"></a>00579     netsnmp_binary_array_for_each(container, f, context, 1);
<a name="l00580"></a>00580 }
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00583"></a>00583 _ba_clear(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *container, netsnmp_container_obj_func *f,
<a name="l00584"></a>00584              <span class="keywordtype">void</span> *context)
<a name="l00585"></a>00585 {
<a name="l00586"></a>00586     netsnmp_binary_array_clear(container, f, context);
<a name="l00587"></a>00587 }
<a name="l00588"></a>00588 
<a name="l00589"></a>00589 <span class="keyword">static</span> <a class="code" href="structnetsnmp__void__array__s.html">netsnmp_void_array</a> *
<a name="l00590"></a>00590 _ba_get_subset(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *container, <span class="keywordtype">void</span> *data)
<a name="l00591"></a>00591 {
<a name="l00592"></a>00592     <a class="code" href="structnetsnmp__void__array__s.html">netsnmp_void_array</a> * va;
<a name="l00593"></a>00593     <span class="keywordtype">void</span> ** rtn;
<a name="l00594"></a>00594     <span class="keywordtype">int</span> len;
<a name="l00595"></a>00595 
<a name="l00596"></a>00596     rtn = netsnmp_binary_array_get_subset(container, data, &amp;len);
<a name="l00597"></a>00597     <span class="keywordflow">if</span> ((NULL==rtn) || (len &lt;=0))
<a name="l00598"></a>00598         <span class="keywordflow">return</span> NULL;
<a name="l00599"></a>00599     
<a name="l00600"></a>00600     va = <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424" title="Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href="structnetsnmp__void__array__s.html">netsnmp_void_array</a>);
<a name="l00601"></a>00601     <span class="keywordflow">if</span> (NULL==va)
<a name="l00602"></a>00602     {
<a name="l00603"></a>00603         free (rtn);
<a name="l00604"></a>00604         <span class="keywordflow">return</span> NULL;
<a name="l00605"></a>00605     }
<a name="l00606"></a>00606     
<a name="l00607"></a>00607     va-&gt;size = len;
<a name="l00608"></a>00608     va-&gt;array = rtn;
<a name="l00609"></a>00609 
<a name="l00610"></a>00610     <span class="keywordflow">return</span> va;
<a name="l00611"></a>00611 }
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 <span class="keyword">static</span> <span class="keywordtype">int</span> _ba_options(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c, <span class="keywordtype">int</span> <span class="keyword">set</span>, u_int flags)
<a name="l00614"></a>00614 {
<a name="l00615"></a>00615     <span class="keywordflow">return</span> netsnmp_binary_array_options_set(c, <span class="keyword">set</span>, flags);
<a name="l00616"></a>00616 }
<a name="l00617"></a>00617 
<a name="l00618"></a>00618 <span class="keyword">static</span> <a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *
<a name="l00619"></a>00619 _ba_duplicate(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c, <span class="keywordtype">void</span> *ctx, u_int flags)
<a name="l00620"></a>00620 {
<a name="l00621"></a>00621     <a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *dup;
<a name="l00622"></a>00622     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *dupt, *t;
<a name="l00623"></a>00623 
<a name="l00624"></a>00624     <span class="keywordflow">if</span> (flags) {
<a name="l00625"></a>00625         <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_ERR, <span class="stringliteral">&quot;binary arry duplicate does not supprt flags yet\n&quot;</span>);
<a name="l00626"></a>00626         <span class="keywordflow">return</span> NULL;
<a name="l00627"></a>00627     }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629     dup = netsnmp_container_get_binary_array();
<a name="l00630"></a>00630     <span class="keywordflow">if</span> (NULL == dup) {
<a name="l00631"></a>00631         <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_ERR,<span class="stringliteral">&quot; no memory for binary array duplicate\n&quot;</span>);
<a name="l00632"></a>00632         <span class="keywordflow">return</span> NULL;
<a name="l00633"></a>00633     }
<a name="l00634"></a>00634     <span class="comment">/*</span>
<a name="l00635"></a>00635 <span class="comment">     * deal with container stuff</span>
<a name="l00636"></a>00636 <span class="comment">     */</span>
<a name="l00637"></a>00637     <span class="keywordflow">if</span> (netsnmp_container_data_dup(dup, c) != 0) {
<a name="l00638"></a>00638         netsnmp_binary_array_release(dup);
<a name="l00639"></a>00639         <span class="keywordflow">return</span> NULL;
<a name="l00640"></a>00640     }
<a name="l00641"></a>00641 
<a name="l00642"></a>00642     <span class="comment">/*</span>
<a name="l00643"></a>00643 <span class="comment">     * deal with data</span>
<a name="l00644"></a>00644 <span class="comment">     */</span>
<a name="l00645"></a>00645     dupt = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)dup-&gt;container_data;
<a name="l00646"></a>00646     t = (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)c-&gt;container_data;
<a name="l00647"></a>00647 
<a name="l00648"></a>00648     dupt-&gt;max_size = t-&gt;max_size;
<a name="l00649"></a>00649     dupt-&gt;count = t-&gt;count;
<a name="l00650"></a>00650     dupt-&gt;dirty = t-&gt;dirty;
<a name="l00651"></a>00651 
<a name="l00652"></a>00652     <span class="comment">/*</span>
<a name="l00653"></a>00653 <span class="comment">     * shallow copy</span>
<a name="l00654"></a>00654 <span class="comment">     */</span>
<a name="l00655"></a>00655     dupt-&gt;data = (<span class="keywordtype">void</span>**) malloc(dupt-&gt;max_size * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00656"></a>00656     <span class="keywordflow">if</span> (NULL == dupt-&gt;data) {
<a name="l00657"></a>00657         <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_ERR, <span class="stringliteral">&quot;no memory for binary array duplicate\n&quot;</span>);
<a name="l00658"></a>00658         netsnmp_binary_array_release(dup);
<a name="l00659"></a>00659         <span class="keywordflow">return</span> NULL;
<a name="l00660"></a>00660     }
<a name="l00661"></a>00661 
<a name="l00662"></a>00662     memcpy(dupt-&gt;data, t-&gt;data, dupt-&gt;max_size * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00663"></a>00663 
<a name="l00664"></a>00664     <span class="keywordflow">return</span> dup;
<a name="l00665"></a>00665 }
<a name="l00666"></a>00666 
<a name="l00667"></a>00667 <a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *
<a name="l00668"></a>00668 netsnmp_container_get_binary_array(<span class="keywordtype">void</span>)
<a name="l00669"></a>00669 {
<a name="l00670"></a>00670     <span class="comment">/*</span>
<a name="l00671"></a>00671 <span class="comment">     * allocate memory</span>
<a name="l00672"></a>00672 <span class="comment">     */</span>
<a name="l00673"></a>00673     <a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c = <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424" title="Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a>);
<a name="l00674"></a>00674     <span class="keywordflow">if</span> (NULL==c) {
<a name="l00675"></a>00675         <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_ERR, <span class="stringliteral">&quot;couldn&#39;t allocate memory\n&quot;</span>);
<a name="l00676"></a>00676         <span class="keywordflow">return</span> NULL;
<a name="l00677"></a>00677     }
<a name="l00678"></a>00678 
<a name="l00679"></a>00679     c-&gt;container_data = netsnmp_binary_array_initialize();
<a name="l00680"></a>00680 
<a name="l00681"></a>00681     <span class="comment">/*</span>
<a name="l00682"></a>00682 <span class="comment">     * NOTE: CHANGES HERE MUST BE DUPLICATED IN duplicate AS WELL!!</span>
<a name="l00683"></a>00683 <span class="comment">     */</span>
<a name="l00684"></a>00684     netsnmp_init_container(c, NULL, _ba_free, _ba_size, NULL, _ba_insert,
<a name="l00685"></a>00685                            _ba_remove, _ba_find);
<a name="l00686"></a>00686     c-&gt;find_next = _ba_find_next;
<a name="l00687"></a>00687     c-&gt;get_subset = _ba_get_subset;
<a name="l00688"></a>00688     c-&gt;get_iterator = _ba_iterator_get;
<a name="l00689"></a>00689     c-&gt;for_each = _ba_for_each;
<a name="l00690"></a>00690     c-&gt;clear = _ba_clear;
<a name="l00691"></a>00691     c-&gt;options = _ba_options;
<a name="l00692"></a>00692     c-&gt;duplicate = _ba_duplicate;
<a name="l00693"></a>00693         
<a name="l00694"></a>00694     <span class="keywordflow">return</span> c;
<a name="l00695"></a>00695 }
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 <a class="code" href="structnetsnmp__factory__s.html">netsnmp_factory</a> *
<a name="l00698"></a>00698 netsnmp_container_get_binary_array_factory(<span class="keywordtype">void</span>)
<a name="l00699"></a>00699 {
<a name="l00700"></a>00700     <span class="keyword">static</span> <a class="code" href="structnetsnmp__factory__s.html">netsnmp_factory</a> f = { <span class="stringliteral">&quot;binary_array&quot;</span>,
<a name="l00701"></a>00701                                  (netsnmp_factory_produce_f*)
<a name="l00702"></a>00702                                  netsnmp_container_get_binary_array };
<a name="l00703"></a>00703     
<a name="l00704"></a>00704     <span class="keywordflow">return</span> &amp;f;
<a name="l00705"></a>00705 }
<a name="l00706"></a>00706 
<a name="l00707"></a>00707 <span class="keywordtype">void</span>
<a name="l00708"></a>00708 netsnmp_container_binary_array_init(<span class="keywordtype">void</span>)
<a name="l00709"></a>00709 {
<a name="l00710"></a>00710     netsnmp_container_register(<span class="stringliteral">&quot;binary_array&quot;</span>,
<a name="l00711"></a>00711                                netsnmp_container_get_binary_array_factory());
<a name="l00712"></a>00712 }
<a name="l00713"></a>00713 
<a name="l00714"></a>00714 <span class="comment">/**********************************************************************</span>
<a name="l00715"></a>00715 <span class="comment"> *</span>
<a name="l00716"></a>00716 <span class="comment"> * iterator</span>
<a name="l00717"></a>00717 <span class="comment"> *</span>
<a name="l00718"></a>00718 <span class="comment"> */</span>
<a name="l00719"></a>00719 NETSNMP_STATIC_INLINE <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *
<a name="l00720"></a>00720 _ba_it2cont(<a class="code" href="structbinary__array__iterator__s.html">binary_array_iterator</a> *it)
<a name="l00721"></a>00721 {
<a name="l00722"></a>00722     <span class="keywordflow">if</span>(NULL == it) {
<a name="l00723"></a>00723         netsnmp_assert(NULL != it);
<a name="l00724"></a>00724         <span class="keywordflow">return</span> NULL;
<a name="l00725"></a>00725     }
<a name="l00726"></a>00726     <span class="keywordflow">if</span>(NULL == it-&gt;base.container) {
<a name="l00727"></a>00727         netsnmp_assert(NULL != it-&gt;base.container);
<a name="l00728"></a>00728         <span class="keywordflow">return</span> NULL;
<a name="l00729"></a>00729     }
<a name="l00730"></a>00730     <span class="keywordflow">if</span>(NULL == it-&gt;base.container-&gt;container_data) {
<a name="l00731"></a>00731         netsnmp_assert(NULL != it-&gt;base.container-&gt;container_data);
<a name="l00732"></a>00732         <span class="keywordflow">return</span> NULL;
<a name="l00733"></a>00733     }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735     <span class="keywordflow">return</span> (<a class="code" href="structbinary__array__table__s.html">binary_array_table</a>*)(it-&gt;base.container-&gt;container_data);
<a name="l00736"></a>00736 }
<a name="l00737"></a>00737 
<a name="l00738"></a>00738 NETSNMP_STATIC_INLINE <span class="keywordtype">void</span> *
<a name="l00739"></a>00739 _ba_iterator_position(<a class="code" href="structbinary__array__iterator__s.html">binary_array_iterator</a> *it, <span class="keywordtype">size_t</span> pos)
<a name="l00740"></a>00740 {
<a name="l00741"></a>00741     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a> *t = _ba_it2cont(it);
<a name="l00742"></a>00742     <span class="keywordflow">if</span> (NULL == t)
<a name="l00743"></a>00743         <span class="keywordflow">return</span> t; <span class="comment">/* msg already logged */</span>
<a name="l00744"></a>00744 
<a name="l00745"></a>00745     <span class="keywordflow">if</span>(it-&gt;base.container-&gt;sync != it-&gt;base.sync) {
<a name="l00746"></a>00746         DEBUGMSGTL((<span class="stringliteral">&quot;container:iterator&quot;</span>, <span class="stringliteral">&quot;out of sync\n&quot;</span>));
<a name="l00747"></a>00747         <span class="keywordflow">return</span> NULL;
<a name="l00748"></a>00748     }
<a name="l00749"></a>00749     
<a name="l00750"></a>00750     <span class="keywordflow">if</span>(0 == t-&gt;count) {
<a name="l00751"></a>00751         DEBUGMSGTL((<span class="stringliteral">&quot;container:iterator&quot;</span>, <span class="stringliteral">&quot;empty\n&quot;</span>));
<a name="l00752"></a>00752         <span class="keywordflow">return</span> NULL;
<a name="l00753"></a>00753     }
<a name="l00754"></a>00754     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pos &gt;= t-&gt;count) {
<a name="l00755"></a>00755         DEBUGMSGTL((<span class="stringliteral">&quot;container:iterator&quot;</span>, <span class="stringliteral">&quot;end of container\n&quot;</span>));
<a name="l00756"></a>00756         <span class="keywordflow">return</span> NULL;
<a name="l00757"></a>00757     }
<a name="l00758"></a>00758 
<a name="l00759"></a>00759     <span class="keywordflow">return</span> t-&gt;data[ pos ];
<a name="l00760"></a>00760 }
<a name="l00761"></a>00761 
<a name="l00762"></a>00762 <span class="keyword">static</span> <span class="keywordtype">void</span> *
<a name="l00763"></a>00763 _ba_iterator_curr(<a class="code" href="structbinary__array__iterator__s.html">binary_array_iterator</a> *it)
<a name="l00764"></a>00764 {
<a name="l00765"></a>00765     <span class="keywordflow">if</span>(NULL == it) {
<a name="l00766"></a>00766         netsnmp_assert(NULL != it);
<a name="l00767"></a>00767         <span class="keywordflow">return</span> NULL;
<a name="l00768"></a>00768     }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770     <span class="keywordflow">return</span> _ba_iterator_position(it, it-&gt;pos);
<a name="l00771"></a>00771 }
<a name="l00772"></a>00772 
<a name="l00773"></a>00773 <span class="keyword">static</span> <span class="keywordtype">void</span> *
<a name="l00774"></a>00774 _ba_iterator_first(<a class="code" href="structbinary__array__iterator__s.html">binary_array_iterator</a> *it)
<a name="l00775"></a>00775 {
<a name="l00776"></a>00776     <span class="keywordflow">return</span> _ba_iterator_position(it, 0);
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 <span class="keyword">static</span> <span class="keywordtype">void</span> *
<a name="l00780"></a>00780 _ba_iterator_next(<a class="code" href="structbinary__array__iterator__s.html">binary_array_iterator</a> *it)
<a name="l00781"></a>00781 {
<a name="l00782"></a>00782     <span class="keywordflow">if</span>(NULL == it) {
<a name="l00783"></a>00783         netsnmp_assert(NULL != it);
<a name="l00784"></a>00784         <span class="keywordflow">return</span> NULL;
<a name="l00785"></a>00785     }
<a name="l00786"></a>00786 
<a name="l00787"></a>00787     ++it-&gt;pos;
<a name="l00788"></a>00788 
<a name="l00789"></a>00789     <span class="keywordflow">return</span> _ba_iterator_position(it, it-&gt;pos);
<a name="l00790"></a>00790 }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 <span class="keyword">static</span> <span class="keywordtype">void</span> *
<a name="l00793"></a>00793 _ba_iterator_last(<a class="code" href="structbinary__array__iterator__s.html">binary_array_iterator</a> *it)
<a name="l00794"></a>00794 {
<a name="l00795"></a>00795     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a>* t = _ba_it2cont(it);
<a name="l00796"></a>00796     <span class="keywordflow">if</span>(NULL == t) {
<a name="l00797"></a>00797         netsnmp_assert(NULL != t);
<a name="l00798"></a>00798         <span class="keywordflow">return</span> NULL;
<a name="l00799"></a>00799     }
<a name="l00800"></a>00800     
<a name="l00801"></a>00801     <span class="keywordflow">return</span> _ba_iterator_position(it, t-&gt;count - 1 );
<a name="l00802"></a>00802 }
<a name="l00803"></a>00803 
<a name="l00804"></a>00804 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00805"></a>00805 _ba_iterator_remove(<a class="code" href="structbinary__array__iterator__s.html">binary_array_iterator</a> *it)
<a name="l00806"></a>00806 {
<a name="l00807"></a>00807     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a>* t = _ba_it2cont(it);
<a name="l00808"></a>00808     <span class="keywordflow">if</span>(NULL == t) {
<a name="l00809"></a>00809         netsnmp_assert(NULL != t);
<a name="l00810"></a>00810         <span class="keywordflow">return</span> -1;
<a name="l00811"></a>00811     }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813     <span class="comment">/*</span>
<a name="l00814"></a>00814 <span class="comment">     * since this iterator was used for the remove, keep it in sync with</span>
<a name="l00815"></a>00815 <span class="comment">     * the container. Also, back up one so that next will be the position</span>
<a name="l00816"></a>00816 <span class="comment">     * that was just removed.</span>
<a name="l00817"></a>00817 <span class="comment">     */</span>
<a name="l00818"></a>00818     ++it-&gt;base.sync;
<a name="l00819"></a>00819     <span class="keywordflow">return</span> netsnmp_binary_array_remove_at(it-&gt;base.container, it-&gt;pos--, NULL);
<a name="l00820"></a>00820 
<a name="l00821"></a>00821 }
<a name="l00822"></a>00822 
<a name="l00823"></a>00823 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00824"></a>00824 _ba_iterator_reset(<a class="code" href="structbinary__array__iterator__s.html">binary_array_iterator</a> *it)
<a name="l00825"></a>00825 {
<a name="l00826"></a>00826     <a class="code" href="structbinary__array__table__s.html">binary_array_table</a>* t = _ba_it2cont(it);
<a name="l00827"></a>00827     <span class="keywordflow">if</span>(NULL == t) {
<a name="l00828"></a>00828         netsnmp_assert(NULL != t);
<a name="l00829"></a>00829         <span class="keywordflow">return</span> -1;
<a name="l00830"></a>00830     }
<a name="l00831"></a>00831 
<a name="l00832"></a>00832     <span class="keywordflow">if</span> (t-&gt;dirty)
<a name="l00833"></a>00833         Sort_Array(it-&gt;base.container);
<a name="l00834"></a>00834 
<a name="l00835"></a>00835     <span class="comment">/*</span>
<a name="l00836"></a>00836 <span class="comment">     * save sync count, to make sure container doesn&#39;t change while</span>
<a name="l00837"></a>00837 <span class="comment">     * iterator is in use.</span>
<a name="l00838"></a>00838 <span class="comment">     */</span>
<a name="l00839"></a>00839     it-&gt;base.sync = it-&gt;base.container-&gt;sync;
<a name="l00840"></a>00840 
<a name="l00841"></a>00841     it-&gt;pos = 0;
<a name="l00842"></a>00842 
<a name="l00843"></a>00843     <span class="keywordflow">return</span> 0;
<a name="l00844"></a>00844 }
<a name="l00845"></a>00845 
<a name="l00846"></a>00846 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00847"></a>00847 _ba_iterator_release(<a class="code" href="structnetsnmp__iterator__s.html">netsnmp_iterator</a> *it)
<a name="l00848"></a>00848 {
<a name="l00849"></a>00849     free(it);
<a name="l00850"></a>00850 
<a name="l00851"></a>00851     <span class="keywordflow">return</span> 0;
<a name="l00852"></a>00852 }
<a name="l00853"></a>00853 
<a name="l00854"></a>00854 <span class="keyword">static</span> <a class="code" href="structnetsnmp__iterator__s.html">netsnmp_iterator</a> *
<a name="l00855"></a>00855 _ba_iterator_get(<a class="code" href="structnetsnmp__container__s.html">netsnmp_container</a> *c)
<a name="l00856"></a>00856 {
<a name="l00857"></a>00857     <a class="code" href="structbinary__array__iterator__s.html">binary_array_iterator</a>* it;
<a name="l00858"></a>00858 
<a name="l00859"></a>00859     <span class="keywordflow">if</span>(NULL == c)
<a name="l00860"></a>00860         <span class="keywordflow">return</span> NULL;
<a name="l00861"></a>00861 
<a name="l00862"></a>00862     it = <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424" title="Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href="structbinary__array__iterator__s.html">binary_array_iterator</a>);
<a name="l00863"></a>00863     <span class="keywordflow">if</span>(NULL == it)
<a name="l00864"></a>00864         <span class="keywordflow">return</span> NULL;
<a name="l00865"></a>00865 
<a name="l00866"></a>00866     it-&gt;base.container = c;
<a name="l00867"></a>00867     
<a name="l00868"></a>00868     it-&gt;base.first = (netsnmp_iterator_rtn*)_ba_iterator_first;
<a name="l00869"></a>00869     it-&gt;base.next = (netsnmp_iterator_rtn*)_ba_iterator_next;
<a name="l00870"></a>00870     it-&gt;base.curr = (netsnmp_iterator_rtn*)_ba_iterator_curr;
<a name="l00871"></a>00871     it-&gt;base.last = (netsnmp_iterator_rtn*)_ba_iterator_last;
<a name="l00872"></a>00872     it-&gt;base.remove = (netsnmp_iterator_rc*)_ba_iterator_remove;
<a name="l00873"></a>00873     it-&gt;base.reset = (netsnmp_iterator_rc*)_ba_iterator_reset;
<a name="l00874"></a>00874     it-&gt;base.release = (netsnmp_iterator_rc*)_ba_iterator_release;
<a name="l00875"></a>00875 
<a name="l00876"></a>00876     (void)_ba_iterator_reset(it);
<a name="l00877"></a>00877 
<a name="l00878"></a>00878     <span class="keywordflow">return</span> (<a class="code" href="structnetsnmp__iterator__s.html">netsnmp_iterator</a> *)it;
<a name="l00879"></a>00879 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jul 14 2011 for net-snmp by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
