<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000003.html">agent</a>
  </div>

  <h1>agent_registry.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * agent_registry.c</span>
00003 <span class="comment"> */</span>
00004 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
00005 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00006 <span class="comment"> * that may apply:</span>
00007 <span class="comment"> */</span>
00008 <span class="comment">/*</span>
00009 <span class="comment"> * Portions of this file are copyrighted by:</span>
00010 <span class="comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
00011 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00012 <span class="comment"> * distributed with the Net-SNMP package.</span>
00013 <span class="comment"> */</span>
00020 <span class="preprocessor">#define IN_SNMP_VARS_C</span>
00021 
00022 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00023 <span class="preprocessor">#include &lt;signal.h&gt;</span>
00024 <span class="preprocessor">#if HAVE_STRING_H</span>
00025 <span class="preprocessor">#include &lt;string.h&gt;</span>
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00028 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00029 <span class="preprocessor">#endif</span>
00030 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00031 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00032 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00033 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00034 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00035 <span class="preprocessor">#endif</span>
00036 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00037 <span class="preprocessor"># ifdef WIN32</span>
00038 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00039 <span class="preprocessor"># else</span>
00040 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00041 <span class="preprocessor"># endif</span>
00042 <span class="preprocessor"># include &lt;time.h&gt;</span>
00043 <span class="preprocessor">#else</span>
00044 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00045 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00046 <span class="preprocessor"># else</span>
00047 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00048 <span class="preprocessor"># endif</span>
00049 <span class="preprocessor">#endif</span>
00050 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00051 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00052 <span class="preprocessor">#endif</span>
00053 
00054 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00055 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00056 <span class="preprocessor">#endif</span>
00057 
00058 <span class="preprocessor">#include &lt;net-snmp/net-snmp-includes.h&gt;</span>
00059 <span class="preprocessor">#include &lt;net-snmp/agent/net-snmp-agent-includes.h&gt;</span>
00060 <span class="preprocessor">#include &lt;net-snmp/agent/agent_callbacks.h&gt;</span>
00061 
00062 <span class="preprocessor">#include "snmpd.h"</span>
00063 <span class="preprocessor">#include "mibgroup/struct.h"</span>
00064 <span class="preprocessor">#include &lt;net-snmp/agent/old_api.h&gt;</span>
00065 <span class="preprocessor">#include &lt;net-snmp/agent/null.h&gt;</span>
00066 <span class="preprocessor">#include &lt;net-snmp/agent/table.h&gt;</span>
00067 <span class="preprocessor">#include &lt;net-snmp/agent/table_iterator.h&gt;</span>
00068 <span class="preprocessor">#include &lt;net-snmp/agent/agent_registry.h&gt;</span>
00069 <span class="preprocessor">#include "mib_module_includes.h"</span>
00070 
00071 <span class="preprocessor">#ifdef USING_AGENTX_SUBAGENT_MODULE</span>
00072 <span class="preprocessor">#include "agentx/subagent.h"</span>
00073 <span class="preprocessor">#include "agentx/client.h"</span>
00074 <span class="preprocessor">#endif</span>
00075 
00076 <span class="keyword">static</span> <span class="keywordtype">void</span> register_mib_detach_node(netsnmp_subtree *s);
00077 NETSNMP_STATIC_INLINE <span class="keywordtype">void</span> invalidate_lookup_cache(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *context);
00078 <span class="keywordtype">void</span> <a class="code" href=
"group__agent__registry.html#ga21">netsnmp_set_lookup_cache_size</a>(<span class="keywordtype">int</span> newsize);
00079 <span class="keywordtype">int</span> <a class="code" href=
"group__agent__registry.html#ga22">netsnmp_get_lookup_cache_size</a>(<span class="keywordtype">void</span>);
00080 
00081 subtree_context_cache *context_subtrees = NULL;
00082 
00083 <span class="keywordtype">void</span>
00084 netsnmp_subtree_free(netsnmp_subtree *a)
00085 {
00086   <span class="keywordflow">if</span> (a != NULL) {
00087     <span class="keywordflow">if</span> (a-&gt;variables != NULL &amp;&amp; <a class="code" href=
"group__library.html#ga100">netsnmp_oid_equals</a>(a-&gt;name_a, a-&gt;namelen, 
00088                                              a-&gt;start_a, a-&gt;start_len) == 0) {
00089       <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(a-&gt;variables);
00090     }
00091     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(a-&gt;name_a);
00092     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(a-&gt;start_a);
00093     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(a-&gt;end_a);
00094     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(a-&gt;label_a);
00095     <a class="code" href="group__handler.html#ga21">netsnmp_handler_registration_free</a>(a-&gt;reginfo);
00096     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(a);
00097   }
00098 }
00099 
00100 netsnmp_subtree *
00101 netsnmp_subtree_deepcopy(netsnmp_subtree *a)
00102 {
00103   netsnmp_subtree *b = (netsnmp_subtree *)calloc(1, <span class="keyword">sizeof</span>(netsnmp_subtree));
00104 
00105   <span class="keywordflow">if</span> (b != NULL) {
00106     memcpy(b, a, <span class="keyword">sizeof</span>(netsnmp_subtree));
00107     b-&gt;name_a  = snmp_duplicate_objid(a-&gt;name_a,  a-&gt;namelen);
00108     b-&gt;start_a = snmp_duplicate_objid(a-&gt;start_a, a-&gt;start_len);
00109     b-&gt;end_a   = snmp_duplicate_objid(a-&gt;end_a,   a-&gt;end_len);
00110     b-&gt;label_a = strdup(a-&gt;label_a);
00111     
00112     <span class="keywordflow">if</span> (b-&gt;name_a == NULL || b-&gt;start_a == NULL || 
00113         b-&gt;end_a  == NULL || b-&gt;label_a == NULL) {
00114       netsnmp_subtree_free(b);
00115       <span class="keywordflow">return</span> NULL;
00116     }
00117 
00118     <span class="keywordflow">if</span> (a-&gt;variables != NULL) {
00119       b-&gt;variables = (<span class="keyword">struct </span>variable *)malloc(a-&gt;variables_len * 
00120                                                a-&gt;variables_width);
00121       <span class="keywordflow">if</span> (b-&gt;variables != NULL) {
00122         memcpy(b-&gt;variables, a-&gt;variables,a-&gt;variables_len*a-&gt;variables_width);
00123       } <span class="keywordflow">else</span> {
00124         netsnmp_subtree_free(b);
00125         <span class="keywordflow">return</span> NULL;
00126       }
00127     }
00128 
00129     <span class="keywordflow">if</span> (a-&gt;reginfo != NULL) {
00130       b-&gt;reginfo = <a class="code" href="group__handler.html#ga22">netsnmp_handler_registration_dup</a>(a-&gt;reginfo);
00131       <span class="keywordflow">if</span> (b-&gt;reginfo == NULL) {
00132         netsnmp_subtree_free(b);
00133         <span class="keywordflow">return</span> NULL;
00134       }
00135     }
00136   }
00137   <span class="keywordflow">return</span> b;
00138 }
00139 
00140 subtree_context_cache *
00141 get_top_context_cache(<span class="keywordtype">void</span>)
00142 {
00143     <span class="keywordflow">return</span> context_subtrees;
00144 }
00145 
00146 netsnmp_subtree *
00147 netsnmp_subtree_find_first(<span class="keyword">const</span> <span class="keywordtype">char</span> *context_name)
00148 {
00149     subtree_context_cache *ptr;
00150 
00151     <span class="keywordflow">if</span> (!context_name) {
00152         context_name = <span class="stringliteral">""</span>;
00153     }
00154 
00155     DEBUGMSGTL((<span class="stringliteral">"subtree"</span>, <span class=
"stringliteral">"looking for subtree for context: \"%s\"\n"</span>, 
00156                 context_name));
00157     <span class="keywordflow">for</span> (ptr = context_subtrees; ptr != NULL; ptr = ptr-&gt;next) {
00158         <span class="keywordflow">if</span> (ptr-&gt;context_name != NULL &amp;&amp; 
00159             strcmp(ptr-&gt;context_name, context_name) == 0) {
00160             DEBUGMSGTL((<span class="stringliteral">"subtree"</span>, <span class=
"stringliteral">"found one for: \"%s\"\n"</span>, context_name));
00161             <span class="keywordflow">return</span> ptr-&gt;first_subtree;
00162         }
00163     }
00164     DEBUGMSGTL((<span class="stringliteral">"subtree"</span>, <span class=
"stringliteral">"didn't find a subtree for context: \"%s\"\n"</span>, 
00165                 context_name));
00166     <span class="keywordflow">return</span> NULL;
00167 }
00168 
00169 netsnmp_subtree *
00170 add_subtree(netsnmp_subtree *new_tree, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *context_name)
00171 {
00172     subtree_context_cache *ptr = <a class="code" href=
"group__util.html#ga39">SNMP_MALLOC_TYPEDEF</a>(subtree_context_cache);
00173     
00174     <span class="keywordflow">if</span> (!context_name) {
00175         context_name = <span class="stringliteral">""</span>;
00176     }
00177 
00178     <span class="keywordflow">if</span> (!ptr) {
00179         <span class="keywordflow">return</span> NULL;
00180     }
00181     
00182     DEBUGMSGTL((<span class="stringliteral">"subtree"</span>, <span class=
"stringliteral">"adding subtree for context: \"%s\"\n"</span>,      
00183                 context_name));
00184 
00185     ptr-&gt;next = context_subtrees;
00186     ptr-&gt;first_subtree = new_tree;
00187     ptr-&gt;context_name = strdup(context_name);
00188     context_subtrees = ptr;
00189 
00190     <span class="keywordflow">return</span> ptr-&gt;first_subtree;
00191 }
00192 
00193 netsnmp_subtree *
00194 netsnmp_subtree_replace_first(netsnmp_subtree *new_tree, 
00195                               <span class="keyword">const</span> <span class="keywordtype">char</span> *context_name)
00196 {
00197     subtree_context_cache *ptr;
00198     <span class="keywordflow">if</span> (!context_name) {
00199         context_name = <span class="stringliteral">""</span>;
00200     }
00201     <span class="keywordflow">for</span> (ptr = context_subtrees; ptr != NULL; ptr = ptr-&gt;next) {
00202         <span class="keywordflow">if</span> (ptr-&gt;context_name != NULL &amp;&amp;
00203             strcmp(ptr-&gt;context_name, context_name) == 0) {
00204             ptr-&gt;first_subtree = new_tree;
00205             <span class="keywordflow">return</span> ptr-&gt;first_subtree;
00206         }
00207     }
00208     <span class="keywordflow">return</span> add_subtree(new_tree, context_name);
00209 }
00210 
00211 
00212 
00213 <span class="keywordtype">int</span>
00214 netsnmp_subtree_compare(<span class="keyword">const</span> netsnmp_subtree *ap, <span class=
"keyword">const</span> netsnmp_subtree *bp)
00215 {
00216     <span class="keywordflow">return</span> <a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>(ap-&gt;name_a, ap-&gt;namelen, bp-&gt;name_a, bp-&gt;namelen);
00217 }
00218 
00219 <span class="keywordtype">void</span>
00220 netsnmp_subtree_join(netsnmp_subtree *root)
00221 {
00222     netsnmp_subtree *s, *tmp, *c, *d;
00223 
00224     <span class="keywordflow">while</span> (root != NULL) {
00225         s = root-&gt;next;
00226         <span class="keywordflow">while</span> (s != NULL &amp;&amp; root-&gt;reginfo == s-&gt;reginfo) {
00227             tmp = s-&gt;next;
00228             DEBUGMSGTL((<span class="stringliteral">"subtree"</span>, <span class="stringliteral">"root start "</span>));
00229             DEBUGMSGOID((<span class="stringliteral">"subtree"</span>, root-&gt;start_a, root-&gt;start_len));
00230             DEBUGMSG((<span class="stringliteral">"subtree"</span>, <span class="stringliteral">" (original end "</span>));
00231             DEBUGMSGOID((<span class="stringliteral">"subtree"</span>, root-&gt;end_a, root-&gt;end_len));
00232             DEBUGMSG((<span class="stringliteral">"subtree"</span>, <span class="stringliteral">")\n"</span>));
00233             DEBUGMSGTL((<span class="stringliteral">"subtree"</span>, <span class="stringliteral">"  JOINING to "</span>));
00234             DEBUGMSGOID((<span class="stringliteral">"subtree"</span>, s-&gt;start_a, s-&gt;start_len));
00235 
00236             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(root-&gt;end_a);
00237             root-&gt;end_a   = s-&gt;end_a;
00238             root-&gt;end_len = s-&gt;end_len;
00239             s-&gt;end_a      = NULL;
00240 
00241             <span class="keywordflow">for</span> (c = root; c != NULL; c = c-&gt;children) {
00242                 c-&gt;next = s-&gt;next;
00243             }
00244             <span class="keywordflow">for</span> (c = s; c != NULL; c = c-&gt;children) {
00245                 c-&gt;prev = root;
00246             }
00247             DEBUGMSG((<span class="stringliteral">"subtree"</span>, <span class="stringliteral">" so new end "</span>));
00248             DEBUGMSGOID((<span class="stringliteral">"subtree"</span>, root-&gt;end_a, root-&gt;end_len));
00249             DEBUGMSG((<span class="stringliteral">"subtree"</span>, <span class="stringliteral">"\n"</span>));
00250             <span class="comment">/*</span>
00251 <span class="comment">             * Probably need to free children too?  </span>
00252 <span class="comment">             */</span>
00253             <span class="keywordflow">for</span> (c = s-&gt;children; c != NULL; c = d) {
00254                 d = c-&gt;children;
00255                 netsnmp_subtree_free(c);
00256             }
00257             netsnmp_subtree_free(s);
00258             s = tmp;
00259         }
00260         root = root-&gt;next;
00261     }
00262 }
00263 
00264 
00265         <span class="comment">/*</span>
00266 <span class="comment">         *  Split the subtree into two at the specified point,</span>
00267 <span class="comment">         *    returning the new (second) subtree</span>
00268 <span class="comment">         */</span>
00269 netsnmp_subtree *
00270 netsnmp_subtree_split(netsnmp_subtree *current, oid name[], <span class="keywordtype">int</span> name_len)
00271 {
00272     <span class="keyword">struct </span>variable *vp = NULL;
00273     netsnmp_subtree *new_sub, *ptr;
00274     <span class="keywordtype">int</span> i = 0, rc = 0, rc2 = 0;
00275     size_t common_len = 0;
00276     <span class="keywordtype">char</span> *cp;
00277     oid *tmp_a, *tmp_b;
00278 
00279     <span class="keywordflow">if</span> (<a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>(name, name_len, current-&gt;end_a, current-&gt;end_len)&gt;0) {
00280         <span class="comment">/* Split comes after the end of this subtree */</span>
00281         <span class="keywordflow">return</span> NULL;
00282     }
00283 
00284     new_sub = netsnmp_subtree_deepcopy(current);
00285     <span class="keywordflow">if</span> (new_sub == NULL) {
00286         <span class="keywordflow">return</span> NULL;
00287     }
00288 
00289     <span class="comment">/*  Set up the point of division.  */</span>
00290     tmp_a = snmp_duplicate_objid(name, name_len);
00291     <span class="keywordflow">if</span> (tmp_a == NULL) {
00292         netsnmp_subtree_free(new_sub);
00293         <span class="keywordflow">return</span> NULL;
00294     }
00295     tmp_b = snmp_duplicate_objid(name, name_len);
00296     <span class="keywordflow">if</span> (tmp_b == NULL) {
00297         netsnmp_subtree_free(new_sub);
00298         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tmp_a);
00299         <span class="keywordflow">return</span> NULL;
00300     }
00301 
00302     <span class="keywordflow">if</span> (current-&gt;end_a != NULL) {
00303         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(current-&gt;end_a);
00304     }
00305     current-&gt;end_a = tmp_a;
00306     current-&gt;end_len = name_len;
00307     <span class="keywordflow">if</span> (new_sub-&gt;start_a != NULL) {
00308         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(new_sub-&gt;start_a);
00309     }
00310     new_sub-&gt;start_a = tmp_b;
00311     new_sub-&gt;start_len = name_len;
00312 
00313     <span class="comment">/*  Split the variables between the two new subtrees.  */</span>
00314     i = current-&gt;variables_len;
00315     current-&gt;variables_len = 0;
00316 
00317     <span class="keywordflow">for</span> (vp = current-&gt;variables; i &gt; 0; i--) {
00318         <span class="comment">/*  Note that the variable "name" field omits the prefix common to the</span>
00319 <span class="comment">            whole registration, hence the strange comparison here.  */</span>
00320 
00321         rc = <a class="code" href="group__library.html#ga98">snmp_oid_compare</a>(vp-&gt;name, vp-&gt;namelen,
00322                               name     + current-&gt;namelen, 
00323                               name_len - current-&gt;namelen);
00324 
00325         <span class="keywordflow">if</span> (name_len - current-&gt;namelen &gt; vp-&gt;namelen) {
00326             common_len = vp-&gt;namelen;
00327         } <span class="keywordflow">else</span> {
00328             common_len = name_len - current-&gt;namelen;
00329         }
00330 
00331         rc2 = <a class="code" href="group__library.html#ga98">snmp_oid_compare</a>(vp-&gt;name, common_len,
00332                                name + current-&gt;namelen, common_len);
00333 
00334         <span class="keywordflow">if</span> (rc &gt;= 0) {
00335             <span class="keywordflow">break</span>;  <span class=
"comment">/* All following variables belong to the second subtree */</span>
00336         }
00337 
00338         current-&gt;variables_len++;
00339         <span class="keywordflow">if</span> (rc2 &lt; 0) {
00340             new_sub-&gt;variables_len--;
00341             cp = (<span class="keywordtype">char</span> *) new_sub-&gt;variables;
00342             new_sub-&gt;variables = (<span class="keyword">struct </span>variable *)(cp + 
00343                                                      new_sub-&gt;variables_width);
00344         }
00345         vp = (<span class="keyword">struct </span>variable *) ((<span class=
"keywordtype">char</span> *) vp + current-&gt;variables_width);
00346     }
00347 
00348     <span class="comment">/* Delegated trees should retain their variables regardless */</span>
00349     <span class="keywordflow">if</span> (current-&gt;variables_len &gt; 0 &amp;&amp;
00350         IS_DELEGATED((u_char) current-&gt;variables[0].type)) {
00351         new_sub-&gt;variables_len = 1;
00352         new_sub-&gt;variables = current-&gt;variables;
00353     }
00354 
00355     <span class="comment">/* Propogate this split down through any children */</span>
00356     <span class="keywordflow">if</span> (current-&gt;children) {
00357         new_sub-&gt;children = netsnmp_subtree_split(current-&gt;children, 
00358                                                   name, name_len);
00359     }
00360 
00361     <span class="comment">/* Retain the correct linking of the list */</span>
00362     <span class="keywordflow">for</span> (ptr = current; ptr != NULL; ptr = ptr-&gt;children) {
00363       ptr-&gt;next = new_sub;
00364     }
00365     <span class="keywordflow">for</span> (ptr = new_sub; ptr != NULL; ptr = ptr-&gt;children) {
00366       ptr-&gt;prev = current;
00367     }
00368     <span class="keywordflow">for</span> (ptr = new_sub-&gt;next; ptr != NULL; ptr=ptr-&gt;children) {
00369       ptr-&gt;prev = new_sub;
00370     }
00371 
00372     <span class="keywordflow">return</span> new_sub;
00373 }
00374 
00375 <span class="keywordtype">int</span>
00376 netsnmp_subtree_load(netsnmp_subtree *new_sub, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *context_name)
00377 {
00378     netsnmp_subtree *tree1, *tree2, *new2;
00379     netsnmp_subtree *prev, *next;
00380     <span class="keywordtype">int</span>             res, rc = 0;
00381 
00382     <span class="keywordflow">if</span> (new_sub == NULL) {
00383         <span class="keywordflow">return</span> MIB_REGISTERED_OK;       <span class="comment">/* Degenerate case */</span>
00384     }
00385 
00386     <span class="keywordflow">if</span> (!netsnmp_subtree_find_first(context_name)) {
00387         <span class="keyword">static</span> <span class="keywordtype">int</span> inloop = 0;
00388         <span class="keywordflow">if</span> (!inloop) {
00389             oid ccitt[1]           = { 0 };
00390             oid iso[1]             = { 1 };
00391             oid joint_ccitt_iso[1] = { 2 };
00392             inloop = 1;
00393             netsnmp_register_null_context(snmp_duplicate_objid(ccitt, 1), 1,
00394                                           context_name);
00395             netsnmp_register_null_context(snmp_duplicate_objid(iso, 1), 1,
00396                                           context_name);
00397             netsnmp_register_null_context(snmp_duplicate_objid(joint_ccitt_iso, 1),
00398                                           1, context_name);
00399             inloop = 0;
00400         }
00401     }
00402 
00403     <span class="comment">/*  Find the subtree that contains the start of the new subtree (if</span>
00404 <span class="comment">        any)...*/</span>
00405 
00406     tree1 = netsnmp_subtree_find(new_sub-&gt;start_a, new_sub-&gt;start_len, 
00407                                  NULL, context_name);
00408 
00409     <span class="comment">/*  ... and the subtree that follows the new one (NULL implies this is the</span>
00410 <span class="comment">        final region covered).  */</span>
00411 
00412     <span class="keywordflow">if</span> (tree1 == NULL) {
00413         tree2 = netsnmp_subtree_find_next(new_sub-&gt;start_a, new_sub-&gt;start_len,
00414                                           NULL, context_name);
00415     } <span class="keywordflow">else</span> {
00416         tree2 = tree1-&gt;next;
00417     }
00418 
00419     <span class="comment">/*  Handle new subtrees that start in virgin territory.  */</span>
00420 
00421     <span class="keywordflow">if</span> (tree1 == NULL) {
00422         new2 = NULL;
00423         <span class="comment">/*  Is there any overlap with later subtrees?  */</span>
00424         <span class="keywordflow">if</span> (tree2 &amp;&amp; <a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>(new_sub-&gt;end_a, new_sub-&gt;end_len,
00425                                       tree2-&gt;start_a, tree2-&gt;start_len) &gt; 0) {
00426             new2 = netsnmp_subtree_split(new_sub, 
00427                                          tree2-&gt;start_a, tree2-&gt;start_len);
00428         }
00429 
00430         <span class="comment">/*  Link the new subtree (less any overlapping region) with the list of</span>
00431 <span class="comment">            existing registrations.  */</span>
00432 
00433         <span class="keywordflow">if</span> (tree2) {
00434             new_sub-&gt;prev = tree2-&gt;prev;
00435             tree2-&gt;prev   = new_sub;
00436         } <span class="keywordflow">else</span> {
00437             new_sub-&gt;prev = netsnmp_subtree_find_prev(new_sub-&gt;start_a,
00438                                       new_sub-&gt;start_len, NULL, context_name);
00439 
00440             <span class="keywordflow">if</span> (new_sub-&gt;prev) {
00441                 new_sub-&gt;prev-&gt;next = new_sub;
00442             } <span class="keywordflow">else</span> {
00443                 netsnmp_subtree_replace_first(new_sub, context_name);
00444             }
00445 
00446             new_sub-&gt;next = tree2;
00447 
00448             <span class="comment">/* If there was any overlap, recurse to merge in the overlapping</span>
00449 <span class="comment">               region (including anything that may follow the overlap).  */</span>
00450             <span class="keywordflow">if</span> (new2) {
00451                 <span class="keywordflow">return</span> netsnmp_subtree_load(new2, context_name);
00452             }
00453         }
00454     } <span class="keywordflow">else</span> {
00455         <span class="comment">/*  If the new subtree starts *within* an existing registration</span>
00456 <span class="comment">            (rather than at the same point as it), then split the existing</span>
00457 <span class="comment">            subtree at this point.  */</span>
00458 
00459         <span class="keywordflow">if</span> (<a class="code" href=
"group__library.html#ga100">netsnmp_oid_equals</a>(new_sub-&gt;start_a, new_sub-&gt;start_len, 
00460                              tree1-&gt;start_a,   tree1-&gt;start_len) != 0) {
00461             tree1 = netsnmp_subtree_split(tree1, new_sub-&gt;start_a, 
00462                                           new_sub-&gt;start_len);
00463         }
00464 
00465         <span class="keywordflow">if</span> (tree1 == NULL) {
00466             <span class="keywordflow">return</span> MIB_REGISTRATION_FAILED;
00467         }
00468 
00469         <span class="comment">/*  Now consider the end of this existing subtree:</span>
00470 <span class="comment">            </span>
00471 <span class="comment">            If it matches the new subtree precisely,</span>
00472 <span class="comment">                    simply merge the new one into the list of children</span>
00473 
00474 <span class="comment">            If it includes the whole of the new subtree,</span>
00475 <span class="comment">                    split it at the appropriate point, and merge again</span>
00476 <span class="comment">     </span>
00477 <span class="comment">            If the new subtree extends beyond this existing region,</span>
00478 <span class="comment">                    split it, and recurse to merge the two parts.  */</span>
00479 
00480         rc = <a class="code" href="group__library.html#ga98">snmp_oid_compare</a>(new_sub-&gt;end_a, new_sub-&gt;end_len, 
00481                               tree1-&gt;end_a, tree1-&gt;end_len);
00482 
00483         <span class="keywordflow">switch</span> (rc) {
00484 
00485         <span class="keywordflow">case</span> -1:
00486             <span class="comment">/*  Existing subtree contains new one.  */</span>
00487             netsnmp_subtree_split(tree1, new_sub-&gt;end_a, new_sub-&gt;end_len);
00488             <span class="comment">/* Fall Through */</span>
00489 
00490         <span class="keywordflow">case</span>  0:
00491             <span class="comment">/*  The two trees match precisely.  */</span>
00492 
00493             <span class="comment">/*  Note: This is the only point where the original registration</span>
00494 <span class="comment">                OID ("name") is used.  */</span>
00495 
00496             prev = NULL;
00497             next = tree1;
00498         
00499             <span class="keywordflow">while</span> (next &amp;&amp; next-&gt;namelen &gt; new_sub-&gt;namelen) {
00500                 prev = next;
00501                 next = next-&gt;children;
00502             }
00503 
00504             <span class="keywordflow">while</span> (next &amp;&amp; next-&gt;namelen == new_sub-&gt;namelen &amp;&amp;
00505                    next-&gt;priority &lt; new_sub-&gt;priority ) {
00506                 prev = next;
00507                 next = next-&gt;children;
00508             }
00509         
00510             <span class="keywordflow">if</span> (next &amp;&amp; (next-&gt;namelen  == new_sub-&gt;namelen) &amp;&amp;
00511                 (next-&gt;priority == new_sub-&gt;priority)) {
00512                 netsnmp_assert(<span class="stringliteral">"registration"</span> != <span class=
"stringliteral">"duplicate"</span>);
00513                 <span class="keywordflow">return</span> MIB_DUPLICATE_REGISTRATION;
00514             }
00515 
00516             <span class="keywordflow">if</span> (prev) {
00517                 prev-&gt;children    = new_sub;
00518                 new_sub-&gt;children = next;
00519                 new_sub-&gt;prev = prev-&gt;prev;
00520                 new_sub-&gt;next = prev-&gt;next;
00521             } <span class="keywordflow">else</span> {
00522                 new_sub-&gt;children = next;
00523                 new_sub-&gt;prev = next-&gt;prev;
00524                 new_sub-&gt;next = next-&gt;next;
00525         
00526                 <span class="keywordflow">for</span> (next = new_sub-&gt;next; next != NULL;next = next-&gt;children){
00527                     next-&gt;prev = new_sub;
00528                 }
00529 
00530                 <span class="keywordflow">for</span> (prev = new_sub-&gt;prev; prev != NULL;prev = prev-&gt;children){
00531                     prev-&gt;next = new_sub;
00532                 }
00533             }
00534             <span class="keywordflow">break</span>;
00535 
00536         <span class="keywordflow">case</span>  1:
00537             <span class="comment">/*  New subtree contains the existing one.  */</span>
00538             new2 = netsnmp_subtree_split(new_sub, tree1-&gt;end_a,tree1-&gt;end_len);
00539             res = netsnmp_subtree_load(new_sub, context_name);
00540             <span class="keywordflow">if</span> (res != MIB_REGISTERED_OK) {
00541                 netsnmp_subtree_free(new2);
00542                 <span class="keywordflow">return</span> res;
00543             }
00544             <span class="keywordflow">return</span> netsnmp_subtree_load(new2, context_name);
00545         }
00546     }
00547     <span class="keywordflow">return</span> 0;
00548 }
00549 
00550 <span class="comment">/*</span>
00551 <span class="comment"> * Note: reginfo will be freed on failures</span>
00552 <span class="comment"> */</span>
00553 <span class="keywordtype">int</span>
00554 netsnmp_register_mib(<span class="keyword">const</span> <span class="keywordtype">char</span> *moduleName,
00555                      <span class="keyword">struct</span> variable *var,
00556                      size_t varsize,
00557                      size_t numvars,
00558                      oid * mibloc,
00559                      size_t mibloclen,
00560                      <span class="keywordtype">int</span> priority,
00561                      <span class="keywordtype">int</span> range_subid,
00562                      oid range_ubound,
00563                      <a class="code" href="structsnmp__session.html">netsnmp_session</a> * ss,
00564                      <span class="keyword">const</span> <span class="keywordtype">char</span> *context,
00565                      <span class="keywordtype">int</span> timeout,
00566                      <span class="keywordtype">int</span> flags,
00567                      <a class="code" href=
"structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo,
00568                      <span class="keywordtype">int</span> perform_callback)
00569 {
00570     netsnmp_subtree *subtree, *sub2;
00571     <span class="keywordtype">int</span>             res, i;
00572     <span class="keyword">struct </span>register_parameters reg_parms;
00573     <span class="keywordtype">int</span> old_lookup_cache_val = <a class="code" href=
"group__agent__registry.html#ga22">netsnmp_get_lookup_cache_size</a>();
00574 
00575     <span class="keywordflow">if</span> (moduleName == NULL ||
00576         mibloc     == NULL) {
00577         <span class="comment">/* Shouldn't happen ??? */</span>
00578         <a class="code" href="group__handler.html#ga21">netsnmp_handler_registration_free</a>(reginfo);
00579         <span class="keywordflow">return</span> MIB_REGISTRATION_FAILED;
00580     }
00581     subtree = (netsnmp_subtree *)calloc(1, <span class="keyword">sizeof</span>(netsnmp_subtree));
00582     <span class="keywordflow">if</span> (subtree == NULL) {
00583         <a class="code" href="group__handler.html#ga21">netsnmp_handler_registration_free</a>(reginfo);
00584         <span class="keywordflow">return</span> MIB_REGISTRATION_FAILED;
00585     }
00586 
00587     DEBUGMSGTL((<span class="stringliteral">"register_mib"</span>, <span class=
"stringliteral">"registering \"%s\" at "</span>, moduleName));
00588     DEBUGMSGOIDRANGE((<span class="stringliteral">"register_mib"</span>, mibloc, mibloclen, range_subid,
00589                       range_ubound));
00590     DEBUGMSG((<span class="stringliteral">"register_mib"</span>, <span class="stringliteral">"\n"</span>));
00591 
00592     <span class="comment">/*  Create the new subtree node being registered.  */</span>
00593 
00594     subtree-&gt;reginfo = reginfo;
00595     subtree-&gt;name_a  = snmp_duplicate_objid(mibloc, mibloclen);
00596     subtree-&gt;start_a = snmp_duplicate_objid(mibloc, mibloclen);
00597     subtree-&gt;end_a   = snmp_duplicate_objid(mibloc, mibloclen);
00598     subtree-&gt;label_a = strdup(moduleName);
00599     <span class="keywordflow">if</span> (subtree-&gt;name_a == NULL || subtree-&gt;start_a == NULL || 
00600         subtree-&gt;end_a  == NULL || subtree-&gt;label_a == NULL) {
00601         netsnmp_subtree_free(subtree); <span class="comment">/* also frees reginfo */</span>
00602         <span class="keywordflow">return</span> MIB_REGISTRATION_FAILED;
00603     }
00604     subtree-&gt;namelen   = (u_char)mibloclen;
00605     subtree-&gt;start_len = (u_char)mibloclen;
00606     subtree-&gt;end_len   = (u_char)mibloclen;
00607     subtree-&gt;end_a[mibloclen - 1]++;
00608 
00609     <span class="keywordflow">if</span> (var != NULL) {
00610         subtree-&gt;variables = (<span class="keyword">struct </span>variable *)malloc(varsize*numvars);
00611         <span class="keywordflow">if</span> (subtree-&gt;variables == NULL) {
00612             netsnmp_subtree_free(subtree); <span class="comment">/* also frees reginfo */</span>
00613             <span class="keywordflow">return</span> MIB_REGISTRATION_FAILED;
00614         }
00615         memcpy(subtree-&gt;variables, var, numvars*varsize);
00616         subtree-&gt;variables_len = numvars;
00617         subtree-&gt;variables_width = varsize;
00618     }
00619     subtree-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#o6">priority</a> = priority;
00620     subtree-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#o9">timeout</a> = timeout;
00621     subtree-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#o7">range_subid</a> = range_subid;
00622     subtree-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#o8">range_ubound</a> = range_ubound;
00623     subtree-&gt;session = ss;
00624     subtree-&gt;<a class="code" href="structsnmp__session.html#o3">flags</a> = (u_char)flags;    <span class=
"comment">/*  used to identify instance oids  */</span>
00625     subtree-&gt;<a class="code" href="structsnmp__session.html#o3">flags</a> |= SUBTREE_ATTACHED;
00626     subtree-&gt;global_cacheid = reginfo-&gt;<a class="code" href=
"structnetsnmp__handler__registration__s.html#o10">global_cacheid</a>;
00627 
00628     <a class="code" href="group__agent__registry.html#ga21">netsnmp_set_lookup_cache_size</a>(0);
00629     res = netsnmp_subtree_load(subtree, context);
00630 
00631     <span class="comment">/*  If registering a range, use the first subtree as a template for the</span>
00632 <span class="comment">        rest of the range.  */</span>
00633 
00634     <span class="keywordflow">if</span> (res == MIB_REGISTERED_OK &amp;&amp; range_subid != 0) {
00635         <span class="keywordflow">for</span> (i = mibloc[range_subid - 1] + 1; i &lt;= (int)range_ubound; i++) {
00636             sub2 = netsnmp_subtree_deepcopy(subtree);
00637 
00638             <span class="keywordflow">if</span> (sub2 == NULL) {
00639                 <a class="code" href=
"group__agent__registry.html#ga42">unregister_mib_context</a>(mibloc, mibloclen, priority,
00640                                        range_subid, range_ubound, context);
00641                 <a class="code" href=
"group__agent__registry.html#ga21">netsnmp_set_lookup_cache_size</a>(old_lookup_cache_val);
00642                 invalidate_lookup_cache(context);
00643                 <span class="keywordflow">return</span> MIB_REGISTRATION_FAILED;
00644             }
00645 
00646             sub2-&gt;name_a[range_subid - 1]  = i;
00647             sub2-&gt;start_a[range_subid - 1] = i;
00648             sub2-&gt;end_a[range_subid - 1]   = i;     <span class="comment">/* XXX - ???? */</span>
00649             <span class="keywordflow">if</span> (range_subid == (int)mibloclen)
00650                 ++sub2-&gt;end_a[range_subid - 1];
00651             res = netsnmp_subtree_load(sub2, context);
00652             sub2-&gt;flags |= SUBTREE_ATTACHED;
00653             <span class="keywordflow">if</span> (res != MIB_REGISTERED_OK) {
00654                 <a class="code" href=
"group__agent__registry.html#ga42">unregister_mib_context</a>(mibloc, mibloclen, priority,
00655                                        range_subid, range_ubound, context);
00656                 netsnmp_subtree_free(sub2);
00657                 <a class="code" href=
"group__agent__registry.html#ga21">netsnmp_set_lookup_cache_size</a>(old_lookup_cache_val);
00658                 invalidate_lookup_cache(context);
00659                 <span class="keywordflow">return</span> res;
00660             }
00661         }
00662     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (res == MIB_DUPLICATE_REGISTRATION ||
00663                res == MIB_REGISTRATION_FAILED) {
00664         <a class="code" href="group__agent__registry.html#ga21">netsnmp_set_lookup_cache_size</a>(old_lookup_cache_val);
00665         invalidate_lookup_cache(context);
00666         netsnmp_subtree_free(subtree);
00667         <span class="keywordflow">return</span> res;
00668     }
00669 
00670     <span class="comment">/*</span>
00671 <span class="comment">     * mark the MIB as detached, if there's no master agent present as of now </span>
00672 <span class="comment">     */</span>
00673     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
00674                                NETSNMP_DS_AGENT_ROLE) != MASTER_AGENT) {
00675         <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href=
"structsnmp__session.html">snmp_session</a> *main_session;
00676         <span class="keywordflow">if</span> (main_session == NULL) {
00677             register_mib_detach_node(subtree);
00678         }
00679     }
00680 
00681     <span class="keywordflow">if</span> (res == MIB_REGISTERED_OK &amp;&amp; perform_callback) {
00682         reg_parms.name = mibloc;
00683         reg_parms.namelen = mibloclen;
00684         reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o6">priority</a> = priority;
00685         reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o7">range_subid</a> = range_subid;
00686         reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o8">range_ubound</a> = range_ubound;
00687         reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o9">timeout</a> = timeout;
00688         reg_parms.flags = (u_char) flags;
00689         reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o1">contextName</a> = context;
00690         <a class="code" href="group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
00691                             SNMPD_CALLBACK_REGISTER_OID, &amp;reg_parms);
00692     }
00693 
00694     <a class="code" href="group__agent__registry.html#ga21">netsnmp_set_lookup_cache_size</a>(old_lookup_cache_val);
00695     invalidate_lookup_cache(context);
00696     <span class="keywordflow">return</span> res;
00697 }
00698 
00699 <span class="comment">/*</span>
00700 <span class="comment"> * Reattach a particular node.  </span>
00701 <span class="comment"> */</span>
00702 
00703 <span class="keyword">static</span> <span class="keywordtype">void</span>
00704 register_mib_reattach_node(netsnmp_subtree *s)
00705 {
00706     <span class=
"keywordflow">if</span> ((s != NULL) &amp;&amp; (s-&gt;namelen &gt; 1) &amp;&amp; !(s-&gt;flags &amp; SUBTREE_ATTACHED)) {
00707         <span class="keyword">struct </span>register_parameters reg_parms;
00708         <span class="comment">/*</span>
00709 <span class="comment">         * only do registrations that are not the top level nodes </span>
00710 <span class="comment">         */</span>
00711         <span class="comment">/*</span>
00712 <span class="comment">         * XXX: do this better </span>
00713 <span class="comment">         */</span>
00714         reg_parms.name = s-&gt;name_a;
00715         reg_parms.namelen = s-&gt;namelen;
00716         reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o6">priority</a> = s-&gt;<a class=
"code" href="structnetsnmp__handler__registration__s.html#o6">priority</a>;
00717         reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o7">range_subid</a> = s-&gt;<a class=
"code" href="structnetsnmp__handler__registration__s.html#o7">range_subid</a>;
00718         reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o8">range_ubound</a> = s-&gt;<a class=
"code" href="structnetsnmp__handler__registration__s.html#o8">range_ubound</a>;
00719         reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o9">timeout</a> = s-&gt;<a class=
"code" href="structnetsnmp__handler__registration__s.html#o9">timeout</a>;
00720         reg_parms.flags = s-&gt;flags;
00721         <a class="code" href="group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
00722                             SNMPD_CALLBACK_REGISTER_OID, &amp;reg_parms);
00723         s-&gt;flags |= SUBTREE_ATTACHED;
00724     }
00725 }
00726 
00727 <span class="comment">/*</span>
00728 <span class="comment"> * Call callbacks to reattach all our nodes.  </span>
00729 <span class="comment"> */</span>
00730 
00731 <span class="keywordtype">void</span>
00732 register_mib_reattach(<span class="keywordtype">void</span>)
00733 {
00734     netsnmp_subtree *s, *t;
00735     subtree_context_cache *ptr;
00736 
00737     <span class="keywordflow">for</span> (ptr = context_subtrees; ptr; ptr = ptr-&gt;next) {
00738         <span class="keywordflow">for</span> (s = ptr-&gt;first_subtree; s != NULL; s = s-&gt;next) {
00739             register_mib_reattach_node(s);
00740             <span class="keywordflow">for</span> (t = s-&gt;children; t != NULL; t = t-&gt;children) {
00741                 register_mib_reattach_node(t);
00742             }
00743         }
00744     }
00745 }
00746 
00747 <span class="comment">/*</span>
00748 <span class="comment"> * Mark a node as detached.  </span>
00749 <span class="comment"> */</span>
00750 
00751 <span class="keyword">static</span> <span class="keywordtype">void</span>
00752 register_mib_detach_node(netsnmp_subtree *s)
00753 {
00754     <span class="keywordflow">if</span> (s != NULL) {
00755         s-&gt;flags = s-&gt;flags &amp; ~SUBTREE_ATTACHED;
00756     }
00757 }
00758 
00759 <span class="comment">/*</span>
00760 <span class="comment"> * Mark all our registered OIDs as detached.  This is only really</span>
00761 <span class="comment"> * useful for subagent protocols, when a connection is lost or</span>
00762 <span class="comment"> * something.  </span>
00763 <span class="comment"> */</span>
00764 
00765 <span class="keywordtype">void</span>
00766 register_mib_detach(<span class="keywordtype">void</span>)
00767 {
00768     netsnmp_subtree *s, *t;
00769     subtree_context_cache *ptr;
00770     <span class="keywordflow">for</span> (ptr = context_subtrees; ptr; ptr = ptr-&gt;next) {
00771         <span class="keywordflow">for</span> (s = ptr-&gt;first_subtree; s != NULL; s = s-&gt;next) {
00772             register_mib_detach_node(s);
00773             <span class="keywordflow">for</span> (t = s-&gt;children; t != NULL; t = t-&gt;children) {
00774                 register_mib_detach_node(t);
00775             }
00776         }
00777     }
00778 }
00779 
00780 <span class="keywordtype">int</span>
00781 register_mib_context(<span class="keyword">const</span> <span class="keywordtype">char</span> *moduleName,
00782                      <span class="keyword">struct</span> variable *var,
00783                      size_t varsize,
00784                      size_t numvars,
00785                      oid * mibloc,
00786                      size_t mibloclen,
00787                      <span class="keywordtype">int</span> priority,
00788                      <span class="keywordtype">int</span> range_subid,
00789                      oid range_ubound,
00790                      <a class="code" href="structsnmp__session.html">netsnmp_session</a> * ss,
00791                      <span class="keyword">const</span> <span class="keywordtype">char</span> *context, <span class=
"keywordtype">int</span> timeout, <span class="keywordtype">int</span> flags)
00792 {
00793     <span class="keywordflow">return</span> <a class="code" href=
"group__old__api.html#ga1">netsnmp_register_old_api</a>(moduleName, var, varsize, numvars,
00794                                     mibloc, mibloclen, priority,
00795                                     range_subid, range_ubound, ss, context,
00796                                     timeout, flags);
00797 }
00798 
00799 <span class="keywordtype">int</span>
00800 register_mib_range(<span class="keyword">const</span> <span class="keywordtype">char</span> *moduleName,
00801                    <span class="keyword">struct</span> variable *var,
00802                    size_t varsize,
00803                    size_t numvars,
00804                    oid * mibloc,
00805                    size_t mibloclen,
00806                    <span class="keywordtype">int</span> priority,
00807                    <span class="keywordtype">int</span> range_subid, oid range_ubound, <a class="code" href=
"structsnmp__session.html">netsnmp_session</a> * ss)
00808 {
00809     <span class="keywordflow">return</span> register_mib_context(moduleName, var, varsize, numvars,
00810                                 mibloc, mibloclen, priority,
00811                                 range_subid, range_ubound, ss, <span class="stringliteral">""</span>, -1, 0);
00812 }
00813 
00814 <span class="keywordtype">int</span>
00815 register_mib_priority(<span class="keyword">const</span> <span class="keywordtype">char</span> *moduleName,
00816                       <span class="keyword">struct</span> variable *var,
00817                       size_t varsize,
00818                       size_t numvars,
00819                       oid * mibloc, size_t mibloclen, <span class="keywordtype">int</span> priority)
00820 {
00821     <span class="keywordflow">return</span> register_mib_range(moduleName, var, varsize, numvars,
00822                               mibloc, mibloclen, priority, 0, 0, NULL);
00823 }
00824 
00825 <span class="keywordtype">int</span>
00826 register_mib(<span class="keyword">const</span> <span class="keywordtype">char</span> *moduleName,
00827              <span class="keyword">struct</span> variable *var,
00828              size_t varsize,
00829              size_t numvars, oid * mibloc, size_t mibloclen)
00830 {
00831     <span class="keywordflow">return</span> register_mib_priority(moduleName, var, varsize, numvars,
00832                                  mibloc, mibloclen, DEFAULT_MIB_PRIORITY);
00833 }
00834 
00835 <span class="keywordtype">void</span>
00836 netsnmp_subtree_unload(netsnmp_subtree *sub, netsnmp_subtree *prev, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *context)
00837 {
00838     netsnmp_subtree *ptr;
00839 
00840     DEBUGMSGTL((<span class="stringliteral">"register_mib"</span>, <span class="stringliteral">"unload("</span>));
00841     <span class="keywordflow">if</span> (sub != NULL) {
00842         DEBUGMSGOID((<span class="stringliteral">"register_mib"</span>, sub-&gt;start_a, sub-&gt;start_len));
00843     } <span class="keywordflow">else</span> {
00844         DEBUGMSG((<span class="stringliteral">"register_mib"</span>, <span class="stringliteral">"[NIL]"</span>));
00845     }
00846     DEBUGMSG((<span class="stringliteral">"register_mib"</span>, <span class="stringliteral">", "</span>));
00847     <span class="keywordflow">if</span> (prev != NULL) {
00848         DEBUGMSGOID((<span class="stringliteral">"register_mib"</span>, prev-&gt;start_a, prev-&gt;start_len));
00849     } <span class="keywordflow">else</span> {
00850         DEBUGMSG((<span class="stringliteral">"register_mib"</span>, <span class="stringliteral">"[NIL]"</span>));
00851     }
00852     DEBUGMSG((<span class="stringliteral">"register_mib"</span>, <span class="stringliteral">")\n"</span>));
00853 
00854     <span class="keywordflow">if</span> (prev != NULL) {         <span class=
"comment">/* non-leading entries are easy */</span>
00855         prev-&gt;children = sub-&gt;children;
00856         invalidate_lookup_cache(context);
00857         <span class="keywordflow">return</span>;
00858     }
00859     <span class="comment">/*</span>
00860 <span class="comment">     * otherwise, we need to amend our neighbours as well </span>
00861 <span class="comment">     */</span>
00862 
00863     <span class="keywordflow">if</span> (sub-&gt;children == NULL) {        <span class=
"comment">/* just remove this node completely */</span>
00864         <span class="keywordflow">for</span> (ptr = sub-&gt;prev; ptr; ptr = ptr-&gt;children)
00865             ptr-&gt;next = sub-&gt;next;
00866         <span class="keywordflow">for</span> (ptr = sub-&gt;next; ptr; ptr = ptr-&gt;children)
00867             ptr-&gt;prev = sub-&gt;prev;
00868 
00869         <span class="keywordflow">if</span> (sub-&gt;prev == NULL) {
00870             netsnmp_subtree_replace_first(sub-&gt;next, context);
00871         }
00872 
00873     } <span class="keywordflow">else</span> {
00874         <span class="keywordflow">for</span> (ptr = sub-&gt;prev; ptr; ptr = ptr-&gt;children)
00875             ptr-&gt;next = sub-&gt;children;
00876         <span class="keywordflow">for</span> (ptr = sub-&gt;next; ptr; ptr = ptr-&gt;children)
00877             ptr-&gt;prev = sub-&gt;children;
00878 
00879         <span class="keywordflow">if</span> (sub-&gt;prev == NULL) {
00880             netsnmp_subtree_replace_first(sub-&gt;children, context);
00881         }
00882     }
00883     invalidate_lookup_cache(context);
00884 }
00885 
00915 <span class="keywordtype">int</span>
<a name="l00916" id="l00916"></a><a class="code" href="group__agent__registry.html#ga42">00916</a> <a class="code" href=
"group__agent__registry.html#ga42">unregister_mib_context</a>(oid * name, size_t len, <span class=
"keywordtype">int</span> priority,
00917                        <span class="keywordtype">int</span> range_subid, oid range_ubound,
00918                        <span class="keyword">const</span> <span class="keywordtype">char</span> *context)
00919 {
00920     netsnmp_subtree *list, *myptr;
00921     netsnmp_subtree *prev, *child;       <span class="comment">/* loop through children */</span>
00922     <span class="keyword">struct </span>register_parameters reg_parms;
00923     <span class="keywordtype">int</span> old_lookup_cache_val = <a class="code" href=
"group__agent__registry.html#ga22">netsnmp_get_lookup_cache_size</a>();
00924     <a class="code" href="group__agent__registry.html#ga21">netsnmp_set_lookup_cache_size</a>(0);
00925 
00926     DEBUGMSGTL((<span class="stringliteral">"register_mib"</span>, <span class="stringliteral">"unregistering "</span>));
00927     DEBUGMSGOIDRANGE((<span class="stringliteral">"register_mib"</span>, name, len, range_subid, range_ubound));
00928     DEBUGMSG((<span class="stringliteral">"register_mib"</span>, <span class="stringliteral">"\n"</span>));
00929 
00930     list = netsnmp_subtree_find(name, len, netsnmp_subtree_find_first(context),
00931                                 context);
00932     <span class="keywordflow">if</span> (list == NULL) {
00933         <span class="keywordflow">return</span> MIB_NO_SUCH_REGISTRATION;
00934     }
00935 
00936     <span class="keywordflow">for</span> (child = list, prev = NULL; child != NULL;
00937          prev = child, child = child-&gt;children) {
00938         <span class="keywordflow">if</span> (<a class="code" href=
"group__library.html#ga100">netsnmp_oid_equals</a>(child-&gt;name_a, child-&gt;namelen, name, len) == 0 &amp;&amp;
00939             child-&gt;priority == priority) {
00940             <span class="keywordflow">break</span>;              <span class="comment">/* found it */</span>
00941         }
00942     }
00943 
00944     <span class="keywordflow">if</span> (child == NULL) {
00945         <span class="keywordflow">return</span> MIB_NO_SUCH_REGISTRATION;
00946     }
00947 
00948     netsnmp_subtree_unload(child, prev, context);
00949     myptr = child;              <span class="comment">/* remember this for later */</span>
00950 
00951     <span class="comment">/*</span>
00952 <span class="comment">     *  Now handle any occurances in the following subtrees,</span>
00953 <span class="comment">     *      as a result of splitting this range.  Due to the</span>
00954 <span class="comment">     *      nature of the way such splits work, the first</span>
00955 <span class="comment">     *      subtree 'slice' that doesn't refer to the given</span>
00956 <span class="comment">     *      name marks the end of the original region.</span>
00957 <span class="comment">     *</span>
00958 <span class="comment">     *  This should also serve to register ranges.</span>
00959 <span class="comment">     */</span>
00960 
00961     <span class="keywordflow">for</span> (list = myptr-&gt;next; list != NULL; list = list-&gt;next) {
00962         <span class="keywordflow">for</span> (child = list, prev = NULL; child != NULL;
00963              prev = child, child = child-&gt;children) {
00964             <span class="keywordflow">if</span> ((<a class="code" href=
"group__library.html#ga100">netsnmp_oid_equals</a>(child-&gt;name_a, child-&gt;namelen,
00965                                   name, len) == 0) &amp;&amp;
00966                 (child-&gt;priority == priority)) {
00967                 netsnmp_subtree_unload(child, prev, context);
00968                 netsnmp_subtree_free(child);
00969                 <span class="keywordflow">break</span>;
00970             }
00971         }
00972         <span class="keywordflow">if</span> (child == NULL)      <span class=
"comment">/* Didn't find the given name */</span>
00973             <span class="keywordflow">break</span>;
00974     }
00975     netsnmp_subtree_free(myptr);
00976 
00977     reg_parms.name = name;
00978     reg_parms.namelen = len;
00979     reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o6">priority</a> = priority;
00980     reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o7">range_subid</a> = range_subid;
00981     reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o8">range_ubound</a> = range_ubound;
00982     reg_parms.flags = 0x00;     <span class="comment">/*  this is okay I think  */</span>
00983     reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o1">contextName</a> = context;
00984     <a class="code" href="group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
00985                         SNMPD_CALLBACK_UNREGISTER_OID, &amp;reg_parms);
00986 
00987     <a class="code" href="group__agent__registry.html#ga21">netsnmp_set_lookup_cache_size</a>(old_lookup_cache_val);
00988     invalidate_lookup_cache(context);
00989     <span class="keywordflow">return</span> MIB_UNREGISTERED_OK;
00990 }
00991 
00992 <span class="keywordtype">int</span>
00993 netsnmp_unregister_mib_table_row(oid * name, size_t len, <span class="keywordtype">int</span> priority,
00994                                  <span class="keywordtype">int</span> var_subid, oid range_ubound,
00995                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *context)
00996 {
00997     netsnmp_subtree *list, *myptr;
00998     netsnmp_subtree *prev, *child;       <span class="comment">/* loop through children */</span>
00999     <span class="keyword">struct </span>register_parameters reg_parms;
01000     oid             range_lbound = name[var_subid - 1];
01001 
01002     DEBUGMSGTL((<span class="stringliteral">"register_mib"</span>, <span class="stringliteral">"unregistering "</span>));
01003     DEBUGMSGOIDRANGE((<span class="stringliteral">"register_mib"</span>, name, len, var_subid, range_ubound));
01004     DEBUGMSG((<span class="stringliteral">"register_mib"</span>, <span class="stringliteral">"\n"</span>));
01005 
01006     <span class="keywordflow">for</span> (; name[var_subid - 1] &lt;= range_ubound; name[var_subid - 1]++) {
01007         list = netsnmp_subtree_find(name, len, 
01008                                 netsnmp_subtree_find_first(context), context);
01009 
01010         <span class="keywordflow">if</span> (list == NULL) {
01011             <span class="keywordflow">continue</span>;
01012         }
01013 
01014         <span class="keywordflow">for</span> (child = list, prev = NULL; child != NULL;
01015              prev = child, child = child-&gt;children) {
01016 
01017             <span class="keywordflow">if</span> (<a class="code" href=
"group__library.html#ga100">netsnmp_oid_equals</a>(child-&gt;name_a, child-&gt;namelen, 
01018                                  name, len) == 0 &amp;&amp; 
01019                 (child-&gt;priority == priority)) {
01020                 <span class="keywordflow">break</span>;          <span class="comment">/* found it */</span>
01021             }
01022         }
01023 
01024         <span class="keywordflow">if</span> (child == NULL) {
01025             <span class="keywordflow">continue</span>;
01026         }
01027 
01028         netsnmp_subtree_unload(child, prev, context);
01029         myptr = child;          <span class="comment">/* remember this for later */</span>
01030 
01031         <span class="keywordflow">for</span> (list = myptr-&gt;next; list != NULL; list = list-&gt;next) {
01032             <span class="keywordflow">for</span> (child = list, prev = NULL; child != NULL;
01033                  prev = child, child = child-&gt;children) {
01034 
01035                 <span class="keywordflow">if</span> (<a class="code" href=
"group__library.html#ga100">netsnmp_oid_equals</a>(child-&gt;name_a, child-&gt;namelen, 
01036                                       name, len) == 0 &amp;&amp;
01037                     (child-&gt;priority == priority)) {
01038                     netsnmp_subtree_unload(child, prev, context);
01039                     netsnmp_subtree_free(child);
01040                     <span class="keywordflow">break</span>;
01041                 }
01042             }
01043             <span class="keywordflow">if</span> (child == NULL) {        <span class=
"comment">/* Didn't find the given name */</span>
01044                 <span class="keywordflow">break</span>;
01045             }
01046         }
01047         netsnmp_subtree_free(myptr);
01048     }
01049 
01050     name[var_subid - 1] = range_lbound;
01051     reg_parms.name = name;
01052     reg_parms.namelen = len;
01053     reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o6">priority</a> = priority;
01054     reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o7">range_subid</a> = var_subid;
01055     reg_parms.<a class="code" href="structnetsnmp__handler__registration__s.html#o8">range_ubound</a> = range_ubound;
01056     reg_parms.flags = 0x00;     <span class="comment">/*  this is okay I think  */</span>
01057     <a class="code" href="group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
01058                         SNMPD_CALLBACK_UNREGISTER_OID, &amp;reg_parms);
01059 
01060     <span class="keywordflow">return</span> 0;
01061 }
01062 
01063 <span class="keywordtype">int</span>
01064 unregister_mib_range(oid * name, size_t len, <span class="keywordtype">int</span> priority,
01065                      <span class="keywordtype">int</span> range_subid, oid range_ubound)
01066 {
01067     <span class="keywordflow">return</span> <a class="code" href=
"group__agent__registry.html#ga42">unregister_mib_context</a>(name, len, priority, range_subid,
01068                                   range_ubound, <span class="stringliteral">""</span>);
01069 }
01070 
01071 <span class="keywordtype">int</span>
01072 unregister_mib_priority(oid * name, size_t len, <span class="keywordtype">int</span> priority)
01073 {
01074     <span class="keywordflow">return</span> unregister_mib_range(name, len, priority, 0, 0);
01075 }
01076 
01077 <span class="keywordtype">int</span>
01078 unregister_mib(oid * name, size_t len)
01079 {
01080     <span class="keywordflow">return</span> unregister_mib_priority(name, len, DEFAULT_MIB_PRIORITY);
01081 }
01082 
01083 <span class="keywordtype">void</span>
01084 unregister_mibs_by_session(<a class="code" href="structsnmp__session.html">netsnmp_session</a> * ss)
01085 {
01086     netsnmp_subtree *list, *list2;
01087     netsnmp_subtree *child, *prev, *next_child;
01088     <span class="keyword">struct </span>register_parameters rp;
01089     subtree_context_cache *contextptr;
01090 
01091     DEBUGMSGTL((<span class="stringliteral">"register_mib"</span>, <span class=
"stringliteral">"unregister_mibs_by_session(%p) ctxt \"%s\"\n"</span>,
01092                 ss, (ss &amp;&amp; ss-&gt;<a class="code" href=
"structsnmp__session.html#o25">contextName</a>) ? ss-&gt;<a class="code" href=
"structsnmp__session.html#o25">contextName</a> : <span class="stringliteral">"[NIL]"</span>));
01093 
01094     <span class="keywordflow">for</span> (contextptr = get_top_context_cache(); contextptr != NULL;
01095          contextptr = contextptr-&gt;next) {
01096         <span class="keywordflow">for</span> (list = contextptr-&gt;first_subtree; list != NULL; list = list2) {
01097             list2 = list-&gt;next;
01098 
01099             <span class="keywordflow">for</span> (child = list, prev = NULL; child != NULL; child = next_child){
01100                 next_child = child-&gt;children;
01101 
01102                 <span class="keywordflow">if</span> (((!ss || ss-&gt;<a class="code" href=
"structsnmp__session.html#o3">flags</a> &amp; SNMP_FLAGS_SUBSESSION) &amp;&amp;
01103                      child-&gt;session == ss) ||
01104                     (!(!ss || ss-&gt;<a class="code" href=
"structsnmp__session.html#o3">flags</a> &amp; SNMP_FLAGS_SUBSESSION) &amp;&amp; child-&gt;session &amp;&amp;
01105                      child-&gt;session-&gt;subsession == ss)) {
01106 
01107                     rp.name = child-&gt;name_a;
01108                     child-&gt;name_a = NULL;
01109                     rp.namelen = child-&gt;namelen;
01110                     rp.<a class="code" href=
"structnetsnmp__handler__registration__s.html#o6">priority</a> = child-&gt;<a class="code" href=
"structnetsnmp__handler__registration__s.html#o6">priority</a>;
01111                     rp.<a class="code" href=
"structnetsnmp__handler__registration__s.html#o7">range_subid</a> = child-&gt;<a class="code" href=
"structnetsnmp__handler__registration__s.html#o7">range_subid</a>;
01112                     rp.<a class="code" href=
"structnetsnmp__handler__registration__s.html#o8">range_ubound</a> = child-&gt;<a class="code" href=
"structnetsnmp__handler__registration__s.html#o8">range_ubound</a>;
01113                     rp.<a class="code" href=
"structnetsnmp__handler__registration__s.html#o9">timeout</a> = child-&gt;<a class="code" href=
"structnetsnmp__handler__registration__s.html#o9">timeout</a>;
01114                     rp.flags = child-&gt;flags;
01115 
01116                     <span class="keywordflow">if</span> (child-&gt;reginfo != NULL) {
01117                         <span class="comment">/*</span>
01118 <span class="comment">                         * Don't let's free the session pointer just yet!  </span>
01119 <span class="comment">                         */</span>
01120                         child-&gt;reginfo-&gt;<a class="code" href=
"structnetsnmp__handler__registration__s.html#o4">handler</a>-&gt;<a class="code" href=
"structnetsnmp__mib__handler__s.html#o1">myvoid</a> = NULL;
01121                         <a class="code" href=
"group__handler.html#ga21">netsnmp_handler_registration_free</a>(child-&gt;reginfo);
01122                         child-&gt;reginfo = NULL;
01123                     }
01124 
01125                     netsnmp_subtree_unload(child, prev, contextptr-&gt;context_name);
01126                     netsnmp_subtree_free(child);
01127 
01128                     <a class="code" href="group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
01129                                         SNMPD_CALLBACK_UNREGISTER_OID, &amp;rp);
01130                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(rp.name);
01131                 } <span class="keywordflow">else</span> {
01132                     prev = child;
01133                 }
01134             }
01135         }
01136         netsnmp_subtree_join(contextptr-&gt;first_subtree);
01137     }
01138 }
01139 
01140 <span class="comment">/*</span>
01141 <span class="comment"> * in_a_view: determines if a given snmp_pdu is allowed to see a</span>
01142 <span class="comment"> * given name/namelen OID pointer</span>
01143 <span class="comment"> * name         IN - name of var, OUT - name matched</span>
01144 <span class="comment"> * nameLen      IN -number of sub-ids in name, OUT - subid-is in matched name</span>
01145 <span class="comment"> * pi           IN - relevant auth info re PDU </span>
01146 <span class="comment"> * cvp          IN - relevant auth info re mib module</span>
01147 <span class="comment"> */</span>
01148 
01149 <span class="keywordtype">int</span>
01150 in_a_view(oid *name, size_t *namelen, <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu, <span class=
"keywordtype">int</span> type)
01151 {
01152     <span class="keyword">struct </span>view_parameters view_parms;
01153 
01154     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a> &amp; UCD_MSG_FLAG_ALWAYS_IN_VIEW) {
01155         <span class="comment">/* Enable bypassing of view-based access control */</span>
01156         <span class="keywordflow">return</span> VACM_SUCCESS;
01157     }
01158 
01159     <span class="comment">/*</span>
01160 <span class="comment">     * check for v1 and counter64s, since snmpv1 doesn't support it </span>
01161 <span class="comment">     */</span>
01162 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
01163     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o0">version</a> == SNMP_VERSION_1 &amp;&amp; type == ASN_COUNTER64) {
01164         <span class="keywordflow">return</span> VACM_NOTINVIEW;
01165     }
01166 <span class="preprocessor">#endif</span>
01167 
01168     view_parms.pdu = pdu;
01169     view_parms.name = name;
01170     <span class="keywordflow">if</span> (namelen != NULL) {
01171         view_parms.namelen = *namelen;
01172     } <span class="keywordflow">else</span> {
01173         view_parms.namelen = 0;
01174     }
01175     view_parms.errorcode = 0;
01176     view_parms.check_subtree = 0;
01177 
01178     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>) {
01179 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
01180     <span class="keywordflow">case</span> SNMP_VERSION_1:
01181 <span class="preprocessor">#endif</span>
01182 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
01183     <span class="keywordflow">case</span> SNMP_VERSION_2c:
01184 <span class="preprocessor">#endif</span>
01185     <span class="keywordflow">case</span> SNMP_VERSION_3:
01186         <a class="code" href="group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
01187                             SNMPD_CALLBACK_ACM_CHECK, &amp;view_parms);
01188         <span class="keywordflow">return</span> view_parms.errorcode;
01189     }
01190     <span class="keywordflow">return</span> VACM_NOSECNAME;
01191 }
01192 
01193 <span class="comment">/*</span>
01194 <span class="comment"> * check_acces: determines if a given snmp_pdu is ever going to be</span>
01195 <span class="comment"> * allowed to do anynthing or if it's not going to ever be</span>
01196 <span class="comment"> * authenticated.</span>
01197 <span class="comment"> */</span>
01198 <span class="keywordtype">int</span>
01199 check_access(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
01200 {                               <span class="comment">/* IN - pdu being checked */</span>
01201     <span class="keyword">struct </span>view_parameters view_parms;
01202     view_parms.pdu = pdu;
01203     view_parms.name = 0;
01204     view_parms.namelen = 0;
01205     view_parms.errorcode = 0;
01206     view_parms.check_subtree = 0;
01207 
01208     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a> &amp; UCD_MSG_FLAG_ALWAYS_IN_VIEW) {
01209         <span class="comment">/* Enable bypassing of view-based access control */</span>
01210         <span class="keywordflow">return</span> 0;
01211     }
01212 
01213     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>) {
01214 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
01215     <span class="keywordflow">case</span> SNMP_VERSION_1:
01216 <span class="preprocessor">#endif</span>
01217 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
01218     <span class="keywordflow">case</span> SNMP_VERSION_2c:
01219 <span class="preprocessor">#endif</span>
01220     <span class="keywordflow">case</span> SNMP_VERSION_3:
01221         <a class="code" href="group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
01222                             SNMPD_CALLBACK_ACM_CHECK_INITIAL, &amp;view_parms);
01223         <span class="keywordflow">return</span> view_parms.errorcode;
01224     }
01225     <span class="keywordflow">return</span> 1;
01226 }
01227 
01235 <span class="keywordtype">int</span>
<a name="l01236" id="l01236"></a><a class="code" href="group__agent__registry.html#ga50">01236</a> <a class="code" href=
"group__agent__registry.html#ga50">netsnmp_acm_check_subtree</a>(<a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *pdu, oid *name, size_t namelen)
01237 {                               <span class="comment">/* IN - pdu being checked */</span>
01238     <span class="keyword">struct </span>view_parameters view_parms;
01239     view_parms.pdu = pdu;
01240     view_parms.name = name;
01241     view_parms.namelen = namelen;
01242     view_parms.errorcode = 0;
01243     view_parms.check_subtree = 1;
01244 
01245     <span class="keywordflow">if</span> (pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a> &amp; UCD_MSG_FLAG_ALWAYS_IN_VIEW) {
01246         <span class="comment">/* Enable bypassing of view-based access control */</span>
01247         <span class="keywordflow">return</span> 0;
01248     }
01249 
01250     <span class="keywordflow">switch</span> (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a>) {
01251 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
01252     <span class="keywordflow">case</span> SNMP_VERSION_1:
01253 <span class="preprocessor">#endif</span>
01254 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
01255     <span class="keywordflow">case</span> SNMP_VERSION_2c:
01256 <span class="preprocessor">#endif</span>
01257     <span class="keywordflow">case</span> SNMP_VERSION_3:
01258         <a class="code" href="group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
01259                             SNMPD_CALLBACK_ACM_CHECK_SUBTREE, &amp;view_parms);
01260         <span class="keywordflow">return</span> view_parms.errorcode;
01261     }
01262     <span class="keywordflow">return</span> 1;
01263 }
01264 
01265 <span class="preprocessor">#define SUBTREE_DEFAULT_CACHE_SIZE 8</span>
01266 <span class="preprocessor">#define SUBTREE_MAX_CACHE_SIZE     32</span>
01267 <span class="keywordtype">int</span> lookup_cache_size = 0; <span class=
"comment">/*enabled later after registrations are loaded */</span>
01268 
01269 <span class="keyword">typedef</span> <span class="keyword">struct </span>lookup_cache_s {
01270    netsnmp_subtree *next;
01271    netsnmp_subtree *previous;
01272 } lookup_cache;
01273 
01274 <span class="keyword">typedef</span> <span class="keyword">struct </span>lookup_cache_context_s {
01275    <span class="keywordtype">char</span> *context;
01276    <span class="keyword">struct </span>lookup_cache_context_s *next;
01277    <span class="keywordtype">int</span> thecachecount;
01278    <span class="keywordtype">int</span> currentpos;
01279    lookup_cache cache[SUBTREE_MAX_CACHE_SIZE];
01280 } lookup_cache_context;
01281 
01282 <span class="keyword">static</span> lookup_cache_context *thecontextcache = NULL;
01283 
01295 <span class="keywordtype">void</span>
<a name="l01296" id="l01296"></a><a class="code" href="group__agent__registry.html#ga21">01296</a> <a class="code" href=
"group__agent__registry.html#ga21">netsnmp_set_lookup_cache_size</a>(<span class="keywordtype">int</span> newsize) {
01297     <span class="keywordflow">if</span> (newsize &lt; 0)
01298         lookup_cache_size = SUBTREE_DEFAULT_CACHE_SIZE;
01299     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newsize &lt; SUBTREE_MAX_CACHE_SIZE)
01300         lookup_cache_size = newsize;
01301     <span class="keywordflow">else</span>
01302         lookup_cache_size = SUBTREE_MAX_CACHE_SIZE;
01303 }
01304 
01308 <span class="keywordtype">int</span>
<a name="l01309" id="l01309"></a><a class="code" href="group__agent__registry.html#ga22">01309</a> <a class="code" href=
"group__agent__registry.html#ga22">netsnmp_get_lookup_cache_size</a>(<span class="keywordtype">void</span>) {
01310     <span class="keywordflow">return</span> lookup_cache_size;
01311 }
01312 
01313 NETSNMP_STATIC_INLINE lookup_cache_context *
01314 get_context_lookup_cache(<span class="keyword">const</span> <span class="keywordtype">char</span> *context) {
01315     lookup_cache_context *ptr;
01316     <span class="keywordflow">if</span> (!context)
01317         context = <span class="stringliteral">""</span>;
01318 
01319     <span class="keywordflow">for</span>(ptr = thecontextcache; ptr; ptr = ptr-&gt;next) {
01320         <span class="keywordflow">if</span> (strcmp(ptr-&gt;context, context) == 0)
01321             <span class="keywordflow">break</span>;
01322     }
01323     <span class="keywordflow">if</span> (!ptr) {
01324         <span class="keywordflow">if</span> (netsnmp_subtree_find_first(context)) {
01325             ptr = <a class="code" href="group__util.html#ga39">SNMP_MALLOC_TYPEDEF</a>(lookup_cache_context);
01326             ptr-&gt;next = thecontextcache;
01327             ptr-&gt;context = strdup(context);
01328             thecontextcache = ptr;
01329         } <span class="keywordflow">else</span> {
01330             <span class="keywordflow">return</span> NULL;
01331         }
01332     }
01333     <span class="keywordflow">return</span> ptr;
01334 }
01335 
01336 NETSNMP_STATIC_INLINE <span class="keywordtype">void</span>
01337 lookup_cache_add(<span class="keyword">const</span> <span class="keywordtype">char</span> *context,
01338                  netsnmp_subtree *next, netsnmp_subtree *previous) {
01339     lookup_cache_context *cptr;
01340 
01341     <span class="keywordflow">if</span> ((cptr = get_context_lookup_cache(context)) == NULL)
01342         <span class="keywordflow">return</span>;
01343     
01344     <span class="keywordflow">if</span> (cptr-&gt;thecachecount &lt; lookup_cache_size)
01345         cptr-&gt;thecachecount++;
01346 
01347     cptr-&gt;cache[cptr-&gt;currentpos].next = next;
01348     cptr-&gt;cache[cptr-&gt;currentpos].previous = previous;
01349 
01350     <span class="keywordflow">if</span> (++cptr-&gt;currentpos &gt;= lookup_cache_size)
01351         cptr-&gt;currentpos = 0;
01352 }
01353 
01354 NETSNMP_STATIC_INLINE <span class="keywordtype">void</span>
01355 lookup_cache_replace(lookup_cache *ptr,
01356                      netsnmp_subtree *next, netsnmp_subtree *previous) {
01357 
01358     ptr-&gt;next = next;
01359     ptr-&gt;previous = previous;
01360 }
01361 
01362 NETSNMP_STATIC_INLINE lookup_cache *
01363 lookup_cache_find(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *context, oid *name, size_t name_len,
01364                   <span class="keywordtype">int</span> *retcmp) {
01365     lookup_cache_context *cptr;
01366     lookup_cache *ret = NULL;
01367     <span class="keywordtype">int</span> cmp;
01368     <span class="keywordtype">int</span> i;
01369 
01370     <span class="keywordflow">if</span> ((cptr = get_context_lookup_cache(context)) == NULL)
01371         <span class="keywordflow">return</span> NULL;
01372 
01373     <span class="keywordflow">for</span>(i = 0; i &lt; cptr-&gt;thecachecount &amp;&amp; i &lt; lookup_cache_size; i++) {
01374         <span class="keywordflow">if</span> (cptr-&gt;cache[i].previous-&gt;start_a)
01375             cmp = <a class="code" href="group__library.html#ga98">snmp_oid_compare</a>(name, name_len,
01376                                    cptr-&gt;cache[i].previous-&gt;start_a,
01377                                    cptr-&gt;cache[i].previous-&gt;start_len);
01378         <span class="keywordflow">else</span>
01379             cmp = 1;
01380         <span class="keywordflow">if</span> (cmp &gt;= 0) {
01381             *retcmp = cmp;
01382             ret = &amp;(cptr-&gt;cache[i]);
01383         }
01384     }
01385     <span class="keywordflow">return</span> ret;
01386 }
01387 
01388 NETSNMP_STATIC_INLINE <span class="keywordtype">void</span>
01389 invalidate_lookup_cache(<span class="keyword">const</span> <span class="keywordtype">char</span> *context) {
01390     lookup_cache_context *cptr;
01391     <span class="keywordflow">if</span> ((cptr = get_context_lookup_cache(context)) != NULL) {
01392         cptr-&gt;thecachecount = 0;
01393         cptr-&gt;currentpos = 0;
01394     }
01395 }
01396 
01397 netsnmp_subtree *
01398 netsnmp_subtree_find_prev(oid *name, size_t len, netsnmp_subtree *subtree,
01399                           <span class="keyword">const</span> <span class="keywordtype">char</span> *context_name)
01400 {
01401     lookup_cache *lookup_cache = NULL;
01402     netsnmp_subtree *myptr = NULL, *previous = NULL;
01403     <span class="keywordtype">int</span> cmp = 1;
01404 
01405     <span class="keywordflow">if</span> (subtree) {
01406         myptr = subtree;
01407     } <span class="keywordflow">else</span> {
01408         <span class="comment">/* look through everything */</span>
01409         <span class="keywordflow">if</span> (lookup_cache_size) {
01410             lookup_cache = lookup_cache_find(context_name, name, len, &amp;cmp);
01411             <span class="keywordflow">if</span> (lookup_cache) {
01412                 myptr = lookup_cache-&gt;next;
01413                 previous = lookup_cache-&gt;previous;
01414             }
01415             <span class="keywordflow">if</span> (!myptr)
01416                 myptr = netsnmp_subtree_find_first(context_name);
01417         } <span class="keywordflow">else</span> {
01418             myptr = netsnmp_subtree_find_first(context_name);
01419         }
01420     }
01421 
01422     <span class="keywordflow">for</span> (; myptr != NULL; previous = myptr, myptr = myptr-&gt;next) {
01423         <span class="keywordflow">if</span> (<a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>(name, len, myptr-&gt;start_a, myptr-&gt;start_len) &lt; 0) {
01424             <span class="keywordflow">if</span> (lookup_cache_size &amp;&amp; previous &amp;&amp; cmp) {
01425                 <span class="keywordflow">if</span> (lookup_cache) {
01426                     lookup_cache_replace(lookup_cache, myptr, previous);
01427                 } <span class="keywordflow">else</span> {
01428                     lookup_cache_add(context_name, myptr, previous);
01429                 }
01430             }
01431             <span class="keywordflow">return</span> previous;
01432         }
01433     }
01434     <span class="keywordflow">return</span> previous;
01435 }
01436 
01437 netsnmp_subtree *
01438 netsnmp_subtree_find_next(oid *name, size_t len,
01439                           netsnmp_subtree *subtree, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *context_name)
01440 {
01441     netsnmp_subtree *myptr = NULL;
01442 
01443     myptr = netsnmp_subtree_find_prev(name, len, subtree, context_name);
01444 
01445     <span class="keywordflow">if</span> (myptr != NULL) {
01446         myptr = myptr-&gt;next;
01447         <span class="keywordflow">while</span> (myptr != NULL &amp;&amp; (myptr-&gt;variables == NULL || 
01448                                  myptr-&gt;variables_len == 0)) {
01449             myptr = myptr-&gt;next;
01450         }
01451         <span class="keywordflow">return</span> myptr;
01452     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (subtree != NULL &amp;&amp; <a class="code"
href="group__library.html#ga98">snmp_oid_compare</a>(name, len, 
01453                                    subtree-&gt;start_a, subtree-&gt;start_len) &lt; 0) {
01454         <span class="keywordflow">return</span> subtree;
01455     } <span class="keywordflow">else</span> {
01456         <span class="keywordflow">return</span> NULL;
01457     }
01458 }
01459 
01460 netsnmp_subtree *
01461 netsnmp_subtree_find(oid *name, size_t len, netsnmp_subtree *subtree, 
01462                      <span class="keyword">const</span> <span class="keywordtype">char</span> *context_name)
01463 {
01464     netsnmp_subtree *myptr;
01465 
01466     myptr = netsnmp_subtree_find_prev(name, len, subtree, context_name);
01467     <span class="keywordflow">if</span> (myptr &amp;&amp; myptr-&gt;end_a &amp;&amp;
01468         <a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>(name, len, myptr-&gt;end_a, myptr-&gt;end_len)&lt;0) {
01469         <span class="keywordflow">return</span> myptr;
01470     }
01471 
01472     <span class="keywordflow">return</span> NULL;
01473 }
01474 
01475 <a class="code" href="structsnmp__session.html">netsnmp_session</a> *
01476 get_session_for_oid(oid *name, size_t len, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *context_name)
01477 {
01478     netsnmp_subtree *myptr;
01479 
01480     myptr = netsnmp_subtree_find_prev(name, len, 
01481                                       netsnmp_subtree_find_first(context_name),
01482                                       context_name);
01483 
01484     <span class="keywordflow">while</span> (myptr &amp;&amp; myptr-&gt;variables == NULL) {
01485         myptr = myptr-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
01486     }
01487 
01488     <span class="keywordflow">if</span> (myptr == NULL) {
01489         <span class="keywordflow">return</span> NULL;
01490     } <span class="keywordflow">else</span> {
01491         <span class="keywordflow">return</span> myptr-&gt;session;
01492     }
01493 }
01494 
01495 <span class="keywordtype">void</span>
01496 setup_tree(<span class="keywordtype">void</span>)
01497 {
01498     oid ccitt[1]           = { 0 };
01499     oid iso[1]             = { 1 };
01500     oid joint_ccitt_iso[1] = { 2 };
01501 
01502 <span class="preprocessor">#ifdef USING_AGENTX_SUBAGENT_MODULE</span>
01503     <span class="keywordtype">int</span> role =  netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, 
01504                                        NETSNMP_DS_AGENT_ROLE);
01505 
01506     <a class="code" href=
"group__default__store.html#ga8">netsnmp_ds_set_boolean</a>(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_AGENT_ROLE, 
01507                            MASTER_AGENT);
01508 <span class="preprocessor">#endif</span>
01509 
01510     <span class="comment">/* </span>
01511 <span class="comment">     * we need to have the oid's in the heap, that we can *free* it for every case, </span>
01512 <span class="comment">     * thats the purpose of the duplicate_objid's</span>
01513 <span class="comment">     */</span>
01514     netsnmp_register_null(snmp_duplicate_objid(ccitt, 1), 1);
01515     netsnmp_register_null(snmp_duplicate_objid(iso, 1), 1);
01516     netsnmp_register_null(snmp_duplicate_objid(joint_ccitt_iso, 1), 1);
01517 
01518 <span class="preprocessor">#ifdef USING_AGENTX_SUBAGENT_MODULE</span>
01519     <a class="code" href=
"group__default__store.html#ga8">netsnmp_ds_set_boolean</a>(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_AGENT_ROLE, 
01520                            role);
01521 <span class="preprocessor">#endif</span>
01522 }
01523 
01524 <span class="keywordtype">int</span> 
01525 remove_tree_entry (oid *name, size_t len) {
01526 
01527     netsnmp_subtree *sub = NULL;
01528 
01529     <span class="keywordflow">if</span> ((sub = netsnmp_subtree_find(name, len, NULL, <span class=
"stringliteral">""</span>)) == NULL) {
01530         <span class="keywordflow">return</span> MIB_NO_SUCH_REGISTRATION;
01531     }
01532 
01533     <span class="keywordflow">return</span> <a class="code" href=
"group__agent__registry.html#ga42">unregister_mib_context</a>(name, len, sub-&gt;priority,
01534                                   sub-&gt;range_subid, sub-&gt;range_ubound, <span class="stringliteral">""</span>);
01535 
01536 }
01537 
01538 
01539 <span class="keywordtype">void</span>
01540 shutdown_tree(<span class="keywordtype">void</span>) {
01541     oid ccitt[1]           = { 0 };
01542     oid iso[1]             = { 1 };
01543     oid joint_ccitt_iso[1] = { 2 };
01544 
01545     DEBUGMSGTL((<span class="stringliteral">"agent_registry"</span>, <span class=
"stringliteral">"shut down tree\n"</span>));
01546 
01547     remove_tree_entry(joint_ccitt_iso, 1);
01548     remove_tree_entry(iso, 1);
01549     remove_tree_entry(ccitt, 1);
01550 
01551 }
01552 
01553 <span class="keywordtype">void</span>
01554 clear_subtree (netsnmp_subtree *sub) {
01555 
01556     netsnmp_subtree *nxt;
01557     
01558     <span class="keywordflow">if</span> (sub == NULL)
01559         <span class="keywordflow">return</span>;
01560 
01561     <span class="keywordflow">for</span>(nxt = sub; nxt;) {
01562         <span class="keywordflow">if</span> (nxt-&gt;children != NULL) {
01563             clear_subtree(nxt-&gt;children);
01564         }
01565         sub = nxt;
01566         nxt = nxt-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
01567         netsnmp_subtree_free(sub);
01568     }
01569 
01570 }
01571 
01572 <span class="keywordtype">void</span>
01573 clear_lookup_cache(<span class="keywordtype">void</span>) {
01574 
01575     lookup_cache_context *ptr = NULL, *next = NULL;
01576 
01577     ptr = thecontextcache;
01578     <span class="keywordflow">while</span> (ptr) {
01579         next = ptr-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
01580         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ptr-&gt;context);
01581         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ptr);
01582         ptr = next;
01583     }
01584     thecontextcache = NULL; <span class="comment">/* !!! */</span>
01585 }
01586 
01587 <span class="keywordtype">void</span>
01588 clear_context(<span class="keywordtype">void</span>) {
01589 
01590     subtree_context_cache *ptr = NULL, *next = NULL;
01591 
01592     DEBUGMSGTL((<span class="stringliteral">"agent_registry"</span>, <span class=
"stringliteral">"clear context\n"</span>));
01593 
01594     ptr = get_top_context_cache(); 
01595     <span class="keywordflow">while</span> (ptr) {
01596         next = ptr-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
01597 
01598         <span class="keywordflow">if</span> (ptr-&gt;first_subtree) {
01599             clear_subtree(ptr-&gt;first_subtree);
01600         }
01601 
01602         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ptr-&gt;context_name);
01603         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ptr);
01604 
01605         ptr = next;
01606     }
01607     context_subtrees = NULL; <span class="comment">/* !!! */</span>
01608     clear_lookup_cache();
01609 }
01610 
01611 <span class="keyword">extern</span> <span class="keywordtype">void</span>     dump_idx_registry(<span class=
"keywordtype">void</span>);
01612 <span class="keywordtype">void</span>
01613 dump_registry(<span class="keywordtype">void</span>)
01614 {
01615     <span class="keyword">struct </span>variable *vp = NULL;
01616     netsnmp_subtree *myptr, *myptr2;
01617     u_char *s = NULL, *e = NULL, *v = NULL;
01618     size_t sl = 256, el = 256, vl = 256, sl_o = 0, el_o = 0, vl_o = 0;
01619     <span class="keywordtype">int</span> i = 0;
01620 
01621     <span class="keywordflow">if</span> ((s = (u_char *) calloc(sl, 1)) != NULL &amp;&amp;
01622         (e = (u_char *) calloc(sl, 1)) != NULL &amp;&amp;
01623         (v = (u_char *) calloc(sl, 1)) != NULL) {
01624 
01625         subtree_context_cache *ptr;
01626         <span class="keywordflow">for</span> (ptr = context_subtrees; ptr; ptr = ptr-&gt;next) {
01627             printf(<span class="stringliteral">"Subtrees for Context: %s\n"</span>, ptr-&gt;context_name);
01628             <span class="keywordflow">for</span> (myptr = ptr-&gt;first_subtree; myptr != NULL;
01629                  myptr = myptr-&gt;next) {
01630                 sl_o = el_o = vl_o = 0;
01631 
01632                 <span class="keywordflow">if</span> (!sprint_realloc_objid(&amp;s, &amp;sl, &amp;sl_o, 1,
01633                                           myptr-&gt;start_a,
01634                                           myptr-&gt;start_len)) {
01635                     <span class="keywordflow">break</span>;
01636                 }
01637                 <span class="keywordflow">if</span> (!sprint_realloc_objid(&amp;e, &amp;el, &amp;el_o, 1,
01638                                           myptr-&gt;end_a,
01639                                           myptr-&gt;end_len)) {
01640                     <span class="keywordflow">break</span>;
01641                 }
01642 
01643                 <span class="keywordflow">if</span> (myptr-&gt;variables) {
01644                     printf(<span class="stringliteral">"%02x ( %s - %s ) ["</span>, myptr-&gt;flags, s, e);
01645                     <span class="keywordflow">for</span> (i = 0, vp = myptr-&gt;variables;
01646                          i &lt; myptr-&gt;variables_len; i++) {
01647                         vl_o = 0;
01648                         <span class="keywordflow">if</span> (!sprint_realloc_objid
01649                             (&amp;v, &amp;vl, &amp;vl_o, 1, vp-&gt;name, vp-&gt;namelen)) {
01650                             <span class="keywordflow">break</span>;
01651                         }
01652                         printf(<span class="stringliteral">"%s, "</span>, v);
01653                         vp = (<span class="keyword">struct </span>variable *) ((<span class=
"keywordtype">char</span> *) vp +
01654                                                   myptr-&gt;variables_width);
01655                     }
01656                     printf(<span class="stringliteral">"]\n"</span>);
01657                 } <span class="keywordflow">else</span> {
01658                     printf(<span class="stringliteral">"%02x   %s - %s  \n"</span>, myptr-&gt;flags, s, e);
01659                 }
01660                 <span class="keywordflow">for</span> (myptr2 = myptr; myptr2 != NULL;
01661                      myptr2 = myptr2-&gt;children) {
01662                     <span class="keywordflow">if</span> (myptr2-&gt;label_a &amp;&amp; myptr2-&gt;label_a[0]) {
01663                         <span class="keywordflow">if</span> (strcmp(myptr2-&gt;label_a, <span class=
"stringliteral">"old_api"</span>) == 0) {
01664                             <span class="keyword">struct </span>variable *vp =
01665                                 myptr2-&gt;reginfo-&gt;handler-&gt;<a class="code" href=
"structsnmp__session.html#o46">myvoid</a>;
01666 
01667                             sprint_realloc_objid(&amp;s, &amp;sl, &amp;sl_o, 1,
01668                                                  vp-&gt;name, vp-&gt;namelen);
01669                             printf(<span class="stringliteral">"\t%s[%s] %p var %s\n"</span>, myptr2-&gt;label_a,
01670                                    myptr2-&gt;reginfo-&gt;handlerName ? myptr2-&gt;
01671                                    reginfo-&gt;<a class="code" href=
"structnetsnmp__handler__registration__s.html#o0">handlerName</a> : <span class="stringliteral">"no-name"</span>,
01672                                    myptr2-&gt;reginfo, s);
01673                         } <span class="keywordflow">else</span> {
01674                             printf(<span class="stringliteral">"\t%s %s %p\n"</span>, myptr2-&gt;label_a,
01675                                    myptr2-&gt;reginfo-&gt;handlerName ? myptr2-&gt;
01676                                    reginfo-&gt;
01677                                    handlerName : <span class="stringliteral">"no-handler-name"</span>,
01678                                    myptr2-&gt;reginfo);
01679                         }
01680                     }
01681                 }
01682             }
01683         }
01684     }
01685 
01686     <span class="keywordflow">if</span> (s != NULL) {
01687         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s);
01688     }
01689     <span class="keywordflow">if</span> (e != NULL) {
01690         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(e);
01691     }
01692     <span class="keywordflow">if</span> (v != NULL) {
01693         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(v);
01694     }
01695 
01696     dump_idx_registry();
01697 }
01698 
01699 
01700 <span class="keywordtype">int</span>     external_readfd[NUM_EXTERNAL_FDS],   external_readfdlen   = 0;
01701 <span class="keywordtype">int</span>     external_writefd[NUM_EXTERNAL_FDS],  external_writefdlen  = 0;
01702 <span class="keywordtype">int</span>     external_exceptfd[NUM_EXTERNAL_FDS], external_exceptfdlen = 0;
01703 void  (*external_readfdfunc[NUM_EXTERNAL_FDS]) (int, <span class="keywordtype">void</span> *);
01704 void  (*external_writefdfunc[NUM_EXTERNAL_FDS]) (int, <span class="keywordtype">void</span> *);
01705 void  (*external_exceptfdfunc[NUM_EXTERNAL_FDS]) (int, <span class="keywordtype">void</span> *);
01706 <span class="keywordtype">void</span>   *external_readfd_data[NUM_EXTERNAL_FDS];
01707 <span class="keywordtype">void</span>   *external_writefd_data[NUM_EXTERNAL_FDS];
01708 <span class="keywordtype">void</span>   *external_exceptfd_data[NUM_EXTERNAL_FDS];
01709 
01710 <span class="keywordtype">int</span>
01711 register_readfd(<span class="keywordtype">int</span> fd, <span class="keywordtype">void</span> (*func) (<span class=
"keywordtype">int</span>, <span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *data)
01712 {
01713     <span class="keywordflow">if</span> (external_readfdlen &lt; NUM_EXTERNAL_FDS) {
01714         external_readfd[external_readfdlen] = fd;
01715         external_readfdfunc[external_readfdlen] = func;
01716         external_readfd_data[external_readfdlen] = data;
01717         external_readfdlen++;
01718         DEBUGMSGTL((<span class="stringliteral">"register_readfd"</span>, <span class=
"stringliteral">"registered fd %d\n"</span>, fd));
01719         <span class="keywordflow">return</span> FD_REGISTERED_OK;
01720     } <span class="keywordflow">else</span> {
01721         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_CRIT, <span class=
"stringliteral">"register_readfd: too many file descriptors\n"</span>);
01722         <span class="keywordflow">return</span> FD_REGISTRATION_FAILED;
01723     }
01724 }
01725 
01726 <span class="keywordtype">int</span>
01727 register_writefd(<span class="keywordtype">int</span> fd, <span class="keywordtype">void</span> (*func) (<span class=
"keywordtype">int</span>, <span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *data)
01728 {
01729     <span class="keywordflow">if</span> (external_writefdlen &lt; NUM_EXTERNAL_FDS) {
01730         external_writefd[external_writefdlen] = fd;
01731         external_writefdfunc[external_writefdlen] = func;
01732         external_writefd_data[external_writefdlen] = data;
01733         external_writefdlen++;
01734         DEBUGMSGTL((<span class="stringliteral">"register_writefd"</span>, <span class=
"stringliteral">"registered fd %d\n"</span>, fd));
01735         <span class="keywordflow">return</span> FD_REGISTERED_OK;
01736     } <span class="keywordflow">else</span> {
01737         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_CRIT,
01738                  <span class="stringliteral">"register_writefd: too many file descriptors\n"</span>);
01739         <span class="keywordflow">return</span> FD_REGISTRATION_FAILED;
01740     }
01741 }
01742 
01743 <span class="keywordtype">int</span>
01744 register_exceptfd(<span class="keywordtype">int</span> fd, <span class="keywordtype">void</span> (*func) (<span class=
"keywordtype">int</span>, <span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *data)
01745 {
01746     <span class="keywordflow">if</span> (external_exceptfdlen &lt; NUM_EXTERNAL_FDS) {
01747         external_exceptfd[external_exceptfdlen] = fd;
01748         external_exceptfdfunc[external_exceptfdlen] = func;
01749         external_exceptfd_data[external_exceptfdlen] = data;
01750         external_exceptfdlen++;
01751         DEBUGMSGTL((<span class="stringliteral">"register_exceptfd"</span>, <span class=
"stringliteral">"registered fd %d\n"</span>, fd));
01752         <span class="keywordflow">return</span> FD_REGISTERED_OK;
01753     } <span class="keywordflow">else</span> {
01754         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_CRIT,
01755                  <span class="stringliteral">"register_exceptfd: too many file descriptors\n"</span>);
01756         <span class="keywordflow">return</span> FD_REGISTRATION_FAILED;
01757     }
01758 }
01759 
01760 <span class="keywordtype">int</span>
01761 unregister_readfd(<span class="keywordtype">int</span> fd)
01762 {
01763     <span class="keywordtype">int</span>             i, j;
01764 
01765     <span class="keywordflow">for</span> (i = 0; i &lt; external_readfdlen; i++) {
01766         <span class="keywordflow">if</span> (external_readfd[i] == fd) {
01767             external_readfdlen--;
01768             <span class="keywordflow">for</span> (j = i; j &lt; external_readfdlen; j++) {
01769                 external_readfd[j] = external_readfd[j + 1];
01770                 external_readfdfunc[j] = external_readfdfunc[j + 1];
01771                 external_readfd_data[j] = external_readfd_data[j + 1];
01772             }
01773             DEBUGMSGTL((<span class="stringliteral">"unregister_readfd"</span>, <span class=
"stringliteral">"unregistered fd %d\n"</span>, fd));
01774             <span class="keywordflow">return</span> FD_UNREGISTERED_OK;
01775         }
01776     }
01777     <span class="keywordflow">return</span> FD_NO_SUCH_REGISTRATION;
01778 }
01779 
01780 <span class="keywordtype">int</span>
01781 unregister_writefd(<span class="keywordtype">int</span> fd)
01782 {
01783     <span class="keywordtype">int</span>             i, j;
01784 
01785     <span class="keywordflow">for</span> (i = 0; i &lt; external_writefdlen; i++) {
01786         <span class="keywordflow">if</span> (external_writefd[i] == fd) {
01787             external_writefdlen--;
01788             <span class="keywordflow">for</span> (j = i; j &lt; external_writefdlen; j++) {
01789                 external_writefd[j] = external_writefd[j + 1];
01790                 external_writefdfunc[j] = external_writefdfunc[j + 1];
01791                 external_writefd_data[j] = external_writefd_data[j + 1];
01792             }
01793             DEBUGMSGTL((<span class="stringliteral">"unregister_writefd"</span>, <span class=
"stringliteral">"unregistered fd %d\n"</span>, fd));
01794             <span class="keywordflow">return</span> FD_UNREGISTERED_OK;
01795         }
01796     }
01797     <span class="keywordflow">return</span> FD_NO_SUCH_REGISTRATION;
01798 }
01799 
01800 <span class="keywordtype">int</span>
01801 unregister_exceptfd(<span class="keywordtype">int</span> fd)
01802 {
01803     <span class="keywordtype">int</span>             i, j;
01804 
01805     <span class="keywordflow">for</span> (i = 0; i &lt; external_exceptfdlen; i++) {
01806         <span class="keywordflow">if</span> (external_exceptfd[i] == fd) {
01807             external_exceptfdlen--;
01808             <span class="keywordflow">for</span> (j = i; j &lt; external_exceptfdlen; j++) {
01809                 external_exceptfd[j] = external_exceptfd[j + 1];
01810                 external_exceptfdfunc[j] = external_exceptfdfunc[j + 1];
01811                 external_exceptfd_data[j] = external_exceptfd_data[j + 1];
01812             }
01813             DEBUGMSGTL((<span class="stringliteral">"unregister_exceptfd"</span>, <span class=
"stringliteral">"unregistered fd %d\n"</span>,
01814                         fd));
01815             <span class="keywordflow">return</span> FD_UNREGISTERED_OK;
01816         }
01817     }
01818     <span class="keywordflow">return</span> FD_NO_SUCH_REGISTRATION;
01819 }
01820 
01821 <span class="keywordtype">int</span>             external_signal_scheduled[NUM_EXTERNAL_SIGS];
01822 void            (*external_signal_handler[NUM_EXTERNAL_SIGS]) (int);
01823 
01824 <span class="preprocessor">#ifndef WIN32</span>
01825 
01826 <span class="comment">/*</span>
01827 <span class="comment"> * TODO: add agent_SIGXXX_handler functions and `case SIGXXX: ...' lines</span>
01828 <span class="comment"> *       below for every single that might be handled by register_signal().</span>
01829 <span class="comment"> */</span>
01830 
01831 RETSIGTYPE
01832 agent_SIGCHLD_handler(<span class="keywordtype">int</span> sig)
01833 {
01834     external_signal_scheduled[SIGCHLD]++;
01835 <span class="preprocessor">#ifndef HAVE_SIGACTION</span>
01836     <span class="comment">/*</span>
01837 <span class="comment">     * signal() sucks. It *might* have SysV semantics, which means that</span>
01838 <span class="comment">     * * a signal handler is reset once it gets called. Ensure that it</span>
01839 <span class="comment">     * * remains active.</span>
01840 <span class="comment">     */</span>
01841     signal(SIGCHLD, agent_SIGCHLD_handler);
01842 <span class="preprocessor">#endif</span>
01843 }
01844 
01845 <span class="keywordtype">int</span>
01846 register_signal(<span class="keywordtype">int</span> sig, <span class="keywordtype">void</span> (*func) (<span class=
"keywordtype">int</span>))
01847 {
01848 
01849     <span class="keywordflow">switch</span> (sig) {
01850 <span class="preprocessor">#if defined(SIGCHLD)</span>
01851     <span class="keywordflow">case</span> SIGCHLD:
01852 <span class="preprocessor">#ifdef HAVE_SIGACTION</span>
01853         {
01854             <span class="keyword">static</span> <span class="keyword">struct </span>sigaction act;
01855             act.sa_handler = agent_SIGCHLD_handler;
01856             sigemptyset(&amp;act.sa_mask);
01857             act.sa_flags = 0;
01858             sigaction(SIGCHLD, &amp;act, NULL);
01859         }
01860 <span class="preprocessor">#else</span>
01861         signal(SIGCHLD, agent_SIGCHLD_handler);
01862 <span class="preprocessor">#endif</span>
01863         <span class="keywordflow">break</span>;
01864 <span class="preprocessor">#endif</span>
01865     <span class="keywordflow">default</span>:
01866         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_CRIT,
01867                  <span class="stringliteral">"register_signal: signal %d cannot be handled\n"</span>, sig);
01868         <span class="keywordflow">return</span> SIG_REGISTRATION_FAILED;
01869     }
01870 
01871     external_signal_handler[sig] = func;
01872     external_signal_scheduled[sig] = 0;
01873 
01874     DEBUGMSGTL((<span class="stringliteral">"register_signal"</span>, <span class=
"stringliteral">"registered signal %d\n"</span>, sig));
01875     <span class="keywordflow">return</span> SIG_REGISTERED_OK;
01876 }
01877 
01878 <span class="keywordtype">int</span>
01879 unregister_signal(<span class="keywordtype">int</span> sig)
01880 {
01881     signal(sig, SIG_DFL);
01882     DEBUGMSGTL((<span class="stringliteral">"unregister_signal"</span>, <span class=
"stringliteral">"unregistered signal %d\n"</span>, sig));
01883     <span class="keywordflow">return</span> SIG_UNREGISTERED_OK;
01884 }
01885 
01886 <span class="preprocessor">#endif                          </span><span class="comment">/* !WIN32 */</span>
01887 
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small><!--#include virtual="/sfbutton.html" --><br />
    Generated on Thu Oct 28 21:46:56 2004 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

