<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>net-snmp: Net-SNMP Agent handler and extensibility API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">net-snmp&#160;<span id="projectnumber">5.7</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Net-SNMP Agent handler and extensibility API</div>  </div>
<div class="ingroups"><a class="el" href="group__agent.html">The Net-SNMP agent</a></div></div>
<div class="contents">

<p>The basic theory goes something like this: In the past, with the original mib module api (which derived from the original CMU SNMP code) the underlying mib modules were passed very little information (only the truly most basic information about a request).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the mib handler structure to be registered  <a href="structnetsnmp__mib__handler__s.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Root registration info.  <a href="structnetsnmp__handler__registration__s.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnetsnmp__handler__args__s.html">netsnmp_handler_args_s</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnetsnmp__delegated__cache__s.html">netsnmp_delegated_cache_s</a></td></tr>
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html">utility_handlers</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Simplify request processing A group of handlers intended to simplify certain aspects of processing a request for a MIB object. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__leaf.html">leaf_handlers</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Process individual leaf objects A group of handlers to implement individual leaf objects and instances (both scalar objects, and individual objects and instances within a table). </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__baby__steps.html">baby_steps</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Calls your handler in baby_steps for set processing. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__old__api.html">old_api</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Calls mib module code written in the old style of code. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stash__cache.html">stash_cache</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Automatically caches data for certain handlers. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__table.html">table</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Helps you implement a table. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga164274e46962ce0e69a4ef5a35c3ddf8"></a><!-- doxytag: member="handler::MIB_HANDLER_AUTO_NEXT" ref="ga164274e46962ce0e69a4ef5a35c3ddf8" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIB_HANDLER_AUTO_NEXT</b>&#160;&#160;&#160;0x00000001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac6769b9ef1064bc496da0a10cebeec3b"></a><!-- doxytag: member="handler::MIB_HANDLER_AUTO_NEXT_OVERRIDE_ONCE" ref="gac6769b9ef1064bc496da0a10cebeec3b" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIB_HANDLER_AUTO_NEXT_OVERRIDE_ONCE</b>&#160;&#160;&#160;0x00000002</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f5e150bfd131f036b2add3fc7f7be73"></a><!-- doxytag: member="handler::MIB_HANDLER_INSTANCE" ref="ga6f5e150bfd131f036b2add3fc7f7be73" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIB_HANDLER_INSTANCE</b>&#160;&#160;&#160;0x00000004</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ce7c5e66b8efe7e5a79ef147ff3eea1"></a><!-- doxytag: member="handler::MIB_HANDLER_CUSTOM4" ref="ga2ce7c5e66b8efe7e5a79ef147ff3eea1" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIB_HANDLER_CUSTOM4</b>&#160;&#160;&#160;0x10000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7592b7402d7184242e132416eaa96b70"></a><!-- doxytag: member="handler::MIB_HANDLER_CUSTOM3" ref="ga7592b7402d7184242e132416eaa96b70" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIB_HANDLER_CUSTOM3</b>&#160;&#160;&#160;0x20000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf509fadc999e7ebb1f2f6413cbc1f1a1"></a><!-- doxytag: member="handler::MIB_HANDLER_CUSTOM2" ref="gaf509fadc999e7ebb1f2f6413cbc1f1a1" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIB_HANDLER_CUSTOM2</b>&#160;&#160;&#160;0x40000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga88b8effeaf40cbccf66838a0bdaf47d6"></a><!-- doxytag: member="handler::MIB_HANDLER_CUSTOM1" ref="ga88b8effeaf40cbccf66838a0bdaf47d6" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIB_HANDLER_CUSTOM1</b>&#160;&#160;&#160;0x80000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9f5bef4022d9998d9755959fd7ccf662"></a><!-- doxytag: member="handler::HANDLER_CAN_GETANDGETNEXT" ref="ga9f5bef4022d9998d9755959fd7ccf662" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HANDLER_CAN_GETANDGETNEXT</b>&#160;&#160;&#160;0x01</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab40590598eab2ee6ce2bce87a8619ce5"></a><!-- doxytag: member="handler::HANDLER_CAN_SET" ref="gab40590598eab2ee6ce2bce87a8619ce5" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HANDLER_CAN_SET</b>&#160;&#160;&#160;0x02</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8270faef505ac7cb1d7b75f0cfe8da35"></a><!-- doxytag: member="handler::HANDLER_CAN_GETBULK" ref="ga8270faef505ac7cb1d7b75f0cfe8da35" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HANDLER_CAN_GETBULK</b>&#160;&#160;&#160;0x04</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga975e839a9b896909c16212e62deb3e8f"></a><!-- doxytag: member="handler::HANDLER_CAN_NOT_CREATE" ref="ga975e839a9b896909c16212e62deb3e8f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HANDLER_CAN_NOT_CREATE</b>&#160;&#160;&#160;0x08</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae02917cb1c4f228b7aa511e8fbe8e736"></a><!-- doxytag: member="handler::HANDLER_CAN_BABY_STEP" ref="gae02917cb1c4f228b7aa511e8fbe8e736" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HANDLER_CAN_BABY_STEP</b>&#160;&#160;&#160;0x10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0319a7dadb4e95ea1f11c1eb8e8eced7"></a><!-- doxytag: member="handler::HANDLER_CAN_STASH" ref="ga0319a7dadb4e95ea1f11c1eb8e8eced7" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HANDLER_CAN_STASH</b>&#160;&#160;&#160;0x20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7ddb8691abb4248a63cfc38f0392c4bc"></a><!-- doxytag: member="handler::HANDLER_CAN_RONLY" ref="ga7ddb8691abb4248a63cfc38f0392c4bc" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HANDLER_CAN_RONLY</b>&#160;&#160;&#160;(HANDLER_CAN_GETANDGETNEXT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga03c1b4a8a0446dcfb1c8effc432ea91e"></a><!-- doxytag: member="handler::HANDLER_CAN_RWRITE" ref="ga03c1b4a8a0446dcfb1c8effc432ea91e" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HANDLER_CAN_RWRITE</b>&#160;&#160;&#160;(HANDLER_CAN_GETANDGETNEXT | HANDLER_CAN_SET)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1cdf4e84d36c3d904c9e6f4eb9e9c444"></a><!-- doxytag: member="handler::HANDLER_CAN_SET_ONLY" ref="ga1cdf4e84d36c3d904c9e6f4eb9e9c444" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HANDLER_CAN_SET_ONLY</b>&#160;&#160;&#160;(HANDLER_CAN_SET | HANDLER_CAN_NOT_CREATE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga28a5329a4d48ce4af25b9876e8343595"></a><!-- doxytag: member="handler::HANDLER_CAN_DEFAULT" ref="ga28a5329a4d48ce4af25b9876e8343595" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HANDLER_CAN_DEFAULT</b>&#160;&#160;&#160;(HANDLER_CAN_RONLY | HANDLER_CAN_NOT_CREATE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa6a6bf0ae2b150b658022bf133f928f9"></a><!-- doxytag: member="handler::REQUEST_IS_DELEGATED" ref="gaa6a6bf0ae2b150b658022bf133f928f9" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REQUEST_IS_DELEGATED</b>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad572b091d6840c12089315bda715ffe7"></a><!-- doxytag: member="handler::REQUEST_IS_NOT_DELEGATED" ref="gad572b091d6840c12089315bda715ffe7" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REQUEST_IS_NOT_DELEGATED</b>&#160;&#160;&#160;0</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga77f4225c0e0c1d549e634f58dba3de3d">netsnmp_mib_handler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedefs the <a class="el" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler_s</a> struct into netsnmp_mib_handler.  <a href="#ga77f4225c0e0c1d549e634f58dba3de3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#gac475ff73806c2d76ebfc78a87d921b8b">netsnmp_handler_registration</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedefs the <a class="el" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration_s</a> struct into netsnmp_handler_registration.  <a href="#gac475ff73806c2d76ebfc78a87d921b8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3869cb145f61a81ad7a835adc3f33bf0"></a><!-- doxytag: member="handler::Netsnmp_Node_Handler" ref="ga3869cb145f61a81ad7a835adc3f33bf0" args=")(netsnmp_mib_handler *handler, netsnmp_handler_registration *reginfo, netsnmp_agent_request_info *reqinfo, netsnmp_request_info *requests)" -->
typedef int(&#160;</td><td class="memItemRight" valign="bottom"><b>Netsnmp_Node_Handler</b> )(<a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *handler, <a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo, <a class="el" href="structnetsnmp__agent__request__info__s.html">netsnmp_agent_request_info</a> *reqinfo, <a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *requests)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5437f5d545d0034d060323fdebfa0b61"></a><!-- doxytag: member="handler::netsnmp_handler_args" ref="ga5437f5d545d0034d060323fdebfa0b61" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="structnetsnmp__handler__args__s.html">netsnmp_handler_args_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>netsnmp_handler_args</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga092d18ed86d78b2e24c49a76b30662e9"></a><!-- doxytag: member="handler::netsnmp_delegated_cache" ref="ga092d18ed86d78b2e24c49a76b30662e9" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="structnetsnmp__delegated__cache__s.html">netsnmp_delegated_cache_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>netsnmp_delegated_cache</b></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga287199b9db5d7f8e93d3e7369cdb8631">netsnmp_handler_registration_create</a> (const char *name, <a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *handler, const oid *reg_oid, size_t reg_oid_len, int modes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a MIB handler structure.  <a href="#ga287199b9db5d7f8e93d3e7369cdb8631"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga537fac61fff7e112e121e5f629eded65">netsnmp_create_handler_registration</a> (const char *name, Netsnmp_Node_Handler *handler_access_method, const oid *reg_oid, size_t reg_oid_len, int modes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a handler registration structure with a new MIB handler.  <a href="#ga537fac61fff7e112e121e5f629eded65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#gacdbdb9d74898a5bf04b0992ea0316aa4">netsnmp_register_handler</a> (<a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a MIB handler inside the registration structure.  <a href="#gacdbdb9d74898a5bf04b0992ea0316aa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga62639943d2328300a27a196205fe88de">netsnmp_unregister_handler</a> (<a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a MIB handler described inside the registration structure.  <a href="#ga62639943d2328300a27a196205fe88de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#gab05fc800c46b5bd81125ed623d0d989c">netsnmp_register_handler_nocallback</a> (<a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a MIB handler inside the registration structure.  <a href="#gab05fc800c46b5bd81125ed623d0d989c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga1dea0606678b435440ac3267a9f36f6b">netsnmp_inject_handler_before</a> (<a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo, <a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *handler, const char *before_what)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects handler into the calling chain of handlers.  <a href="#ga1dea0606678b435440ac3267a9f36f6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga6649d75b3eaf98d70704754d3d8235f3">netsnmp_inject_handler</a> (<a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo, <a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *handler)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects handler into the calling chain of handlers.  <a href="#ga6649d75b3eaf98d70704754d3d8235f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#gad9c9c2c88fc86c2838bfab9fd87270cb">netsnmp_call_handler</a> (<a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *next_handler, <a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo, <a class="el" href="structnetsnmp__agent__request__info__s.html">netsnmp_agent_request_info</a> *reqinfo, <a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *requests)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a MIB handlers chain, starting with specific handler.  <a href="#gad9c9c2c88fc86c2838bfab9fd87270cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#gac0eb7f89dee961df2d09084fd7925952">netsnmp_handler_free</a> (<a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *handler)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates resources associated with a given handler.  <a href="#gac0eb7f89dee961df2d09084fd7925952"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga6e129a4e26986e07d1b65f2be6e79a97">netsnmp_handler_dup</a> (<a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *handler)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates a MIB handler and all subsequent handlers.  <a href="#ga6e129a4e26986e07d1b65f2be6e79a97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga8335082f0d99bb6cf19771ae75725c58">netsnmp_handler_registration_free</a> (<a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free resources associated with a handler registration object.  <a href="#ga8335082f0d99bb6cf19771ae75725c58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga448ff32b31b535f1772012e58744e00f">netsnmp_handler_registration_dup</a> (<a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates handler registration object and all subsequent handlers.  <a href="#ga448ff32b31b535f1772012e58744e00f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_INLINE <br class="typebreak"/>
<a class="el" href="structnetsnmp__delegated__cache__s.html">netsnmp_delegated_cache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga1b1324a6635e13db666189caa91b6b04">netsnmp_create_delegated_cache</a> (<a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *handler, <a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo, <a class="el" href="structnetsnmp__agent__request__info__s.html">netsnmp_agent_request_info</a> *reqinfo, <a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *requests, void *localinfo)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a cache of information which can be saved for future reference.  <a href="#ga1b1324a6635e13db666189caa91b6b04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_INLINE <br class="typebreak"/>
<a class="el" href="structnetsnmp__delegated__cache__s.html">netsnmp_delegated_cache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga5bce39313c473465dc3128127a3da75f">netsnmp_handler_check_cache</a> (<a class="el" href="structnetsnmp__delegated__cache__s.html">netsnmp_delegated_cache</a> *dcache)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a given delegated cache is still valid.  <a href="#ga5bce39313c473465dc3128127a3da75f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#gab06f90f7b3c942c5fa19bc29a994e657">netsnmp_free_delegated_cache</a> (<a class="el" href="structnetsnmp__delegated__cache__s.html">netsnmp_delegated_cache</a> *dcache)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a cache once it's no longer used.  <a href="#gab06f90f7b3c942c5fa19bc29a994e657"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga4a4542018f162f3929a4bf0d90d3fe76">netsnmp_handler_mark_requests_as_delegated</a> (<a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *requests, int isdelegated)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a list of requests as delegated or not delegated.  <a href="#ga4a4542018f162f3929a4bf0d90d3fe76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#gacc092f27f7c4203fe20665c8341023c8">netsnmp_request_add_list_data</a> (<a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *request, <a class="el" href="structnetsnmp__data__list__s.html">netsnmp_data_list</a> *node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds data from node list to the request information structure.  <a href="#gacc092f27f7c4203fe20665c8341023c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#gac1dd5d6dc36145dc6f1552750edce93c">netsnmp_request_remove_list_data</a> (<a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *request, const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all data from a request.  <a href="#gac1dd5d6dc36145dc6f1552750edce93c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#gac8ebe16c4ca9e9e8d06fadcaa2650079">netsnmp_request_get_list_data</a> (<a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *request, const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts data from a request.  <a href="#gac8ebe16c4ca9e9e8d06fadcaa2650079"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#gacbdb429ed1fa170c441f6058f20ba112">netsnmp_free_request_data_set</a> (<a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *request)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the extra data stored in a request.  <a href="#gacbdb429ed1fa170c441f6058f20ba112"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga14d1a9eeb19594f07d4cb70de8a89145">netsnmp_free_request_data_sets</a> (<a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *request)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the extra data stored in a bunch of requests.  <a href="#ga14d1a9eeb19594f07d4cb70de8a89145"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga2b0f905c6ac5a8a51ff68623cd2f7327">netsnmp_find_handler_by_name</a> (<a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo, const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a MIB handler from a chain based on the name.  <a href="#ga2b0f905c6ac5a8a51ff68623cd2f7327"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga6b85cb5b40f357ae415c44a1f3e50f5a">netsnmp_find_handler_data_by_name</a> (<a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo, const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handler's void pointer from a chain based on the name.  <a href="#ga6b85cb5b40f357ae415c44a1f3e50f5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4912165f65937b04bcecdba8cd198d81"></a><!-- doxytag: member="handler::handler_free_callback" ref="ga4912165f65937b04bcecdba8cd198d81" args="(void *handler)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>handler_free_callback</b> (void *handler)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#gacbb642ff9ceefcd591d455e0c9295bc5">netsnmp_register_handler_by_name</a> (const char *name, <a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *handler)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a given handler by name, so that it can be found easily later.  <a href="#gacbb642ff9ceefcd591d455e0c9295bc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handler.html#ga51fb49d72729dac64d3a781a86e397d9">netsnmp_clear_handler_list</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the entire MIB Handlers registration list.  <a href="#ga51fb49d72729dac64d3a781a86e397d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaeff27bbb82fdebde534d9ba2b8a1543"></a><!-- doxytag: member="handler::netsnmp_call_next_handler_one_request" ref="gaaeff27bbb82fdebde534d9ba2b8a1543" args="(netsnmp_mib_handler *current, netsnmp_handler_registration *reginfo, netsnmp_agent_request_info *reqinfo, netsnmp_request_info *requests)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>netsnmp_call_next_handler_one_request</b> (<a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *current, <a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *reginfo, <a class="el" href="structnetsnmp__agent__request__info__s.html">netsnmp_agent_request_info</a> *reqinfo, <a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *requests)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeb090a81fbe0cbea3434f12a993d0b43"></a><!-- doxytag: member="handler::netsnmp_create_handler" ref="gaeb090a81fbe0cbea3434f12a993d0b43" args="(const char *name, Netsnmp_Node_Handler *handler_access_method)" -->
<a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>netsnmp_create_handler</b> (const char *name, Netsnmp_Node_Handler *handler_access_method)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6fc0f2b801066c8076b0bc6891483cea"></a><!-- doxytag: member="handler::netsnmp_handler_get_parent_data" ref="ga6fc0f2b801066c8076b0bc6891483cea" args="(netsnmp_request_info *, const char *)" -->
void *&#160;</td><td class="memItemRight" valign="bottom"><b>netsnmp_handler_get_parent_data</b> (<a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *, const char *)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The basic theory goes something like this: In the past, with the original mib module api (which derived from the original CMU SNMP code) the underlying mib modules were passed very little information (only the truly most basic information about a request). </p>
<p>This worked well at the time but in todays world of subagents, device instrumentation, low resource consumption, etc, it just isn't flexible enough. "handlers" are here to fix all that.</p>
<p>With the rewrite of the agent internals for the net-snmp 5.0 release, we introduce a modular calling scheme that allows agent modules to be written in a very flexible manner, and more importantly allows reuse of code in a decent way (and without the memory and speed overheads of OO languages like C++).</p>
<p>Functionally, the notion of what a handler does is the same as the older api: A handler is <a class="el" href="#gaeb090a81fbe0cbea3434f12a993d0b43">created</a> and then <a class="el" href="group__handler.html#gacdbdb9d74898a5bf04b0992ea0316aa4">registered</a> with the main agent at a given OID in the OID tree and gets called any time a request is made that it should respond to. You probably should use one of the convenience helpers instead of doing anything else yourself though:</p>
<p>Most importantly, though, is that the handlers are built on the notion of modularity and reuse. Specifically, rather than do all the really hard work (like parsing table indexes out of an incoming oid request) in each module, the API is designed to make it easy to write "helper" handlers that merely process some aspect of the request before passing it along to the final handler that returns the real answer. Most people will want to make use of the <a class="el" href="group__instance.html">instance</a>, <a class="el" href="group__table.html">table</a>, <a class="el" href="group__table__iterator.html">table_iterator</a>, <a class="el" href="group__table__data.html">table_data</a>, or <a class="el" href="group__table__dataset.html">table_dataset</a> helpers to make their life easier. These "helpers" interpert important aspects of the request and pass them on to you.</p>
<p>For instance, the <a class="el" href="group__table.html">table</a> helper is designed to hand you a list of extracted index values from an incoming request. THe <a class="el" href="group__table__iterator.html">table_iterator</a> helper is built on top of the table helper, and is designed to help you iterate through data stored elsewhere (like in a kernel) that is not in OID lexographical order (ie, don't write your own index/oid sorting routine, use this helper instead). The beauty of the <a class="el" href="group__table__iterator.html">table_iterator helper</a>, as well as the <a class="el" href="group__instance.html">instance</a> helper is that they take care of the complex GETNEXT processing entirely for you and hand you everything you need to merely return the data as if it was a GET request. Much less code and hair pulling. I've pulled all my hair out to help you so that only one of us has to be bald. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gac475ff73806c2d76ebfc78a87d921b8b"></a><!-- doxytag: member="agent_handler.h::netsnmp_handler_registration" ref="gac475ff73806c2d76ebfc78a87d921b8b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration_s</a> <a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Typedefs the <a class="el" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration_s</a> struct into netsnmp_handler_registration. </p>

</div>
</div>
<a class="anchor" id="ga77f4225c0e0c1d549e634f58dba3de3d"></a><!-- doxytag: member="agent_handler.h::netsnmp_mib_handler" ref="ga77f4225c0e0c1d549e634f58dba3de3d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler_s</a> <a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Typedefs the <a class="el" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler_s</a> struct into netsnmp_mib_handler. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad9c9c2c88fc86c2838bfab9fd87270cb"></a><!-- doxytag: member="agent_handler.c::netsnmp_call_handler" ref="gad9c9c2c88fc86c2838bfab9fd87270cb" args="(netsnmp_mib_handler *next_handler, netsnmp_handler_registration *reginfo, netsnmp_agent_request_info *reqinfo, netsnmp_request_info *requests)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int netsnmp_call_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *&#160;</td>
          <td class="paramname"><em>next_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td>
          <td class="paramname"><em>reginfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnetsnmp__agent__request__info__s.html">netsnmp_agent_request_info</a> *&#160;</td>
          <td class="paramname"><em>reqinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *&#160;</td>
          <td class="paramname"><em>requests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls a MIB handlers chain, starting with specific handler. </p>
<p>The given arguments and MIB handler are checked for sanity, then the handlers are called, one by one, until next handler is NULL.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns SNMPERR_SUCCESS or SNMP_ERR_* error code. </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00485">485</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga51fb49d72729dac64d3a781a86e397d9"></a><!-- doxytag: member="agent_handler.c::netsnmp_clear_handler_list" ref="ga51fb49d72729dac64d3a781a86e397d9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netsnmp_clear_handler_list </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the entire MIB Handlers registration list. </p>
<p>MIB Handlers registration list is used to access any MIB Handler by its name. The function frees the list memory and sets pointer to NULL. Instead of calling this function directly, use shutdown_agent().</p>
<dl class="see"><dt><b>See also:</b></dt><dd>shutdown_agent() </dd>
<dd>
<a class="el" href="group__handler.html#gacbb642ff9ceefcd591d455e0c9295bc5" title="Registers a given handler by name, so that it can be found easily later.">netsnmp_register_handler_by_name()</a> </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l01150">1150</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1b1324a6635e13db666189caa91b6b04"></a><!-- doxytag: member="agent_handler.c::netsnmp_create_delegated_cache" ref="ga1b1324a6635e13db666189caa91b6b04" args="(netsnmp_mib_handler *handler, netsnmp_handler_registration *reginfo, netsnmp_agent_request_info *reqinfo, netsnmp_request_info *requests, void *localinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnetsnmp__delegated__cache__s.html">netsnmp_delegated_cache</a> * netsnmp_create_delegated_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td>
          <td class="paramname"><em>reginfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnetsnmp__agent__request__info__s.html">netsnmp_agent_request_info</a> *&#160;</td>
          <td class="paramname"><em>reqinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *&#160;</td>
          <td class="paramname"><em>requests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>localinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a cache of information which can be saved for future reference. </p>
<p>The cache is filled with pointers from parameters. Note that the input structures are not duplicated, but put directly into the new cache struct. Use <a class="el" href="group__handler.html#ga5bce39313c473465dc3128127a3da75f" title="Check if a given delegated cache is still valid.">netsnmp_handler_check_cache()</a> later to make sure it's still valid before referencing it in the future.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#ga5bce39313c473465dc3128127a3da75f" title="Check if a given delegated cache is still valid.">netsnmp_handler_check_cache()</a> </dd>
<dd>
<a class="el" href="group__handler.html#gab06f90f7b3c942c5fa19bc29a994e657" title="Free a cache once it&#39;s no longer used.">netsnmp_free_delegated_cache()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="delayed_instance_8c-example.html#a9">delayed_instance.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00853">853</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga537fac61fff7e112e121e5f629eded65"></a><!-- doxytag: member="agent_handler.c::netsnmp_create_handler_registration" ref="ga537fac61fff7e112e121e5f629eded65" args="(const char *name, Netsnmp_Node_Handler *handler_access_method, const oid *reg_oid, size_t reg_oid_len, int modes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> * netsnmp_create_handler_registration </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Netsnmp_Node_Handler *&#160;</td>
          <td class="paramname"><em>handler_access_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const oid *&#160;</td>
          <td class="paramname"><em>reg_oid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reg_oid_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a handler registration structure with a new MIB handler. </p>
<p>This function first <a class="el" href="#gaeb090a81fbe0cbea3434f12a993d0b43">creates </a> a MIB handler, then <a class="el" href="group__handler.html#ga287199b9db5d7f8e93d3e7369cdb8631">makes registation structure </a> for it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the handler name for netsnmp_create_handler()</td></tr>
    <tr><td class="paramname">handler_access_method</td><td>is a function pointer used as the access method for netsnmp_create_handler()</td></tr>
    <tr><td class="paramname">reg_oid</td><td>is the registration location oid.</td></tr>
    <tr><td class="paramname">reg_oid_len</td><td>is the length of reg_oid; can use the macro, OID_LENGTH</td></tr>
    <tr><td class="paramname">modes</td><td>is used to configure read/write access, as in <a class="el" href="group__handler.html#ga287199b9db5d7f8e93d3e7369cdb8631" title="Creates a MIB handler structure.">netsnmp_handler_registration_create()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to a netsnmp_handler_registration struct. If the structures creation failed, NULL is returned.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>netsnmp_create_handler() </dd>
<dd>
<a class="el" href="group__handler.html#ga287199b9db5d7f8e93d3e7369cdb8631" title="Creates a MIB handler structure.">netsnmp_handler_registration_create()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="data_set_8c-example.html#a6">data_set.c</a>, <a class="el" href="delayed_instance_8c-example.html#a1">delayed_instance.c</a>, and <a class="el" href="watched_8c-example.html#a2">watched.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00219">219</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga2b0f905c6ac5a8a51ff68623cd2f7327"></a><!-- doxytag: member="agent_handler.c::netsnmp_find_handler_by_name" ref="ga2b0f905c6ac5a8a51ff68623cd2f7327" args="(netsnmp_handler_registration *reginfo, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> * netsnmp_find_handler_by_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td>
          <td class="paramname"><em>reginfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a MIB handler from a chain based on the name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reginfo</td><td>Handler registration struct which contains the chain.</td></tr>
    <tr><td class="paramname">name</td><td>Target MIB Handler name string. The name is case sensitive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The MIB Handler is returned, or NULL if not found.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#gacc092f27f7c4203fe20665c8341023c8" title="Adds data from node list to the request information structure.">netsnmp_request_add_list_data()</a> </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l01051">1051</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga6b85cb5b40f357ae415c44a1f3e50f5a"></a><!-- doxytag: member="agent_handler.c::netsnmp_find_handler_data_by_name" ref="ga6b85cb5b40f357ae415c44a1f3e50f5a" args="(netsnmp_handler_registration *reginfo, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * netsnmp_find_handler_data_by_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td>
          <td class="paramname"><em>reginfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a handler's void pointer from a chain based on the name. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The void pointer data may change as a handler evolves. Handlers should really advertise some function for you to use instead.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reginfo</td><td>Handler registration struct which contains the chain.</td></tr>
    <tr><td class="paramname">name</td><td>Target MIB Handler name string. The name is case sensitive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The MIB Handler's void * pointer is returned, or NULL if the handler is not found.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#ga2b0f905c6ac5a8a51ff68623cd2f7327" title="Returns a MIB handler from a chain based on the name.">netsnmp_find_handler_by_name()</a> </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l01082">1082</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab06f90f7b3c942c5fa19bc29a994e657"></a><!-- doxytag: member="agent_handler.c::netsnmp_free_delegated_cache" ref="gab06f90f7b3c942c5fa19bc29a994e657" args="(netsnmp_delegated_cache *dcache)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netsnmp_free_delegated_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__delegated__cache__s.html">netsnmp_delegated_cache</a> *&#160;</td>
          <td class="paramname"><em>dcache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a cache once it's no longer used. </p>
<p>Deletes the data allocated by <a class="el" href="group__handler.html#ga1b1324a6635e13db666189caa91b6b04" title="Creates a cache of information which can be saved for future reference.">netsnmp_create_delegated_cache()</a>. Structures which were not allocated by <a class="el" href="group__handler.html#ga1b1324a6635e13db666189caa91b6b04" title="Creates a cache of information which can be saved for future reference.">netsnmp_create_delegated_cache()</a> are not freed (pointers are dropped).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dcache</td><td>is the delegated cache to be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#ga1b1324a6635e13db666189caa91b6b04" title="Creates a cache of information which can be saved for future reference.">netsnmp_create_delegated_cache()</a> </dd>
<dd>
<a class="el" href="group__handler.html#ga5bce39313c473465dc3128127a3da75f" title="Check if a given delegated cache is still valid.">netsnmp_handler_check_cache()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="delayed_instance_8c-example.html#a19">delayed_instance.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00908">908</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="gacbdb429ed1fa170c441f6058f20ba112"></a><!-- doxytag: member="agent_handler.c::netsnmp_free_request_data_set" ref="gacbdb429ed1fa170c441f6058f20ba112" args="(netsnmp_request_info *request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netsnmp_free_request_data_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the extra data stored in a request. </p>
<p>Deletes the data in given request only. Other chain items are unaffected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>Request information structure to be modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#gacc092f27f7c4203fe20665c8341023c8" title="Adds data from node list to the request information structure.">netsnmp_request_add_list_data()</a> </dd>
<dd>
netsnmp_free_list_data() </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l01016">1016</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga14d1a9eeb19594f07d4cb70de8a89145"></a><!-- doxytag: member="agent_handler.c::netsnmp_free_request_data_sets" ref="ga14d1a9eeb19594f07d4cb70de8a89145" args="(netsnmp_request_info *request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netsnmp_free_request_data_sets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the extra data stored in a bunch of requests. </p>
<p>Deletes all data in the chain inside request.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>Request information structure to be modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#gacc092f27f7c4203fe20665c8341023c8" title="Adds data from node list to the request information structure.">netsnmp_request_add_list_data()</a> </dd>
<dd>
<a class="el" href="group__handler.html#gacbdb429ed1fa170c441f6058f20ba112" title="Free the extra data stored in a request.">netsnmp_free_request_data_set()</a> </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l01031">1031</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga5bce39313c473465dc3128127a3da75f"></a><!-- doxytag: member="agent_handler.c::netsnmp_handler_check_cache" ref="ga5bce39313c473465dc3128127a3da75f" args="(netsnmp_delegated_cache *dcache)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnetsnmp__delegated__cache__s.html">netsnmp_delegated_cache</a> * netsnmp_handler_check_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__delegated__cache__s.html">netsnmp_delegated_cache</a> *&#160;</td>
          <td class="paramname"><em>dcache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a given delegated cache is still valid. </p>
<p>The cache is valid if it's a part of transaction (ie, the agent still considers it to be an outstanding request).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dcache</td><td>is the delegated cache to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the cache pointer if it is still valid, NULL otherwise.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#ga1b1324a6635e13db666189caa91b6b04" title="Creates a cache of information which can be saved for future reference.">netsnmp_create_delegated_cache()</a> </dd>
<dd>
<a class="el" href="group__handler.html#gab06f90f7b3c942c5fa19bc29a994e657" title="Free a cache once it&#39;s no longer used.">netsnmp_free_delegated_cache()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="delayed_instance_8c-example.html#a11">delayed_instance.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00885">885</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga6e129a4e26986e07d1b65f2be6e79a97"></a><!-- doxytag: member="agent_handler.c::netsnmp_handler_dup" ref="ga6e129a4e26986e07d1b65f2be6e79a97" args="(netsnmp_mib_handler *handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> * netsnmp_handler_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicates a MIB handler and all subsequent handlers. </p>
<p>Creates a copy of all data in given handlers chain.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>is the MIB Handler to be duplicated</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the complete copy, or NULL if any problem occured.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>_clone_handler() </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00712">712</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac0eb7f89dee961df2d09084fd7925952"></a><!-- doxytag: member="agent_handler.c::netsnmp_handler_free" ref="gac0eb7f89dee961df2d09084fd7925952" args="(netsnmp_mib_handler *handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netsnmp_handler_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocates resources associated with a given handler. </p>
<p>The handler is removed from chain and then freed. After calling this function, the handler pointer is invalid and should be set to NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>is the MIB Handler to be freed </td></tr>
  </table>
  </dd>
</dl>

<p><p>make sure we aren't pointing to ourselves. </p>
</p>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00683">683</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga4a4542018f162f3929a4bf0d90d3fe76"></a><!-- doxytag: member="agent_handler.c::netsnmp_handler_mark_requests_as_delegated" ref="ga4a4542018f162f3929a4bf0d90d3fe76" args="(netsnmp_request_info *requests, int isdelegated)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netsnmp_handler_mark_requests_as_delegated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *&#160;</td>
          <td class="paramname"><em>requests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isdelegated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a list of requests as delegated or not delegated. </p>
<p>Sweeps through given chain of requests and sets 'delegated' flag accordingly to the isdelegaded parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">isdelegaded</td><td>New value of the 'delegated' flag. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00928">928</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga287199b9db5d7f8e93d3e7369cdb8631"></a><!-- doxytag: member="agent_handler.c::netsnmp_handler_registration_create" ref="ga287199b9db5d7f8e93d3e7369cdb8631" args="(const char *name, netsnmp_mib_handler *handler, const oid *reg_oid, size_t reg_oid_len, int modes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> * netsnmp_handler_registration_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const oid *&#160;</td>
          <td class="paramname"><em>reg_oid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reg_oid_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a MIB handler structure. </p>
<p>The new structure is allocated and filled using the given name, access function, registration location OID and list of modes that the handler supports. If modes == 0, then modes will automatically be set to the default value of only HANDLER_CAN_DEFAULT, which is by default read-only GET and GETNEXT requests. A hander which supports sets but not row creation should set us a mode of HANDLER_CAN_SET_ONLY. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This ends up calling netsnmp_create_handler(name, handler_access_method) </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the handler name and is copied then assigned to netsnmp_handler_registration-&gt;handlerName.</td></tr>
    <tr><td class="paramname">handler</td><td>is a function pointer used as the access method for this handler registration instance for whatever required needs.</td></tr>
    <tr><td class="paramname">reg_oid</td><td>is the registration location oid.</td></tr>
    <tr><td class="paramname">reg_oid_len</td><td>is the length of reg_oid; can use the macro, OID_LENGTH</td></tr>
    <tr><td class="paramname">modes</td><td>is used to configure read/write access. If modes == 0, then modes will automatically be set to the default value of only HANDLER_CAN_DEFAULT, which is by default read-only GET and GETNEXT requests. The other two mode options are read only, HANDLER_CAN_RONLY, and read/write, HANDLER_CAN_RWRITE.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>HANDLER_CAN_GETANDGETNEXT</li>
<li>HANDLER_CAN_SET</li>
<li>HANDLER_CAN_GETBULK</li>
</ul>
<ul>
<li>HANDLER_CAN_RONLY (HANDLER_CAN_GETANDGETNEXT)</li>
<li>HANDLER_CAN_RWRITE (HANDLER_CAN_GETANDGETNEXT | HANDLER_CAN_SET)</li>
<li>HANDLER_CAN_DEFAULT HANDLER_CAN_RONLY</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to a netsnmp_handler_registration struct. NULL is returned only when memory could not be allocated for the netsnmp_handler_registration struct.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>netsnmp_create_handler() </dd>
<dd>
<a class="el" href="group__handler.html#gacdbdb9d74898a5bf04b0992ea0316aa4" title="Registers a MIB handler inside the registration structure.">netsnmp_register_handler()</a> </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00170">170</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga448ff32b31b535f1772012e58744e00f"></a><!-- doxytag: member="agent_handler.c::netsnmp_handler_registration_dup" ref="ga448ff32b31b535f1772012e58744e00f" args="(netsnmp_handler_registration *reginfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> * netsnmp_handler_registration_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td>
          <td class="paramname"><em>reginfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicates handler registration object and all subsequent handlers. </p>
<p>Creates a copy of the handler registration object and all its data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>is the handler registration object to be duplicated</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the complete copy, or NULL if any problem occured.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#ga6e129a4e26986e07d1b65f2be6e79a97" title="Duplicates a MIB handler and all subsequent handlers.">netsnmp_handler_dup()</a> </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00785">785</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8335082f0d99bb6cf19771ae75725c58"></a><!-- doxytag: member="agent_handler.c::netsnmp_handler_registration_free" ref="ga8335082f0d99bb6cf19771ae75725c58" args="(netsnmp_handler_registration *reginfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netsnmp_handler_registration_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td>
          <td class="paramname"><em>reginfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free resources associated with a handler registration object. </p>
<p>The registration object and all MIB Handlers in the chain are freed. When the function ends, given pointer is no longer valid and should be set to NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reginfo</td><td>is the handler registration object to be freed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00762">762</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga6649d75b3eaf98d70704754d3d8235f3"></a><!-- doxytag: member="agent_handler.c::netsnmp_inject_handler" ref="ga6649d75b3eaf98d70704754d3d8235f3" args="(netsnmp_handler_registration *reginfo, netsnmp_mib_handler *handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int netsnmp_inject_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td>
          <td class="paramname"><em>reginfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Injects handler into the calling chain of handlers. </p>
<p>The given MIB handler is put at the top of the list, and hence will be the handler to be called first.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns SNMPERR_SUCCESS or SNMP_ERR_* error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#ga537fac61fff7e112e121e5f629eded65" title="Creates a handler registration structure with a new MIB handler.">netsnmp_create_handler_registration()</a> </dd>
<dd>
<a class="el" href="group__handler.html#ga1dea0606678b435440ac3267a9f36f6b" title="Injects handler into the calling chain of handlers.">netsnmp_inject_handler_before()</a> </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00471">471</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1dea0606678b435440ac3267a9f36f6b"></a><!-- doxytag: member="agent_handler.c::netsnmp_inject_handler_before" ref="ga1dea0606678b435440ac3267a9f36f6b" args="(netsnmp_handler_registration *reginfo, netsnmp_mib_handler *handler, const char *before_what)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int netsnmp_inject_handler_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td>
          <td class="paramname"><em>reginfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>before_what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Injects handler into the calling chain of handlers. </p>
<p>The given MIB handler is inserted after the handler named before_what. If before_what is NULL, the handler is put at the top of the list, and hence will be the handler to be called first.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns SNMPERR_SUCCESS or SNMP_ERR_* error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#ga537fac61fff7e112e121e5f629eded65" title="Creates a handler registration structure with a new MIB handler.">netsnmp_create_handler_registration()</a> </dd>
<dd>
<a class="el" href="group__handler.html#ga6649d75b3eaf98d70704754d3d8235f3" title="Injects handler into the calling chain of handlers.">netsnmp_inject_handler()</a> </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00409">409</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="gacdbdb9d74898a5bf04b0992ea0316aa4"></a><!-- doxytag: member="agent_handler.c::netsnmp_register_handler" ref="gacdbdb9d74898a5bf04b0992ea0316aa4" args="(netsnmp_handler_registration *reginfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int netsnmp_register_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td>
          <td class="paramname"><em>reginfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers a MIB handler inside the registration structure. </p>
<p>Checks given registation handler for sanity, then <a class="el" href="group__agent__mib__registering.html#gab754f78658b7539cc25e628ea04a487f">performs registration </a> in the MIB tree, as defined by the netsnmp_handler_registration pointer. On success, SNMP_CALLBACK_APPLICATION is called. The registration struct may be created by call of <a class="el" href="group__handler.html#ga537fac61fff7e112e121e5f629eded65" title="Creates a handler registration structure with a new MIB handler.">netsnmp_create_handler_registration()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reginfo</td><td>Pointer to a netsnmp_handler_registration struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns SNMPERR_SUCCESS or SNMP_ERR_* error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#ga537fac61fff7e112e121e5f629eded65" title="Creates a handler registration structure with a new MIB handler.">netsnmp_create_handler_registration()</a> </dd>
<dd>
<a class="el" href="group__agent__mib__registering.html#gab754f78658b7539cc25e628ea04a487f" title="Registers a MIB handler.">netsnmp_register_mib()</a> </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00252">252</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="gacbb642ff9ceefcd591d455e0c9295bc5"></a><!-- doxytag: member="agent_handler.c::netsnmp_register_handler_by_name" ref="gacbb642ff9ceefcd591d455e0c9295bc5" args="(const char *name, netsnmp_mib_handler *handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netsnmp_register_handler_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnetsnmp__mib__handler__s.html">netsnmp_mib_handler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers a given handler by name, so that it can be found easily later. </p>
<p>Pointer to the handler is put into a list where it can be easily located at any time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name string to be associated with the handler.</td></tr>
    <tr><td class="paramname">handler</td><td>Pointer the MIB Handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#ga51fb49d72729dac64d3a781a86e397d9" title="Clears the entire MIB Handlers registration list.">netsnmp_clear_handler_list()</a> </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l01132">1132</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab05fc800c46b5bd81125ed623d0d989c"></a><!-- doxytag: member="agent_handler.c::netsnmp_register_handler_nocallback" ref="gab05fc800c46b5bd81125ed623d0d989c" args="(netsnmp_handler_registration *reginfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int netsnmp_register_handler_nocallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td>
          <td class="paramname"><em>reginfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers a MIB handler inside the registration structure. </p>
<p>Checks given registation handler for sanity, then <a class="el" href="group__agent__mib__registering.html#gab754f78658b7539cc25e628ea04a487f">performs registration </a> in the MIB tree, as defined by the netsnmp_handler_registration pointer. Never calls SNMP_CALLBACK_APPLICATION. The registration struct may be created by call of <a class="el" href="group__handler.html#ga537fac61fff7e112e121e5f629eded65" title="Creates a handler registration structure with a new MIB handler.">netsnmp_create_handler_registration()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reginfo</td><td>Pointer to a netsnmp_handler_registration struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns SNMPERR_SUCCESS or SNMP_ERR_* error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#ga537fac61fff7e112e121e5f629eded65" title="Creates a handler registration structure with a new MIB handler.">netsnmp_create_handler_registration()</a> </dd>
<dd>
<a class="el" href="group__agent__mib__registering.html#gab754f78658b7539cc25e628ea04a487f" title="Registers a MIB handler.">netsnmp_register_mib()</a> </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00352">352</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="gacc092f27f7c4203fe20665c8341023c8"></a><!-- doxytag: member="agent_handler.c::netsnmp_request_add_list_data" ref="gacc092f27f7c4203fe20665c8341023c8" args="(netsnmp_request_info *request, netsnmp_data_list *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netsnmp_request_add_list_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnetsnmp__data__list__s.html">netsnmp_data_list</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds data from node list to the request information structure. </p>
<p>Data in the request can be later extracted and used by submodules.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>Destination request information structure.</td></tr>
    <tr><td class="paramname">node</td><td>The data to be added to the linked list request-&gt;parent_data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#gac1dd5d6dc36145dc6f1552750edce93c" title="Removes all data from a request.">netsnmp_request_remove_list_data()</a> </dd>
<dd>
<a class="el" href="group__handler.html#gac8ebe16c4ca9e9e8d06fadcaa2650079" title="Extracts data from a request.">netsnmp_request_get_list_data()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="delayed_instance_8c-example.html#a21">delayed_instance.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00950">950</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac8ebe16c4ca9e9e8d06fadcaa2650079"></a><!-- doxytag: member="agent_handler.c::netsnmp_request_get_list_data" ref="gac8ebe16c4ca9e9e8d06fadcaa2650079" args="(netsnmp_request_info *request, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * netsnmp_request_get_list_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts data from a request. </p>
<p>Retrieves data that was previously added to the request, usually by a parent module.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>Source request information structure.</td></tr>
    <tr><td class="paramname">name</td><td>Used to compare against the request-&gt;parent_data-&gt;name value; if a match is found, request-&gt;parent_data-&gt;data is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Gives a void pointer(request-&gt;parent_data-&gt;data); NULL is returned if source data is NULL or the object is not found.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#gacc092f27f7c4203fe20665c8341023c8" title="Adds data from node list to the request information structure.">netsnmp_request_add_list_data()</a> </dd>
<dd>
<a class="el" href="group__handler.html#gac1dd5d6dc36145dc6f1552750edce93c" title="Removes all data from a request.">netsnmp_request_remove_list_data()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="delayed_instance_8c-example.html#a25">delayed_instance.c</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00998">998</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac1dd5d6dc36145dc6f1552750edce93c"></a><!-- doxytag: member="agent_handler.c::netsnmp_request_remove_list_data" ref="gac1dd5d6dc36145dc6f1552750edce93c" args="(netsnmp_request_info *request, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int netsnmp_request_remove_list_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__request__info__s.html">netsnmp_request_info</a> *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all data from a request. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>the netsnmp request info structure</td></tr>
    <tr><td class="paramname">name</td><td>this is the name of the previously added data</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on successful find-and-delete, 1 otherwise.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#gacc092f27f7c4203fe20665c8341023c8" title="Adds data from node list to the request information structure.">netsnmp_request_add_list_data()</a> </dd>
<dd>
<a class="el" href="group__handler.html#gac8ebe16c4ca9e9e8d06fadcaa2650079" title="Extracts data from a request.">netsnmp_request_get_list_data()</a> </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00973">973</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga62639943d2328300a27a196205fe88de"></a><!-- doxytag: member="agent_handler.c::netsnmp_unregister_handler" ref="ga62639943d2328300a27a196205fe88de" args="(netsnmp_handler_registration *reginfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int netsnmp_unregister_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnetsnmp__handler__registration__s.html">netsnmp_handler_registration</a> *&#160;</td>
          <td class="paramname"><em>reginfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters a MIB handler described inside the registration structure. </p>
<p>Removes a registration, performed earlier by <a class="el" href="group__handler.html#gacdbdb9d74898a5bf04b0992ea0316aa4" title="Registers a MIB handler inside the registration structure.">netsnmp_register_handler()</a>, from the MIB tree. Uses <a class="el" href="group__agent__mib__registering.html#ga716dbeeb93cb6de5b124e6f89eb7b38a" title="Unregisters a module registered against a given OID (or range) in a specified context.">unregister_mib_context()</a> to do the task.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reginfo</td><td>Pointer to a netsnmp_handler_registration struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns SNMPERR_SUCCESS or SNMP_ERR_* error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__handler.html#gacdbdb9d74898a5bf04b0992ea0316aa4" title="Registers a MIB handler inside the registration structure.">netsnmp_register_handler()</a> </dd>
<dd>
<a class="el" href="group__agent__mib__registering.html#ga716dbeeb93cb6de5b124e6f89eb7b38a" title="Unregisters a module registered against a given OID (or range) in a specified context.">unregister_mib_context()</a> </dd></dl>

<p>Definition at line <a class="el" href="agent__handler_8c_source.html#l00328">328</a> of file <a class="el" href="agent__handler_8c_source.html">agent_handler.c</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jul 14 2011 for net-snmp by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
