<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.6.1 -->

  <div class="navigation" id="top">
    <div class="tabs">
      <ul>
        <li><a href="index.html"><span>Main Page</span></a></li>

        <li><a href="pages.html"><span>Related Pages</span></a></li>

        <li><a href="modules.html"><span>Modules</span></a></li>

        <li><a href="annotated.html"><span>Data Structures</span></a></li>

        <li class="current"><a href="files.html"><span>Files</span></a></li>

        <li><a href="examples.html"><span>Examples</span></a></li>
      </ul>
    </div>

    <div class="tabs">
      <ul>
        <li><a href="files.html"><span>File List</span></a></li>

        <li><a href="globals.html"><span>Globals</span></a></li>
      </ul>
    </div>

    <h1>snmpSSHDomain.c</h1>

    <div class="fragment">
      <pre class="fragment">
<a name="l00001" id="l00001"></a>00001 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
<a name="l00002" id="l00002"></a>00002 
<a name="l00003" id="l00003"></a>00003 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00004" id="l00004"></a>00004 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00005" id="l00005"></a>00005 <span class="preprocessor">#include &lt;errno.h&gt;</span>
<a name="l00006" id="l00006"></a>00006 
<a name="l00007" id="l00007"></a>00007 <span class="preprocessor">#include &lt;libssh2.h&gt;</span>
<a name="l00008" id="l00008"></a>00008 <span class="preprocessor">#include &lt;libssh2_sftp.h&gt;</span>
<a name="l00009" id="l00009"></a>00009 
<a name="l00010" id="l00010"></a>00010 <span class="preprocessor">#ifdef HAVE_SYS_PARAM_H</span>
<a name="l00011" id="l00011"></a>00011 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
<a name="l00012" id="l00012"></a>00012 <span class="preprocessor">#endif</span>
<a name="l00013" id="l00013"></a>00013 <span class="preprocessor">#if HAVE_STRING_H</span>
<a name="l00014" id="l00014"></a>00014 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00015" id="l00015"></a>00015 <span class="preprocessor">#else</span>
<a name="l00016" id="l00016"></a>00016 <span class="preprocessor">#include &lt;strings.h&gt;</span>
<a name="l00017" id="l00017"></a>00017 <span class="preprocessor">#endif</span>
<a name="l00018" id="l00018"></a>00018 <span class="preprocessor">#if HAVE_STDLIB_H</span>
<a name="l00019" id="l00019"></a>00019 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00020" id="l00020"></a>00020 <span class="preprocessor">#endif</span>
<a name="l00021" id="l00021"></a>00021 <span class="preprocessor">#if HAVE_UNISTD_H</span>
<a name="l00022" id="l00022"></a>00022 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00023" id="l00023"></a>00023 <span class="preprocessor">#endif</span>
<a name="l00024" id="l00024"></a>00024 <span class="preprocessor">#if HAVE_SYS_SOCKET_H</span>
<a name="l00025" id="l00025"></a>00025 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
<a name="l00026" id="l00026"></a>00026 <span class="preprocessor">#endif</span>
<a name="l00027" id="l00027"></a>00027 <span class="preprocessor">#if HAVE_SYS_UN_H</span>
<a name="l00028" id="l00028"></a>00028 <span class="preprocessor">#include &lt;sys/un.h&gt;</span>
<a name="l00029" id="l00029"></a>00029 <span class="preprocessor">#endif</span>
<a name="l00030" id="l00030"></a>00030 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
<a name="l00031" id="l00031"></a>00031 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
<a name="l00032" id="l00032"></a>00032 <span class="preprocessor">#endif</span>
<a name="l00033" id="l00033"></a>00033 <span class="preprocessor">#if HAVE_ARPA_INET_H</span>
<a name="l00034" id="l00034"></a>00034 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
<a name="l00035" id="l00035"></a>00035 <span class="preprocessor">#endif</span>
<a name="l00036" id="l00036"></a>00036 <span class="preprocessor">#if HAVE_FCNTL_H</span>
<a name="l00037" id="l00037"></a>00037 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
<a name="l00038" id="l00038"></a>00038 <span class="preprocessor">#endif</span>
<a name="l00039" id="l00039"></a>00039 
<a name="l00040" id="l00040"></a>00040 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
<a name="l00041" id="l00041"></a>00041 <span class="preprocessor">#include &lt;winsock2.h&gt;</span>
<a name="l00042" id="l00042"></a>00042 <span class="preprocessor">#include &lt;ws2tcpip.h&gt;</span>
<a name="l00043" id="l00043"></a>00043 <span class="preprocessor">#endif</span>
<a name="l00044" id="l00044"></a>00044 
<a name="l00045" id="l00045"></a>00045 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
<a name="l00046" id="l00046"></a>00046 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
<a name="l00047" id="l00047"></a>00047 <span class="preprocessor">#endif</span>
<a name="l00048" id="l00048"></a>00048 <span class="preprocessor">#include &lt;pwd.h&gt;</span>
<a name="l00049" id="l00049"></a>00049 
<a name="l00050" id="l00050"></a>00050 <span class="preprocessor">#ifndef MAXPATHLEN</span>
<a name="l00051" id="l00051"></a>00051 <span class="preprocessor">#warn no system max path length detected</span>
<a name="l00052" id="l00052"></a>00052 <span class="preprocessor">#define MAXPATHLEN 2048</span>
<a name="l00053" id="l00053"></a>00053 <span class="preprocessor">#endif</span>
<a name="l00054" id="l00054"></a>00054 
<a name="l00055" id="l00055"></a>00055 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
<a name="l00056" id="l00056"></a>00056 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
<a name="l00057" id="l00057"></a>00057 <span class="preprocessor">#include &lt;<a class="code" href=
"tools_8h.html">net-snmp/library/tools.h</a>&gt;</span>
<a name="l00058" id="l00058"></a>00058 <span class="preprocessor">#include &lt;net-snmp/library/system.h&gt;</span>
<a name="l00059" id="l00059"></a>00059 <span class="preprocessor">#include &lt;net-snmp/library/default_store.h&gt;</span>
<a name="l00060" id="l00060"></a>00060 
<a name="l00061" id="l00061"></a>00061 <span class="preprocessor">#include &lt;net-snmp/library/snmp_transport.h&gt;</span>
<a name="l00062" id="l00062"></a>00062 <span class="preprocessor">#include &lt;net-snmp/library/snmpUDPDomain.h&gt;</span>
<a name="l00063" id="l00063"></a>00063 <span class="preprocessor">#include &lt;net-snmp/library/snmpTCPDomain.h&gt;</span>
<a name="l00064" id="l00064"></a>00064 <span class="preprocessor">#include &lt;net-snmp/library/snmpSSHDomain.h&gt;</span>
<a name="l00065" id="l00065"></a>00065 <span class="preprocessor">#include &lt;net-snmp/library/read_config.h&gt;</span>
<a name="l00066" id="l00066"></a>00066 
<a name="l00067" id="l00067"></a>00067 <span class="preprocessor">#define MAX_NAME_LENGTH 127</span>
<a name="l00068" id="l00068"></a>00068 
<a name="l00069" id="l00069"></a>00069 <span class="preprocessor">#define NETSNMP_SSHTOSNMP_VERSION1      1</span>
<a name="l00070" id="l00070"></a>00070 <span class="preprocessor">#define NETSNMP_MAX_SSHTOSNMP_VERSION   1</span>
<a name="l00071" id="l00071"></a>00071 
<a name="l00072" id="l00072"></a>00072 <span class="preprocessor">#define DEFAULT_SOCK_NAME "sshdomainsocket"</span>
<a name="l00073" id="l00073"></a>00073 
<a name="l00074" id="l00074"></a><a class="code" href="structnetsnmp__ssh__addr__pair__s.html">00074</a> <span class=
"keyword">typedef</span> <span class="keyword">struct </span><a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair_s</a> {
<a name="l00075" id="l00075"></a>00075     <span class="keyword">struct </span>sockaddr_in remote_addr;
<a name="l00076" id="l00076"></a>00076     <span class="keyword">struct </span>in_addr local_addr;
<a name="l00077" id="l00077"></a>00077     LIBSSH2_SESSION *session;
<a name="l00078" id="l00078"></a>00078     LIBSSH2_CHANNEL *channel;
<a name="l00079" id="l00079"></a>00079     <span class="keywordtype">char</span> username[MAX_NAME_LENGTH+1];
<a name="l00080" id="l00080"></a>00080     <span class="keyword">struct </span>sockaddr_un unix_socket_end;
<a name="l00081" id="l00081"></a>00081     <span class="keywordtype">char</span> socket_path[MAXPATHLEN];
<a name="l00082" id="l00082"></a>00082 } <a class="code" href="structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a>;
<a name="l00083" id="l00083"></a>00083 
<a name="l00084" id="l00084"></a>00084 oid netsnmp_snmpSSHDomain[] = { TRANSPORT_DOMAIN_SSH_IP };
<a name="l00085" id="l00085"></a>00085 <span class="keyword">static</span> <a class="code" href=
"structnetsnmp__tdomain__s.html">netsnmp_tdomain</a> sshDomain;
<a name="l00086" id="l00086"></a>00086 
<a name="l00087" id="l00087"></a>00087 <span class="keyword">const</span> <span class=
"keywordtype">char</span> *keyfile1=<span class="stringliteral">"/home/hardaker/.ssh/id_rsa.pub"</span>;
<a name="l00088" id="l00088"></a>00088 <span class="keyword">const</span> <span class=
"keywordtype">char</span> *keyfile2=<span class="stringliteral">"/home/hardaker/.ssh/id_rsa"</span>;
<a name="l00089" id="l00089"></a>00089 <span class="keyword">const</span> <span class=
"keywordtype">char</span> *username=<span class="stringliteral">"hardaker"</span>;
<a name="l00090" id="l00090"></a>00090 
<a name="l00091" id="l00091"></a>00091 <span class="preprocessor">#define SNMPSSHDOMAIN_USE_EXTERNAL_PIPE 1</span>
<a name="l00092" id="l00092"></a>00092 
<a name="l00093" id="l00093"></a>00093 <span class="comment">/*</span>
<a name="l00094" id="l00094"></a>00094 <span class=
"comment"> * Not static since it is needed here as well as in snmpUDPDomain, but not</span>
<a name="l00095" id="l00095"></a>00095 <span class="comment"> * public either</span>
<a name="l00096" id="l00096"></a>00096 <span class="comment"> */</span>
<a name="l00097" id="l00097"></a>00097 <span class="keywordtype">int</span>
<a name="l00098" id="l00098"></a>00098 netsnmp_sockaddr_in2(<span class="keyword">struct</span> sockaddr_in *addr,
<a name="l00099" id="l00099"></a>00099                      <span class="keyword">const</span> <span class=
"keywordtype">char</span> *inpeername, <span class="keyword">const</span> <span class="keywordtype">char</span> *default_target);
<a name="l00100" id="l00100"></a>00100 
<a name="l00101" id="l00101"></a>00101 <span class="comment">/*</span>
<a name="l00102" id="l00102"></a>00102 <span class=
"comment"> * Return a string representing the address in data, or else the "far end"</span>
<a name="l00103" id="l00103"></a>00103 <span class="comment"> * address if data is NULL.  </span>
<a name="l00104" id="l00104"></a>00104 <span class="comment"> */</span>
<a name="l00105" id="l00105"></a>00105 
<a name="l00106" id="l00106"></a>00106 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00107" id="l00107"></a>00107 netsnmp_ssh_fmtaddr(<a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a> *t, <span class="keywordtype">void</span> *data, <span class=
"keywordtype">int</span> len)
<a name="l00108" id="l00108"></a>00108 {
<a name="l00109" id="l00109"></a>00109     <a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a> *addr_pair = NULL;
<a name="l00110" id="l00110"></a>00110 
<a name="l00111" id="l00111"></a>00111     <span class="keywordflow">if</span> (data != NULL &amp;&amp; len == <span class=
"keyword">sizeof</span>(<a class="code" href="structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a>)) {
<a name="l00112" id="l00112"></a>00112         addr_pair = (<a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a> *) data;
<a name="l00113" id="l00113"></a>00113     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL) {
<a name="l00114" id="l00114"></a>00114         addr_pair = (<a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a> *) t-&gt;data;
<a name="l00115" id="l00115"></a>00115     }
<a name="l00116" id="l00116"></a>00116 
<a name="l00117" id="l00117"></a>00117     <span class="keywordflow">if</span> (addr_pair == NULL) {
<a name="l00118" id="l00118"></a>00118         <span class="keywordflow">return</span> strdup(<span class=
"stringliteral">"SSH: unknown"</span>);
<a name="l00119" id="l00119"></a>00119     } <span class="keywordflow">else</span> {
<a name="l00120" id="l00120"></a>00120         <span class="keyword">struct </span>sockaddr_in *to = NULL;
<a name="l00121" id="l00121"></a>00121         <span class="keywordtype">char</span> tmp[64];
<a name="l00122" id="l00122"></a>00122         to = (<span class=
"keyword">struct </span>sockaddr_in *) &amp;(addr_pair-&gt;remote_addr);
<a name="l00123" id="l00123"></a>00123         <span class="keywordflow">if</span> (to == NULL) {
<a name="l00124" id="l00124"></a>00124             <span class="keywordflow">return</span> strdup(<span class=
"stringliteral">"SSH: unknown"</span>);
<a name="l00125" id="l00125"></a>00125         }
<a name="l00126" id="l00126"></a>00126 
<a name="l00127" id="l00127"></a>00127         sprintf(tmp, <span class="stringliteral">"SSH: [%s]:%hd"</span>,
<a name="l00128" id="l00128"></a>00128                 inet_ntoa(to-&gt;sin_addr), ntohs(to-&gt;sin_port));
<a name="l00129" id="l00129"></a>00129         <span class="keywordflow">return</span> strdup(tmp);
<a name="l00130" id="l00130"></a>00130     }
<a name="l00131" id="l00131"></a>00131 }
<a name="l00132" id="l00132"></a>00132 
<a name="l00133" id="l00133"></a>00133 
<a name="l00134" id="l00134"></a>00134 
<a name="l00135" id="l00135"></a>00135 <span class="comment">/*</span>
<a name="l00136" id="l00136"></a>00136 <span class=
"comment"> * You can write something into opaque that will subsequently get passed back </span>
<a name="l00137" id="l00137"></a>00137 <span class=
"comment"> * to your send function if you like.  For instance, you might want to</span>
<a name="l00138" id="l00138"></a>00138 <span class=
"comment"> * remember where a PDU came from, so that you can send a reply there...  </span>
<a name="l00139" id="l00139"></a>00139 <span class="comment"> */</span>
<a name="l00140" id="l00140"></a>00140 
<a name="l00141" id="l00141"></a>00141 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00142" id="l00142"></a>00142 netsnmp_ssh_recv(<a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a> *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
<a name="l00143" id="l00143"></a>00143                  <span class="keywordtype">void</span> **opaque, <span class=
"keywordtype">int</span> *olength)
<a name="l00144" id="l00144"></a>00144 {
<a name="l00145" id="l00145"></a>00145     <span class="keywordtype">int</span> rc = -1;
<a name="l00146" id="l00146"></a>00146     <a class="code" href=
"structnetsnmp__tmStateReference__s.html">netsnmp_tmStateReference</a> *tmStateRef = NULL;
<a name="l00147" id="l00147"></a>00147     <a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a> *addr_pair = NULL;
<a name="l00148" id="l00148"></a>00148     <span class="keywordtype">int</span> iamclient = 0;
<a name="l00149" id="l00149"></a>00149 
<a name="l00150" id="l00150"></a>00150     DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"at the top of ssh_recv\n"</span>));
<a name="l00151" id="l00151"></a>00151     DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"t=%p\n"</span>, t));
<a name="l00152" id="l00152"></a>00152     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL) {
<a name="l00153" id="l00153"></a>00153         addr_pair = (<a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a> *) t-&gt;data;
<a name="l00154" id="l00154"></a>00154     }
<a name="l00155" id="l00155"></a>00155 
<a name="l00156" id="l00156"></a>00156     DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"addr_pair=%p\n"</span>, addr_pair));
<a name="l00157" id="l00157"></a>00157     <span class=
"keywordflow">if</span> (t != NULL &amp;&amp; addr_pair &amp;&amp; addr_pair-&gt;channel) {
<a name="l00158" id="l00158"></a>00158         DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"t=%p, addr_pair=%p, channel=%p\n"</span>,
<a name="l00159" id="l00159"></a>00159                     t, addr_pair, addr_pair-&gt;channel));
<a name="l00160" id="l00160"></a>00160         iamclient = 1;
<a name="l00161" id="l00161"></a>00161         <span class="keywordflow">while</span> (rc &lt; 0) {
<a name="l00162" id="l00162"></a>00162             rc = libssh2_channel_read(addr_pair-&gt;channel, buf, size);
<a name="l00163" id="l00163"></a>00163             <span class="keywordflow">if</span> (rc &lt; 0) {  <span class=
"comment">/* XXX: from tcp; ssh equiv?:  &amp;&amp; errno != EINTR */</span>
<a name="l00164" id="l00164"></a>00164                 DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"recv fd %d err %d (\"%s\")\n"</span>,
<a name="l00165" id="l00165"></a>00165                             t-&gt;sock, errno, strerror(errno)));
<a name="l00166" id="l00166"></a>00166                 <span class="keywordflow">break</span>;
<a name="l00167" id="l00167"></a>00167             }
<a name="l00168" id="l00168"></a>00168             DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"recv fd %d got %d bytes\n"</span>,
<a name="l00169" id="l00169"></a>00169                         t-&gt;sock, rc));
<a name="l00170" id="l00170"></a>00170         }
<a name="l00171" id="l00171"></a>00171     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (t != NULL) {
<a name="l00172" id="l00172"></a>00172 
<a name="l00173" id="l00173"></a>00173 <span class="preprocessor">#ifdef SNMPSSHDOMAIN_USE_EXTERNAL_PIPE</span>
<a name="l00174" id="l00174"></a>00174 
<a name="l00175" id="l00175"></a>00175         socklen_t       tolen = <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_un);
<a name="l00176" id="l00176"></a>00176 
<a name="l00177" id="l00177"></a>00177         <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
<a name="l00178" id="l00178"></a>00178             <span class="keyword">struct </span>sockaddr *to;
<a name="l00179" id="l00179"></a>00179             to = (<span class="keyword">struct </span>sockaddr *) <a class="code" href=
"group__util.html#ga6356941968481380ea6f4a646df4aaf9" title=
"Mallocs memory of sizeof(struct s), zeros it and returns a pointer to it.">SNMP_MALLOC_STRUCT</a>(sockaddr_un);
<a name="l00180" id="l00180"></a>00180             <span class="keywordflow">if</span> (NULL == to) {
<a name="l00181" id="l00181"></a>00181                 *opaque = NULL;
<a name="l00182" id="l00182"></a>00182                 *olength = 0;
<a name="l00183" id="l00183"></a>00183                 <span class="keywordflow">return</span> -1;
<a name="l00184" id="l00184"></a>00184             }
<a name="l00185" id="l00185"></a>00185 
<a name="l00186" id="l00186"></a>00186             <span class=
"keywordflow">if</span>(getsockname(t-&gt;sock, to, &amp;tolen) != 0){
<a name="l00187" id="l00187"></a>00187                 free(to);
<a name="l00188" id="l00188"></a>00188                 *opaque = NULL;
<a name="l00189" id="l00189"></a>00189                 *olength = 0;
<a name="l00190" id="l00190"></a>00190                 <span class="keywordflow">return</span> -1;
<a name="l00191" id="l00191"></a>00191             };
<a name="l00192" id="l00192"></a>00192 
<a name="l00193" id="l00193"></a>00193             <span class="keywordflow">if</span> (addr_pair-&gt;username[0] == <span class=
"charliteral">'\0'</span>) {
<a name="l00194" id="l00194"></a>00194                 <span class=
"comment">/* we don't have a username yet, so this is the first message */</span>
<a name="l00195" id="l00195"></a>00195                 <span class="keyword">struct </span>ucred *remoteuser;
<a name="l00196" id="l00196"></a>00196                 <span class="keyword">struct </span>msghdr msg;
<a name="l00197" id="l00197"></a>00197                 <span class="keyword">struct </span>iovec iov[1];
<a name="l00198" id="l00198"></a>00198                 <span class="keywordtype">char</span> cmsg[CMSG_SPACE(<span class=
"keyword">sizeof</span>(remoteuser))+4096];
<a name="l00199" id="l00199"></a>00199                 <span class="keyword">struct </span>cmsghdr *cmsgptr;
<a name="l00200" id="l00200"></a>00200                 u_char *charbuf  = buf;
<a name="l00201" id="l00201"></a>00201 
<a name="l00202" id="l00202"></a>00202                 iov[0].iov_base = buf;
<a name="l00203" id="l00203"></a>00203                 iov[0].iov_len = size;
<a name="l00204" id="l00204"></a>00204 
<a name="l00205" id="l00205"></a>00205                 memset(&amp;msg, 0, <span class="keyword">sizeof</span> msg);
<a name="l00206" id="l00206"></a>00206                 msg.msg_iov = iov;
<a name="l00207" id="l00207"></a>00207                 msg.msg_iovlen = 1;
<a name="l00208" id="l00208"></a>00208                 msg.msg_control = &amp;cmsg;
<a name="l00209" id="l00209"></a>00209                 msg.msg_controllen = <span class="keyword">sizeof</span>(cmsg);
<a name="l00210" id="l00210"></a>00210                 
<a name="l00211" id="l00211"></a>00211                 rc = recvmsg(t-&gt;sock, &amp;msg, MSG_DONTWAIT); <span class=
"comment">/* use DONTWAIT? */</span>
<a name="l00212" id="l00212"></a>00212                 <span class="keywordflow">if</span> (rc &lt;= 0) {
<a name="l00213" id="l00213"></a>00213                     <span class="keywordflow">return</span> rc;
<a name="l00214" id="l00214"></a>00214                 }
<a name="l00215" id="l00215"></a>00215 
<a name="l00216" id="l00216"></a>00216                 <span class="comment">/* we haven't received the starting info */</span>
<a name="l00217" id="l00217"></a>00217                 <span class=
"keywordflow">if</span> ((u_char) charbuf[0] &gt; NETSNMP_SSHTOSNMP_VERSION1) {
<a name="l00218" id="l00218"></a>00218                     <span class="comment">/* unsupported connection version */</span>
<a name="l00219" id="l00219"></a>00219                     <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"received unsupported sshtosnmp version: %d\n"</span>, charbuf[0]);
<a name="l00220" id="l00220"></a>00220                     <span class="keywordflow">return</span> -1;
<a name="l00221" id="l00221"></a>00221                 }
<a name="l00222" id="l00222"></a>00222 
<a name="l00223" id="l00223"></a>00223                 DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"received first msg over SSH; internal SSH protocol version %d\n"</span>, charbuf[0]));
<a name="l00224" id="l00224"></a>00224 
<a name="l00225" id="l00225"></a>00225                 <span class=
"keywordflow">for</span> (cmsgptr = CMSG_FIRSTHDR(&amp;msg); cmsgptr != NULL; cmsgptr = CMSG_NXTHDR(&amp;msg, cmsgptr)) {
<a name="l00226" id="l00226"></a>00226                     <span class=
"keywordflow">if</span> (cmsgptr-&gt;cmsg_level == SOL_SOCKET &amp;&amp; cmsgptr-&gt;cmsg_type == SCM_CREDENTIALS) {
<a name="l00227" id="l00227"></a>00227                         <span class="comment">/* received credential info */</span>
<a name="l00228" id="l00228"></a>00228                         <span class="keyword">struct </span>passwd *user_pw;
<a name="l00229" id="l00229"></a>00229 
<a name="l00230" id="l00230"></a>00230                         remoteuser = (<span class=
"keyword">struct </span>ucred *) CMSG_DATA(cmsgptr);
<a name="l00231" id="l00231"></a>00231 
<a name="l00232" id="l00232"></a>00232                         <span class=
"keywordflow">if</span> ((user_pw = getpwuid(remoteuser-&gt;uid)) == NULL) {
<a name="l00233" id="l00233"></a>00233                             <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"No user found for uid %d\n"</span>,
<a name="l00234" id="l00234"></a>00234                                 remoteuser-&gt;uid);
<a name="l00235" id="l00235"></a>00235                             <span class="keywordflow">return</span> -1;
<a name="l00236" id="l00236"></a>00236                         }
<a name="l00237" id="l00237"></a>00237                         <span class=
"keywordflow">if</span> (strlen(user_pw-&gt;pw_name) &gt;
<a name="l00238" id="l00238"></a>00238                             <span class=
"keyword">sizeof</span>(addr_pair-&gt;username)-1) {
<a name="l00239" id="l00239"></a>00239                             <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR,
<a name="l00240" id="l00240"></a>00240                                      <span class=
"stringliteral">"User name '%s' too long for snmp\n"</span>,
<a name="l00241" id="l00241"></a>00241                                      user_pw-&gt;pw_name);
<a name="l00242" id="l00242"></a>00242                             <span class="keywordflow">return</span> -1;
<a name="l00243" id="l00243"></a>00243                         }
<a name="l00244" id="l00244"></a>00244                         strncpy(addr_pair-&gt;username, user_pw-&gt;pw_name,
<a name="l00245" id="l00245"></a>00245                                 <span class=
"keyword">sizeof</span>(addr_pair-&gt;username));
<a name="l00246" id="l00246"></a>00246                         addr_pair-&gt;username[<span class=
"keyword">sizeof</span>(addr_pair-&gt;username)-1] = <span class="charliteral">'\0'</span>;
<a name="l00247" id="l00247"></a>00247                     }
<a name="l00248" id="l00248"></a>00248                     DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"Setting user name to %s\n"</span>,
<a name="l00249" id="l00249"></a>00249                                 addr_pair-&gt;username));
<a name="l00250" id="l00250"></a>00250                 }
<a name="l00251" id="l00251"></a>00251 
<a name="l00252" id="l00252"></a>00252                 <span class=
"keywordflow">if</span> (addr_pair-&gt;username[0] == <span class="charliteral">'\0'</span>) {
<a name="l00253" id="l00253"></a>00253                     <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR,
<a name="l00254" id="l00254"></a>00254                              <span class=
"stringliteral">"failed to extract username from sshd connected unix socket\n"</span>);
<a name="l00255" id="l00255"></a>00255                     <span class="keywordflow">return</span> -1;
<a name="l00256" id="l00256"></a>00256                 }
<a name="l00257" id="l00257"></a>00257 
<a name="l00258" id="l00258"></a>00258                 <span class="keywordflow">if</span> (rc == 1) {
<a name="l00259" id="l00259"></a>00259                     <span class=
"comment">/* the only packet we received was the starting one */</span>
<a name="l00260" id="l00260"></a>00260                     t-&gt;flags |= NETSNMP_TRANSPORT_FLAG_EMPTY_PKT;
<a name="l00261" id="l00261"></a>00261                     <span class="keywordflow">return</span> 0;
<a name="l00262" id="l00262"></a>00262                 }
<a name="l00263" id="l00263"></a>00263 
<a name="l00264" id="l00264"></a>00264                 rc -= 1;
<a name="l00265" id="l00265"></a>00265                 memmove(charbuf, &amp;charbuf[1], rc);
<a name="l00266" id="l00266"></a>00266             } <span class="keywordflow">else</span> {
<a name="l00267" id="l00267"></a>00267                 <span class="keywordflow">while</span> (rc &lt; 0) {
<a name="l00268" id="l00268"></a>00268                     rc = recvfrom(t-&gt;sock, buf, size, 0, NULL, NULL);
<a name="l00269" id="l00269"></a>00269                     <span class=
"keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
<a name="l00270" id="l00270"></a>00270                         DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"recv fd %d err %d (\"%s\")\n"</span>,
<a name="l00271" id="l00271"></a>00271                                     t-&gt;sock, errno, strerror(errno)));
<a name="l00272" id="l00272"></a>00272                         <span class="keywordflow">return</span> rc;
<a name="l00273" id="l00273"></a>00273                     }
<a name="l00274" id="l00274"></a>00274                     *opaque = (<span class="keywordtype">void</span>*)to;
<a name="l00275" id="l00275"></a>00275                     *olength = <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_un);
<a name="l00276" id="l00276"></a>00276                 }
<a name="l00277" id="l00277"></a>00277             }
<a name="l00278" id="l00278"></a>00278             DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"recv fd %d got %d bytes\n"</span>,
<a name="l00279" id="l00279"></a>00279                         t-&gt;sock, rc));
<a name="l00280" id="l00280"></a>00280         }
<a name="l00281" id="l00281"></a>00281         
<a name="l00282" id="l00282"></a>00282 <span class="preprocessor">#else </span><span class=
"comment">/* we're called directly by sshd and use stdin/out */</span>
<a name="l00283" id="l00283"></a>00283 
<a name="l00284" id="l00284"></a>00284         <span class="keyword">struct </span>passwd *user_pw;
<a name="l00285" id="l00285"></a>00285 
<a name="l00286" id="l00286"></a>00286         iamclient = 0;
<a name="l00287" id="l00287"></a>00287         <span class=
"comment">/* we're on the server side and should read from stdin */</span>
<a name="l00288" id="l00288"></a>00288         <span class="keywordflow">while</span> (rc &lt; 0) {
<a name="l00289" id="l00289"></a>00289             rc = read(STDIN_FILENO, buf, size);
<a name="l00290" id="l00290"></a>00290             <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
<a name="l00291" id="l00291"></a>00291                 DEBUGMSGTL((<span class="stringliteral">"ssh"</span>,
<a name="l00292" id="l00292"></a>00292                             <span class=
"stringliteral">" read on stdin failed: %d (\"%s\")\n"</span>,
<a name="l00293" id="l00293"></a>00293                             errno, strerror(errno)));
<a name="l00294" id="l00294"></a>00294                 <span class="keywordflow">break</span>;
<a name="l00295" id="l00295"></a>00295             }
<a name="l00296" id="l00296"></a>00296             <span class="keywordflow">if</span> (rc == 0) {
<a name="l00297" id="l00297"></a>00297                 <span class=
"comment">/* 0 input is probably bad since we selected on it */</span>
<a name="l00298" id="l00298"></a>00298                 DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"got a 0 read on stdin\n"</span>));
<a name="l00299" id="l00299"></a>00299                 <span class="keywordflow">return</span> -1;
<a name="l00300" id="l00300"></a>00300             }
<a name="l00301" id="l00301"></a>00301             DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"read on stdin got %d bytes\n"</span>, rc));
<a name="l00302" id="l00302"></a>00302         }
<a name="l00303" id="l00303"></a>00303 
<a name="l00304" id="l00304"></a>00304 <span class=
"comment">/* XXX: need to check the username, but addr_pair doesn't exist! */</span>
<a name="l00305" id="l00305"></a>00305         <span class="comment">/*</span>
<a name="l00306" id="l00306"></a>00306 <span class="comment">        DEBUGMSGTL(("ssh", "current username=%s\n", c));</span>
<a name="l00307" id="l00307"></a>00307 <span class="comment">        if (addr_pair-&gt;username[0] == '\0') {</span>
<a name="l00308" id="l00308"></a>00308 <span class="comment">            if ((user_pw = getpwuid(getuid())) == NULL) {</span>
<a name="l00309" id="l00309"></a>00309 <span class=
"comment">                snmp_log(LOG_ERR, "No user found for uid %d\n", getuid());</span>
<a name="l00310" id="l00310"></a>00310 <span class="comment">                return -1;</span>
<a name="l00311" id="l00311"></a>00311 <span class="comment">            }</span>
<a name="l00312" id="l00312"></a>00312 <span class=
"comment">            if (strlen(user_pw-&gt;pw_name) &gt; sizeof(addr_pair-&gt;username)-1) {</span>
<a name="l00313" id="l00313"></a>00313 <span class=
"comment">                snmp_log(LOG_ERR, "User name '%s' too long for snmp\n",</span>
<a name="l00314" id="l00314"></a>00314 <span class="comment">                         user_pw-&gt;pw_name);</span>
<a name="l00315" id="l00315"></a>00315 <span class="comment">                return -1;</span>
<a name="l00316" id="l00316"></a>00316 <span class="comment">            }</span>
<a name="l00317" id="l00317"></a>00317 <span class=
"comment">            strncpy(addr_pair-&gt;username, user_pw-&gt;pw_name,</span>
<a name="l00318" id="l00318"></a>00318 <span class="comment">                    sizeof(addr_pair-&gt;username));</span>
<a name="l00319" id="l00319"></a>00319 <span class=
"comment">            addr_pair-&gt;username[sizeof(addr_pair-&gt;username)-1] = '\0';</span>
<a name="l00320" id="l00320"></a>00320 <span class="comment">        }</span>
<a name="l00321" id="l00321"></a>00321 <span class="comment">        */</span>
<a name="l00322" id="l00322"></a>00322 
<a name="l00323" id="l00323"></a>00323 <span class="preprocessor">#endif </span><span class=
"comment">/* ! SNMPSSHDOMAIN_USE_EXTERNAL_PIPE */</span>
<a name="l00324" id="l00324"></a>00324     }
<a name="l00325" id="l00325"></a>00325 
<a name="l00326" id="l00326"></a>00326     <span class="comment">/* create a tmStateRef cache */</span>
<a name="l00327" id="l00327"></a>00327     tmStateRef = <a class="code" href=
"group__util.html#ga9cd013bb193de5048149afeb9d94e424" title=
"Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href=
"structnetsnmp__tmStateReference__s.html">netsnmp_tmStateReference</a>);
<a name="l00328" id="l00328"></a>00328 
<a name="l00329" id="l00329"></a>00329     <span class=
"comment">/* secshell document says were always authpriv, even if NULL algorithms */</span>
<a name="l00330" id="l00330"></a>00330     <span class="comment">/* ugh! */</span>
<a name="l00331" id="l00331"></a>00331     <span class="comment">/* XXX: disallow NULL in our implementations */</span>
<a name="l00332" id="l00332"></a>00332     tmStateRef-&gt;transportSecurityLevel = SNMP_SEC_LEVEL_AUTHPRIV;
<a name="l00333" id="l00333"></a>00333 
<a name="l00334" id="l00334"></a>00334     <span class=
"comment">/* XXX: figure out how to get the specified local secname from the session */</span>
<a name="l00335" id="l00335"></a>00335     <span class="keywordflow">if</span> (iamclient &amp;&amp; 0) {
<a name="l00336" id="l00336"></a>00336         <span class="comment">/* XXX: we're on the client; we should have named the</span>
<a name="l00337" id="l00337"></a>00337 <span class=
"comment">           connection ourselves...  pull this from session somehow? */</span>
<a name="l00338" id="l00338"></a>00338         strncpy(tmStateRef-&gt;securityName, addr_pair-&gt;username,
<a name="l00339" id="l00339"></a>00339                 <span class="keyword">sizeof</span>(tmStateRef-&gt;securityName)-1);
<a name="l00340" id="l00340"></a>00340     } <span class="keywordflow">else</span> {
<a name="l00341" id="l00341"></a>00341 <span class="preprocessor">#ifdef SNMPSSHDOMAIN_USE_EXTERNAL_PIPE</span>
<a name="l00342" id="l00342"></a>00342         strncpy(tmStateRef-&gt;securityName, addr_pair-&gt;username,
<a name="l00343" id="l00343"></a>00343                 <span class="keyword">sizeof</span>(tmStateRef-&gt;securityName)-1);
<a name="l00344" id="l00344"></a>00344 <span class="preprocessor">#else </span><span class=
"comment">/* we're called directly by sshd and use stdin/out */</span>
<a name="l00345" id="l00345"></a>00345         <span class="comment">/* we're on the server... */</span>
<a name="l00346" id="l00346"></a>00346         <span class=
"comment">/* XXX: this doesn't copy properly and can get pointer</span>
<a name="l00347" id="l00347"></a>00347 <span class="comment">           reference issues */</span>
<a name="l00348" id="l00348"></a>00348         <span class="keywordflow">if</span> (strlen(getenv(<span class=
"stringliteral">"USER"</span>)) &gt; 127) {
<a name="l00349" id="l00349"></a>00349             <span class="comment">/* ruh roh */</span>
<a name="l00350" id="l00350"></a>00350             <span class="comment">/* XXX: clean up */</span>
<a name="l00351" id="l00351"></a>00351             <span class="keywordflow">return</span> -1;
<a name="l00352" id="l00352"></a>00352             exit;
<a name="l00353" id="l00353"></a>00353         }
<a name="l00354" id="l00354"></a>00354 
<a name="l00355" id="l00355"></a>00355         <span class=
"comment">/* XXX: detect and throw out overflow secname sizes rather</span>
<a name="l00356" id="l00356"></a>00356 <span class="comment">           than truncating. */</span>
<a name="l00357" id="l00357"></a>00357         strncpy(tmStateRef-&gt;securityName, getenv(<span class=
"stringliteral">"USER"</span>),
<a name="l00358" id="l00358"></a>00358                 <span class="keyword">sizeof</span>(tmStateRef-&gt;securityName)-1);
<a name="l00359" id="l00359"></a>00359 <span class="preprocessor">#endif </span><span class=
"comment">/* ! SNMPSSHDOMAIN_USE_EXTERNAL_PIPE */</span>
<a name="l00360" id="l00360"></a>00360     }
<a name="l00361" id="l00361"></a>00361     tmStateRef-&gt;securityName[<span class=
"keyword">sizeof</span>(tmStateRef-&gt;securityName)-1] = <span class="charliteral">'\0'</span>;
<a name="l00362" id="l00362"></a>00362     tmStateRef-&gt;securityNameLen = strlen(tmStateRef-&gt;securityName);
<a name="l00363" id="l00363"></a>00363     *opaque = tmStateRef;
<a name="l00364" id="l00364"></a>00364     *olength = <span class="keyword">sizeof</span>(<a class="code" href=
"structnetsnmp__tmStateReference__s.html">netsnmp_tmStateReference</a>);
<a name="l00365" id="l00365"></a>00365 
<a name="l00366" id="l00366"></a>00366     <span class="keywordflow">return</span> rc;
<a name="l00367" id="l00367"></a>00367 }
<a name="l00368" id="l00368"></a>00368 
<a name="l00369" id="l00369"></a>00369 
<a name="l00370" id="l00370"></a>00370 
<a name="l00371" id="l00371"></a>00371 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00372" id="l00372"></a>00372 netsnmp_ssh_send(<a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a> *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
<a name="l00373" id="l00373"></a>00373                  <span class="keywordtype">void</span> **opaque, <span class=
"keywordtype">int</span> *olength)
<a name="l00374" id="l00374"></a>00374 {
<a name="l00375" id="l00375"></a>00375     <span class="keywordtype">int</span> rc = -1;
<a name="l00376" id="l00376"></a>00376 
<a name="l00377" id="l00377"></a>00377     <a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a> *addr_pair = NULL;
<a name="l00378" id="l00378"></a>00378     <a class="code" href=
"structnetsnmp__tmStateReference__s.html">netsnmp_tmStateReference</a> *tmStateRef = NULL;
<a name="l00379" id="l00379"></a>00379 
<a name="l00380" id="l00380"></a>00380     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL) {
<a name="l00381" id="l00381"></a>00381         addr_pair = (<a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a> *) t-&gt;data;
<a name="l00382" id="l00382"></a>00382     }
<a name="l00383" id="l00383"></a>00383 
<a name="l00384" id="l00384"></a>00384     <span class=
"keywordflow">if</span> (opaque != NULL &amp;&amp; *opaque != NULL &amp;&amp;
<a name="l00385" id="l00385"></a>00385         *olength == <span class="keyword">sizeof</span>(<a class="code" href=
"structnetsnmp__tmStateReference__s.html">netsnmp_tmStateReference</a>)) {
<a name="l00386" id="l00386"></a>00386         tmStateRef = (<a class="code" href=
"structnetsnmp__tmStateReference__s.html">netsnmp_tmStateReference</a> *) *opaque;
<a name="l00387" id="l00387"></a>00387     }
<a name="l00388" id="l00388"></a>00388 
<a name="l00389" id="l00389"></a>00389     <span class="keywordflow">if</span> (!tmStateRef) {
<a name="l00390" id="l00390"></a>00390         <span class=
"comment">/* this is now an error according to my memory in the recent draft */</span>
<a name="l00391" id="l00391"></a>00391         <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"netsnmp_ssh_send wasn't passed a valid tmStateReference\n"</span>);
<a name="l00392" id="l00392"></a>00392         <span class="keywordflow">return</span> -1;
<a name="l00393" id="l00393"></a>00393     }
<a name="l00394" id="l00394"></a>00394 
<a name="l00395" id="l00395"></a>00395     <span class=
"keywordflow">if</span> (NULL != t &amp;&amp; NULL != addr_pair &amp;&amp; NULL != addr_pair-&gt;channel) {
<a name="l00396" id="l00396"></a>00396         <span class="keywordflow">if</span> (addr_pair-&gt;username[0] == <span class=
"charliteral">'\0'</span>) {
<a name="l00397" id="l00397"></a>00397             strncpy(addr_pair-&gt;username, tmStateRef-&gt;securityName,
<a name="l00398" id="l00398"></a>00398                     <span class="keyword">sizeof</span>(addr_pair-&gt;username)-1);
<a name="l00399" id="l00399"></a>00399             addr_pair-&gt;username[<span class=
"keyword">sizeof</span>(addr_pair-&gt;username)-1] = <span class="charliteral">'\0'</span>;
<a name="l00400" id="l00400"></a>00400         } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strcmp(addr_pair-&gt;username, tmStateRef-&gt;securityName) != 0 ||
<a name="l00401" id="l00401"></a>00401                    strlen(addr_pair-&gt;username) != tmStateRef-&gt;securityNameLen) {
<a name="l00402" id="l00402"></a>00402             <span class="comment">/* error!  they must always match */</span>
<a name="l00403" id="l00403"></a>00403             <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"netsnmp_ssh_send was passed a tmStateReference with a securityName not equal to previous messages\n"</span>);
<a name="l00404" id="l00404"></a>00404             <span class="keywordflow">return</span> -1;
<a name="l00405" id="l00405"></a>00405         }
<a name="l00406" id="l00406"></a>00406         <span class="keywordflow">while</span> (rc &lt; 0) {
<a name="l00407" id="l00407"></a>00407             rc = libssh2_channel_write(addr_pair-&gt;channel, buf, size);
<a name="l00408" id="l00408"></a>00408             <span class="keywordflow">if</span> (rc &lt; 0) { <span class=
"comment">/* XXX:  &amp;&amp; errno != EINTR */</span>
<a name="l00409" id="l00409"></a>00409                 <span class="keywordflow">break</span>;
<a name="l00410" id="l00410"></a>00410             }
<a name="l00411" id="l00411"></a>00411         }
<a name="l00412" id="l00412"></a>00412     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (t != NULL) {
<a name="l00413" id="l00413"></a>00413 <span class="preprocessor">#ifdef SNMPSSHDOMAIN_USE_EXTERNAL_PIPE</span>
<a name="l00414" id="l00414"></a>00414 
<a name="l00415" id="l00415"></a>00415         <span class="keywordflow">while</span> (rc &lt; 0) {
<a name="l00416" id="l00416"></a>00416             rc = sendto(t-&gt;sock, buf, size, 0, NULL, 0);
<a name="l00417" id="l00417"></a>00417             
<a name="l00418" id="l00418"></a>00418             <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
<a name="l00419" id="l00419"></a>00419                 <span class="keywordflow">break</span>;
<a name="l00420" id="l00420"></a>00420             }
<a name="l00421" id="l00421"></a>00421         }
<a name="l00422" id="l00422"></a>00422 
<a name="l00423" id="l00423"></a>00423 <span class="preprocessor">#else </span><span class=
"comment">/* we're called directly by sshd and use stdin/out */</span>
<a name="l00424" id="l00424"></a>00424         <span class="comment">/* on the server; send to stdout */</span>
<a name="l00425" id="l00425"></a>00425         <span class="keywordflow">while</span> (rc &lt; 0) {
<a name="l00426" id="l00426"></a>00426             rc = write(STDOUT_FILENO, buf, size);
<a name="l00427" id="l00427"></a>00427             fflush(stdout);
<a name="l00428" id="l00428"></a>00428             <span class=
"keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) { <span class=
"comment">/* XXX:  &amp;&amp; errno != EINTR */</span>
<a name="l00429" id="l00429"></a>00429                 <span class="keywordflow">break</span>;
<a name="l00430" id="l00430"></a>00430             }
<a name="l00431" id="l00431"></a>00431         }
<a name="l00432" id="l00432"></a>00432 <span class="preprocessor">#endif</span>
<a name="l00433" id="l00433"></a>00433     }
<a name="l00434" id="l00434"></a>00434 
<a name="l00435" id="l00435"></a>00435     <span class="keywordflow">return</span> rc;
<a name="l00436" id="l00436"></a>00436 }
<a name="l00437" id="l00437"></a>00437 
<a name="l00438" id="l00438"></a>00438 
<a name="l00439" id="l00439"></a>00439 
<a name="l00440" id="l00440"></a>00440 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00441" id="l00441"></a>00441 netsnmp_ssh_close(<a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a> *t)
<a name="l00442" id="l00442"></a>00442 {
<a name="l00443" id="l00443"></a>00443     <span class="keywordtype">int</span> rc = -1;
<a name="l00444" id="l00444"></a>00444     <a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a> *addr_pair = NULL;
<a name="l00445" id="l00445"></a>00445 
<a name="l00446" id="l00446"></a>00446     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL) {
<a name="l00447" id="l00447"></a>00447         addr_pair = (<a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a> *) t-&gt;data;
<a name="l00448" id="l00448"></a>00448     }
<a name="l00449" id="l00449"></a>00449 
<a name="l00450" id="l00450"></a>00450     <span class=
"keywordflow">if</span> (t != NULL &amp;&amp; addr_pair &amp;&amp; t-&gt;sock &gt;= 0) {
<a name="l00451" id="l00451"></a>00451         DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"close fd %d\n"</span>, t-&gt;sock));
<a name="l00452" id="l00452"></a>00452 
<a name="l00453" id="l00453"></a>00453         <span class="keywordflow">if</span> (addr_pair-&gt;channel) {
<a name="l00454" id="l00454"></a>00454             libssh2_channel_close(addr_pair-&gt;channel);
<a name="l00455" id="l00455"></a>00455             libssh2_channel_free(addr_pair-&gt;channel);
<a name="l00456" id="l00456"></a>00456             addr_pair-&gt;channel = NULL;
<a name="l00457" id="l00457"></a>00457         }
<a name="l00458" id="l00458"></a>00458 
<a name="l00459" id="l00459"></a>00459         <span class="keywordflow">if</span> (addr_pair-&gt;session) {
<a name="l00460" id="l00460"></a>00460             libssh2_session_disconnect(addr_pair-&gt;session, <span class=
"stringliteral">"Normal Shutdown"</span>);
<a name="l00461" id="l00461"></a>00461             libssh2_session_free(addr_pair-&gt;session);
<a name="l00462" id="l00462"></a>00462             addr_pair-&gt;session = NULL;
<a name="l00463" id="l00463"></a>00463         }
<a name="l00464" id="l00464"></a>00464 
<a name="l00465" id="l00465"></a>00465 <span class="preprocessor">#ifndef HAVE_CLOSESOCKET</span>
<a name="l00466" id="l00466"></a>00466         rc = close(t-&gt;sock);
<a name="l00467" id="l00467"></a>00467 <span class="preprocessor">#else</span>
<a name="l00468" id="l00468"></a>00468         rc = closesocket(t-&gt;sock);
<a name="l00469" id="l00469"></a>00469 <span class="preprocessor">#endif</span>
<a name="l00470" id="l00470"></a>00470         t-&gt;sock = -1;
<a name="l00471" id="l00471"></a>00471 
<a name="l00472" id="l00472"></a>00472 <span class="preprocessor">#ifdef SNMPSSHDOMAIN_USE_EXTERNAL_PIPE</span>
<a name="l00473" id="l00473"></a>00473 
<a name="l00474" id="l00474"></a>00474         close(t-&gt;sock);
<a name="l00475" id="l00475"></a>00475         
<a name="l00476" id="l00476"></a>00476         <span class=
"keywordflow">if</span> (!addr_pair-&gt;session &amp;&amp; !addr_pair-&gt;channel) {
<a name="l00477" id="l00477"></a>00477             <span class="comment">/* unix socket based connection */</span>
<a name="l00478" id="l00478"></a>00478             close(t-&gt;sock);
<a name="l00479" id="l00479"></a>00479 
<a name="l00480" id="l00480"></a>00480             <span class="comment">/* XXX: make configurable */</span>
<a name="l00481" id="l00481"></a>00481             unlink(addr_pair-&gt;socket_path);
<a name="l00482" id="l00482"></a>00482         }
<a name="l00483" id="l00483"></a>00483 
<a name="l00484" id="l00484"></a>00484 <span class="preprocessor">#else </span><span class=
"comment">/* we're called directly by sshd and use stdin/out */</span>
<a name="l00485" id="l00485"></a>00485 
<a name="l00486" id="l00486"></a>00486         <span class="comment">/* on the server: close stdin/out */</span>
<a name="l00487" id="l00487"></a>00487         close(STDIN_FILENO);
<a name="l00488" id="l00488"></a>00488         close(STDOUT_FILENO);
<a name="l00489" id="l00489"></a>00489 <span class="preprocessor">#endif </span><span class=
"comment">/* ! SNMPSSHDOMAIN_USE_EXTERNAL_PIPE */</span>
<a name="l00490" id="l00490"></a>00490 
<a name="l00491" id="l00491"></a>00491     } <span class="keywordflow">else</span> {
<a name="l00492" id="l00492"></a>00492 
<a name="l00493" id="l00493"></a>00493 <span class="preprocessor">#ifndef SNMPSSHDOMAIN_USE_EXTERNAL_PIPE</span>
<a name="l00494" id="l00494"></a>00494         <span class="comment">/* on the server: close stdin/out */</span>
<a name="l00495" id="l00495"></a>00495         close(STDIN_FILENO);
<a name="l00496" id="l00496"></a>00496         close(STDOUT_FILENO);
<a name="l00497" id="l00497"></a>00497 <span class="preprocessor">#endif </span><span class=
"comment">/* ! SNMPSSHDOMAIN_USE_EXTERNAL_PIPE */</span>
<a name="l00498" id="l00498"></a>00498 
<a name="l00499" id="l00499"></a>00499     }
<a name="l00500" id="l00500"></a>00500     <span class="keywordflow">return</span> rc;
<a name="l00501" id="l00501"></a>00501 }
<a name="l00502" id="l00502"></a>00502 
<a name="l00503" id="l00503"></a>00503 
<a name="l00504" id="l00504"></a>00504 
<a name="l00505" id="l00505"></a>00505 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00506" id="l00506"></a>00506 netsnmp_ssh_accept(<a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a> *t)
<a name="l00507" id="l00507"></a>00507 {
<a name="l00508" id="l00508"></a>00508 <span class="preprocessor">#ifdef SNMPSSHDOMAIN_USE_EXTERNAL_PIPE</span>
<a name="l00509" id="l00509"></a>00509 
<a name="l00510" id="l00510"></a>00510     <span class="comment">/* much of this is duplicated from snmpUnixDomain.c */</span>
<a name="l00511" id="l00511"></a>00511 
<a name="l00512" id="l00512"></a>00512     <a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a> *addr_pair;    
<a name="l00513" id="l00513"></a>00513     <span class="keywordtype">int</span>                    newsock   = -1;
<a name="l00514" id="l00514"></a>00514     <span class="keyword">struct </span>sockaddr       *farend    = NULL;
<a name="l00515" id="l00515"></a>00515     socklen_t              farendlen = <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_un);
<a name="l00516" id="l00516"></a>00516 
<a name="l00517" id="l00517"></a>00517 
<a name="l00518" id="l00518"></a>00518     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
<a name="l00519" id="l00519"></a>00519         addr_pair = <a class="code" href=
"group__util.html#ga9cd013bb193de5048149afeb9d94e424" title=
"Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a>);
<a name="l00520" id="l00520"></a>00520 
<a name="l00521" id="l00521"></a>00521         <span class="keywordflow">if</span> (addr_pair == NULL) {
<a name="l00522" id="l00522"></a>00522             <span class="comment">/*</span>
<a name="l00523" id="l00523"></a>00523 <span class=
"comment">             * Indicate that the acceptance of this socket failed.</span>
<a name="l00524" id="l00524"></a>00524 <span class="comment">             */</span>
<a name="l00525" id="l00525"></a>00525             DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"accept: malloc failed\n"</span>));
<a name="l00526" id="l00526"></a>00526             <span class="keywordflow">return</span> -1;
<a name="l00527" id="l00527"></a>00527         }
<a name="l00528" id="l00528"></a>00528 
<a name="l00529" id="l00529"></a>00529         farend = (<span class=
"keyword">struct </span>sockaddr *) &amp;addr_pair-&gt;unix_socket_end;
<a name="l00530" id="l00530"></a>00530 
<a name="l00531" id="l00531"></a>00531         newsock = accept(t-&gt;sock, farend, &amp;farendlen);
<a name="l00532" id="l00532"></a>00532 
<a name="l00533" id="l00533"></a>00533         <span class=
"comment">/* set the SO_PASSCRED option so we can receive the remote uid */</span>
<a name="l00534" id="l00534"></a>00534         {
<a name="l00535" id="l00535"></a>00535             <span class="keywordtype">int</span> one = 1;
<a name="l00536" id="l00536"></a>00536             setsockopt(newsock, SOL_SOCKET, SO_PASSCRED, (<span class=
"keywordtype">void</span> *) &amp;one,
<a name="l00537" id="l00537"></a>00537                        <span class="keyword">sizeof</span>(one));
<a name="l00538" id="l00538"></a>00538         }
<a name="l00539" id="l00539"></a>00539 
<a name="l00540" id="l00540"></a>00540         <span class="keywordflow">if</span> (newsock &lt; 0) {
<a name="l00541" id="l00541"></a>00541             DEBUGMSGTL((<span class="stringliteral">"ssh"</span>,<span class=
"stringliteral">"accept failed rc %d errno %d \"%s\"\n"</span>,
<a name="l00542" id="l00542"></a>00542                         newsock, errno, strerror(errno)));
<a name="l00543" id="l00543"></a>00543             free(addr_pair);
<a name="l00544" id="l00544"></a>00544             <span class="keywordflow">return</span> newsock;
<a name="l00545" id="l00545"></a>00545         }
<a name="l00546" id="l00546"></a>00546 
<a name="l00547" id="l00547"></a>00547         <span class="keywordflow">if</span> (t-&gt;data != NULL) {
<a name="l00548" id="l00548"></a>00548             free(t-&gt;data);
<a name="l00549" id="l00549"></a>00549         }
<a name="l00550" id="l00550"></a>00550 
<a name="l00551" id="l00551"></a>00551         DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"accept succeeded (farend %p len %d)\n"</span>,
<a name="l00552" id="l00552"></a>00552                     farend, farendlen));
<a name="l00553" id="l00553"></a>00553         t-&gt;data = addr_pair;
<a name="l00554" id="l00554"></a>00554         t-&gt;data_length = <span class="keyword">sizeof</span>(<a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a>);
<a name="l00555" id="l00555"></a>00555         netsnmp_sock_buffer_set(newsock, SO_SNDBUF, 1, 0);
<a name="l00556" id="l00556"></a>00556         netsnmp_sock_buffer_set(newsock, SO_RCVBUF, 1, 0);
<a name="l00557" id="l00557"></a>00557         <span class="keywordflow">return</span> newsock;
<a name="l00558" id="l00558"></a>00558     } <span class="keywordflow">else</span> {
<a name="l00559" id="l00559"></a>00559         <span class="keywordflow">return</span> -1;
<a name="l00560" id="l00560"></a>00560     }
<a name="l00561" id="l00561"></a>00561 
<a name="l00562" id="l00562"></a>00562 <span class="preprocessor">#else </span><span class=
"comment">/* we're called directly by sshd and use stdin/out */</span>
<a name="l00563" id="l00563"></a>00563     <span class=
"comment">/* we don't need to do anything; server side uses stdin/out */</span>
<a name="l00564" id="l00564"></a>00564     <span class="comment">/* XXX: check that we're an ssh connection */</span>
<a name="l00565" id="l00565"></a>00565     
<a name="l00566" id="l00566"></a>00566     <span class="keywordflow">return</span> STDIN_FILENO; <span class=
"comment">/* return stdin */</span>
<a name="l00567" id="l00567"></a>00567 <span class="preprocessor">#endif </span><span class=
"comment">/* ! SNMPSSHDOMAIN_USE_EXTERNAL_PIPE */</span>
<a name="l00568" id="l00568"></a>00568 
<a name="l00569" id="l00569"></a>00569 }
<a name="l00570" id="l00570"></a>00570 
<a name="l00571" id="l00571"></a>00571 
<a name="l00572" id="l00572"></a>00572 
<a name="l00573" id="l00573"></a>00573 <span class="comment">/*</span>
<a name="l00574" id="l00574"></a>00574 <span class=
"comment"> * Open a SSH-based transport for SNMP.  Local is TRUE if addr is the local</span>
<a name="l00575" id="l00575"></a>00575 <span class=
"comment"> * address to bind to (i.e. this is a server-type session); otherwise addr is </span>
<a name="l00576" id="l00576"></a>00576 <span class="comment"> * the remote address to send things to.  </span>
<a name="l00577" id="l00577"></a>00577 <span class="comment"> */</span>
<a name="l00578" id="l00578"></a>00578 
<a name="l00579" id="l00579"></a>00579 <a class="code" href="structnetsnmp__transport__s.html">netsnmp_transport</a> *
<a name="l00580" id="l00580"></a>00580 netsnmp_ssh_transport(<span class="keyword">struct</span> sockaddr_in *addr, <span class=
"keywordtype">int</span> local)
<a name="l00581" id="l00581"></a>00581 {
<a name="l00582" id="l00582"></a>00582     <a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a> *t = NULL;
<a name="l00583" id="l00583"></a>00583     <a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a> *addr_pair = NULL;
<a name="l00584" id="l00584"></a>00584     <span class="keywordtype">int</span> rc = 0;
<a name="l00585" id="l00585"></a>00585     <span class="keywordtype">int</span> i, auth_pw = 0;
<a name="l00586" id="l00586"></a>00586     <span class="keyword">const</span> <span class="keywordtype">char</span> *fingerprint;
<a name="l00587" id="l00587"></a>00587     <span class="keywordtype">char</span> *userauthlist;
<a name="l00588" id="l00588"></a>00588     <span class="keyword">struct </span>sockaddr_un *unaddr;
<a name="l00589" id="l00589"></a>00589     <span class="keyword">const</span> <span class="keywordtype">char</span> *sockpath =
<a name="l00590" id="l00590"></a>00590         netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
<a name="l00591" id="l00591"></a>00591                               NETSNMP_DS_LIB_SSHTOSNMP_SOCKET);
<a name="l00592" id="l00592"></a>00592     <span class="keywordtype">char</span> tmpsockpath[MAXPATHLEN];
<a name="l00593" id="l00593"></a>00593 
<a name="l00594" id="l00594"></a>00594     <span class="keywordflow">if</span> (addr == NULL || addr-&gt;sin_family != AF_INET) {
<a name="l00595" id="l00595"></a>00595         <span class="keywordflow">return</span> NULL;
<a name="l00596" id="l00596"></a>00596     }
<a name="l00597" id="l00597"></a>00597 
<a name="l00598" id="l00598"></a>00598     t = <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424" title=
"Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a>);
<a name="l00599" id="l00599"></a>00599     <span class="keywordflow">if</span> (t == NULL) {
<a name="l00600" id="l00600"></a>00600         <span class="keywordflow">return</span> NULL;
<a name="l00601" id="l00601"></a>00601     }
<a name="l00602" id="l00602"></a>00602     memset(t, 0, <span class="keyword">sizeof</span>(<a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a>));
<a name="l00603" id="l00603"></a>00603 
<a name="l00604" id="l00604"></a>00604     t-&gt;domain = netsnmp_snmpSSHDomain;
<a name="l00605" id="l00605"></a>00605     t-&gt;domain_length =
<a name="l00606" id="l00606"></a>00606         <span class="keyword">sizeof</span>(netsnmp_snmpSSHDomain) / <span class=
"keyword">sizeof</span>(netsnmp_snmpSSHDomain[0]);
<a name="l00607" id="l00607"></a>00607 
<a name="l00608" id="l00608"></a>00608     t-&gt;flags = NETSNMP_TRANSPORT_FLAG_STREAM | NETSNMP_TRANSPORT_FLAG_TUNNELED;
<a name="l00609" id="l00609"></a>00609 
<a name="l00610" id="l00610"></a>00610     addr_pair = <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424"
title="Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a>);
<a name="l00611" id="l00611"></a>00611     <span class="keywordflow">if</span> (addr_pair == NULL) {
<a name="l00612" id="l00612"></a>00612         netsnmp_transport_free(t);
<a name="l00613" id="l00613"></a>00613         <span class="keywordflow">return</span> NULL;
<a name="l00614" id="l00614"></a>00614     }
<a name="l00615" id="l00615"></a>00615     t-&gt;data = addr_pair;
<a name="l00616" id="l00616"></a>00616     t-&gt;data_length = <span class="keyword">sizeof</span>(<a class="code" href=
"structnetsnmp__ssh__addr__pair__s.html">netsnmp_ssh_addr_pair</a>);
<a name="l00617" id="l00617"></a>00617 
<a name="l00618" id="l00618"></a>00618     <span class="keywordflow">if</span> (local) {
<a name="l00619" id="l00619"></a>00619 <span class="preprocessor">#ifdef SNMPSSHDOMAIN_USE_EXTERNAL_PIPE</span>
<a name="l00620" id="l00620"></a>00620 
<a name="l00621" id="l00621"></a>00621         <span class="comment">/* XXX: set t-&gt;local and t-&gt;local_length */</span>
<a name="l00622" id="l00622"></a>00622 
<a name="l00623" id="l00623"></a>00623 
<a name="l00624" id="l00624"></a>00624         t-&gt;flags |= NETSNMP_TRANSPORT_FLAG_LISTEN;
<a name="l00625" id="l00625"></a>00625 
<a name="l00626" id="l00626"></a>00626         unaddr = &amp;addr_pair-&gt;unix_socket_end;
<a name="l00627" id="l00627"></a>00627 
<a name="l00628" id="l00628"></a>00628         <span class="comment">/* open a unix domain socket */</span>
<a name="l00629" id="l00629"></a>00629         <span class=
"comment">/* XXX: get data from the transport def for it's location */</span>
<a name="l00630" id="l00630"></a>00630         unaddr-&gt;sun_family = AF_UNIX;
<a name="l00631" id="l00631"></a>00631         <span class="keywordflow">if</span> (NULL == sockpath) {
<a name="l00632" id="l00632"></a>00632             sprintf(tmpsockpath, <span class=
"stringliteral">"%s/%s"</span>, get_persistent_directory(),
<a name="l00633" id="l00633"></a>00633                     DEFAULT_SOCK_NAME);
<a name="l00634" id="l00634"></a>00634             sockpath = tmpsockpath;
<a name="l00635" id="l00635"></a>00635         }
<a name="l00636" id="l00636"></a>00636 
<a name="l00637" id="l00637"></a>00637         strcpy(unaddr-&gt;sun_path, sockpath);
<a name="l00638" id="l00638"></a>00638         strcpy(addr_pair-&gt;socket_path, sockpath);
<a name="l00639" id="l00639"></a>00639 
<a name="l00640" id="l00640"></a>00640         t-&gt;sock = socket(PF_UNIX, SOCK_STREAM, 0);
<a name="l00641" id="l00641"></a>00641         <span class="keywordflow">if</span> (t-&gt;sock &lt; 0) {
<a name="l00642" id="l00642"></a>00642             netsnmp_transport_free(t);
<a name="l00643" id="l00643"></a>00643             <span class="keywordflow">return</span> NULL;
<a name="l00644" id="l00644"></a>00644         }
<a name="l00645" id="l00645"></a>00645 
<a name="l00646" id="l00646"></a>00646         <span class=
"comment">/* set the SO_PASSCRED option so we can receive the remote uid */</span>
<a name="l00647" id="l00647"></a>00647         {
<a name="l00648" id="l00648"></a>00648             <span class="keywordtype">int</span> one = 1;
<a name="l00649" id="l00649"></a>00649             setsockopt(t-&gt;sock, SOL_SOCKET, SO_PASSCRED, (<span class=
"keywordtype">void</span> *) &amp;one,
<a name="l00650" id="l00650"></a>00650                        <span class="keyword">sizeof</span>(one));
<a name="l00651" id="l00651"></a>00651         }
<a name="l00652" id="l00652"></a>00652 
<a name="l00653" id="l00653"></a>00653         unlink(unaddr-&gt;sun_path);
<a name="l00654" id="l00654"></a>00654         rc = bind(t-&gt;sock, (<span class=
"keyword">struct</span> sockaddr *) unaddr, SUN_LEN(unaddr));
<a name="l00655" id="l00655"></a>00655         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00656" id="l00656"></a>00656             DEBUGMSGTL((<span class="stringliteral">"netsnmp_ssh_transport"</span>,
<a name="l00657" id="l00657"></a>00657                         <span class=
"stringliteral">"couldn't bind \"%s\", errno %d (%s)\n"</span>,
<a name="l00658" id="l00658"></a>00658                         unaddr-&gt;sun_path, errno, strerror(errno)));
<a name="l00659" id="l00659"></a>00659             netsnmp_ssh_close(t);
<a name="l00660" id="l00660"></a>00660             netsnmp_transport_free(t);
<a name="l00661" id="l00661"></a>00661             <span class="keywordflow">return</span> NULL;
<a name="l00662" id="l00662"></a>00662         }
<a name="l00663" id="l00663"></a>00663 
<a name="l00664" id="l00664"></a>00664 
<a name="l00665" id="l00665"></a>00665         <span class="comment">/* set the socket permissions */</span>
<a name="l00666" id="l00666"></a>00666         {
<a name="l00667" id="l00667"></a>00667             <span class="comment">/*</span>
<a name="l00668" id="l00668"></a>00668 <span class=
"comment">             * Apply any settings to the ownership/permissions of the</span>
<a name="l00669" id="l00669"></a>00669 <span class="comment">             * Sshdomain socket</span>
<a name="l00670" id="l00670"></a>00670 <span class="comment">             */</span>
<a name="l00671" id="l00671"></a>00671             <span class="keywordtype">int</span> sshdomain_sock_perm =
<a name="l00672" id="l00672"></a>00672                 netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID,
<a name="l00673" id="l00673"></a>00673                                    NETSNMP_DS_SSHDOMAIN_SOCK_PERM);
<a name="l00674" id="l00674"></a>00674             <span class="keywordtype">int</span> sshdomain_sock_user =
<a name="l00675" id="l00675"></a>00675                 netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID,
<a name="l00676" id="l00676"></a>00676                                    NETSNMP_DS_SSHDOMAIN_SOCK_USER);
<a name="l00677" id="l00677"></a>00677             <span class="keywordtype">int</span> sshdomain_sock_group =
<a name="l00678" id="l00678"></a>00678                 netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID,
<a name="l00679" id="l00679"></a>00679                                    NETSNMP_DS_SSHDOMAIN_SOCK_GROUP);
<a name="l00680" id="l00680"></a>00680 
<a name="l00681" id="l00681"></a>00681             DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"here: %s, %d, %d, %d\n"</span>,
<a name="l00682" id="l00682"></a>00682                         unaddr-&gt;sun_path,
<a name="l00683" id="l00683"></a>00683                         sshdomain_sock_perm, sshdomain_sock_user,
<a name="l00684" id="l00684"></a>00684                         sshdomain_sock_group));
<a name="l00685" id="l00685"></a>00685             <span class="keywordflow">if</span> (sshdomain_sock_perm != 0) {
<a name="l00686" id="l00686"></a>00686                 DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"Setting socket perms to %d\n"</span>,
<a name="l00687" id="l00687"></a>00687                             sshdomain_sock_perm));
<a name="l00688" id="l00688"></a>00688                 chmod(unaddr-&gt;sun_path, sshdomain_sock_perm);
<a name="l00689" id="l00689"></a>00689             }
<a name="l00690" id="l00690"></a>00690 
<a name="l00691" id="l00691"></a>00691             <span class=
"keywordflow">if</span> (sshdomain_sock_user || sshdomain_sock_group) {
<a name="l00692" id="l00692"></a>00692                 <span class="comment">/*</span>
<a name="l00693" id="l00693"></a>00693 <span class=
"comment">                 * If either of user or group haven't been set,</span>
<a name="l00694" id="l00694"></a>00694 <span class="comment">                 *  then leave them unchanged.</span>
<a name="l00695" id="l00695"></a>00695 <span class="comment">                 */</span>
<a name="l00696" id="l00696"></a>00696                 <span class="keywordflow">if</span> (sshdomain_sock_user == 0 )
<a name="l00697" id="l00697"></a>00697                     sshdomain_sock_user = -1;
<a name="l00698" id="l00698"></a>00698                 <span class="keywordflow">if</span> (sshdomain_sock_group == 0 )
<a name="l00699" id="l00699"></a>00699                     sshdomain_sock_group = -1;
<a name="l00700" id="l00700"></a>00700                 DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"Setting socket user/group to %d/%d\n"</span>,
<a name="l00701" id="l00701"></a>00701                             sshdomain_sock_user, sshdomain_sock_group));
<a name="l00702" id="l00702"></a>00702                 chown(unaddr-&gt;sun_path,
<a name="l00703" id="l00703"></a>00703                       sshdomain_sock_user, sshdomain_sock_group);
<a name="l00704" id="l00704"></a>00704             }
<a name="l00705" id="l00705"></a>00705         }
<a name="l00706" id="l00706"></a>00706 
<a name="l00707" id="l00707"></a>00707         rc = listen(t-&gt;sock, NETSNMP_STREAM_QUEUE_LEN);
<a name="l00708" id="l00708"></a>00708         <span class="keywordflow">if</span> (rc != 0) {
<a name="l00709" id="l00709"></a>00709             DEBUGMSGTL((<span class="stringliteral">"netsnmp_ssh_transport"</span>,
<a name="l00710" id="l00710"></a>00710                         <span class=
"stringliteral">"couldn't listen to \"%s\", errno %d (%s)\n"</span>,
<a name="l00711" id="l00711"></a>00711                         unaddr-&gt;sun_path, errno, strerror(errno)));
<a name="l00712" id="l00712"></a>00712             netsnmp_ssh_close(t);
<a name="l00713" id="l00713"></a>00713             netsnmp_transport_free(t);
<a name="l00714" id="l00714"></a>00714             <span class="keywordflow">return</span> NULL;
<a name="l00715" id="l00715"></a>00715         }
<a name="l00716" id="l00716"></a>00716         
<a name="l00717" id="l00717"></a>00717 
<a name="l00718" id="l00718"></a>00718 <span class="preprocessor">#else </span><span class=
"comment">/* we're called directly by sshd and use stdin/out */</span>
<a name="l00719" id="l00719"></a>00719         <span class=
"comment">/* for ssh on the server side we've been launched so bind to</span>
<a name="l00720" id="l00720"></a>00720 <span class="comment">           stdin/out */</span>
<a name="l00721" id="l00721"></a>00721 
<a name="l00722" id="l00722"></a>00722         <span class="comment">/* nothing to do */</span>
<a name="l00723" id="l00723"></a>00723 
<a name="l00724" id="l00724"></a>00724         <span class="comment">/* XXX: verify we're inside ssh */</span>
<a name="l00725" id="l00725"></a>00725         t-&gt;sock = STDIN_FILENO;
<a name="l00726" id="l00726"></a>00726 <span class="preprocessor">#endif </span><span class=
"comment">/* ! SNMPSSHDOMAIN_USE_EXTERNAL_PIPE */</span>
<a name="l00727" id="l00727"></a>00727 
<a name="l00728" id="l00728"></a>00728     } <span class="keywordflow">else</span> {
<a name="l00729" id="l00729"></a>00729         <span class="comment">/* XXX: need an ipv6 friendly one too (sigh) */</span>
<a name="l00730" id="l00730"></a>00730 
<a name="l00731" id="l00731"></a>00731         <span class=
"comment">/* XXX: not ideal when structs don't actually match size wise */</span>
<a name="l00732" id="l00732"></a>00732         memcpy(&amp;(addr_pair-&gt;remote_addr), addr, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));
<a name="l00733" id="l00733"></a>00733 
<a name="l00734" id="l00734"></a>00734         t-&gt;sock = socket(PF_INET, SOCK_STREAM, 0);
<a name="l00735" id="l00735"></a>00735         <span class="keywordflow">if</span> (t-&gt;sock &lt; 0) {
<a name="l00736" id="l00736"></a>00736             netsnmp_transport_free(t);
<a name="l00737" id="l00737"></a>00737             <span class="keywordflow">return</span> NULL;
<a name="l00738" id="l00738"></a>00738         }
<a name="l00739" id="l00739"></a>00739 
<a name="l00740" id="l00740"></a>00740         t-&gt;remote = (u_char *)malloc(6);
<a name="l00741" id="l00741"></a>00741         <span class="keywordflow">if</span> (t-&gt;remote == NULL) {
<a name="l00742" id="l00742"></a>00742             netsnmp_ssh_close(t);
<a name="l00743" id="l00743"></a>00743             netsnmp_transport_free(t);
<a name="l00744" id="l00744"></a>00744             <span class="keywordflow">return</span> NULL;
<a name="l00745" id="l00745"></a>00745         }
<a name="l00746" id="l00746"></a>00746         memcpy(t-&gt;remote, (u_char *) &amp; (addr-&gt;sin_addr.s_addr), 4);
<a name="l00747" id="l00747"></a>00747         t-&gt;remote[4] = (htons(addr-&gt;sin_port) &amp; 0xff00) &gt;&gt; 8;
<a name="l00748" id="l00748"></a>00748         t-&gt;remote[5] = (htons(addr-&gt;sin_port) &amp; 0x00ff) &gt;&gt; 0;
<a name="l00749" id="l00749"></a>00749         t-&gt;remote_length = 6;
<a name="l00750" id="l00750"></a>00750 
<a name="l00751" id="l00751"></a>00751         <span class="comment">/*</span>
<a name="l00752" id="l00752"></a>00752 <span class=
"comment">         * This is a client-type session, so attempt to connect to the far</span>
<a name="l00753" id="l00753"></a>00753 <span class=
"comment">         * end.  We don't go non-blocking here because it's not obvious what</span>
<a name="l00754" id="l00754"></a>00754 <span class=
"comment">         * you'd then do if you tried to do snmp_sends before the connection</span>
<a name="l00755" id="l00755"></a>00755 <span class="comment">         * had completed.  So this can block.</span>
<a name="l00756" id="l00756"></a>00756 <span class="comment">         */</span>
<a name="l00757" id="l00757"></a>00757 
<a name="l00758" id="l00758"></a>00758         rc = connect(t-&gt;sock, (<span class="keyword">struct</span> sockaddr *)addr,
<a name="l00759" id="l00759"></a>00759                      <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr));
<a name="l00760" id="l00760"></a>00760 
<a name="l00761" id="l00761"></a>00761         <span class="keywordflow">if</span> (rc &lt; 0) {
<a name="l00762" id="l00762"></a>00762             netsnmp_ssh_close(t);
<a name="l00763" id="l00763"></a>00763             netsnmp_transport_free(t);
<a name="l00764" id="l00764"></a>00764             <span class="keywordflow">return</span> NULL;
<a name="l00765" id="l00765"></a>00765         }
<a name="l00766" id="l00766"></a>00766 
<a name="l00767" id="l00767"></a>00767         <span class="comment">/*</span>
<a name="l00768" id="l00768"></a>00768 <span class=
"comment">         * Allow user to override the send and receive buffers. Default is</span>
<a name="l00769" id="l00769"></a>00769 <span class=
"comment">         * to use os default.  Don't worry too much about errors --</span>
<a name="l00770" id="l00770"></a>00770 <span class="comment">         * just plough on regardless.  </span>
<a name="l00771" id="l00771"></a>00771 <span class="comment">         */</span>
<a name="l00772" id="l00772"></a>00772         netsnmp_sock_buffer_set(t-&gt;sock, SO_SNDBUF, local, 0);
<a name="l00773" id="l00773"></a>00773         netsnmp_sock_buffer_set(t-&gt;sock, SO_RCVBUF, local, 0);
<a name="l00774" id="l00774"></a>00774 
<a name="l00775" id="l00775"></a>00775         <span class="comment">/* open the SSH session and channel */</span>
<a name="l00776" id="l00776"></a>00776         addr_pair-&gt;session = libssh2_session_init();
<a name="l00777" id="l00777"></a>00777         <span class=
"keywordflow">if</span> (libssh2_session_startup(addr_pair-&gt;session, t-&gt;sock)) {
<a name="l00778" id="l00778"></a>00778           shutdown:
<a name="l00779" id="l00779"></a>00779             <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Failed to establish an SSH session\n"</span>);
<a name="l00780" id="l00780"></a>00780             netsnmp_ssh_close(t);
<a name="l00781" id="l00781"></a>00781             netsnmp_transport_free(t);
<a name="l00782" id="l00782"></a>00782             <span class="keywordflow">return</span> NULL;
<a name="l00783" id="l00783"></a>00783         }
<a name="l00784" id="l00784"></a>00784 
<a name="l00785" id="l00785"></a>00785         <span class=
"comment">/* At this point we havn't authenticated, The first thing to</span>
<a name="l00786" id="l00786"></a>00786 <span class=
"comment">           do is check the hostkey's fingerprint against our known</span>
<a name="l00787" id="l00787"></a>00787 <span class=
"comment">           hosts Your app may have it hard coded, may go to a file,</span>
<a name="l00788" id="l00788"></a>00788 <span class="comment">           may present it to the user, that's your call</span>
<a name="l00789" id="l00789"></a>00789 <span class="comment">         */</span>
<a name="l00790" id="l00790"></a>00790         fingerprint =
<a name="l00791" id="l00791"></a>00791             libssh2_hostkey_hash(addr_pair-&gt;session, LIBSSH2_HOSTKEY_HASH_MD5);
<a name="l00792" id="l00792"></a>00792         DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"Fingerprint: "</span>));
<a name="l00793" id="l00793"></a>00793         <span class="keywordflow">for</span>(i = 0; i &lt; 16; i++) {
<a name="l00794" id="l00794"></a>00794             DEBUGMSG((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"%02x"</span>,
<a name="l00795" id="l00795"></a>00795                       (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">char</span>)fingerprint[i]));
<a name="l00796" id="l00796"></a>00796         }
<a name="l00797" id="l00797"></a>00797         DEBUGMSG((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"\n"</span>));
<a name="l00798" id="l00798"></a>00798 
<a name="l00799" id="l00799"></a>00799         <span class="comment">/* check what authentication methods are available */</span>
<a name="l00800" id="l00800"></a>00800         userauthlist =
<a name="l00801" id="l00801"></a>00801             libssh2_userauth_list(addr_pair-&gt;session,
<a name="l00802" id="l00802"></a>00802                                   username, strlen(username));
<a name="l00803" id="l00803"></a>00803         DEBUGMSG((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"Authentication methods: %s\n"</span>, userauthlist));
<a name="l00804" id="l00804"></a>00804 
<a name="l00805" id="l00805"></a>00805         <span class="comment">/* XXX: allow other types */</span>
<a name="l00806" id="l00806"></a>00806         <span class="comment">/* XXX: 4 seems magic to me... */</span>
<a name="l00807" id="l00807"></a>00807         <span class="keywordflow">if</span> (strstr(userauthlist, <span class=
"stringliteral">"publickey"</span>) != NULL) {
<a name="l00808" id="l00808"></a>00808             auth_pw |= 4;
<a name="l00809" id="l00809"></a>00809         }
<a name="l00810" id="l00810"></a>00810 
<a name="l00811" id="l00811"></a>00811         <span class="comment">/* XXX: hard coded paths and users */</span>
<a name="l00812" id="l00812"></a>00812         <span class="keywordflow">if</span> (auth_pw &amp; 4) {
<a name="l00813" id="l00813"></a>00813             <span class="comment">/* public key */</span>
<a name="l00814" id="l00814"></a>00814             <span class=
"keywordflow">if</span> (libssh2_userauth_publickey_fromfile(addr_pair-&gt;session,
<a name="l00815" id="l00815"></a>00815                                                     username,
<a name="l00816" id="l00816"></a>00816                                                     keyfile1, keyfile2,
<a name="l00817" id="l00817"></a>00817                                                     NULL)) {
<a name="l00818" id="l00818"></a>00818                 <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"Authentication by public key failed!\n"</span>);
<a name="l00819" id="l00819"></a>00819                 <span class="keywordflow">goto</span> shutdown;
<a name="l00820" id="l00820"></a>00820             } <span class="keywordflow">else</span> {
<a name="l00821" id="l00821"></a>00821                 DEBUGMSG((<span class="stringliteral">"ssh"</span>,
<a name="l00822" id="l00822"></a>00822                           <span class=
"stringliteral">"\tAuthentication by public key succeeded.\n"</span>));
<a name="l00823" id="l00823"></a>00823             }
<a name="l00824" id="l00824"></a>00824         } <span class="keywordflow">else</span> {
<a name="l00825" id="l00825"></a>00825             <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR,<span class=
"stringliteral">"Authentication by public key failed!\n"</span>);
<a name="l00826" id="l00826"></a>00826             <span class="keywordflow">goto</span> shutdown;
<a name="l00827" id="l00827"></a>00827         }
<a name="l00828" id="l00828"></a>00828 
<a name="l00829" id="l00829"></a>00829         <span class=
"comment">/* we've now authenticated both sides; contining onward ... */</span>
<a name="l00830" id="l00830"></a>00830 
<a name="l00831" id="l00831"></a>00831         <span class="comment">/* Request a channel */</span>
<a name="l00832" id="l00832"></a>00832         <span class="keywordflow">if</span> (!(addr_pair-&gt;channel =
<a name="l00833" id="l00833"></a>00833               libssh2_channel_open_session(addr_pair-&gt;session))) {
<a name="l00834" id="l00834"></a>00834             <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Unable to open a session\n"</span>);
<a name="l00835" id="l00835"></a>00835             <span class="keywordflow">goto</span> shutdown;
<a name="l00836" id="l00836"></a>00836         }
<a name="l00837" id="l00837"></a>00837 
<a name="l00838" id="l00838"></a>00838         <span class=
"comment">/* Request a terminal with 'vanilla' terminal emulation</span>
<a name="l00839" id="l00839"></a>00839 <span class="comment">         * See /etc/termcap for more options</span>
<a name="l00840" id="l00840"></a>00840 <span class="comment">         */</span>
<a name="l00841" id="l00841"></a>00841         <span class="comment">/* XXX: needed?  doubt it */</span>
<a name="l00842" id="l00842"></a>00842 <span class=
"comment">/*         if (libssh2_channel_request_pty(addr_pair-&gt;channel, "vanilla")) { */</span>
<a name="l00843" id="l00843"></a>00843 <span class=
"comment">/*             snmp_log(LOG_ERR, "Failed requesting pty\n"); */</span>
<a name="l00844" id="l00844"></a>00844 <span class="comment">/*             goto shutdown; */</span>
<a name="l00845" id="l00845"></a>00845 <span class="comment">/*         } */</span>
<a name="l00846" id="l00846"></a>00846         <span class=
"keywordflow">if</span> (libssh2_channel_subsystem(addr_pair-&gt;channel, <span class="stringliteral">"snmp"</span>)) {
<a name="l00847" id="l00847"></a>00847             <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Failed to request the ssh 'snmp' subsystem\n"</span>);
<a name="l00848" id="l00848"></a>00848             <span class="keywordflow">goto</span> shutdown;
<a name="l00849" id="l00849"></a>00849         }
<a name="l00850" id="l00850"></a>00850     }
<a name="l00851" id="l00851"></a>00851 
<a name="l00852" id="l00852"></a>00852     DEBUGMSG((<span class="stringliteral">"ssh"</span>,<span class=
"stringliteral">"Opened connection.\n"</span>));
<a name="l00853" id="l00853"></a>00853     <span class="comment">/*</span>
<a name="l00854" id="l00854"></a>00854 <span class=
"comment">     * Message size is not limited by this transport (hence msgMaxSize</span>
<a name="l00855" id="l00855"></a>00855 <span class=
"comment">     * is equal to the maximum legal size of an SNMP message).  </span>
<a name="l00856" id="l00856"></a>00856 <span class="comment">     */</span>
<a name="l00857" id="l00857"></a>00857 
<a name="l00858" id="l00858"></a>00858     t-&gt;msgMaxSize = 0x7fffffff;
<a name="l00859" id="l00859"></a>00859     t-&gt;f_recv     = netsnmp_ssh_recv;
<a name="l00860" id="l00860"></a>00860     t-&gt;f_send     = netsnmp_ssh_send;
<a name="l00861" id="l00861"></a>00861     t-&gt;f_close    = netsnmp_ssh_close;
<a name="l00862" id="l00862"></a>00862     t-&gt;f_accept   = netsnmp_ssh_accept;
<a name="l00863" id="l00863"></a>00863     t-&gt;f_fmtaddr  = netsnmp_ssh_fmtaddr;
<a name="l00864" id="l00864"></a>00864 
<a name="l00865" id="l00865"></a>00865     <span class="keywordflow">return</span> t;
<a name="l00866" id="l00866"></a>00866 }
<a name="l00867" id="l00867"></a>00867 
<a name="l00868" id="l00868"></a>00868 
<a name="l00869" id="l00869"></a>00869 
<a name="l00870" id="l00870"></a>00870 <a class="code" href="structnetsnmp__transport__s.html">netsnmp_transport</a> *
<a name="l00871" id="l00871"></a>00871 netsnmp_ssh_create_tstring(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *str, <span class="keywordtype">int</span> local,
<a name="l00872" id="l00872"></a>00872                            <span class="keyword">const</span> <span class=
"keywordtype">char</span> *default_target)
<a name="l00873" id="l00873"></a>00873 {
<a name="l00874" id="l00874"></a>00874     <span class="keyword">struct </span>sockaddr_in addr;
<a name="l00875" id="l00875"></a>00875 
<a name="l00876" id="l00876"></a>00876     <span class=
"keywordflow">if</span> (netsnmp_sockaddr_in2(&amp;addr, str, default_target)) {
<a name="l00877" id="l00877"></a>00877         <span class="keywordflow">return</span> netsnmp_ssh_transport(&amp;addr, local);
<a name="l00878" id="l00878"></a>00878     } <span class="keywordflow">else</span> {
<a name="l00879" id="l00879"></a>00879         <span class="keywordflow">return</span> NULL;
<a name="l00880" id="l00880"></a>00880     }
<a name="l00881" id="l00881"></a>00881 }
<a name="l00882" id="l00882"></a>00882 
<a name="l00883" id="l00883"></a>00883 
<a name="l00884" id="l00884"></a>00884 
<a name="l00885" id="l00885"></a>00885 <a class="code" href="structnetsnmp__transport__s.html">netsnmp_transport</a> *
<a name="l00886" id="l00886"></a>00886 netsnmp_ssh_create_ostring(<span class="keyword">const</span> u_char * o, <span class=
"keywordtype">size_t</span> o_len, <span class="keywordtype">int</span> local)
<a name="l00887" id="l00887"></a>00887 {
<a name="l00888" id="l00888"></a>00888     <span class="keyword">struct </span>sockaddr_in addr;
<a name="l00889" id="l00889"></a>00889 
<a name="l00890" id="l00890"></a>00890     <span class="keywordflow">if</span> (o_len == 6) {
<a name="l00891" id="l00891"></a>00891         <span class="keywordtype">unsigned</span> <span class=
"keywordtype">short</span> porttmp = (o[4] &lt;&lt; 8) + o[5];
<a name="l00892" id="l00892"></a>00892         addr.sin_family = AF_INET;
<a name="l00893" id="l00893"></a>00893         memcpy((u_char *) &amp; (addr.sin_addr.s_addr), o, 4);
<a name="l00894" id="l00894"></a>00894         addr.sin_port = htons(porttmp);
<a name="l00895" id="l00895"></a>00895         <span class="keywordflow">return</span> netsnmp_ssh_transport(&amp;addr, local);
<a name="l00896" id="l00896"></a>00896     }
<a name="l00897" id="l00897"></a>00897     <span class="keywordflow">return</span> NULL;
<a name="l00898" id="l00898"></a>00898 }
<a name="l00899" id="l00899"></a>00899 
<a name="l00900" id="l00900"></a>00900 <span class="keywordtype">void</span>
<a name="l00901" id="l00901"></a>00901 sshdomain_parse_socket(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *token, <span class="keywordtype">char</span> *cptr)
<a name="l00902" id="l00902"></a>00902 {
<a name="l00903" id="l00903"></a>00903     <span class="keywordtype">char</span> *socket_perm, *socket_user, *socket_group;
<a name="l00904" id="l00904"></a>00904     <span class="keywordtype">int</span> uid = -1;
<a name="l00905" id="l00905"></a>00905     <span class="keywordtype">int</span> gid = -1;
<a name="l00906" id="l00906"></a>00906     <span class="keywordtype">int</span> s_perm = -1;
<a name="l00907" id="l00907"></a>00907     <span class="keywordtype">char</span> *st;
<a name="l00908" id="l00908"></a>00908 
<a name="l00909" id="l00909"></a>00909     DEBUGMSGTL((<span class="stringliteral">"ssh/config"</span>, <span class=
"stringliteral">"parsing socket info: %s\n"</span>, cptr));
<a name="l00910" id="l00910"></a>00910     socket_perm = strtok_r(cptr, <span class="stringliteral">" \t"</span>, &amp;st);
<a name="l00911" id="l00911"></a>00911     socket_user = strtok_r(NULL, <span class="stringliteral">" \t"</span>, &amp;st);
<a name="l00912" id="l00912"></a>00912     socket_group = strtok_r(NULL, <span class="stringliteral">" \t"</span>, &amp;st);
<a name="l00913" id="l00913"></a>00913 
<a name="l00914" id="l00914"></a>00914     <span class="keywordflow">if</span> (socket_perm) {
<a name="l00915" id="l00915"></a>00915         s_perm = strtol(socket_perm, NULL, 8);
<a name="l00916" id="l00916"></a>00916         netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,
<a name="l00917" id="l00917"></a>00917                            NETSNMP_DS_SSHDOMAIN_SOCK_PERM, s_perm);
<a name="l00918" id="l00918"></a>00918         DEBUGMSGTL((<span class="stringliteral">"ssh/config"</span>, <span class=
"stringliteral">"socket permissions: %o (%d)\n"</span>,
<a name="l00919" id="l00919"></a>00919                     s_perm, s_perm));
<a name="l00920" id="l00920"></a>00920     }
<a name="l00921" id="l00921"></a>00921     <span class="comment">/*</span>
<a name="l00922" id="l00922"></a>00922 <span class=
"comment">     * Try to handle numeric UIDs or user names for the socket owner</span>
<a name="l00923" id="l00923"></a>00923 <span class="comment">     */</span>
<a name="l00924" id="l00924"></a>00924     <span class="keywordflow">if</span> (socket_user) {
<a name="l00925" id="l00925"></a>00925         uid = netsnmp_str_to_uid(socket_user);
<a name="l00926" id="l00926"></a>00926         <span class="keywordflow">if</span> ( uid != 0 )
<a name="l00927" id="l00927"></a>00927             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,
<a name="l00928" id="l00928"></a>00928                                NETSNMP_DS_SSHDOMAIN_SOCK_USER, uid);
<a name="l00929" id="l00929"></a>00929         DEBUGMSGTL((<span class="stringliteral">"ssh/config"</span>, <span class=
"stringliteral">"socket owner: %s (%d)\n"</span>,
<a name="l00930" id="l00930"></a>00930                     socket_user, uid));
<a name="l00931" id="l00931"></a>00931     }
<a name="l00932" id="l00932"></a>00932 
<a name="l00933" id="l00933"></a>00933     <span class="comment">/*</span>
<a name="l00934" id="l00934"></a>00934 <span class="comment">     * and similarly for the socket group ownership</span>
<a name="l00935" id="l00935"></a>00935 <span class="comment">     */</span>
<a name="l00936" id="l00936"></a>00936     <span class="keywordflow">if</span> (socket_group) {
<a name="l00937" id="l00937"></a>00937         gid = netsnmp_str_to_gid(socket_group);
<a name="l00938" id="l00938"></a>00938         <span class="keywordflow">if</span> ( gid != 0 )
<a name="l00939" id="l00939"></a>00939             netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,
<a name="l00940" id="l00940"></a>00940                                NETSNMP_DS_SSHDOMAIN_SOCK_GROUP, gid);
<a name="l00941" id="l00941"></a>00941         DEBUGMSGTL((<span class="stringliteral">"ssh/config"</span>, <span class=
"stringliteral">"socket group: %s (%d)\n"</span>,
<a name="l00942" id="l00942"></a>00942                     socket_group, gid));
<a name="l00943" id="l00943"></a>00943     }
<a name="l00944" id="l00944"></a>00944 }
<a name="l00945" id="l00945"></a>00945 
<a name="l00946" id="l00946"></a>00946 <span class="keywordtype">void</span>
<a name="l00947" id="l00947"></a>00947 netsnmp_ssh_ctor(<span class="keywordtype">void</span>)    
<a name="l00948" id="l00948"></a>00948 {
<a name="l00949" id="l00949"></a>00949     sshDomain.name = netsnmp_snmpSSHDomain;
<a name="l00950" id="l00950"></a>00950     sshDomain.name_length = <span class=
"keyword">sizeof</span>(netsnmp_snmpSSHDomain) / <span class="keyword">sizeof</span>(oid);
<a name="l00951" id="l00951"></a>00951     sshDomain.prefix = (<span class="keyword">const</span> <span class=
"keywordtype">char</span> **)calloc(2, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
<a name="l00952" id="l00952"></a>00952     sshDomain.prefix[0] = <span class="stringliteral">"ssh"</span>;
<a name="l00953" id="l00953"></a>00953 
<a name="l00954" id="l00954"></a>00954     sshDomain.f_create_from_tstring_new = netsnmp_ssh_create_tstring;
<a name="l00955" id="l00955"></a>00955     sshDomain.f_create_from_ostring = netsnmp_ssh_create_ostring;
<a name="l00956" id="l00956"></a>00956 
<a name="l00957" id="l00957"></a>00957     <a class="code" href="group__read__config.html#ga9a3e481d8eb7d3ef08efa25b9a186c3b"
title=
"register_config_handler registers handlers for certain tokens specified in certain...">register_config_handler</a>(<span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"sshtosnmpsocketperms"</span>,
<a name="l00958" id="l00958"></a>00958                             &amp;sshdomain_parse_socket, NULL,
<a name="l00959" id="l00959"></a>00959                             <span class=
"stringliteral">"socketperms [username [groupname]]"</span>);
<a name="l00960" id="l00960"></a>00960 
<a name="l00961" id="l00961"></a>00961     netsnmp_ds_register_config(ASN_OCTET_STR, <span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"sshtosnmpsocket"</span>,
<a name="l00962" id="l00962"></a>00962                                NETSNMP_DS_LIBRARY_ID,
<a name="l00963" id="l00963"></a>00963                                NETSNMP_DS_LIB_SSHTOSNMP_SOCKET);
<a name="l00964" id="l00964"></a>00964 
<a name="l00965" id="l00965"></a>00965     DEBUGMSGTL((<span class="stringliteral">"ssh"</span>, <span class=
"stringliteral">"registering the ssh domain\n"</span>));
<a name="l00966" id="l00966"></a>00966     netsnmp_tdomain_register(&amp;sshDomain);
<a name="l00967" id="l00967"></a>00967 }
<a name="l00968" id="l00968"></a>00968 
<a name="l00969" id="l00969"></a>00969 
</pre>
    </div>
  </div>
  <hr size="1" />

  <address style="text-align: right;">
    <small>Generated on 28 Sep 2009 for net-snmp by  <a href="http://www.doxygen.org/index.html"><img class="footer" src=
    "doxygen.png" alt="doxygen" /></a> 1.6.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

