<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>net-snmp: asn1 parsing and datatype manipulation routines.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">net-snmp&#160;<span id="projectnumber">5.7</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">asn1 parsing and datatype manipulation routines.</div>  </div>
<div class="ingroups"><a class="el" href="group__library.html">The Net-SNMP library</a></div></div>
<div class="contents">

<p>Note on.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga070d2ce7b6bb7e5c05602aa8c308d0c4"></a><!-- doxytag: member="asn1_packet_parse::NULL" ref="ga070d2ce7b6bb7e5c05602aa8c308d0c4" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NULL</b>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga181807730d4a375f848ba139813ce04f"></a><!-- doxytag: member="asn1_packet_parse::INT32_MAX" ref="ga181807730d4a375f848ba139813ce04f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INT32_MAX</b>&#160;&#160;&#160;2147483647</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga688eb21a22db27c2b2bd5836943cdcbe"></a><!-- doxytag: member="asn1_packet_parse::INT32_MIN" ref="ga688eb21a22db27c2b2bd5836943cdcbe" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INT32_MIN</b>&#160;&#160;&#160;(0 - INT32_MAX - 1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHECK_OVERFLOW_S</b>(x, y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CHECK_OVERFLOW_U</b>(x, y)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaca34eac3a917cce6f1cb238613576469"></a><!-- doxytag: member="asn1_packet_parse::asn_check_packet" ref="gaca34eac3a917cce6f1cb238613576469" args="(u_char *pkt, size_t len)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>asn_check_packet</b> (u_char *pkt, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga052f6f216ddb1907a2f21a1766fc4a09"></a><!-- doxytag: member="asn1_packet_parse::asn_parse_int" ref="ga052f6f216ddb1907a2f21a1766fc4a09" args="(u_char *data, size_t *datalength, u_char *type, long *intp, size_t intsize)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_parse_int</b> (u_char *data, size_t *datalength, u_char *type, long *intp, size_t intsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa2ef962b06b096003738258b9afa6333"></a><!-- doxytag: member="asn1_packet_parse::asn_parse_unsigned_int" ref="gaa2ef962b06b096003738258b9afa6333" args="(u_char *data, size_t *datalength, u_char *type, u_long *intp, size_t intsize)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_parse_unsigned_int</b> (u_char *data, size_t *datalength, u_char *type, u_long *intp, size_t intsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7873d57bd15baa0356228ea9b71714a7"></a><!-- doxytag: member="asn1_packet_parse::asn_build_int" ref="ga7873d57bd15baa0356228ea9b71714a7" args="(u_char *data, size_t *datalength, u_char type, const long *intp, size_t intsize)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_build_int</b> (u_char *data, size_t *datalength, u_char type, const long *intp, size_t intsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe3e9a7978ef46b62cd71b8cc8423f61"></a><!-- doxytag: member="asn1_packet_parse::asn_build_unsigned_int" ref="gafe3e9a7978ef46b62cd71b8cc8423f61" args="(u_char *data, size_t *datalength, u_char type, const u_long *intp, size_t intsize)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_build_unsigned_int</b> (u_char *data, size_t *datalength, u_char type, const u_long *intp, size_t intsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6492aaeb4f6444a5157c01e66219d807"></a><!-- doxytag: member="asn1_packet_parse::asn_parse_string" ref="ga6492aaeb4f6444a5157c01e66219d807" args="(u_char *data, size_t *datalength, u_char *type, u_char *str, size_t *strlength)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_parse_string</b> (u_char *data, size_t *datalength, u_char *type, u_char *str, size_t *strlength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaffd8999d733e489b733ca0057b991403"></a><!-- doxytag: member="asn1_packet_parse::asn_build_string" ref="gaffd8999d733e489b733ca0057b991403" args="(u_char *data, size_t *datalength, u_char type, const u_char *str, size_t strlength)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_build_string</b> (u_char *data, size_t *datalength, u_char type, const u_char *str, size_t strlength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga50cfa70f02385f0f5fdff2bdaac13bf5"></a><!-- doxytag: member="asn1_packet_parse::asn_parse_header" ref="ga50cfa70f02385f0f5fdff2bdaac13bf5" args="(u_char *data, size_t *datalength, u_char *type)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_parse_header</b> (u_char *data, size_t *datalength, u_char *type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0e4493b18a81dbe7bd5401fd01b3ad19"></a><!-- doxytag: member="asn1_packet_parse::asn_parse_sequence" ref="ga0e4493b18a81dbe7bd5401fd01b3ad19" args="(u_char *data, size_t *datalength, u_char *type, u_char expected_type, const char *estr)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_parse_sequence</b> (u_char *data, size_t *datalength, u_char *type, u_char expected_type, const char *estr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga698b488fb34affe27927d265d9fd6034"></a><!-- doxytag: member="asn1_packet_parse::asn_build_header" ref="ga698b488fb34affe27927d265d9fd6034" args="(u_char *data, size_t *datalength, u_char type, size_t length)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_build_header</b> (u_char *data, size_t *datalength, u_char type, size_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a27c0e4a1ac4b7165c5d884d169e103"></a><!-- doxytag: member="asn1_packet_parse::asn_build_sequence" ref="ga9a27c0e4a1ac4b7165c5d884d169e103" args="(u_char *data, size_t *datalength, u_char type, size_t length)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_build_sequence</b> (u_char *data, size_t *datalength, u_char type, size_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6164792250ba3a2081bd9e566c0f75f0"></a><!-- doxytag: member="asn1_packet_parse::asn_parse_length" ref="ga6164792250ba3a2081bd9e566c0f75f0" args="(u_char *data, u_long *length)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_parse_length</b> (u_char *data, u_long *length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a2b9ed231a77311ccff5799a0fc50ba"></a><!-- doxytag: member="asn1_packet_parse::asn_build_length" ref="ga5a2b9ed231a77311ccff5799a0fc50ba" args="(u_char *data, size_t *datalength, size_t length)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_build_length</b> (u_char *data, size_t *datalength, size_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa183b001a5573300031039c48a2f940b"></a><!-- doxytag: member="asn1_packet_parse::asn_parse_objid" ref="gaa183b001a5573300031039c48a2f940b" args="(u_char *data, size_t *datalength, u_char *type, oid *objid, size_t *objidlength)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_parse_objid</b> (u_char *data, size_t *datalength, u_char *type, oid *objid, size_t *objidlength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf4abd3365f8abbf19d638c0f543a389"></a><!-- doxytag: member="asn1_packet_parse::asn_build_objid" ref="gacf4abd3365f8abbf19d638c0f543a389" args="(u_char *data, size_t *datalength, u_char type, oid *objid, size_t objidlength)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_build_objid</b> (u_char *data, size_t *datalength, u_char type, oid *objid, size_t objidlength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5c195aef6f1da359c66ab3289a887079"></a><!-- doxytag: member="asn1_packet_parse::asn_parse_null" ref="ga5c195aef6f1da359c66ab3289a887079" args="(u_char *data, size_t *datalength, u_char *type)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_parse_null</b> (u_char *data, size_t *datalength, u_char *type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga15221d777e38056a60b7ac26131318e1"></a><!-- doxytag: member="asn1_packet_parse::asn_build_null" ref="ga15221d777e38056a60b7ac26131318e1" args="(u_char *data, size_t *datalength, u_char type)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_build_null</b> (u_char *data, size_t *datalength, u_char type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5f3ed6500b150faad78cfffe5e142963"></a><!-- doxytag: member="asn1_packet_parse::asn_parse_bitstring" ref="ga5f3ed6500b150faad78cfffe5e142963" args="(u_char *data, size_t *datalength, u_char *type, u_char *str, size_t *strlength)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_parse_bitstring</b> (u_char *data, size_t *datalength, u_char *type, u_char *str, size_t *strlength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga78322b7450e3af623b09dc108b331842"></a><!-- doxytag: member="asn1_packet_parse::asn_build_bitstring" ref="ga78322b7450e3af623b09dc108b331842" args="(u_char *data, size_t *datalength, u_char type, const u_char *str, size_t strlength)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_build_bitstring</b> (u_char *data, size_t *datalength, u_char type, const u_char *str, size_t strlength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga04acbd9372a22a0a6d213c44c6c3af0d"></a><!-- doxytag: member="asn1_packet_parse::asn_parse_unsigned_int64" ref="ga04acbd9372a22a0a6d213c44c6c3af0d" args="(u_char *data, size_t *datalength, u_char *type, struct counter64 *cp, size_t countersize)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_parse_unsigned_int64</b> (u_char *data, size_t *datalength, u_char *type, struct <a class="el" href="structcounter64.html">counter64</a> *cp, size_t countersize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b496981fe779f68417dfd308cf47df3"></a><!-- doxytag: member="asn1_packet_parse::asn_build_unsigned_int64" ref="ga6b496981fe779f68417dfd308cf47df3" args="(u_char *data, size_t *datalength, u_char type, const struct counter64 *cp, size_t countersize)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>asn_build_unsigned_int64</b> (u_char *data, size_t *datalength, u_char type, const struct <a class="el" href="structcounter64.html">counter64</a> *cp, size_t countersize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab59001ef6a1e6efde1c6a2391918cdf6"></a><!-- doxytag: member="asn1_packet_parse::asn_realloc" ref="gab59001ef6a1e6efde1c6a2391918cdf6" args="(u_char **pkt, size_t *pkt_len)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>asn_realloc</b> (u_char **pkt, size_t *pkt_len)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Note on. </p>
<p>Re-allocating reverse ASN.1 encoder functions. Synopsis:</p>
<div class="fragment"><pre class="fragment"> u_char *buf = (u_char*)malloc(100);
 u_char type = (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER);
 <span class="keywordtype">size_t</span> buf_len = 100, offset = 0;
 <span class="keywordtype">long</span> data = 12345;
 <span class="keywordtype">int</span> allow_realloc = 1;
 
 <span class="keywordflow">if</span> (asn_realloc_rbuild_int(&amp;buf, &amp;buf_len, &amp;offset, allow_realloc,
                            type, &amp;data, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>)) == 0) {
     error;
 }
</pre></div><p>NOTE WELL: after calling one of these functions with allow_realloc non-zero, buf might have moved, buf_len might have grown and offset will have increased by the size of the encoded data. You should **NEVER** do something like this:</p>
<div class="fragment"><pre class="fragment"> u_char *buf = (u_char *)malloc(100), *ptr;
 u_char type = (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER);
 <span class="keywordtype">size_t</span> buf_len = 100, offset = 0;
 <span class="keywordtype">long</span> data1 = 1234, data2 = 5678;
 <span class="keywordtype">int</span> rc = 0, allow_realloc = 1;
 
 rc  = asn_realloc_rbuild_int(&amp;buf, &amp;buf_len, &amp;offset, allow_realloc,
                                type, &amp;data1, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
 ptr = buf[buf_len - offset];   / * points at encoding of data1 * /
 <span class="keywordflow">if</span> (rc == 0) {
      error;
 }
 rc  = asn_realloc_rbuild_int(&amp;buf, &amp;buf_len, &amp;offset, allow_realloc,
                              type, &amp;data2, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
 make use of ptr here;
</pre></div><p>ptr is **INVALID** at this point. In general, you should store the offset value and compute pointers when you need them:</p>
<div class="fragment"><pre class="fragment"> u_char *buf = (u_char *)malloc(100), *ptr;
 u_char type = (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER);
 <span class="keywordtype">size_t</span> buf_len = 100, offset = 0, ptr_offset;
 <span class="keywordtype">long</span> data1 = 1234, data2 = 5678;
 <span class="keywordtype">int</span> rc = 0, allow_realloc = 1;
 
 rc  = asn_realloc_rbuild_int(&amp;buf, &amp;buf_len, &amp;offset, allow_realloc,
                              type, &amp;data1, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
 ptr_offset = offset;
 <span class="keywordflow">if</span> (rc == 0) {
      error;
 }
 rc  = asn_realloc_rbuild_int(&amp;buf, &amp;buf_len, &amp;offset, allow_realloc,
                              type, &amp;data2, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
 ptr = buf + buf_len - ptr_offset
 make use of ptr here;
</pre></div><p>Here, you can see that ptr will be a valid pointer even if the block of memory has been moved, as it may well have been. Plenty of examples of usage all over <a class="el" href="asn1_8c_source.html">asn1.c</a>, <a class="el" href="snmp__api_8c_source.html">snmp_api.c</a>, <a class="el" href="snmpusm_8c_source.html">snmpusm.c</a>.</p>
<p>The other thing you should **NEVER** do is to pass a pointer to a buffer on the stack as the first argument when allow_realloc is non-zero, unless you really know what you are doing and your machine/compiler allows you to free non-heap memory. There are rumours that such things exist, but many consider them no more than the wild tales of a fool.</p>
<p>Of course, you can pass allow_realloc as zero, to indicate that you do not wish the packet buffer to be reallocated for some reason; perhaps because it is on the stack. This may be useful to emulate the functionality of the old API:</p>
<div class="fragment"><pre class="fragment"> u_char my_static_buffer[100], *cp = NULL;
 <span class="keywordtype">size_t</span> my_static_buffer_len = 100;
 <span class="keywordtype">float</span> my_pi = (float)22/(<span class="keywordtype">float</span>)7;
 
 cp = asn_rbuild_float(my_static_buffer, &amp;my_static_buffer_len,
                       ASN_OPAQUE_FLOAT, &amp;my_pi, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
 <span class="keywordflow">if</span> (cp == NULL) {
 error;
 }
</pre></div><p>IS EQUIVALENT TO:</p>
<div class="fragment"><pre class="fragment"> u_char my_static_buffer[100];
 <span class="keywordtype">size_t</span> my_static_buffer_len = 100, my_offset = 0;
 <span class="keywordtype">float</span> my_pi = (float)22/(<span class="keywordtype">float</span>)7;
 <span class="keywordtype">int</span> rc = 0;
 
 rc = asn_realloc_rbuild_float(&amp;my_static_buffer, &amp;my_static_buffer_len,
                               &amp;my_offset, 0,
                               ASN_OPAQUE_FLOAT, &amp;my_pi, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
 <span class="keywordflow">if</span> (rc == 0) {
   error;
 }
</pre></div> <hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaad6883850efcf93cce52ece24b8c88a2"></a><!-- doxytag: member="asn1.c::CHECK_OVERFLOW_S" ref="gaad6883850efcf93cce52ece24b8c88a2" args="(x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_OVERFLOW_S</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                    \
        <span class="keywordflow">if</span> (x &gt; INT32_MAX) {                                            \
            DEBUGMSG((<span class="stringliteral">&quot;asn&quot;</span>,<span class="stringliteral">&quot;truncating signed value %ld to 32 bits (%d)\n&quot;</span>,(<span class="keywordtype">long</span>)(x),y)); \
            x &amp;= 0xffffffff;                                            \
        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x &lt; INT32_MIN) {                                     \
            DEBUGMSG((<span class="stringliteral">&quot;asn&quot;</span>,<span class="stringliteral">&quot;truncating signed value %ld to 32 bits (%d)\n&quot;</span>,(<span class="keywordtype">long</span>)(x),y)); \
            x = 0 - (x &amp; 0xffffffff);                                   \
        }                                                               \
    } <span class="keywordflow">while</span>(0)
</pre></div>
<p>Definition at line <a class="el" href="asn1_8c_source.html#l00211">211</a> of file <a class="el" href="asn1_8c_source.html">asn1.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga182f703531402c39c485f363915cb0bd"></a><!-- doxytag: member="asn1.c::CHECK_OVERFLOW_U" ref="ga182f703531402c39c485f363915cb0bd" args="(x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_OVERFLOW_U</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {                                    \
        <span class="keywordflow">if</span> (x &gt; UINT32_MAX) {                                           \
            x &amp;= 0xffffffff;                                            \
            DEBUGMSG((<span class="stringliteral">&quot;asn&quot;</span>,<span class="stringliteral">&quot;truncating unsigned value to 32 bits (%d)\n&quot;</span>,y)); \
        }                                                               \
    } <span class="keywordflow">while</span>(0)
</pre></div>
<p>Definition at line <a class="el" href="asn1_8c_source.html#l00221">221</a> of file <a class="el" href="asn1_8c_source.html">asn1.c</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jul 14 2011 for net-snmp by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
