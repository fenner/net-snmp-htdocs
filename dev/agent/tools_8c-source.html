<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>tools.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * tools.c</span>
00003 <span class="comment"> */</span>
00004 
00005 <span class="preprocessor">#define NETSNMP_TOOLS_C 1 </span><span class=
"comment">/* dont re-define malloc wrappers here */</span>
00006 
00007 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00008 
00009 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00010 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00011 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00012 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00013 <span class="preprocessor"># ifdef WIN32</span>
00014 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00015 <span class="preprocessor"># else</span>
00016 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00017 <span class="preprocessor"># endif</span>
00018 <span class="preprocessor"># include &lt;time.h&gt;</span>
00019 <span class="preprocessor">#else</span>
00020 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00021 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00022 <span class="preprocessor"># else</span>
00023 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00024 <span class="preprocessor"># endif</span>
00025 <span class="preprocessor">#endif</span>
00026 <span class="preprocessor">#ifdef HAVE_SYS_SOCKET_H</span>
00027 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00028 <span class="preprocessor">#endif</span>
00029 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00030 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00031 <span class="preprocessor">#endif</span>
00032 <span class="preprocessor">#ifdef HAVE_STDLIB_H</span>
00033 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00034 <span class="preprocessor">#endif</span>
00035 <span class="preprocessor">#if HAVE_STRING_H</span>
00036 <span class="preprocessor">#include &lt;string.h&gt;</span>
00037 <span class="preprocessor">#else</span>
00038 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00039 <span class="preprocessor">#endif</span>
00040 <span class="preprocessor">#ifdef HAVE_NETINET_IN_H</span>
00041 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00042 <span class="preprocessor">#endif</span>
00043 <span class="preprocessor">#ifdef HAVE_ARPA_INET_H</span>
00044 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
00045 <span class="preprocessor">#endif</span>
00046 <span class="preprocessor">#ifdef cygwin</span>
00047 <span class="preprocessor">#include &lt;windows.h&gt;</span>
00048 <span class="preprocessor">#endif</span>
00049 
00050 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00051 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00052 <span class="preprocessor">#endif</span>
00053 
00054 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00055 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00056 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00057 <span class="preprocessor">#include &lt;net-snmp/library/tools.h&gt;</span>     <span class=
"comment">/* for "internal" definitions */</span>
00058 
00059 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00060 <span class="preprocessor">#include &lt;net-snmp/library/mib.h&gt;</span>
00061 <span class="preprocessor">#include &lt;net-snmp/library/scapi.h&gt;</span>
00062 
00063 <span class="preprocessor">#ifdef WIN32</span>
00064 
00067 <span class="keywordtype">char</span> * netsnmp_strdup( <span class="keyword">const</span> <span class=
"keywordtype">char</span> * ptr)
00068 {
00069     <span class="keywordflow">return</span> strdup(ptr);
00070 }
00074 <span class="keywordtype">void</span> * netsnmp_calloc(size_t nmemb, size_t size)
00075 {
00076     <span class="keywordflow">return</span> calloc(nmemb, size);
00077 }
00078 
00082 <span class="keywordtype">void</span> * netsnmp_malloc(size_t size)
00083 {
00084     <span class="keywordflow">return</span> malloc(size);
00085 }
00086 
00090 <span class="keywordtype">void</span> * netsnmp_realloc( <span class="keywordtype">void</span> * ptr, size_t size)
00091 {
00092     <span class="keywordflow">return</span> realloc(ptr, size);
00093 }
00094 
00099 <span class="keywordtype">void</span> netsnmp_free( <span class="keywordtype">void</span> * ptr)
00100 {
00101     <span class="keywordflow">if</span> (ptr)
00102         free(ptr);
00103 }
00104 <span class="preprocessor">#endif </span><span class="comment">/* WIN32 */</span>
00105 
00120 <span class="keywordtype">int</span>
<a name="l00121" id="l00121"></a><a class="code" href="group__util.html#ga1">00121</a> <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(u_char ** buf, size_t * buf_len)
00122 {
00123     u_char         *new_buf = NULL;
00124     size_t          new_buf_len = 0;
00125 
00126     <span class="keywordflow">if</span> (buf == NULL) {
00127         <span class="keywordflow">return</span> 0;
00128     }
00129 
00130     <span class="keywordflow">if</span> (*buf_len &lt;= 255) {
00131         new_buf_len = *buf_len + 256;
00132     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (*buf_len &gt; 255 &amp;&amp; *buf_len &lt;= 8191) {
00133         new_buf_len = *buf_len * 2;
00134     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*buf_len &gt; 8191) {
00135         new_buf_len = *buf_len + 8192;
00136     }
00137 
00138     <span class="keywordflow">if</span> (*buf == NULL) {
00139         new_buf = (u_char *) malloc(new_buf_len);
00140     } <span class="keywordflow">else</span> {
00141         new_buf = (u_char *) realloc(*buf, new_buf_len);
00142     }
00143 
00144     <span class="keywordflow">if</span> (new_buf != NULL) {
00145         *buf = new_buf;
00146         *buf_len = new_buf_len;
00147         <span class="keywordflow">return</span> 1;
00148     } <span class="keywordflow">else</span> {
00149         <span class="keywordflow">return</span> 0;
00150     }
00151 }
00152 
00153 <span class="keywordtype">int</span>
00154 snmp_strcat(u_char ** buf, size_t * buf_len, size_t * out_len,
00155             <span class="keywordtype">int</span> allow_realloc, <span class="keyword">const</span> u_char * s)
00156 {
00157     <span class="keywordflow">if</span> (buf == NULL || buf_len == NULL || out_len == NULL) {
00158         <span class="keywordflow">return</span> 0;
00159     }
00160 
00161     <span class="keywordflow">if</span> (s == NULL) {
00162         <span class="comment">/*</span>
00163 <span class="comment">         * Appending a NULL string always succeeds since it is a NOP.  </span>
00164 <span class="comment">         */</span>
00165         <span class="keywordflow">return</span> 1;
00166     }
00167 
00168     <span class="keywordflow">while</span> ((*out_len + strlen((<span class="keyword">const</span> <span class=
"keywordtype">char</span> *) s) + 1) &gt;= *buf_len) {
00169         <span class="keywordflow">if</span> (!(allow_realloc &amp;&amp; <a class="code" href=
"group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00170             <span class="keywordflow">return</span> 0;
00171         }
00172     }
00173 
00174     strcpy((<span class="keywordtype">char</span> *) (*buf + *out_len), (<span class="keyword">const</span> <span class=
"keywordtype">char</span> *) s);
00175     *out_len += strlen((<span class="keywordtype">char</span> *) (*buf + *out_len));
00176     <span class="keywordflow">return</span> 1;
00177 }
00178 
00184 <span class="keywordtype">void</span>
<a name="l00185" id="l00185"></a><a class="code" href="group__util.html#ga2">00185</a> <a class="code" href=
"group__util.html#ga2">free_zero</a>(<span class="keywordtype">void</span> *buf, size_t size)
00186 {
00187     <span class="keywordflow">if</span> (buf) {
00188         memset(buf, 0, size);
00189         free(buf);
00190     }
00191 
00192 }                               <span class="comment">/* end free_zero() */</span>
00193 
00204 u_char         *
<a name="l00205" id="l00205"></a><a class="code" href="group__util.html#ga3">00205</a> <a class="code" href=
"group__util.html#ga3">malloc_random</a>(size_t * size)
00206 {
00207     <span class="keywordtype">int</span>             rval = SNMPERR_SUCCESS;
00208     u_char         *buf = (u_char *) calloc(1, *size);
00209 
00210     <span class="keywordflow">if</span> (buf) {
00211         rval = sc_random(buf, size);
00212 
00213         <span class="keywordflow">if</span> (rval &lt; 0) {
00214             <a class="code" href="group__util.html#ga2">free_zero</a>(buf, *size);
00215             buf = NULL;
00216         } <span class="keywordflow">else</span> {
00217             *size = rval;
00218         }
00219     }
00220 
00221     <span class="keywordflow">return</span> buf;
00222 
00223 }                               <span class="comment">/* end malloc_random() */</span>
00224 
00235 <span class="keywordtype">int</span>
<a name="l00236" id="l00236"></a><a class="code" href="group__util.html#ga5">00236</a> <a class="code" href=
"group__util.html#ga5">memdup</a>(u_char ** to, <span class="keyword">const</span> u_char * from, size_t size)
00237 {
00238     <span class="keywordflow">if</span> (to == NULL)
00239         <span class="keywordflow">return</span> SNMPERR_GENERR;
00240     <span class="keywordflow">if</span> (from == NULL) {
00241         *to = NULL;
00242         <span class="keywordflow">return</span> SNMPERR_SUCCESS;
00243     }
00244     <span class="keywordflow">if</span> ((*to = (u_char *) malloc(size)) == NULL)
00245         <span class="keywordflow">return</span> SNMPERR_GENERR;
00246     memcpy(*to, from, size);
00247     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
00248 
00249 }                               <span class="comment">/* end memdup() */</span>
00250 
00254 <span class="keywordtype">char</span>           *
<a name="l00255" id="l00255"></a><a class="code" href="group__util.html#ga12">00255</a> <a class="code" href=
"group__util.html#ga12">netsnmp_strdup_and_null</a>(<span class="keyword">const</span> u_char * from, size_t from_len)
00256 {
00257     u_char         *ret;
00258 
00259     <span class="keywordflow">if</span> (from_len == 0 || from[from_len - 1] != <span class="charliteral">'\0'</span>) {
00260         ret = malloc(from_len + 1);
00261         <span class="keywordflow">if</span> (!ret)
00262             <span class="keywordflow">return</span> NULL;
00263         ret[from_len] = <span class="charliteral">'\0'</span>;
00264     } <span class="keywordflow">else</span> {
00265         ret = malloc(from_len);
00266         <span class="keywordflow">if</span> (!ret)
00267             <span class="keywordflow">return</span> NULL;
00268         ret[from_len - 1] = <span class="charliteral">'\0'</span>;
00269     }
00270     memcpy(ret, from, from_len);
00271     <span class="keywordflow">return</span> ret;
00272 }
00273 
00286 u_int
<a name="l00287" id="l00287"></a><a class="code" href="group__util.html#ga6">00287</a> <a class="code" href=
"group__util.html#ga6">binary_to_hex</a>(<span class="keyword">const</span> u_char * input, size_t len, <span class=
"keywordtype">char</span> **output)
00288 {
00289     u_int           olen = (len * 2) + 1;
00290     <span class="keywordtype">char</span>           *s = (<span class=
"keywordtype">char</span> *) calloc(1, olen), *op = s;
00291     <span class="keyword">const</span> u_char   *ip = input;
00292 
00293 
00294     <span class="keywordflow">while</span> (ip - input &lt; (int) len) {
00295         *op++ = VAL2HEX((*ip &gt;&gt; 4) &amp; 0xf);
00296         *op++ = VAL2HEX(*ip &amp; 0xf);
00297         ip++;
00298     }
00299     *op = <span class="charliteral">'\0'</span>;
00300 
00301     *output = s;
00302     <span class="keywordflow">return</span> olen;
00303 
00304 }                               <span class="comment">/* end binary_to_hex() */</span>
00305 
00306 
00307 
00308 
00323 <span class="keywordtype">int</span>
<a name="l00324" id="l00324"></a><a class="code" href="group__util.html#ga9">00324</a> <a class="code" href=
"group__util.html#ga9">hex_to_binary2</a>(<span class="keyword">const</span> u_char * input, size_t len, <span class=
"keywordtype">char</span> **output)
00325 {
00326     u_int           olen = (len / 2) + (len % 2);
00327     <span class="keywordtype">char</span>           *s = (<span class=
"keywordtype">char</span> *) calloc(1, (olen) ? olen : 1), *op = s;
00328     <span class="keyword">const</span> u_char   *ip = input;
00329 
00330 
00331     *output = NULL;
00332     *op = 0;
00333     <span class="keywordflow">if</span> (len % 2) {
00334         <span class="keywordflow">if</span> (!isxdigit(*ip))
00335             <span class="keywordflow">goto</span> hex_to_binary2_quit;
00336         *op++ = HEX2VAL(*ip);
00337         ip++;
00338     }
00339 
00340     <span class="keywordflow">while</span> (ip - input &lt; (int) len) {
00341         <span class="keywordflow">if</span> (!isxdigit(*ip))
00342             <span class="keywordflow">goto</span> hex_to_binary2_quit;
00343         *op = HEX2VAL(*ip) &lt;&lt; 4;
00344         ip++;
00345 
00346         <span class="keywordflow">if</span> (!isxdigit(*ip))
00347             <span class="keywordflow">goto</span> hex_to_binary2_quit;
00348         *op++ += HEX2VAL(*ip);
00349         ip++;
00350     }
00351 
00352     *output = s;
00353     <span class="keywordflow">return</span> olen;
00354 
00355   hex_to_binary2_quit:
00356     <a class="code" href="group__util.html#ga2">free_zero</a>(s, olen);
00357     <span class="keywordflow">return</span> -1;
00358 
00359 }                               <span class="comment">/* end hex_to_binary2() */</span>
00360 
00361 <span class="keywordtype">int</span>
00362 snmp_decimal_to_binary(u_char ** buf, size_t * buf_len, size_t * out_len,
00363                        <span class="keywordtype">int</span> allow_realloc, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *decimal)
00364 {
00365     <span class="keywordtype">int</span>             subid = 0;
00366     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp = decimal;
00367 
00368     <span class="keywordflow">if</span> (buf == NULL || buf_len == NULL || out_len == NULL
00369         || decimal == NULL) {
00370         <span class="keywordflow">return</span> 0;
00371     }
00372 
00373     <span class="keywordflow">while</span> (*cp != <span class="charliteral">'\0'</span>) {
00374         <span class="keywordflow">if</span> (isspace((<span class="keywordtype">int</span>) *cp) || *cp == <span class=
"charliteral">'.'</span>) {
00375             cp++;
00376             <span class="keywordflow">continue</span>;
00377         }
00378         <span class="keywordflow">if</span> (!isdigit((<span class="keywordtype">int</span>) *cp)) {
00379             <span class="keywordflow">return</span> 0;
00380         }
00381         <span class="keywordflow">if</span> ((subid = atoi(cp)) &gt; 255) {
00382             <span class="keywordflow">return</span> 0;
00383         }
00384         <span class="keywordflow">if</span> ((*out_len &gt;= *buf_len) &amp;&amp;
00385             !(allow_realloc &amp;&amp; <a class="code" href="group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00386             <span class="keywordflow">return</span> 0;
00387         }
00388         *(*buf + *out_len) = (u_char) subid;
00389         (*out_len)++;
00390         <span class="keywordflow">while</span> (isdigit((<span class="keywordtype">int</span>) *cp)) {
00391             cp++;
00392         }
00393     }
00394     <span class="keywordflow">return</span> 1;
00395 }
00396 
00424 <span class="keywordtype">int</span>
<a name="l00425" id="l00425"></a><a class="code" href="group__util.html#ga7">00425</a> <a class="code" href=
"group__util.html#ga7">netsnmp_hex_to_binary</a>(u_char ** buf, size_t * buf_len, size_t * offset,
00426                       <span class="keywordtype">int</span> allow_realloc, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *hex, <span class="keyword">const</span> <span class="keywordtype">char</span> *delim)
00427 {
00428     <span class="keywordtype">int</span>             subid = 0;
00429     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp = hex;
00430 
00431     <span class="keywordflow">if</span> (buf == NULL || buf_len == NULL || offset == NULL || hex == NULL) {
00432         <span class="keywordflow">return</span> 0;
00433     }
00434 
00435     <span class="keywordflow">if</span> ((*cp == <span class=
"charliteral">'0'</span>) &amp;&amp; ((*(cp + 1) == <span class="charliteral">'x'</span>) || (*(cp + 1) == <span class=
"charliteral">'X'</span>))) {
00436         cp += 2;
00437     }
00438 
00439     <span class="keywordflow">while</span> (*cp != <span class="charliteral">'\0'</span>) {
00440         <span class="keywordflow">if</span> (!isxdigit((<span class="keywordtype">int</span>) *cp)) {
00441             <span class="keywordflow">if</span> ((NULL != delim) &amp;&amp; (NULL != strchr(delim, *cp))) {
00442                 cp++;
00443                 <span class="keywordflow">continue</span>;
00444             }
00445             <span class="keywordflow">return</span> 0;
00446         }
00447         <span class="keywordflow">if</span> (sscanf(cp, <span class="stringliteral">"%2x"</span>, &amp;subid) == 0) {
00448             <span class="keywordflow">return</span> 0;
00449         }
00450         <span class="comment">/*</span>
00451 <span class="comment">         * if we dont' have enough space, realloc.</span>
00452 <span class="comment">         * (snmp_realloc will adjust buf_len to new size)</span>
00453 <span class="comment">         */</span>
00454         <span class="keywordflow">if</span> ((*offset &gt;= *buf_len) &amp;&amp;
00455             !(allow_realloc &amp;&amp; <a class="code" href="group__util.html#ga1">snmp_realloc</a>(buf, buf_len))) {
00456             <span class="keywordflow">return</span> 0;
00457         }
00458         *(*buf + *offset) = (u_char) subid;
00459         (*offset)++;
00460         <span class="keywordflow">if</span> (*++cp == <span class="charliteral">'\0'</span>) {
00461             <span class="comment">/*</span>
00462 <span class="comment">             * Odd number of hex digits is an error.  </span>
00463 <span class="comment">             */</span>
00464             <span class="keywordflow">return</span> 0;
00465         } <span class="keywordflow">else</span> {
00466             cp++;
00467         }
00468     }
00469     <span class="keywordflow">return</span> 1;
00470 }
00471 
00483 <span class="keywordtype">int</span>
<a name="l00484" id="l00484"></a><a class="code" href="group__util.html#ga8">00484</a> <a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(u_char ** buf, size_t * buf_len, size_t * offset,
00485                    <span class="keywordtype">int</span> allow_realloc, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *hex)
00486 {
00487     <span class="keywordflow">return</span> <a class="code" href=
"group__util.html#ga7">netsnmp_hex_to_binary</a>(buf, buf_len, offset, allow_realloc, hex, <span class=
"stringliteral">" "</span>);
00488 }
00489 
00490 <span class="comment">/*******************************************************************-o-******</span>
00491 <span class="comment"> * dump_chunk</span>
00492 <span class="comment"> *</span>
00493 <span class="comment"> * Parameters:</span>
00494 <span class="comment"> *      *title  (May be NULL.)</span>
00495 <span class="comment"> *      *buf</span>
00496 <span class="comment"> *       size</span>
00497 <span class="comment"> */</span>
00498 <span class="keywordtype">void</span>
00499 dump_chunk(<span class="keyword">const</span> <span class="keywordtype">char</span> *debugtoken, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *title, <span class="keyword">const</span> u_char * buf,
00500            <span class="keywordtype">int</span> size)
00501 {
00502     u_int           printunit = 64;     <span class="comment">/* XXX  Make global. */</span>
00503     <span class="keywordtype">char</span>            chunk[SNMP_MAXBUF], *s, *sp;
00504 
00505     <span class="keywordflow">if</span> (title &amp;&amp; (*title != <span class="charliteral">'\0'</span>)) {
00506         DEBUGMSGTL((debugtoken, <span class="stringliteral">"%s\n"</span>, title));
00507     }
00508 
00509 
00510     memset(chunk, 0, SNMP_MAXBUF);
00511     size = <a class="code" href="group__util.html#ga6">binary_to_hex</a>(buf, size, &amp;s);
00512     sp = s;
00513 
00514     <span class="keywordflow">while</span> (size &gt; 0) {
00515         <span class="keywordflow">if</span> (size &gt; (int) printunit) {
00516             strncpy(chunk, sp, printunit);
00517             chunk[printunit] = <span class="charliteral">'\0'</span>;
00518             DEBUGMSGTL((debugtoken, <span class="stringliteral">"\t%s\n"</span>, chunk));
00519         } <span class="keywordflow">else</span> {
00520             DEBUGMSGTL((debugtoken, <span class="stringliteral">"\t%s\n"</span>, sp));
00521         }
00522 
00523         sp += printunit;
00524         size -= printunit;
00525     }
00526 
00527 
00528     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s);
00529 
00530 }                               <span class="comment">/* end dump_chunk() */</span>
00531 
00532 
00533 
00534 
00535 <span class="comment">/*******************************************************************-o-******</span>
00536 <span class="comment"> * dump_snmpEngineID</span>
00537 <span class="comment"> *</span>
00538 <span class="comment"> * Parameters:</span>
00539 <span class="comment"> *      *estring</span>
00540 <span class="comment"> *      *estring_len</span>
00541 <span class="comment"> *      </span>
00542 <span class="comment"> * Returns:</span>
00543 <span class="comment"> *      Allocated memory pointing to a string of buflen char representing</span>
00544 <span class="comment"> *      a printf'able form of the snmpEngineID.</span>
00545 <span class="comment"> *</span>
00546 <span class="comment"> *      -OR- NULL on error.</span>
00547 <span class="comment"> *</span>
00548 <span class="comment"> *</span>
00549 <span class="comment"> * Translates the snmpEngineID TC into a printable string.  From RFC 2271,</span>
00550 <span class="comment"> * Section 5 (pp. 36-37):</span>
00551 <span class="comment"> *</span>
00552 <span class="comment"> * First bit:   0       Bit string structured by means non-SNMPv3.</span>
00553 <span class="comment"> *              1       Structure described by SNMPv3 SnmpEngineID TC.</span>
00554 <span class="comment"> *  </span>
00555 <span class="comment"> * Bytes 1-4:           Enterprise ID.  (High bit of first byte is ignored.)</span>
00556 <span class="comment"> *  </span>
00557 <span class="comment"> * Byte 5:      0       (RESERVED by IANA.)</span>
00558 <span class="comment"> *              1       IPv4 address.           (   4 octets)</span>
00559 <span class="comment"> *              2       IPv6 address.           (  16 octets)</span>
00560 <span class="comment"> *              3       MAC address.            (   6 octets)</span>
00561 <span class="comment"> *              4       Locally defined text.   (0-27 octets)</span>
00562 <span class="comment"> *              5       Locally defined octets. (0-27 octets)</span>
00563 <span class="comment"> *              6-127   (RESERVED for enterprise.)</span>
00564 <span class="comment"> *  </span>
00565 <span class="comment"> * Bytes 6-32:          (Determined by byte 5.)</span>
00566 <span class="comment"> *  </span>
00567 <span class="comment"> *</span>
00568 <span class="comment"> * Non-printable characters are given in hex.  Text is given in quotes.</span>
00569 <span class="comment"> * IP and MAC addresses are given in standard (UN*X) conventions.  Sections</span>
00570 <span class="comment"> * are comma separated.</span>
00571 <span class="comment"> *</span>
00572 <span class="comment"> * esp, remaining_len and s trace the state of the constructed buffer.</span>
00573 <span class="comment"> * s will be defined if there is something to return, and it will point</span>
00574 <span class="comment"> * to the end of the constructed buffer.</span>
00575 <span class="comment"> *</span>
00576 <span class="comment"> *</span>
00577 <span class="comment"> * ASSUME  "Text" means printable characters.</span>
00578 <span class="comment"> *</span>
00579 <span class="comment"> * XXX  Must the snmpEngineID always have a minimum length of 12?</span>
00580 <span class="comment"> *      (Cf. part 2 of the TC definition.)</span>
00581 <span class="comment"> * XXX  Does not enforce upper-bound of 32 bytes.</span>
00582 <span class="comment"> * XXX  Need a switch to decide whether to use DNS name instead of a simple</span>
00583 <span class="comment"> *      IP address.</span>
00584 <span class="comment"> *</span>
00585 <span class="comment"> * FIX  Use something other than snprint_hexstring which doesn't add </span>
00586 <span class="comment"> *      trailing spaces and (sometimes embedded) newlines...</span>
00587 <span class="comment"> */</span>
00588 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
00589 <span class="keywordtype">char</span>           *
00590 dump_snmpEngineID(<span class="keyword">const</span> u_char * estring, size_t * estring_len)
00591 {
00592 <span class="preprocessor">#define eb(b)   ( *(esp+b) &amp; 0xff )</span>
00593 
00594     <span class="keywordtype">int</span>             rval = SNMPERR_SUCCESS, gotviolation = 0, slen = 0;
00595     u_int           remaining_len;
00596 
00597     <span class="keywordtype">char</span>            buf[SNMP_MAXBUF], *s = NULL, *t;
00598     <span class="keyword">const</span> u_char   *esp = estring;
00599 
00600     <span class="keyword">struct </span>in_addr  iaddr;
00601 
00602 
00603 
00604     <span class="comment">/*</span>
00605 <span class="comment">     * Sanity check.</span>
00606 <span class="comment">     */</span>
00607     <span class="keywordflow">if</span> (!estring || (*estring_len &lt;= 0)) {
00608         QUITFUN(SNMPERR_GENERR, dump_snmpEngineID_quit);
00609     }
00610     remaining_len = *estring_len;
00611     memset(buf, 0, SNMP_MAXBUF);
00612 
00613 
00614 
00615     <span class="comment">/*</span>
00616 <span class="comment">     * Test first bit.  Return immediately with a hex string, or</span>
00617 <span class="comment">     * begin by formatting the enterprise ID.</span>
00618 <span class="comment">     */</span>
00619     <span class="keywordflow">if</span> (!(*esp &amp; 0x80)) {
00620         snprint_hexstring(buf, SNMP_MAXBUF, esp, remaining_len);
00621         s = strchr(buf, <span class="charliteral">'\0'</span>);
00622         s -= 1;
00623         <span class="keywordflow">goto</span> dump_snmpEngineID_quit;
00624     }
00625 
00626     s = buf;
00627     s += sprintf(s, <span class="stringliteral">"enterprise %d, "</span>, ((*(esp + 0) &amp; 0x7f) &lt;&lt; 24) |
00628                  ((*(esp + 1) &amp; 0xff) &lt;&lt; 16) |
00629                  ((*(esp + 2) &amp; 0xff) &lt;&lt; 8) | ((*(esp + 3) &amp; 0xff)));
00630     <span class="comment">/*</span>
00631 <span class="comment">     * XXX  Ick. </span>
00632 <span class="comment">     */</span>
00633 
00634     <span class="keywordflow">if</span> (remaining_len &lt; 5) {    <span class=
"comment">/* XXX  Violating string. */</span>
00635         <span class="keywordflow">goto</span> dump_snmpEngineID_quit;
00636     }
00637 
00638     esp += 4;                   <span class="comment">/* Incremented one more in the switch below. */</span>
00639     remaining_len -= 5;
00640 
00641 
00642 
00643     <span class="comment">/*</span>
00644 <span class="comment">     * Act on the fifth byte.</span>
00645 <span class="comment">     */</span>
00646     <span class="keywordflow">switch</span> ((int) *esp++) {
00647     <span class="keywordflow">case</span> 1:                    <span class="comment">/* IPv4 address. */</span>
00648 
00649         <span class="keywordflow">if</span> (remaining_len &lt; 4)
00650             <span class="keywordflow">goto</span> dump_snmpEngineID_violation;
00651         memcpy(&amp;iaddr.s_addr, esp, 4);
00652 
00653         <span class="keywordflow">if</span> (!(t = inet_ntoa(iaddr)))
00654             <span class="keywordflow">goto</span> dump_snmpEngineID_violation;
00655         s += sprintf(s, <span class="stringliteral">"%s"</span>, t);
00656 
00657         esp += 4;
00658         remaining_len -= 4;
00659         <span class="keywordflow">break</span>;
00660 
00661     <span class="keywordflow">case</span> 2:                    <span class="comment">/* IPv6 address. */</span>
00662 
00663         <span class="keywordflow">if</span> (remaining_len &lt; 16)
00664             <span class="keywordflow">goto</span> dump_snmpEngineID_violation;
00665 
00666         s += sprintf(s,
00667                      <span class="stringliteral">"%02X%02X %02X%02X %02X%02X %02X%02X::"</span>
00668                      <span class="stringliteral">"%02X%02X %02X%02X %02X%02X %02X%02X"</span>,
00669                      eb(0), eb(1), eb(2), eb(3),
00670                      eb(4), eb(5), eb(6), eb(7),
00671                      eb(8), eb(9), eb(10), eb(11),
00672                      eb(12), eb(13), eb(14), eb(15));
00673 
00674         esp += 16;
00675         remaining_len -= 16;
00676         <span class="keywordflow">break</span>;
00677 
00678     <span class="keywordflow">case</span> 3:                    <span class="comment">/* MAC address. */</span>
00679 
00680         <span class="keywordflow">if</span> (remaining_len &lt; 6)
00681             <span class="keywordflow">goto</span> dump_snmpEngineID_violation;
00682 
00683         s += sprintf(s, <span class="stringliteral">"%02X:%02X:%02X:%02X:%02X:%02X"</span>,
00684                      eb(0), eb(1), eb(2), eb(3), eb(4), eb(5));
00685 
00686         esp += 6;
00687         remaining_len -= 6;
00688         <span class="keywordflow">break</span>;
00689 
00690     <span class="keywordflow">case</span> 4:                    <span class="comment">/* Text. */</span>
00691 
00692         <span class="comment">/*</span>
00693 <span class="comment">         * Doesn't exist on all (many) architectures </span>
00694 <span class="comment">         */</span>
00695         <span class="comment">/*</span>
00696 <span class="comment">         * s += snprintf(s, remaining_len+3, "\"%s\"", esp); </span>
00697 <span class="comment">         */</span>
00698         s += sprintf(s, <span class="stringliteral">"\"%s\""</span>, esp);
00699         <span class="keywordflow">goto</span> dump_snmpEngineID_quit;
00700         <span class="keywordflow">break</span>;
00701      <span class="comment">/*NOTREACHED*/</span> <span class="keywordflow">case</span> 5:    <span class=
"comment">/* Octets. */</span>
00702 
00703         snprint_hexstring(s, (SNMP_MAXBUF - (s-buf)),
00704                           esp, remaining_len);
00705         s = strchr(buf, <span class="charliteral">'\0'</span>);
00706         s -= 1;
00707         <span class="keywordflow">goto</span> dump_snmpEngineID_quit;
00708         <span class="keywordflow">break</span>;
00709        <span class="comment">/*NOTREACHED*/</span> dump_snmpEngineID_violation:
00710     <span class="keywordflow">case</span> 0:                    <span class="comment">/* Violation of RESERVED, </span>
00711 <span class="comment">                                 * *   -OR- of expected length.</span>
00712 <span class="comment">                                 */</span>
00713         gotviolation = 1;
00714         s += sprintf(s, <span class="stringliteral">"!!! "</span>);
00715 
00716     <span class="keywordflow">default</span>:                   <span class="comment">/* Unknown encoding. */</span>
00717 
00718         <span class="keywordflow">if</span> (!gotviolation) {
00719             s += sprintf(s, <span class="stringliteral">"??? "</span>);
00720         }
00721         snprint_hexstring(s, (SNMP_MAXBUF - (s-buf)),
00722                           esp, remaining_len);
00723         s = strchr(buf, <span class="charliteral">'\0'</span>);
00724         s -= 1;
00725 
00726         <span class="keywordflow">goto</span> dump_snmpEngineID_quit;
00727 
00728     }                           <span class="comment">/* endswitch */</span>
00729 
00730 
00731 
00732     <span class="comment">/*</span>
00733 <span class="comment">     * Cases 1-3 (IP and MAC addresses) should not have trailing</span>
00734 <span class="comment">     * octets, but perhaps they do.  Throw them in too.  XXX</span>
00735 <span class="comment">     */</span>
00736     <span class="keywordflow">if</span> (remaining_len &gt; 0) {
00737         s += sprintf(s, <span class="stringliteral">" (??? "</span>);
00738 
00739         snprint_hexstring(s, (SNMP_MAXBUF - (s-buf)),
00740                           esp, remaining_len);
00741         s = strchr(buf, <span class="charliteral">'\0'</span>);
00742         s -= 1;
00743 
00744         s += sprintf(s, <span class="stringliteral">")"</span>);
00745     }
00746 
00747 
00748 
00749   dump_snmpEngineID_quit:
00750     <span class="keywordflow">if</span> (s) {
00751         slen = s - buf + 1;
00752         s = calloc(1, slen);
00753         memcpy(s, buf, (slen) - 1);
00754     }
00755 
00756     memset(buf, 0, SNMP_MAXBUF);        <span class="comment">/* XXX -- Overkill? XXX: Yes! */</span>
00757 
00758     <span class="keywordflow">return</span> s;
00759 
00760 <span class="preprocessor">#undef eb</span>
00761 }                               <span class="comment">/* end dump_snmpEngineID() */</span>
00762 <span class="preprocessor">#endif                          </span><span class="comment">/* SNMP_TESTING_CODE */</span>
00763 
00764 
00769 marker_t
<a name="l00770" id="l00770"></a><a class="code" href="group__util.html#ga15">00770</a> <a class="code" href=
"group__util.html#ga15">atime_newMarker</a>(<span class="keywordtype">void</span>)
00771 {
00772     marker_t        pm = (marker_t) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> timeval));
00773     gettimeofday((<span class="keyword">struct</span> timeval *) pm, 0);
00774     <span class="keywordflow">return</span> pm;
00775 }
00776 
00780 <span class="keywordtype">void</span>
<a name="l00781" id="l00781"></a><a class="code" href="group__util.html#ga16">00781</a> <a class="code" href=
"group__util.html#ga16">atime_setMarker</a>(marker_t pm)
00782 {
00783     <span class="keywordflow">if</span> (!pm)
00784         <span class="keywordflow">return</span>;
00785 
00786     gettimeofday((<span class="keyword">struct</span> timeval *) pm, 0);
00787 }
00788 
00789 
00793 <span class="keywordtype">long</span>
<a name="l00794" id="l00794"></a><a class="code" href="group__util.html#ga17">00794</a> <a class="code" href=
"group__util.html#ga17">atime_diff</a>(marker_t first, marker_t second)
00795 {
00796     <span class="keyword">struct </span>timeval *tv1, *tv2, diff;
00797 
00798     tv1 = (<span class="keyword">struct </span>timeval *) first;
00799     tv2 = (<span class="keyword">struct </span>timeval *) second;
00800 
00801     diff.tv_sec = tv2-&gt;tv_sec - tv1-&gt;tv_sec - 1;
00802     diff.tv_usec = tv2-&gt;tv_usec - tv1-&gt;tv_usec + 1000000;
00803 
00804     <span class="keywordflow">return</span> (diff.tv_sec * 1000 + diff.tv_usec / 1000);
00805 }
00806 
00810 u_long
<a name="l00811" id="l00811"></a><a class="code" href="group__util.html#ga18">00811</a> <a class="code" href=
"group__util.html#ga18">uatime_diff</a>(marker_t first, marker_t second)
00812 {
00813     <span class="keyword">struct </span>timeval *tv1, *tv2, diff;
00814 
00815     tv1 = (<span class="keyword">struct </span>timeval *) first;
00816     tv2 = (<span class="keyword">struct </span>timeval *) second;
00817 
00818     diff.tv_sec = tv2-&gt;tv_sec - tv1-&gt;tv_sec - 1;
00819     diff.tv_usec = tv2-&gt;tv_usec - tv1-&gt;tv_usec + 1000000;
00820 
00821     <span class="keywordflow">return</span> (((u_long) diff.tv_sec) * 1000 + diff.tv_usec / 1000);
00822 }
00823 
00828 u_long
<a name="l00829" id="l00829"></a><a class="code" href="group__util.html#ga19">00829</a> <a class="code" href=
"group__util.html#ga19">uatime_hdiff</a>(marker_t first, marker_t second)
00830 {
00831     <span class="keyword">struct </span>timeval *tv1, *tv2, diff;
00832     u_long          res;
00833 
00834     tv1 = (<span class="keyword">struct </span>timeval *) first;
00835     tv2 = (<span class="keyword">struct </span>timeval *) second;
00836 
00837     diff.tv_sec = tv2-&gt;tv_sec - tv1-&gt;tv_sec - 1;
00838     diff.tv_usec = tv2-&gt;tv_usec - tv1-&gt;tv_usec + 1000000;
00839 
00840     res = ((u_long) diff.tv_sec) * 100 + diff.tv_usec / 10000;
00841     <span class="keywordflow">return</span> res;
00842 }
00843 
00848 <span class="keywordtype">int</span>
<a name="l00849" id="l00849"></a><a class="code" href="group__util.html#ga20">00849</a> <a class="code" href=
"group__util.html#ga20">atime_ready</a>(marker_t pm, <span class="keywordtype">int</span> deltaT)
00850 {
00851     marker_t        now;
00852     <span class="keywordtype">long</span>            diff;
00853     <span class="keywordflow">if</span> (!pm)
00854         <span class="keywordflow">return</span> 0;
00855 
00856     now = <a class="code" href="group__util.html#ga15">atime_newMarker</a>();
00857 
00858     diff = <a class="code" href="group__util.html#ga17">atime_diff</a>(pm, now);
00859     free(now);
00860     <span class="keywordflow">if</span> (diff &lt; deltaT)
00861         <span class="keywordflow">return</span> 0;
00862 
00863     <span class="keywordflow">return</span> 1;
00864 }
00865 
00870 <span class="keywordtype">int</span>
<a name="l00871" id="l00871"></a><a class="code" href="group__util.html#ga21">00871</a> <a class="code" href=
"group__util.html#ga21">uatime_ready</a>(marker_t pm, <span class="keywordtype">unsigned</span> <span class=
"keywordtype">int</span> deltaT)
00872 {
00873     marker_t        now;
00874     u_long          diff;
00875     <span class="keywordflow">if</span> (!pm)
00876         <span class="keywordflow">return</span> 0;
00877 
00878     now = <a class="code" href="group__util.html#ga15">atime_newMarker</a>();
00879 
00880     diff = <a class="code" href="group__util.html#ga18">uatime_diff</a>(pm, now);
00881     free(now);
00882     <span class="keywordflow">if</span> (diff &lt; deltaT)
00883         <span class="keywordflow">return</span> 0;
00884 
00885     <span class="keywordflow">return</span> 1;
00886 }
00887 
00888 
00889         <span class="comment">/*</span>
00890 <span class="comment">         * Time-related utility functions</span>
00891 <span class="comment">         */</span>
00892 
00896 <span class="keywordtype">int</span>
<a name="l00897" id="l00897"></a><a class="code" href="group__util.html#ga22">00897</a> <a class="code" href=
"group__util.html#ga22">marker_tticks</a>(marker_t pm)
00898 {
00899     <span class="keywordtype">int</span>             res;
00900     marker_t        now = <a class="code" href="group__util.html#ga15">atime_newMarker</a>();
00901 
00902     res = <a class="code" href="group__util.html#ga17">atime_diff</a>(pm, now);
00903     free(now);
00904     <span class="keywordflow">return</span> res / 10;            <span class=
"comment">/* atime_diff works in msec, not csec */</span>
00905 }
00906 
00907 <span class="keywordtype">int</span>
00908 timeval_tticks(<span class="keyword">struct</span> timeval *tv)
00909 {
00910     <span class="keywordflow">return</span> <a class="code" href="group__util.html#ga22">marker_tticks</a>((marker_t) tv);
00911 }
00912 
<a name="l00925" id="l00925"></a><a class="code" href="group__util.html#ga24">00925</a> <span class=
"keywordtype">char</span> *<a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *name)
00926 {
00927 <span class="preprocessor">#if !defined (WIN32) &amp;&amp; !defined (cygwin)</span>
00928   <span class="keywordflow">return</span> (getenv(name));
00929 <span class="preprocessor">#else</span>
00930   <span class="keywordtype">char</span> *temp = NULL;  
00931   HKEY hKey;
00932   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * key_value = NULL;
00933   DWORD key_value_size = 0;
00934   DWORD key_value_type = 0;
00935   DWORD getenv_worked = 0;
00936 
00937   DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"netsnmp_getenv called with name: %s\n"</span>,name));
00938 
00939   <span class="keywordflow">if</span> (!(name))
00940     <span class="keywordflow">return</span> NULL;
00941   
00942   <span class="comment">/* Try environment variable first */</span> 
00943   temp = getenv(name);
00944   <span class="keywordflow">if</span> (temp) {
00945     getenv_worked = 1;
00946     DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"netsnmp_getenv will return from ENV: %s\n"</span>,temp));
00947   }
00948   
00949   <span class="comment">/* Next try HKCU */</span>
00950   <span class="keywordflow">if</span> (temp == NULL)
00951   {
00952     <span class="keywordflow">if</span> (RegOpenKeyExA(
00953           HKEY_CURRENT_USER, 
00954           <span class="stringliteral">"SOFTWARE\\Net-SNMP"</span>, 
00955           0, 
00956           KEY_QUERY_VALUE, 
00957           &amp;hKey) == ERROR_SUCCESS) {   
00958       
00959       <span class="keywordflow">if</span> (RegQueryValueExA(
00960             hKey, 
00961             name, 
00962             NULL, 
00963             &amp;key_value_type, 
00964             NULL,               <span class="comment">/* Just get the size */</span>
00965             &amp;key_value_size) == ERROR_SUCCESS) {
00966 
00967         <span class="keywordflow">if</span> (key_value)
00968           <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(key_value);
00969 
00970         <span class="comment">/* Allocate memory needed +1 to allow RegQueryValueExA to NULL terminate the</span>
00971 <span class="comment">         * string data in registry is missing one (which is unlikely).</span>
00972 <span class="comment">         */</span>
00973         key_value = (<span class="keywordtype">char</span> *) malloc((<span class="keyword">sizeof</span>(<span class=
"keywordtype">char</span>) * key_value_size)+<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00974         
00975         <span class="keywordflow">if</span> (RegQueryValueExA(
00976               hKey, 
00977               name, 
00978               NULL, 
00979               &amp;key_value_type, 
00980               key_value, 
00981               &amp;key_value_size) == ERROR_SUCCESS) {
00982         }
00983         temp = key_value;
00984       }
00985       RegCloseKey(hKey);
00986       <span class="keywordflow">if</span> (temp)
00987         DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"netsnmp_getenv will return from HKCU: %s\n"</span>,temp));
00988     }
00989   }
00990 
00991   <span class="comment">/* Next try HKLM */</span>
00992   <span class="keywordflow">if</span> (temp == NULL)
00993   {
00994     <span class="keywordflow">if</span> (RegOpenKeyExA(
00995           HKEY_LOCAL_MACHINE, 
00996           <span class="stringliteral">"SOFTWARE\\Net-SNMP"</span>, 
00997           0, 
00998           KEY_QUERY_VALUE, 
00999           &amp;hKey) == ERROR_SUCCESS) {   
01000       
01001       <span class="keywordflow">if</span> (RegQueryValueExA(
01002             hKey, 
01003             name, 
01004             NULL, 
01005             &amp;key_value_type, 
01006             NULL,               <span class="comment">/* Just get the size */</span>
01007             &amp;key_value_size) == ERROR_SUCCESS) {
01008 
01009         <span class="keywordflow">if</span> (key_value)
01010           <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(key_value);
01011 
01012         <span class="comment">/* Allocate memory needed +1 to allow RegQueryValueExA to NULL terminate the</span>
01013 <span class="comment">         * string data in registry is missing one (which is unlikely).</span>
01014 <span class="comment">         */</span>
01015         key_value = (<span class="keywordtype">char</span> *) malloc((<span class="keyword">sizeof</span>(<span class=
"keywordtype">char</span>) * key_value_size)+<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
01016         
01017         <span class="keywordflow">if</span> (RegQueryValueExA(
01018               hKey, 
01019               name, 
01020               NULL, 
01021               &amp;key_value_type, 
01022               key_value, 
01023               &amp;key_value_size) == ERROR_SUCCESS) {
01024         }
01025         temp = key_value;
01026 
01027       }
01028       RegCloseKey(hKey);
01029       <span class="keywordflow">if</span> (temp)
01030         DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"netsnmp_getenv will return from HKLM: %s\n"</span>,temp));
01031     }
01032   }
01033   
01034   <span class="keywordflow">if</span> (temp &amp;&amp; !getenv_worked) {
01035     setenv(name, temp, 1);
01036     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(temp);
01037   }
01038 
01039   DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"netsnmp_getenv returning: %s\n"</span>,getenv(name)));
01040 
01041   <span class="keywordflow">return</span>(getenv(name));
01042 <span class="preprocessor">#endif</span>
01043 }
01044 
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small>Generated on Fri Dec 30 13:47:51 2005 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

