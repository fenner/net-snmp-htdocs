<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000000.html">include</a>&nbsp;/&nbsp;<a class="el" href=
    "dir_000001.html">net-snmp</a>&nbsp;/&nbsp;<a class="el" href="dir_000006.html">library</a>
  </div>

  <h1>parse.h</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="preprocessor">#ifndef PARSE_H</span>
00002 <span class="preprocessor">#define PARSE_H</span>
00003 
00004 <span class="preprocessor">#ifdef __cplusplus</span>
00005 <span class="keyword">extern</span>          <span class="stringliteral">"C"</span> {
00006 <span class="preprocessor">#endif</span>
00007     <span class="comment">/*</span>
00008 <span class="comment">     * parse.h</span>
00009 <span class="comment">     */</span>
00010 <span class="comment">/***********************************************************</span>
00011 <span class="comment">        Copyright 1989 by Carnegie Mellon University</span>
00012 
00013 <span class="comment">                      All Rights Reserved</span>
00014 
00015 <span class="comment">Permission to use, copy, modify, and distribute this software and its</span>
00016 <span class="comment">documentation for any purpose and without fee is hereby granted,</span>
00017 <span class="comment">provided that the above copyright notice appear in all copies and that</span>
00018 <span class="comment">both that copyright notice and this permission notice appear in</span>
00019 <span class="comment">supporting documentation, and that the name of CMU not be</span>
00020 <span class="comment">used in advertising or publicity pertaining to distribution of the</span>
00021 <span class="comment">software without specific, written prior permission.</span>
00022 
00023 <span class="comment">CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING</span>
00024 <span class="comment">ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL</span>
00025 <span class="comment">CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR</span>
00026 <span class="comment">ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</span>
00027 <span class="comment">WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,</span>
00028 <span class="comment">ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS</span>
00029 <span class="comment">SOFTWARE.</span>
00030 <span class="comment">******************************************************************/</span>
00031 
00032 <span class="preprocessor">#define MAXLABEL        64      </span><span class=
"comment">/* maximum characters in a label */</span>
00033 <span class="preprocessor">#define MAXTOKEN        128     </span><span class=
"comment">/* maximum characters in a token */</span>
00034 <span class="preprocessor">#define MAXQUOTESTR     4096    </span><span class=
"comment">/* maximum characters in a quoted string */</span>
00035 
00036     <span class="keyword">struct </span><a class="code" href="structvariable__list.html">variable_list</a>;
00037 
00038     <span class="comment">/*</span>
00039 <span class="comment">     * A linked list of tag-value pairs for enumerated integers.</span>
00040 <span class="comment">     */</span>
00041     <span class="keyword">struct </span>enum_list {
00042         <span class="keyword">struct </span>enum_list *next;
00043         <span class="keywordtype">int</span>             value;
00044         <span class="keywordtype">char</span>           *label;
00045     };
00046 
00047     <span class="comment">/*</span>
00048 <span class="comment">     * A linked list of ranges</span>
00049 <span class="comment">     */</span>
00050     <span class="keyword">struct </span>range_list {
00051         <span class="keyword">struct </span>range_list *next;
00052         <span class="keywordtype">int</span>             low, high;
00053     };
00054 
00055     <span class="comment">/*</span>
00056 <span class="comment">     * A linked list of indexes</span>
00057 <span class="comment">     */</span>
00058     <span class="keyword">struct </span>index_list {
00059         <span class="keyword">struct </span>index_list *next;
00060         <span class="keywordtype">char</span>           *ilabel;
00061         <span class="keywordtype">char</span>            isimplied;
00062     };
00063 
00064     <span class="comment">/*</span>
00065 <span class="comment">     * A linked list of varbinds</span>
00066 <span class="comment">     */</span>
00067     <span class="keyword">struct </span>varbind_list {
00068         <span class="keyword">struct </span>varbind_list *next;
00069         <span class="keywordtype">char</span>           *vblabel;
00070     };
00071 
00072     <span class="comment">/*</span>
00073 <span class="comment">     * A linked list of nodes.</span>
00074 <span class="comment">     */</span>
00075     <span class="keyword">struct </span>node {
00076         <span class="keyword">struct </span>node    *next;
00077         <span class="keywordtype">char</span>           *label;  <span class=
"comment">/* This node's (unique) textual name */</span>
00078         u_long          subid;  <span class="comment">/* This node's integer subidentifier */</span>
00079         <span class="keywordtype">int</span>             modid;  <span class=
"comment">/* The module containing this node */</span>
00080         <span class="keywordtype">char</span>           *parent; <span class=
"comment">/* The parent's textual name */</span>
00081         <span class="keywordtype">int</span>             tc_index;       <span class=
"comment">/* index into tclist (-1 if NA) */</span>
00082         <span class="keywordtype">int</span>             type;   <span class=
"comment">/* The type of object this represents */</span>
00083         <span class="keywordtype">int</span>             access;
00084         <span class="keywordtype">int</span>             status;
00085         <span class="keyword">struct </span>enum_list *enums;        <span class=
"comment">/* (optional) list of enumerated integers */</span>
00086         <span class="keyword">struct </span>range_list *ranges;
00087         <span class="keyword">struct </span>index_list *indexes;
00088         <span class="keywordtype">char</span>           *augments;
00089         <span class="keyword">struct </span>varbind_list *varbinds;
00090         <span class="keywordtype">char</span>           *hint;
00091         <span class="keywordtype">char</span>           *units;
00092         <span class="keywordtype">char</span>           *description;    <span class=
"comment">/* description (a quoted string) */</span>
00093         <span class="keywordtype">char</span>           *reference;    <span class=
"comment">/* references (a quoted string) */</span>
00094         <span class="keywordtype">char</span>           *defaultValue;
00095         <span class="keywordtype">char</span>           *filename;
00096         <span class="keywordtype">int</span>             lineno;
00097     };
00098 
00099     <span class="comment">/*</span>
00100 <span class="comment">     * A tree in the format of the tree structure of the MIB.</span>
00101 <span class="comment">     */</span>
00102     <span class="keyword">struct </span>tree {
00103         <span class="keyword">struct </span>tree    *child_list;     <span class=
"comment">/* list of children of this node */</span>
00104         <span class="keyword">struct </span>tree    *next_peer;      <span class=
"comment">/* Next node in list of peers */</span>
00105         <span class="keyword">struct </span>tree    *next;   <span class=
"comment">/* Next node in hashed list of names */</span>
00106         <span class="keyword">struct </span>tree    *parent;
00107         <span class="keywordtype">char</span>           *label;  <span class=
"comment">/* This node's textual name */</span>
00108         u_long          subid;  <span class="comment">/* This node's integer subidentifier */</span>
00109         <span class="keywordtype">int</span>             modid;  <span class=
"comment">/* The module containing this node */</span>
00110         <span class="keywordtype">int</span>             number_modules;
00111         <span class="keywordtype">int</span>            *module_list;    <span class=
"comment">/* To handle multiple modules */</span>
00112         <span class="keywordtype">int</span>             tc_index;       <span class=
"comment">/* index into tclist (-1 if NA) */</span>
00113         <span class="keywordtype">int</span>             type;   <span class="comment">/* This node's object type */</span>
00114         <span class="keywordtype">int</span>             access; <span class="comment">/* This nodes access */</span>
00115         <span class="keywordtype">int</span>             status; <span class="comment">/* This nodes status */</span>
00116         <span class="keyword">struct </span>enum_list *enums;        <span class=
"comment">/* (optional) list of enumerated integers */</span>
00117         <span class="keyword">struct </span>range_list *ranges;
00118         <span class="keyword">struct </span>index_list *indexes;
00119         <span class="keywordtype">char</span>           *augments;
00120         <span class="keyword">struct </span>varbind_list *varbinds;
00121         <span class="keywordtype">char</span>           *hint;
00122         <span class="keywordtype">char</span>           *units;
00123         int             (*printomat) (u_char **, size_t *, size_t *, int,
00124                                       <span class="keyword">const</span> <a class="code" href=
"structvariable__list.html">netsnmp_variable_list</a> *,
00125                                       <span class="keyword">const</span> <span class=
"keyword">struct </span>enum_list *, <span class="keyword">const</span> <span class="keywordtype">char</span> *,
00126                                       <span class="keyword">const</span> <span class="keywordtype">char</span> *);
00127         void            (*printer) (<span class="keywordtype">char</span> *, <span class=
"keyword">const</span> netsnmp_variable_list *, <span class="keyword">const</span> <span class=
"keyword">struct </span>enum_list *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *);   <span class="comment">/* Value printing function */</span>
00128         <span class="keywordtype">char</span>           *description;    <span class=
"comment">/* description (a quoted string) */</span>
00129         <span class="keywordtype">char</span>           *reference;    <span class=
"comment">/* references (a quoted string) */</span>
00130         <span class="keywordtype">int</span>             reported;       <span class=
"comment">/* 1=report started in print_subtree... */</span>
00131         <span class="keywordtype">char</span>           *defaultValue;
00132     };
00133 
00134     <span class="comment">/*</span>
00135 <span class="comment">     * Information held about each MIB module</span>
00136 <span class="comment">     */</span>
00137     <span class="keyword">struct </span>module_import {
00138         <span class="keywordtype">char</span>           *label;  <span class=
"comment">/* The descriptor being imported */</span>
00139         <span class="keywordtype">int</span>             modid;  <span class=
"comment">/* The module imported from */</span>
00140     };
00141 
00142     <span class="keyword">struct </span>module {
00143         <span class="keywordtype">char</span>           *name;   <span class="comment">/* This module's name */</span>
00144         <span class="keywordtype">char</span>           *file;   <span class=
"comment">/* The file containing the module */</span>
00145         <span class="keyword">struct </span>module_import *imports;  <span class=
"comment">/* List of descriptors being imported */</span>
00146         <span class="keywordtype">int</span>             no_imports;     <span class=
"comment">/* The number of such import descriptors */</span>
00147         <span class="comment">/*</span>
00148 <span class="comment">         * -1 implies the module hasn't been read in yet </span>
00149 <span class="comment">         */</span>
00150         <span class="keywordtype">int</span>             modid;  <span class=
"comment">/* The index number of this module */</span>
00151         <span class="keyword">struct </span>module  *next;   <span class="comment">/* Linked list pointer */</span>
00152     };
00153 
00154     <span class="keyword">struct </span>module_compatability {
00155         <span class="keyword">const</span> <span class="keywordtype">char</span>     *old_module;
00156         <span class="keyword">const</span> <span class="keywordtype">char</span>     *new_module;
00157         <span class="keyword">const</span> <span class="keywordtype">char</span>     *tag;    <span class=
"comment">/* NULL implies unconditional replacement,</span>
00158 <span class="comment">                                 * otherwise node identifier or prefix */</span>
00159         size_t          tag_len;        <span class="comment">/* 0 implies exact match (or unconditional) */</span>
00160         <span class="keyword">struct </span>module_compatability *next;      <span class="comment">/* linked list */</span>
00161     };
00162 
00163 
00164     <span class="comment">/*</span>
00165 <span class="comment">     * non-aggregate types for tree end nodes </span>
00166 <span class="comment">     */</span>
00167 <span class="preprocessor">#define TYPE_OTHER          0</span>
00168 <span class="preprocessor">#define TYPE_OBJID          1</span>
00169 <span class="preprocessor">#define TYPE_OCTETSTR       2</span>
00170 <span class="preprocessor">#define TYPE_INTEGER        3</span>
00171 <span class="preprocessor">#define TYPE_NETADDR        4</span>
00172 <span class="preprocessor">#define TYPE_IPADDR         5</span>
00173 <span class="preprocessor">#define TYPE_COUNTER        6</span>
00174 <span class="preprocessor">#define TYPE_GAUGE          7</span>
00175 <span class="preprocessor">#define TYPE_TIMETICKS      8</span>
00176 <span class="preprocessor">#define TYPE_OPAQUE         9</span>
00177 <span class="preprocessor">#define TYPE_NULL           10</span>
00178 <span class="preprocessor">#define TYPE_COUNTER64      11</span>
00179 <span class="preprocessor">#define TYPE_BITSTRING      12</span>
00180 <span class="preprocessor">#define TYPE_NSAPADDRESS    13</span>
00181 <span class="preprocessor">#define TYPE_UINTEGER       14</span>
00182 <span class="preprocessor">#define TYPE_UNSIGNED32     15</span>
00183 <span class="preprocessor">#define TYPE_INTEGER32      16</span>
00184 
00185 <span class="preprocessor">#define TYPE_SIMPLE_LAST    16</span>
00186 
00187 <span class="preprocessor">#define TYPE_TRAPTYPE       20</span>
00188 <span class="preprocessor">#define TYPE_NOTIFTYPE      21</span>
00189 <span class="preprocessor">#define TYPE_OBJGROUP       22</span>
00190 <span class="preprocessor">#define TYPE_NOTIFGROUP     23</span>
00191 <span class="preprocessor">#define TYPE_MODID          24</span>
00192 <span class="preprocessor">#define TYPE_AGENTCAP       25</span>
00193 <span class="preprocessor">#define TYPE_MODCOMP        26</span>
00194 
00195 <span class="preprocessor">#define MIB_ACCESS_READONLY    18</span>
00196 <span class="preprocessor">#define MIB_ACCESS_READWRITE   19</span>
00197 <span class="preprocessor">#define MIB_ACCESS_WRITEONLY   20</span>
00198 <span class="preprocessor">#define MIB_ACCESS_NOACCESS    21</span>
00199 <span class="preprocessor">#define MIB_ACCESS_NOTIFY      67</span>
00200 <span class="preprocessor">#define MIB_ACCESS_CREATE      48</span>
00201 
00202 <span class="preprocessor">#define MIB_STATUS_MANDATORY   23</span>
00203 <span class="preprocessor">#define MIB_STATUS_OPTIONAL    24</span>
00204 <span class="preprocessor">#define MIB_STATUS_OBSOLETE    25</span>
00205 <span class="preprocessor">#define MIB_STATUS_DEPRECATED  39</span>
00206 <span class="preprocessor">#define MIB_STATUS_CURRENT     57</span>
00207 
00208 <span class="preprocessor">#define ANON    "anonymous#"</span>
00209 <span class="preprocessor">#define ANON_LEN  strlen(ANON)</span>
00210 
00211     <span class="keyword">struct </span>tree    *read_module(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *);
00212     <span class="keyword">struct </span>tree    *read_mib(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *);
00213     <span class="keyword">struct </span>tree    *read_all_mibs(<span class="keywordtype">void</span>);
00214     <span class="keywordtype">int</span>             unload_module(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *name);
00215     <span class="keywordtype">void</span>            unload_all_mibs(<span class="keywordtype">void</span>);
00216     <span class="keywordtype">void</span>            init_mib_internals(<span class="keywordtype">void</span>);
00217     <span class="keywordtype">int</span>             add_mibfile(<span class="keyword">const</span> <span class=
"keywordtype">char</span>*, <span class="keyword">const</span> <span class="keywordtype">char</span>*, FILE *);
00218     <span class="keywordtype">int</span>             add_mibdir(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *);
00219     <span class="keywordtype">void</span>            add_module_replacement(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *,
00220                                            <span class="keyword">const</span> <span class=
"keywordtype">char</span> *, <span class="keywordtype">int</span>);
00221     <span class="keywordtype">int</span>             which_module(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *);
00222     <span class="keywordtype">char</span>           *module_name(<span class="keywordtype">int</span>, <span class=
"keywordtype">char</span> *);
00223     <span class="keywordtype">void</span>            print_subtree(FILE *, <span class=
"keyword">struct</span> tree *, <span class="keywordtype">int</span>);
00224     <span class="keywordtype">void</span>            print_ascii_dump_tree(FILE *, <span class=
"keyword">struct</span> tree *, <span class="keywordtype">int</span>);
00225     <span class="keyword">struct </span>tree    *find_tree_node(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *, <span class="keywordtype">int</span>);
00226     <span class="keyword">const</span> <span class="keywordtype">char</span>     *get_tc_descriptor(<span class=
"keywordtype">int</span>);
00227     <span class="keyword">const</span> <span class="keywordtype">char</span>     *get_tc_description(<span class=
"keywordtype">int</span>);
00228     <span class="keyword">struct </span>tree    *find_best_tree_node(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *, <span class="keyword">struct</span> tree *,
00229                                         u_int *);
00230     <span class="comment">/*</span>
00231 <span class="comment">     * backwards compatability </span>
00232 <span class="comment">     */</span>
00233     <span class="keyword">struct </span>tree    *find_node(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *, <span class="keyword">struct</span> tree *);
00234     <span class="keyword">struct </span>tree    *find_node2(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *); 
00235     <span class="keyword">struct </span>module  *find_module(<span class="keywordtype">int</span>);
00236     <span class="keywordtype">void</span>            adopt_orphans(<span class="keywordtype">void</span>);
00237     <span class="keywordtype">char</span>           *snmp_mib_toggle_options(<span class=
"keywordtype">char</span> *options);
00238     <span class="keywordtype">void</span>            snmp_mib_toggle_options_usage(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *lead,
00239                                                   FILE * outf);
00240     <span class="keywordtype">void</span>            <a class="code" href=
"group__mib__utilities.html#ga58">print_mib</a>(FILE *);
00241     <span class="keywordtype">void</span>            print_mib_tree(FILE *, <span class=
"keyword">struct</span> tree *, <span class="keywordtype">int</span>);
00242     <span class="keywordtype">int</span>             get_mib_parse_error_count(<span class="keywordtype">void</span>);
00243     <span class="keywordtype">int</span>             snmp_get_token(FILE * fp, <span class=
"keywordtype">char</span> *token, <span class="keywordtype">int</span> maxtlen);
00244     <span class="keyword">struct </span>tree    *find_best_tree_node(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *name,
00245                                         <span class="keyword">struct</span> tree *tree_top,
00246                                         u_int * match);
00247 
00248 <span class="preprocessor">#ifdef __cplusplus</span>
00249 }
00250 <span class="preprocessor">#endif</span>
00251 <span class="preprocessor">#endif                          </span><span class="comment">/* PARSE_H */</span>
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small><!--#include virtual="/sfbutton.html" --><br />
    Generated on Thu Nov 25 17:51:39 2004 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

