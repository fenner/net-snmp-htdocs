<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>snmpTCPIPv6Domain.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00002 
00003 <span class="preprocessor">#ifdef SNMP_TRANSPORT_TCPIPV6_DOMAIN</span>
00004 
00005 <span class="comment">/*</span>
00006 <span class="comment"> * hack-o-matic for Cygwin to use winsock2</span>
00007 <span class="comment">*/</span>
00008 <span class="preprocessor">#if defined(cygwin)</span>
00009 <span class="preprocessor">#undef HAVE_UNISTD_H</span>
00010 <span class="preprocessor">#undef HAVE_NETINET_IN_H</span>
00011 <span class="preprocessor">#undef HAVE_ARPA_INET_H</span>
00012 <span class="preprocessor">#undef HAVE_NET_IF_H</span>
00013 <span class="preprocessor">#undef HAVE_NETDB_H</span>
00014 <span class="preprocessor">#undef HAVE_SYS_PARAM_H</span>
00015 <span class="preprocessor">#undef HAVE_SYS_SELECT_H</span>
00016 <span class="preprocessor">#undef HAVE_SYS_SOCKET_H</span>
00017 <span class="preprocessor">#undef HAVE_IN_ADDR_T</span>
00018 <span class="preprocessor">#endif</span>
00019 
00020 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00021 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00022 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00023 
00024 <span class="preprocessor">#if HAVE_STRING_H</span>
00025 <span class="preprocessor">#include &lt;string.h&gt;</span>
00026 <span class="preprocessor">#else</span>
00027 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00028 <span class="preprocessor">#endif</span>
00029 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00030 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00031 <span class="preprocessor">#endif</span>
00032 <span class="preprocessor">#if HAVE_UNISTD_H</span>
00033 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00034 <span class="preprocessor">#endif</span>
00035 <span class="preprocessor">#if HAVE_SYS_SOCKET_H</span>
00036 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00037 <span class="preprocessor">#endif</span>
00038 
00039 <span class="preprocessor">#if defined(HAVE_WINSOCK_H) || defined(cygwin)</span>
00040     <span class="comment">/*</span>
00041 <span class="comment">     * Windows IPv6 support is part of WinSock2 only</span>
00042 <span class="comment">     */</span>
00043 <span class="preprocessor">#include &lt;winsock2.h&gt;</span>
00044 <span class="preprocessor">#include &lt;ws2tcpip.h&gt;</span>
00045 
00046 <span class="keyword">extern</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *inet_ntop(<span class="keywordtype">int</span>, <span class="keyword">const</span> <span class=
"keywordtype">void</span>*, <span class="keywordtype">char</span>*, size_t);
00047 
00048 <span class="preprocessor">#endif</span>
00049 
00050 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00051 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00052 <span class="preprocessor">#endif</span>
00053 <span class="preprocessor">#if HAVE_ARPA_INET_H</span>
00054 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
00055 <span class="preprocessor">#endif</span>
00056 <span class="preprocessor">#if HAVE_NETDB_H</span>
00057 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00058 <span class="preprocessor">#endif</span>
00059 <span class="preprocessor">#if HAVE_FCNTL_H</span>
00060 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00061 <span class="preprocessor">#endif</span>
00062 
00063 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00064 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00065 <span class="preprocessor">#endif</span>
00066 
00067 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00068 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00069 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00070 
00071 <span class="preprocessor">#include &lt;net-snmp/library/snmp_transport.h&gt;</span>
00072 <span class="preprocessor">#include &lt;net-snmp/library/snmpUDPDomain.h&gt;</span>
00073 <span class="preprocessor">#include &lt;net-snmp/library/snmpUDPIPv6Domain.h&gt;</span>
00074 <span class="preprocessor">#include &lt;net-snmp/library/snmpTCPIPv6Domain.h&gt;</span>
00075 
00076 oid netsnmp_TCPIPv6Domain[] = { TRANSPORT_DOMAIN_TCP_IPV6 };
00077 <span class="keyword">static</span> netsnmp_tdomain tcp6Domain;
00078 
00079 <span class="comment">/*</span>
00080 <span class="comment"> * Return a string representing the address in data, or else the "far end"</span>
00081 <span class="comment"> * address if data is NULL.  </span>
00082 <span class="comment"> */</span>
00083 
00084 <span class="keyword">static</span> <span class="keywordtype">char</span> *
00085 netsnmp_tcp6_fmtaddr(netsnmp_transport *t, <span class="keywordtype">void</span> *data, <span class=
"keywordtype">int</span> len)
00086 {
00087     <span class="keyword">struct </span>sockaddr_in6 *to = NULL;
00088 
00089     DEBUGMSGTL((<span class="stringliteral">"netsnmp_tcp6"</span>, <span class=
"stringliteral">"fmtaddr: t = %p, data = %p, len = %d\n"</span>, t,
00090                 data, len));
00091     <span class="keywordflow">if</span> (data != NULL &amp;&amp; len == <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_in6)) {
00092         to = (<span class="keyword">struct </span>sockaddr_in6 *) data;
00093     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL) {
00094         to = (<span class="keyword">struct </span>sockaddr_in6 *) t-&gt;data;
00095     }
00096     <span class="keywordflow">if</span> (to == NULL) {
00097         <span class="keywordflow">return</span> strdup(<span class="stringliteral">"TCP/IPv6: unknown"</span>);
00098     } <span class="keywordflow">else</span> {
00099         <span class="keywordtype">char</span> addr[INET6_ADDRSTRLEN];
00100         <span class="keywordtype">char</span> tmp[INET6_ADDRSTRLEN + 8];
00101 
00102         sprintf(tmp, <span class="stringliteral">"TCP/IPv6: [%s]:%hd"</span>,
00103                 inet_ntop(AF_INET6, (<span class="keywordtype">void</span> *) &amp;(to-&gt;sin6_addr), addr,
00104                           INET6_ADDRSTRLEN), ntohs(to-&gt;sin6_port));
00105         <span class="keywordflow">return</span> strdup(tmp);
00106     }
00107 }
00108 
00109 <span class="comment">/*</span>
00110 <span class="comment"> * You can write something into opaque that will subsequently get passed back </span>
00111 <span class="comment"> * to your send function if you like.  For instance, you might want to</span>
00112 <span class="comment"> * remember where a PDU came from, so that you can send a reply there...  </span>
00113 <span class="comment"> */</span>
00114 
00115 <span class="keyword">static</span> <span class="keywordtype">int</span>
00116 netsnmp_tcp6_recv(netsnmp_transport *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
00117                   <span class="keywordtype">void</span> **opaque, <span class="keywordtype">int</span> *olength)
00118 {
00119     <span class="keywordtype">int</span> rc = -1;
00120 
00121     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00122         <span class="keywordflow">while</span> (rc &lt; 0) {
00123             rc = recv(t-&gt;sock, buf, size, 0);
00124             <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
00125                 DEBUGMSGTL((<span class="stringliteral">"netsnmp_tcp6"</span>, <span class=
"stringliteral">"recv fd %d err %d (\"%s\")\n"</span>,
00126                             t-&gt;sock, errno, strerror(errno)));
00127                 <span class="keywordflow">return</span> -1;
00128             }
00129         }
00130         DEBUGMSGTL((<span class="stringliteral">"netsnmp_tcp6"</span>, <span class=
"stringliteral">"recv fd %d got %d bytes\n"</span>, t-&gt;sock, rc));
00131     } <span class="keywordflow">else</span> {
00132         <span class="keywordflow">return</span> -1;
00133     }
00134 
00135     <span class="keywordflow">if</span> (opaque != NULL &amp;&amp; olength != NULL) {
00136         <span class="keywordflow">if</span> (t-&gt;data_length &gt; 0) {
00137             <span class="keywordflow">if</span> ((*opaque = malloc(t-&gt;data_length)) != NULL) {
00138                 memcpy(*opaque, t-&gt;data, t-&gt;data_length);
00139                 *olength = t-&gt;data_length;
00140             } <span class="keywordflow">else</span> {
00141                 *olength = 0;
00142             }
00143         } <span class="keywordflow">else</span> {
00144             *opaque = NULL;
00145             *olength = 0;
00146         }
00147     }
00148 
00149     <span class="keywordflow">return</span> rc;
00150 }
00151 
00152 <span class="keyword">static</span> <span class="keywordtype">int</span>
00153 netsnmp_tcp6_send(netsnmp_transport *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
00154                   <span class="keywordtype">void</span> **opaque, <span class="keywordtype">int</span> *olength)
00155 {
00156     <span class="keywordtype">int</span> rc = -1;
00157 
00158     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00159         <span class="keywordflow">while</span> (rc &lt; 0) {
00160             rc = send(t-&gt;sock, buf, size, 0);
00161             <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
00162                 <span class="keywordflow">break</span>;
00163             }
00164         }
00165     }
00166     <span class="keywordflow">return</span> rc;
00167 }
00168 
00169 <span class="keyword">static</span> <span class="keywordtype">int</span>
00170 netsnmp_tcp6_close(netsnmp_transport *t)
00171 {
00172     <span class="keywordtype">int</span> rc = -1;
00173     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00174         DEBUGMSGTL((<span class="stringliteral">"netsnmp_tcp6"</span>, <span class=
"stringliteral">"close fd %d\n"</span>, t-&gt;sock));
00175 <span class="preprocessor">#ifndef HAVE_CLOSESOCKET</span>
00176         rc = close(t-&gt;sock);
00177 <span class="preprocessor">#else</span>
00178         rc = closesocket(t-&gt;sock);
00179 <span class="preprocessor">#endif</span>
00180         t-&gt;sock = -1;
00181     }
00182     <span class="keywordflow">return</span> rc;
00183 }
00184 
00185 <span class="keyword">static</span> <span class="keywordtype">int</span>
00186 netsnmp_tcp6_accept(netsnmp_transport *t)
00187 {
00188     <span class="keyword">struct </span>sockaddr_in6 *farend = NULL;
00189     <span class="keywordtype">int</span>             newsock = -1, sockflags = 0;
00190     socklen_t       farendlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in6);
00191     <span class="keywordtype">char</span>           *str = NULL;
00192 
00193     farend = (<span class="keyword">struct </span>sockaddr_in6 *) malloc(<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_in6));
00194 
00195     <span class="keywordflow">if</span> (farend == NULL) {
00196         <span class="comment">/*</span>
00197 <span class="comment">         * Indicate that the acceptance of this socket failed.  </span>
00198 <span class="comment">         */</span>
00199         DEBUGMSGTL((<span class="stringliteral">"netsnmp_tcp6"</span>, <span class=
"stringliteral">"accept: malloc failed\n"</span>));
00200         <span class="keywordflow">return</span> -1;
00201     }
00202 
00203     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00204         newsock = accept(t-&gt;sock, (<span class="keyword">struct</span> sockaddr *) farend, &amp;farendlen);
00205 
00206         <span class="keywordflow">if</span> (newsock &lt; 0) {
00207             DEBUGMSGTL((<span class="stringliteral">"netsnmp_tcp6"</span>,<span class=
"stringliteral">"accept failed rc %d errno %d \"%s\"\n"</span>,
00208                         newsock, errno, strerror(errno)));
00209             free(farend);
00210             <span class="keywordflow">return</span> newsock;
00211         }
00212 
00213         <span class="keywordflow">if</span> (t-&gt;data != NULL) {
00214             free(t-&gt;data);
00215         }
00216 
00217         t-&gt;data = farend;
00218         t-&gt;data_length = farendlen;
00219         str = netsnmp_tcp6_fmtaddr(NULL, farend, farendlen);
00220         DEBUGMSGTL((<span class="stringliteral">"netsnmp_tcp6"</span>, <span class=
"stringliteral">"accept succeeded (from %s)\n"</span>, str));
00221         free(str);
00222 
00223         <span class="comment">/*</span>
00224 <span class="comment">         * Try to make the new socket blocking.  </span>
00225 <span class="comment">         */</span>
00226 
00227 <span class="preprocessor">#ifdef WIN32</span>
00228         ioctlsocket(newsock, FIONBIO, &amp;sockflags);
00229 <span class="preprocessor">#else</span>
00230         <span class="keywordflow">if</span> ((sockflags = fcntl(newsock, F_GETFL, 0)) &gt;= 0) {
00231             fcntl(newsock, F_SETFL, (sockflags &amp; ~O_NONBLOCK));
00232         } <span class="keywordflow">else</span> {
00233             DEBUGMSGTL((<span class="stringliteral">"netsnmp_tcp6"</span>, <span class=
"stringliteral">"accept: couldn't f_getfl of fd %d\n"</span>,
00234                         newsock));
00235         }
00236 <span class="preprocessor">#endif</span>
00237 
00238         <span class="comment">/*</span>
00239 <span class="comment">         * Allow user to override the send and receive buffers. Default is</span>
00240 <span class="comment">         * to use os default.  Don't worry too much about errors --</span>
00241 <span class="comment">         * just plough on regardless.  </span>
00242 <span class="comment">         */</span>
00243         netsnmp_sock_buffer_set(newsock, SO_SNDBUF, 1, 0);
00244         netsnmp_sock_buffer_set(newsock, SO_RCVBUF, 1, 0);
00245 
00246         <span class="keywordflow">return</span> newsock;
00247     } <span class="keywordflow">else</span> {
00248         free(farend);
00249         <span class="keywordflow">return</span> -1;
00250     }
00251 }
00252 
00253 
00254 
00255 <span class="comment">/*</span>
00256 <span class="comment"> * Open a TCP/IPv6-based transport for SNMP.  Local is TRUE if addr is the</span>
00257 <span class="comment"> * local address to bind to (i.e. this is a server-type session); otherwise</span>
00258 <span class="comment"> * addr is the remote address to send things to.  </span>
00259 <span class="comment"> */</span>
00260 
00261 netsnmp_transport *
00262 netsnmp_tcp6_transport(<span class="keyword">struct</span> sockaddr_in6 *addr, <span class="keywordtype">int</span> local)
00263 {
00264     netsnmp_transport *t = NULL;
00265     <span class="keywordtype">int</span>             rc = 0;
00266     <span class="keywordtype">char</span>           *str = NULL;
00267 
00268     <span class="keywordflow">if</span> (addr == NULL || addr-&gt;sin6_family != AF_INET6) {
00269         <span class="keywordflow">return</span> NULL;
00270     }
00271 
00272     t = (netsnmp_transport *) malloc(<span class="keyword">sizeof</span>(netsnmp_transport));
00273     <span class="keywordflow">if</span> (t == NULL) {
00274         <span class="keywordflow">return</span> NULL;
00275     }
00276     memset(t, 0, <span class="keyword">sizeof</span>(netsnmp_transport));
00277 
00278     str = netsnmp_tcp6_fmtaddr(NULL, (<span class="keywordtype">void</span> *)addr,
00279                                   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6));
00280     DEBUGMSGTL((<span class="stringliteral">"netsnmp_tcp6"</span>, <span class=
"stringliteral">"open %s %s\n"</span>, local ? <span class="stringliteral">"local"</span> : <span class=
"stringliteral">"remote"</span>,
00281                 str));
00282     free(str);
00283 
00284     memset(t, 0, <span class="keyword">sizeof</span>(netsnmp_transport));
00285 
00286     t-&gt;data = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6));
00287     <span class="keywordflow">if</span> (t-&gt;data == NULL) {
00288         netsnmp_transport_free(t);
00289         <span class="keywordflow">return</span> NULL;
00290     }
00291     t-&gt;data_length = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in6);
00292     memcpy(t-&gt;data, addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6));
00293 
00294     t-&gt;domain = netsnmp_TCPIPv6Domain;
00295     t-&gt;domain_length = <span class="keyword">sizeof</span>(netsnmp_TCPIPv6Domain) / <span class=
"keyword">sizeof</span>(oid);
00296 
00297     t-&gt;sock = socket(PF_INET6, SOCK_STREAM, 0);
00298     <span class="keywordflow">if</span> (t-&gt;sock &lt; 0) {
00299         netsnmp_transport_free(t);
00300         <span class="keywordflow">return</span> NULL;
00301     }
00302 
00303     t-&gt;flags = NETSNMP_TRANSPORT_FLAG_STREAM;
00304 
00305     <span class="keywordflow">if</span> (local) {
00306         <span class="keywordtype">int</span> sockflags = 0, opt = 1;
00307 
00308         <span class="comment">/*</span>
00309 <span class="comment">         * This session is inteneded as a server, so we must bind on to the</span>
00310 <span class="comment">         * given IP address, which may include an interface address, or could</span>
00311 <span class="comment">         * be INADDR_ANY, but certainly includes a port number.</span>
00312 <span class="comment">         */</span>
00313 
00314 <span class="preprocessor">#ifdef IPV6_V6ONLY</span>
00315         <span class="comment">/* Try to restrict PF_INET6 socket to IPv6 communications only. */</span>
00316         {
00317           <span class="keywordtype">int</span> one=1;
00318           <span class="keywordflow">if</span> (setsockopt(t-&gt;sock, IPPROTO_IPV6, IPV6_V6ONLY, (<span class=
"keywordtype">char</span> *)&amp;one, <span class="keyword">sizeof</span>(one)) != 0) {
00319             DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6"</span>, <span class=
"stringliteral">"couldn't set IPV6_V6ONLY to %d bytes: %s\n"</span>, one, strerror(errno)));
00320           } 
00321         }
00322 <span class="preprocessor">#endif</span>
00323 
00324         t-&gt;flags |= NETSNMP_TRANSPORT_FLAG_LISTEN;
00325         t-&gt;local = malloc(18);
00326         <span class="keywordflow">if</span> (t-&gt;local == NULL) {
00327             netsnmp_tcp6_close(t);
00328             netsnmp_transport_free(t);
00329             <span class="keywordflow">return</span> NULL;
00330         }
00331         memcpy(t-&gt;local, addr-&gt;sin6_addr.s6_addr, 16);
00332         t-&gt;local[16] = (addr-&gt;sin6_port &amp; 0xff00) &gt;&gt; 8;
00333         t-&gt;local[17] = (addr-&gt;sin6_port &amp; 0x00ff) &gt;&gt; 0;
00334         t-&gt;local_length = 18;
00335 
00336         <span class="comment">/*</span>
00337 <span class="comment">         * We should set SO_REUSEADDR too.  </span>
00338 <span class="comment">         */</span>
00339 
00340         setsockopt(t-&gt;sock, SOL_SOCKET, SO_REUSEADDR, (<span class="keywordtype">void</span> *)&amp;opt, <span class=
"keyword">sizeof</span>(opt));
00341 
00342         rc = bind(t-&gt;sock, (<span class="keyword">struct</span> sockaddr *) addr,
00343                   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6));
00344         <span class="keywordflow">if</span> (rc != 0) {
00345             netsnmp_tcp6_close(t);
00346             netsnmp_transport_free(t);
00347             <span class="keywordflow">return</span> NULL;
00348         }
00349 
00350         <span class="comment">/*</span>
00351 <span class="comment">         * Since we are going to be letting select() tell us when connections</span>
00352 <span class="comment">         * are ready to be accept()ed, we need to make the socket n0n-blocking</span>
00353 <span class="comment">         * to avoid the race condition described in W. R. Stevens, ``Unix</span>
00354 <span class="comment">         * Network Programming Volume I Second Edition'', pp. 422--4, which</span>
00355 <span class="comment">         * could otherwise wedge the agent.</span>
00356 <span class="comment">         */</span>
00357 
00358 <span class="preprocessor">#ifdef WIN32</span>
00359         opt = 1;
00360         ioctlsocket(t-&gt;sock, FIONBIO, &amp;opt);
00361 <span class="preprocessor">#else</span>
00362         sockflags = fcntl(t-&gt;sock, F_GETFL, 0);
00363         fcntl(t-&gt;sock, F_SETFL, sockflags | O_NONBLOCK);
00364 <span class="preprocessor">#endif</span>
00365 
00366         <span class="comment">/*</span>
00367 <span class="comment">         * Now sit here and wait for connections to arrive.  </span>
00368 <span class="comment">         */</span>
00369 
00370         rc = listen(t-&gt;sock, NETSNMP_STREAM_QUEUE_LEN);
00371         <span class="keywordflow">if</span> (rc != 0) {
00372             netsnmp_tcp6_close(t);
00373             netsnmp_transport_free(t);
00374             <span class="keywordflow">return</span> NULL;
00375         }
00376         
00377         <span class="comment">/*</span>
00378 <span class="comment">         * no buffer size on listen socket - doesn't make sense</span>
00379 <span class="comment">         */</span>
00380 
00381     } <span class="keywordflow">else</span> {
00382         t-&gt;remote = malloc(18);
00383         <span class="keywordflow">if</span> (t-&gt;remote == NULL) {
00384             netsnmp_tcp6_close(t);
00385             netsnmp_transport_free(t);
00386             <span class="keywordflow">return</span> NULL;
00387         }
00388         memcpy(t-&gt;remote, addr-&gt;sin6_addr.s6_addr, 16);
00389         t-&gt;remote[16] = (addr-&gt;sin6_port &amp; 0xff00) &gt;&gt; 8;
00390         t-&gt;remote[17] = (addr-&gt;sin6_port &amp; 0x00ff) &gt;&gt; 0;
00391         t-&gt;remote_length = 18;
00392 
00393         <span class="comment">/*</span>
00394 <span class="comment">         * This is a client-type session, so attempt to connect to the far</span>
00395 <span class="comment">         * end.  We don't go non-blocking here because it's not obvious what</span>
00396 <span class="comment">         * you'd then do if you tried to do snmp_sends before the connection</span>
00397 <span class="comment">         * had completed.  So this can block.</span>
00398 <span class="comment">         */</span>
00399 
00400         rc = connect(t-&gt;sock, (<span class="keyword">struct</span> sockaddr *) addr,
00401                      <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6));
00402 
00403         DEBUGMSGTL((<span class="stringliteral">"netsnmp_tcp6"</span>, <span class=
"stringliteral">"connect returns %d\n"</span>, rc));
00404 
00405         <span class="keywordflow">if</span> (rc &lt; 0) {
00406             netsnmp_tcp6_close(t);
00407             netsnmp_transport_free(t);
00408             <span class="keywordflow">return</span> NULL;
00409         }
00410 
00411         <span class="comment">/*</span>
00412 <span class="comment">         * Allow user to override the send and receive buffers. Default is</span>
00413 <span class="comment">         * to use os default.  Don't worry too much about errors --</span>
00414 <span class="comment">         * just plough on regardless.  </span>
00415 <span class="comment">         */</span>
00416         netsnmp_sock_buffer_set(t-&gt;sock, SO_SNDBUF, local, 0);
00417         netsnmp_sock_buffer_set(t-&gt;sock, SO_RCVBUF, local, 0);
00418     }
00419 
00420     <span class="comment">/*</span>
00421 <span class="comment">     * Message size is not limited by this transport (hence msgMaxSize</span>
00422 <span class="comment">     * is equal to the maximum legal size of an SNMP message).  </span>
00423 <span class="comment">     */</span>
00424 
00425     t-&gt;msgMaxSize = 0x7fffffff;
00426     t-&gt;f_recv     = netsnmp_tcp6_recv;
00427     t-&gt;f_send     = netsnmp_tcp6_send;
00428     t-&gt;f_close    = netsnmp_tcp6_close;
00429     t-&gt;f_accept   = netsnmp_tcp6_accept;
00430     t-&gt;f_fmtaddr  = netsnmp_tcp6_fmtaddr;
00431 
00432     <span class="keywordflow">return</span> t;
00433 }
00434 
00435 
00436 
00437 netsnmp_transport *
00438 netsnmp_tcp6_create_tstring(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class=
"keywordtype">int</span> local)
00439 {
00440     <span class="keyword">struct </span>sockaddr_in6 addr;
00441 
00442     <span class="keywordflow">if</span> (netsnmp_sockaddr_in6(&amp;addr, str, 0)) {
00443         <span class="keywordflow">return</span> netsnmp_tcp6_transport(&amp;addr, local);
00444     } <span class="keywordflow">else</span> {
00445         <span class="keywordflow">return</span> NULL;
00446     }
00447 }
00448 
00449 
00450 <span class="comment">/*</span>
00451 <span class="comment"> * See:</span>
00452 <span class="comment"> * </span>
00453 <span class="comment"> * http://www.ietf.org/internet-drafts/draft-ietf-ops-taddress-mib-01.txt</span>
00454 <span class="comment"> * </span>
00455 <span class="comment"> * (or newer equivalent) for details of the TC which we are using for</span>
00456 <span class="comment"> * the mapping here.  </span>
00457 <span class="comment"> */</span>
00458 
00459 netsnmp_transport *
00460 netsnmp_tcp6_create_ostring(<span class="keyword">const</span> u_char * o, size_t o_len, <span class=
"keywordtype">int</span> local)
00461 {
00462     <span class="keyword">struct </span>sockaddr_in6 addr;
00463 
00464     <span class="keywordflow">if</span> (o_len == 18) {
00465         memset((u_char *) &amp; addr, 0, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_in6));
00466         addr.sin6_family = AF_INET6;
00467         memcpy((u_char *) &amp; (addr.sin6_addr.s6_addr), o, 16);
00468         addr.sin6_port = (o[16] &lt;&lt; 8) + o[17];
00469         <span class="keywordflow">return</span> netsnmp_tcp6_transport(&amp;addr, local);
00470     }
00471     <span class="keywordflow">return</span> NULL;
00472 }
00473 
00474 
00475 <span class="keywordtype">void</span>
00476 netsnmp_tcp6_ctor(<span class="keywordtype">void</span>)
00477 {
00478     tcp6Domain.name = netsnmp_TCPIPv6Domain;
00479     tcp6Domain.name_length = <span class="keyword">sizeof</span>(netsnmp_TCPIPv6Domain) / <span class=
"keyword">sizeof</span>(oid);
00480     tcp6Domain.f_create_from_tstring = netsnmp_tcp6_create_tstring;
00481     tcp6Domain.f_create_from_ostring = netsnmp_tcp6_create_ostring;
00482     tcp6Domain.prefix = calloc(4, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
00483     tcp6Domain.prefix[0] = <span class="stringliteral">"tcp6"</span>;
00484     tcp6Domain.prefix[1] = <span class="stringliteral">"tcpv6"</span>;
00485     tcp6Domain.prefix[2] = <span class="stringliteral">"tcpipv6"</span>;
00486 
00487     netsnmp_tdomain_register(&amp;tcp6Domain);
00488 }
00489 
00490 <span class="preprocessor">#endif </span><span class="comment">/* SNMP_TRANSPORT_TCPIPV6_DOMAIN */</span>
00491 
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small>Generated on Fri Dec 30 13:47:49 2005 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

