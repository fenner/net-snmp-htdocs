<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>net-snmp: table_iterator.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">net-snmp&#160;<span id="projectnumber">5.7</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">table_iterator.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * table_iterator.c </span>
<a name="l00003"></a>00003 <span class="comment"> */</span>
<a name="l00004"></a>00004 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
<a name="l00005"></a>00005 <span class="comment"> * the Net-SNMP&#39;s COPYING file for more details and other copyrights</span>
<a name="l00006"></a>00006 <span class="comment"> * that may apply:</span>
<a name="l00007"></a>00007 <span class="comment"> */</span>
<a name="l00008"></a>00008 <span class="comment">/*</span>
<a name="l00009"></a>00009 <span class="comment"> * Portions of this file are copyrighted by:</span>
<a name="l00010"></a>00010 <span class="comment"> * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.</span>
<a name="l00011"></a>00011 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
<a name="l00012"></a>00012 <span class="comment"> * distributed with the Net-SNMP package.</span>
<a name="l00013"></a>00013 <span class="comment"> */</span>
<a name="l00014"></a>00014 
<a name="l00085"></a>00085 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="preprocessor">#include &lt;net-snmp/net-snmp-features.h&gt;</span>
<a name="l00088"></a>00088 <span class="preprocessor">#include &lt;net-snmp/net-snmp-includes.h&gt;</span>
<a name="l00089"></a>00089 <span class="preprocessor">#include &lt;net-snmp/agent/net-snmp-agent-includes.h&gt;</span>
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="preprocessor">#include &lt;<a class="code" href="table__iterator_8h.html">net-snmp/agent/table_iterator.h</a>&gt;</span>
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="preprocessor">#if HAVE_STRING_H</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00095"></a>00095 <span class="preprocessor">#else</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="preprocessor">#include &lt;strings.h&gt;</span>
<a name="l00097"></a>00097 <span class="preprocessor">#endif</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span>
<a name="l00099"></a>00099 <span class="preprocessor">#include &lt;net-snmp/agent/table.h&gt;</span>
<a name="l00100"></a>00100 <span class="preprocessor">#include &lt;net-snmp/agent/serialize.h&gt;</span>
<a name="l00101"></a>00101 <span class="preprocessor">#include &lt;net-snmp/agent/stash_cache.h&gt;</span>
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 netsnmp_feature_child_of(table_iterator_all, mib_helpers)
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 netsnmp_feature_child_of(table_iterator_insert_context, table_iterator_all)
<a name="l00106"></a>00106 netsnmp_feature_child_of(table_iterator_create_table, table_iterator_all)
<a name="l00107"></a>00107 netsnmp_feature_child_of(table_iterator_row_first, table_iterator_all)
<a name="l00108"></a>00108 netsnmp_feature_child_of(table_iterator_row_count, table_iterator_all)
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="preprocessor">#ifdef NETSNMP_FEATURE_REQUIRE_STASH_CACHE</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span>netsnmp_feature_require(data_list_get_list_node)
<a name="l00112"></a>00112 netsnmp_feature_require(oid_stash_add_data)
<a name="l00113"></a>00113 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_FEATURE_REQUIRE_STASH_CACHE */</span>
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 <span class="comment">/* ==================================</span>
<a name="l00116"></a>00116 <span class="comment"> *</span>
<a name="l00117"></a>00117 <span class="comment"> * Iterator API: Table maintenance</span>
<a name="l00118"></a>00118 <span class="comment"> *</span>
<a name="l00119"></a>00119 <span class="comment"> * ================================== */</span>
<a name="l00120"></a>00120 
<a name="l00121"></a>00121     <span class="comment">/*</span>
<a name="l00122"></a>00122 <span class="comment">     * Iterator-based tables are typically maintained by external</span>
<a name="l00123"></a>00123 <span class="comment">     *  code, and this helper is really only concerned with</span>
<a name="l00124"></a>00124 <span class="comment">     *  mapping between a walk through this local representation,</span>
<a name="l00125"></a>00125 <span class="comment">     *  and the requirements of SNMP table ordering.</span>
<a name="l00126"></a>00126 <span class="comment">     * However, there&#39;s a case to be made for considering the</span>
<a name="l00127"></a>00127 <span class="comment">     *  iterator info structure as encapsulating the table, so</span>
<a name="l00128"></a>00128 <span class="comment">     *  it&#39;s probably worth defining the table creation/deletion</span>
<a name="l00129"></a>00129 <span class="comment">     *  routines from the generic API.</span>
<a name="l00130"></a>00130 <span class="comment">     *</span>
<a name="l00131"></a>00131 <span class="comment">     * Time will show whether this is a sensible approach or not.</span>
<a name="l00132"></a>00132 <span class="comment">     */</span>
<a name="l00133"></a>00133 <span class="preprocessor">#ifndef NETSNMP_FEATURE_REMOVE_TABLE_ITERATOR_CREATE_TABLE</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span><a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *
<a name="l00135"></a>00135 netsnmp_iterator_create_table( Netsnmp_First_Data_Point *firstDP,
<a name="l00136"></a>00136                                Netsnmp_Next_Data_Point  *nextDP,
<a name="l00137"></a>00137                                Netsnmp_First_Data_Point *getidx,
<a name="l00138"></a>00138                                <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a>    *indexes)
<a name="l00139"></a>00139 {
<a name="l00140"></a>00140     <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo =
<a name="l00141"></a>00141         <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424" title="Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a>);
<a name="l00142"></a>00142 
<a name="l00143"></a>00143     <span class="keywordflow">if</span> ( !iinfo )
<a name="l00144"></a>00144         <span class="keywordflow">return</span> NULL;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146     <span class="keywordflow">if</span> ( indexes )
<a name="l00147"></a>00147         iinfo-&gt;indexes = snmp_clone_varbind(indexes);
<a name="l00148"></a>00148     iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a98224fb1d34bf8794bc2e45eab33ce56" title="Responsible for: returning the first set of &quot;index&quot; data, a loop-context pointer, and optionally a da...">get_first_data_point</a> = firstDP;
<a name="l00149"></a>00149     iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a9df181621eb551784037a5bfbea1e9a0" title="Given the previous loop context, this should return the next loop context, associated index set and o...">get_next_data_point</a>  = nextDP;
<a name="l00150"></a>00150     iinfo-&gt;get_row_indexes      = getidx;
<a name="l00151"></a>00151 
<a name="l00152"></a>00152     <span class="keywordflow">return</span> iinfo;
<a name="l00153"></a>00153 }
<a name="l00154"></a>00154 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_FEATURE_REMOVE_TABLE_ITERATOR_CREATE_TABLE */</span>
<a name="l00155"></a>00155 
<a name="l00157"></a>00157 <span class="keywordtype">void</span>
<a name="l00158"></a><a class="code" href="group__table__iterator.html#ga9eda4907c0d8aeb59d3e603f20cb05b4">00158</a> <a class="code" href="group__table__iterator.html#ga9eda4907c0d8aeb59d3e603f20cb05b4" title="Free the memory that was allocated for a table iterator.">netsnmp_iterator_delete_table</a>( <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo )
<a name="l00159"></a>00159 {
<a name="l00160"></a>00160     <span class="keywordflow">if</span> (!iinfo)
<a name="l00161"></a>00161         <span class="keywordflow">return</span>;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     <span class="keywordflow">if</span> (iinfo-&gt;indexes) {
<a name="l00164"></a>00164         snmp_free_varbind( iinfo-&gt;indexes );
<a name="l00165"></a>00165         iinfo-&gt;indexes = NULL;
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167     netsnmp_table_registration_info_free(iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a2322feee30ec894a07007d2fa43fc5f2" title="A pointer to the netsnmp_table_registration_info object this iterator is registered along with...">table_reginfo</a>);
<a name="l00168"></a>00168     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>( iinfo );
<a name="l00169"></a>00169 }
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     <span class="comment">/*</span>
<a name="l00172"></a>00172 <span class="comment">     * The rest of the table maintenance section of the</span>
<a name="l00173"></a>00173 <span class="comment">     *   generic table API is Not Applicable to this helper.</span>
<a name="l00174"></a>00174 <span class="comment">     *</span>
<a name="l00175"></a>00175 <span class="comment">     * The contents of a iterator-based table will be</span>
<a name="l00176"></a>00176 <span class="comment">     *  maintained by the table-specific module itself.</span>
<a name="l00177"></a>00177 <span class="comment">     */</span>
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="comment">/* ==================================</span>
<a name="l00180"></a>00180 <span class="comment"> *</span>
<a name="l00181"></a>00181 <span class="comment"> * Iterator API: MIB maintenance</span>
<a name="l00182"></a>00182 <span class="comment"> *</span>
<a name="l00183"></a>00183 <span class="comment"> * ================================== */</span>
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 <span class="keyword">static</span> <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *
<a name="l00186"></a>00186 netsnmp_iterator_ref(<a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo)
<a name="l00187"></a>00187 {
<a name="l00188"></a>00188     iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a634b671760f438c9b9ada0d23c0a77fb" title="Number of handlers that own this data structure.">refcnt</a>++;
<a name="l00189"></a>00189     <span class="keywordflow">return</span> iinfo;
<a name="l00190"></a>00190 }
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00193"></a>00193 netsnmp_iterator_deref(<a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo)
<a name="l00194"></a>00194 {
<a name="l00195"></a>00195     <span class="keywordflow">if</span> (--iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a634b671760f438c9b9ada0d23c0a77fb" title="Number of handlers that own this data structure.">refcnt</a> == 0)
<a name="l00196"></a>00196         <a class="code" href="group__table__iterator.html#ga9eda4907c0d8aeb59d3e603f20cb05b4" title="Free the memory that was allocated for a table iterator.">netsnmp_iterator_delete_table</a>(iinfo);
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="keywordtype">void</span> netsnmp_handler_owns_iterator_info(<a class="code" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler</a> *h)
<a name="l00200"></a>00200 {
<a name="l00201"></a>00201     netsnmp_assert(h);
<a name="l00202"></a>00202     netsnmp_assert(h-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#a74067d02cea4a059cd0fce7790b77b18" title="for handler&#39;s internal use">myvoid</a>);
<a name="l00203"></a>00203     ((<a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *)(h-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#a74067d02cea4a059cd0fce7790b77b18" title="for handler&#39;s internal use">myvoid</a>))-&gt;refcnt++;
<a name="l00204"></a>00204     h-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#a920cb70b2ae344b1c268a5f96f4b4e59" title="data clone hook for myvoid deep copy the myvoid member - default is to copy the pointer This method i...">data_clone</a> = (<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))netsnmp_iterator_ref;
<a name="l00205"></a>00205     h-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#ae007338d354e85a5d9bf6a918bd42469" title="data free hook for myvoid delete the myvoid member - default is to do nothing This method is only cal...">data_free</a>  = (void(*)(<span class="keywordtype">void</span> *))netsnmp_iterator_deref;
<a name="l00206"></a>00206 }
<a name="l00207"></a>00207 
<a name="l00216"></a>00216 <a class="code" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler</a> *
<a name="l00217"></a><a class="code" href="group__table__iterator.html#gac72db9799a31046c476f5d8638d689a3">00217</a> <a class="code" href="group__table__iterator.html#gac72db9799a31046c476f5d8638d689a3" title="Returns a netsnmp_mib_handler object for the table_iterator helper.">netsnmp_get_table_iterator_handler</a>(<a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo)
<a name="l00218"></a>00218 {
<a name="l00219"></a>00219     <a class="code" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler</a> *me;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221     <span class="keywordflow">if</span> (!iinfo)
<a name="l00222"></a>00222         <span class="keywordflow">return</span> NULL;
<a name="l00223"></a>00223 
<a name="l00224"></a>00224     me =
<a name="l00225"></a>00225         netsnmp_create_handler(TABLE_ITERATOR_NAME,
<a name="l00226"></a>00226                                netsnmp_table_iterator_helper_handler);
<a name="l00227"></a>00227 
<a name="l00228"></a>00228     <span class="keywordflow">if</span> (!me)
<a name="l00229"></a>00229         <span class="keywordflow">return</span> NULL;
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     me-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#a74067d02cea4a059cd0fce7790b77b18" title="for handler&#39;s internal use">myvoid</a> = iinfo;
<a name="l00232"></a>00232     <span class="keywordflow">if</span> (iinfo-&gt;flags &amp; NETSNMP_HANDLER_OWNS_IINFO)
<a name="l00233"></a>00233         netsnmp_handler_owns_iterator_info(me);
<a name="l00234"></a>00234     <span class="keywordflow">return</span> me;
<a name="l00235"></a>00235 }
<a name="l00236"></a>00236 
<a name="l00258"></a>00258 <span class="keywordtype">int</span>
<a name="l00259"></a><a class="code" href="group__table__iterator.html#ga3f10f7be6c67bed6f7284bdfe13c6a23">00259</a> <a class="code" href="group__table__iterator.html#ga3f10f7be6c67bed6f7284bdfe13c6a23" title="Creates and registers a table iterator helper handler calling netsnmp_create_handler with a handler n...">netsnmp_register_table_iterator</a>(<a class="code" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration</a> *reginfo,
<a name="l00260"></a>00260                                 <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo)
<a name="l00261"></a>00261 {
<a name="l00262"></a>00262 <span class="preprocessor">#ifndef NETSNMP_FEATURE_REMOVE_STASH_CACHE</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span>    reginfo-&gt;modes |= HANDLER_CAN_STASH;
<a name="l00264"></a>00264 <span class="preprocessor">#endif  </span><span class="comment">/* NETSNMP_FEATURE_REMOVE_STASH_CACHE */</span>
<a name="l00265"></a>00265     <a class="code" href="group__handler.html#ga6649d75b3eaf98d70704754d3d8235f3" title="Injects handler into the calling chain of handlers.">netsnmp_inject_handler</a>(reginfo,
<a name="l00266"></a>00266                            <a class="code" href="group__table__iterator.html#gac72db9799a31046c476f5d8638d689a3" title="Returns a netsnmp_mib_handler object for the table_iterator helper.">netsnmp_get_table_iterator_handler</a>(iinfo));
<a name="l00267"></a>00267     <span class="keywordflow">if</span> (!iinfo)
<a name="l00268"></a>00268         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l00269"></a>00269     <span class="keywordflow">if</span> (!iinfo-&gt;indexes &amp;&amp; iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a2322feee30ec894a07007d2fa43fc5f2" title="A pointer to the netsnmp_table_registration_info object this iterator is registered along with...">table_reginfo</a> &amp;&amp;
<a name="l00270"></a>00270                            iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a2322feee30ec894a07007d2fa43fc5f2" title="A pointer to the netsnmp_table_registration_info object this iterator is registered along with...">table_reginfo</a>-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a3045fe8e402e974d840af4084b88dc2a" title="list of varbinds with only &#39;type&#39; set">indexes</a> )
<a name="l00271"></a>00271         iinfo-&gt;indexes = snmp_clone_varbind( iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a2322feee30ec894a07007d2fa43fc5f2" title="A pointer to the netsnmp_table_registration_info object this iterator is registered along with...">table_reginfo</a>-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a3045fe8e402e974d840af4084b88dc2a" title="list of varbinds with only &#39;type&#39; set">indexes</a> );
<a name="l00272"></a>00272 
<a name="l00273"></a>00273     <span class="keywordflow">return</span> <a class="code" href="group__table.html#ga9940ed4fe4f46dc0212ddd46967c16f2" title="creates a table handler given the netsnmp_table_registration_info object, inserts it into the request...">netsnmp_register_table</a>(reginfo, iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a2322feee30ec894a07007d2fa43fc5f2" title="A pointer to the netsnmp_table_registration_info object this iterator is registered along with...">table_reginfo</a>);
<a name="l00274"></a>00274 }
<a name="l00275"></a>00275 
<a name="l00289"></a>00289 NETSNMP_INLINE <span class="keywordtype">void</span>    *
<a name="l00290"></a><a class="code" href="group__table__iterator.html#ga10027da7b08c561e38845bfc20659a41">00290</a> <a class="code" href="group__table__iterator.html#ga10027da7b08c561e38845bfc20659a41" title="extracts the table_iterator specific data from a request.">netsnmp_extract_iterator_context</a>(<a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *request)
<a name="l00291"></a>00291 {
<a name="l00292"></a>00292     <span class="keywordflow">return</span> <a class="code" href="group__handler.html#gac8ebe16c4ca9e9e8d06fadcaa2650079" title="Extracts data from a request.">netsnmp_request_get_list_data</a>(request, TABLE_ITERATOR_NAME);
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="preprocessor">#ifndef NETSNMP_FEATURE_REMOVE_TABLE_ITERATOR_INSERT_CONTEXT</span>
<a name="l00296"></a>00296 <span class="preprocessor"></span>
<a name="l00298"></a>00298 NETSNMP_INLINE <span class="keywordtype">void</span>
<a name="l00299"></a><a class="code" href="group__table__iterator.html#ga6a33283792ad8980ee20154b1993d09c">00299</a> <a class="code" href="group__table__iterator.html#ga6a33283792ad8980ee20154b1993d09c" title="inserts table_iterator specific data for a newly created row into a request">netsnmp_insert_iterator_context</a>(<a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *request, <span class="keywordtype">void</span> *data)
<a name="l00300"></a>00300 {
<a name="l00301"></a>00301     <a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a>       *req;
<a name="l00302"></a>00302     <a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *table_info = NULL;
<a name="l00303"></a>00303     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a>      *this_index = NULL;
<a name="l00304"></a>00304     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a>      *that_index = NULL;
<a name="l00305"></a>00305     oid      base_oid[] = {0, 0};       <span class="comment">/* Make sure index OIDs are legal! */</span>
<a name="l00306"></a>00306     oid      this_oid[MAX_OID_LEN];
<a name="l00307"></a>00307     oid      that_oid[MAX_OID_LEN];
<a name="l00308"></a>00308     <span class="keywordtype">size_t</span>   this_oid_len, that_oid_len;
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="keywordflow">if</span> (!request)
<a name="l00311"></a>00311         <span class="keywordflow">return</span>;
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     <span class="comment">/*</span>
<a name="l00314"></a>00314 <span class="comment">     * We&#39;ll add the new row information to any request</span>
<a name="l00315"></a>00315 <span class="comment">     * structure with the same index values as the request</span>
<a name="l00316"></a>00316 <span class="comment">     * passed in (which includes that one!).</span>
<a name="l00317"></a>00317 <span class="comment">     *</span>
<a name="l00318"></a>00318 <span class="comment">     * So construct an OID based on these index values.</span>
<a name="l00319"></a>00319 <span class="comment">     */</span>
<a name="l00320"></a>00320 
<a name="l00321"></a>00321     table_info = <a class="code" href="group__table.html#ga0f2aa788814b909e3e3003b63b1dbd3a" title="Extracts the processed table information from a given request.">netsnmp_extract_table_info</a>(request);
<a name="l00322"></a>00322     this_index = table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a>;
<a name="l00323"></a>00323     build_oid_noalloc(this_oid, MAX_OID_LEN, &amp;this_oid_len,
<a name="l00324"></a>00324                       base_oid, 2, this_index);
<a name="l00325"></a>00325 
<a name="l00326"></a>00326     <span class="comment">/*</span>
<a name="l00327"></a>00327 <span class="comment">     * We need to look through the whole of the request list</span>
<a name="l00328"></a>00328 <span class="comment">     * (as received by the current handler), as there&#39;s no</span>
<a name="l00329"></a>00329 <span class="comment">     * guarantee that this routine will be called by the first</span>
<a name="l00330"></a>00330 <span class="comment">     * varbind that refers to this row.</span>
<a name="l00331"></a>00331 <span class="comment">     *   In particular, a RowStatus controlled row creation</span>
<a name="l00332"></a>00332 <span class="comment">     * may easily occur later in the variable list.</span>
<a name="l00333"></a>00333 <span class="comment">     *</span>
<a name="l00334"></a>00334 <span class="comment">     * So first, we rewind to the head of the list....</span>
<a name="l00335"></a>00335 <span class="comment">     */</span>
<a name="l00336"></a>00336     <span class="keywordflow">for</span> (req=request; req-&gt;prev; req=req-&gt;prev)
<a name="l00337"></a>00337         ;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339     <span class="comment">/*</span>
<a name="l00340"></a>00340 <span class="comment">     * ... and then start looking for matching indexes</span>
<a name="l00341"></a>00341 <span class="comment">     * (by constructing OIDs from these index values)</span>
<a name="l00342"></a>00342 <span class="comment">     */</span>
<a name="l00343"></a>00343     <span class="keywordflow">for</span> (; req; req=req-&gt;next) {
<a name="l00344"></a>00344         table_info = <a class="code" href="group__table.html#ga0f2aa788814b909e3e3003b63b1dbd3a" title="Extracts the processed table information from a given request.">netsnmp_extract_table_info</a>(req);
<a name="l00345"></a>00345         that_index = table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a>;
<a name="l00346"></a>00346         build_oid_noalloc(that_oid, MAX_OID_LEN, &amp;that_oid_len,
<a name="l00347"></a>00347                           base_oid, 2, that_index);
<a name="l00348"></a>00348       
<a name="l00349"></a>00349         <span class="comment">/*</span>
<a name="l00350"></a>00350 <span class="comment">         * This request has the same index values,</span>
<a name="l00351"></a>00351 <span class="comment">         * so add the newly-created row information.</span>
<a name="l00352"></a>00352 <span class="comment">         */</span>
<a name="l00353"></a>00353         <span class="keywordflow">if</span> (<a class="code" href="group__library.html#gab5b48a42c19a801547e025ed40b4561e" title="lexicographical compare two object identifiers.">snmp_oid_compare</a>(this_oid, this_oid_len,
<a name="l00354"></a>00354                              that_oid, that_oid_len) == 0) {
<a name="l00355"></a>00355             <a class="code" href="group__handler.html#gacc092f27f7c4203fe20665c8341023c8" title="Adds data from node list to the request information structure.">netsnmp_request_add_list_data</a>(req,
<a name="l00356"></a>00356                 <a class="code" href="group__data__list.html#ga3dc286b678474c6adb610460ea71b03e" title="adds creates a data_list node given a name, data and a free function ptr.">netsnmp_create_data_list</a>(TABLE_ITERATOR_NAME, data, NULL));
<a name="l00357"></a>00357         }
<a name="l00358"></a>00358     }
<a name="l00359"></a>00359 }
<a name="l00360"></a>00360 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_FEATURE_REMOVE_TABLE_ITERATOR_INSERT_CONTEXT */</span>
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="preprocessor">#define TI_REQUEST_CACHE &quot;ti_cache&quot;</span>
<a name="l00363"></a>00363 <span class="preprocessor"></span>
<a name="l00364"></a><a class="code" href="structti__cache__info__s.html">00364</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structti__cache__info__s.html">ti_cache_info_s</a> {
<a name="l00365"></a>00365    oid best_match[MAX_OID_LEN];
<a name="l00366"></a>00366    <span class="keywordtype">size_t</span> best_match_len;
<a name="l00367"></a>00367    <span class="keywordtype">void</span> *data_context;
<a name="l00368"></a>00368    Netsnmp_Free_Data_Context *free_context;
<a name="l00369"></a>00369    <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo;
<a name="l00370"></a>00370    <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *results;
<a name="l00371"></a>00371 } <a class="code" href="structti__cache__info__s.html">ti_cache_info</a>;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00374"></a>00374 netsnmp_free_ti_cache(<span class="keywordtype">void</span> *it) {
<a name="l00375"></a>00375     <a class="code" href="structti__cache__info__s.html">ti_cache_info</a> *beer = (<a class="code" href="structti__cache__info__s.html">ti_cache_info</a>*)it;
<a name="l00376"></a>00376     <span class="keywordflow">if</span> (!it) <span class="keywordflow">return</span>;
<a name="l00377"></a>00377     <span class="keywordflow">if</span> (beer-&gt;data_context &amp;&amp; beer-&gt;free_context) {
<a name="l00378"></a>00378             (beer-&gt;free_context)(beer-&gt;data_context, beer-&gt;iinfo);
<a name="l00379"></a>00379     }
<a name="l00380"></a>00380     <span class="keywordflow">if</span> (beer-&gt;results) {
<a name="l00381"></a>00381         snmp_free_varbind(beer-&gt;results);
<a name="l00382"></a>00382     }
<a name="l00383"></a>00383     free(beer);
<a name="l00384"></a>00384 }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386 <span class="comment">/* caches information (in the request) we&#39;ll need at a later point in time */</span>
<a name="l00387"></a>00387 <span class="keyword">static</span> <a class="code" href="structti__cache__info__s.html">ti_cache_info</a> *
<a name="l00388"></a>00388 netsnmp_iterator_remember(<a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *request,
<a name="l00389"></a>00389                           oid *oid_to_save,
<a name="l00390"></a>00390                           <span class="keywordtype">size_t</span> oid_to_save_len,
<a name="l00391"></a>00391                           <span class="keywordtype">void</span> *callback_data_context,
<a name="l00392"></a>00392                           <span class="keywordtype">void</span> *callback_loop_context,
<a name="l00393"></a>00393                           <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo)
<a name="l00394"></a>00394 {
<a name="l00395"></a>00395     <a class="code" href="structti__cache__info__s.html">ti_cache_info</a> *ti_info;
<a name="l00396"></a>00396 
<a name="l00397"></a>00397     <span class="keywordflow">if</span> (!request || !oid_to_save || oid_to_save_len &gt; MAX_OID_LEN)
<a name="l00398"></a>00398         <span class="keywordflow">return</span> NULL;
<a name="l00399"></a>00399 
<a name="l00400"></a>00400     <span class="comment">/* extract existing cached state */</span>
<a name="l00401"></a>00401     ti_info = (<a class="code" href="structti__cache__info__s.html">ti_cache_info</a>*)<a class="code" href="group__handler.html#gac8ebe16c4ca9e9e8d06fadcaa2650079" title="Extracts data from a request.">netsnmp_request_get_list_data</a>(request, TI_REQUEST_CACHE);
<a name="l00402"></a>00402 
<a name="l00403"></a>00403     <span class="comment">/* no existing cached state.  make a new one. */</span>
<a name="l00404"></a>00404     <span class="keywordflow">if</span> (!ti_info) {
<a name="l00405"></a>00405         ti_info = <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424" title="Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href="structti__cache__info__s.html">ti_cache_info</a>);
<a name="l00406"></a>00406         <span class="keywordflow">if</span> (ti_info == NULL)
<a name="l00407"></a>00407             <span class="keywordflow">return</span> NULL;
<a name="l00408"></a>00408         <a class="code" href="group__handler.html#gacc092f27f7c4203fe20665c8341023c8" title="Adds data from node list to the request information structure.">netsnmp_request_add_list_data</a>(request,
<a name="l00409"></a>00409                                       <a class="code" href="group__data__list.html#ga3dc286b678474c6adb610460ea71b03e" title="adds creates a data_list node given a name, data and a free function ptr.">netsnmp_create_data_list</a>
<a name="l00410"></a>00410                                       (TI_REQUEST_CACHE,
<a name="l00411"></a>00411                                        ti_info,
<a name="l00412"></a>00412                                        netsnmp_free_ti_cache));
<a name="l00413"></a>00413     }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415     <span class="comment">/* free existing cache before replacing */</span>
<a name="l00416"></a>00416     <span class="keywordflow">if</span> (ti_info-&gt;data_context &amp;&amp; ti_info-&gt;free_context)
<a name="l00417"></a>00417         (ti_info-&gt;free_context)(ti_info-&gt;data_context, iinfo);
<a name="l00418"></a>00418 
<a name="l00419"></a>00419     <span class="comment">/* maybe generate it from the loop context? */</span>
<a name="l00420"></a>00420     <span class="keywordflow">if</span> (iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a17fbe4838bb67d1d1a7f6cfbdf6750ba" title="If a data context wasn&#39;t supplied by the get_first_data_point or get_next_data_point functions and th...">make_data_context</a> &amp;&amp; !callback_data_context) {
<a name="l00421"></a>00421         callback_data_context =
<a name="l00422"></a>00422             (iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a17fbe4838bb67d1d1a7f6cfbdf6750ba" title="If a data context wasn&#39;t supplied by the get_first_data_point or get_next_data_point functions and th...">make_data_context</a>)(callback_loop_context, iinfo);
<a name="l00423"></a>00423 
<a name="l00424"></a>00424     }
<a name="l00425"></a>00425 
<a name="l00426"></a>00426     <span class="comment">/* save data as requested */</span>
<a name="l00427"></a>00427     ti_info-&gt;data_context = callback_data_context;
<a name="l00428"></a>00428     ti_info-&gt;free_context = iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a21a0de492a8c6986be23bce6061c08a0" title="Frees a data context.">free_data_context</a>;
<a name="l00429"></a>00429     ti_info-&gt;best_match_len = oid_to_save_len;
<a name="l00430"></a>00430     ti_info-&gt;iinfo = iinfo;
<a name="l00431"></a>00431     <span class="keywordflow">if</span> (oid_to_save_len)
<a name="l00432"></a>00432         memcpy(ti_info-&gt;best_match, oid_to_save, oid_to_save_len * <span class="keyword">sizeof</span>(oid));
<a name="l00433"></a>00433 
<a name="l00434"></a>00434     <span class="keywordflow">return</span> ti_info;
<a name="l00435"></a>00435 }    
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="preprocessor">#define TABLE_ITERATOR_NOTAGAIN 255</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span><span class="comment">/* implements the table_iterator helper */</span>
<a name="l00439"></a>00439 <span class="keywordtype">int</span>
<a name="l00440"></a>00440 netsnmp_table_iterator_helper_handler(<a class="code" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler</a> *handler,
<a name="l00441"></a>00441                                       <a class="code" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration</a> *reginfo,
<a name="l00442"></a>00442                                       <a class="code" href="structnetsnmp__agent__request__info__s.html" title="The agent transaction request structure.">netsnmp_agent_request_info</a> *reqinfo,
<a name="l00443"></a>00443                                       <a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *requests)
<a name="l00444"></a>00444 {
<a name="l00445"></a>00445     <a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *tbl_info;
<a name="l00446"></a>00446     <a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *table_info = NULL;
<a name="l00447"></a>00447     oid             coloid[MAX_OID_LEN];
<a name="l00448"></a>00448     <span class="keywordtype">size_t</span>          coloid_len;
<a name="l00449"></a>00449     <span class="keywordtype">int</span>             ret = SNMP_ERR_NOERROR;
<a name="l00450"></a>00450     <span class="keyword">static</span> oid      myname[MAX_OID_LEN];
<a name="l00451"></a>00451     <span class="keywordtype">size_t</span>          myname_len;
<a name="l00452"></a>00452     <span class="keywordtype">int</span>             oldmode = 0;
<a name="l00453"></a>00453     <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo;
<a name="l00454"></a>00454     <span class="keywordtype">int</span> notdone;
<a name="l00455"></a>00455     <span class="keywordtype">int</span> hintok = 0;
<a name="l00456"></a>00456     <a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *request, *reqtmp = NULL;
<a name="l00457"></a>00457     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *index_search = NULL;
<a name="l00458"></a>00458     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *free_this_index_search = NULL;
<a name="l00459"></a>00459     <span class="keywordtype">void</span>           *callback_loop_context = NULL, *last_loop_context;
<a name="l00460"></a>00460     <span class="keywordtype">void</span>           *callback_data_context = NULL;
<a name="l00461"></a>00461     <a class="code" href="structti__cache__info__s.html">ti_cache_info</a>  *ti_info = NULL;
<a name="l00462"></a>00462     <span class="keywordtype">int</span>             request_count = 0;
<a name="l00463"></a>00463 <span class="preprocessor">#ifndef NETSNMP_FEATURE_REMOVE_STASH_CACHE</span>
<a name="l00464"></a>00464 <span class="preprocessor"></span>    <a class="code" href="structnetsnmp__oid__stash__node__s.html">netsnmp_oid_stash_node</a> **cinfo = NULL;
<a name="l00465"></a>00465     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *old_indexes = NULL, *vb;
<a name="l00466"></a>00466     <a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *table_reg_info = NULL;
<a name="l00467"></a>00467     <span class="keywordtype">int</span> i;
<a name="l00468"></a>00468     <a class="code" href="structnetsnmp__data__list__s.html" title="used to iterate through lists of data">netsnmp_data_list</a>    *ldata = NULL;
<a name="l00469"></a>00469 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_FEATURE_REMOVE_STASH_CACHE */</span>
<a name="l00470"></a>00470 
<a name="l00471"></a>00471     iinfo = (<a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *) handler-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#a74067d02cea4a059cd0fce7790b77b18" title="for handler&#39;s internal use">myvoid</a>;
<a name="l00472"></a>00472     if (!iinfo || !reginfo || !reqinfo)
<a name="l00473"></a>00473         <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475     tbl_info = iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a2322feee30ec894a07007d2fa43fc5f2" title="A pointer to the netsnmp_table_registration_info object this iterator is registered along with...">table_reginfo</a>;
<a name="l00476"></a>00476 
<a name="l00477"></a>00477     <span class="comment">/*</span>
<a name="l00478"></a>00478 <span class="comment">     * copy in the table registration oid for later use </span>
<a name="l00479"></a>00479 <span class="comment">     */</span>
<a name="l00480"></a>00480     coloid_len = reginfo-&gt;rootoid_len + 2;
<a name="l00481"></a>00481     memcpy(coloid, reginfo-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#a264722b6b9385237fbcb5f8bc144d470" title="where are we registered at?">rootoid</a>, reginfo-&gt;rootoid_len * <span class="keyword">sizeof</span>(oid));
<a name="l00482"></a>00482     coloid[reginfo-&gt;rootoid_len] = 1;   <span class="comment">/* table.entry node */</span>
<a name="l00483"></a>00483 
<a name="l00484"></a>00484     <span class="comment">/*</span>
<a name="l00485"></a>00485 <span class="comment">     * illegally got here if these functions aren&#39;t defined </span>
<a name="l00486"></a>00486 <span class="comment">     */</span>
<a name="l00487"></a>00487     <span class="keywordflow">if</span> (iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a98224fb1d34bf8794bc2e45eab33ce56" title="Responsible for: returning the first set of &quot;index&quot; data, a loop-context pointer, and optionally a da...">get_first_data_point</a> == NULL ||
<a name="l00488"></a>00488         iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a9df181621eb551784037a5bfbea1e9a0" title="Given the previous loop context, this should return the next loop context, associated index set and o...">get_next_data_point</a> == NULL) {
<a name="l00489"></a>00489         <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_ERR,
<a name="l00490"></a>00490                  <span class="stringliteral">&quot;table_iterator helper called without data accessor functions\n&quot;</span>);
<a name="l00491"></a>00491         <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l00492"></a>00492     }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494     <span class="comment">/* preliminary analysis */</span>
<a name="l00495"></a>00495     <span class="keywordflow">switch</span> (reqinfo-&gt;mode) {
<a name="l00496"></a>00496 <span class="preprocessor">#ifndef NETSNMP_FEATURE_REMOVE_STASH_CACHE</span>
<a name="l00497"></a>00497 <span class="preprocessor"></span>    <span class="keywordflow">case</span> MODE_GET_STASH:
<a name="l00498"></a>00498         cinfo = <a class="code" href="group__stash__cache.html#ga9c9dcbe0bb7fb4ba2623a27d943334db" title="extracts a pointer to the stash_cache info from the reqinfo structure.">netsnmp_extract_stash_cache</a>(reqinfo);
<a name="l00499"></a>00499         table_reg_info = <a class="code" href="group__table.html#gaf0f72a85bfca5e069971fa3869082267" title="extracts the registered netsnmp_table_registration_info object from a netsnmp_handler_registration ob...">netsnmp_find_table_registration_info</a>(reginfo);
<a name="l00500"></a>00500 
<a name="l00501"></a>00501         <span class="comment">/* XXX: move this malloc to stash_cache handler? */</span>
<a name="l00502"></a>00502         reqtmp = <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424" title="Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a>);
<a name="l00503"></a>00503         <span class="keywordflow">if</span> (reqtmp == NULL)
<a name="l00504"></a>00504             <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l00505"></a>00505         reqtmp-&gt;subtree = requests-&gt;subtree;
<a name="l00506"></a>00506         table_info = <a class="code" href="group__table.html#ga0f2aa788814b909e3e3003b63b1dbd3a" title="Extracts the processed table information from a given request.">netsnmp_extract_table_info</a>(requests);
<a name="l00507"></a>00507         <a class="code" href="group__handler.html#gacc092f27f7c4203fe20665c8341023c8" title="Adds data from node list to the request information structure.">netsnmp_request_add_list_data</a>(reqtmp,
<a name="l00508"></a>00508                                       <a class="code" href="group__data__list.html#ga3dc286b678474c6adb610460ea71b03e" title="adds creates a data_list node given a name, data and a free function ptr.">netsnmp_create_data_list</a>
<a name="l00509"></a>00509                                       (TABLE_HANDLER_NAME,
<a name="l00510"></a>00510                                        (<span class="keywordtype">void</span> *) table_info, NULL));
<a name="l00511"></a>00511 
<a name="l00512"></a>00512         <span class="comment">/* remember the indexes that were originally parsed. */</span>
<a name="l00513"></a>00513         old_indexes = table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a>;
<a name="l00514"></a>00514         <span class="keywordflow">break</span>;
<a name="l00515"></a>00515 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_FEATURE_REMOVE_STASH_CACHE */</span>
<a name="l00516"></a>00516 
<a name="l00517"></a>00517     <span class="keywordflow">case</span> MODE_GETNEXT:
<a name="l00518"></a>00518         <span class="keywordflow">for</span>(request = requests ; request; request = request-&gt;next) {
<a name="l00519"></a>00519             <span class="keywordflow">if</span> (request-&gt;processed)
<a name="l00520"></a>00520                 <span class="keywordflow">continue</span>;
<a name="l00521"></a>00521             table_info = <a class="code" href="group__table.html#ga0f2aa788814b909e3e3003b63b1dbd3a" title="Extracts the processed table information from a given request.">netsnmp_extract_table_info</a>(request);
<a name="l00522"></a>00522             <span class="keywordflow">if</span> (table_info == NULL) {
<a name="l00523"></a>00523                 <span class="comment">/*</span>
<a name="l00524"></a>00524 <span class="comment">                 * Cleanup </span>
<a name="l00525"></a>00525 <span class="comment">                 */</span>
<a name="l00526"></a>00526                 <span class="keywordflow">if</span> (free_this_index_search)
<a name="l00527"></a>00527                     snmp_free_varbind(free_this_index_search);
<a name="l00528"></a>00528                 <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l00529"></a>00529             }
<a name="l00530"></a>00530             <span class="keywordflow">if</span> (table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> &lt; tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#ae48fd51376f573a4c4e5aede809f7092" title="the minimum columns number.">min_column</a> - 1) {
<a name="l00531"></a>00531                 <span class="comment">/* XXX: optimize better than this */</span>
<a name="l00532"></a>00532                 <span class="comment">/* for now, just increase to colnum-1 */</span>
<a name="l00533"></a>00533                 <span class="comment">/* we need to jump to the lowest result of the min_column</span>
<a name="l00534"></a>00534 <span class="comment">                   and take it, comparing to nothing from the request */</span>
<a name="l00535"></a>00535                 table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> = tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#ae48fd51376f573a4c4e5aede809f7092" title="the minimum columns number.">min_column</a> - 1;
<a name="l00536"></a>00536             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> &gt; tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a4b7f37faafced959b943e974ba58e008" title="the maximum columns number">max_column</a>) {
<a name="l00537"></a>00537                 request-&gt;processed = TABLE_ITERATOR_NOTAGAIN;
<a name="l00538"></a>00538             }
<a name="l00539"></a>00539 
<a name="l00540"></a>00540             ti_info = (<a class="code" href="structti__cache__info__s.html">ti_cache_info</a>*)
<a name="l00541"></a>00541                 <a class="code" href="group__handler.html#gac8ebe16c4ca9e9e8d06fadcaa2650079" title="Extracts data from a request.">netsnmp_request_get_list_data</a>(request, TI_REQUEST_CACHE);
<a name="l00542"></a>00542             <span class="keywordflow">if</span> (!ti_info) {
<a name="l00543"></a>00543                 ti_info = <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424" title="Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href="structti__cache__info__s.html">ti_cache_info</a>);
<a name="l00544"></a>00544                 <span class="keywordflow">if</span> (ti_info == NULL) {
<a name="l00545"></a>00545                     <span class="comment">/*</span>
<a name="l00546"></a>00546 <span class="comment">                     * Cleanup </span>
<a name="l00547"></a>00547 <span class="comment">                     */</span>
<a name="l00548"></a>00548                     <span class="keywordflow">if</span> (free_this_index_search)
<a name="l00549"></a>00549                         snmp_free_varbind(free_this_index_search);
<a name="l00550"></a>00550                     <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l00551"></a>00551                 }
<a name="l00552"></a>00552                 <a class="code" href="group__handler.html#gacc092f27f7c4203fe20665c8341023c8" title="Adds data from node list to the request information structure.">netsnmp_request_add_list_data</a>(request,
<a name="l00553"></a>00553                                               <a class="code" href="group__data__list.html#ga3dc286b678474c6adb610460ea71b03e" title="adds creates a data_list node given a name, data and a free function ptr.">netsnmp_create_data_list</a>
<a name="l00554"></a>00554                                               (TI_REQUEST_CACHE,
<a name="l00555"></a>00555                                                ti_info,
<a name="l00556"></a>00556                                                netsnmp_free_ti_cache));
<a name="l00557"></a>00557             }
<a name="l00558"></a>00558 
<a name="l00559"></a>00559             <span class="comment">/* XXX: if no valid requests, don&#39;t even loop below */</span>
<a name="l00560"></a>00560         }
<a name="l00561"></a>00561         <span class="keywordflow">break</span>;
<a name="l00562"></a>00562     }
<a name="l00563"></a>00563 
<a name="l00564"></a>00564     <span class="comment">/*</span>
<a name="l00565"></a>00565 <span class="comment">     * collect all information for each needed row</span>
<a name="l00566"></a>00566 <span class="comment">     */</span>
<a name="l00567"></a>00567     <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_GET ||
<a name="l00568"></a>00568         reqinfo-&gt;mode == MODE_GETNEXT ||
<a name="l00569"></a>00569         reqinfo-&gt;mode == MODE_GET_STASH
<a name="l00570"></a>00570 #ifndef NETSNMP_NO_WRITE_SUPPORT
<a name="l00571"></a>00571         || reqinfo-&gt;mode == MODE_SET_RESERVE1
<a name="l00572"></a>00572 #endif <span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00573"></a>00573         ) {
<a name="l00574"></a>00574         <span class="comment">/*</span>
<a name="l00575"></a>00575 <span class="comment">         * Count the number of request in the list,</span>
<a name="l00576"></a>00576 <span class="comment">         *   so that we&#39;ll know when we&#39;re finished</span>
<a name="l00577"></a>00577 <span class="comment">         */</span>
<a name="l00578"></a>00578         <span class="keywordflow">for</span>(request = requests ; request; request = request-&gt;next)
<a name="l00579"></a>00579           <span class="keywordflow">if</span> (!request-&gt;processed)
<a name="l00580"></a>00580             request_count++;
<a name="l00581"></a>00581         notdone = 1;
<a name="l00582"></a>00582         hintok = 1;
<a name="l00583"></a>00583         <span class="keywordflow">while</span>(notdone) {
<a name="l00584"></a>00584             notdone = 0;
<a name="l00585"></a>00585 
<a name="l00586"></a>00586             <span class="comment">/* find first data point */</span>
<a name="l00587"></a>00587             <span class="keywordflow">if</span> (!index_search) {
<a name="l00588"></a>00588                 <span class="keywordflow">if</span> (free_this_index_search) {
<a name="l00589"></a>00589                     <span class="comment">/* previously done */</span>
<a name="l00590"></a>00590                     index_search = free_this_index_search;
<a name="l00591"></a>00591                 } <span class="keywordflow">else</span> {
<a name="l00592"></a>00592                     <span class="keywordflow">for</span>(request=requests ; request; request=request-&gt;next) {
<a name="l00593"></a>00593                         table_info = <a class="code" href="group__table.html#ga0f2aa788814b909e3e3003b63b1dbd3a" title="Extracts the processed table information from a given request.">netsnmp_extract_table_info</a>(request);
<a name="l00594"></a>00594                         <span class="keywordflow">if</span> (table_info)
<a name="l00595"></a>00595                             <span class="keywordflow">break</span>;
<a name="l00596"></a>00596                     }
<a name="l00597"></a>00597                     <span class="keywordflow">if</span> (!table_info) {
<a name="l00598"></a>00598                         <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_WARNING,
<a name="l00599"></a>00599                                  <span class="stringliteral">&quot;no valid requests for iterator table %s\n&quot;</span>,
<a name="l00600"></a>00600                                  reginfo-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#ab932303bcdd9ee47ad6cefd77d9a4123" title="for mrTable listings, and other uses">handlerName</a>);
<a name="l00601"></a>00601                         <a class="code" href="group__handler.html#ga14d1a9eeb19594f07d4cb70de8a89145" title="Free the extra data stored in a bunch of requests.">netsnmp_free_request_data_sets</a>(reqtmp);
<a name="l00602"></a>00602                         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(reqtmp);
<a name="l00603"></a>00603                         <span class="keywordflow">return</span> SNMP_ERR_NOERROR;
<a name="l00604"></a>00604                     }
<a name="l00605"></a>00605                     index_search = snmp_clone_varbind(table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a>);
<a name="l00606"></a>00606                     free_this_index_search = index_search;
<a name="l00607"></a>00607 
<a name="l00608"></a>00608                     <span class="comment">/* setup, malloc search data: */</span>
<a name="l00609"></a>00609                     <span class="keywordflow">if</span> (!index_search) {
<a name="l00610"></a>00610                         <span class="comment">/*</span>
<a name="l00611"></a>00611 <span class="comment">                         * hmmm....  invalid table? </span>
<a name="l00612"></a>00612 <span class="comment">                         */</span>
<a name="l00613"></a>00613                         <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_WARNING,
<a name="l00614"></a>00614                                  <span class="stringliteral">&quot;invalid index list or failed malloc for table %s\n&quot;</span>,
<a name="l00615"></a>00615                                  reginfo-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#ab932303bcdd9ee47ad6cefd77d9a4123" title="for mrTable listings, and other uses">handlerName</a>);
<a name="l00616"></a>00616                         <a class="code" href="group__handler.html#ga14d1a9eeb19594f07d4cb70de8a89145" title="Free the extra data stored in a bunch of requests.">netsnmp_free_request_data_sets</a>(reqtmp);
<a name="l00617"></a>00617                         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(reqtmp);
<a name="l00618"></a>00618                         <span class="keywordflow">return</span> SNMP_ERR_NOERROR;
<a name="l00619"></a>00619                     }
<a name="l00620"></a>00620                 }
<a name="l00621"></a>00621             }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623             <span class="comment">/* if sorted, pass in a hint */</span>
<a name="l00624"></a>00624             <span class="keywordflow">if</span> (hintok &amp;&amp; (iinfo-&gt;flags &amp; NETSNMP_ITERATOR_FLAG_SORTED)) {
<a name="l00625"></a>00625                 callback_loop_context = table_info;
<a name="l00626"></a>00626             }
<a name="l00627"></a>00627             index_search =
<a name="l00628"></a>00628                 (iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a98224fb1d34bf8794bc2e45eab33ce56" title="Responsible for: returning the first set of &quot;index&quot; data, a loop-context pointer, and optionally a da...">get_first_data_point</a>) (&amp;callback_loop_context,
<a name="l00629"></a>00629                                                &amp;callback_data_context,
<a name="l00630"></a>00630                                                index_search, iinfo);
<a name="l00631"></a>00631 
<a name="l00632"></a>00632             <span class="comment">/* loop over each data point */</span>
<a name="l00633"></a>00633             <span class="keywordflow">while</span>(index_search) {
<a name="l00634"></a>00634 
<a name="l00635"></a>00635                 <span class="comment">/* remember to free this later */</span>
<a name="l00636"></a>00636                 free_this_index_search = index_search;
<a name="l00637"></a>00637             
<a name="l00638"></a>00638                 <span class="comment">/* compare against each request*/</span>
<a name="l00639"></a>00639                 <span class="keywordflow">for</span>(request = requests ; request; request = request-&gt;next) {
<a name="l00640"></a>00640                     <span class="keywordflow">if</span> (request-&gt;processed)
<a name="l00641"></a>00641                         <span class="keywordflow">continue</span>;
<a name="l00642"></a>00642 
<a name="l00643"></a>00643                     <span class="comment">/* XXX: store in an array for faster retrieval */</span>
<a name="l00644"></a>00644                     table_info = <a class="code" href="group__table.html#ga0f2aa788814b909e3e3003b63b1dbd3a" title="Extracts the processed table information from a given request.">netsnmp_extract_table_info</a>(request);
<a name="l00645"></a>00645                     <span class="keywordflow">if</span> (table_info == NULL) {
<a name="l00646"></a>00646                         <span class="comment">/*</span>
<a name="l00647"></a>00647 <span class="comment">                         * Cleanup </span>
<a name="l00648"></a>00648 <span class="comment">                         */</span>
<a name="l00649"></a>00649                         <span class="keywordflow">if</span> (free_this_index_search)
<a name="l00650"></a>00650                             snmp_free_varbind(free_this_index_search);
<a name="l00651"></a>00651                         <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l00652"></a>00652                     }
<a name="l00653"></a>00653                     coloid[reginfo-&gt;rootoid_len + 1] = table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a>;
<a name="l00654"></a>00654 
<a name="l00655"></a>00655                     ti_info = (<a class="code" href="structti__cache__info__s.html">ti_cache_info</a>*)
<a name="l00656"></a>00656                         <a class="code" href="group__handler.html#gac8ebe16c4ca9e9e8d06fadcaa2650079" title="Extracts data from a request.">netsnmp_request_get_list_data</a>(request, TI_REQUEST_CACHE);
<a name="l00657"></a>00657 
<a name="l00658"></a>00658                     <span class="keywordflow">switch</span>(reqinfo-&gt;mode) {
<a name="l00659"></a>00659                     <span class="keywordflow">case</span> MODE_GET:
<a name="l00660"></a>00660 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l00661"></a>00661 <span class="preprocessor"></span>                    <span class="keywordflow">case</span> MODE_SET_RESERVE1:
<a name="l00662"></a>00662 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00663"></a>00663                         <span class="comment">/* looking for exact matches */</span>
<a name="l00664"></a>00664                         build_oid_noalloc(myname, MAX_OID_LEN, &amp;myname_len,
<a name="l00665"></a>00665                                           coloid, coloid_len, index_search);
<a name="l00666"></a>00666                         <span class="keywordflow">if</span> (<a class="code" href="group__library.html#gab5b48a42c19a801547e025ed40b4561e" title="lexicographical compare two object identifiers.">snmp_oid_compare</a>(myname, myname_len,
<a name="l00667"></a>00667                                              request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>,
<a name="l00668"></a>00668                                              request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a>) == 0) {
<a name="l00669"></a>00669                             <span class="comment">/* </span>
<a name="l00670"></a>00670 <span class="comment">                             * keep this</span>
<a name="l00671"></a>00671 <span class="comment">                             */</span>
<a name="l00672"></a>00672                             <span class="keywordflow">if</span> (netsnmp_iterator_remember(request,
<a name="l00673"></a>00673                                                           myname,
<a name="l00674"></a>00674                                                           myname_len,
<a name="l00675"></a>00675                                                           callback_data_context,
<a name="l00676"></a>00676                                                           callback_loop_context,
<a name="l00677"></a>00677                                                           iinfo) == NULL) {
<a name="l00678"></a>00678                                 <span class="comment">/*</span>
<a name="l00679"></a>00679 <span class="comment">                                 * Cleanup </span>
<a name="l00680"></a>00680 <span class="comment">                                 */</span>
<a name="l00681"></a>00681                                 <span class="keywordflow">if</span> (free_this_index_search)
<a name="l00682"></a>00682                                     snmp_free_varbind
<a name="l00683"></a>00683                                         (free_this_index_search);
<a name="l00684"></a>00684                                 <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l00685"></a>00685                             }
<a name="l00686"></a>00686                             request_count--;   <span class="comment">/* One less to look for */</span>
<a name="l00687"></a>00687                         } <span class="keywordflow">else</span> {
<a name="l00688"></a>00688                             <span class="keywordflow">if</span> (iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a21a0de492a8c6986be23bce6061c08a0" title="Frees a data context.">free_data_context</a> &amp;&amp; callback_data_context) {
<a name="l00689"></a>00689                                 (iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a21a0de492a8c6986be23bce6061c08a0" title="Frees a data context.">free_data_context</a>)(callback_data_context,
<a name="l00690"></a>00690                                                            iinfo);
<a name="l00691"></a>00691                             }
<a name="l00692"></a>00692                         }
<a name="l00693"></a>00693                         <span class="keywordflow">break</span>;
<a name="l00694"></a>00694 
<a name="l00695"></a>00695 <span class="preprocessor">#ifndef NETSNMP_FEATURE_REMOVE_STASH_CACHE</span>
<a name="l00696"></a>00696 <span class="preprocessor"></span>                    <span class="keywordflow">case</span> MODE_GET_STASH:
<a name="l00697"></a>00697                         <span class="comment">/* collect data for each column for every row */</span>
<a name="l00698"></a>00698                         build_oid_noalloc(myname, MAX_OID_LEN, &amp;myname_len,
<a name="l00699"></a>00699                                           coloid, coloid_len, index_search);
<a name="l00700"></a>00700                         reqinfo-&gt;mode = MODE_GET;
<a name="l00701"></a>00701                         <span class="keywordflow">if</span> (reqtmp)
<a name="l00702"></a>00702                             ldata =
<a name="l00703"></a>00703                                 <a class="code" href="group__data__list.html#ga4036a7e291b29389229a6054111b6414" title="returns a data_list node for a given name within a data_list">netsnmp_get_list_node</a>(reqtmp-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a6420dc3c100f91dc2c8bb6a383dbb4bd" title="can be used to pass information on a per-request basis from a helper to the later handlers...">parent_data</a>,
<a name="l00704"></a>00704                                                       TABLE_ITERATOR_NAME);
<a name="l00705"></a>00705                         <span class="keywordflow">if</span> (!ldata) {
<a name="l00706"></a>00706                             <a class="code" href="group__handler.html#gacc092f27f7c4203fe20665c8341023c8" title="Adds data from node list to the request information structure.">netsnmp_request_add_list_data</a>(reqtmp,
<a name="l00707"></a>00707                                                           <a class="code" href="group__data__list.html#ga3dc286b678474c6adb610460ea71b03e" title="adds creates a data_list node given a name, data and a free function ptr.">netsnmp_create_data_list</a>
<a name="l00708"></a>00708                                                           (TABLE_ITERATOR_NAME,
<a name="l00709"></a>00709                                                            callback_data_context,
<a name="l00710"></a>00710                                                            NULL));
<a name="l00711"></a>00711                         } <span class="keywordflow">else</span> {
<a name="l00712"></a>00712                             <span class="comment">/* may have changed */</span>
<a name="l00713"></a>00713                             ldata-&gt;<a class="code" href="structnetsnmp__data__list__s.html#a05f61358d6cc6dc46f16b92ddc37c6d6" title="The pointer to the data passed on.">data</a> = callback_data_context;
<a name="l00714"></a>00714                         }
<a name="l00715"></a>00715 
<a name="l00716"></a>00716                         table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a> = index_search;
<a name="l00717"></a>00717                         <span class="keywordflow">for</span>(i = table_reg_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#ae48fd51376f573a4c4e5aede809f7092" title="the minimum columns number.">min_column</a>;
<a name="l00718"></a>00718                             i &lt;= (<span class="keywordtype">int</span>)table_reg_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a4b7f37faafced959b943e974ba58e008" title="the maximum columns number">max_column</a>; i++) {
<a name="l00719"></a>00719                             myname[reginfo-&gt;rootoid_len + 1] = i;
<a name="l00720"></a>00720                             table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> = i;
<a name="l00721"></a>00721                             vb = reqtmp-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a> =
<a name="l00722"></a>00722                                 <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424" title="Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a>);
<a name="l00723"></a>00723                             <span class="keywordflow">if</span> (vb == NULL) {
<a name="l00724"></a>00724                                 <span class="comment">/*</span>
<a name="l00725"></a>00725 <span class="comment">                                 * Cleanup </span>
<a name="l00726"></a>00726 <span class="comment">                                 */</span>
<a name="l00727"></a>00727                                 <span class="keywordflow">if</span> (free_this_index_search)
<a name="l00728"></a>00728                                     snmp_free_varbind
<a name="l00729"></a>00729                                         (free_this_index_search);
<a name="l00730"></a>00730                                 <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l00731"></a>00731                             }
<a name="l00732"></a>00732                             vb-&gt;type = ASN_NULL;
<a name="l00733"></a>00733                             snmp_set_var_objid(vb, myname, myname_len);
<a name="l00734"></a>00734                             netsnmp_call_next_handler(handler, reginfo,
<a name="l00735"></a>00735                                                       reqinfo, reqtmp);
<a name="l00736"></a>00736                             reqtmp-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a> = NULL;
<a name="l00737"></a>00737                             reqtmp-&gt;processed = 0;
<a name="l00738"></a>00738                             <span class="keywordflow">if</span> (vb-&gt;type != ASN_NULL) { <span class="comment">/* XXX, not all */</span>
<a name="l00739"></a>00739                                 netsnmp_oid_stash_add_data(cinfo, myname,
<a name="l00740"></a>00740                                                            myname_len, vb);
<a name="l00741"></a>00741                             } <span class="keywordflow">else</span> {
<a name="l00742"></a>00742                                 snmp_free_var(vb);
<a name="l00743"></a>00743                             }
<a name="l00744"></a>00744                         }
<a name="l00745"></a>00745                         reqinfo-&gt;mode = MODE_GET_STASH;
<a name="l00746"></a>00746                         <span class="keywordflow">break</span>;
<a name="l00747"></a>00747 <span class="preprocessor">#endif  </span><span class="comment">/* NETSNMP_FEATURE_REMOVE_STASH_CACHE */</span>
<a name="l00748"></a>00748 
<a name="l00749"></a>00749                     <span class="keywordflow">case</span> MODE_GETNEXT:
<a name="l00750"></a>00750                         <span class="comment">/* looking for &quot;next&quot; matches */</span>
<a name="l00751"></a>00751                         <span class="keywordflow">if</span> (<a class="code" href="group__table.html#gaa28a07930d1248645af1f2e9fbf337e7" title="checks the original request against the current data being passed in if its greater than the request ...">netsnmp_check_getnext_reply</a>
<a name="l00752"></a>00752                             (request, coloid, coloid_len, index_search,
<a name="l00753"></a>00753                              &amp;ti_info-&gt;results)) {
<a name="l00754"></a>00754                             <span class="keywordflow">if</span> (netsnmp_iterator_remember(request,
<a name="l00755"></a>00755                                                           ti_info-&gt;
<a name="l00756"></a>00756                                                           results-&gt;name,
<a name="l00757"></a>00757                                                           ti_info-&gt;
<a name="l00758"></a>00758                                                           results-&gt;
<a name="l00759"></a>00759                                                           name_length,
<a name="l00760"></a>00760                                                           callback_data_context,
<a name="l00761"></a>00761                                                           callback_loop_context,
<a name="l00762"></a>00762                                                           iinfo) == NULL) {
<a name="l00763"></a>00763                                 <span class="comment">/*</span>
<a name="l00764"></a>00764 <span class="comment">                                 * Cleanup </span>
<a name="l00765"></a>00765 <span class="comment">                                 */</span>
<a name="l00766"></a>00766                                 <span class="keywordflow">if</span> (free_this_index_search)
<a name="l00767"></a>00767                                     snmp_free_varbind
<a name="l00768"></a>00768                                         (free_this_index_search);
<a name="l00769"></a>00769                                 <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l00770"></a>00770                             }
<a name="l00771"></a>00771                             <span class="comment">/*</span>
<a name="l00772"></a>00772 <span class="comment">                             *  If we&#39;ve been told that the rows are sorted,</span>
<a name="l00773"></a>00773 <span class="comment">                             *   then the first valid one we find</span>
<a name="l00774"></a>00774 <span class="comment">                             *   must be the right one.</span>
<a name="l00775"></a>00775 <span class="comment">                             */</span>
<a name="l00776"></a>00776                             <span class="keywordflow">if</span> (iinfo-&gt;flags &amp; NETSNMP_ITERATOR_FLAG_SORTED)
<a name="l00777"></a>00777                                 request_count--;
<a name="l00778"></a>00778                         
<a name="l00779"></a>00779                         } <span class="keywordflow">else</span> {
<a name="l00780"></a>00780                             <span class="keywordflow">if</span> (iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a21a0de492a8c6986be23bce6061c08a0" title="Frees a data context.">free_data_context</a> &amp;&amp; callback_data_context) {
<a name="l00781"></a>00781                                 (iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a21a0de492a8c6986be23bce6061c08a0" title="Frees a data context.">free_data_context</a>)(callback_data_context,
<a name="l00782"></a>00782                                                            iinfo);
<a name="l00783"></a>00783                             }
<a name="l00784"></a>00784                         }
<a name="l00785"></a>00785                         <span class="keywordflow">break</span>;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l00788"></a>00788 <span class="preprocessor"></span>                    <span class="keywordflow">case</span> MODE_SET_RESERVE2:
<a name="l00789"></a>00789                     <span class="keywordflow">case</span> MODE_SET_FREE:
<a name="l00790"></a>00790                     <span class="keywordflow">case</span> MODE_SET_UNDO:
<a name="l00791"></a>00791                     <span class="keywordflow">case</span> MODE_SET_COMMIT:
<a name="l00792"></a>00792                         <span class="comment">/* needed processing already done in RESERVE1 */</span>
<a name="l00793"></a>00793                         <span class="keywordflow">break</span>;
<a name="l00794"></a>00794 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00795"></a>00795 
<a name="l00796"></a>00796                     <span class="keywordflow">default</span>:
<a name="l00797"></a>00797                         <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_ERR,
<a name="l00798"></a>00798                                  <span class="stringliteral">&quot;table_iterator called with unsupported mode\n&quot;</span>);
<a name="l00799"></a>00799                         <span class="keywordflow">break</span>;  <span class="comment">/* XXX return */</span>
<a name="l00800"></a>00800                 
<a name="l00801"></a>00801                     }
<a name="l00802"></a>00802                 }
<a name="l00803"></a>00803 
<a name="l00804"></a>00804                 <span class="comment">/* Is there any point in carrying on? */</span>
<a name="l00805"></a>00805                 <span class="keywordflow">if</span> (!request_count)
<a name="l00806"></a>00806                     <span class="keywordflow">break</span>;
<a name="l00807"></a>00807                 <span class="comment">/* get the next search possibility */</span>
<a name="l00808"></a>00808                 last_loop_context = callback_loop_context;
<a name="l00809"></a>00809                 index_search =
<a name="l00810"></a>00810                     (iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a9df181621eb551784037a5bfbea1e9a0" title="Given the previous loop context, this should return the next loop context, associated index set and o...">get_next_data_point</a>) (&amp;callback_loop_context,
<a name="l00811"></a>00811                                                   &amp;callback_data_context,
<a name="l00812"></a>00812                                                   index_search, iinfo);
<a name="l00813"></a>00813                 <span class="keywordflow">if</span> (iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#ab6cbc4dc5f00074e5ae1b0a04a3360a9" title="A function which should free the loop context.">free_loop_context</a> &amp;&amp; last_loop_context &amp;&amp;
<a name="l00814"></a>00814                     callback_data_context != last_loop_context) {
<a name="l00815"></a>00815                     (iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#ab6cbc4dc5f00074e5ae1b0a04a3360a9" title="A function which should free the loop context.">free_loop_context</a>) (last_loop_context, iinfo);
<a name="l00816"></a>00816                     last_loop_context = NULL;
<a name="l00817"></a>00817                 }
<a name="l00818"></a>00818             }
<a name="l00819"></a>00819 
<a name="l00820"></a>00820             <span class="comment">/* free loop context before going on */</span>
<a name="l00821"></a>00821             <span class="keywordflow">if</span> (callback_loop_context &amp;&amp; iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a79677e673db89809584498816821d1b0" title="Frees a loop context at the end of the entire iteration sequence.">free_loop_context_at_end</a>) {
<a name="l00822"></a>00822                 (iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a79677e673db89809584498816821d1b0" title="Frees a loop context at the end of the entire iteration sequence.">free_loop_context_at_end</a>) (callback_loop_context,
<a name="l00823"></a>00823                                                    iinfo);
<a name="l00824"></a>00824                 callback_loop_context = NULL;
<a name="l00825"></a>00825             }
<a name="l00826"></a>00826 
<a name="l00827"></a>00827             <span class="comment">/* decide which (GETNEXT) requests are not yet filled */</span>
<a name="l00828"></a>00828             <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_GETNEXT) {
<a name="l00829"></a>00829                 <span class="keywordflow">for</span>(request = requests ; request; request = request-&gt;next) {
<a name="l00830"></a>00830                     <span class="keywordflow">if</span> (request-&gt;processed)
<a name="l00831"></a>00831                         <span class="keywordflow">continue</span>;
<a name="l00832"></a>00832                     ti_info = (<a class="code" href="structti__cache__info__s.html">ti_cache_info</a>*)
<a name="l00833"></a>00833                         <a class="code" href="group__handler.html#gac8ebe16c4ca9e9e8d06fadcaa2650079" title="Extracts data from a request.">netsnmp_request_get_list_data</a>(request,
<a name="l00834"></a>00834                                                       TI_REQUEST_CACHE);
<a name="l00835"></a>00835                     <span class="keywordflow">if</span> (!ti_info-&gt;results) {
<a name="l00836"></a>00836                       <span class="keywordtype">int</span> nc;
<a name="l00837"></a>00837                         table_info = <a class="code" href="group__table.html#ga0f2aa788814b909e3e3003b63b1dbd3a" title="Extracts the processed table information from a given request.">netsnmp_extract_table_info</a>(request);
<a name="l00838"></a>00838                         nc = netsnmp_table_next_column(table_info);
<a name="l00839"></a>00839                         <span class="keywordflow">if</span> (0 == nc) {
<a name="l00840"></a>00840                             coloid[reginfo-&gt;rootoid_len+1] = table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a>+1;
<a name="l00841"></a>00841                             snmp_set_var_objid(request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>,
<a name="l00842"></a>00842                                                coloid, reginfo-&gt;rootoid_len+2);
<a name="l00843"></a>00843                             request-&gt;processed = TABLE_ITERATOR_NOTAGAIN;
<a name="l00844"></a>00844                             <span class="keywordflow">break</span>;
<a name="l00845"></a>00845                         } <span class="keywordflow">else</span> {
<a name="l00846"></a>00846                           table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> = nc;
<a name="l00847"></a>00847                           hintok = 0;
<a name="l00848"></a>00848                           notdone = 1;
<a name="l00849"></a>00849                         }
<a name="l00850"></a>00850                     }
<a name="l00851"></a>00851                 }
<a name="l00852"></a>00852             }
<a name="l00853"></a>00853         }
<a name="l00854"></a>00854     }
<a name="l00855"></a>00855 
<a name="l00856"></a>00856     <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_GET ||
<a name="l00857"></a>00857         reqinfo-&gt;mode == MODE_GETNEXT
<a name="l00858"></a>00858 #ifndef NETSNMP_NO_WRITE_SUPPORT
<a name="l00859"></a>00859         || reqinfo-&gt;mode == MODE_SET_RESERVE1
<a name="l00860"></a>00860 #endif <span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00861"></a>00861         ) {
<a name="l00862"></a>00862         <span class="comment">/* per request last minute processing */</span>
<a name="l00863"></a>00863         <span class="keywordflow">for</span>(request = requests ; request; request = request-&gt;next) {
<a name="l00864"></a>00864             <span class="keywordflow">if</span> (request-&gt;processed)
<a name="l00865"></a>00865                 <span class="keywordflow">continue</span>;
<a name="l00866"></a>00866             ti_info = (<a class="code" href="structti__cache__info__s.html">ti_cache_info</a>*)
<a name="l00867"></a>00867                 <a class="code" href="group__handler.html#gac8ebe16c4ca9e9e8d06fadcaa2650079" title="Extracts data from a request.">netsnmp_request_get_list_data</a>(request, TI_REQUEST_CACHE);
<a name="l00868"></a>00868             table_info =
<a name="l00869"></a>00869                 <a class="code" href="group__table.html#ga0f2aa788814b909e3e3003b63b1dbd3a" title="Extracts the processed table information from a given request.">netsnmp_extract_table_info</a>(request);
<a name="l00870"></a>00870 
<a name="l00871"></a>00871             <span class="keywordflow">if</span> (!ti_info)
<a name="l00872"></a>00872                 <span class="keywordflow">continue</span>;
<a name="l00873"></a>00873         
<a name="l00874"></a>00874             <span class="keywordflow">switch</span>(reqinfo-&gt;mode) {
<a name="l00875"></a>00875 
<a name="l00876"></a>00876             <span class="keywordflow">case</span> MODE_GETNEXT:
<a name="l00877"></a>00877                 <span class="keywordflow">if</span> (ti_info-&gt;best_match_len)
<a name="l00878"></a>00878                     snmp_set_var_objid(request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>, ti_info-&gt;best_match,
<a name="l00879"></a>00879                                        ti_info-&gt;best_match_len);
<a name="l00880"></a>00880                 <span class="keywordflow">else</span> {
<a name="l00881"></a>00881                     coloid[reginfo-&gt;rootoid_len+1] = 
<a name="l00882"></a>00882                         netsnmp_table_next_column(table_info);
<a name="l00883"></a>00883                     <span class="keywordflow">if</span> (0 == coloid[reginfo-&gt;rootoid_len+1]) {
<a name="l00884"></a>00884                         <span class="comment">/* out of range. */</span>
<a name="l00885"></a>00885                         coloid[reginfo-&gt;rootoid_len+1] = tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a4b7f37faafced959b943e974ba58e008" title="the maximum columns number">max_column</a> + 1;
<a name="l00886"></a>00886                         request-&gt;processed = TABLE_ITERATOR_NOTAGAIN;
<a name="l00887"></a>00887                     }
<a name="l00888"></a>00888                     snmp_set_var_objid(request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>,
<a name="l00889"></a>00889                                        coloid, reginfo-&gt;rootoid_len+2);
<a name="l00890"></a>00890                     request-&gt;processed = 1;
<a name="l00891"></a>00891                 }
<a name="l00892"></a>00892                 snmp_free_varbind(table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a>);
<a name="l00893"></a>00893                 table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a> = snmp_clone_varbind(ti_info-&gt;results);
<a name="l00894"></a>00894                 <span class="comment">/* FALL THROUGH */</span>
<a name="l00895"></a>00895 
<a name="l00896"></a>00896             <span class="keywordflow">case</span> MODE_GET:
<a name="l00897"></a>00897 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l00898"></a>00898 <span class="preprocessor"></span>            <span class="keywordflow">case</span> MODE_SET_RESERVE1:
<a name="l00899"></a>00899 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00900"></a>00900                 <span class="keywordflow">if</span> (ti_info-&gt;data_context)
<a name="l00901"></a>00901                     <span class="comment">/* we don&#39;t add a free pointer, since it&#39;s in the</span>
<a name="l00902"></a>00902 <span class="comment">                       TI_REQUEST_CACHE instead */</span>
<a name="l00903"></a>00903                     <a class="code" href="group__handler.html#gacc092f27f7c4203fe20665c8341023c8" title="Adds data from node list to the request information structure.">netsnmp_request_add_list_data</a>(request,
<a name="l00904"></a>00904                                                   <a class="code" href="group__data__list.html#ga3dc286b678474c6adb610460ea71b03e" title="adds creates a data_list node given a name, data and a free function ptr.">netsnmp_create_data_list</a>
<a name="l00905"></a>00905                                                   (TABLE_ITERATOR_NAME,
<a name="l00906"></a>00906                                                    ti_info-&gt;data_context,
<a name="l00907"></a>00907                                                    NULL));
<a name="l00908"></a>00908                 <span class="keywordflow">break</span>;
<a name="l00909"></a>00909             
<a name="l00910"></a>00910             <span class="keywordflow">default</span>:
<a name="l00911"></a>00911                 <span class="keywordflow">break</span>;
<a name="l00912"></a>00912             }
<a name="l00913"></a>00913         }
<a name="l00914"></a>00914             
<a name="l00915"></a>00915         <span class="comment">/* we change all GETNEXT operations into GET operations.</span>
<a name="l00916"></a>00916 <span class="comment">           why? because we&#39;re just so nice to the lower levels.</span>
<a name="l00917"></a>00917 <span class="comment">           maybe someday they&#39;ll pay us for it.  doubtful though. */</span>
<a name="l00918"></a>00918         oldmode = reqinfo-&gt;mode;
<a name="l00919"></a>00919         <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_GETNEXT) {
<a name="l00920"></a>00920             reqinfo-&gt;mode = MODE_GET;
<a name="l00921"></a>00921         }
<a name="l00922"></a>00922 <span class="preprocessor">#ifndef NETSNMP_FEATURE_REMOVE_STASH_CACHE</span>
<a name="l00923"></a>00923 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_GET_STASH) {
<a name="l00924"></a>00924         <a class="code" href="group__handler.html#ga14d1a9eeb19594f07d4cb70de8a89145" title="Free the extra data stored in a bunch of requests.">netsnmp_free_request_data_sets</a>(reqtmp);
<a name="l00925"></a>00925         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(reqtmp);
<a name="l00926"></a>00926         table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a> = old_indexes;
<a name="l00927"></a>00927 <span class="preprocessor">#endif  </span><span class="comment">/* NETSNMP_FEATURE_REMOVE_STASH_CACHE */</span>
<a name="l00928"></a>00928     }
<a name="l00929"></a>00929 
<a name="l00930"></a>00930 
<a name="l00931"></a>00931     <span class="comment">/* Finally, we get to call the next handler below us.  Boy, wasn&#39;t</span>
<a name="l00932"></a>00932 <span class="comment">       all that simple?  They better be glad they don&#39;t have to do it! */</span>
<a name="l00933"></a>00933     <span class="keywordflow">if</span> (reqinfo-&gt;mode != MODE_GET_STASH) {
<a name="l00934"></a>00934         DEBUGMSGTL((<span class="stringliteral">&quot;table_iterator&quot;</span>, <span class="stringliteral">&quot;call subhandler for mode: %s\n&quot;</span>,
<a name="l00935"></a>00935                     se_find_label_in_slist(<span class="stringliteral">&quot;agent_mode&quot;</span>, oldmode)));
<a name="l00936"></a>00936         ret =
<a name="l00937"></a>00937             netsnmp_call_next_handler(handler, reginfo, reqinfo, requests);
<a name="l00938"></a>00938     }
<a name="l00939"></a>00939 
<a name="l00940"></a>00940     <span class="comment">/* reverse the previously saved mode if we were a getnext */</span>
<a name="l00941"></a>00941     <span class="keywordflow">if</span> (oldmode == MODE_GETNEXT) {
<a name="l00942"></a>00942         reqinfo-&gt;mode = oldmode;
<a name="l00943"></a>00943     }
<a name="l00944"></a>00944 
<a name="l00945"></a>00945     <span class="comment">/* cleanup */</span>
<a name="l00946"></a>00946     <span class="keywordflow">if</span> (free_this_index_search)
<a name="l00947"></a>00947         snmp_free_varbind(free_this_index_search);
<a name="l00948"></a>00948 
<a name="l00949"></a>00949     <span class="keywordflow">return</span> ret;
<a name="l00950"></a>00950 }
<a name="l00951"></a>00951 
<a name="l00952"></a>00952 <span class="comment">/* ==================================</span>
<a name="l00953"></a>00953 <span class="comment"> *</span>
<a name="l00954"></a>00954 <span class="comment"> * Iterator API: Row operations</span>
<a name="l00955"></a>00955 <span class="comment"> *</span>
<a name="l00956"></a>00956 <span class="comment"> * ================================== */</span>
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 <span class="preprocessor">#ifndef NETSNMP_FEATURE_REMOVE_TABLE_ITERATOR_ROW_FIRST</span>
<a name="l00959"></a>00959 <span class="preprocessor"></span><span class="keywordtype">void</span> *
<a name="l00960"></a>00960 netsnmp_iterator_row_first( <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo ) {
<a name="l00961"></a>00961     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *vp1, *vp2;
<a name="l00962"></a>00962     <span class="keywordtype">void</span> *ctx1, *ctx2;
<a name="l00963"></a>00963 
<a name="l00964"></a>00964     <span class="keywordflow">if</span> (!iinfo)
<a name="l00965"></a>00965         <span class="keywordflow">return</span> NULL;
<a name="l00966"></a>00966 
<a name="l00967"></a>00967     vp1 = snmp_clone_varbind(iinfo-&gt;indexes);
<a name="l00968"></a>00968     vp2 = iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a98224fb1d34bf8794bc2e45eab33ce56" title="Responsible for: returning the first set of &quot;index&quot; data, a loop-context pointer, and optionally a da...">get_first_data_point</a>( &amp;ctx1, &amp;ctx2, vp1, iinfo );
<a name="l00969"></a>00969 
<a name="l00970"></a>00970     <span class="keywordflow">if</span> (!vp2)
<a name="l00971"></a>00971         ctx2 = NULL;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973     <span class="comment">/* free loop context ?? */</span>
<a name="l00974"></a>00974     snmp_free_varbind( vp1 );
<a name="l00975"></a>00975     <span class="keywordflow">return</span> ctx2;  <span class="comment">/* or *ctx2 ?? */</span>
<a name="l00976"></a>00976 }
<a name="l00977"></a>00977 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_FEATURE_REMOVE_TABLE_ITERATOR_ROW_FIRST */</span>
<a name="l00978"></a>00978 
<a name="l00979"></a>00979 <span class="keywordtype">void</span> *
<a name="l00980"></a>00980 netsnmp_iterator_row_get( <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo, <span class="keywordtype">void</span> *row )
<a name="l00981"></a>00981 {
<a name="l00982"></a>00982     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *vp1, *vp2;
<a name="l00983"></a>00983     <span class="keywordtype">void</span> *ctx1, *ctx2;
<a name="l00984"></a>00984 
<a name="l00985"></a>00985     <span class="keywordflow">if</span> (!iinfo || !row)
<a name="l00986"></a>00986         <span class="keywordflow">return</span> NULL;
<a name="l00987"></a>00987 
<a name="l00988"></a>00988         <span class="comment">/*</span>
<a name="l00989"></a>00989 <span class="comment">         * This routine relies on being able to</span>
<a name="l00990"></a>00990 <span class="comment">         *   determine the indexes for a given row.  </span>
<a name="l00991"></a>00991 <span class="comment">         */</span>
<a name="l00992"></a>00992     <span class="keywordflow">if</span> (!iinfo-&gt;get_row_indexes)
<a name="l00993"></a>00993         <span class="keywordflow">return</span> NULL;
<a name="l00994"></a>00994 
<a name="l00995"></a>00995     vp1  = snmp_clone_varbind(iinfo-&gt;indexes);
<a name="l00996"></a>00996     ctx1 = row;   <span class="comment">/* Probably only need one of these ... */</span>
<a name="l00997"></a>00997     ctx2 = row;
<a name="l00998"></a>00998     vp2  = iinfo-&gt;get_row_indexes( &amp;ctx1, &amp;ctx2, vp1, iinfo );
<a name="l00999"></a>00999 
<a name="l01000"></a>01000     ctx2 = NULL;
<a name="l01001"></a>01001     <span class="keywordflow">if</span> (vp2) {
<a name="l01002"></a>01002         ctx2 = netsnmp_iterator_row_get_byidx( iinfo, vp2 );
<a name="l01003"></a>01003     }
<a name="l01004"></a>01004     snmp_free_varbind( vp1 );
<a name="l01005"></a>01005     <span class="keywordflow">return</span> ctx2;
<a name="l01006"></a>01006 }
<a name="l01007"></a>01007 
<a name="l01008"></a>01008 <span class="keywordtype">void</span> *
<a name="l01009"></a>01009 netsnmp_iterator_row_next( <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo, <span class="keywordtype">void</span> *row )
<a name="l01010"></a>01010 {
<a name="l01011"></a>01011     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *vp1, *vp2;
<a name="l01012"></a>01012     <span class="keywordtype">void</span> *ctx1, *ctx2;
<a name="l01013"></a>01013 
<a name="l01014"></a>01014     <span class="keywordflow">if</span> (!iinfo || !row)
<a name="l01015"></a>01015         <span class="keywordflow">return</span> NULL;
<a name="l01016"></a>01016 
<a name="l01017"></a>01017         <span class="comment">/*</span>
<a name="l01018"></a>01018 <span class="comment">         * This routine relies on being able to</span>
<a name="l01019"></a>01019 <span class="comment">         *   determine the indexes for a given row.  </span>
<a name="l01020"></a>01020 <span class="comment">         */</span>
<a name="l01021"></a>01021     <span class="keywordflow">if</span> (!iinfo-&gt;get_row_indexes)
<a name="l01022"></a>01022         <span class="keywordflow">return</span> NULL;
<a name="l01023"></a>01023 
<a name="l01024"></a>01024     vp1  = snmp_clone_varbind(iinfo-&gt;indexes);
<a name="l01025"></a>01025     ctx1 = row;   <span class="comment">/* Probably only need one of these ... */</span>
<a name="l01026"></a>01026     ctx2 = row;
<a name="l01027"></a>01027     vp2  = iinfo-&gt;get_row_indexes( &amp;ctx1, &amp;ctx2, vp1, iinfo );
<a name="l01028"></a>01028 
<a name="l01029"></a>01029     ctx2 = NULL;
<a name="l01030"></a>01030     <span class="keywordflow">if</span> (vp2) {
<a name="l01031"></a>01031         ctx2 = netsnmp_iterator_row_next_byidx( iinfo, vp2 );
<a name="l01032"></a>01032     }
<a name="l01033"></a>01033     snmp_free_varbind( vp1 );
<a name="l01034"></a>01034     <span class="keywordflow">return</span> ctx2;
<a name="l01035"></a>01035 }
<a name="l01036"></a>01036 
<a name="l01037"></a>01037 <span class="keywordtype">void</span> *
<a name="l01038"></a>01038 netsnmp_iterator_row_get_byidx(  <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo,
<a name="l01039"></a>01039                                  <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *indexes )
<a name="l01040"></a>01040 {
<a name="l01041"></a>01041     oid    dummy[] = {0,0};   <span class="comment">/* Keep &#39;build_oid&#39; happy */</span>
<a name="l01042"></a>01042     oid    instance[MAX_OID_LEN];
<a name="l01043"></a>01043     <span class="keywordtype">size_t</span> len =    MAX_OID_LEN;
<a name="l01044"></a>01044 
<a name="l01045"></a>01045     <span class="keywordflow">if</span> (!iinfo || !indexes)
<a name="l01046"></a>01046         <span class="keywordflow">return</span> NULL;
<a name="l01047"></a>01047 
<a name="l01048"></a>01048     build_oid_noalloc(instance, MAX_OID_LEN, &amp;len,
<a name="l01049"></a>01049                       dummy, 2, indexes);
<a name="l01050"></a>01050     <span class="keywordflow">return</span> netsnmp_iterator_row_get_byoid( iinfo, instance+2, len-2 );
<a name="l01051"></a>01051 }
<a name="l01052"></a>01052 
<a name="l01053"></a>01053 <span class="keywordtype">void</span> *
<a name="l01054"></a>01054 netsnmp_iterator_row_next_byidx( <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo,
<a name="l01055"></a>01055                                  <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *indexes )
<a name="l01056"></a>01056 {
<a name="l01057"></a>01057     oid    dummy[] = {0,0};
<a name="l01058"></a>01058     oid    instance[MAX_OID_LEN];
<a name="l01059"></a>01059     <span class="keywordtype">size_t</span> len =    MAX_OID_LEN;
<a name="l01060"></a>01060 
<a name="l01061"></a>01061     <span class="keywordflow">if</span> (!iinfo || !indexes)
<a name="l01062"></a>01062         <span class="keywordflow">return</span> NULL;
<a name="l01063"></a>01063 
<a name="l01064"></a>01064     build_oid_noalloc(instance, MAX_OID_LEN, &amp;len,
<a name="l01065"></a>01065                       dummy, 2, indexes);
<a name="l01066"></a>01066     <span class="keywordflow">return</span> netsnmp_iterator_row_next_byoid( iinfo, instance+2, len-2 );
<a name="l01067"></a>01067 }
<a name="l01068"></a>01068 
<a name="l01069"></a>01069 <span class="keywordtype">void</span> *
<a name="l01070"></a>01070 netsnmp_iterator_row_get_byoid(  <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo,
<a name="l01071"></a>01071                                  oid *instance, <span class="keywordtype">size_t</span> len )
<a name="l01072"></a>01072 {
<a name="l01073"></a>01073     oid    dummy[] = {0,0};
<a name="l01074"></a>01074     oid    this_inst[ MAX_OID_LEN];
<a name="l01075"></a>01075     <span class="keywordtype">size_t</span> this_len;
<a name="l01076"></a>01076     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *vp1, *vp2;
<a name="l01077"></a>01077     <span class="keywordtype">void</span> *ctx1, *ctx2;
<a name="l01078"></a>01078     <span class="keywordtype">int</span>   n;
<a name="l01079"></a>01079 
<a name="l01080"></a>01080     <span class="keywordflow">if</span> (!iinfo || !iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a98224fb1d34bf8794bc2e45eab33ce56" title="Responsible for: returning the first set of &quot;index&quot; data, a loop-context pointer, and optionally a da...">get_first_data_point</a>
<a name="l01081"></a>01081                || !iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a9df181621eb551784037a5bfbea1e9a0" title="Given the previous loop context, this should return the next loop context, associated index set and o...">get_next_data_point</a> )
<a name="l01082"></a>01082         <span class="keywordflow">return</span> NULL;
<a name="l01083"></a>01083 
<a name="l01084"></a>01084     <span class="keywordflow">if</span> ( !instance || !len )
<a name="l01085"></a>01085         <span class="keywordflow">return</span> NULL;
<a name="l01086"></a>01086 
<a name="l01087"></a>01087     vp1 = snmp_clone_varbind(iinfo-&gt;indexes);
<a name="l01088"></a>01088     vp2 = iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a98224fb1d34bf8794bc2e45eab33ce56" title="Responsible for: returning the first set of &quot;index&quot; data, a loop-context pointer, and optionally a da...">get_first_data_point</a>( &amp;ctx1, &amp;ctx2, vp1, iinfo );
<a name="l01089"></a>01089     DEBUGMSGTL((<span class="stringliteral">&quot;table:iterator:get&quot;</span>, <span class="stringliteral">&quot;first DP: %p %p %p\n&quot;</span>,
<a name="l01090"></a>01090                                        ctx1, ctx2, vp2));
<a name="l01091"></a>01091 
<a name="l01092"></a>01092     <span class="comment">/* XXX - free context ? */</span>
<a name="l01093"></a>01093     
<a name="l01094"></a>01094     <span class="keywordflow">while</span> ( vp2 ) {
<a name="l01095"></a>01095         this_len = MAX_OID_LEN;
<a name="l01096"></a>01096         build_oid_noalloc(this_inst, MAX_OID_LEN, &amp;this_len, dummy, 2, vp2);
<a name="l01097"></a>01097         n = <a class="code" href="group__library.html#gab5b48a42c19a801547e025ed40b4561e" title="lexicographical compare two object identifiers.">snmp_oid_compare</a>( instance, len, this_inst+2, this_len-2 );
<a name="l01098"></a>01098         <span class="keywordflow">if</span> ( n == 0 )
<a name="l01099"></a>01099             <span class="keywordflow">break</span>;  <span class="comment">/* Found matching row */</span>
<a name="l01100"></a>01100 
<a name="l01101"></a>01101         <span class="keywordflow">if</span> (( n &gt; 0) &amp;&amp;
<a name="l01102"></a>01102             (iinfo-&gt;flags &amp; NETSNMP_ITERATOR_FLAG_SORTED)) {
<a name="l01103"></a>01103             vp2 = NULL;  <span class="comment">/* Row not present */</span>
<a name="l01104"></a>01104             <span class="keywordflow">break</span>;
<a name="l01105"></a>01105         }
<a name="l01106"></a>01106         
<a name="l01107"></a>01107         vp2 = iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a9df181621eb551784037a5bfbea1e9a0" title="Given the previous loop context, this should return the next loop context, associated index set and o...">get_next_data_point</a>( &amp;ctx1, &amp;ctx2, vp2, iinfo );
<a name="l01108"></a>01108         DEBUGMSGTL((<span class="stringliteral">&quot;table:iterator:get&quot;</span>, <span class="stringliteral">&quot;next DP: %p %p %p\n&quot;</span>,
<a name="l01109"></a>01109                                            ctx1, ctx2, vp2));
<a name="l01110"></a>01110         <span class="comment">/* XXX - free context ? */</span>
<a name="l01111"></a>01111     }
<a name="l01112"></a>01112            
<a name="l01113"></a>01113     <span class="comment">/* XXX - final free context ? */</span>
<a name="l01114"></a>01114     snmp_free_varbind( vp1 );
<a name="l01115"></a>01115 
<a name="l01116"></a>01116     <span class="keywordflow">return</span> ( vp2 ? ctx2 : NULL );
<a name="l01117"></a>01117 }
<a name="l01118"></a>01118 
<a name="l01119"></a>01119 <span class="keywordtype">void</span> *
<a name="l01120"></a>01120 netsnmp_iterator_row_next_byoid( <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo,
<a name="l01121"></a>01121                                  oid *instance, <span class="keywordtype">size_t</span> len )
<a name="l01122"></a>01122 {
<a name="l01123"></a>01123     oid    dummy[] = {0,0};
<a name="l01124"></a>01124     oid    this_inst[ MAX_OID_LEN];
<a name="l01125"></a>01125     <span class="keywordtype">size_t</span> this_len;
<a name="l01126"></a>01126     oid    best_inst[ MAX_OID_LEN];
<a name="l01127"></a>01127     <span class="keywordtype">size_t</span> best_len = 0;
<a name="l01128"></a>01128     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *vp1, *vp2;
<a name="l01129"></a>01129     <span class="keywordtype">void</span> *ctx1, *ctx2;
<a name="l01130"></a>01130     <span class="keywordtype">int</span>   n;
<a name="l01131"></a>01131 
<a name="l01132"></a>01132     <span class="keywordflow">if</span> (!iinfo || !iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a98224fb1d34bf8794bc2e45eab33ce56" title="Responsible for: returning the first set of &quot;index&quot; data, a loop-context pointer, and optionally a da...">get_first_data_point</a>
<a name="l01133"></a>01133                || !iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a9df181621eb551784037a5bfbea1e9a0" title="Given the previous loop context, this should return the next loop context, associated index set and o...">get_next_data_point</a> )
<a name="l01134"></a>01134         <span class="keywordflow">return</span> NULL;
<a name="l01135"></a>01135 
<a name="l01136"></a>01136     vp1 = snmp_clone_varbind(iinfo-&gt;indexes);
<a name="l01137"></a>01137     vp2 = iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a98224fb1d34bf8794bc2e45eab33ce56" title="Responsible for: returning the first set of &quot;index&quot; data, a loop-context pointer, and optionally a da...">get_first_data_point</a>( &amp;ctx1, &amp;ctx2, vp1, iinfo );
<a name="l01138"></a>01138     DEBUGMSGTL((<span class="stringliteral">&quot;table:iterator:get&quot;</span>, <span class="stringliteral">&quot;first DP: %p %p %p\n&quot;</span>,
<a name="l01139"></a>01139                                        ctx1, ctx2, vp2));
<a name="l01140"></a>01140 
<a name="l01141"></a>01141     <span class="keywordflow">if</span> ( !instance || !len ) {
<a name="l01142"></a>01142         snmp_free_varbind( vp1 );
<a name="l01143"></a>01143         <span class="keywordflow">return</span> ( vp2 ? ctx2 : NULL );   <span class="comment">/* First entry */</span>
<a name="l01144"></a>01144     }
<a name="l01145"></a>01145 
<a name="l01146"></a>01146     <span class="comment">/* XXX - free context ? */</span>
<a name="l01147"></a>01147     
<a name="l01148"></a>01148     <span class="keywordflow">while</span> ( vp2 ) {
<a name="l01149"></a>01149         this_len = MAX_OID_LEN;
<a name="l01150"></a>01150         build_oid_noalloc(this_inst, MAX_OID_LEN, &amp;this_len, dummy, 2, vp2);
<a name="l01151"></a>01151         n = <a class="code" href="group__library.html#gab5b48a42c19a801547e025ed40b4561e" title="lexicographical compare two object identifiers.">snmp_oid_compare</a>( instance, len, this_inst+2, this_len-2 );
<a name="l01152"></a>01152 
<a name="l01153"></a>01153         <span class="comment">/*</span>
<a name="l01154"></a>01154 <span class="comment">         * Look for the best-fit candidate for the next row</span>
<a name="l01155"></a>01155 <span class="comment">         *   (bearing in mind the rows may not be ordered &quot;correctly&quot;)</span>
<a name="l01156"></a>01156 <span class="comment">         */</span>
<a name="l01157"></a>01157         <span class="keywordflow">if</span> ( n &gt; 0 ) {
<a name="l01158"></a>01158             <span class="keywordflow">if</span> ( best_len == 0 ) {
<a name="l01159"></a>01159                 memcpy( best_inst, this_inst, <span class="keyword">sizeof</span>( this_inst ));
<a name="l01160"></a>01160                 best_len = this_len;
<a name="l01161"></a>01161                 <span class="keywordflow">if</span> (iinfo-&gt;flags &amp; NETSNMP_ITERATOR_FLAG_SORTED)
<a name="l01162"></a>01162                     <span class="keywordflow">break</span>;
<a name="l01163"></a>01163             } <span class="keywordflow">else</span> {
<a name="l01164"></a>01164                 n = <a class="code" href="group__library.html#gab5b48a42c19a801547e025ed40b4561e" title="lexicographical compare two object identifiers.">snmp_oid_compare</a>( best_inst, best_len, this_inst, this_len );
<a name="l01165"></a>01165                 <span class="keywordflow">if</span> ( n &lt; 0 ) {
<a name="l01166"></a>01166                     memcpy( best_inst, this_inst, <span class="keyword">sizeof</span>( this_inst ));
<a name="l01167"></a>01167                     best_len = this_len;
<a name="l01168"></a>01168                     <span class="keywordflow">if</span> (iinfo-&gt;flags &amp; NETSNMP_ITERATOR_FLAG_SORTED)
<a name="l01169"></a>01169                         <span class="keywordflow">break</span>;
<a name="l01170"></a>01170                 }
<a name="l01171"></a>01171             }
<a name="l01172"></a>01172         }
<a name="l01173"></a>01173         
<a name="l01174"></a>01174         vp2 = iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a9df181621eb551784037a5bfbea1e9a0" title="Given the previous loop context, this should return the next loop context, associated index set and o...">get_next_data_point</a>( &amp;ctx1, &amp;ctx2, vp2, iinfo );
<a name="l01175"></a>01175         DEBUGMSGTL((<span class="stringliteral">&quot;table:iterator:get&quot;</span>, <span class="stringliteral">&quot;next DP: %p %p %p\n&quot;</span>,
<a name="l01176"></a>01176                                            ctx1, ctx2, vp2));
<a name="l01177"></a>01177         <span class="comment">/* XXX - free context ? */</span>
<a name="l01178"></a>01178     }
<a name="l01179"></a>01179            
<a name="l01180"></a>01180     <span class="comment">/* XXX - final free context ? */</span>
<a name="l01181"></a>01181     snmp_free_varbind( vp1 );
<a name="l01182"></a>01182 
<a name="l01183"></a>01183     <span class="keywordflow">return</span> ( vp2 ? ctx2 : NULL );
<a name="l01184"></a>01184 }
<a name="l01185"></a>01185 
<a name="l01186"></a>01186 <span class="preprocessor">#ifndef NETSNMP_FEATURE_REMOVE_TABLE_ITERATOR_ROW_COUNT</span>
<a name="l01187"></a>01187 <span class="preprocessor"></span><span class="keywordtype">int</span>
<a name="l01188"></a>01188 netsnmp_iterator_row_count( <a class="code" href="structnetsnmp__iterator__info__s.html" title="Holds iterator information containing functions which should be called by the iterator_handler to loo...">netsnmp_iterator_info</a> *iinfo )
<a name="l01189"></a>01189 {
<a name="l01190"></a>01190     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *vp1, *vp2;
<a name="l01191"></a>01191     <span class="keywordtype">void</span> *ctx1, *ctx2;
<a name="l01192"></a>01192     <span class="keywordtype">int</span>   i=0;
<a name="l01193"></a>01193 
<a name="l01194"></a>01194     <span class="keywordflow">if</span> (!iinfo || !iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a98224fb1d34bf8794bc2e45eab33ce56" title="Responsible for: returning the first set of &quot;index&quot; data, a loop-context pointer, and optionally a da...">get_first_data_point</a>
<a name="l01195"></a>01195                || !iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a9df181621eb551784037a5bfbea1e9a0" title="Given the previous loop context, this should return the next loop context, associated index set and o...">get_next_data_point</a> )
<a name="l01196"></a>01196         <span class="keywordflow">return</span> 0;
<a name="l01197"></a>01197 
<a name="l01198"></a>01198     vp1 = snmp_clone_varbind(iinfo-&gt;indexes);
<a name="l01199"></a>01199     vp2 = iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a98224fb1d34bf8794bc2e45eab33ce56" title="Responsible for: returning the first set of &quot;index&quot; data, a loop-context pointer, and optionally a da...">get_first_data_point</a>( &amp;ctx1, &amp;ctx2, vp1, iinfo );
<a name="l01200"></a>01200     <span class="keywordflow">if</span> (!vp2) {
<a name="l01201"></a>01201         snmp_free_varbind( vp1 );
<a name="l01202"></a>01202         <span class="keywordflow">return</span> 0;
<a name="l01203"></a>01203     }
<a name="l01204"></a>01204     
<a name="l01205"></a>01205     DEBUGMSGTL((<span class="stringliteral">&quot;table:iterator:count&quot;</span>, <span class="stringliteral">&quot;first DP: %p %p %p\n&quot;</span>,
<a name="l01206"></a>01206                                          ctx1, ctx2, vp2));
<a name="l01207"></a>01207 
<a name="l01208"></a>01208     <span class="comment">/* XXX - free context ? */</span>
<a name="l01209"></a>01209 
<a name="l01210"></a>01210     <span class="keywordflow">while</span> (vp2) {
<a name="l01211"></a>01211         i++;
<a name="l01212"></a>01212         vp2 = iinfo-&gt;<a class="code" href="structnetsnmp__iterator__info__s.html#a9df181621eb551784037a5bfbea1e9a0" title="Given the previous loop context, this should return the next loop context, associated index set and o...">get_next_data_point</a>( &amp;ctx1, &amp;ctx2, vp2, iinfo );
<a name="l01213"></a>01213         DEBUGMSGTL((<span class="stringliteral">&quot;table:iterator:count&quot;</span>, <span class="stringliteral">&quot;next DP: %p %p %p (%d)\n&quot;</span>,
<a name="l01214"></a>01214                                              ctx1, ctx2, vp2, i));
<a name="l01215"></a>01215         <span class="comment">/* XXX - free context ? */</span>
<a name="l01216"></a>01216     }
<a name="l01217"></a>01217            
<a name="l01218"></a>01218     <span class="comment">/* XXX - final free context ? */</span>
<a name="l01219"></a>01219     snmp_free_varbind( vp1 );
<a name="l01220"></a>01220     <span class="keywordflow">return</span> i;
<a name="l01221"></a>01221 }
<a name="l01222"></a>01222 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_FEATURE_REMOVE_TABLE_ITERATOR_ROW_COUNT */</span>
<a name="l01223"></a>01223 
<a name="l01224"></a>01224 
<a name="l01225"></a>01225 <span class="comment">/* ==================================</span>
<a name="l01226"></a>01226 <span class="comment"> *</span>
<a name="l01227"></a>01227 <span class="comment"> * Iterator API: Index operations</span>
<a name="l01228"></a>01228 <span class="comment"> *</span>
<a name="l01229"></a>01229 <span class="comment"> * ================================== */</span>
<a name="l01230"></a>01230 
<a name="l01231"></a>01231 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jul 14 2011 for net-snmp by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
