<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>vacm.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
00002 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00003 <span class="comment"> * that may apply:</span>
00004 <span class="comment"> */</span>
00005 <span class="comment">/*</span>
00006 <span class="comment"> * Portions of this file are copyrighted by:</span>
00007 <span class="comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
00008 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00009 <span class="comment"> * distributed with the Net-SNMP package.</span>
00010 <span class="comment"> */</span>
00011 
00012 <span class="comment">/*</span>
00013 <span class="comment"> * vacm.c</span>
00014 <span class="comment"> *</span>
00015 <span class="comment"> * SNMPv3 View-based Access Control Model</span>
00016 <span class="comment"> */</span>
00017 
00018 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00019 
00020 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00021 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00022 <span class="preprocessor">#endif</span>
00023 <span class="preprocessor">#if HAVE_STRING_H</span>
00024 <span class="preprocessor">#include &lt;string.h&gt;</span>
00025 <span class="preprocessor">#else</span>
00026 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00027 <span class="preprocessor">#endif</span>
00028 <span class="preprocessor">#if HAVE_UNISTD_H</span>
00029 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00030 <span class="preprocessor">#endif</span>
00031 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00032 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00033 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00034 <span class="preprocessor"># ifdef WIN32</span>
00035 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00036 <span class="preprocessor"># else</span>
00037 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00038 <span class="preprocessor"># endif</span>
00039 <span class="preprocessor"># include &lt;time.h&gt;</span>
00040 <span class="preprocessor">#else</span>
00041 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00042 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00043 <span class="preprocessor"># else</span>
00044 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00045 <span class="preprocessor"># endif</span>
00046 <span class="preprocessor">#endif</span>
00047 
00048 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00049 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00050 <span class="preprocessor">#endif</span>
00051 
00052 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00053 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00054 <span class="preprocessor">#endif</span>
00055 
00056 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00057 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00058 <span class="preprocessor">#endif</span>
00059 
00060 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00061 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00062 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00063 
00064 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00065 <span class="preprocessor">#include &lt;net-snmp/library/vacm.h&gt;</span>
00066 
00067 <span class="keyword">static</span> <span class=
"keyword">struct </span>vacm_viewEntry *viewList = NULL, *viewScanPtr = NULL;
00068 <span class="keyword">static</span> <span class=
"keyword">struct </span>vacm_accessEntry *accessList = NULL, *accessScanPtr = NULL;
00069 <span class="keyword">static</span> <span class=
"keyword">struct </span>vacm_groupEntry *groupList = NULL, *groupScanPtr = NULL;
00070 
00071 <span class="keywordtype">void</span>
00072 vacm_save(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *type)
00073 {
00074     <span class="keyword">struct </span>vacm_viewEntry *vptr;
00075     <span class="keyword">struct </span>vacm_accessEntry *aptr;
00076     <span class="keyword">struct </span>vacm_groupEntry *gptr;
00077 
00078     <span class="keywordflow">for</span> (vptr = viewList; vptr != NULL; vptr = vptr-&gt;next) {
00079         <span class="keywordflow">if</span> (vptr-&gt;viewStorageType == ST_NONVOLATILE)
00080             vacm_save_view(vptr, token, type);
00081     }
00082 
00083     <span class="keywordflow">for</span> (aptr = accessList; aptr != NULL; aptr = aptr-&gt;next) {
00084         <span class="keywordflow">if</span> (aptr-&gt;storageType == ST_NONVOLATILE)
00085             vacm_save_access(aptr, token, type);
00086     }
00087 
00088     <span class="keywordflow">for</span> (gptr = groupList; gptr != NULL; gptr = gptr-&gt;next) {
00089         <span class="keywordflow">if</span> (gptr-&gt;storageType == ST_NONVOLATILE)
00090             vacm_save_group(gptr, token, type);
00091     }
00092 }
00093 
00094 <span class="comment">/*</span>
00095 <span class="comment"> * vacm_save_view(): saves a view entry to the persistent cache </span>
00096 <span class="comment"> */</span>
00097 <span class="keywordtype">void</span>
00098 vacm_save_view(<span class="keyword">struct</span> vacm_viewEntry *view, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *token,
00099                <span class="keyword">const</span> <span class="keywordtype">char</span> *type)
00100 {
00101     <span class="keywordtype">char</span>            line[4096];
00102     <span class="keywordtype">char</span>           *cptr;
00103 
00104     memset(line, 0, <span class="keyword">sizeof</span>(line));
00105     snprintf(line, <span class="keyword">sizeof</span>(line), <span class=
"stringliteral">"%s%s %d %d %d "</span>, token, <span class="stringliteral">"View"</span>,
00106             view-&gt;viewStatus, view-&gt;viewStorageType, view-&gt;viewType);
00107     line[ <span class="keyword">sizeof</span>(line)-1 ] = 0;
00108     cptr = &amp;line[strlen(line)]; <span class="comment">/* the NULL */</span>
00109 
00110     cptr =
00111         read_config_save_octet_string(cptr, (u_char *) view-&gt;viewName + 1,
00112                                       view-&gt;viewName[0] + 1);
00113     *cptr++ = <span class="charliteral">' '</span>;
00114     cptr =
00115         read_config_save_objid(cptr, view-&gt;viewSubtree+1,
00116                                      view-&gt;viewSubtreeLen-1);
00117     *cptr++ = <span class="charliteral">' '</span>;
00118     cptr = read_config_save_octet_string(cptr, (u_char *) view-&gt;viewMask,
00119                                          view-&gt;viewMaskLen);
00120 
00121     <a class="code" href="group__read__config.html#ga37">read_config_store</a>(type, line);
00122 }
00123 
00124 <span class="keywordtype">void</span>
00125 vacm_parse_config_view(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
00126 {
00127     <span class="keyword">struct </span>vacm_viewEntry view;
00128     <span class="keyword">struct </span>vacm_viewEntry *vptr;
00129     <span class="keywordtype">char</span>           *viewName = (<span class=
"keywordtype">char</span> *) &amp;view.viewName;
00130     oid            *viewSubtree = (oid *) &amp; view.viewSubtree;
00131     u_char         *viewMask;
00132     size_t          len;
00133 
00134     view.viewStatus = atoi(line);
00135     line = skip_token(line);
00136     view.viewStorageType = atoi(line);
00137     line = skip_token(line);
00138     view.viewType = atoi(line);
00139     line = skip_token(line);
00140     line =
00141         read_config_read_octet_string(line, (u_char **) &amp; viewName, &amp;len);
00142     view.viewSubtreeLen = MAX_OID_LEN;
00143     line =
00144         read_config_read_objid(line, (oid **) &amp; viewSubtree,
00145                                &amp;view.viewSubtreeLen);
00146 
00147     vptr =
00148         vacm_createViewEntry(view.viewName, view.viewSubtree,
00149                              view.viewSubtreeLen);
00150     <span class="keywordflow">if</span> (!vptr)
00151         <span class="keywordflow">return</span>;
00152 
00153     vptr-&gt;viewStatus = view.viewStatus;
00154     vptr-&gt;viewStorageType = view.viewStorageType;
00155     vptr-&gt;viewType = view.viewType;
00156     viewMask = (u_char *) vptr-&gt;viewMask;
00157     line =
00158         read_config_read_octet_string(line, (u_char **) &amp; viewMask,
00159                                       &amp;vptr-&gt;viewMaskLen);
00160 }
00161 
00162 <span class="comment">/*</span>
00163 <span class="comment"> * vacm_save_access(): saves an access entry to the persistent cache </span>
00164 <span class="comment"> */</span>
00165 <span class="keywordtype">void</span>
00166 vacm_save_access(<span class="keyword">struct</span> vacm_accessEntry *access_entry, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *token,
00167                  <span class="keyword">const</span> <span class="keywordtype">char</span> *type)
00168 {
00169     <span class="keywordtype">char</span>            line[4096];
00170     <span class="keywordtype">char</span>           *cptr;
00171 
00172     memset(line, 0, <span class="keyword">sizeof</span>(line));
00173     snprintf(line, <span class="keyword">sizeof</span>(line), <span class="stringliteral">"%s%s %d %d %d %d %d "</span>,
00174             token, <span class="stringliteral">"Access"</span>, access_entry-&gt;status,
00175             access_entry-&gt;storageType, access_entry-&gt;securityModel,
00176             access_entry-&gt;securityLevel, access_entry-&gt;contextMatch);
00177     line[ <span class="keyword">sizeof</span>(line)-1 ] = 0;
00178     cptr = &amp;line[strlen(line)]; <span class="comment">/* the NULL */</span>
00179     cptr =
00180         read_config_save_octet_string(cptr,
00181                                       (u_char *) access_entry-&gt;groupName + 1,
00182                                       access_entry-&gt;groupName[0] + 1);
00183     *cptr++ = <span class="charliteral">' '</span>;
00184     cptr =
00185         read_config_save_octet_string(cptr,
00186                                       (u_char *) access_entry-&gt;contextPrefix + 1,
00187                                       access_entry-&gt;contextPrefix[0] + 1);
00188 
00189     *cptr++ = <span class="charliteral">' '</span>;
00190     cptr = read_config_save_octet_string(cptr, (u_char *) access_entry-&gt;readView,
00191                                          strlen(access_entry-&gt;readView) + 1);
00192     *cptr++ = <span class="charliteral">' '</span>;
00193     cptr =
00194         read_config_save_octet_string(cptr, (u_char *) access_entry-&gt;writeView,
00195                                       strlen(access_entry-&gt;writeView) + 1);
00196     *cptr++ = <span class="charliteral">' '</span>;
00197     cptr =
00198         read_config_save_octet_string(cptr, (u_char *) access_entry-&gt;notifyView,
00199                                       strlen(access_entry-&gt;notifyView) + 1);
00200 
00201     <a class="code" href="group__read__config.html#ga37">read_config_store</a>(type, line);
00202 }
00203 
00204 <span class="keywordtype">void</span>
00205 vacm_parse_config_access(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
00206 {
00207     <span class="keyword">struct </span>vacm_accessEntry access;
00208     <span class="keyword">struct </span>vacm_accessEntry *aptr;
00209     <span class="keywordtype">char</span>           *contextPrefix = (<span class=
"keywordtype">char</span> *) &amp;access.contextPrefix;
00210     <span class="keywordtype">char</span>           *groupName = (<span class=
"keywordtype">char</span> *) &amp;access.groupName;
00211     <span class="keywordtype">char</span>           *readView, *writeView, *notifyView;
00212     size_t          len;
00213 
00214     access.status = atoi(line);
00215     line = skip_token(line);
00216     access.storageType = atoi(line);
00217     line = skip_token(line);
00218     access.securityModel = atoi(line);
00219     line = skip_token(line);
00220     access.securityLevel = atoi(line);
00221     line = skip_token(line);
00222     access.contextMatch = atoi(line);
00223     line = skip_token(line);
00224     line =
00225         read_config_read_octet_string(line, (u_char **) &amp; groupName, &amp;len);
00226     line =
00227         read_config_read_octet_string(line, (u_char **) &amp; contextPrefix,
00228                                       &amp;len);
00229 
00230     aptr = vacm_createAccessEntry(access.groupName, access.contextPrefix,
00231                                   access.securityModel,
00232                                   access.securityLevel);
00233     <span class="keywordflow">if</span> (!aptr)
00234         <span class="keywordflow">return</span>;
00235 
00236     aptr-&gt;status = access.status;
00237     aptr-&gt;storageType = access.storageType;
00238     aptr-&gt;securityModel = access.securityModel;
00239     aptr-&gt;securityLevel = access.securityLevel;
00240     aptr-&gt;contextMatch = access.contextMatch;
00241     readView = (<span class="keywordtype">char</span> *) aptr-&gt;readView;
00242     line =
00243         read_config_read_octet_string(line, (u_char **) &amp; readView, &amp;len);
00244     writeView = (<span class="keywordtype">char</span> *) aptr-&gt;writeView;
00245     line =
00246         read_config_read_octet_string(line, (u_char **) &amp; writeView, &amp;len);
00247     notifyView = (<span class="keywordtype">char</span> *) aptr-&gt;notifyView;
00248     line =
00249         read_config_read_octet_string(line, (u_char **) &amp; notifyView,
00250                                       &amp;len);
00251 }
00252 
00253 <span class="comment">/*</span>
00254 <span class="comment"> * vacm_save_group(): saves a group entry to the persistent cache </span>
00255 <span class="comment"> */</span>
00256 <span class="keywordtype">void</span>
00257 vacm_save_group(<span class="keyword">struct</span> vacm_groupEntry *group_entry, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *token,
00258                 <span class="keyword">const</span> <span class="keywordtype">char</span> *type)
00259 {
00260     <span class="keywordtype">char</span>            line[4096];
00261     <span class="keywordtype">char</span>           *cptr;
00262 
00263     memset(line, 0, <span class="keyword">sizeof</span>(line));
00264     snprintf(line, <span class="keyword">sizeof</span>(line), <span class="stringliteral">"%s%s %d %d %d "</span>,
00265             token, <span class="stringliteral">"Group"</span>, group_entry-&gt;status,
00266             group_entry-&gt;storageType, group_entry-&gt;securityModel);
00267     line[ <span class="keyword">sizeof</span>(line)-1 ] = 0;
00268     cptr = &amp;line[strlen(line)]; <span class="comment">/* the NULL */</span>
00269 
00270     cptr =
00271         read_config_save_octet_string(cptr,
00272                                       (u_char *) group_entry-&gt;securityName + 1,
00273                                       group_entry-&gt;securityName[0] + 1);
00274     *cptr++ = <span class="charliteral">' '</span>;
00275     cptr = read_config_save_octet_string(cptr, (u_char *) group_entry-&gt;groupName,
00276                                          strlen(group_entry-&gt;groupName) + 1);
00277 
00278     <a class="code" href="group__read__config.html#ga37">read_config_store</a>(type, line);
00279 }
00280 
00281 <span class="keywordtype">void</span>
00282 vacm_parse_config_group(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
00283 {
00284     <span class="keyword">struct </span>vacm_groupEntry group;
00285     <span class="keyword">struct </span>vacm_groupEntry *gptr;
00286     <span class="keywordtype">char</span>           *securityName = (<span class=
"keywordtype">char</span> *) &amp;group.securityName;
00287     <span class="keywordtype">char</span>           *groupName;
00288     size_t          len;
00289 
00290     group.status = atoi(line);
00291     line = skip_token(line);
00292     group.storageType = atoi(line);
00293     line = skip_token(line);
00294     group.securityModel = atoi(line);
00295     line = skip_token(line);
00296     line =
00297         read_config_read_octet_string(line, (u_char **) &amp; securityName,
00298                                       &amp;len);
00299 
00300     gptr = vacm_createGroupEntry(group.securityModel, group.securityName);
00301     <span class="keywordflow">if</span> (!gptr)
00302         <span class="keywordflow">return</span>;
00303 
00304     gptr-&gt;status = group.status;
00305     gptr-&gt;storageType = group.storageType;
00306     groupName = (<span class="keywordtype">char</span> *) gptr-&gt;groupName;
00307     line =
00308         read_config_read_octet_string(line, (u_char **) &amp; groupName, &amp;len);
00309 }
00310 
00311 <span class="keyword">struct </span>vacm_viewEntry *
00312 vacm_getViewEntry(<span class="keyword">const</span> <span class="keywordtype">char</span> *viewName,
00313                   oid * viewSubtree, size_t viewSubtreeLen, <span class="keywordtype">int</span> mode)
00314 {
00315     <span class="keyword">struct </span>vacm_viewEntry *vp, *vpret = NULL;
00316     <span class="keywordtype">char</span>            view[VACMSTRINGLEN];
00317     <span class="keywordtype">int</span>             found, glen;
00318     <span class="keywordtype">int</span> count=0;
00319 
00320     glen = (int) strlen(viewName);
00321     <span class="keywordflow">if</span> (glen &lt; 0 || glen &gt;= VACM_MAX_STRING)
00322         <span class="keywordflow">return</span> NULL;
00323     view[0] = glen;
00324     strcpy(view + 1, viewName);
00325     <span class="keywordflow">for</span> (vp = viewList; vp; vp = vp-&gt;next) {
00326         <span class="keywordflow">if</span> (!memcmp(view, vp-&gt;viewName, glen + 1)
00327             &amp;&amp; viewSubtreeLen &gt;= (vp-&gt;viewSubtreeLen - 1)) {
00328             <span class="keywordtype">int</span>             mask = 0x80, maskpos = 0;
00329             <span class="keywordtype">int</span>             oidpos;
00330             found = 1;
00331 
00332             <span class="keywordflow">if</span> (mode != VACM_MODE_IGNORE_MASK) {  <span class=
"comment">/* check the mask */</span>
00333                 <span class="keywordflow">for</span> (oidpos = 0;
00334                      found &amp;&amp; oidpos &lt; (int) vp-&gt;viewSubtreeLen - 1;
00335                      oidpos++) {
00336                     <span class="keywordflow">if</span> ((vp-&gt;viewMask[maskpos] &amp; mask) != 0) {
00337                         <span class="keywordflow">if</span> (viewSubtree[oidpos] !=
00338                             vp-&gt;viewSubtree[oidpos + 1])
00339                             found = 0;
00340                     }
00341                     <span class="keywordflow">if</span> (mask == 1) {
00342                         mask = 0x80;
00343                         maskpos++;
00344                     } <span class="keywordflow">else</span>
00345                         mask &gt;&gt;= 1;
00346                 }
00347             }
00348             <span class="keywordflow">if</span> (found) {
00349                 <span class="comment">/*</span>
00350 <span class="comment">                 * match successful, keep this node if its longer than</span>
00351 <span class="comment">                 * the previous or (equal and lexicographically greater</span>
00352 <span class="comment">                 * than the previous). </span>
00353 <span class="comment">                 */</span>
00354                 count++;
00355                 <span class="keywordflow">if</span> (mode == VACM_MODE_CHECK_SUBTREE) {
00356                     vpret = vp;
00357                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vpret == NULL
00358                            || vp-&gt;viewSubtreeLen &gt; vpret-&gt;viewSubtreeLen
00359                            || (vp-&gt;viewSubtreeLen == vpret-&gt;viewSubtreeLen
00360                                &amp;&amp; <a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>(vp-&gt;viewSubtree + 1,
00361                                                    vp-&gt;viewSubtreeLen - 1,
00362                                                    vpret-&gt;viewSubtree + 1,
00363                                                    vpret-&gt;viewSubtreeLen - 1) &gt;
00364                                0)) {
00365                     vpret = vp;
00366                 }
00367             }
00368         }
00369     }
00370     DEBUGMSGTL((<span class="stringliteral">"vacm:getView"</span>, <span class=
"stringliteral">", %s\n"</span>, (vpret) ? <span class="stringliteral">"found"</span> : <span class=
"stringliteral">"none"</span>));
00371     <span class="keywordflow">if</span> (mode == VACM_MODE_CHECK_SUBTREE &amp;&amp; count &gt; 1) {
00372         <span class="keywordflow">return</span> NULL;
00373     }
00374     <span class="keywordflow">return</span> vpret;
00375 }
00376 
00377 <span class="comment">/*******************************************************************o-o******</span>
00378 <span class="comment"> * vacm_checkSubtree</span>
00379 <span class="comment"> *</span>
00380 <span class="comment"> * Check to see if everything within a subtree is in view, not in view,</span>
00381 <span class="comment"> * or possibly both.</span>
00382 <span class="comment"> *</span>
00383 <span class="comment"> * Parameters:</span>
00384 <span class="comment"> *   *viewName           - Name of view to check</span>
00385 <span class="comment"> *   *viewSubtree        - OID of subtree</span>
00386 <span class="comment"> *    viewSubtreeLen     - length of subtree OID</span>
00387 <span class="comment"> *      </span>
00388 <span class="comment"> * Returns:</span>
00389 <span class="comment"> *   VACM_SUCCESS          The OID is included in the view.</span>
00390 <span class="comment"> *   VACM_NOTINVIEW        If no entry in the view list includes the</span>
00391 <span class="comment"> *                         provided OID, or the OID is explicitly excluded</span>
00392 <span class="comment"> *                         from the view. </span>
00393 <span class="comment"> *   VACM_SUBTREE_UNKNOWN  The entire subtree has both allowed and disallowed</span>
00394 <span class="comment"> *                         portions.</span>
00395 <span class="comment"> */</span>
00396 <span class="keywordtype">int</span>
00397 vacm_checkSubtree(<span class="keyword">const</span> <span class="keywordtype">char</span> *viewName,
00398                   oid * viewSubtree, size_t viewSubtreeLen)
00399 {
00400     <span class="keyword">struct </span>vacm_viewEntry *vp, *vpShorter = NULL, *vpLonger = NULL;
00401     <span class="keywordtype">char</span>            view[VACMSTRINGLEN];
00402     <span class="keywordtype">int</span>             found, glen;
00403 
00404     glen = (int) strlen(viewName);
00405     <span class="keywordflow">if</span> (glen &lt; 0 || glen &gt;= VACM_MAX_STRING)
00406         <span class="keywordflow">return</span> VACM_NOTINVIEW;
00407     view[0] = glen;
00408     strcpy(view + 1, viewName);
00409     <span class="keywordflow">for</span> (vp = viewList; vp; vp = vp-&gt;next) {
00410         <span class="keywordflow">if</span> (!memcmp(view, vp-&gt;viewName, glen + 1)) {
00411             <span class="comment">/*</span>
00412 <span class="comment">             * If the subtree defined in the view is shorter than or equal</span>
00413 <span class="comment">             * to the subtree we are comparing, then it might envelop the</span>
00414 <span class="comment">             * subtree we are comparing against.</span>
00415 <span class="comment">             */</span>
00416             <span class="keywordflow">if</span> (viewSubtreeLen &gt;= (vp-&gt;viewSubtreeLen - 1)) {
00417                 <span class="keywordtype">int</span>             mask = 0x80, maskpos = 0;
00418                 <span class="keywordtype">int</span>             oidpos;
00419                 found = 1;
00420 
00421                 <span class="comment">/*</span>
00422 <span class="comment">                 * check the mask</span>
00423 <span class="comment">                 */</span>
00424                 <span class="keywordflow">for</span> (oidpos = 0;
00425                      found &amp;&amp; oidpos &lt; (int) vp-&gt;viewSubtreeLen - 1;
00426                      oidpos++) {
00427                     <span class="keywordflow">if</span> ((vp-&gt;viewMask[maskpos] &amp; mask) != 0) {
00428                         <span class="keywordflow">if</span> (viewSubtree[oidpos] !=
00429                             vp-&gt;viewSubtree[oidpos + 1])
00430                             found = 0;
00431                     }
00432                     <span class="keywordflow">if</span> (mask == 1) {
00433                         mask = 0x80;
00434                         maskpos++;
00435                     } <span class="keywordflow">else</span>
00436                         mask &gt;&gt;= 1;
00437                 }
00438 
00439                 <span class="keywordflow">if</span> (found) {
00440                     <span class="comment">/*</span>
00441 <span class="comment">                     * match successful, keep this node if it's longer than</span>
00442 <span class="comment">                     * the previous or (equal and lexicographically greater</span>
00443 <span class="comment">                     * than the previous). </span>
00444 <span class="comment">                     */</span>
00445     
00446                     <span class="keywordflow">if</span> (vpShorter == NULL
00447                         || vp-&gt;viewSubtreeLen &gt; vpShorter-&gt;viewSubtreeLen
00448                         || (vp-&gt;viewSubtreeLen == vpShorter-&gt;viewSubtreeLen
00449                            &amp;&amp; <a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>(vp-&gt;viewSubtree + 1,
00450                                                vp-&gt;viewSubtreeLen - 1,
00451                                                vpShorter-&gt;viewSubtree + 1,
00452                                                vpShorter-&gt;viewSubtreeLen - 1) &gt;
00453                                    0)) {
00454                         vpShorter = vp;
00455                     }
00456                 }
00457             }
00458             <span class="comment">/*</span>
00459 <span class="comment">             * If the subtree defined in the view is longer than the</span>
00460 <span class="comment">             * subtree we are comparing, then it might ambiguate our</span>
00461 <span class="comment">             * response.</span>
00462 <span class="comment">             */</span>
00463             <span class="keywordflow">else</span> {
00464                 <span class="keywordtype">int</span>             mask = 0x80, maskpos = 0;
00465                 <span class="keywordtype">int</span>             oidpos;
00466                 found = 1;
00467 
00468                 <span class="comment">/*</span>
00469 <span class="comment">                 * check the mask up to the length of the provided subtree</span>
00470 <span class="comment">                 */</span>
00471                 <span class="keywordflow">for</span> (oidpos = 0;
00472                      found &amp;&amp; oidpos &lt; (int) viewSubtreeLen;
00473                      oidpos++) {
00474                     <span class="keywordflow">if</span> ((vp-&gt;viewMask[maskpos] &amp; mask) != 0) {
00475                         <span class="keywordflow">if</span> (viewSubtree[oidpos] !=
00476                             vp-&gt;viewSubtree[oidpos + 1])
00477                             found = 0;
00478                     }
00479                     <span class="keywordflow">if</span> (mask == 1) {
00480                         mask = 0x80;
00481                         maskpos++;
00482                     } <span class="keywordflow">else</span>
00483                         mask &gt;&gt;= 1;
00484                 }
00485 
00486                 <span class="keywordflow">if</span> (found) {
00487                     <span class="comment">/*</span>
00488 <span class="comment">                     * match successful.  If we already found a match</span>
00489 <span class="comment">                     * with a different view type, then parts of the subtree </span>
00490 <span class="comment">                     * are included and others are excluded, so return UNKNOWN.</span>
00491 <span class="comment">                     */</span>
00492                     <span class="keywordflow">if</span> (vpLonger != NULL
00493                         &amp;&amp; (vpLonger-&gt;viewType != vp-&gt;viewType)) {
00494                         DEBUGMSGTL((<span class="stringliteral">"vacm:checkSubtree"</span>, <span class=
"stringliteral">", %s\n"</span>, <span class="stringliteral">"unknown"</span>));
00495                         <span class="keywordflow">return</span> VACM_SUBTREE_UNKNOWN;
00496                     }
00497                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vpLonger == NULL) {
00498                         vpLonger = vp;
00499                     }
00500                 }
00501             }
00502         }
00503     }
00504 
00505     <span class="comment">/*</span>
00506 <span class="comment">     * If we found a matching view subtree with a longer OID than the provided</span>
00507 <span class="comment">     * OID, check to see if its type is consistent with any matching view</span>
00508 <span class="comment">     * subtree we may have found with a shorter OID than the provided OID.</span>
00509 <span class="comment">     *</span>
00510 <span class="comment">     * The view type of the longer OID is inconsistent with the shorter OID in</span>
00511 <span class="comment">     * either of these two cases:</span>
00512 <span class="comment">     *  1) No matching shorter OID was found and the view type of the longer</span>
00513 <span class="comment">     *     OID is INCLUDE.</span>
00514 <span class="comment">     *  2) A matching shorter ID was found and its view type doesn't match</span>
00515 <span class="comment">     *     the view type of the longer OID.</span>
00516 <span class="comment">     */</span>
00517     <span class="keywordflow">if</span> (vpLonger != NULL) {
00518         <span class="keywordflow">if</span> ((!vpShorter &amp;&amp; vpLonger-&gt;viewType != SNMP_VIEW_EXCLUDED)
00519             || (vpShorter &amp;&amp; vpLonger-&gt;viewType != vpShorter-&gt;viewType)) {
00520             DEBUGMSGTL((<span class="stringliteral">"vacm:checkSubtree"</span>, <span class=
"stringliteral">", %s\n"</span>, <span class="stringliteral">"unknown"</span>));
00521             <span class="keywordflow">return</span> VACM_SUBTREE_UNKNOWN;
00522         }
00523     }
00524 
00525     <span class="keywordflow">if</span> (vpShorter &amp;&amp; vpShorter-&gt;viewType != SNMP_VIEW_EXCLUDED) {
00526         DEBUGMSGTL((<span class="stringliteral">"vacm:checkSubtree"</span>, <span class=
"stringliteral">", %s\n"</span>, <span class="stringliteral">"included"</span>));
00527         <span class="keywordflow">return</span> VACM_SUCCESS;
00528     }
00529 
00530     DEBUGMSGTL((<span class="stringliteral">"vacm:checkSubtree"</span>, <span class=
"stringliteral">", %s\n"</span>, <span class="stringliteral">"excluded"</span>));
00531     <span class="keywordflow">return</span> VACM_NOTINVIEW;
00532 }
00533 
00534 <span class="keywordtype">void</span>
00535 vacm_scanViewInit(<span class="keywordtype">void</span>)
00536 {
00537     viewScanPtr = viewList;
00538 }
00539 
00540 <span class="keyword">struct </span>vacm_viewEntry *
00541 vacm_scanViewNext(<span class="keywordtype">void</span>)
00542 {
00543     <span class="keyword">struct </span>vacm_viewEntry *returnval = viewScanPtr;
00544     <span class="keywordflow">if</span> (viewScanPtr)
00545         viewScanPtr = viewScanPtr-&gt;next;
00546     <span class="keywordflow">return</span> returnval;
00547 }
00548 
00549 <span class="keyword">struct </span>vacm_viewEntry *
00550 vacm_createViewEntry(<span class="keyword">const</span> <span class="keywordtype">char</span> *viewName,
00551                      oid * viewSubtree, size_t viewSubtreeLen)
00552 {
00553     <span class="keyword">struct </span>vacm_viewEntry *vp, *lp, *op = NULL;
00554     <span class="keywordtype">int</span>             cmp, cmp2, glen;
00555 
00556     glen = (int) strlen(viewName);
00557     <span class="keywordflow">if</span> (glen &lt; 0 || glen &gt;= VACM_MAX_STRING)
00558         <span class="keywordflow">return</span> NULL;
00559     vp = (<span class="keyword">struct </span>vacm_viewEntry *) calloc(1,
00560                                           <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> vacm_viewEntry));
00561     <span class="keywordflow">if</span> (vp == NULL)
00562         <span class="keywordflow">return</span> NULL;
00563     vp-&gt;reserved =
00564         (<span class="keyword">struct </span>vacm_viewEntry *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> vacm_viewEntry));
00565     <span class="keywordflow">if</span> (vp-&gt;reserved == NULL) {
00566         free(vp);
00567         <span class="keywordflow">return</span> NULL;
00568     }
00569 
00570     vp-&gt;viewName[0] = glen;
00571     strcpy(vp-&gt;viewName + 1, viewName);
00572     vp-&gt;viewSubtree[0] = viewSubtreeLen;
00573     memcpy(vp-&gt;viewSubtree + 1, viewSubtree, viewSubtreeLen * <span class="keyword">sizeof</span>(oid));
00574     vp-&gt;viewSubtreeLen = viewSubtreeLen + 1;
00575 
00576     lp = viewList;
00577     <span class="keywordflow">while</span> (lp) {
00578         cmp = memcmp(lp-&gt;viewName, vp-&gt;viewName, glen + 1);
00579         cmp2 = <a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>(lp-&gt;viewSubtree, lp-&gt;viewSubtreeLen,
00580                                 vp-&gt;viewSubtree, vp-&gt;viewSubtreeLen);
00581         <span class="keywordflow">if</span> (cmp == 0 &amp;&amp; cmp2 &gt; 0)
00582             <span class="keywordflow">break</span>;
00583         <span class="keywordflow">if</span> (cmp &gt; 0)
00584             <span class="keywordflow">break</span>;
00585         op = lp;
00586         lp = lp-&gt;next;
00587     }
00588     vp-&gt;next = lp;
00589     <span class="keywordflow">if</span> (op)
00590         op-&gt;next = vp;
00591     <span class="keywordflow">else</span>
00592         viewList = vp;
00593     <span class="keywordflow">return</span> vp;
00594 }
00595 
00596 <span class="keywordtype">void</span>
00597 vacm_destroyViewEntry(<span class="keyword">const</span> <span class="keywordtype">char</span> *viewName,
00598                       oid * viewSubtree, size_t viewSubtreeLen)
00599 {
00600     <span class="keyword">struct </span>vacm_viewEntry *vp, *lastvp = NULL;
00601 
00602     <span class="keywordflow">if</span> (viewList &amp;&amp; !strcmp(viewList-&gt;viewName + 1, viewName)
00603         &amp;&amp; viewList-&gt;viewSubtreeLen == viewSubtreeLen
00604         &amp;&amp; !memcmp((<span class="keywordtype">char</span> *) viewList-&gt;viewSubtree, (<span class=
"keywordtype">char</span> *) viewSubtree,
00605                    viewSubtreeLen * <span class="keyword">sizeof</span>(oid))) {
00606         vp = viewList;
00607         viewList = viewList-&gt;next;
00608     } <span class="keywordflow">else</span> {
00609         <span class="keywordflow">for</span> (vp = viewList; vp; vp = vp-&gt;next) {
00610             <span class="keywordflow">if</span> (!strcmp(vp-&gt;viewName + 1, viewName)
00611                 &amp;&amp; vp-&gt;viewSubtreeLen == viewSubtreeLen
00612                 &amp;&amp; !memcmp((<span class="keywordtype">char</span> *) vp-&gt;viewSubtree, (<span class=
"keywordtype">char</span> *) viewSubtree,
00613                            viewSubtreeLen * <span class="keyword">sizeof</span>(oid)))
00614                 <span class="keywordflow">break</span>;
00615             lastvp = vp;
00616         }
00617         <span class="keywordflow">if</span> (!vp)
00618             <span class="keywordflow">return</span>;
00619         lastvp-&gt;next = vp-&gt;next;
00620     }
00621     <span class="keywordflow">if</span> (vp-&gt;reserved)
00622         free(vp-&gt;reserved);
00623     free(vp);
00624     <span class="keywordflow">return</span>;
00625 }
00626 
00627 <span class="keywordtype">void</span>
00628 vacm_destroyAllViewEntries(<span class="keywordtype">void</span>)
00629 {
00630     <span class="keyword">struct </span>vacm_viewEntry *vp;
00631     <span class="keywordflow">while</span> ((vp = viewList)) {
00632         viewList = vp-&gt;next;
00633         <span class="keywordflow">if</span> (vp-&gt;reserved)
00634             free(vp-&gt;reserved);
00635         free(vp);
00636     }
00637 }
00638 
00639 <span class="keyword">struct </span>vacm_groupEntry *
00640 vacm_getGroupEntry(<span class="keywordtype">int</span> securityModel, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *securityName)
00641 {
00642     <span class="keyword">struct </span>vacm_groupEntry *vp;
00643     <span class="keywordtype">char</span>            secname[VACMSTRINGLEN];
00644     <span class="keywordtype">int</span>             glen;
00645 
00646     glen = (int) strlen(securityName);
00647     <span class="keywordflow">if</span> (glen &lt; 0 || glen &gt;= VACM_MAX_STRING)
00648         <span class="keywordflow">return</span> NULL;
00649     secname[0] = glen;
00650     strcpy(secname + 1, securityName);
00651 
00652     <span class="keywordflow">for</span> (vp = groupList; vp; vp = vp-&gt;next) {
00653         <span class="keywordflow">if</span> ((securityModel == vp-&gt;securityModel
00654              || vp-&gt;securityModel == SNMP_SEC_MODEL_ANY)
00655             &amp;&amp; !memcmp(vp-&gt;securityName, secname, glen + 1))
00656             <span class="keywordflow">return</span> vp;
00657     }
00658     <span class="keywordflow">return</span> NULL;
00659 }
00660 
00661 <span class="keywordtype">void</span>
00662 vacm_scanGroupInit(<span class="keywordtype">void</span>)
00663 {
00664     groupScanPtr = groupList;
00665 }
00666 
00667 <span class="keyword">struct </span>vacm_groupEntry *
00668 vacm_scanGroupNext(<span class="keywordtype">void</span>)
00669 {
00670     <span class="keyword">struct </span>vacm_groupEntry *returnval = groupScanPtr;
00671     <span class="keywordflow">if</span> (groupScanPtr)
00672         groupScanPtr = groupScanPtr-&gt;next;
00673     <span class="keywordflow">return</span> returnval;
00674 }
00675 
00676 <span class="keyword">struct </span>vacm_groupEntry *
00677 vacm_createGroupEntry(<span class="keywordtype">int</span> securityModel, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *securityName)
00678 {
00679     <span class="keyword">struct </span>vacm_groupEntry *gp, *lg, *og;
00680     <span class="keywordtype">int</span>             cmp, glen;
00681 
00682     glen = (int) strlen(securityName);
00683     <span class="keywordflow">if</span> (glen &lt; 0 || glen &gt;= VACM_MAX_STRING)
00684         <span class="keywordflow">return</span> NULL;
00685     gp = (<span class="keyword">struct </span>vacm_groupEntry *) calloc(1,
00686                                            <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> vacm_groupEntry));
00687     <span class="keywordflow">if</span> (gp == NULL)
00688         <span class="keywordflow">return</span> NULL;
00689     gp-&gt;reserved =
00690         (<span class="keyword">struct </span>vacm_groupEntry *) calloc(1,
00691                                           <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> vacm_groupEntry));
00692     <span class="keywordflow">if</span> (gp-&gt;reserved == NULL) {
00693         free(gp);
00694         <span class="keywordflow">return</span> NULL;
00695     }
00696 
00697     gp-&gt;securityModel = securityModel;
00698     gp-&gt;securityName[0] = glen;
00699     strcpy(gp-&gt;securityName + 1, securityName);
00700 
00701     lg = groupList;
00702     og = NULL;
00703     <span class="keywordflow">while</span> (lg) {
00704         <span class="keywordflow">if</span> (lg-&gt;securityModel &gt; securityModel)
00705             <span class="keywordflow">break</span>;
00706         <span class="keywordflow">if</span> (lg-&gt;securityModel == securityModel &amp;&amp;
00707             (cmp =
00708              memcmp(lg-&gt;securityName, gp-&gt;securityName, glen + 1)) &gt; 0)
00709             <span class="keywordflow">break</span>;
00710         <span class="comment">/*</span>
00711 <span class="comment">         * if (lg-&gt;securityModel == securityModel &amp;&amp; cmp == 0) abort(); </span>
00712 <span class="comment">         */</span>
00713         og = lg;
00714         lg = lg-&gt;next;
00715     }
00716     gp-&gt;next = lg;
00717     <span class="keywordflow">if</span> (og == NULL)
00718         groupList = gp;
00719     <span class="keywordflow">else</span>
00720         og-&gt;next = gp;
00721     <span class="keywordflow">return</span> gp;
00722 }
00723 
00724 <span class="keywordtype">void</span>
00725 vacm_destroyGroupEntry(<span class="keywordtype">int</span> securityModel, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *securityName)
00726 {
00727     <span class="keyword">struct </span>vacm_groupEntry *vp, *lastvp = NULL;
00728 
00729     <span class="keywordflow">if</span> (groupList &amp;&amp; groupList-&gt;securityModel == securityModel
00730         &amp;&amp; !strcmp(groupList-&gt;securityName + 1, securityName)) {
00731         vp = groupList;
00732         groupList = groupList-&gt;next;
00733     } <span class="keywordflow">else</span> {
00734         <span class="keywordflow">for</span> (vp = groupList; vp; vp = vp-&gt;next) {
00735             <span class="keywordflow">if</span> (vp-&gt;securityModel == securityModel
00736                 &amp;&amp; !strcmp(vp-&gt;securityName + 1, securityName))
00737                 <span class="keywordflow">break</span>;
00738             lastvp = vp;
00739         }
00740         <span class="keywordflow">if</span> (!vp)
00741             <span class="keywordflow">return</span>;
00742         lastvp-&gt;next = vp-&gt;next;
00743     }
00744     <span class="keywordflow">if</span> (vp-&gt;reserved)
00745         free(vp-&gt;reserved);
00746     free(vp);
00747     <span class="keywordflow">return</span>;
00748 }
00749 
00750 <span class="keywordtype">void</span>
00751 vacm_destroyAllGroupEntries(<span class="keywordtype">void</span>)
00752 {
00753     <span class="keyword">struct </span>vacm_groupEntry *gp;
00754     <span class="keywordflow">while</span> ((gp = groupList)) {
00755         groupList = gp-&gt;next;
00756         <span class="keywordflow">if</span> (gp-&gt;reserved)
00757             free(gp-&gt;reserved);
00758         free(gp);
00759     }
00760 }
00761 
00762 <span class="keyword">struct </span>vacm_accessEntry *
00763 vacm_getAccessEntry(<span class="keyword">const</span> <span class="keywordtype">char</span> *groupName,
00764                     <span class="keyword">const</span> <span class="keywordtype">char</span> *contextPrefix,
00765                     <span class="keywordtype">int</span> securityModel, <span class="keywordtype">int</span> securityLevel)
00766 {
00767     <span class="keyword">struct </span>vacm_accessEntry *vp;
00768     <span class="keywordtype">char</span>            group[VACMSTRINGLEN];
00769     <span class="keywordtype">char</span>            context[VACMSTRINGLEN];
00770     <span class="keywordtype">int</span>             glen, clen;
00771 
00772     glen = (int) strlen(groupName);
00773     <span class="keywordflow">if</span> (glen &lt; 0 || glen &gt;= VACM_MAX_STRING)
00774         <span class="keywordflow">return</span> NULL;
00775     clen = (int) strlen(contextPrefix);
00776     <span class="keywordflow">if</span> (clen &lt; 0 || clen &gt;= VACM_MAX_STRING)
00777         <span class="keywordflow">return</span> NULL;
00778 
00779     group[0] = glen;
00780     strcpy(group + 1, groupName);
00781     context[0] = clen;
00782     strcpy(context + 1, contextPrefix);
00783     <span class="keywordflow">for</span> (vp = accessList; vp; vp = vp-&gt;next) {
00784         <span class="keywordflow">if</span> ((securityModel == vp-&gt;securityModel
00785              || vp-&gt;securityModel == SNMP_SEC_MODEL_ANY)
00786             &amp;&amp; securityLevel &gt;= vp-&gt;securityLevel
00787             &amp;&amp; !memcmp(vp-&gt;groupName, group, glen + 1)
00788             &amp;&amp;
00789             ((vp-&gt;contextMatch == CONTEXT_MATCH_EXACT
00790               &amp;&amp; clen == vp-&gt;contextPrefix[0]
00791               &amp;&amp; (memcmp(vp-&gt;contextPrefix, context, clen + 1) == 0))
00792              || (vp-&gt;contextMatch == CONTEXT_MATCH_PREFIX
00793                  &amp;&amp; clen &gt;= vp-&gt;contextPrefix[0]
00794                  &amp;&amp; (memcmp(vp-&gt;contextPrefix + 1, context + 1,
00795                             vp-&gt;contextPrefix[0]) == 0))))
00796             <span class="keywordflow">return</span> vp;
00797     }
00798     <span class="keywordflow">return</span> NULL;
00799 }
00800 
00801 <span class="keywordtype">void</span>
00802 vacm_scanAccessInit(<span class="keywordtype">void</span>)
00803 {
00804     accessScanPtr = accessList;
00805 }
00806 
00807 <span class="keyword">struct </span>vacm_accessEntry *
00808 vacm_scanAccessNext(<span class="keywordtype">void</span>)
00809 {
00810     <span class="keyword">struct </span>vacm_accessEntry *returnval = accessScanPtr;
00811     <span class="keywordflow">if</span> (accessScanPtr)
00812         accessScanPtr = accessScanPtr-&gt;next;
00813     <span class="keywordflow">return</span> returnval;
00814 }
00815 
00816 <span class="keyword">struct </span>vacm_accessEntry *
00817 vacm_createAccessEntry(<span class="keyword">const</span> <span class="keywordtype">char</span> *groupName,
00818                        <span class="keyword">const</span> <span class="keywordtype">char</span> *contextPrefix,
00819                        <span class="keywordtype">int</span> securityModel, <span class=
"keywordtype">int</span> securityLevel)
00820 {
00821     <span class="keyword">struct </span>vacm_accessEntry *vp, *lp, *op = NULL;
00822     <span class="keywordtype">int</span>             cmp, glen, clen;
00823 
00824     glen = (int) strlen(groupName);
00825     <span class="keywordflow">if</span> (glen &lt; 0 || glen &gt;= VACM_MAX_STRING)
00826         <span class="keywordflow">return</span> NULL;
00827     clen = (int) strlen(contextPrefix);
00828     <span class="keywordflow">if</span> (clen &lt; 0 || clen &gt;= VACM_MAX_STRING)
00829         <span class="keywordflow">return</span> NULL;
00830     vp = (<span class="keyword">struct </span>vacm_accessEntry *) calloc(1,
00831                                             <span class="keyword">sizeof</span>(<span class="keyword">struct</span>
00832                                                    vacm_accessEntry));
00833     <span class="keywordflow">if</span> (vp == NULL)
00834         <span class="keywordflow">return</span> NULL;
00835     vp-&gt;reserved =
00836         (<span class="keyword">struct </span>vacm_accessEntry *) calloc(1,
00837                                            <span class="keyword">sizeof</span>(<span class="keyword">struct</span>
00838                                                   vacm_accessEntry));
00839     <span class="keywordflow">if</span> (vp-&gt;reserved == NULL) {
00840         free(vp);
00841         <span class="keywordflow">return</span> NULL;
00842     }
00843 
00844     vp-&gt;securityModel = securityModel;
00845     vp-&gt;securityLevel = securityLevel;
00846     vp-&gt;groupName[0] = glen;
00847     strcpy(vp-&gt;groupName + 1, groupName);
00848     vp-&gt;contextPrefix[0] = clen;
00849     strcpy(vp-&gt;contextPrefix + 1, contextPrefix);
00850 
00851     lp = accessList;
00852     <span class="keywordflow">while</span> (lp) {
00853         cmp = memcmp(lp-&gt;groupName, vp-&gt;groupName, glen + 1);
00854         <span class="keywordflow">if</span> (cmp &gt; 0)
00855             <span class="keywordflow">break</span>;
00856         <span class="keywordflow">if</span> (cmp &lt; 0)
00857             <span class="keywordflow">goto</span> next;
00858         cmp = memcmp(lp-&gt;contextPrefix, vp-&gt;contextPrefix, clen + 1);
00859         <span class="keywordflow">if</span> (cmp &gt; 0)
00860             <span class="keywordflow">break</span>;
00861         <span class="keywordflow">if</span> (cmp &lt; 0)
00862             <span class="keywordflow">goto</span> next;
00863         <span class="keywordflow">if</span> (lp-&gt;securityModel &lt; securityModel)
00864             <span class="keywordflow">break</span>;
00865         <span class="keywordflow">if</span> (lp-&gt;securityModel &gt; securityModel)
00866             <span class="keywordflow">goto</span> next;
00867         <span class="keywordflow">if</span> (lp-&gt;securityLevel &lt; securityLevel)
00868             <span class="keywordflow">break</span>;
00869       next:
00870         op = lp;
00871         lp = lp-&gt;next;
00872     }
00873     vp-&gt;next = lp;
00874     <span class="keywordflow">if</span> (op == NULL)
00875         accessList = vp;
00876     <span class="keywordflow">else</span>
00877         op-&gt;next = vp;
00878     <span class="keywordflow">return</span> vp;
00879 }
00880 
00881 <span class="keywordtype">void</span>
00882 vacm_destroyAccessEntry(<span class="keyword">const</span> <span class="keywordtype">char</span> *groupName,
00883                         <span class="keyword">const</span> <span class="keywordtype">char</span> *contextPrefix,
00884                         <span class="keywordtype">int</span> securityModel, <span class=
"keywordtype">int</span> securityLevel)
00885 {
00886     <span class="keyword">struct </span>vacm_accessEntry *vp, *lastvp = NULL;
00887 
00888     <span class="keywordflow">if</span> (accessList &amp;&amp; accessList-&gt;securityModel == securityModel
00889         &amp;&amp; accessList-&gt;securityLevel == securityLevel
00890         &amp;&amp; !strcmp(accessList-&gt;groupName + 1, groupName)
00891         &amp;&amp; !strcmp(accessList-&gt;contextPrefix + 1, contextPrefix)) {
00892         vp = accessList;
00893         accessList = accessList-&gt;next;
00894     } <span class="keywordflow">else</span> {
00895         <span class="keywordflow">for</span> (vp = accessList; vp; vp = vp-&gt;next) {
00896             <span class="keywordflow">if</span> (vp-&gt;securityModel == securityModel
00897                 &amp;&amp; vp-&gt;securityLevel == securityLevel
00898                 &amp;&amp; !strcmp(vp-&gt;groupName + 1, groupName)
00899                 &amp;&amp; !strcmp(vp-&gt;contextPrefix + 1, contextPrefix))
00900                 <span class="keywordflow">break</span>;
00901             lastvp = vp;
00902         }
00903         <span class="keywordflow">if</span> (!vp)
00904             <span class="keywordflow">return</span>;
00905         lastvp-&gt;next = vp-&gt;next;
00906     }
00907     <span class="keywordflow">if</span> (vp-&gt;reserved)
00908         free(vp-&gt;reserved);
00909     free(vp);
00910     <span class="keywordflow">return</span>;
00911 }
00912 
00913 <span class="keywordtype">void</span>
00914 vacm_destroyAllAccessEntries(<span class="keywordtype">void</span>)
00915 {
00916     <span class="keyword">struct </span>vacm_accessEntry *ap;
00917     <span class="keywordflow">while</span> ((ap = accessList)) {
00918         accessList = ap-&gt;next;
00919         <span class="keywordflow">if</span> (ap-&gt;reserved)
00920             free(ap-&gt;reserved);
00921         free(ap);
00922     }
00923 }
00924 
00925 <span class="keywordtype">int</span>
00926 store_vacm(<span class="keywordtype">int</span> majorID, <span class="keywordtype">int</span> minorID, <span class=
"keywordtype">void</span> *serverarg, <span class="keywordtype">void</span> *clientarg)
00927 {
00928     <span class="comment">/*</span>
00929 <span class="comment">     * figure out our application name </span>
00930 <span class="comment">     */</span>
00931     <span class="keywordtype">char</span>           *appname = (<span class="keywordtype">char</span> *) clientarg;
00932     <span class="keywordflow">if</span> (appname == NULL) {
00933         appname = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
00934                                         NETSNMP_DS_LIB_APPTYPE);
00935     }
00936 
00937     <span class="comment">/*</span>
00938 <span class="comment">     * save the VACM MIB </span>
00939 <span class="comment">     */</span>
00940     vacm_save(<span class="stringliteral">"vacm"</span>, appname);
00941     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
00942 }
00943 
00944 <span class="comment">/*</span>
00945 <span class="comment"> * returns 1 if vacm has *any* configuration entries in it (regardless</span>
00946 <span class="comment"> * of weather or not there is enough to make a decision based on it),</span>
00947 <span class="comment"> * else return 0 </span>
00948 <span class="comment"> */</span>
00949 <span class="keywordtype">int</span>
00950 vacm_is_configured(<span class="keywordtype">void</span>)
00951 {
00952     <span class="keywordflow">if</span> (viewList == NULL &amp;&amp; accessList == NULL &amp;&amp; groupList == NULL) {
00953         <span class="keywordflow">return</span> 0;
00954     }
00955     <span class="keywordflow">return</span> 1;
00956 }
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small><!--#include virtual="/sfbutton.html" --><br />
    Generated on Thu Nov 25 17:51:43 2004 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

