<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>net-snmp: Memory Utility Routines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">net-snmp&#160;<span id="projectnumber">5.7</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory Utility Routines</div>  </div>
<div class="ingroups"><a class="el" href="group__library.html">The Net-SNMP library</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga688c3aa414ca0df35b96ee5887c96a6f"></a><!-- doxytag: member="util::SNMP_MAXPATH" ref="ga688c3aa414ca0df35b96ee5887c96a6f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNMP_MAXPATH</b>&#160;&#160;&#160;1024</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd4a3c52fccbeb0c1e59e526410359af"></a><!-- doxytag: member="util::SNMP_MAXBUF" ref="gadd4a3c52fccbeb0c1e59e526410359af" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNMP_MAXBUF</b>&#160;&#160;&#160;(1024 * 4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ec66fd78ae497a04fccbbca1d83db72"></a><!-- doxytag: member="util::SNMP_MAXBUF_MEDIUM" ref="ga2ec66fd78ae497a04fccbbca1d83db72" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNMP_MAXBUF_MEDIUM</b>&#160;&#160;&#160;1024</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9c464d6073f6e6363a790b73201032bd"></a><!-- doxytag: member="util::SNMP_MAXBUF_SMALL" ref="ga9c464d6073f6e6363a790b73201032bd" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNMP_MAXBUF_SMALL</b>&#160;&#160;&#160;512</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga15444598872922f2904b3eae9122ef4b"></a><!-- doxytag: member="util::SNMP_MAXBUF_MESSAGE" ref="ga15444598872922f2904b3eae9122ef4b" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNMP_MAXBUF_MESSAGE</b>&#160;&#160;&#160;1500</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae7ee3a2dedea11458fb7e7bd3eb0c870"></a><!-- doxytag: member="util::SNMP_MAXOID" ref="gae7ee3a2dedea11458fb7e7bd3eb0c870" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNMP_MAXOID</b>&#160;&#160;&#160;64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2f677cec78aa9fc04c649c1286d30b39"></a><!-- doxytag: member="util::SNMP_MAX_CMDLINE_OIDS" ref="ga2f677cec78aa9fc04c649c1286d30b39" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNMP_MAX_CMDLINE_OIDS</b>&#160;&#160;&#160;128</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga01fdf844512e930bb3ecddac4fe56c6e"></a><!-- doxytag: member="util::SNMP_FILEMODE_CLOSED" ref="ga01fdf844512e930bb3ecddac4fe56c6e" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNMP_FILEMODE_CLOSED</b>&#160;&#160;&#160;0600</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3ba9dd1e300d94b4bba1f76f00df297f"></a><!-- doxytag: member="util::SNMP_FILEMODE_OPEN" ref="ga3ba9dd1e300d94b4bba1f76f00df297f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNMP_FILEMODE_OPEN</b>&#160;&#160;&#160;0644</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa04cfd9a988babfbfbc6bd909ed883be"></a><!-- doxytag: member="util::BYTESIZE" ref="gaa04cfd9a988babfbfbc6bd909ed883be" args="(bitsize)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BYTESIZE</b>(bitsize)&#160;&#160;&#160;((bitsize + 7) &gt;&gt; 3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae0349e25aed55824890bb7bd2fa6af3e"></a><!-- doxytag: member="util::ROUNDUP8" ref="gae0349e25aed55824890bb7bd2fa6af3e" args="(x)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ROUNDUP8</b>(x)&#160;&#160;&#160;( ( (x+7) &gt;&gt; 3 ) * 8 )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9ee6d897f46cceb17af49d7ff9325e24"></a><!-- doxytag: member="util::SNMP_STRORNULL" ref="ga9ee6d897f46cceb17af49d7ff9325e24" args="(x)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNMP_STRORNULL</b>(x)&#160;&#160;&#160;( x ? x : &quot;(null)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6">SNMP_FREE</a>(s)&#160;&#160;&#160;do { if (s) { free((void *)s); s=NULL; } } while(0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a pointer only if it is !NULL and sets its value to NULL.  <a href="#ga951e93edb6f0ea941e26155e3f8912a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga15e5a68e6d21430ddd4312fec64e5027">SNMP_SWIPE_MEM</a>(n, s)&#160;&#160;&#160;do { if (n) free((void *)n); n = s; s=NULL; } while(0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees pointer n only if it is !NULL, sets n to s and sets s to NULL.  <a href="#ga15e5a68e6d21430ddd4312fec64e5027"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga6356941968481380ea6f4a646df4aaf9">SNMP_MALLOC_STRUCT</a>(s)&#160;&#160;&#160;(struct s *) calloc(1, sizeof(struct s))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mallocs memory of sizeof(struct s), zeros it and returns a pointer to it.  <a href="#ga6356941968481380ea6f4a646df4aaf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424">SNMP_MALLOC_TYPEDEF</a>(td)&#160;&#160;&#160;(td *) calloc(1, sizeof(td))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mallocs memory of sizeof(t), zeros it and returns a pointer to it.  <a href="#ga9cd013bb193de5048149afeb9d94e424"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga190280d08c828c153ec2755b9c263227">SNMP_ZERO</a>(s, l)&#160;&#160;&#160;do { if (s) memset(s, 0, l); } while(0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeros l bytes of memory starting at s.  <a href="#ga190280d08c828c153ec2755b9c263227"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga6310fec832043acba37f99871097b137">NETSNMP_REMOVE_CONST</a>(t, e)&#160;&#160;&#160;((t)(uintptr_t)(e))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast away constness without that gcc -Wcast-qual prints a compiler warning, similar to const_cast&lt;&gt; in C++.  <a href="#ga6310fec832043acba37f99871097b137"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab54417c7c018570043920af66ba7457f"></a><!-- doxytag: member="util::TOUPPER" ref="gab54417c7c018570043920af66ba7457f" args="(c)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TOUPPER</b>(c)&#160;&#160;&#160;(c &gt;= 'a' &amp;&amp; c &lt;= 'z' ? c - ('a' - 'A') : c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4771ad2e5dd6a87c83ecf879b7985de"></a><!-- doxytag: member="util::TOLOWER" ref="gad4771ad2e5dd6a87c83ecf879b7985de" args="(c)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TOLOWER</b>(c)&#160;&#160;&#160;(c &gt;= 'A' &amp;&amp; c &lt;= 'Z' ? c + ('a' - 'A') : c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga10334939731a211462809df2ec1ae597"></a><!-- doxytag: member="util::HEX2VAL" ref="ga10334939731a211462809df2ec1ae597" args="(s)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HEX2VAL</b>(s)&#160;&#160;&#160;((isalpha(s) ? (TOLOWER(s)-'a'+10) : (TOLOWER(s)-'0')) &amp; 0xf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7e6e411a3c5e530ed96926a6801e3c20"></a><!-- doxytag: member="util::VAL2HEX" ref="ga7e6e411a3c5e530ed96926a6801e3c20" args="(s)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VAL2HEX</b>(s)&#160;&#160;&#160;( (s) + (((s) &gt;= 10) ? ('a'-10) : '0') )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaa70d7b83d1001df95cf64280e9545564">SNMP_MAX</a>(a, b)&#160;&#160;&#160;((a) &gt; (b) ? (a) : (b))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computers the maximum of a and b.  <a href="#gaa70d7b83d1001df95cf64280e9545564"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gad1976dec11cfd62abaa4ecedad948f18">SNMP_MIN</a>(a, b)&#160;&#160;&#160;((a) &gt; (b) ? (b) : (a))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computers the minimum of a and b.  <a href="#gad1976dec11cfd62abaa4ecedad948f18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga5d58fec0dd81779c027ad243253897e0">SNMP_MACRO_VAL_TO_STR</a>(s)&#160;&#160;&#160;SNMP_MACRO_VAL_TO_STR_PRIV(s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands to string with value of the s.  <a href="#ga5d58fec0dd81779c027ad243253897e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8fadb3abdda9cd683d2b4b46a6b5f32d"></a><!-- doxytag: member="util::SNMP_MACRO_VAL_TO_STR_PRIV" ref="ga8fadb3abdda9cd683d2b4b46a6b5f32d" args="(s)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNMP_MACRO_VAL_TO_STR_PRIV</b>(s)&#160;&#160;&#160;#s</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa93f0eb578d23995850d61f7d61c55c1"></a><!-- doxytag: member="util::FALSE" ref="gaa93f0eb578d23995850d61f7d61c55c1" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FALSE</b>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa8cecfc5c5c054d2875c03e77b7be15d"></a><!-- doxytag: member="util::TRUE" ref="gaa8cecfc5c5c054d2875c03e77b7be15d" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TRUE</b>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>QUITFUN</b>(e, l)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>DIFFTIMEVAL</b>(now, then, diff)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga52bf06a90b4e0c92165051ff38023c26">NETSNMP_TIMERADD</a>(a, b, res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute res = a + b.  <a href="#ga52bf06a90b4e0c92165051ff38023c26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga0d9f88130fa5677416b8f1c513826e0b">NETSNMP_TIMERSUB</a>(a, b, res)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute res = a - b.  <a href="#ga0d9f88130fa5677416b8f1c513826e0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae96b45b99bccd0eb7ed9e9766dbe00c9"></a><!-- doxytag: member="util::USM_LENGTH_OID_TRANSFORM" ref="gae96b45b99bccd0eb7ed9e9766dbe00c9" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>USM_LENGTH_OID_TRANSFORM</b>&#160;&#160;&#160;10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>ISTRANSFORM</b>(ttype, toid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga72aa0161c1a423e4e95bfd8069bc91b4"></a><!-- doxytag: member="util::ENGINETIME_MAX" ref="ga72aa0161c1a423e4e95bfd8069bc91b4" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ENGINETIME_MAX</b>&#160;&#160;&#160;2147483647</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga476dd2e72571d762f3a6c6831735675e"></a><!-- doxytag: member="util::ENGINEBOOT_MAX" ref="ga476dd2e72571d762f3a6c6831735675e" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ENGINEBOOT_MAX</b>&#160;&#160;&#160;2147483647</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab133b4957931586fabc6ea31b2b76b6d"></a><!-- doxytag: member="util::snmp_cstrcat" ref="gab133b4957931586fabc6ea31b2b76b6d" args="(b, l, o, a, s)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>snmp_cstrcat</b>(b, l, o, a, s)&#160;&#160;&#160;snmp_strcat(b,l,o,a,(const u_char *)s)</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaf7a2cb94c76e0414a050651bba3a7c89">marker_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to an opaque time marker value.  <a href="#gaf7a2cb94c76e0414a050651bba3a7c89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf790716792af33ac05a86c6f2d4ec755"></a><!-- doxytag: member="util::const_marker_t" ref="gaf790716792af33ac05a86c6f2d4ec755" args="" -->
typedef const void *&#160;</td><td class="memItemRight" valign="bottom"><b>const_marker_t</b></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga40652bb342e382d783e3a1ff9a0ddc6f">snmp_realloc</a> (u_char **buf, size_t *buf_len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function increase the size of the buffer pointed at by *buf, which is initially of size *buf_len.  <a href="#ga40652bb342e382d783e3a1ff9a0ddc6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga26a103aafde4d6dcf72c8e30c7d05bd9">free_zero</a> (void *buf, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">zeros memory before freeing it.  <a href="#ga26a103aafde4d6dcf72c8e30c7d05bd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u_char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga76b7f8b21c44e2f8b274a0db8b57d5a1">malloc_random</a> (size_t *size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to allocaed &amp; set buffer on success, size contains number of random bytes filled.  <a href="#ga76b7f8b21c44e2f8b274a0db8b57d5a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf8c38f67fb20fad45695c2b9bca249e5"></a><!-- doxytag: member="util::malloc_zero" ref="gaf8c38f67fb20fad45695c2b9bca249e5" args="(size_t size)" -->
u_char *&#160;</td><td class="memItemRight" valign="bottom"><b>malloc_zero</b> (size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga098ada1e30ad7ee207ba90b73db7000a">memdup</a> (u_char **to, const void *from, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates a memory block.  <a href="#ga098ada1e30ad7ee207ba90b73db7000a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga90238b6a9eaedea5f09cf8ddb45f8bfe">netsnmp_check_definedness</a> (const void *packet, size_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">When running under Valgrind, check whether all bytes in the range [packet, packet+length) are defined.  <a href="#ga90238b6a9eaedea5f09cf8ddb45f8bfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_IMPORT u_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga9e77aebe2205db278a97e1cc57e8b14d">netsnmp_binary_to_hex</a> (u_char **dest, size_t *dest_len, int allow_realloc, const u_char *input, size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts binary to hexidecimal  <a href="#ga9e77aebe2205db278a97e1cc57e8b14d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_IMPORT u_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gae8a7a7b45158226de729f10af5e6a8e0">binary_to_hex</a> (const u_char *input, size_t len, char **output)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts binary to hexidecimal  <a href="#gae8a7a7b45158226de729f10af5e6a8e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga8c1a230e987560600de9f81e55480c0a">netsnmp_hex_to_binary</a> (u_char **buf, size_t *buf_len, size_t *offset, int allow_realloc, const char *hex, const char *delim)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">convert an ASCII hex string (with specified delimiters) to binary  <a href="#ga8c1a230e987560600de9f81e55480c0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gabcc7d0fd7e0145ef532da8d0949c9131">snmp_hex_to_binary</a> (u_char **buf, size_t *buf_len, size_t *offset, int allow_realloc, const char *hex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">convert an ASCII hex string to binary  <a href="#gabcc7d0fd7e0145ef532da8d0949c9131"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga601b13a13aab88bd74b4f54986d43722">hex_to_binary2</a> (const u_char *input, size_t len, char **output)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">hex_to_binary2  <a href="#ga601b13a13aab88bd74b4f54986d43722"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga78c5499c35e148fccbe7ce0afcb46dc0"></a><!-- doxytag: member="util::snmp_decimal_to_binary" ref="ga78c5499c35e148fccbe7ce0afcb46dc0" args="(u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const char *decimal)" -->
NETSNMP_IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><b>snmp_decimal_to_binary</b> (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const char *decimal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaae360e54e7ef8ff27354f0969375bde1"></a><!-- doxytag: member="util::snmp_strcat" ref="gaae360e54e7ef8ff27354f0969375bde1" args="(u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const u_char *s)" -->
NETSNMP_IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><b>snmp_strcat</b> (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const u_char *s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_IMPORT char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga939f4b1177b3980545eadce70148c41b">netsnmp_strdup_and_null</a> (const u_char *from, size_t from_len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copies a (possible) unterminated string of a given length into a new buffer and null terminates it as well (new buffer MAY be one byte longer to account for this  <a href="#ga939f4b1177b3980545eadce70148c41b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf4476e22eb909551adff08500c36d643"></a><!-- doxytag: member="util::dump_chunk" ref="gaf4476e22eb909551adff08500c36d643" args="(const char *debugtoken, const char *title, const u_char *buf, int size)" -->
NETSNMP_IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>dump_chunk</b> (const char *debugtoken, const char *title, const u_char *buf, int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaec261f3c0ced150c01f5ea49a3d9b0bf"></a><!-- doxytag: member="util::dump_snmpEngineID" ref="gaec261f3c0ced150c01f5ea49a3d9b0bf" args="(const u_char *buf, size_t *buflen)" -->
char *&#160;</td><td class="memItemRight" valign="bottom"><b>dump_snmpEngineID</b> (const u_char *buf, size_t *buflen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_IMPORT <a class="el" href="group__util.html#gaf7a2cb94c76e0414a050651bba3a7c89">marker_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga0d2cc1553cd4bbdd9f703f62d9ecff5d">atime_newMarker</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new time marker.  <a href="#ga0d2cc1553cd4bbdd9f703f62d9ecff5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_IMPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaff24d4b425df1f36ea5da0d79e7e6860">atime_setMarker</a> (<a class="el" href="group__util.html#gaf7a2cb94c76e0414a050651bba3a7c89">marker_t</a> pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">set a time marker.  <a href="#gaff24d4b425df1f36ea5da0d79e7e6860"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_IMPORT long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga0a394efc345d644fbac92b2e4f6522bb">atime_diff</a> (const_marker_t first, const_marker_t second)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference (in msec) between the two markers.  <a href="#ga0a394efc345d644fbac92b2e4f6522bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u_long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga5b27dd0a0b3adc35a0b6329a005a9bc4">uatime_diff</a> (const_marker_t first, const_marker_t second)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference (in u_long msec) between the two markers.  <a href="#ga5b27dd0a0b3adc35a0b6329a005a9bc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_IMPORT u_long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga7ba38caeffa80fa6aaf19cfb71eaba3b">uatime_hdiff</a> (const_marker_t first, const_marker_t second)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference (in u_long 1/100th secs) between the two markers (functionally this is what sysUpTime needs)  <a href="#ga7ba38caeffa80fa6aaf19cfb71eaba3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gabf4fbd193d32cc00e9fc171a151cc50e">atime_ready</a> (const_marker_t pm, int deltaT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test: Has (marked time plus delta) exceeded current time (in msec) ? Returns 0 if test fails or cannot be tested (no marker).  <a href="#gabf4fbd193d32cc00e9fc171a151cc50e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaa24ec07ac80a68792b95ceeb475a1bb3">uatime_ready</a> (const_marker_t pm, unsigned int deltaT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test: Has (marked time plus delta) exceeded current time (in msec) ? Returns 0 if test fails or cannot be tested (no marker).  <a href="#gaa24ec07ac80a68792b95ceeb475a1bb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gac3eba1d195cd704fec703a133ec48a4b">marker_tticks</a> (const_marker_t pm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of timeTicks since the given marker.  <a href="#gac3eba1d195cd704fec703a133ec48a4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad38528f45390f181e1ee823347e7e49c"></a><!-- doxytag: member="util::timeval_tticks" ref="gad38528f45390f181e1ee823347e7e49c" args="(const struct timeval *tv)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>timeval_tticks</b> (const struct timeval *tv)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga1816d1ce1e701fcbce27b20159433313">netsnmp_getenv</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non Windows: Returns a pointer to the desired environment variable or NULL if the environment variable does not exist.  <a href="#ga1816d1ce1e701fcbce27b20159433313"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga894f095eacb20a9a848d60df4c6f6436"></a><!-- doxytag: member="util::netsnmp_addrstr_hton" ref="ga894f095eacb20a9a848d60df4c6f6436" args="(char *ptr, size_t len)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>netsnmp_addrstr_hton</b> (char *ptr, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NETSNMP_IMPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga15fc22ecd93620a53bb67b5abeafdcf1">netsnmp_string_time_to_secs</a> (const char *time_string)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a time string like 4h and converts it to seconds.  <a href="#ga15fc22ecd93620a53bb67b5abeafdcf1"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gadf702d784ab85e02492b7aa45439b466"></a><!-- doxytag: member="tools.h::DIFFTIMEVAL" ref="gadf702d784ab85e02492b7aa45439b466" args="(now, then, diff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DIFFTIMEVAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">now, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">then, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">diff&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                       \
        now.tv_sec--;                                   \
        now.tv_usec += 1000000L;                        \
        diff.tv_sec  = now.tv_sec  - then.tv_sec;       \
        diff.tv_usec = now.tv_usec - then.tv_usec;      \
        <span class="keywordflow">if</span> (diff.tv_usec &gt; 1000000L){                   \
                diff.tv_usec -= 1000000L;               \
                diff.tv_sec++;                          \
        }                                               \
}
</pre></div>
<p>Definition at line <a class="el" href="tools_8h_source.html#l00152">152</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga683ed1e9aa299b460d28c2ba85dea2ca"></a><!-- doxytag: member="tools.h::ISTRANSFORM" ref="ga683ed1e9aa299b460d28c2ba85dea2ca" args="(ttype, toid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ISTRANSFORM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ttype, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">toid&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">!<a class="code" href="group__library.html#gab5b48a42c19a801547e025ed40b4561e" title="lexicographical compare two object identifiers.">snmp_oid_compare</a>(ttype, USM_LENGTH_OID_TRANSFORM,              \
                usm ## toid ## Protocol, USM_LENGTH_OID_TRANSFORM)
</pre></div>
<p>Definition at line <a class="el" href="tools_8h_source.html#l00207">207</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6310fec832043acba37f99871097b137"></a><!-- doxytag: member="tools.h::NETSNMP_REMOVE_CONST" ref="ga6310fec832043acba37f99871097b137" args="(t, e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NETSNMP_REMOVE_CONST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((t)(uintptr_t)(e))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cast away constness without that gcc -Wcast-qual prints a compiler warning, similar to const_cast&lt;&gt; in C++. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>A pointer type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>An expression of a type that can be assigned to the type (const t). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tools_8h_source.html#l00092">92</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga52bf06a90b4e0c92165051ff38023c26"></a><!-- doxytag: member="tools.h::NETSNMP_TIMERADD" ref="ga52bf06a90b4e0c92165051ff38023c26" args="(a, b, res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NETSNMP_TIMERADD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">res&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                    \
    (res)-&gt;tv_sec  = (a)-&gt;tv_sec  + (b)-&gt;tv_sec;     \
    (res)-&gt;tv_usec = (a)-&gt;tv_usec + (b)-&gt;tv_usec;    \
    <span class="keywordflow">if</span> ((res)-&gt;tv_usec &gt;= 1000000L) {                \
        (res)-&gt;tv_usec -= 1000000L;                  \
        (res)-&gt;tv_sec++;                             \
    }                                                \
}
</pre></div>
<p>Compute res = a + b. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>a and b must be normalized 'struct timeval' values.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>res may be the same variable as one of the operands. In other words, &amp;a == &amp;res || &amp;b == &amp;res may hold. </dd></dl>

<p>Definition at line <a class="el" href="tools_8h_source.html#l00172">172</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0d9f88130fa5677416b8f1c513826e0b"></a><!-- doxytag: member="tools.h::NETSNMP_TIMERSUB" ref="ga0d9f88130fa5677416b8f1c513826e0b" args="(a, b, res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NETSNMP_TIMERSUB</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">res&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                               \
    (res)-&gt;tv_sec  = (a)-&gt;tv_sec  - (b)-&gt;tv_sec - 1;            \
    (res)-&gt;tv_usec = (a)-&gt;tv_usec - (b)-&gt;tv_usec + 1000000L;    \
    <span class="keywordflow">if</span> ((res)-&gt;tv_usec &gt;= 1000000L) {                           \
        (res)-&gt;tv_usec -= 1000000L;                             \
        (res)-&gt;tv_sec++;                                        \
    }                                                           \
}
</pre></div>
<p>Compute res = a - b. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>a and b must be normalized 'struct timeval' values.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>res may be the same variable as one of the operands. In other words, &amp;a == &amp;res || &amp;b == &amp;res may hold. </dd></dl>

<p>Definition at line <a class="el" href="tools_8h_source.html#l00190">190</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f91aec5dcb8867a1ea8d9a66e5199f2"></a><!-- doxytag: member="tools.h::QUITFUN" ref="ga8f91aec5dcb8867a1ea8d9a66e5199f2" args="(e, l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QUITFUN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> ( (e) != SNMPERR_SUCCESS) {  \
                rval = SNMPERR_GENERR;  \
                <span class="keywordflow">goto</span> l ;                \
        }
</pre></div>
<p>Definition at line <a class="el" href="tools_8h_source.html#l00139">139</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga951e93edb6f0ea941e26155e3f8912a6"></a><!-- doxytag: member="tools.h::SNMP_FREE" ref="ga951e93edb6f0ea941e26155e3f8912a6" args="(s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SNMP_FREE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td>&#160;&#160;&#160;do { if (s) { free((void *)s); s=NULL; } } while(0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a pointer only if it is !NULL and sets its value to NULL. </p>

<p>Definition at line <a class="el" href="tools_8h_source.html#l00057">57</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5d58fec0dd81779c027ad243253897e0"></a><!-- doxytag: member="tools.h::SNMP_MACRO_VAL_TO_STR" ref="ga5d58fec0dd81779c027ad243253897e0" args="(s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SNMP_MACRO_VAL_TO_STR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td>&#160;&#160;&#160;SNMP_MACRO_VAL_TO_STR_PRIV(s)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands to string with value of the s. </p>
<p>If s is macro, the resulting string is value of the macro. Example: #define TEST 1234 <a class="el" href="group__util.html#ga5d58fec0dd81779c027ad243253897e0" title="Expands to string with value of the s.">SNMP_MACRO_VAL_TO_STR(TEST)</a> expands to "1234" SNMP_MACRO_VAL_TO_STR(TEST+1) expands to "1234+1" </p>

<p>Definition at line <a class="el" href="tools_8h_source.html#l00120">120</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6356941968481380ea6f4a646df4aaf9"></a><!-- doxytag: member="tools.h::SNMP_MALLOC_STRUCT" ref="ga6356941968481380ea6f4a646df4aaf9" args="(s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SNMP_MALLOC_STRUCT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td>&#160;&#160;&#160;(struct s *) calloc(1, sizeof(struct s))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mallocs memory of sizeof(struct s), zeros it and returns a pointer to it. </p>

<p>Definition at line <a class="el" href="tools_8h_source.html#l00068">68</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9cd013bb193de5048149afeb9d94e424"></a><!-- doxytag: member="tools.h::SNMP_MALLOC_TYPEDEF" ref="ga9cd013bb193de5048149afeb9d94e424" args="(td)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SNMP_MALLOC_TYPEDEF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">td</td><td>)</td>
          <td>&#160;&#160;&#160;(td *) calloc(1, sizeof(td))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mallocs memory of sizeof(t), zeros it and returns a pointer to it. </p>

<p>Definition at line <a class="el" href="tools_8h_source.html#l00072">72</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa70d7b83d1001df95cf64280e9545564"></a><!-- doxytag: member="tools.h::SNMP_MAX" ref="gaa70d7b83d1001df95cf64280e9545564" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SNMP_MAX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((a) &gt; (b) ? (a) : (b))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computers the maximum of a and b. </p>

<p>Definition at line <a class="el" href="tools_8h_source.html#l00106">106</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad1976dec11cfd62abaa4ecedad948f18"></a><!-- doxytag: member="tools.h::SNMP_MIN" ref="gad1976dec11cfd62abaa4ecedad948f18" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SNMP_MIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((a) &gt; (b) ? (b) : (a))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computers the minimum of a and b. </p>

<p>Definition at line <a class="el" href="tools_8h_source.html#l00110">110</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga15e5a68e6d21430ddd4312fec64e5027"></a><!-- doxytag: member="tools.h::SNMP_SWIPE_MEM" ref="ga15e5a68e6d21430ddd4312fec64e5027" args="(n, s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SNMP_SWIPE_MEM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;do { if (n) free((void *)n); n = s; s=NULL; } while(0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees pointer n only if it is !NULL, sets n to s and sets s to NULL. </p>

<p>Definition at line <a class="el" href="tools_8h_source.html#l00061">61</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga190280d08c828c153ec2755b9c263227"></a><!-- doxytag: member="tools.h::SNMP_ZERO" ref="ga190280d08c828c153ec2755b9c263227" args="(s, l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SNMP_ZERO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;do { if (s) memset(s, 0, l); } while(0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Zeros l bytes of memory starting at s. </p>

<p>Definition at line <a class="el" href="tools_8h_source.html#l00076">76</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaf7a2cb94c76e0414a050651bba3a7c89"></a><!-- doxytag: member="tools.h::marker_t" ref="gaf7a2cb94c76e0414a050651bba3a7c89" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="group__util.html#gaf7a2cb94c76e0414a050651bba3a7c89">marker_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A pointer to an opaque time marker value. </p>

<p>Definition at line <a class="el" href="tools_8h_source.html#l00276">276</a> of file <a class="el" href="tools_8h_source.html">tools.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga0a394efc345d644fbac92b2e4f6522bb"></a><!-- doxytag: member="tools.h::atime_diff" ref="ga0a394efc345d644fbac92b2e4f6522bb" args="(const_marker_t first, const_marker_t second)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETSNMP_IMPORT long atime_diff </td>
          <td>(</td>
          <td class="paramtype">const_marker_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_marker_t&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the difference (in msec) between the two markers. </p>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00908">908</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0d2cc1553cd4bbdd9f703f62d9ecff5d"></a><!-- doxytag: member="tools.h::atime_newMarker" ref="ga0d2cc1553cd4bbdd9f703f62d9ecff5d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETSNMP_IMPORT <a class="el" href="group__util.html#gaf7a2cb94c76e0414a050651bba3a7c89">marker_t</a> atime_newMarker </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create a new time marker. </p>
<p>NOTE: Caller must free time marker when no longer needed. </p>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00884">884</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="gabf4fbd193d32cc00e9fc171a151cc50e"></a><!-- doxytag: member="tools.h::atime_ready" ref="gabf4fbd193d32cc00e9fc171a151cc50e" args="(const_marker_t pm, int deltaT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETSNMP_IMPORT int atime_ready </td>
          <td>(</td>
          <td class="paramtype">const_marker_t&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deltaT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test: Has (marked time plus delta) exceeded current time (in msec) ? Returns 0 if test fails or cannot be tested (no marker). </p>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00948">948</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaff24d4b425df1f36ea5da0d79e7e6860"></a><!-- doxytag: member="tools.h::atime_setMarker" ref="gaff24d4b425df1f36ea5da0d79e7e6860" args="(marker_t pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETSNMP_IMPORT void atime_setMarker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__util.html#gaf7a2cb94c76e0414a050651bba3a7c89">marker_t</a>&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set a time marker. </p>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00895">895</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae8a7a7b45158226de729f10af5e6a8e0"></a><!-- doxytag: member="tools.h::binary_to_hex" ref="gae8a7a7b45158226de729f10af5e6a8e0" args="(const u_char *input, size_t len, char **output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETSNMP_IMPORT u_int binary_to_hex </td>
          <td>(</td>
          <td class="paramtype">const u_char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts binary to hexidecimal </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*input</td><td>Binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data. </td></tr>
    <tr><td class="paramname">**output</td><td>NULL terminated string equivalent in hex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>olen Length of output string not including NULL terminator.</dd></dl>
<p>FIX Is there already one of these in the UCD SNMP codebase? The old one should be used, or this one should be moved to <a class="el" href="snmp__api_8c_source.html">snmplib/snmp_api.c</a>. </p>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00410">410</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga26a103aafde4d6dcf72c8e30c7d05bd9"></a><!-- doxytag: member="tools.h::free_zero" ref="ga26a103aafde4d6dcf72c8e30c7d05bd9" args="(void *buf, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_zero </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>zeros memory before freeing it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*buf</td><td>Pointer at bytes to free. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes in buf. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00221">221</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga601b13a13aab88bd74b4f54986d43722"></a><!-- doxytag: member="tools.h::hex_to_binary2" ref="ga601b13a13aab88bd74b4f54986d43722" args="(const u_char *input, size_t len, char **output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETSNMP_IMPORT int hex_to_binary2 </td>
          <td>(</td>
          <td class="paramtype">const u_char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>hex_to_binary2 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*input</td><td>Printable data in base16. </td></tr>
    <tr><td class="paramname">len</td><td>Length in bytes of data. </td></tr>
    <tr><td class="paramname">**output</td><td>Binary data equivalent to input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SNMPERR_GENERR on failure, otherwise length of allocated string.</dd></dl>
<p>Input of an odd length is right aligned.</p>
<p>FIX Another version of "hex-to-binary" which takes odd length input strings. It also allocates the memory to hold the binary data. Should be integrated with the official hex_to_binary() function. </p>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00437">437</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga76b7f8b21c44e2f8b274a0db8b57d5a1"></a><!-- doxytag: member="tools.h::malloc_random" ref="ga76b7f8b21c44e2f8b274a0db8b57d5a1" args="(size_t *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_char* malloc_random </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns pointer to allocaed &amp; set buffer on success, size contains number of random bytes filled. </p>
<p>buf is NULL and *size set to KMT error value upon failure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of bytes to malloc() and fill with random bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a malloced buffer </dd></dl>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00242">242</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac3eba1d195cd704fec703a133ec48a4b"></a><!-- doxytag: member="tools.h::marker_tticks" ref="gac3eba1d195cd704fec703a133ec48a4b" args="(const_marker_t pm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int marker_tticks </td>
          <td>(</td>
          <td class="paramtype">const_marker_t&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of timeTicks since the given marker. </p>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00998">998</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga098ada1e30ad7ee207ba90b73db7000a"></a><!-- doxytag: member="tools.h::memdup" ref="ga098ada1e30ad7ee207ba90b73db7000a" args="(u_char **to, const void *from, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETSNMP_IMPORT int memdup </td>
          <td>(</td>
          <td class="paramtype">u_char **&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Duplicates a memory block. </p>
<p>Copies a existing memory location from a pointer to another, newly malloced, pointer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>Pointer to allocate and copy memory to. </td></tr>
    <tr><td class="paramname">from</td><td>Pointer to copy memory from. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the data to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SNMPERR_SUCCESS on success, SNMPERR_GENERR on failure. </dd></dl>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00274">274</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9e77aebe2205db278a97e1cc57e8b14d"></a><!-- doxytag: member="tools.h::netsnmp_binary_to_hex" ref="ga9e77aebe2205db278a97e1cc57e8b14d" args="(u_char **dest, size_t *dest_len, int allow_realloc, const u_char *input, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETSNMP_IMPORT u_int netsnmp_binary_to_hex </td>
          <td>(</td>
          <td class="paramtype">u_char **&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dest_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>allow_realloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u_char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts binary to hexidecimal </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*input</td><td>Binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data. </td></tr>
    <tr><td class="paramname">**dest</td><td>NULL terminated string equivalent in hex. </td></tr>
    <tr><td class="paramname">*dest_len</td><td>size of destination buffer </td></tr>
    <tr><td class="paramname">allow_realloc</td><td>flag indicating if buffer can be realloc'd</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>olen Length of output string not including NULL terminator. </dd></dl>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00356">356</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga90238b6a9eaedea5f09cf8ddb45f8bfe"></a><!-- doxytag: member="tools.h::netsnmp_check_definedness" ref="ga90238b6a9eaedea5f09cf8ddb45f8bfe" args="(const void *packet, size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void netsnmp_check_definedness </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When running under Valgrind, check whether all bytes in the range [packet, packet+length) are defined. </p>
<p>Let Valgrind print a backtrace if one or more bytes with uninitialized values have been found. This function can help to find the cause of undefined value errors if --track-origins=yes is not sufficient. Does nothing when not running under Valgrind.</p>
<p>Note: this requires a fairly recent valgrind. </p>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00300">300</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1816d1ce1e701fcbce27b20159433313"></a><!-- doxytag: member="tools.h::netsnmp_getenv" ref="ga1816d1ce1e701fcbce27b20159433313" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* netsnmp_getenv </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non Windows: Returns a pointer to the desired environment variable or NULL if the environment variable does not exist. </p>
<p>Windows: Returns a pointer to the desired environment variable if it exists. If it does not, the variable is looked up in the registry in HKCU\Net-SNMP or HKLM\Net-SNMP (whichever it finds first) and stores the result in the environment variable. It then returns a pointer to environment variable. </p>

<p>Definition at line <a class="el" href="tools_8c_source.html#l01028">1028</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c1a230e987560600de9f81e55480c0a"></a><!-- doxytag: member="tools.h::netsnmp_hex_to_binary" ref="ga8c1a230e987560600de9f81e55480c0a" args="(u_char **buf, size_t *buf_len, size_t *offset, int allow_realloc, const char *hex, const char *delim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int netsnmp_hex_to_binary </td>
          <td>(</td>
          <td class="paramtype">u_char **&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>allow_realloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convert an ASCII hex string (with specified delimiters) to binary </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>address of a pointer (pointer to pointer) for the output buffer. If allow_realloc is set, the buffer may be grown via snmp_realloc to accomodate the data.</td></tr>
    <tr><td class="paramname">buf_len</td><td>pointer to a size_t containing the initial size of buf.</td></tr>
    <tr><td class="paramname">offset</td><td>On input, a pointer to a size_t indicating an offset into buf. The binary data will be stored at this offset. On output, this pointer will have updated the offset to be the first byte after the converted data.</td></tr>
    <tr><td class="paramname">allow_realloc</td><td>If true, the buffer can be reallocated. If false, and the buffer is not large enough to contain the string, an error will be returned.</td></tr>
    <tr><td class="paramname">hex</td><td>pointer to hex string to be converted. May be prefixed by "0x" or "0X".</td></tr>
    <tr><td class="paramname">delim</td><td>point to a string of allowed delimiters between bytes. If not specified, any non-hex characters will be an error.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>success </td></tr>
    <tr><td class="paramname">0</td><td>error </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00538">538</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga939f4b1177b3980545eadce70148c41b"></a><!-- doxytag: member="tools.h::netsnmp_strdup_and_null" ref="ga939f4b1177b3980545eadce70148c41b" args="(const u_char *from, size_t from_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETSNMP_IMPORT char* netsnmp_strdup_and_null </td>
          <td>(</td>
          <td class="paramtype">const u_char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copies a (possible) unterminated string of a given length into a new buffer and null terminates it as well (new buffer MAY be one byte longer to account for this </p>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00326">326</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga15fc22ecd93620a53bb67b5abeafdcf1"></a><!-- doxytag: member="tools.h::netsnmp_string_time_to_secs" ref="ga15fc22ecd93620a53bb67b5abeafdcf1" args="(const char *time_string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETSNMP_IMPORT int netsnmp_string_time_to_secs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>time_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Takes a time string like 4h and converts it to seconds. </p>
<p>The string time given may end in 's' for seconds (the default anyway if no suffix is specified), 'm' for minutes, 'h' for hours, 'd' for days, or 'w' for weeks. The upper case versions are also accepted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">time_string</td><td>The time string to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>seconds converted from the string </dd>
<dd>
-1 : on failure </dd></dl>

<p>Definition at line <a class="el" href="tools_8c_source.html#l01196">1196</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="gabcc7d0fd7e0145ef532da8d0949c9131"></a><!-- doxytag: member="tools.h::snmp_hex_to_binary" ref="gabcc7d0fd7e0145ef532da8d0949c9131" args="(u_char **buf, size_t *buf_len, size_t *offset, int allow_realloc, const char *hex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETSNMP_IMPORT int snmp_hex_to_binary </td>
          <td>(</td>
          <td class="paramtype">u_char **&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>allow_realloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convert an ASCII hex string to binary </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is a wrapper which calls netsnmp_hex_to_binary with a delimiter string of " ".</dd></dl>
<p>See netsnmp_hex_to_binary for parameter descriptions.</p>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>success </td></tr>
    <tr><td class="paramname">0</td><td>error </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00598">598</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga40652bb342e382d783e3a1ff9a0ddc6f"></a><!-- doxytag: member="tools.h::snmp_realloc" ref="ga40652bb342e382d783e3a1ff9a0ddc6f" args="(u_char **buf, size_t *buf_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETSNMP_IMPORT int snmp_realloc </td>
          <td>(</td>
          <td class="paramtype">u_char **&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buf_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function increase the size of the buffer pointed at by *buf, which is initially of size *buf_len. </p>
<p>Contents are preserved **AT THE BOTTOM END OF THE BUFFER**. If memory can be (re-)allocated then it returns 1, else it returns 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>pointer to a buffer pointer </td></tr>
    <tr><td class="paramname">buf_len</td><td>pointer to current size of buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The current re-allocation algorithm is to increase the buffer size by whichever is the greater of 256 bytes or the current buffer size, up to a maximum increase of 8192 bytes. </dd></dl>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00157">157</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga5b27dd0a0b3adc35a0b6329a005a9bc4"></a><!-- doxytag: member="tools.h::uatime_diff" ref="ga5b27dd0a0b3adc35a0b6329a005a9bc4" args="(const_marker_t first, const_marker_t second)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_long uatime_diff </td>
          <td>(</td>
          <td class="paramtype">const_marker_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_marker_t&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the difference (in u_long msec) between the two markers. </p>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00921">921</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga7ba38caeffa80fa6aaf19cfb71eaba3b"></a><!-- doxytag: member="tools.h::uatime_hdiff" ref="ga7ba38caeffa80fa6aaf19cfb71eaba3b" args="(const_marker_t first, const_marker_t second)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NETSNMP_IMPORT u_long uatime_hdiff </td>
          <td>(</td>
          <td class="paramtype">const_marker_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_marker_t&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the difference (in u_long 1/100th secs) between the two markers (functionally this is what sysUpTime needs) </p>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00935">935</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaa24ec07ac80a68792b95ceeb475a1bb3"></a><!-- doxytag: member="tools.h::uatime_ready" ref="gaa24ec07ac80a68792b95ceeb475a1bb3" args="(const_marker_t pm, unsigned int deltaT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uatime_ready </td>
          <td>(</td>
          <td class="paramtype">const_marker_t&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>deltaT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test: Has (marked time plus delta) exceeded current time (in msec) ? Returns 0 if test fails or cannot be tested (no marker). </p>

<p>Definition at line <a class="el" href="tools_8c_source.html#l00971">971</a> of file <a class="el" href="tools_8c_source.html">tools.c</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jul 14 2011 for net-snmp by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
