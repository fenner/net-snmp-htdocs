<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>net-snmp: table.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">net-snmp&#160;<span id="projectnumber">5.7</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">table.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * table.c </span>
<a name="l00003"></a>00003 <span class="comment"> */</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
<a name="l00006"></a>00006 <span class="comment"> * the Net-SNMP&#39;s COPYING file for more details and other copyrights</span>
<a name="l00007"></a>00007 <span class="comment"> * that may apply:</span>
<a name="l00008"></a>00008 <span class="comment"> */</span>
<a name="l00009"></a>00009 <span class="comment">/*</span>
<a name="l00010"></a>00010 <span class="comment"> * Portions of this file are copyrighted by:</span>
<a name="l00011"></a>00011 <span class="comment"> * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.</span>
<a name="l00012"></a>00012 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
<a name="l00013"></a>00013 <span class="comment"> * distributed with the Net-SNMP package.</span>
<a name="l00014"></a>00014 <span class="comment"> */</span>
<a name="l00015"></a>00015 <span class="comment">/*</span>
<a name="l00016"></a>00016 <span class="comment"> * Portions of this file are copyrighted by:</span>
<a name="l00017"></a>00017 <span class="comment"> * Copyright (C) 2007 Apple, Inc. All rights reserved.</span>
<a name="l00018"></a>00018 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
<a name="l00019"></a>00019 <span class="comment"> * distributed with the Net-SNMP package.</span>
<a name="l00020"></a>00020 <span class="comment"> */</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;net-snmp/net-snmp-features.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;net-snmp/net-snmp-includes.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;net-snmp/agent/net-snmp-agent-includes.h&gt;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;net-snmp/agent/table.h&gt;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span>netsnmp_feature_require(oid_stash)
<a name="l00032"></a>00032 <span class="preprocessor">#endif </span><span class="comment">/* !NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#if HAVE_STRING_H</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#else</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#include &lt;strings.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#endif</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;net-snmp/library/snmp_assert.h&gt;</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 netsnmp_feature_child_of(table_all, mib_helpers)
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 netsnmp_feature_child_of(table_build_result, table_all)
<a name="l00045"></a>00045 netsnmp_feature_child_of(table_get_or_create_row_stash, table_all)
<a name="l00046"></a>00046 netsnmp_feature_child_of(registration_owns_table_info, table_all)
<a name="l00047"></a>00047 netsnmp_feature_child_of(table_sparse, table_all)
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 static <span class="keywordtype">void</span>     table_helper_cleanup(<a class="code" href="structnetsnmp__agent__request__info__s.html" title="The agent transaction request structure.">netsnmp_agent_request_info</a> *reqinfo,
<a name="l00050"></a>00050                                      <a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *request,
<a name="l00051"></a>00051                                      <span class="keywordtype">int</span> status);
<a name="l00052"></a>00052 static <span class="keywordtype">void</span>     table_data_free_func(<span class="keywordtype">void</span> *data);
<a name="l00053"></a>00053 static <span class="keywordtype">int</span>
<a name="l00054"></a>00054 sparse_table_helper_handler(<a class="code" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler</a> *handler,
<a name="l00055"></a>00055                             <a class="code" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration</a> *reginfo,
<a name="l00056"></a>00056                             <a class="code" href="structnetsnmp__agent__request__info__s.html" title="The agent transaction request structure.">netsnmp_agent_request_info</a> *reqinfo,
<a name="l00057"></a>00057                             <a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *requests);
<a name="l00058"></a>00058 
<a name="l00102"></a>00102 <a class="code" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler</a> *
<a name="l00103"></a>00103 netsnmp_get_table_handler(<a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *tabreq)
<a name="l00104"></a>00104 {
<a name="l00105"></a>00105     <a class="code" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler</a> *ret = NULL;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107     <span class="keywordflow">if</span> (!tabreq) {
<a name="l00108"></a>00108         <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_INFO, <span class="stringliteral">&quot;netsnmp_get_table_handler(NULL) called\n&quot;</span>);
<a name="l00109"></a>00109         <span class="keywordflow">return</span> NULL;
<a name="l00110"></a>00110     }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112     ret = netsnmp_create_handler(TABLE_HANDLER_NAME, <a class="code" href="group__table.html#ga571606b4d4e705a4420ff73ce3ac6b00" title="implements the table helper handler">table_helper_handler</a>);
<a name="l00113"></a>00113     <span class="keywordflow">if</span> (ret) {
<a name="l00114"></a>00114         ret-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#a74067d02cea4a059cd0fce7790b77b18" title="for handler&#39;s internal use">myvoid</a> = (<span class="keywordtype">void</span> *) tabreq;
<a name="l00115"></a>00115         tabreq-&gt;number_indexes = count_varbinds(tabreq-&gt;indexes);
<a name="l00116"></a>00116     }
<a name="l00117"></a>00117     <span class="keywordflow">return</span> ret;
<a name="l00118"></a>00118 }
<a name="l00119"></a>00119 
<a name="l00124"></a><a class="code" href="group__table.html#ga83f72dc340aa048813866471b571be6e">00124</a> <span class="keywordtype">void</span> <a class="code" href="group__table.html#ga83f72dc340aa048813866471b571be6e" title="Configures a handler such that table registration information is freed by netsnmp_handler_free().">netsnmp_handler_owns_table_info</a>(<a class="code" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler</a> *handler)
<a name="l00125"></a>00125 {
<a name="l00126"></a>00126     netsnmp_assert(handler);
<a name="l00127"></a>00127     netsnmp_assert(handler-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#a74067d02cea4a059cd0fce7790b77b18" title="for handler&#39;s internal use">myvoid</a>);
<a name="l00128"></a>00128     handler-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#a920cb70b2ae344b1c268a5f96f4b4e59" title="data clone hook for myvoid deep copy the myvoid member - default is to copy the pointer This method i...">data_clone</a>
<a name="l00129"></a>00129         = (<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *)) netsnmp_table_registration_info_clone;
<a name="l00130"></a>00130     handler-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#ae007338d354e85a5d9bf6a918bd42469" title="data free hook for myvoid delete the myvoid member - default is to do nothing This method is only cal...">data_free</a>
<a name="l00131"></a>00131         = (void (*)(<span class="keywordtype">void</span> *)) netsnmp_table_registration_info_free;
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00138"></a>00138 <span class="preprocessor">#ifndef NETSNMP_FEATURE_REMOVE_REGISTRATION_OWNS_TABLE_INFO</span>
<a name="l00139"></a><a class="code" href="group__table.html#ga7903c0e94035677df8a90b91e1a97aa6">00139</a> <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="group__table.html#ga7903c0e94035677df8a90b91e1a97aa6" title="Configures a handler such that table registration information is freed by netsnmp_handler_free().">netsnmp_registration_owns_table_info</a>(<a class="code" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration</a> *reg)
<a name="l00140"></a>00140 {
<a name="l00141"></a>00141     <span class="keywordflow">if</span> (reg)
<a name="l00142"></a>00142         <a class="code" href="group__table.html#ga83f72dc340aa048813866471b571be6e" title="Configures a handler such that table registration information is freed by netsnmp_handler_free().">netsnmp_handler_owns_table_info</a>(reg-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#a4ef77cb16c8094af69cdd67a654ebfa3" title="handler details">handler</a>);
<a name="l00143"></a>00143 }
<a name="l00144"></a>00144 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_FEATURE_REMOVE_REGISTRATION_OWNS_TABLE_INFO */</span>
<a name="l00145"></a>00145 
<a name="l00150"></a>00150 <span class="keywordtype">int</span>
<a name="l00151"></a><a class="code" href="group__table.html#ga9940ed4fe4f46dc0212ddd46967c16f2">00151</a> <a class="code" href="group__table.html#ga9940ed4fe4f46dc0212ddd46967c16f2" title="creates a table handler given the netsnmp_table_registration_info object, inserts it into the request...">netsnmp_register_table</a>(<a class="code" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration</a> *reginfo,
<a name="l00152"></a>00152                        <a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *tabreq)
<a name="l00153"></a>00153 {
<a name="l00154"></a>00154     <span class="keywordtype">int</span> rc = <a class="code" href="group__handler.html#ga6649d75b3eaf98d70704754d3d8235f3" title="Injects handler into the calling chain of handlers.">netsnmp_inject_handler</a>(reginfo, netsnmp_get_table_handler(tabreq));
<a name="l00155"></a>00155     <span class="keywordflow">if</span> (SNMPERR_SUCCESS != rc)
<a name="l00156"></a>00156         <span class="keywordflow">return</span> rc;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158     <span class="keywordflow">return</span> <a class="code" href="group__handler.html#gacdbdb9d74898a5bf04b0992ea0316aa4" title="Registers a MIB handler inside the registration structure.">netsnmp_register_handler</a>(reginfo);
<a name="l00159"></a>00159 }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="keywordtype">int</span>
<a name="l00162"></a>00162 netsnmp_unregister_table(<a class="code" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration</a> *reginfo)
<a name="l00163"></a>00163 {
<a name="l00164"></a>00164     <span class="comment">/* Locate &quot;this&quot; reginfo */</span>
<a name="l00165"></a>00165     <span class="comment">/* SNMP_FREE(reginfo-&gt;myvoid); */</span>
<a name="l00166"></a>00166     <span class="keywordflow">return</span> <a class="code" href="group__handler.html#ga62639943d2328300a27a196205fe88de" title="Unregisters a MIB handler described inside the registration structure.">netsnmp_unregister_handler</a>(reginfo);
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 
<a name="l00178"></a>00178 NETSNMP_INLINE <a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *
<a name="l00179"></a><a class="code" href="group__table.html#ga0f2aa788814b909e3e3003b63b1dbd3a">00179</a> <a class="code" href="group__table.html#ga0f2aa788814b909e3e3003b63b1dbd3a" title="Extracts the processed table information from a given request.">netsnmp_extract_table_info</a>(<a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *request)
<a name="l00180"></a>00180 {
<a name="l00181"></a>00181     <span class="keywordflow">return</span> (<a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *)
<a name="l00182"></a>00182         <a class="code" href="group__handler.html#gac8ebe16c4ca9e9e8d06fadcaa2650079" title="Extracts data from a request.">netsnmp_request_get_list_data</a>(request, TABLE_HANDLER_NAME);
<a name="l00183"></a>00183 }
<a name="l00184"></a>00184 
<a name="l00187"></a>00187 <a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *
<a name="l00188"></a><a class="code" href="group__table.html#gaf0f72a85bfca5e069971fa3869082267">00188</a> <a class="code" href="group__table.html#gaf0f72a85bfca5e069971fa3869082267" title="extracts the registered netsnmp_table_registration_info object from a netsnmp_handler_registration ob...">netsnmp_find_table_registration_info</a>(<a class="code" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration</a> *reginfo)
<a name="l00189"></a>00189 {
<a name="l00190"></a>00190     <span class="keywordflow">return</span> (<a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *)
<a name="l00191"></a>00191         <a class="code" href="group__handler.html#ga6b85cb5b40f357ae415c44a1f3e50f5a" title="Returns a handler&#39;s void pointer from a chain based on the name.">netsnmp_find_handler_data_by_name</a>(reginfo, TABLE_HANDLER_NAME);
<a name="l00192"></a>00192 }
<a name="l00193"></a>00193 
<a name="l00195"></a>00195 <span class="keywordtype">int</span>
<a name="l00196"></a><a class="code" href="group__table.html#ga571606b4d4e705a4420ff73ce3ac6b00">00196</a> <a class="code" href="group__table.html#ga571606b4d4e705a4420ff73ce3ac6b00" title="implements the table helper handler">table_helper_handler</a>(<a class="code" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler</a> *handler,
<a name="l00197"></a>00197                      <a class="code" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration</a> *reginfo,
<a name="l00198"></a>00198                      <a class="code" href="structnetsnmp__agent__request__info__s.html" title="The agent transaction request structure.">netsnmp_agent_request_info</a> *reqinfo,
<a name="l00199"></a>00199                      <a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *requests)
<a name="l00200"></a>00200 {
<a name="l00201"></a>00201 
<a name="l00202"></a>00202     <a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *request;
<a name="l00203"></a>00203     <a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *tbl_info;
<a name="l00204"></a>00204     <span class="keywordtype">int</span>             oid_index_pos;
<a name="l00205"></a>00205     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    oid_column_pos;
<a name="l00206"></a>00206     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    tmp_idx;
<a name="l00207"></a>00207     ssize_t         tmp_len;
<a name="l00208"></a>00208     <span class="keywordtype">int</span>             incomplete, out_of_range;
<a name="l00209"></a>00209     <span class="keywordtype">int</span>             status = SNMP_ERR_NOERROR, need_processing = 0;
<a name="l00210"></a>00210     oid            *tmp_name;
<a name="l00211"></a>00211     <a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *tbl_req_info;
<a name="l00212"></a>00212     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *vb;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214     <span class="keywordflow">if</span> (!reginfo || !handler)
<a name="l00215"></a>00215         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l00216"></a>00216 
<a name="l00217"></a>00217     oid_index_pos  = reginfo-&gt;rootoid_len + 2;
<a name="l00218"></a>00218     oid_column_pos = reginfo-&gt;rootoid_len + 1;
<a name="l00219"></a>00219     tbl_info = (<a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *) handler-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#a74067d02cea4a059cd0fce7790b77b18" title="for handler&#39;s internal use">myvoid</a>;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221     if ((!handler-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#a74067d02cea4a059cd0fce7790b77b18" title="for handler&#39;s internal use">myvoid</a>) || (!tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a3045fe8e402e974d840af4084b88dc2a" title="list of varbinds with only &#39;type&#39; set">indexes</a>)) {
<a name="l00222"></a>00222         <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_ERR, <span class="stringliteral">&quot;improperly registered table found\n&quot;</span>);
<a name="l00223"></a>00223         <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_ERR, <span class="stringliteral">&quot;name: %s, table info: %p, indexes: %p\n&quot;</span>,
<a name="l00224"></a>00224                  handler-&gt;handler_name, handler-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#a74067d02cea4a059cd0fce7790b77b18" title="for handler&#39;s internal use">myvoid</a>, tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a3045fe8e402e974d840af4084b88dc2a" title="list of varbinds with only &#39;type&#39; set">indexes</a>);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226         <span class="comment">/*</span>
<a name="l00227"></a>00227 <span class="comment">         * XXX-rks: unregister table? </span>
<a name="l00228"></a>00228 <span class="comment">         */</span>
<a name="l00229"></a>00229         <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l00230"></a>00230     }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232     DEBUGIF(<span class="stringliteral">&quot;helper:table:req&quot;</span>) {
<a name="l00233"></a>00233         DEBUGMSGTL((<span class="stringliteral">&quot;helper:table:req&quot;</span>,
<a name="l00234"></a>00234                     <span class="stringliteral">&quot;Got %s (%d) mode request for handler %s: base oid:&quot;</span>,
<a name="l00235"></a>00235                     se_find_label_in_slist(<span class="stringliteral">&quot;agent_mode&quot;</span>, reqinfo-&gt;mode),
<a name="l00236"></a>00236                     reqinfo-&gt;mode, handler-&gt;handler_name));
<a name="l00237"></a>00237         DEBUGMSGOID((<span class="stringliteral">&quot;helper:table:req&quot;</span>, reginfo-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#a264722b6b9385237fbcb5f8bc144d470" title="where are we registered at?">rootoid</a>,
<a name="l00238"></a>00238                      reginfo-&gt;rootoid_len));
<a name="l00239"></a>00239         DEBUGMSG((<span class="stringliteral">&quot;helper:table:req&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l00240"></a>00240     }
<a name="l00241"></a>00241     
<a name="l00242"></a>00242     <span class="comment">/*</span>
<a name="l00243"></a>00243 <span class="comment">     * if the agent request info has a state reference, then this is a </span>
<a name="l00244"></a>00244 <span class="comment">     * later pass of a set request and we can skip all the lookup stuff.</span>
<a name="l00245"></a>00245 <span class="comment">     *</span>
<a name="l00246"></a>00246 <span class="comment">     * xxx-rks: this might break for handlers which only handle one varbind</span>
<a name="l00247"></a>00247 <span class="comment">     * at a time... those handlers should not save data by their handler_name</span>
<a name="l00248"></a>00248 <span class="comment">     * in the netsnmp_agent_request_info. </span>
<a name="l00249"></a>00249 <span class="comment">     */</span>
<a name="l00250"></a>00250     <span class="keywordflow">if</span> (netsnmp_agent_get_list_data(reqinfo, handler-&gt;next-&gt;handler_name)) {
<a name="l00251"></a>00251 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (MODE_IS_SET(reqinfo-&gt;mode)) {
<a name="l00253"></a>00253             <span class="keywordflow">return</span> netsnmp_call_next_handler(handler, reginfo, reqinfo,
<a name="l00254"></a>00254                                              requests);
<a name="l00255"></a>00255         } <span class="keywordflow">else</span> {
<a name="l00256"></a>00256 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00257"></a>00257 
<a name="l00258"></a>00258             netsnmp_free_agent_data_sets(reqinfo);
<a name="l00259"></a>00259 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span>        }
<a name="l00261"></a>00261 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00262"></a>00262     }
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l00265"></a>00265 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ( MODE_IS_SET(reqinfo-&gt;mode) &amp;&amp;
<a name="l00266"></a>00266          (reqinfo-&gt;mode != MODE_SET_RESERVE1)) {
<a name="l00267"></a>00267         <span class="comment">/*</span>
<a name="l00268"></a>00268 <span class="comment">         * for later set modes, we can skip all the index parsing,</span>
<a name="l00269"></a>00269 <span class="comment">         * and we always need to let child handlers have a chance</span>
<a name="l00270"></a>00270 <span class="comment">         * to clean up, if they were called in the first place (i.e. have</span>
<a name="l00271"></a>00271 <span class="comment">         * a valid table info pointer).</span>
<a name="l00272"></a>00272 <span class="comment">         */</span>
<a name="l00273"></a>00273         <span class="keywordflow">if</span>(NULL == <a class="code" href="group__table.html#ga0f2aa788814b909e3e3003b63b1dbd3a" title="Extracts the processed table information from a given request.">netsnmp_extract_table_info</a>(requests)) {
<a name="l00274"></a>00274             DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>,<span class="stringliteral">&quot;no table info for set - skipping\n&quot;</span>));
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276         <span class="keywordflow">else</span>
<a name="l00277"></a>00277             need_processing = 1;
<a name="l00278"></a>00278     }
<a name="l00279"></a>00279     <span class="keywordflow">else</span> {
<a name="l00280"></a>00280 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00281"></a>00281         <span class="comment">/*</span>
<a name="l00282"></a>00282 <span class="comment">         * for GETS, only continue if we have at least one valid request.</span>
<a name="l00283"></a>00283 <span class="comment">         * for RESERVE1, only continue if we have indexes for all requests.</span>
<a name="l00284"></a>00284 <span class="comment">         */</span>
<a name="l00285"></a>00285            
<a name="l00286"></a>00286     <span class="comment">/*</span>
<a name="l00287"></a>00287 <span class="comment">     * loop through requests</span>
<a name="l00288"></a>00288 <span class="comment">     */</span>
<a name="l00289"></a>00289 
<a name="l00290"></a>00290     <span class="keywordflow">for</span> (request = requests; request; request = request-&gt;next) {
<a name="l00291"></a>00291         <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *var = request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293         DEBUGMSGOID((<span class="stringliteral">&quot;verbose:table&quot;</span>, var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>, var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a>));
<a name="l00294"></a>00294         DEBUGMSG((<span class="stringliteral">&quot;verbose:table&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l00295"></a>00295 
<a name="l00296"></a>00296         <span class="keywordflow">if</span> (request-&gt;processed) {
<a name="l00297"></a>00297             DEBUGMSG((<span class="stringliteral">&quot;verbose:table&quot;</span>, <span class="stringliteral">&quot;already processed\n&quot;</span>));
<a name="l00298"></a>00298             <span class="keywordflow">continue</span>;
<a name="l00299"></a>00299         }
<a name="l00300"></a>00300         netsnmp_assert(request-&gt;status == SNMP_ERR_NOERROR);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302         <span class="comment">/*</span>
<a name="l00303"></a>00303 <span class="comment">         * this should probably be handled further up </span>
<a name="l00304"></a>00304 <span class="comment">         */</span>
<a name="l00305"></a>00305         <span class="keywordflow">if</span> ((reqinfo-&gt;mode == MODE_GET) &amp;&amp; (var-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a> != ASN_NULL)) {
<a name="l00306"></a>00306             <span class="comment">/*</span>
<a name="l00307"></a>00307 <span class="comment">             * valid request if ASN_NULL </span>
<a name="l00308"></a>00308 <span class="comment">             */</span>
<a name="l00309"></a>00309             DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>,
<a name="l00310"></a>00310                         <span class="stringliteral">&quot;  GET var type is not ASN_NULL\n&quot;</span>));
<a name="l00311"></a>00311             <a class="code" href="group__snmp__agent.html#gac0668f1fd9036ebc88a734d9d4a6a59b" title="set error for a request">netsnmp_set_request_error</a>(reqinfo, request,
<a name="l00312"></a>00312                                       SNMP_ERR_WRONGTYPE);
<a name="l00313"></a>00313             <span class="keywordflow">continue</span>;
<a name="l00314"></a>00314         }
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l00317"></a>00317 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_SET_RESERVE1) {
<a name="l00318"></a>00318             DEBUGIF(<span class="stringliteral">&quot;helper:table:set&quot;</span>) {
<a name="l00319"></a>00319                 u_char         *buf = NULL;
<a name="l00320"></a>00320                 <span class="keywordtype">size_t</span>          buf_len = 0, out_len = 0;
<a name="l00321"></a>00321                 DEBUGMSGTL((<span class="stringliteral">&quot;helper:table:set&quot;</span>, <span class="stringliteral">&quot; SET_REQUEST for OID: &quot;</span>));
<a name="l00322"></a>00322                 DEBUGMSGOID((<span class="stringliteral">&quot;helper:table:set&quot;</span>, var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>, var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a>));
<a name="l00323"></a>00323                 out_len = 0;
<a name="l00324"></a>00324                 <span class="keywordflow">if</span> (<a class="code" href="group__mib__utilities.html#gaabc12c361abdca75234c11dccb34871b" title="Universal print routine, prints a variable into a buffer according to the variable type...">sprint_realloc_by_type</a>(&amp;buf, &amp;buf_len, &amp;out_len, 1,
<a name="l00325"></a>00325                                            var, NULL, NULL, NULL)) {
<a name="l00326"></a>00326                     DEBUGMSG((<span class="stringliteral">&quot;helper:table:set&quot;</span>,<span class="stringliteral">&quot; type=%d(%02x), value=%s\n&quot;</span>,
<a name="l00327"></a>00327                               var-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a>, var-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a>, buf));
<a name="l00328"></a>00328                 } <span class="keywordflow">else</span> {
<a name="l00329"></a>00329                     <span class="keywordflow">if</span> (buf != NULL) {
<a name="l00330"></a>00330                         DEBUGMSG((<span class="stringliteral">&quot;helper:table:set&quot;</span>,
<a name="l00331"></a>00331                                   <span class="stringliteral">&quot; type=%d(%02x), value=%s [TRUNCATED]\n&quot;</span>,
<a name="l00332"></a>00332                                   var-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a>, var-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a>, buf));
<a name="l00333"></a>00333                     } <span class="keywordflow">else</span> {
<a name="l00334"></a>00334                         DEBUGMSG((<span class="stringliteral">&quot;helper:table:set&quot;</span>,
<a name="l00335"></a>00335                                   <span class="stringliteral">&quot; type=%d(%02x), value=[NIL] [TRUNCATED]\n&quot;</span>,
<a name="l00336"></a>00336                                   var-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a>, var-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a>));
<a name="l00337"></a>00337                     }
<a name="l00338"></a>00338                 }
<a name="l00339"></a>00339                 <span class="keywordflow">if</span> (buf != NULL) {
<a name="l00340"></a>00340                     free(buf);
<a name="l00341"></a>00341                 }
<a name="l00342"></a>00342             }
<a name="l00343"></a>00343         }
<a name="l00344"></a>00344 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00345"></a>00345 
<a name="l00346"></a>00346         <span class="comment">/*</span>
<a name="l00347"></a>00347 <span class="comment">         * check to make sure its in table range </span>
<a name="l00348"></a>00348 <span class="comment">         */</span>
<a name="l00349"></a>00349 
<a name="l00350"></a>00350         out_of_range = 0;
<a name="l00351"></a>00351         <span class="comment">/*</span>
<a name="l00352"></a>00352 <span class="comment">         * if our root oid is &gt; var-&gt;name and this is not a GETNEXT, </span>
<a name="l00353"></a>00353 <span class="comment">         * then the oid is out of range. (only compare up to shorter </span>
<a name="l00354"></a>00354 <span class="comment">         * length) </span>
<a name="l00355"></a>00355 <span class="comment">         */</span>
<a name="l00356"></a>00356         <span class="keywordflow">if</span> (reginfo-&gt;rootoid_len &gt; var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a>)
<a name="l00357"></a>00357             tmp_len = var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a>;
<a name="l00358"></a>00358         <span class="keywordflow">else</span>
<a name="l00359"></a>00359             tmp_len = reginfo-&gt;rootoid_len;
<a name="l00360"></a>00360         <span class="keywordflow">if</span> (<a class="code" href="group__library.html#gab5b48a42c19a801547e025ed40b4561e" title="lexicographical compare two object identifiers.">snmp_oid_compare</a>(reginfo-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#a264722b6b9385237fbcb5f8bc144d470" title="where are we registered at?">rootoid</a>, reginfo-&gt;rootoid_len,
<a name="l00361"></a>00361                              var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>, tmp_len) &gt; 0) {
<a name="l00362"></a>00362             <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_GETNEXT) {
<a name="l00363"></a>00363                 <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a> != var-&gt;<a class="code" href="structvariable__list.html#a5b8071f7514fb530c9b596791bca6813" title="buffer to hold the OID">name_loc</a>)
<a name="l00364"></a>00364                     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>);
<a name="l00365"></a>00365                 snmp_set_var_objid(var, reginfo-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#a264722b6b9385237fbcb5f8bc144d470" title="where are we registered at?">rootoid</a>,
<a name="l00366"></a>00366                                    reginfo-&gt;rootoid_len);
<a name="l00367"></a>00367             } <span class="keywordflow">else</span> {
<a name="l00368"></a>00368                 DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>, <span class="stringliteral">&quot;  oid is out of range.\n&quot;</span>));
<a name="l00369"></a>00369                 out_of_range = 1;
<a name="l00370"></a>00370             }
<a name="l00371"></a>00371         }
<a name="l00372"></a>00372         <span class="comment">/*</span>
<a name="l00373"></a>00373 <span class="comment">         * if var-&gt;name is longer than the root, make sure it is </span>
<a name="l00374"></a>00374 <span class="comment">         * table.1 (table.ENTRY).  </span>
<a name="l00375"></a>00375 <span class="comment">         */</span>
<a name="l00376"></a>00376         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a> &gt; reginfo-&gt;rootoid_len) &amp;&amp;
<a name="l00377"></a>00377                  (var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>[reginfo-&gt;rootoid_len] != 1)) {
<a name="l00378"></a>00378             <span class="keywordflow">if</span> ((var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>[reginfo-&gt;rootoid_len] &lt; 1) &amp;&amp;
<a name="l00379"></a>00379                 (reqinfo-&gt;mode == MODE_GETNEXT)) {
<a name="l00380"></a>00380                 var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>[reginfo-&gt;rootoid_len] = 1;
<a name="l00381"></a>00381                 var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a> = reginfo-&gt;rootoid_len;
<a name="l00382"></a>00382             } <span class="keywordflow">else</span> {
<a name="l00383"></a>00383                 out_of_range = 1;
<a name="l00384"></a>00384                 DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>, <span class="stringliteral">&quot;  oid is out of range.\n&quot;</span>));
<a name="l00385"></a>00385             }
<a name="l00386"></a>00386         }
<a name="l00387"></a>00387         <span class="comment">/*</span>
<a name="l00388"></a>00388 <span class="comment">         * if it is not in range, then mark it in the request list </span>
<a name="l00389"></a>00389 <span class="comment">         * because we can&#39;t process it, and set an error so</span>
<a name="l00390"></a>00390 <span class="comment">         * nobody else wastes time trying to process it either.  </span>
<a name="l00391"></a>00391 <span class="comment">         */</span>
<a name="l00392"></a>00392         <span class="keywordflow">if</span> (out_of_range) {
<a name="l00393"></a>00393             DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>, <span class="stringliteral">&quot;  Not processed: &quot;</span>));
<a name="l00394"></a>00394             DEBUGMSGOID((<span class="stringliteral">&quot;helper:table&quot;</span>, var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>, var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a>));
<a name="l00395"></a>00395             DEBUGMSG((<span class="stringliteral">&quot;helper:table&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l00396"></a>00396 
<a name="l00397"></a>00397             <span class="comment">/*</span>
<a name="l00398"></a>00398 <span class="comment">             *  Reject requests of the form &#39;myTable.N&#39;   (N != 1)</span>
<a name="l00399"></a>00399 <span class="comment">             */</span>
<a name="l00400"></a>00400 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l00401"></a>00401 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_SET_RESERVE1)
<a name="l00402"></a>00402                 table_helper_cleanup(reqinfo, request,
<a name="l00403"></a>00403                                      SNMP_ERR_NOTWRITABLE);
<a name="l00404"></a>00404             <span class="keywordflow">else</span>
<a name="l00405"></a>00405 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00406"></a>00406             <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_GET)
<a name="l00407"></a>00407                 table_helper_cleanup(reqinfo, request,
<a name="l00408"></a>00408                                      SNMP_NOSUCHOBJECT);
<a name="l00409"></a>00409             <span class="keywordflow">continue</span>;
<a name="l00410"></a>00410         }
<a name="l00411"></a>00411 
<a name="l00412"></a>00412 
<a name="l00413"></a>00413         <span class="comment">/*</span>
<a name="l00414"></a>00414 <span class="comment">         * Check column ranges; set-up to pull out indexes from OID. </span>
<a name="l00415"></a>00415 <span class="comment">         */</span>
<a name="l00416"></a>00416 
<a name="l00417"></a>00417         incomplete = 0;
<a name="l00418"></a>00418         tbl_req_info = <a class="code" href="group__table.html#ga0f2aa788814b909e3e3003b63b1dbd3a" title="Extracts the processed table information from a given request.">netsnmp_extract_table_info</a>(request);
<a name="l00419"></a>00419         <span class="keywordflow">if</span> (NULL == tbl_req_info) {
<a name="l00420"></a>00420             tbl_req_info = <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424" title="Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a>);
<a name="l00421"></a>00421             <span class="keywordflow">if</span> (tbl_req_info == NULL) {
<a name="l00422"></a>00422                 table_helper_cleanup(reqinfo, request,
<a name="l00423"></a>00423                                      SNMP_ERR_GENERR);
<a name="l00424"></a>00424                 <span class="keywordflow">continue</span>;
<a name="l00425"></a>00425             }
<a name="l00426"></a>00426             tbl_req_info-&gt;reg_info = tbl_info;
<a name="l00427"></a>00427             tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a> = snmp_clone_varbind(tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a3045fe8e402e974d840af4084b88dc2a" title="list of varbinds with only &#39;type&#39; set">indexes</a>);
<a name="l00428"></a>00428             tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a7a5309fb5e3d994e4ccd4986b6a90bfd" title="0 if failure to parse any">number_indexes</a> = 0;       <span class="comment">/* none yet */</span>
<a name="l00429"></a>00429             <a class="code" href="group__handler.html#gacc092f27f7c4203fe20665c8341023c8" title="Adds data from node list to the request information structure.">netsnmp_request_add_list_data</a>(request,
<a name="l00430"></a>00430                                           <a class="code" href="group__data__list.html#ga3dc286b678474c6adb610460ea71b03e" title="adds creates a data_list node given a name, data and a free function ptr.">netsnmp_create_data_list</a>
<a name="l00431"></a>00431                                           (TABLE_HANDLER_NAME,
<a name="l00432"></a>00432                                            (<span class="keywordtype">void</span> *) tbl_req_info,
<a name="l00433"></a>00433                                            table_data_free_func));
<a name="l00434"></a>00434         } <span class="keywordflow">else</span> {
<a name="l00435"></a>00435             DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>, <span class="stringliteral">&quot;  using existing tbl_req_info\n &quot;</span>));
<a name="l00436"></a>00436         }
<a name="l00437"></a>00437 
<a name="l00438"></a>00438         <span class="comment">/*</span>
<a name="l00439"></a>00439 <span class="comment">         * do we have a column?</span>
<a name="l00440"></a>00440 <span class="comment">         */</span>
<a name="l00441"></a>00441         <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a> &gt; oid_column_pos) {
<a name="l00442"></a>00442             <span class="comment">/*</span>
<a name="l00443"></a>00443 <span class="comment">             * oid is long enough to contain COLUMN info</span>
<a name="l00444"></a>00444 <span class="comment">             */</span>
<a name="l00445"></a>00445             DEBUGMSGTL((<span class="stringliteral">&quot;helper:table:col&quot;</span>,
<a name="l00446"></a>00446                         <span class="stringliteral">&quot;  have at least a column (%&quot;</span> NETSNMP_PRIo <span class="stringliteral">&quot;d)\n&quot;</span>,
<a name="l00447"></a>00447                         var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>[oid_column_pos]));
<a name="l00448"></a>00448             <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>[oid_column_pos] &lt; tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#ae48fd51376f573a4c4e5aede809f7092" title="the minimum columns number.">min_column</a>) {
<a name="l00449"></a>00449                 DEBUGMSGTL((<span class="stringliteral">&quot;helper:table:col&quot;</span>,
<a name="l00450"></a>00450                             <span class="stringliteral">&quot;    but it&#39;s less than min (%d)\n&quot;</span>,
<a name="l00451"></a>00451                             tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#ae48fd51376f573a4c4e5aede809f7092" title="the minimum columns number.">min_column</a>));
<a name="l00452"></a>00452                 <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_GETNEXT) {
<a name="l00453"></a>00453                     <span class="comment">/*</span>
<a name="l00454"></a>00454 <span class="comment">                     * fix column, truncate useless column info </span>
<a name="l00455"></a>00455 <span class="comment">                     */</span>
<a name="l00456"></a>00456                     var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a> = oid_column_pos;
<a name="l00457"></a>00457                     tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> = tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#ae48fd51376f573a4c4e5aede809f7092" title="the minimum columns number.">min_column</a>;
<a name="l00458"></a>00458                 } <span class="keywordflow">else</span>
<a name="l00459"></a>00459                     out_of_range = 1;
<a name="l00460"></a>00460             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>[oid_column_pos] &gt; tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a4b7f37faafced959b943e974ba58e008" title="the maximum columns number">max_column</a>)
<a name="l00461"></a>00461                 out_of_range = 1;
<a name="l00462"></a>00462             <span class="keywordflow">else</span>
<a name="l00463"></a>00463                 tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> = var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>[oid_column_pos];
<a name="l00464"></a>00464 
<a name="l00465"></a>00465             <span class="keywordflow">if</span> (out_of_range) {
<a name="l00466"></a>00466                 <span class="comment">/*</span>
<a name="l00467"></a>00467 <span class="comment">                 * this is out of range...  remove from requests, free</span>
<a name="l00468"></a>00468 <span class="comment">                 * memory </span>
<a name="l00469"></a>00469 <span class="comment">                 */</span>
<a name="l00470"></a>00470                 DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>,
<a name="l00471"></a>00471                             <span class="stringliteral">&quot;    oid is out of range. Not processed: &quot;</span>));
<a name="l00472"></a>00472                 DEBUGMSGOID((<span class="stringliteral">&quot;helper:table&quot;</span>, var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>, var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a>));
<a name="l00473"></a>00473                 DEBUGMSG((<span class="stringliteral">&quot;helper:table&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l00474"></a>00474 
<a name="l00475"></a>00475                 <span class="comment">/*</span>
<a name="l00476"></a>00476 <span class="comment">                 *  Reject requests of the form &#39;myEntry.N&#39;   (invalid N)</span>
<a name="l00477"></a>00477 <span class="comment">                 */</span>
<a name="l00478"></a>00478 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l00479"></a>00479 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_SET_RESERVE1)
<a name="l00480"></a>00480                     table_helper_cleanup(reqinfo, request,
<a name="l00481"></a>00481                                          SNMP_ERR_NOTWRITABLE);
<a name="l00482"></a>00482                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_GET)
<a name="l00483"></a>00483 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00484"></a>00484                     table_helper_cleanup(reqinfo, request,
<a name="l00485"></a>00485                                          SNMP_NOSUCHOBJECT);
<a name="l00486"></a>00486                 <span class="keywordflow">continue</span>;
<a name="l00487"></a>00487             }
<a name="l00488"></a>00488             <span class="comment">/*</span>
<a name="l00489"></a>00489 <span class="comment">             * use column verification </span>
<a name="l00490"></a>00490 <span class="comment">             */</span>
<a name="l00491"></a>00491             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#aaedf72ed4f760e9926f739553da49835" title="more details on columns">valid_columns</a>) {
<a name="l00492"></a>00492                 tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> =
<a name="l00493"></a>00493                     netsnmp_closest_column(var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>[oid_column_pos],
<a name="l00494"></a>00494                                            tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#aaedf72ed4f760e9926f739553da49835" title="more details on columns">valid_columns</a>);
<a name="l00495"></a>00495                 DEBUGMSGTL((<span class="stringliteral">&quot;helper:table:col&quot;</span>, <span class="stringliteral">&quot;    closest column is %d\n&quot;</span>,
<a name="l00496"></a>00496                             tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a>));
<a name="l00497"></a>00497                 <span class="comment">/*</span>
<a name="l00498"></a>00498 <span class="comment">                 * xxx-rks: document why the continue...</span>
<a name="l00499"></a>00499 <span class="comment">                 */</span>
<a name="l00500"></a>00500                 <span class="keywordflow">if</span> (tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> == 0)
<a name="l00501"></a>00501                     <span class="keywordflow">continue</span>;
<a name="l00502"></a>00502                 <span class="keywordflow">if</span> (tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> != var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>[oid_column_pos]) {
<a name="l00503"></a>00503                     DEBUGMSGTL((<span class="stringliteral">&quot;helper:table:col&quot;</span>,
<a name="l00504"></a>00504                                 <span class="stringliteral">&quot;    which doesn&#39;t match req &quot;</span>
<a name="l00505"></a>00505                                 <span class="stringliteral">&quot;%&quot;</span> NETSNMP_PRIo <span class="stringliteral">&quot;d - truncating index info\n&quot;</span>,
<a name="l00506"></a>00506                                 var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>[oid_column_pos]));
<a name="l00507"></a>00507                     <span class="comment">/*</span>
<a name="l00508"></a>00508 <span class="comment">                     * different column! truncate useless index info </span>
<a name="l00509"></a>00509 <span class="comment">                     */</span>
<a name="l00510"></a>00510                     var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a> = oid_column_pos + 1; <span class="comment">/* pos is 0 based */</span>
<a name="l00511"></a>00511                 }
<a name="l00512"></a>00512             }
<a name="l00513"></a>00513             <span class="comment">/*</span>
<a name="l00514"></a>00514 <span class="comment">             * var-&gt;name_length may have changed - check again </span>
<a name="l00515"></a>00515 <span class="comment">             */</span>
<a name="l00516"></a>00516             <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a> &lt;= oid_index_pos) { <span class="comment">/* pos is 0 based */</span>
<a name="l00517"></a>00517                 DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>, <span class="stringliteral">&quot;    not enough for indexes\n&quot;</span>));
<a name="l00518"></a>00518                 tbl_req_info-&gt;index_oid_len = 0; 
<a name="l00519"></a>00519             } <span class="keywordflow">else</span> {
<a name="l00520"></a>00520                 <span class="comment">/*</span>
<a name="l00521"></a>00521 <span class="comment">                 * oid is long enough to contain INDEX info</span>
<a name="l00522"></a>00522 <span class="comment">                 */</span>
<a name="l00523"></a>00523                 tbl_req_info-&gt;index_oid_len =
<a name="l00524"></a>00524                     var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a> - oid_index_pos;
<a name="l00525"></a>00525                 DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>, <span class="stringliteral">&quot;    have %lu bytes of index\n&quot;</span>,
<a name="l00526"></a>00526                             (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)tbl_req_info-&gt;index_oid_len));
<a name="l00527"></a>00527                 netsnmp_assert(tbl_req_info-&gt;index_oid_len &lt; MAX_OID_LEN);
<a name="l00528"></a>00528                 memcpy(tbl_req_info-&gt;index_oid, &amp;var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>[oid_index_pos],
<a name="l00529"></a>00529                        tbl_req_info-&gt;index_oid_len * <span class="keyword">sizeof</span>(oid));
<a name="l00530"></a>00530                 tmp_name = tbl_req_info-&gt;index_oid;
<a name="l00531"></a>00531             }
<a name="l00532"></a>00532         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_GETNEXT ||
<a name="l00533"></a>00533                    reqinfo-&gt;mode == MODE_GETBULK) {
<a name="l00534"></a>00534             <span class="comment">/*</span>
<a name="l00535"></a>00535 <span class="comment">             * oid is NOT long enough to contain column or index info, so start</span>
<a name="l00536"></a>00536 <span class="comment">             * at the minimum column. Set index oid len to 0 because we don&#39;t</span>
<a name="l00537"></a>00537 <span class="comment">             * have any index info in the OID.</span>
<a name="l00538"></a>00538 <span class="comment">             */</span>
<a name="l00539"></a>00539             DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>, <span class="stringliteral">&quot;  no column/index in request\n&quot;</span>));
<a name="l00540"></a>00540             tbl_req_info-&gt;index_oid_len = 0;
<a name="l00541"></a>00541             tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> = tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#ae48fd51376f573a4c4e5aede809f7092" title="the minimum columns number.">min_column</a>;
<a name="l00542"></a>00542         } <span class="keywordflow">else</span> {
<a name="l00543"></a>00543             <span class="comment">/*</span>
<a name="l00544"></a>00544 <span class="comment">             * oid is NOT long enough to contain index info,</span>
<a name="l00545"></a>00545 <span class="comment">             * so we can&#39;t do anything with it.</span>
<a name="l00546"></a>00546 <span class="comment">             *</span>
<a name="l00547"></a>00547 <span class="comment">             * Reject requests of the form &#39;myTable&#39; or &#39;myEntry&#39;</span>
<a name="l00548"></a>00548 <span class="comment">             */</span>
<a name="l00549"></a>00549             <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_GET ) {
<a name="l00550"></a>00550                 table_helper_cleanup(reqinfo, request, SNMP_NOSUCHOBJECT);
<a name="l00551"></a>00551 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l00552"></a>00552 <span class="preprocessor"></span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_SET_RESERVE1 ) {
<a name="l00553"></a>00553                 table_helper_cleanup(reqinfo, request, SNMP_ERR_NOTWRITABLE);
<a name="l00554"></a>00554 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00555"></a>00555             }
<a name="l00556"></a>00556             <span class="keywordflow">continue</span>;
<a name="l00557"></a>00557         }
<a name="l00558"></a>00558 
<a name="l00559"></a>00559         <span class="comment">/*</span>
<a name="l00560"></a>00560 <span class="comment">         * set up tmp_len to be the number of OIDs we have beyond the column;</span>
<a name="l00561"></a>00561 <span class="comment">         * these should be the index(s) for the table. If the index_oid_len</span>
<a name="l00562"></a>00562 <span class="comment">         * is 0, set tmp_len to -1 so that when we try to parse the index below,</span>
<a name="l00563"></a>00563 <span class="comment">         * we just zero fill everything.</span>
<a name="l00564"></a>00564 <span class="comment">         */</span>
<a name="l00565"></a>00565         <span class="keywordflow">if</span> (tbl_req_info-&gt;index_oid_len == 0) {
<a name="l00566"></a>00566             incomplete = 1;
<a name="l00567"></a>00567             tmp_len = -1;
<a name="l00568"></a>00568         } <span class="keywordflow">else</span>
<a name="l00569"></a>00569             tmp_len = tbl_req_info-&gt;index_oid_len;
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 
<a name="l00572"></a>00572         <span class="comment">/*</span>
<a name="l00573"></a>00573 <span class="comment">         * for each index type, try to extract the index from var-&gt;name</span>
<a name="l00574"></a>00574 <span class="comment">         */</span>
<a name="l00575"></a>00575         DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>, <span class="stringliteral">&quot;  looking for %d indexes\n&quot;</span>,
<a name="l00576"></a>00576                     tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a31ac0da11dbc52abe401401df065020a" title="calculated automatically">number_indexes</a>));
<a name="l00577"></a>00577         <span class="keywordflow">for</span> (tmp_idx = 0, vb = tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a>;
<a name="l00578"></a>00578              tmp_idx &lt; tbl_info-&gt;number_indexes;
<a name="l00579"></a>00579              ++tmp_idx, vb = vb-&gt;<a class="code" href="structvariable__list.html#a036af3c8c73da042622a58afa452d76e" title="NULL for last variable.">next_variable</a>) {
<a name="l00580"></a>00580             <span class="keywordtype">size_t</span> parsed_oid_len;
<a name="l00581"></a>00581 
<a name="l00582"></a>00582             <span class="keywordflow">if</span> (incomplete &amp;&amp; tmp_len) {
<a name="l00583"></a>00583                 <span class="comment">/*</span>
<a name="l00584"></a>00584 <span class="comment">                 * incomplete/illegal OID, set up dummy 0 to parse </span>
<a name="l00585"></a>00585 <span class="comment">                 */</span>
<a name="l00586"></a>00586                 DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>,
<a name="l00587"></a>00587                             <span class="stringliteral">&quot;  oid indexes not complete: &quot;</span>));
<a name="l00588"></a>00588                 DEBUGMSGOID((<span class="stringliteral">&quot;helper:table&quot;</span>, var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>, var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a>));
<a name="l00589"></a>00589                 DEBUGMSG((<span class="stringliteral">&quot;helper:table&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l00590"></a>00590 
<a name="l00591"></a>00591                 <span class="comment">/*</span>
<a name="l00592"></a>00592 <span class="comment">                 * no sense in trying anymore if this is a GET/SET. </span>
<a name="l00593"></a>00593 <span class="comment">                 *</span>
<a name="l00594"></a>00594 <span class="comment">                 * Reject requests of the form &#39;myObject&#39;   (no instance)</span>
<a name="l00595"></a>00595 <span class="comment">                 */</span>
<a name="l00596"></a>00596                 tmp_len = 0;
<a name="l00597"></a>00597                 tmp_name = NULL;
<a name="l00598"></a>00598                 <span class="keywordflow">break</span>;
<a name="l00599"></a>00599             }
<a name="l00600"></a>00600             <span class="comment">/*</span>
<a name="l00601"></a>00601 <span class="comment">             * try and parse current index </span>
<a name="l00602"></a>00602 <span class="comment">             */</span>
<a name="l00603"></a>00603             netsnmp_assert(tmp_len &gt;= 0);
<a name="l00604"></a>00604             parsed_oid_len = tmp_len;
<a name="l00605"></a>00605             <span class="keywordflow">if</span> (parse_one_oid_index(&amp;tmp_name, &amp;parsed_oid_len,
<a name="l00606"></a>00606                                     vb, 1) != SNMPERR_SUCCESS) {
<a name="l00607"></a>00607                 incomplete = 1;
<a name="l00608"></a>00608                 tmp_len = -1;   <span class="comment">/* is this necessary? Better safe than</span>
<a name="l00609"></a>00609 <span class="comment">                                 * sorry */</span>
<a name="l00610"></a>00610             } <span class="keywordflow">else</span> {
<a name="l00611"></a>00611                 tmp_len = parsed_oid_len;
<a name="l00612"></a>00612                 DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>, <span class="stringliteral">&quot;  got 1 (incomplete=%d)\n&quot;</span>,
<a name="l00613"></a>00613                             incomplete));
<a name="l00614"></a>00614                 <span class="comment">/*</span>
<a name="l00615"></a>00615 <span class="comment">                 * do not count incomplete indexes </span>
<a name="l00616"></a>00616 <span class="comment">                 */</span>
<a name="l00617"></a>00617                 <span class="keywordflow">if</span> (incomplete)
<a name="l00618"></a>00618                     <span class="keywordflow">continue</span>;
<a name="l00619"></a>00619                 ++tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a7a5309fb5e3d994e4ccd4986b6a90bfd" title="0 if failure to parse any">number_indexes</a>; 
<a name="l00620"></a>00620                 <span class="keywordflow">if</span> (tmp_len &lt;= 0) {
<a name="l00621"></a>00621                     incomplete = 1;
<a name="l00622"></a>00622                     tmp_len = -1;       <span class="comment">/* is this necessary? Better safe</span>
<a name="l00623"></a>00623 <span class="comment">                                         * than sorry */</span>
<a name="l00624"></a>00624                 }
<a name="l00625"></a>00625             }
<a name="l00626"></a>00626         }                       
<a name="l00628"></a>00628         DEBUGIF(<span class="stringliteral">&quot;helper:table:results&quot;</span>) {
<a name="l00629"></a>00629                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    count;
<a name="l00630"></a>00630                 u_char         *buf = NULL;
<a name="l00631"></a>00631                 <span class="keywordtype">size_t</span>          buf_len = 0, out_len = 0;
<a name="l00632"></a>00632                 DEBUGMSGTL((<span class="stringliteral">&quot;helper:table:results&quot;</span>, <span class="stringliteral">&quot;  found %d indexes\n&quot;</span>,
<a name="l00633"></a>00633                             tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a7a5309fb5e3d994e4ccd4986b6a90bfd" title="0 if failure to parse any">number_indexes</a>));
<a name="l00634"></a>00634                 DEBUGMSGTL((<span class="stringliteral">&quot;helper:table:results&quot;</span>,
<a name="l00635"></a>00635                             <span class="stringliteral">&quot;  column: %d, indexes: %d&quot;</span>,
<a name="l00636"></a>00636                             tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a>,
<a name="l00637"></a>00637                             tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a7a5309fb5e3d994e4ccd4986b6a90bfd" title="0 if failure to parse any">number_indexes</a>));
<a name="l00638"></a>00638                 <span class="keywordflow">for</span> (vb = tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a>, count = 0;
<a name="l00639"></a>00639                      vb &amp;&amp; count &lt; tbl_req_info-&gt;number_indexes;
<a name="l00640"></a>00640                      count++, vb = vb-&gt;<a class="code" href="structvariable__list.html#a036af3c8c73da042622a58afa452d76e" title="NULL for last variable.">next_variable</a>) {
<a name="l00641"></a>00641                     out_len = 0;
<a name="l00642"></a>00642                     <span class="keywordflow">if</span> (<a class="code" href="group__mib__utilities.html#gaabc12c361abdca75234c11dccb34871b" title="Universal print routine, prints a variable into a buffer according to the variable type...">sprint_realloc_by_type</a>(&amp;buf, &amp;buf_len, &amp;out_len, 1,
<a name="l00643"></a>00643                                                vb, NULL, NULL, NULL)) {
<a name="l00644"></a>00644                         DEBUGMSG((<span class="stringliteral">&quot;helper:table:results&quot;</span>,
<a name="l00645"></a>00645                                   <span class="stringliteral">&quot;   index: type=%d(%02x), value=%s&quot;</span>,
<a name="l00646"></a>00646                                   vb-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a>, vb-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a>, buf));
<a name="l00647"></a>00647                     } <span class="keywordflow">else</span> {
<a name="l00648"></a>00648                         <span class="keywordflow">if</span> (buf != NULL) {
<a name="l00649"></a>00649                             DEBUGMSG((<span class="stringliteral">&quot;helper:table:results&quot;</span>,
<a name="l00650"></a>00650                                       <span class="stringliteral">&quot;   index: type=%d(%02x), value=%s [TRUNCATED]&quot;</span>,
<a name="l00651"></a>00651                                       vb-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a>, vb-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a>, buf));
<a name="l00652"></a>00652                         } <span class="keywordflow">else</span> {
<a name="l00653"></a>00653                             DEBUGMSG((<span class="stringliteral">&quot;helper:table:results&quot;</span>,
<a name="l00654"></a>00654                                       <span class="stringliteral">&quot;   index: type=%d(%02x), value=[NIL] [TRUNCATED]&quot;</span>,
<a name="l00655"></a>00655                                       vb-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a>, vb-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a>));
<a name="l00656"></a>00656                         }
<a name="l00657"></a>00657                     }
<a name="l00658"></a>00658                 }
<a name="l00659"></a>00659                 <span class="keywordflow">if</span> (buf != NULL) {
<a name="l00660"></a>00660                     free(buf);
<a name="l00661"></a>00661                 }
<a name="l00662"></a>00662                 DEBUGMSG((<span class="stringliteral">&quot;helper:table:results&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l00663"></a>00663         }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665 
<a name="l00666"></a>00666         <span class="comment">/*</span>
<a name="l00667"></a>00667 <span class="comment">         * do we have sufficient index info to continue?</span>
<a name="l00668"></a>00668 <span class="comment">         */</span>
<a name="l00669"></a>00669 
<a name="l00670"></a>00670         <span class="keywordflow">if</span> ((reqinfo-&gt;mode != MODE_GETNEXT) &amp;&amp;
<a name="l00671"></a>00671             ((tbl_req_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a7a5309fb5e3d994e4ccd4986b6a90bfd" title="0 if failure to parse any">number_indexes</a> != tbl_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a31ac0da11dbc52abe401401df065020a" title="calculated automatically">number_indexes</a>) ||
<a name="l00672"></a>00672              (tmp_len != -1))) {
<a name="l00673"></a>00673 
<a name="l00674"></a>00674             DEBUGMSGTL((<span class="stringliteral">&quot;helper:table&quot;</span>,
<a name="l00675"></a>00675                         <span class="stringliteral">&quot;invalid index(es) for table - skipping\n&quot;</span>));
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l00678"></a>00678 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( MODE_IS_SET(reqinfo-&gt;mode) ) {
<a name="l00679"></a>00679                 <span class="comment">/*</span>
<a name="l00680"></a>00680 <span class="comment">                 * no point in continuing without indexes for set.</span>
<a name="l00681"></a>00681 <span class="comment">                 */</span>
<a name="l00682"></a>00682                 netsnmp_assert(reqinfo-&gt;mode == MODE_SET_RESERVE1);
<a name="l00684"></a>00684                 <a class="code" href="group__handler.html#ga14d1a9eeb19594f07d4cb70de8a89145" title="Free the extra data stored in a bunch of requests.">netsnmp_free_request_data_sets</a>(requests);
<a name="l00686"></a>00686                 table_helper_cleanup(reqinfo, request, SNMP_ERR_NOCREATION);
<a name="l00687"></a>00687                 need_processing = 0; <span class="comment">/* don&#39;t call next handler */</span>
<a name="l00688"></a>00688                 <span class="keywordflow">break</span>;
<a name="l00689"></a>00689             }
<a name="l00690"></a>00690 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00691"></a>00691             table_helper_cleanup(reqinfo, request, SNMP_NOSUCHINSTANCE);
<a name="l00692"></a>00692             <span class="keywordflow">continue</span>;
<a name="l00693"></a>00693         }
<a name="l00694"></a>00694         netsnmp_assert(request-&gt;status == SNMP_ERR_NOERROR);
<a name="l00695"></a>00695         
<a name="l00696"></a>00696         ++need_processing;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698     }                           <span class="comment">/* for each request */</span>
<a name="l00699"></a>00699 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l00700"></a>00700 <span class="preprocessor"></span>    }
<a name="l00701"></a>00701 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l00702"></a>00702 
<a name="l00703"></a>00703     <span class="comment">/*</span>
<a name="l00704"></a>00704 <span class="comment">     * bail if there is nothing for our child handlers</span>
<a name="l00705"></a>00705 <span class="comment">     */</span>
<a name="l00706"></a>00706     <span class="keywordflow">if</span> (0 == need_processing)
<a name="l00707"></a>00707         <span class="keywordflow">return</span> status;
<a name="l00708"></a>00708 
<a name="l00709"></a>00709     <span class="comment">/*</span>
<a name="l00710"></a>00710 <span class="comment">     * call our child access function </span>
<a name="l00711"></a>00711 <span class="comment">     */</span>
<a name="l00712"></a>00712     status =
<a name="l00713"></a>00713         netsnmp_call_next_handler(handler, reginfo, reqinfo, requests);
<a name="l00714"></a>00714 
<a name="l00715"></a>00715     <span class="comment">/*</span>
<a name="l00716"></a>00716 <span class="comment">     * check for sparse tables</span>
<a name="l00717"></a>00717 <span class="comment">     */</span>
<a name="l00718"></a>00718     <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_GETNEXT)
<a name="l00719"></a>00719         sparse_table_helper_handler( handler, reginfo, reqinfo, requests );
<a name="l00720"></a>00720 
<a name="l00721"></a>00721     <span class="keywordflow">return</span> status;
<a name="l00722"></a>00722 }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 <span class="preprocessor">#define SPARSE_TABLE_HANDLER_NAME &quot;sparse_table&quot;</span>
<a name="l00725"></a>00725 <span class="preprocessor"></span>
<a name="l00734"></a>00734 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00735"></a>00735 sparse_table_helper_handler(<a class="code" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler</a> *handler,
<a name="l00736"></a>00736                      <a class="code" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration</a> *reginfo,
<a name="l00737"></a>00737                      <a class="code" href="structnetsnmp__agent__request__info__s.html" title="The agent transaction request structure.">netsnmp_agent_request_info</a> *reqinfo,
<a name="l00738"></a>00738                      <a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *requests)
<a name="l00739"></a>00739 {
<a name="l00740"></a>00740     <span class="keywordtype">int</span>             status = SNMP_ERR_NOERROR;
<a name="l00741"></a>00741     <a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *request;
<a name="l00742"></a>00742     oid             coloid[MAX_OID_LEN];
<a name="l00743"></a>00743     <a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *table_info;
<a name="l00744"></a>00744 
<a name="l00745"></a>00745     <span class="comment">/*</span>
<a name="l00746"></a>00746 <span class="comment">     * since we don&#39;t call child handlers, warn if one was registered</span>
<a name="l00747"></a>00747 <span class="comment">     * beneath us. A special exception for the table helper, which calls</span>
<a name="l00748"></a>00748 <span class="comment">     * the handler directly. Use handle custom flag to only log once.</span>
<a name="l00749"></a>00749 <span class="comment">     */</span>
<a name="l00750"></a>00750     <span class="keywordflow">if</span>((<a class="code" href="group__table.html#ga571606b4d4e705a4420ff73ce3ac6b00" title="implements the table helper handler">table_helper_handler</a> != handler-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#ae75b8ace28cb246887fa85d410fc844b" title="if you add more members, you probably also want to update">access_method</a>) &amp;&amp;
<a name="l00751"></a>00751        (NULL != handler-&gt;next)) {
<a name="l00752"></a>00752         <span class="comment">/*</span>
<a name="l00753"></a>00753 <span class="comment">         * always warn if called without our own handler. If we</span>
<a name="l00754"></a>00754 <span class="comment">         * have our own handler, use custom bit 1 to only log once.</span>
<a name="l00755"></a>00755 <span class="comment">         */</span>
<a name="l00756"></a>00756         <span class="keywordflow">if</span>((sparse_table_helper_handler != handler-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#ae75b8ace28cb246887fa85d410fc844b" title="if you add more members, you probably also want to update">access_method</a>) ||
<a name="l00757"></a>00757            !(handler-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#a320fa53cc0c6edac56c54d6dcf17dfe9" title="for agent_handler&#39;s internal use">flags</a> &amp; MIB_HANDLER_CUSTOM1)) {
<a name="l00758"></a>00758             <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_WARNING, <span class="stringliteral">&quot;handler (%s) registered after sparse table &quot;</span>
<a name="l00759"></a>00759                      <span class="stringliteral">&quot;hander will not be called\n&quot;</span>,
<a name="l00760"></a>00760                      handler-&gt;next-&gt;handler_name ?
<a name="l00761"></a>00761                      handler-&gt;next-&gt;handler_name : <span class="stringliteral">&quot;&quot;</span> );
<a name="l00762"></a>00762             <span class="keywordflow">if</span>(sparse_table_helper_handler == handler-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#ae75b8ace28cb246887fa85d410fc844b" title="if you add more members, you probably also want to update">access_method</a>)
<a name="l00763"></a>00763                 handler-&gt;<a class="code" href="structnetsnmp__mib__handler__s.html#a320fa53cc0c6edac56c54d6dcf17dfe9" title="for agent_handler&#39;s internal use">flags</a> |= MIB_HANDLER_CUSTOM1;
<a name="l00764"></a>00764         }
<a name="l00765"></a>00765     }
<a name="l00766"></a>00766 
<a name="l00767"></a>00767     <span class="keywordflow">if</span> (reqinfo-&gt;mode == MODE_GETNEXT) {
<a name="l00768"></a>00768         <span class="keywordflow">for</span>(request = requests ; request; request = request-&gt;next) {
<a name="l00769"></a>00769             <span class="keywordflow">if</span> ((request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a> == ASN_NULL &amp;&amp; request-&gt;processed) ||
<a name="l00770"></a>00770                 request-&gt;delegated)
<a name="l00771"></a>00771                 <span class="keywordflow">continue</span>;
<a name="l00772"></a>00772             <span class="keywordflow">if</span> (request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a> == SNMP_NOSUCHINSTANCE) {
<a name="l00773"></a>00773                 <span class="comment">/*</span>
<a name="l00774"></a>00774 <span class="comment">                 * get next skipped this value for this column, we</span>
<a name="l00775"></a>00775 <span class="comment">                 * need to keep searching forward </span>
<a name="l00776"></a>00776 <span class="comment">                 */</span>
<a name="l00777"></a>00777                 DEBUGMSGT((<span class="stringliteral">&quot;sparse&quot;</span>, <span class="stringliteral">&quot;retry for NOSUCHINSTANCE\n&quot;</span>));
<a name="l00778"></a>00778                 request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a> = ASN_PRIV_RETRY;
<a name="l00779"></a>00779             }
<a name="l00780"></a>00780             <span class="keywordflow">if</span> (request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a> == SNMP_NOSUCHOBJECT ||
<a name="l00781"></a>00781                 request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a> == SNMP_ENDOFMIBVIEW) {
<a name="l00782"></a>00782                 <span class="comment">/*</span>
<a name="l00783"></a>00783 <span class="comment">                 * get next has completely finished with this column,</span>
<a name="l00784"></a>00784 <span class="comment">                 * so we need to try with the next column (if any)</span>
<a name="l00785"></a>00785 <span class="comment">                 */</span>
<a name="l00786"></a>00786                 DEBUGMSGT((<span class="stringliteral">&quot;sparse&quot;</span>, <span class="stringliteral">&quot;retry for NOSUCHOBJECT\n&quot;</span>));
<a name="l00787"></a>00787                 table_info = <a class="code" href="group__table.html#ga0f2aa788814b909e3e3003b63b1dbd3a" title="Extracts the processed table information from a given request.">netsnmp_extract_table_info</a>(request);
<a name="l00788"></a>00788                 table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> = netsnmp_table_next_column(table_info);
<a name="l00789"></a>00789                 <span class="keywordflow">if</span> (0 != table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a>) {
<a name="l00790"></a>00790                     memcpy(coloid, reginfo-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#a264722b6b9385237fbcb5f8bc144d470" title="where are we registered at?">rootoid</a>,
<a name="l00791"></a>00791                            reginfo-&gt;rootoid_len * <span class="keyword">sizeof</span>(oid));
<a name="l00792"></a>00792                     coloid[reginfo-&gt;rootoid_len]   = 1;   <span class="comment">/* table.entry node */</span>
<a name="l00793"></a>00793                     coloid[reginfo-&gt;rootoid_len+1] = table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a>;
<a name="l00794"></a>00794                     snmp_set_var_objid(request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>,
<a name="l00795"></a>00795                                        coloid, reginfo-&gt;rootoid_len + 2);
<a name="l00796"></a>00796                     
<a name="l00797"></a>00797                     request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a> = ASN_PRIV_RETRY;
<a name="l00798"></a>00798                 }
<a name="l00799"></a>00799                 <span class="keywordflow">else</span> {
<a name="l00800"></a>00800                     <span class="comment">/*</span>
<a name="l00801"></a>00801 <span class="comment">                     * If we don&#39;t have column info, reset to null so</span>
<a name="l00802"></a>00802 <span class="comment">                     * the agent will move on to the next table.</span>
<a name="l00803"></a>00803 <span class="comment">                     */</span>
<a name="l00804"></a>00804                     request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a> = ASN_NULL;
<a name="l00805"></a>00805                 }
<a name="l00806"></a>00806             }
<a name="l00807"></a>00807         }
<a name="l00808"></a>00808     }
<a name="l00809"></a>00809     <span class="keywordflow">return</span> status;
<a name="l00810"></a>00810 }
<a name="l00811"></a>00811 
<a name="l00814"></a>00814 <span class="preprocessor">#ifndef NETSNMP_FEATURE_REMOVE_TABLE_SPARSE</span>
<a name="l00815"></a>00815 <span class="preprocessor"></span><a class="code" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler</a> *
<a name="l00816"></a><a class="code" href="group__table.html#ga2ea65cc682cad5695f16c6eabef4489b">00816</a> <a class="code" href="group__table.html#ga2ea65cc682cad5695f16c6eabef4489b" title="create sparse table handler">netsnmp_sparse_table_handler_get</a>(<span class="keywordtype">void</span>)
<a name="l00817"></a>00817 {
<a name="l00818"></a>00818     <span class="keywordflow">return</span> netsnmp_create_handler(SPARSE_TABLE_HANDLER_NAME,
<a name="l00819"></a>00819                                   sparse_table_helper_handler);
<a name="l00820"></a>00820 }
<a name="l00821"></a>00821 
<a name="l00826"></a>00826 <span class="keywordtype">int</span>
<a name="l00827"></a><a class="code" href="group__table.html#ga82f2d76b366b08edb76e93ddba44849d">00827</a> <a class="code" href="group__table.html#ga82f2d76b366b08edb76e93ddba44849d" title="creates a table handler given the netsnmp_table_registration_info object, inserts it into the request...">netsnmp_sparse_table_register</a>(<a class="code" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration</a> *reginfo,
<a name="l00828"></a>00828                        <a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *tabreq)
<a name="l00829"></a>00829 {
<a name="l00830"></a>00830     <a class="code" href="structnetsnmp__mib__handler__s.html" title="the mib handler structure to be registered">netsnmp_mib_handler</a> *handler1, *handler2;
<a name="l00831"></a>00831     <span class="keywordtype">int</span> rc;
<a name="l00832"></a>00832 
<a name="l00833"></a>00833     handler1 = netsnmp_create_handler(SPARSE_TABLE_HANDLER_NAME,
<a name="l00834"></a>00834                                      sparse_table_helper_handler);
<a name="l00835"></a>00835     <span class="keywordflow">if</span> (NULL == handler1)
<a name="l00836"></a>00836         <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l00837"></a>00837 
<a name="l00838"></a>00838     handler2 = netsnmp_get_table_handler(tabreq);
<a name="l00839"></a>00839     <span class="keywordflow">if</span> (NULL == handler2 ) {
<a name="l00840"></a>00840         <a class="code" href="group__handler.html#gac0eb7f89dee961df2d09084fd7925952" title="Deallocates resources associated with a given handler.">netsnmp_handler_free</a>(handler1);
<a name="l00841"></a>00841         <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l00842"></a>00842     }
<a name="l00843"></a>00843 
<a name="l00844"></a>00844     rc = <a class="code" href="group__handler.html#ga6649d75b3eaf98d70704754d3d8235f3" title="Injects handler into the calling chain of handlers.">netsnmp_inject_handler</a>(reginfo, handler1);
<a name="l00845"></a>00845     <span class="keywordflow">if</span> (SNMPERR_SUCCESS != rc) {
<a name="l00846"></a>00846         <a class="code" href="group__handler.html#gac0eb7f89dee961df2d09084fd7925952" title="Deallocates resources associated with a given handler.">netsnmp_handler_free</a>(handler1);
<a name="l00847"></a>00847         <a class="code" href="group__handler.html#gac0eb7f89dee961df2d09084fd7925952" title="Deallocates resources associated with a given handler.">netsnmp_handler_free</a>(handler2);
<a name="l00848"></a>00848         <span class="keywordflow">return</span> rc;
<a name="l00849"></a>00849     }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851     rc = <a class="code" href="group__handler.html#ga6649d75b3eaf98d70704754d3d8235f3" title="Injects handler into the calling chain of handlers.">netsnmp_inject_handler</a>(reginfo, handler2);
<a name="l00852"></a>00852     <span class="keywordflow">if</span> (SNMPERR_SUCCESS != rc) {
<a name="l00854"></a>00854         <a class="code" href="group__handler.html#gac0eb7f89dee961df2d09084fd7925952" title="Deallocates resources associated with a given handler.">netsnmp_handler_free</a>(handler2);
<a name="l00855"></a>00855         <span class="keywordflow">return</span> rc;
<a name="l00856"></a>00856     }
<a name="l00857"></a>00857 
<a name="l00859"></a>00859     <span class="keywordflow">return</span> <a class="code" href="group__handler.html#gacdbdb9d74898a5bf04b0992ea0316aa4" title="Registers a MIB handler inside the registration structure.">netsnmp_register_handler</a>(reginfo);
<a name="l00860"></a>00860 }
<a name="l00861"></a>00861 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_FEATURE_REMOVE_TABLE_SPARSE */</span>
<a name="l00862"></a>00862 
<a name="l00863"></a>00863 
<a name="l00864"></a>00864 <span class="preprocessor">#ifndef NETSNMP_FEATURE_REMOVE_TABLE_BUILD_RESULT</span>
<a name="l00865"></a>00865 <span class="preprocessor"></span>
<a name="l00871"></a>00871 <span class="keywordtype">int</span>
<a name="l00872"></a><a class="code" href="group__table.html#ga841d2e015ff873f9e0110309f316c5f4">00872</a> <a class="code" href="group__table.html#ga841d2e015ff873f9e0110309f316c5f4" title="Builds the result to be returned to the agent given the table information.">netsnmp_table_build_result</a>(<a class="code" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration</a> *reginfo,
<a name="l00873"></a>00873                            <a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *reqinfo,
<a name="l00874"></a>00874                            <a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *table_info,
<a name="l00875"></a>00875                            u_char type, u_char * result, <span class="keywordtype">size_t</span> result_len)
<a name="l00876"></a>00876 {
<a name="l00877"></a>00877 
<a name="l00878"></a>00878     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *var;
<a name="l00879"></a>00879 
<a name="l00880"></a>00880     <span class="keywordflow">if</span> (!reqinfo || !table_info)
<a name="l00881"></a>00881         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l00882"></a>00882 
<a name="l00883"></a>00883     var = reqinfo-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>;
<a name="l00884"></a>00884 
<a name="l00885"></a>00885     <span class="keywordflow">if</span> (var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a> != var-&gt;<a class="code" href="structvariable__list.html#a5b8071f7514fb530c9b596791bca6813" title="buffer to hold the OID">name_loc</a>)
<a name="l00886"></a>00886         free(var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>);
<a name="l00887"></a>00887     var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a> = NULL;
<a name="l00888"></a>00888 
<a name="l00889"></a>00889     <span class="keywordflow">if</span> (<a class="code" href="group__table.html#ga872f2b0efe5bd631441de780ecdb6e34" title="given a registration info object, a request object and the table info object it builds the request-&gt;r...">netsnmp_table_build_oid</a>(reginfo, reqinfo, table_info) !=
<a name="l00890"></a>00890         SNMPERR_SUCCESS)
<a name="l00891"></a>00891         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l00892"></a>00892 
<a name="l00893"></a>00893     <a class="code" href="group__snmp__client.html#gae3f88533cfdd61ec2b603963ef8a3394" title="snmp_set_var_typed_value is used to set data into the netsnmp_variable_list structure.">snmp_set_var_typed_value</a>(var, type, result, result_len);
<a name="l00894"></a>00894 
<a name="l00895"></a>00895     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l00896"></a>00896 }
<a name="l00897"></a>00897 
<a name="l00903"></a>00903 <span class="keywordtype">int</span>
<a name="l00904"></a><a class="code" href="group__table.html#ga872f2b0efe5bd631441de780ecdb6e34">00904</a> <a class="code" href="group__table.html#ga872f2b0efe5bd631441de780ecdb6e34" title="given a registration info object, a request object and the table info object it builds the request-&gt;r...">netsnmp_table_build_oid</a>(<a class="code" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration</a> *reginfo,
<a name="l00905"></a>00905                         <a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *reqinfo,
<a name="l00906"></a>00906                         <a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *table_info)
<a name="l00907"></a>00907 {
<a name="l00908"></a>00908     oid             tmpoid[MAX_OID_LEN];
<a name="l00909"></a>00909     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *var;
<a name="l00910"></a>00910 
<a name="l00911"></a>00911     <span class="keywordflow">if</span> (!reginfo || !reqinfo || !table_info)
<a name="l00912"></a>00912         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l00913"></a>00913 
<a name="l00914"></a>00914     <span class="comment">/*</span>
<a name="l00915"></a>00915 <span class="comment">     * xxx-rks: inefficent. we do a copy here, then build_oid does it</span>
<a name="l00916"></a>00916 <span class="comment">     *          again. either come up with a new utility routine, or</span>
<a name="l00917"></a>00917 <span class="comment">     *          do some hijinks here to eliminate extra copy.</span>
<a name="l00918"></a>00918 <span class="comment">     *          Probably could make sure all callers have the</span>
<a name="l00919"></a>00919 <span class="comment">     *          index &amp; variable list updated, and use</span>
<a name="l00920"></a>00920 <span class="comment">     *          netsnmp_table_build_oid_from_index() instead of all this.</span>
<a name="l00921"></a>00921 <span class="comment">     */</span>
<a name="l00922"></a>00922     memcpy(tmpoid, reginfo-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#a264722b6b9385237fbcb5f8bc144d470" title="where are we registered at?">rootoid</a>, reginfo-&gt;rootoid_len * <span class="keyword">sizeof</span>(oid));
<a name="l00923"></a>00923     tmpoid[reginfo-&gt;rootoid_len] = 1;   
<a name="l00924"></a>00924     tmpoid[reginfo-&gt;rootoid_len + 1] = table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a>; 
<a name="l00926"></a>00926     var = reqinfo-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>;
<a name="l00927"></a>00927     <span class="keywordflow">if</span> (<a class="code" href="group__mib__utilities.html#ga438e30e7500b071916fec5592384f956">build_oid</a>(&amp;var-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>, &amp;var-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a>,
<a name="l00928"></a>00928                   tmpoid, reginfo-&gt;rootoid_len + 2, table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a>)
<a name="l00929"></a>00929         != SNMPERR_SUCCESS)
<a name="l00930"></a>00930         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l00931"></a>00931 
<a name="l00932"></a>00932     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l00933"></a>00933 }
<a name="l00934"></a>00934 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_FEATURE_REMOVE_TABLE_BUILD_RESULT */</span>
<a name="l00935"></a>00935 
<a name="l00941"></a>00941 <span class="keywordtype">int</span>
<a name="l00942"></a><a class="code" href="group__table.html#ga7450b303b9bdbbc05bfdac6a6f2aba61">00942</a> <a class="code" href="group__table.html#ga7450b303b9bdbbc05bfdac6a6f2aba61" title="given a registration info object, a request object and the table info object it builds the request-&gt;r...">netsnmp_table_build_oid_from_index</a>(<a class="code" href="structnetsnmp__handler__registration__s.html" title="Root registration info.">netsnmp_handler_registration</a> *reginfo,
<a name="l00943"></a>00943                                    <a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *reqinfo,
<a name="l00944"></a>00944                                    <a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *table_info)
<a name="l00945"></a>00945 {
<a name="l00946"></a>00946     oid             tmpoid[MAX_OID_LEN];
<a name="l00947"></a>00947     <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> *var;
<a name="l00948"></a>00948     <span class="keywordtype">int</span>             len;
<a name="l00949"></a>00949 
<a name="l00950"></a>00950     <span class="keywordflow">if</span> (!reginfo || !reqinfo || !table_info)
<a name="l00951"></a>00951         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l00952"></a>00952 
<a name="l00953"></a>00953     var = reqinfo-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>;
<a name="l00954"></a>00954     len = reginfo-&gt;rootoid_len;
<a name="l00955"></a>00955     memcpy(tmpoid, reginfo-&gt;<a class="code" href="structnetsnmp__handler__registration__s.html#a264722b6b9385237fbcb5f8bc144d470" title="where are we registered at?">rootoid</a>, len * <span class="keyword">sizeof</span>(oid));
<a name="l00956"></a>00956     tmpoid[len++] = 1;          <span class="comment">/* .Entry */</span>
<a name="l00957"></a>00957     tmpoid[len++] = table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a>; <span class="comment">/* .column */</span>
<a name="l00958"></a>00958     memcpy(&amp;tmpoid[len], table_info-&gt;index_oid,
<a name="l00959"></a>00959            table_info-&gt;index_oid_len * <span class="keyword">sizeof</span>(oid));
<a name="l00960"></a>00960     len += table_info-&gt;index_oid_len;
<a name="l00961"></a>00961     snmp_set_var_objid( var, tmpoid, len );
<a name="l00962"></a>00962 
<a name="l00963"></a>00963     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l00964"></a>00964 }
<a name="l00965"></a>00965 
<a name="l00967"></a>00967 <span class="keywordtype">int</span>
<a name="l00968"></a><a class="code" href="group__table.html#ga6df6b6d782cc85a5b980acb2c4197725">00968</a> <a class="code" href="group__table.html#ga6df6b6d782cc85a5b980acb2c4197725" title="parses an OID into table indexses">netsnmp_update_variable_list_from_index</a>(<a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *tri)
<a name="l00969"></a>00969 {
<a name="l00970"></a>00970     <span class="keywordflow">if</span> (!tri)
<a name="l00971"></a>00971         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973     <span class="comment">/*</span>
<a name="l00974"></a>00974 <span class="comment">     * free any existing allocated memory, then parse oid into varbinds</span>
<a name="l00975"></a>00975 <span class="comment">     */</span>
<a name="l00976"></a>00976     snmp_reset_var_buffers( tri-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a>);
<a name="l00977"></a>00977 
<a name="l00978"></a>00978     <span class="keywordflow">return</span> parse_oid_indexes(tri-&gt;index_oid, tri-&gt;index_oid_len,
<a name="l00979"></a>00979                              tri-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a>);
<a name="l00980"></a>00980 }
<a name="l00981"></a>00981 
<a name="l00983"></a>00983 <span class="keywordtype">int</span>
<a name="l00984"></a><a class="code" href="group__table.html#gaa41463715fe95923d767ae7472e547c3">00984</a> <a class="code" href="group__table.html#gaa41463715fe95923d767ae7472e547c3" title="builds an oid given a set of indexes.">netsnmp_update_indexes_from_variable_list</a>(<a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *tri)
<a name="l00985"></a>00985 {
<a name="l00986"></a>00986     <span class="keywordflow">if</span> (!tri)
<a name="l00987"></a>00987         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l00988"></a>00988 
<a name="l00989"></a>00989     <span class="keywordflow">return</span> build_oid_noalloc(tri-&gt;index_oid, <span class="keyword">sizeof</span>(tri-&gt;index_oid),
<a name="l00990"></a>00990                              &amp;tri-&gt;index_oid_len, NULL, 0, tri-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a>);
<a name="l00991"></a>00991 }
<a name="l00992"></a>00992 
<a name="l01001"></a>01001 <span class="keywordtype">int</span>
<a name="l01002"></a><a class="code" href="group__table.html#gaa28a07930d1248645af1f2e9fbf337e7">01002</a> <a class="code" href="group__table.html#gaa28a07930d1248645af1f2e9fbf337e7" title="checks the original request against the current data being passed in if its greater than the request ...">netsnmp_check_getnext_reply</a>(<a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *request,
<a name="l01003"></a>01003                             oid * prefix,
<a name="l01004"></a>01004                             <span class="keywordtype">size_t</span> prefix_len,
<a name="l01005"></a>01005                             <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> * newvar,
<a name="l01006"></a>01006                             <a class="code" href="structvariable__list.html" title="The netsnmp variable list binding structure, it&#39;s typedef&#39;d to netsnmp_variable_list.">netsnmp_variable_list</a> ** outvar)
<a name="l01007"></a>01007 {
<a name="l01008"></a>01008     oid      myname[MAX_OID_LEN];
<a name="l01009"></a>01009     <span class="keywordtype">size_t</span>   myname_len;
<a name="l01010"></a>01010 
<a name="l01011"></a>01011     build_oid_noalloc(myname, MAX_OID_LEN, &amp;myname_len,
<a name="l01012"></a>01012                       prefix, prefix_len, newvar);
<a name="l01013"></a>01013     <span class="comment">/*</span>
<a name="l01014"></a>01014 <span class="comment">     * is the build of the new indexes less than our current result </span>
<a name="l01015"></a>01015 <span class="comment">     */</span>
<a name="l01016"></a>01016     <span class="keywordflow">if</span> ((!(*outvar) || <a class="code" href="group__library.html#gab5b48a42c19a801547e025ed40b4561e" title="lexicographical compare two object identifiers.">snmp_oid_compare</a>(myname + prefix_len,
<a name="l01017"></a>01017                                         myname_len - prefix_len,
<a name="l01018"></a>01018                                         (*outvar)-&gt;name + prefix_len,
<a name="l01019"></a>01019                                         (*outvar)-&gt;name_length -
<a name="l01020"></a>01020                                         prefix_len) &lt; 0)) {
<a name="l01021"></a>01021         <span class="comment">/*</span>
<a name="l01022"></a>01022 <span class="comment">         * and greater than the requested oid </span>
<a name="l01023"></a>01023 <span class="comment">         */</span>
<a name="l01024"></a>01024         <span class="keywordflow">if</span> (<a class="code" href="group__library.html#gab5b48a42c19a801547e025ed40b4561e" title="lexicographical compare two object identifiers.">snmp_oid_compare</a>(myname, myname_len,
<a name="l01025"></a>01025                              request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>-&gt;<a class="code" href="structvariable__list.html#a7b5bdda01921550d24ea53033ce76146" title="Object identifier of variable.">name</a>,
<a name="l01026"></a>01026                              request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a455d87f6b7178fe19ea564c60c0ccb6f" title="variable bindings">requestvb</a>-&gt;<a class="code" href="structvariable__list.html#a089e5b1a422bf8e693510ff5408a57a7" title="number of subid&#39;s in name">name_length</a>) &gt; 0) {
<a name="l01027"></a>01027             <span class="comment">/*</span>
<a name="l01028"></a>01028 <span class="comment">             * the new result must be better than the old </span>
<a name="l01029"></a>01029 <span class="comment">             */</span>
<a name="l01030"></a>01030 <span class="preprocessor">#ifdef ONLY_WORKS_WITH_ONE_VARBIND</span>
<a name="l01031"></a>01031 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (!*outvar)
<a name="l01032"></a>01032                 *outvar = snmp_clone_varbind(newvar);
<a name="l01033"></a>01033             <span class="keywordflow">else</span>
<a name="l01034"></a>01034                 <span class="comment">/* </span>
<a name="l01035"></a>01035 <span class="comment">                 * TODO: walk the full varbind list, setting</span>
<a name="l01036"></a>01036 <span class="comment">                 *       *all* the values - not just the first.</span>
<a name="l01037"></a>01037 <span class="comment">                 */</span>
<a name="l01038"></a>01038                 <a class="code" href="group__snmp__client.html#gae3f88533cfdd61ec2b603963ef8a3394" title="snmp_set_var_typed_value is used to set data into the netsnmp_variable_list structure.">snmp_set_var_typed_value</a>(*outvar, newvar-&gt;<a class="code" href="structvariable__list.html#a8bd719974b3554116631ea80dc88b6aa" title="ASN type of variable.">type</a>,
<a name="l01039"></a>01039                                 newvar-&gt;<a class="code" href="structvariable__list.html#a6ed7c00d712b83c174823b1cff6e9e29" title="value of variable">val</a>.string, newvar-&gt;<a class="code" href="structvariable__list.html#a17aaa6b445178fc39aba69642247d3e9" title="the length of the value to be copied into buf">val_len</a>);
<a name="l01040"></a>01040 <span class="preprocessor">#else  </span><span class="comment">/* Interim replacement approach - less efficient, but it works! */</span>
<a name="l01041"></a>01041             <span class="keywordflow">if</span> (*outvar)
<a name="l01042"></a>01042                 snmp_free_varbind(*outvar);
<a name="l01043"></a>01043             *outvar = snmp_clone_varbind(newvar);
<a name="l01044"></a>01044 <span class="preprocessor">#endif</span>
<a name="l01045"></a>01045 <span class="preprocessor"></span>            snmp_set_var_objid(*outvar, myname, myname_len);
<a name="l01046"></a>01046 
<a name="l01047"></a>01047             <span class="keywordflow">return</span> 1;
<a name="l01048"></a>01048         }
<a name="l01049"></a>01049     }
<a name="l01050"></a>01050     <span class="keywordflow">return</span> 0;
<a name="l01051"></a>01051 }
<a name="l01052"></a>01052 
<a name="l01053"></a>01053 <a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *
<a name="l01054"></a>01054 netsnmp_table_registration_info_clone(<a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *tri)
<a name="l01055"></a>01055 {
<a name="l01056"></a>01056     <a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *copy;
<a name="l01057"></a>01057     copy = malloc(<span class="keyword">sizeof</span>(*copy));
<a name="l01058"></a>01058     <span class="keywordflow">if</span> (copy) {
<a name="l01059"></a>01059         *copy = *tri;
<a name="l01060"></a>01060         copy-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a3045fe8e402e974d840af4084b88dc2a" title="list of varbinds with only &#39;type&#39; set">indexes</a> = snmp_clone_varbind(tri-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a3045fe8e402e974d840af4084b88dc2a" title="list of varbinds with only &#39;type&#39; set">indexes</a>);
<a name="l01061"></a>01061         <span class="keywordflow">if</span> (!copy-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a3045fe8e402e974d840af4084b88dc2a" title="list of varbinds with only &#39;type&#39; set">indexes</a>) {
<a name="l01062"></a>01062             free(copy);
<a name="l01063"></a>01063             copy = NULL;
<a name="l01064"></a>01064         }
<a name="l01065"></a>01065     }
<a name="l01066"></a>01066     <span class="keywordflow">return</span> copy;
<a name="l01067"></a>01067 }
<a name="l01068"></a>01068 
<a name="l01069"></a>01069 <span class="keywordtype">void</span>
<a name="l01070"></a>01070 netsnmp_table_registration_info_free(<a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *tri)
<a name="l01071"></a>01071 {
<a name="l01072"></a>01072     <span class="keywordflow">if</span> (NULL == tri)
<a name="l01073"></a>01073         <span class="keywordflow">return</span>;
<a name="l01074"></a>01074 
<a name="l01075"></a>01075     <span class="keywordflow">if</span> (NULL != tri-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a3045fe8e402e974d840af4084b88dc2a" title="list of varbinds with only &#39;type&#39; set">indexes</a>)
<a name="l01076"></a>01076         snmp_free_varbind(tri-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a3045fe8e402e974d840af4084b88dc2a" title="list of varbinds with only &#39;type&#39; set">indexes</a>);
<a name="l01077"></a>01077 
<a name="l01078"></a>01078 <span class="preprocessor">#if 0</span>
<a name="l01079"></a>01079 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l01080"></a>01080 <span class="comment">     * sigh... example use of valid_columns points to static memory,</span>
<a name="l01081"></a>01081 <span class="comment">     * so freeing it would be bad... we&#39;ll just have to live with any</span>
<a name="l01082"></a>01082 <span class="comment">     * leaks, for now...</span>
<a name="l01083"></a>01083 <span class="comment">     */</span>
<a name="l01084"></a>01084 <span class="preprocessor">#endif</span>
<a name="l01085"></a>01085 <span class="preprocessor"></span>
<a name="l01086"></a>01086     free(tri);
<a name="l01087"></a>01087 }
<a name="l01088"></a>01088 
<a name="l01091"></a>01091 <span class="comment">/*</span>
<a name="l01092"></a>01092 <span class="comment"> * internal routines </span>
<a name="l01093"></a>01093 <span class="comment"> */</span>
<a name="l01094"></a>01094 <span class="keywordtype">void</span>
<a name="l01095"></a>01095 table_data_free_func(<span class="keywordtype">void</span> *data)
<a name="l01096"></a>01096 {
<a name="l01097"></a>01097     <a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *info = (<a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *) data;
<a name="l01098"></a>01098     <span class="keywordflow">if</span> (!info)
<a name="l01099"></a>01099         <span class="keywordflow">return</span>;
<a name="l01100"></a>01100     snmp_free_varbind(info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#a585f93b117d282e0c857e7b3670f85af" title="contents freed by helper upon exit">indexes</a>);
<a name="l01101"></a>01101     free(info);
<a name="l01102"></a>01102 }
<a name="l01103"></a>01103 
<a name="l01104"></a>01104 
<a name="l01105"></a>01105 
<a name="l01106"></a>01106 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01107"></a>01107 table_helper_cleanup(<a class="code" href="structnetsnmp__agent__request__info__s.html" title="The agent transaction request structure.">netsnmp_agent_request_info</a> *reqinfo,
<a name="l01108"></a>01108                      <a class="code" href="structnetsnmp__request__info__s.html" title="The netsnmp request info structure.">netsnmp_request_info</a> *request, <span class="keywordtype">int</span> status)
<a name="l01109"></a>01109 {
<a name="l01110"></a>01110     <a class="code" href="group__snmp__agent.html#gac0668f1fd9036ebc88a734d9d4a6a59b" title="set error for a request">netsnmp_set_request_error</a>(reqinfo, request, status);
<a name="l01111"></a>01111     <a class="code" href="group__handler.html#ga14d1a9eeb19594f07d4cb70de8a89145" title="Free the extra data stored in a bunch of requests.">netsnmp_free_request_data_sets</a>(request);
<a name="l01112"></a>01112     <span class="keywordflow">if</span> (!request)
<a name="l01113"></a>01113         <span class="keywordflow">return</span>;
<a name="l01114"></a>01114     request-&gt;<a class="code" href="structnetsnmp__request__info__s.html#a6420dc3c100f91dc2c8bb6a383dbb4bd" title="can be used to pass information on a per-request basis from a helper to the later handlers...">parent_data</a> = NULL;
<a name="l01115"></a>01115 }
<a name="l01116"></a>01116 
<a name="l01117"></a>01117 
<a name="l01118"></a>01118 <span class="comment">/*</span>
<a name="l01119"></a>01119 <span class="comment"> * find the closest column to current (which may be current).</span>
<a name="l01120"></a>01120 <span class="comment"> *</span>
<a name="l01121"></a>01121 <span class="comment"> * called when a table runs out of rows for column X. This</span>
<a name="l01122"></a>01122 <span class="comment"> * function is called with current = X + 1, to verify that</span>
<a name="l01123"></a>01123 <span class="comment"> * X + 1 is a valid column, or find the next closest column if not.</span>
<a name="l01124"></a>01124 <span class="comment"> *</span>
<a name="l01125"></a>01125 <span class="comment"> * All list types should be sorted, lowest to highest.</span>
<a name="l01126"></a>01126 <span class="comment"> */</span>
<a name="l01127"></a>01127 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l01128"></a>01128 netsnmp_closest_column(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current,
<a name="l01129"></a>01129                        <a class="code" href="structnetsnmp__column__info__t.html" title="column info struct.">netsnmp_column_info</a> *valid_columns)
<a name="l01130"></a>01130 {
<a name="l01131"></a>01131     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    closest = 0;
<a name="l01132"></a>01132     <span class="keywordtype">int</span>             idx;
<a name="l01133"></a>01133 
<a name="l01134"></a>01134     <span class="keywordflow">if</span> (valid_columns == NULL)
<a name="l01135"></a>01135         <span class="keywordflow">return</span> 0;
<a name="l01136"></a>01136 
<a name="l01137"></a>01137     <span class="keywordflow">for</span>( ; valid_columns; valid_columns = valid_columns-&gt;next) {
<a name="l01138"></a>01138 
<a name="l01139"></a>01139         <span class="keywordflow">if</span> (valid_columns-&gt;isRange) {
<a name="l01140"></a>01140             <span class="comment">/*</span>
<a name="l01141"></a>01141 <span class="comment">             * if current &lt; low range, it might be closest.</span>
<a name="l01142"></a>01142 <span class="comment">             * otherwise, if it&#39;s &lt; high range, current is in</span>
<a name="l01143"></a>01143 <span class="comment">             * the range, and thus is an exact match.</span>
<a name="l01144"></a>01144 <span class="comment">             */</span>
<a name="l01145"></a>01145             <span class="keywordflow">if</span> (current &lt; valid_columns-&gt;details.range[0]) {
<a name="l01146"></a>01146                 <span class="keywordflow">if</span> ( (valid_columns-&gt;details.range[0] &lt; closest) ||
<a name="l01147"></a>01147                      (0 == closest)) {
<a name="l01148"></a>01148                     closest = valid_columns-&gt;details.range[0];
<a name="l01149"></a>01149                 }
<a name="l01150"></a>01150             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (current &lt;= valid_columns-&gt;details.range[1]) {
<a name="l01151"></a>01151                 closest = current;
<a name="l01152"></a>01152                 <span class="keywordflow">break</span>;       <span class="comment">/* can not get any closer! */</span>
<a name="l01153"></a>01153             }
<a name="l01154"></a>01154 
<a name="l01155"></a>01155         } <span class="comment">/* range */</span>
<a name="l01156"></a>01156         <span class="keywordflow">else</span> {                  <span class="comment">/* list */</span>
<a name="l01157"></a>01157             <span class="comment">/*</span>
<a name="l01158"></a>01158 <span class="comment">             * if current &lt; first item, no need to iterate over list.</span>
<a name="l01159"></a>01159 <span class="comment">             * that item is either closest, or not.</span>
<a name="l01160"></a>01160 <span class="comment">             */</span>
<a name="l01161"></a>01161             <span class="keywordflow">if</span> (current &lt; valid_columns-&gt;details.list[0]) {
<a name="l01162"></a>01162                 <span class="keywordflow">if</span> ((valid_columns-&gt;details.list[0] &lt; closest) ||
<a name="l01163"></a>01163                     (0 == closest))
<a name="l01164"></a>01164                     closest = valid_columns-&gt;details.list[0];
<a name="l01165"></a>01165                 <span class="keywordflow">continue</span>;
<a name="l01166"></a>01166             }
<a name="l01167"></a>01167 
<a name="l01169"></a>01169             <span class="keywordflow">if</span> (current &gt;
<a name="l01170"></a>01170                 valid_columns-&gt;details.list[(<span class="keywordtype">int</span>)valid_columns-&gt;<a class="code" href="structnetsnmp__column__info__t.html#aad98f438ae02538e4df763022006e259" title="only useful if isRange == 0">list_count</a> - 1])
<a name="l01171"></a>01171                 <span class="keywordflow">continue</span>;       <span class="comment">/* not in list range. */</span>
<a name="l01172"></a>01172 
<a name="l01174"></a>01174             <span class="keywordflow">for</span> (idx = 0; valid_columns-&gt;details.list[idx] &lt; current; ++idx)
<a name="l01175"></a>01175                 ;
<a name="l01176"></a>01176             
<a name="l01178"></a>01178             <span class="keywordflow">if</span> (current == valid_columns-&gt;details.list[idx]) {
<a name="l01179"></a>01179                 closest = current;
<a name="l01180"></a>01180                 <span class="keywordflow">break</span>;      <span class="comment">/* can not get any closer! */</span>
<a name="l01181"></a>01181             }
<a name="l01182"></a>01182             
<a name="l01184"></a>01184             <span class="keywordflow">if</span> ((valid_columns-&gt;details.list[idx] &lt; closest) ||
<a name="l01185"></a>01185                 (0 == closest))
<a name="l01186"></a>01186                 closest = valid_columns-&gt;details.list[idx];
<a name="l01187"></a>01187 
<a name="l01188"></a>01188         }                       <span class="comment">/* list */</span>
<a name="l01189"></a>01189     }                           <span class="comment">/* for */</span>
<a name="l01190"></a>01190 
<a name="l01191"></a>01191     <span class="keywordflow">return</span> closest;
<a name="l01192"></a>01192 }
<a name="l01193"></a>01193 
<a name="l01213"></a>01213 <span class="keywordtype">void</span>
<a name="l01214"></a>01214 netsnmp_table_helper_add_indexes(<a class="code" href="structnetsnmp__table__registration__info__s.html" title="Table registration structure.">netsnmp_table_registration_info</a> *tinfo,
<a name="l01215"></a>01215                                  ...)
<a name="l01216"></a>01216 {
<a name="l01217"></a>01217     va_list         debugargs;
<a name="l01218"></a>01218     <span class="keywordtype">int</span>             type;
<a name="l01219"></a>01219 
<a name="l01220"></a>01220     va_start(debugargs, tinfo);
<a name="l01221"></a>01221     <span class="keywordflow">while</span> ((type = va_arg(debugargs, <span class="keywordtype">int</span>)) != 0) {
<a name="l01222"></a>01222         netsnmp_table_helper_add_index(tinfo, type);
<a name="l01223"></a>01223     }
<a name="l01224"></a>01224     va_end(debugargs);
<a name="l01225"></a>01225 }
<a name="l01226"></a>01226 
<a name="l01227"></a>01227 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l01228"></a>01228 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01229"></a>01229 _row_stash_data_list_free(<span class="keywordtype">void</span> *ptr) {
<a name="l01230"></a>01230     <a class="code" href="structnetsnmp__oid__stash__node__s.html">netsnmp_oid_stash_node</a> **tmp = (<a class="code" href="structnetsnmp__oid__stash__node__s.html">netsnmp_oid_stash_node</a> **)ptr;
<a name="l01231"></a>01231     <a class="code" href="group__oid__stash.html#ga8b3ab7792cfc2014af022a6eb2ecabc0" title="Frees the contents of a netsnmp_oid_stash tree.">netsnmp_oid_stash_free</a>(tmp, NULL);
<a name="l01232"></a>01232     free(ptr);
<a name="l01233"></a>01233 }
<a name="l01234"></a>01234 
<a name="l01235"></a>01235 <span class="preprocessor">#ifndef NETSNMP_FEATURE_REMOVE_TABLE_GET_OR_CREATE_ROW_STASH</span>
<a name="l01236"></a>01236 <span class="preprocessor"></span>
<a name="l01238"></a>01238 <a class="code" href="structnetsnmp__oid__stash__node__s.html">netsnmp_oid_stash_node</a> **
<a name="l01239"></a>01239 netsnmp_table_get_or_create_row_stash(<a class="code" href="structnetsnmp__agent__request__info__s.html" title="The agent transaction request structure.">netsnmp_agent_request_info</a> *reqinfo,
<a name="l01240"></a>01240                                       <span class="keyword">const</span> u_char * storage_name)
<a name="l01241"></a>01241 {
<a name="l01242"></a>01242     <a class="code" href="structnetsnmp__oid__stash__node__s.html">netsnmp_oid_stash_node</a> **stashp = NULL;
<a name="l01243"></a>01243     stashp = (<a class="code" href="structnetsnmp__oid__stash__node__s.html">netsnmp_oid_stash_node</a> **)
<a name="l01244"></a>01244         netsnmp_agent_get_list_data(reqinfo, (<span class="keyword">const</span> <span class="keywordtype">char</span> *) storage_name);
<a name="l01245"></a>01245 
<a name="l01246"></a>01246     <span class="keywordflow">if</span> (!stashp) {
<a name="l01247"></a>01247         <span class="comment">/*</span>
<a name="l01248"></a>01248 <span class="comment">         * hasn&#39;t be created yet.  we create it here. </span>
<a name="l01249"></a>01249 <span class="comment">         */</span>
<a name="l01250"></a>01250         stashp = <a class="code" href="group__util.html#ga9cd013bb193de5048149afeb9d94e424" title="Mallocs memory of sizeof(t), zeros it and returns a pointer to it.">SNMP_MALLOC_TYPEDEF</a>(<a class="code" href="structnetsnmp__oid__stash__node__s.html">netsnmp_oid_stash_node</a> *);
<a name="l01251"></a>01251 
<a name="l01252"></a>01252         <span class="keywordflow">if</span> (!stashp)
<a name="l01253"></a>01253             <span class="keywordflow">return</span> NULL;        <span class="comment">/* ack. out of mem */</span>
<a name="l01254"></a>01254 
<a name="l01255"></a>01255         netsnmp_agent_add_list_data(reqinfo,
<a name="l01256"></a>01256                                     <a class="code" href="group__data__list.html#ga3dc286b678474c6adb610460ea71b03e" title="adds creates a data_list node given a name, data and a free function ptr.">netsnmp_create_data_list</a>((<span class="keyword">const</span> <span class="keywordtype">char</span> *) storage_name,
<a name="l01257"></a>01257                                                              stashp,
<a name="l01258"></a>01258                                                              _row_stash_data_list_free));
<a name="l01259"></a>01259     }
<a name="l01260"></a>01260     <span class="keywordflow">return</span> stashp;
<a name="l01261"></a>01261 }
<a name="l01262"></a>01262 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_FEATURE_REMOVE_TABLE_GET_OR_CREATE_ROW_STASH */</span>
<a name="l01263"></a>01263 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l01264"></a>01264 
<a name="l01265"></a>01265 <span class="comment">/*</span>
<a name="l01266"></a>01266 <span class="comment"> * advance the table info colnum to the next column, or 0 if there are no more</span>
<a name="l01267"></a>01267 <span class="comment"> *</span>
<a name="l01268"></a>01268 <span class="comment"> * @return new column, or 0 if there are no more</span>
<a name="l01269"></a>01269 <span class="comment"> */</span>
<a name="l01270"></a>01270 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
<a name="l01271"></a>01271 netsnmp_table_next_column(<a class="code" href="structnetsnmp__table__request__info__s.html" title="The table request info structure.">netsnmp_table_request_info</a> *table_info)
<a name="l01272"></a>01272 {
<a name="l01273"></a>01273     <span class="keywordflow">if</span> (NULL == table_info)
<a name="l01274"></a>01274         <span class="keywordflow">return</span> 0;
<a name="l01275"></a>01275 
<a name="l01276"></a>01276     <span class="comment">/*</span>
<a name="l01277"></a>01277 <span class="comment">     * try and validate next column</span>
<a name="l01278"></a>01278 <span class="comment">     */</span>
<a name="l01279"></a>01279     <span class="keywordflow">if</span> (table_info-&gt;reg_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#aaedf72ed4f760e9926f739553da49835" title="more details on columns">valid_columns</a>)
<a name="l01280"></a>01280         <span class="keywordflow">return</span> netsnmp_closest_column(table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> + 1,
<a name="l01281"></a>01281                                       table_info-&gt;reg_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#aaedf72ed4f760e9926f739553da49835" title="more details on columns">valid_columns</a>);
<a name="l01282"></a>01282     
<a name="l01283"></a>01283     <span class="comment">/*</span>
<a name="l01284"></a>01284 <span class="comment">     * can&#39;t validate. assume 1..max_column are valid</span>
<a name="l01285"></a>01285 <span class="comment">     */</span>
<a name="l01286"></a>01286     <span class="keywordflow">if</span> (table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> &lt; table_info-&gt;reg_info-&gt;<a class="code" href="structnetsnmp__table__registration__info__s.html#a4b7f37faafced959b943e974ba58e008" title="the maximum columns number">max_column</a>)
<a name="l01287"></a>01287         <span class="keywordflow">return</span> table_info-&gt;<a class="code" href="structnetsnmp__table__request__info__s.html#afbed55ce9b6c75a98fafc84559462b34" title="0 if OID not long enough">colnum</a> + 1;
<a name="l01288"></a>01288     
<a name="l01289"></a>01289     <span class="keywordflow">return</span> 0; <span class="comment">/* out of range */</span>
<a name="l01290"></a>01290 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jul 14 2011 for net-snmp by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
