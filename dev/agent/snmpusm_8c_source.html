<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <div class="navigation" id="top">
    <div class="tabs">
      <ul>
        <li><a href="index.html"><span>Main Page</span></a></li>

        <li><a href="pages.html"><span>Related Pages</span></a></li>

        <li><a href="modules.html"><span>Modules</span></a></li>

        <li><a href="annotated.html"><span>Data Structures</span></a></li>

        <li class="current"><a href="files.html"><span>Files</span></a></li>

        <li><a href="examples.html"><span>Examples</span></a></li>
      </ul>
    </div>

    <div class="tabs">
      <ul>
        <li><a href="files.html"><span>File List</span></a></li>

        <li><a href="globals.html"><span>Globals</span></a></li>
      </ul>
    </div>

    <h1>snmpusm.c</h1>

    <div class="fragment">
      <pre class="fragment">
<a name="l00001" id="l00001"></a>00001 <span class=
"comment">/* Portions of this file are subject to the following copyright(s).  See</span>
<a name="l00002" id="l00002"></a>00002 <span class=
"comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
<a name="l00003" id="l00003"></a>00003 <span class="comment"> * that may apply:</span>
<a name="l00004" id="l00004"></a>00004 <span class="comment"> */</span>
<a name="l00005" id="l00005"></a>00005 <span class="comment">/*</span>
<a name="l00006" id="l00006"></a>00006 <span class="comment"> * Portions of this file are copyrighted by:</span>
<a name="l00007" id="l00007"></a>00007 <span class=
"comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
<a name="l00008" id="l00008"></a>00008 <span class=
"comment"> * Use is subject to license terms specified in the COPYING file</span>
<a name="l00009" id="l00009"></a>00009 <span class="comment"> * distributed with the Net-SNMP package.</span>
<a name="l00010" id="l00010"></a>00010 <span class="comment"> */</span>
<a name="l00011" id="l00011"></a>00011 <span class="comment">/*</span>
<a name="l00012" id="l00012"></a>00012 <span class="comment"> * snmpusm.c</span>
<a name="l00013" id="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014" id="l00014"></a>00014 <span class="comment"> * Routines to manipulate a information about a "user" as</span>
<a name="l00015" id="l00015"></a>00015 <span class="comment"> * defined by the SNMP-USER-BASED-SM-MIB MIB.</span>
<a name="l00016" id="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017" id="l00017"></a>00017 <span class=
"comment"> * All functions usm_set_usmStateReference_*() return 0 on success, -1</span>
<a name="l00018" id="l00018"></a>00018 <span class="comment"> * otherwise.</span>
<a name="l00019" id="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020" id="l00020"></a>00020 <span class="comment"> * !! Tab stops set to 4 in some parts of this file. !!</span>
<a name="l00021" id="l00021"></a>00021 <span class="comment"> *    (Designated on a per function.)</span>
<a name="l00022" id="l00022"></a>00022 <span class="comment"> */</span>
<a name="l00023" id="l00023"></a>00023 
<a name="l00024" id="l00024"></a>00024 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
<a name="l00025" id="l00025"></a>00025 
<a name="l00026" id="l00026"></a>00026 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00027" id="l00027"></a>00027 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
<a name="l00028" id="l00028"></a>00028 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
<a name="l00029" id="l00029"></a>00029 <span class="preprocessor">#endif</span>
<a name="l00030" id="l00030"></a>00030 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00031" id="l00031"></a>00031 <span class="preprocessor">#ifdef HAVE_STDLIB_H</span>
<a name="l00032" id="l00032"></a>00032 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00033" id="l00033"></a>00033 <span class="preprocessor">#endif</span>
<a name="l00034" id="l00034"></a>00034 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
<a name="l00035" id="l00035"></a>00035 <span class="preprocessor"># ifdef WIN32</span>
<a name="l00036" id="l00036"></a>00036 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
<a name="l00037" id="l00037"></a>00037 <span class="preprocessor"># else</span>
<a name="l00038" id="l00038"></a>00038 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
<a name="l00039" id="l00039"></a>00039 <span class="preprocessor"># endif</span>
<a name="l00040" id="l00040"></a>00040 <span class="preprocessor"># include &lt;time.h&gt;</span>
<a name="l00041" id="l00041"></a>00041 <span class="preprocessor">#else</span>
<a name="l00042" id="l00042"></a>00042 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
<a name="l00043" id="l00043"></a>00043 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
<a name="l00044" id="l00044"></a>00044 <span class="preprocessor"># else</span>
<a name="l00045" id="l00045"></a>00045 <span class="preprocessor">#  include &lt;time.h&gt;</span>
<a name="l00046" id="l00046"></a>00046 <span class="preprocessor"># endif</span>
<a name="l00047" id="l00047"></a>00047 <span class="preprocessor">#endif</span>
<a name="l00048" id="l00048"></a>00048 <span class="preprocessor">#if HAVE_STRING_H</span>
<a name="l00049" id="l00049"></a>00049 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00050" id="l00050"></a>00050 <span class="preprocessor">#else</span>
<a name="l00051" id="l00051"></a>00051 <span class="preprocessor">#include &lt;strings.h&gt;</span>
<a name="l00052" id="l00052"></a>00052 <span class="preprocessor">#endif</span>
<a name="l00053" id="l00053"></a>00053 <span class="preprocessor">#ifdef HAVE_NETINET_IN_H</span>
<a name="l00054" id="l00054"></a>00054 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
<a name="l00055" id="l00055"></a>00055 <span class="preprocessor">#endif</span>
<a name="l00056" id="l00056"></a>00056 
<a name="l00057" id="l00057"></a>00057 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
<a name="l00058" id="l00058"></a>00058 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
<a name="l00059" id="l00059"></a>00059 <span class="preprocessor">#endif</span>
<a name="l00060" id="l00060"></a>00060 
<a name="l00061" id="l00061"></a>00061 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
<a name="l00062" id="l00062"></a>00062 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
<a name="l00063" id="l00063"></a>00063 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
<a name="l00064" id="l00064"></a>00064 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
<a name="l00065" id="l00065"></a>00065 
<a name="l00066" id="l00066"></a>00066 <span class="preprocessor">#include &lt;net-snmp/library/asn1.h&gt;</span>
<a name="l00067" id="l00067"></a>00067 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
<a name="l00068" id="l00068"></a>00068 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
<a name="l00069" id="l00069"></a>00069 <span class="preprocessor">#include &lt;<a class="code" href=
"tools_8h.html">net-snmp/library/tools.h</a>&gt;</span>
<a name="l00070" id="l00070"></a>00070 <span class="preprocessor">#include &lt;net-snmp/library/keytools.h&gt;</span>
<a name="l00071" id="l00071"></a>00071 <span class="preprocessor">#include &lt;net-snmp/library/snmpv3.h&gt;</span>
<a name="l00072" id="l00072"></a>00072 <span class="preprocessor">#include &lt;net-snmp/library/lcd_time.h&gt;</span>
<a name="l00073" id="l00073"></a>00073 <span class="preprocessor">#include &lt;net-snmp/library/scapi.h&gt;</span>
<a name="l00074" id="l00074"></a>00074 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
<a name="l00075" id="l00075"></a>00075 <span class="preprocessor">#include &lt;net-snmp/library/snmp_secmod.h&gt;</span>
<a name="l00076" id="l00076"></a>00076 <span class="preprocessor">#include &lt;net-snmp/library/snmpusm.h&gt;</span>
<a name="l00077" id="l00077"></a>00077 
<a name="l00078" id="l00078"></a>00078 oid             usmNoAuthProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 1, 1 };
<a name="l00079" id="l00079"></a>00079 <span class="preprocessor">#ifndef NETSNMP_DISABLE_MD5</span>
<a name="l00080" id="l00080"></a>00080 oid             usmHMACMD5AuthProtocol[10] =
<a name="l00081" id="l00081"></a>00081     { 1, 3, 6, 1, 6, 3, 10, 1, 1, 2 };
<a name="l00082" id="l00082"></a>00082 <span class="preprocessor">#endif</span>
<a name="l00083" id="l00083"></a>00083 oid             usmHMACSHA1AuthProtocol[10] =
<a name="l00084" id="l00084"></a>00084     { 1, 3, 6, 1, 6, 3, 10, 1, 1, 3 };
<a name="l00085" id="l00085"></a>00085 oid             usmNoPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 1 };
<a name="l00086" id="l00086"></a>00086 <span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l00087" id="l00087"></a>00087 oid             usmDESPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 2 };
<a name="l00088" id="l00088"></a>00088 <span class="preprocessor">#endif</span>
<a name="l00089" id="l00089"></a>00089 oid             usmAESPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 4 };
<a name="l00090" id="l00090"></a>00090 <span class="comment">/* backwards compat */</span>
<a name="l00091" id="l00091"></a>00091 oid             *usmAES128PrivProtocol = usmAESPrivProtocol;
<a name="l00092" id="l00092"></a>00092 
<a name="l00093" id="l00093"></a>00093 <span class="keyword">static</span> u_int    dummy_etime, dummy_eboot;       <span class=
"comment">/* For ISENGINEKNOWN(). */</span>
<a name="l00094" id="l00094"></a>00094 
<a name="l00095" id="l00095"></a>00095 <span class="comment">/*</span>
<a name="l00096" id="l00096"></a>00096 <span class="comment"> * Globals.</span>
<a name="l00097" id="l00097"></a>00097 <span class="comment"> */</span>
<a name="l00098" id="l00098"></a>00098 <span class="keyword">static</span> u_int    salt_integer;
<a name="l00099" id="l00099"></a>00099 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l00100" id="l00100"></a>00100 <span class="keyword">static</span> u_int    salt_integer64_1, salt_integer64_2;
<a name="l00101" id="l00101"></a>00101 <span class="preprocessor">#endif</span>
<a name="l00102" id="l00102"></a>00102         <span class="comment">/*</span>
<a name="l00103" id="l00103"></a>00103 <span class=
"comment">         * 1/2 of seed for the salt.   Cf. RFC2274, Sect 8.1.1.1.</span>
<a name="l00104" id="l00104"></a>00104 <span class="comment">         */</span>
<a name="l00105" id="l00105"></a>00105 
<a name="l00106" id="l00106"></a>00106 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code"
href="structusmUser.html">usmUser</a> *noNameUser = NULL;
<a name="l00107" id="l00107"></a>00107 <span class="comment">/*</span>
<a name="l00108" id="l00108"></a>00108 <span class="comment"> * Local storage (LCD) of the default user list.</span>
<a name="l00109" id="l00109"></a>00109 <span class="comment"> */</span>
<a name="l00110" id="l00110"></a>00110 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code"
href="structusmUser.html">usmUser</a> *userList = NULL;
<a name="l00111" id="l00111"></a>00111 
<a name="l00112" id="l00112"></a>00112 <span class="comment">/*</span>
<a name="l00113" id="l00113"></a>00113 <span class="comment"> * Prototypes</span>
<a name="l00114" id="l00114"></a>00114 <span class="comment"> */</span>
<a name="l00115" id="l00115"></a>00115 <span class="keywordtype">int</span>
<a name="l00116" id="l00116"></a>00116                 usm_check_secLevel_vs_protocols(<span class=
"keywordtype">int</span> level,
<a name="l00117" id="l00117"></a>00117                                                 <span class=
"keyword">const</span> oid * authProtocol,
<a name="l00118" id="l00118"></a>00118                                                 u_int authProtocolLen,
<a name="l00119" id="l00119"></a>00119                                                 <span class=
"keyword">const</span> oid * privProtocol,
<a name="l00120" id="l00120"></a>00120                                                 u_int privProtocolLen);
<a name="l00121" id="l00121"></a>00121 <span class="keywordtype">int</span>
<a name="l00122" id="l00122"></a>00122                 usm_calc_offsets(<span class="keywordtype">size_t</span> globalDataLen,
<a name="l00123" id="l00123"></a>00123                                  <span class=
"keywordtype">int</span> secLevel, <span class="keywordtype">size_t</span> secEngineIDLen,
<a name="l00124" id="l00124"></a>00124                                  <span class=
"keywordtype">size_t</span> secNameLen, <span class="keywordtype">size_t</span> scopedPduLen,
<a name="l00125" id="l00125"></a>00125                                  u_long engineboots, <span class=
"keywordtype">long</span> engine_time,
<a name="l00126" id="l00126"></a>00126                                  <span class="keywordtype">size_t</span> * theTotalLength,
<a name="l00127" id="l00127"></a>00127                                  <span class=
"keywordtype">size_t</span> * authParamsOffset,
<a name="l00128" id="l00128"></a>00128                                  <span class=
"keywordtype">size_t</span> * privParamsOffset,
<a name="l00129" id="l00129"></a>00129                                  <span class=
"keywordtype">size_t</span> * dataOffset, <span class="keywordtype">size_t</span> * datalen,
<a name="l00130" id="l00130"></a>00130                                  <span class="keywordtype">size_t</span> * msgAuthParmLen,
<a name="l00131" id="l00131"></a>00131                                  <span class=
"keywordtype">size_t</span> * msgPrivParmLen, <span class="keywordtype">size_t</span> * otstlen,
<a name="l00132" id="l00132"></a>00132                                  <span class=
"keywordtype">size_t</span> * seq_len, <span class="keywordtype">size_t</span> * msgSecParmLen);
<a name="l00133" id="l00133"></a>00133 <span class="comment">/*</span>
<a name="l00134" id="l00134"></a>00134 <span class="comment"> * Set a given field of the secStateRef.</span>
<a name="l00135" id="l00135"></a>00135 <span class="comment"> *</span>
<a name="l00136" id="l00136"></a>00136 <span class=
"comment"> * Allocate &lt;len&gt; bytes for type &lt;type&gt; pointed to by ref-&gt;&lt;field&gt;.</span>
<a name="l00137" id="l00137"></a>00137 <span class=
"comment"> * Then copy in &lt;item&gt; and record its length in ref-&gt;&lt;field_len&gt;.</span>
<a name="l00138" id="l00138"></a>00138 <span class="comment"> *</span>
<a name="l00139" id="l00139"></a>00139 <span class="comment"> * Return 0 on success, -1 otherwise.</span>
<a name="l00140" id="l00140"></a>00140 <span class="comment"> */</span>
<a name="l00141" id="l00141"></a>00141 <span class=
"preprocessor">#define MAKE_ENTRY( type, item, len, field, field_len )                 \</span>
<a name="l00142" id="l00142"></a>00142 <span class=
"preprocessor">{                                                                       \</span>
<a name="l00143" id="l00143"></a>00143 <span class=
"preprocessor">        if (ref == NULL)                                                \</span>
<a name="l00144" id="l00144"></a>00144 <span class=
"preprocessor">                return -1;                                              \</span>
<a name="l00145" id="l00145"></a>00145 <span class=
"preprocessor">        if (ref-&gt;field != NULL) {                                       \</span>
<a name="l00146" id="l00146"></a>00146 <span class=
"preprocessor">                SNMP_ZERO(ref-&gt;field, ref-&gt;field_len);                  \</span>
<a name="l00147" id="l00147"></a>00147 <span class=
"preprocessor">                SNMP_FREE(ref-&gt;field);                                  \</span>
<a name="l00148" id="l00148"></a>00148 <span class=
"preprocessor">        }                                                               \</span>
<a name="l00149" id="l00149"></a>00149 <span class=
"preprocessor">        ref-&gt;field_len = 0;                                             \</span>
<a name="l00150" id="l00150"></a>00150 <span class=
"preprocessor">        if (len == 0 || item == NULL) {                                 \</span>
<a name="l00151" id="l00151"></a>00151 <span class=
"preprocessor">                return 0;                                               \</span>
<a name="l00152" id="l00152"></a>00152 <span class=
"preprocessor">        }                                                               \</span>
<a name="l00153" id="l00153"></a>00153 <span class=
"preprocessor">        if ((ref-&gt;field = (type*) malloc (len * sizeof(type))) == NULL) \</span>
<a name="l00154" id="l00154"></a>00154 <span class=
"preprocessor">        {                                                               \</span>
<a name="l00155" id="l00155"></a>00155 <span class=
"preprocessor">                return -1;                                              \</span>
<a name="l00156" id="l00156"></a>00156 <span class=
"preprocessor">        }                                                               \</span>
<a name="l00157" id="l00157"></a>00157 <span class=
"preprocessor">                                                                        \</span>
<a name="l00158" id="l00158"></a>00158 <span class=
"preprocessor">        memcpy (ref-&gt;field, item, len * sizeof(type));                  \</span>
<a name="l00159" id="l00159"></a>00159 <span class=
"preprocessor">        ref-&gt;field_len = len;                                           \</span>
<a name="l00160" id="l00160"></a>00160 <span class=
"preprocessor">                                                                        \</span>
<a name="l00161" id="l00161"></a>00161 <span class=
"preprocessor">        return 0;                                                       \</span>
<a name="l00162" id="l00162"></a>00162 <span class="preprocessor">}</span>
<a name="l00163" id="l00163"></a>00163 
<a name="l00164" id="l00164"></a>00164 
<a name="l00165" id="l00165"></a>00165 <span class="keyword">struct </span><a class="code" href=
"structusmStateReference.html">usmStateReference</a> *
<a name="l00166" id="l00166"></a>00166 usm_malloc_usmStateReference(<span class="keywordtype">void</span>)
<a name="l00167" id="l00167"></a>00167 {
<a name="l00168" id="l00168"></a>00168     <span class="keyword">struct </span><a class="code" href=
"structusmStateReference.html">usmStateReference</a> *retval = (<span class="keyword">struct </span><a class="code" href=
"structusmStateReference.html">usmStateReference</a> *)
<a name="l00169" id="l00169"></a>00169         calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> <a class="code" href="structusmStateReference.html">usmStateReference</a>));
<a name="l00170" id="l00170"></a>00170 
<a name="l00171" id="l00171"></a>00171     <span class="keywordflow">return</span> retval;
<a name="l00172" id="l00172"></a>00172 }                               <span class=
"comment">/* end usm_malloc_usmStateReference() */</span>
<a name="l00173" id="l00173"></a>00173 
<a name="l00174" id="l00174"></a>00174 
<a name="l00175" id="l00175"></a>00175 <span class="keywordtype">void</span>
<a name="l00176" id="l00176"></a>00176 usm_free_usmStateReference(<span class="keywordtype">void</span> *old)
<a name="l00177" id="l00177"></a>00177 {
<a name="l00178" id="l00178"></a>00178     <span class="keyword">struct </span><a class="code" href=
"structusmStateReference.html">usmStateReference</a> *old_ref = (<span class="keyword">struct </span><a class="code" href=
"structusmStateReference.html">usmStateReference</a> *) old;
<a name="l00179" id="l00179"></a>00179 
<a name="l00180" id="l00180"></a>00180     <span class="keywordflow">if</span> (old_ref) {
<a name="l00181" id="l00181"></a>00181 
<a name="l00182" id="l00182"></a>00182         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref-&gt;usr_name);
<a name="l00183" id="l00183"></a>00183         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref-&gt;usr_engine_id);
<a name="l00184" id="l00184"></a>00184         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref-&gt;usr_auth_protocol);
<a name="l00185" id="l00185"></a>00185         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref-&gt;usr_priv_protocol);
<a name="l00186" id="l00186"></a>00186 
<a name="l00187" id="l00187"></a>00187         <span class="keywordflow">if</span> (old_ref-&gt;usr_auth_key) {
<a name="l00188" id="l00188"></a>00188             <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227"
title="Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(old_ref-&gt;usr_auth_key, old_ref-&gt;usr_auth_key_length);
<a name="l00189" id="l00189"></a>00189             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6"
title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref-&gt;usr_auth_key);
<a name="l00190" id="l00190"></a>00190         }
<a name="l00191" id="l00191"></a>00191         <span class="keywordflow">if</span> (old_ref-&gt;usr_priv_key) {
<a name="l00192" id="l00192"></a>00192             <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227"
title="Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(old_ref-&gt;usr_priv_key, old_ref-&gt;usr_priv_key_length);
<a name="l00193" id="l00193"></a>00193             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6"
title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref-&gt;usr_priv_key);
<a name="l00194" id="l00194"></a>00194         }
<a name="l00195" id="l00195"></a>00195 
<a name="l00196" id="l00196"></a>00196         <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title=
"Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(old_ref, <span class="keyword">sizeof</span>(*old_ref));
<a name="l00197" id="l00197"></a>00197         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref);
<a name="l00198" id="l00198"></a>00198 
<a name="l00199" id="l00199"></a>00199     }
<a name="l00200" id="l00200"></a>00200 
<a name="l00201" id="l00201"></a>00201 }                               <span class=
"comment">/* end usm_free_usmStateReference() */</span>
<a name="l00202" id="l00202"></a>00202 
<a name="l00203" id="l00203"></a>00203 <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *
<a name="l00204" id="l00204"></a>00204 usm_get_userList(<span class="keywordtype">void</span>)
<a name="l00205" id="l00205"></a>00205 {
<a name="l00206" id="l00206"></a>00206     <span class="keywordflow">return</span> userList;
<a name="l00207" id="l00207"></a>00207 }
<a name="l00208" id="l00208"></a>00208 
<a name="l00209" id="l00209"></a>00209 <span class="keywordtype">int</span>
<a name="l00210" id="l00210"></a>00210 usm_set_usmStateReference_name(<span class="keyword">struct</span> <a class="code" href=
"structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00211" id="l00211"></a>00211                                <span class="keywordtype">char</span> *name, <span class=
"keywordtype">size_t</span> name_len)
<a name="l00212" id="l00212"></a>00212 {
<a name="l00213" id="l00213"></a>00213     MAKE_ENTRY(<span class=
"keywordtype">char</span>, name, name_len, usr_name, usr_name_length);
<a name="l00214" id="l00214"></a>00214 }
<a name="l00215" id="l00215"></a>00215 
<a name="l00216" id="l00216"></a>00216 <span class="keywordtype">int</span>
<a name="l00217" id="l00217"></a>00217 usm_set_usmStateReference_engine_id(<span class="keyword">struct</span> <a class="code"
href="structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00218" id="l00218"></a>00218                                     u_char * engine_id,
<a name="l00219" id="l00219"></a>00219                                     <span class="keywordtype">size_t</span> engine_id_len)
<a name="l00220" id="l00220"></a>00220 {
<a name="l00221" id="l00221"></a>00221     MAKE_ENTRY(u_char, engine_id, engine_id_len,
<a name="l00222" id="l00222"></a>00222                usr_engine_id, usr_engine_id_length);
<a name="l00223" id="l00223"></a>00223 }
<a name="l00224" id="l00224"></a>00224 
<a name="l00225" id="l00225"></a>00225 <span class="keywordtype">int</span>
<a name="l00226" id="l00226"></a>00226 usm_set_usmStateReference_auth_protocol(<span class="keyword">struct</span> <a class=
"code" href="structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00227" id="l00227"></a>00227                                         oid * auth_protocol,
<a name="l00228" id="l00228"></a>00228                                         <span class=
"keywordtype">size_t</span> auth_protocol_len)
<a name="l00229" id="l00229"></a>00229 {
<a name="l00230" id="l00230"></a>00230     MAKE_ENTRY(oid, auth_protocol, auth_protocol_len,
<a name="l00231" id="l00231"></a>00231                usr_auth_protocol, usr_auth_protocol_length);
<a name="l00232" id="l00232"></a>00232 }
<a name="l00233" id="l00233"></a>00233 
<a name="l00234" id="l00234"></a>00234 <span class="keywordtype">int</span>
<a name="l00235" id="l00235"></a>00235 usm_set_usmStateReference_auth_key(<span class="keyword">struct</span> <a class="code"
href="structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00236" id="l00236"></a>00236                                    u_char * auth_key, <span class=
"keywordtype">size_t</span> auth_key_len)
<a name="l00237" id="l00237"></a>00237 {
<a name="l00238" id="l00238"></a>00238     MAKE_ENTRY(u_char, auth_key, auth_key_len,
<a name="l00239" id="l00239"></a>00239                usr_auth_key, usr_auth_key_length);
<a name="l00240" id="l00240"></a>00240 }
<a name="l00241" id="l00241"></a>00241 
<a name="l00242" id="l00242"></a>00242 <span class="keywordtype">int</span>
<a name="l00243" id="l00243"></a>00243 usm_set_usmStateReference_priv_protocol(<span class="keyword">struct</span> <a class=
"code" href="structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00244" id="l00244"></a>00244                                         oid * priv_protocol,
<a name="l00245" id="l00245"></a>00245                                         <span class=
"keywordtype">size_t</span> priv_protocol_len)
<a name="l00246" id="l00246"></a>00246 {
<a name="l00247" id="l00247"></a>00247     MAKE_ENTRY(oid, priv_protocol, priv_protocol_len,
<a name="l00248" id="l00248"></a>00248                usr_priv_protocol, usr_priv_protocol_length);
<a name="l00249" id="l00249"></a>00249 }
<a name="l00250" id="l00250"></a>00250 
<a name="l00251" id="l00251"></a>00251 <span class="keywordtype">int</span>
<a name="l00252" id="l00252"></a>00252 usm_set_usmStateReference_priv_key(<span class="keyword">struct</span> <a class="code"
href="structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00253" id="l00253"></a>00253                                    u_char * priv_key, <span class=
"keywordtype">size_t</span> priv_key_len)
<a name="l00254" id="l00254"></a>00254 {
<a name="l00255" id="l00255"></a>00255     MAKE_ENTRY(u_char, priv_key, priv_key_len,
<a name="l00256" id="l00256"></a>00256                usr_priv_key, usr_priv_key_length);
<a name="l00257" id="l00257"></a>00257 }
<a name="l00258" id="l00258"></a>00258 
<a name="l00259" id="l00259"></a>00259 <span class="keywordtype">int</span>
<a name="l00260" id="l00260"></a>00260 usm_set_usmStateReference_sec_level(<span class="keyword">struct</span> <a class="code"
href="structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00261" id="l00261"></a>00261                                     <span class="keywordtype">int</span> sec_level)
<a name="l00262" id="l00262"></a>00262 {
<a name="l00263" id="l00263"></a>00263     <span class="keywordflow">if</span> (ref == NULL)
<a name="l00264" id="l00264"></a>00264         <span class="keywordflow">return</span> -1;
<a name="l00265" id="l00265"></a>00265     ref-&gt;usr_sec_level = sec_level;
<a name="l00266" id="l00266"></a>00266     <span class="keywordflow">return</span> 0;
<a name="l00267" id="l00267"></a>00267 }
<a name="l00268" id="l00268"></a>00268 
<a name="l00269" id="l00269"></a>00269 
<a name="l00270" id="l00270"></a>00270 
<a name="l00271" id="l00271"></a>00271 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l00272" id="l00272"></a>00272 <span class=
"comment">/*******************************************************************-o-******</span>
<a name="l00273" id="l00273"></a>00273 <span class="comment"> * emergency_print</span>
<a name="l00274" id="l00274"></a>00274 <span class="comment"> *</span>
<a name="l00275" id="l00275"></a>00275 <span class="comment"> * Parameters:</span>
<a name="l00276" id="l00276"></a>00276 <span class="comment"> *      *field</span>
<a name="l00277" id="l00277"></a>00277 <span class="comment"> *       length</span>
<a name="l00278" id="l00278"></a>00278 <span class="comment"> *      </span>
<a name="l00279" id="l00279"></a>00279 <span class=
"comment"> *      This is a print routine that is solely included so that it can be</span>
<a name="l00280" id="l00280"></a>00280 <span class=
"comment"> *      used in gdb.  Don't use it as a function, it will be pulled before</span>
<a name="l00281" id="l00281"></a>00281 <span class="comment"> *      a real release of the code.</span>
<a name="l00282" id="l00282"></a>00282 <span class="comment"> *</span>
<a name="l00283" id="l00283"></a>00283 <span class="comment"> *      tab stop 4</span>
<a name="l00284" id="l00284"></a>00284 <span class="comment"> *</span>
<a name="l00285" id="l00285"></a>00285 <span class=
"comment"> *      XXX fflush() only works on FreeBSD; core dumps on Sun OS's</span>
<a name="l00286" id="l00286"></a>00286 <span class="comment"> */</span>
<a name="l00287" id="l00287"></a>00287 <span class="keywordtype">void</span>
<a name="l00288" id="l00288"></a>00288 emergency_print(u_char * field, u_int length)
<a name="l00289" id="l00289"></a>00289 {
<a name="l00290" id="l00290"></a>00290     <span class="keywordtype">int</span>             iindex;
<a name="l00291" id="l00291"></a>00291     <span class="keywordtype">int</span>             start = 0;
<a name="l00292" id="l00292"></a>00292     <span class="keywordtype">int</span>             stop = 25;
<a name="l00293" id="l00293"></a>00293 
<a name="l00294" id="l00294"></a>00294     <span class="keywordflow">while</span> (start &lt; stop) {
<a name="l00295" id="l00295"></a>00295         <span class="keywordflow">for</span> (iindex = start; iindex &lt; stop; iindex++)
<a name="l00296" id="l00296"></a>00296             printf(<span class="stringliteral">"%02X "</span>, field[iindex]);
<a name="l00297" id="l00297"></a>00297 
<a name="l00298" id="l00298"></a>00298         printf(<span class="stringliteral">"\n"</span>);
<a name="l00299" id="l00299"></a>00299         start = stop;
<a name="l00300" id="l00300"></a>00300         stop = stop + 25 &lt; length ? stop + 25 : length;
<a name="l00301" id="l00301"></a>00301     }
<a name="l00302" id="l00302"></a>00302     fflush(0);
<a name="l00303" id="l00303"></a>00303 
<a name="l00304" id="l00304"></a>00304 }                               <span class="comment">/* end emergency_print() */</span>
<a name="l00305" id="l00305"></a>00305 <span class="preprocessor">#endif                          </span><span class=
"comment">/* NETSNMP_ENABLE_TESTING_CODE */</span>
<a name="l00306" id="l00306"></a>00306 
<a name="l00307" id="l00307"></a>00307 
<a name="l00308" id="l00308"></a>00308 <span class=
"comment">/*******************************************************************-o-******</span>
<a name="l00309" id="l00309"></a>00309 <span class="comment"> * asn_predict_int_length</span>
<a name="l00310" id="l00310"></a>00310 <span class="comment"> *</span>
<a name="l00311" id="l00311"></a>00311 <span class="comment"> * Parameters:</span>
<a name="l00312" id="l00312"></a>00312 <span class="comment"> *      type    (UNUSED)</span>
<a name="l00313" id="l00313"></a>00313 <span class="comment"> *      number</span>
<a name="l00314" id="l00314"></a>00314 <span class="comment"> *      len</span>
<a name="l00315" id="l00315"></a>00315 <span class="comment"> *      </span>
<a name="l00316" id="l00316"></a>00316 <span class="comment"> * Returns:</span>
<a name="l00317" id="l00317"></a>00317 <span class=
"comment"> *      Number of bytes necessary to store the ASN.1 encoded value of 'number'.</span>
<a name="l00318" id="l00318"></a>00318 <span class="comment"> *</span>
<a name="l00319" id="l00319"></a>00319 <span class="comment"> *</span>
<a name="l00320" id="l00320"></a>00320 <span class=
"comment"> *      This gives the number of bytes that the ASN.1 encoder (in asn1.c) will</span>
<a name="l00321" id="l00321"></a>00321 <span class="comment"> *      use to encode a particular integer value.</span>
<a name="l00322" id="l00322"></a>00322 <span class="comment"> *</span>
<a name="l00323" id="l00323"></a>00323 <span class="comment"> *      Returns the length of the integer -- NOT THE HEADER!</span>
<a name="l00324" id="l00324"></a>00324 <span class="comment"> *</span>
<a name="l00325" id="l00325"></a>00325 <span class="comment"> *      Do this the same way as asn_build_int()...</span>
<a name="l00326" id="l00326"></a>00326 <span class="comment"> */</span>
<a name="l00327" id="l00327"></a>00327 <span class="keywordtype">int</span>
<a name="l00328" id="l00328"></a>00328 asn_predict_int_length(<span class="keywordtype">int</span> type, <span class=
"keywordtype">long</span> number, <span class="keywordtype">size_t</span> len)
<a name="l00329" id="l00329"></a>00329 {
<a name="l00330" id="l00330"></a>00330     <span class="keyword">register</span> u_long mask;
<a name="l00331" id="l00331"></a>00331 
<a name="l00332" id="l00332"></a>00332 
<a name="l00333" id="l00333"></a>00333     <span class="keywordflow">if</span> (len != <span class=
"keyword">sizeof</span>(<span class="keywordtype">long</span>))
<a name="l00334" id="l00334"></a>00334         <span class="keywordflow">return</span> -1;
<a name="l00335" id="l00335"></a>00335 
<a name="l00336" id="l00336"></a>00336     mask = ((u_long) 0x1FF) &lt;&lt; ((8 * (<span class=
"keyword">sizeof</span>(long) - 1)) - 1);
<a name="l00337" id="l00337"></a>00337     <span class="comment">/*</span>
<a name="l00338" id="l00338"></a>00338 <span class="comment">     * mask is 0xFF800000 on a big-endian machine </span>
<a name="l00339" id="l00339"></a>00339 <span class="comment">     */</span>
<a name="l00340" id="l00340"></a>00340 
<a name="l00341" id="l00341"></a>00341     <span class=
"keywordflow">while</span> ((((number &amp; mask) == 0) || ((number &amp; mask) == mask))
<a name="l00342" id="l00342"></a>00342            &amp;&amp; len &gt; 1) {
<a name="l00343" id="l00343"></a>00343         len--;
<a name="l00344" id="l00344"></a>00344         number &lt;&lt;= 8;
<a name="l00345" id="l00345"></a>00345     }
<a name="l00346" id="l00346"></a>00346 
<a name="l00347" id="l00347"></a>00347     <span class="keywordflow">return</span> len;
<a name="l00348" id="l00348"></a>00348 
<a name="l00349" id="l00349"></a>00349 }                               <span class=
"comment">/* end asn_predict_length() */</span>
<a name="l00350" id="l00350"></a>00350 
<a name="l00351" id="l00351"></a>00351 
<a name="l00352" id="l00352"></a>00352 
<a name="l00353" id="l00353"></a>00353 
<a name="l00354" id="l00354"></a>00354 <span class=
"comment">/*******************************************************************-o-******</span>
<a name="l00355" id="l00355"></a>00355 <span class="comment"> * asn_predict_length</span>
<a name="l00356" id="l00356"></a>00356 <span class="comment"> *</span>
<a name="l00357" id="l00357"></a>00357 <span class="comment"> * Parameters:</span>
<a name="l00358" id="l00358"></a>00358 <span class="comment"> *       type</span>
<a name="l00359" id="l00359"></a>00359 <span class="comment"> *      *ptr</span>
<a name="l00360" id="l00360"></a>00360 <span class="comment"> *       u_char_len</span>
<a name="l00361" id="l00361"></a>00361 <span class="comment"> *      </span>
<a name="l00362" id="l00362"></a>00362 <span class="comment"> * Returns:</span>
<a name="l00363" id="l00363"></a>00363 <span class=
"comment"> *      Length in bytes:        1 + &lt;n&gt; + &lt;u_char_len&gt;, where</span>
<a name="l00364" id="l00364"></a>00364 <span class="comment"> *</span>
<a name="l00365" id="l00365"></a>00365 <span class="comment"> *              1               For the ASN.1 type.</span>
<a name="l00366" id="l00366"></a>00366 <span class=
"comment"> *              &lt;n&gt;             # of bytes to store length of data.</span>
<a name="l00367" id="l00367"></a>00367 <span class=
"comment"> *              &lt;u_char_len&gt;    Length of data associated with ASN.1 type.</span>
<a name="l00368" id="l00368"></a>00368 <span class="comment"> *</span>
<a name="l00369" id="l00369"></a>00369 <span class=
"comment"> *      This gives the number of bytes that the ASN.1 encoder (in asn1.c) will</span>
<a name="l00370" id="l00370"></a>00370 <span class=
"comment"> *      use to encode a particular integer value.  This is as broken as the</span>
<a name="l00371" id="l00371"></a>00371 <span class="comment"> *      currently used encoder.</span>
<a name="l00372" id="l00372"></a>00372 <span class="comment"> *</span>
<a name="l00373" id="l00373"></a>00373 <span class="comment"> * XXX  How is &lt;n&gt; chosen, exactly??</span>
<a name="l00374" id="l00374"></a>00374 <span class="comment"> */</span>
<a name="l00375" id="l00375"></a>00375 <span class="keywordtype">int</span>
<a name="l00376" id="l00376"></a>00376 asn_predict_length(<span class="keywordtype">int</span> type, u_char * ptr, <span class=
"keywordtype">size_t</span> u_char_len)
<a name="l00377" id="l00377"></a>00377 {
<a name="l00378" id="l00378"></a>00378 
<a name="l00379" id="l00379"></a>00379     <span class="keywordflow">if</span> (type &amp; ASN_SEQUENCE)
<a name="l00380" id="l00380"></a>00380         <span class="keywordflow">return</span> 1 + 3 + u_char_len;
<a name="l00381" id="l00381"></a>00381 
<a name="l00382" id="l00382"></a>00382     <span class="keywordflow">if</span> (type &amp; ASN_INTEGER) {
<a name="l00383" id="l00383"></a>00383         u_long          value;
<a name="l00384" id="l00384"></a>00384         memcpy(&amp;value, ptr, u_char_len);
<a name="l00385" id="l00385"></a>00385         u_char_len = asn_predict_int_length(type, value, u_char_len);
<a name="l00386" id="l00386"></a>00386     }
<a name="l00387" id="l00387"></a>00387 
<a name="l00388" id="l00388"></a>00388     <span class="keywordflow">if</span> (u_char_len &lt; 0x80)
<a name="l00389" id="l00389"></a>00389         <span class="keywordflow">return</span> 1 + 1 + u_char_len;
<a name="l00390" id="l00390"></a>00390     <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (u_char_len &lt; 0xFF)
<a name="l00391" id="l00391"></a>00391         <span class="keywordflow">return</span> 1 + 2 + u_char_len;
<a name="l00392" id="l00392"></a>00392     <span class="keywordflow">else</span>
<a name="l00393" id="l00393"></a>00393         <span class="keywordflow">return</span> 1 + 3 + u_char_len;
<a name="l00394" id="l00394"></a>00394 
<a name="l00395" id="l00395"></a>00395 }                               <span class=
"comment">/* end asn_predict_length() */</span>
<a name="l00396" id="l00396"></a>00396 
<a name="l00397" id="l00397"></a>00397 
<a name="l00398" id="l00398"></a>00398 
<a name="l00399" id="l00399"></a>00399 
<a name="l00400" id="l00400"></a>00400 <span class=
"comment">/*******************************************************************-o-******</span>
<a name="l00401" id="l00401"></a>00401 <span class="comment"> * usm_calc_offsets</span>
<a name="l00402" id="l00402"></a>00402 <span class="comment"> *</span>
<a name="l00403" id="l00403"></a>00403 <span class="comment"> * Parameters:</span>
<a name="l00404" id="l00404"></a>00404 <span class="comment"> *      (See list below...)</span>
<a name="l00405" id="l00405"></a>00405 <span class="comment"> *      </span>
<a name="l00406" id="l00406"></a>00406 <span class="comment"> * Returns:</span>
<a name="l00407" id="l00407"></a>00407 <span class="comment"> *      0       On success,</span>
<a name="l00408" id="l00408"></a>00408 <span class="comment"> *      -1      Otherwise.</span>
<a name="l00409" id="l00409"></a>00409 <span class="comment"> *</span>
<a name="l00410" id="l00410"></a>00410 <span class="comment"> *</span>
<a name="l00411" id="l00411"></a>00411 <span class=
"comment"> *      This routine calculates the offsets into an outgoing message buffer</span>
<a name="l00412" id="l00412"></a>00412 <span class=
"comment"> *      for the necessary values.  The outgoing buffer will generically</span>
<a name="l00413" id="l00413"></a>00413 <span class="comment"> *      look like this:</span>
<a name="l00414" id="l00414"></a>00414 <span class="comment"> *</span>
<a name="l00415" id="l00415"></a>00415 <span class="comment"> *      SNMPv3 Message</span>
<a name="l00416" id="l00416"></a>00416 <span class="comment"> *      SEQ len[11]</span>
<a name="l00417" id="l00417"></a>00417 <span class="comment"> *              INT len version</span>
<a name="l00418" id="l00418"></a>00418 <span class="comment"> *      Header</span>
<a name="l00419" id="l00419"></a>00419 <span class="comment"> *              SEQ len</span>
<a name="l00420" id="l00420"></a>00420 <span class="comment"> *                      INT len MsgID</span>
<a name="l00421" id="l00421"></a>00421 <span class="comment"> *                      INT len msgMaxSize</span>
<a name="l00422" id="l00422"></a>00422 <span class="comment"> *                      OST len msgFlags (OST = OCTET STRING)</span>
<a name="l00423" id="l00423"></a>00423 <span class="comment"> *                      INT len msgSecurityModel</span>
<a name="l00424" id="l00424"></a>00424 <span class="comment"> *      MsgSecurityParameters</span>
<a name="l00425" id="l00425"></a>00425 <span class="comment"> *              [1] OST len[2]</span>
<a name="l00426" id="l00426"></a>00426 <span class="comment"> *                      SEQ len[3]</span>
<a name="l00427" id="l00427"></a>00427 <span class=
"comment"> *                              OST len msgAuthoritativeEngineID</span>
<a name="l00428" id="l00428"></a>00428 <span class=
"comment"> *                              INT len msgAuthoritativeEngineBoots</span>
<a name="l00429" id="l00429"></a>00429 <span class=
"comment"> *                              INT len msgAuthoritativeEngineTime</span>
<a name="l00430" id="l00430"></a>00430 <span class="comment"> *                              OST len msgUserName</span>
<a name="l00431" id="l00431"></a>00431 <span class=
"comment"> *                              OST len[4] [5] msgAuthenticationParameters</span>
<a name="l00432" id="l00432"></a>00432 <span class=
"comment"> *                              OST len[6] [7] msgPrivacyParameters</span>
<a name="l00433" id="l00433"></a>00433 <span class="comment"> *      MsgData</span>
<a name="l00434" id="l00434"></a>00434 <span class="comment"> *              [8] OST len[9] [10] encryptedPDU</span>
<a name="l00435" id="l00435"></a>00435 <span class="comment"> *              or</span>
<a name="l00436" id="l00436"></a>00436 <span class="comment"> *              [8,10] SEQUENCE len[9] scopedPDU</span>
<a name="l00437" id="l00437"></a>00437 <span class="comment"> *      [12]</span>
<a name="l00438" id="l00438"></a>00438 <span class="comment"> *</span>
<a name="l00439" id="l00439"></a>00439 <span class=
"comment"> *      The bracketed points will be needed to be identified ([x] is an index</span>
<a name="l00440" id="l00440"></a>00440 <span class=
"comment"> *      value, len[x] means a length value).  Here is a semantic guide to them:</span>
<a name="l00441" id="l00441"></a>00441 <span class="comment"> *</span>
<a name="l00442" id="l00442"></a>00442 <span class="comment"> *      [1] = globalDataLen (input)</span>
<a name="l00443" id="l00443"></a>00443 <span class="comment"> *      [2] = otstlen</span>
<a name="l00444" id="l00444"></a>00444 <span class="comment"> *      [3] = seq_len</span>
<a name="l00445" id="l00445"></a>00445 <span class="comment"> *      [4] = msgAuthParmLen (may be 0 or 12)</span>
<a name="l00446" id="l00446"></a>00446 <span class="comment"> *      [5] = authParamsOffset</span>
<a name="l00447" id="l00447"></a>00447 <span class="comment"> *      [6] = msgPrivParmLen (may be 0 or 8)</span>
<a name="l00448" id="l00448"></a>00448 <span class="comment"> *      [7] = privParamsOffset</span>
<a name="l00449" id="l00449"></a>00449 <span class="comment"> *      [8] = globalDataLen + msgSecParmLen</span>
<a name="l00450" id="l00450"></a>00450 <span class="comment"> *      [9] = datalen</span>
<a name="l00451" id="l00451"></a>00451 <span class="comment"> *      [10] = dataOffset</span>
<a name="l00452" id="l00452"></a>00452 <span class=
"comment"> *      [11] = theTotalLength - the length of the header itself</span>
<a name="l00453" id="l00453"></a>00453 <span class="comment"> *      [12] = theTotalLength</span>
<a name="l00454" id="l00454"></a>00454 <span class="comment"> */</span>
<a name="l00455" id="l00455"></a>00455 <span class="keywordtype">int</span>
<a name="l00456" id="l00456"></a>00456 usm_calc_offsets(<span class="keywordtype">size_t</span> globalDataLen,  <span class=
"comment">/* SNMPv3Message + HeaderData */</span>
<a name="l00457" id="l00457"></a>00457                  <span class="keywordtype">int</span> secLevel, <span class=
"keywordtype">size_t</span> secEngineIDLen, <span class="keywordtype">size_t</span> secNameLen, <span class=
"keywordtype">size_t</span> scopedPduLen,   <span class="comment">/* An BER encoded sequence. */</span>
<a name="l00458" id="l00458"></a>00458                  u_long engineboots,    <span class=
"comment">/* XXX (asn1.c works in long, not int.) */</span>
<a name="l00459" id="l00459"></a>00459                  <span class="keywordtype">long</span> engine_time,      <span class=
"comment">/* XXX (asn1.c works in long, not int.) */</span>
<a name="l00460" id="l00460"></a>00460                  <span class=
"keywordtype">size_t</span> * theTotalLength,       <span class="comment">/* globalDataLen + msgSecurityP. + msgData */</span>
<a name="l00461" id="l00461"></a>00461                  <span class=
"keywordtype">size_t</span> * authParamsOffset,     <span class="comment">/* Distance to auth bytes.                 */</span>
<a name="l00462" id="l00462"></a>00462                  <span class=
"keywordtype">size_t</span> * privParamsOffset,     <span class="comment">/* Distance to priv bytes.                 */</span>
<a name="l00463" id="l00463"></a>00463                  <span class="keywordtype">size_t</span> * dataOffset,   <span class=
"comment">/* Distance to scopedPdu SEQ  -or-  the</span>
<a name="l00464" id="l00464"></a>00464 <span class=
"comment">                                         *   crypted (data) portion of msgData.    */</span>
<a name="l00465" id="l00465"></a>00465                  <span class="keywordtype">size_t</span> * datalen,      <span class=
"comment">/* Size of msgData OCTET STRING encoding.  */</span>
<a name="l00466" id="l00466"></a>00466                  <span class=
"keywordtype">size_t</span> * msgAuthParmLen,       <span class="comment">/* Size of msgAuthenticationParameters.    */</span>
<a name="l00467" id="l00467"></a>00467                  <span class=
"keywordtype">size_t</span> * msgPrivParmLen,       <span class="comment">/* Size of msgPrivacyParameters.           */</span>
<a name="l00468" id="l00468"></a>00468                  <span class="keywordtype">size_t</span> * otstlen,      <span class=
"comment">/* Size of msgSecurityP. O.S. encoding.    */</span>
<a name="l00469" id="l00469"></a>00469                  <span class="keywordtype">size_t</span> * seq_len,      <span class=
"comment">/* Size of msgSecurityP. SEQ data.         */</span>
<a name="l00470" id="l00470"></a>00470                  <span class="keywordtype">size_t</span> * msgSecParmLen)
<a name="l00471" id="l00471"></a>00471 {                               <span class=
"comment">/* Size of msgSecurityP. SEQ.              */</span>
<a name="l00472" id="l00472"></a>00472     <span class="keywordtype">int</span>             engIDlen,   <span class=
"comment">/* Sizes of OCTET STRING and SEQ encodings */</span>
<a name="l00473" id="l00473"></a>00473                     engBtlen,   <span class=
"comment">/*   for fields within                     */</span>
<a name="l00474" id="l00474"></a>00474                     engTmlen,   <span class=
"comment">/*   msgSecurityParameters portion of      */</span>
<a name="l00475" id="l00475"></a>00475                     namelen,    <span class=
"comment">/*   SNMPv3Message.                        */</span>
<a name="l00476" id="l00476"></a>00476                     authlen, privlen;
<a name="l00477" id="l00477"></a>00477 
<a name="l00478" id="l00478"></a>00478     <span class="comment">/*</span>
<a name="l00479" id="l00479"></a>00479 <span class=
"comment">     * If doing authentication, msgAuthParmLen = 12 else msgAuthParmLen = 0.</span>
<a name="l00480" id="l00480"></a>00480 <span class=
"comment">     * If doing encryption,     msgPrivParmLen = 8  else msgPrivParmLen = 0.</span>
<a name="l00481" id="l00481"></a>00481 <span class="comment">     */</span>
<a name="l00482" id="l00482"></a>00482     *msgAuthParmLen = (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
<a name="l00483" id="l00483"></a>00483                        || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) ? 12 : 0;
<a name="l00484" id="l00484"></a>00484 
<a name="l00485" id="l00485"></a>00485     *msgPrivParmLen = (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) ? 8 : 0;
<a name="l00486" id="l00486"></a>00486 
<a name="l00487" id="l00487"></a>00487 
<a name="l00488" id="l00488"></a>00488     <span class="comment">/*</span>
<a name="l00489" id="l00489"></a>00489 <span class="comment">     * Calculate lengths.</span>
<a name="l00490" id="l00490"></a>00490 <span class="comment">     */</span>
<a name="l00491" id="l00491"></a>00491     <span class="keywordflow">if</span> ((engIDlen = asn_predict_length(ASN_OCTET_STR,
<a name="l00492" id="l00492"></a>00492                                        NULL, secEngineIDLen)) == -1) {
<a name="l00493" id="l00493"></a>00493         <span class="keywordflow">return</span> -1;
<a name="l00494" id="l00494"></a>00494     }
<a name="l00495" id="l00495"></a>00495 
<a name="l00496" id="l00496"></a>00496     <span class="keywordflow">if</span> ((engBtlen = asn_predict_length(ASN_INTEGER,
<a name="l00497" id="l00497"></a>00497                                        (u_char *) &amp; engineboots,
<a name="l00498" id="l00498"></a>00498                                        <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>))) == -1) {
<a name="l00499" id="l00499"></a>00499         <span class="keywordflow">return</span> -1;
<a name="l00500" id="l00500"></a>00500     }
<a name="l00501" id="l00501"></a>00501 
<a name="l00502" id="l00502"></a>00502     <span class="keywordflow">if</span> ((engTmlen = asn_predict_length(ASN_INTEGER,
<a name="l00503" id="l00503"></a>00503                                        (u_char *) &amp; engine_time,
<a name="l00504" id="l00504"></a>00504                                        <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>))) == -1) {
<a name="l00505" id="l00505"></a>00505         <span class="keywordflow">return</span> -1;
<a name="l00506" id="l00506"></a>00506     }
<a name="l00507" id="l00507"></a>00507 
<a name="l00508" id="l00508"></a>00508     <span class="keywordflow">if</span> ((namelen = asn_predict_length(ASN_OCTET_STR,
<a name="l00509" id="l00509"></a>00509                                       NULL, secNameLen)) == -1) {
<a name="l00510" id="l00510"></a>00510         <span class="keywordflow">return</span> -1;
<a name="l00511" id="l00511"></a>00511     }
<a name="l00512" id="l00512"></a>00512 
<a name="l00513" id="l00513"></a>00513     <span class="keywordflow">if</span> ((authlen = asn_predict_length(ASN_OCTET_STR,
<a name="l00514" id="l00514"></a>00514                                       NULL, *msgAuthParmLen)) == -1) {
<a name="l00515" id="l00515"></a>00515         <span class="keywordflow">return</span> -1;
<a name="l00516" id="l00516"></a>00516     }
<a name="l00517" id="l00517"></a>00517 
<a name="l00518" id="l00518"></a>00518     <span class="keywordflow">if</span> ((privlen = asn_predict_length(ASN_OCTET_STR,
<a name="l00519" id="l00519"></a>00519                                       NULL, *msgPrivParmLen)) == -1) {
<a name="l00520" id="l00520"></a>00520         <span class="keywordflow">return</span> -1;
<a name="l00521" id="l00521"></a>00521     }
<a name="l00522" id="l00522"></a>00522 
<a name="l00523" id="l00523"></a>00523     *seq_len =
<a name="l00524" id="l00524"></a>00524         engIDlen + engBtlen + engTmlen + namelen + authlen + privlen;
<a name="l00525" id="l00525"></a>00525 
<a name="l00526" id="l00526"></a>00526     <span class="keywordflow">if</span> ((*otstlen = asn_predict_length(ASN_SEQUENCE,
<a name="l00527" id="l00527"></a>00527                                        NULL, *seq_len)) == -1) {
<a name="l00528" id="l00528"></a>00528         <span class="keywordflow">return</span> -1;
<a name="l00529" id="l00529"></a>00529     }
<a name="l00530" id="l00530"></a>00530 
<a name="l00531" id="l00531"></a>00531     <span class=
"keywordflow">if</span> ((*msgSecParmLen = asn_predict_length(ASN_OCTET_STR,
<a name="l00532" id="l00532"></a>00532                                              NULL, *otstlen)) == -1) {
<a name="l00533" id="l00533"></a>00533         <span class="keywordflow">return</span> -1;
<a name="l00534" id="l00534"></a>00534     }
<a name="l00535" id="l00535"></a>00535 
<a name="l00536" id="l00536"></a>00536     *authParamsOffset = globalDataLen + +(*msgSecParmLen - *seq_len)
<a name="l00537" id="l00537"></a>00537         + engIDlen + engBtlen + engTmlen + namelen
<a name="l00538" id="l00538"></a>00538         + (authlen - *msgAuthParmLen);
<a name="l00539" id="l00539"></a>00539 
<a name="l00540" id="l00540"></a>00540     *privParamsOffset = *authParamsOffset + *msgAuthParmLen
<a name="l00541" id="l00541"></a>00541         + (privlen - *msgPrivParmLen);
<a name="l00542" id="l00542"></a>00542 
<a name="l00543" id="l00543"></a>00543 
<a name="l00544" id="l00544"></a>00544     <span class="comment">/*</span>
<a name="l00545" id="l00545"></a>00545 <span class=
"comment">     * Compute the size of the plaintext.  Round up to account for cipher</span>
<a name="l00546" id="l00546"></a>00546 <span class="comment">     * block size, if necessary.</span>
<a name="l00547" id="l00547"></a>00547 <span class="comment">     *</span>
<a name="l00548" id="l00548"></a>00548 <span class=
"comment">     * XXX  This is hardwired for 1DES... If scopedPduLen is already</span>
<a name="l00549" id="l00549"></a>00549 <span class=
"comment">     *      a multiple of 8, then *add* 8 more; otherwise, round up</span>
<a name="l00550" id="l00550"></a>00550 <span class="comment">     *      to the next multiple of 8.</span>
<a name="l00551" id="l00551"></a>00551 <span class="comment">     *</span>
<a name="l00552" id="l00552"></a>00552 <span class=
"comment">     * FIX  Calculation of encrypted portion of msgData and consequent</span>
<a name="l00553" id="l00553"></a>00553 <span class=
"comment">     *      setting and sanity checking of theTotalLength, et al. should</span>
<a name="l00554" id="l00554"></a>00554 <span class="comment">     *      occur *after* encryption has taken place.</span>
<a name="l00555" id="l00555"></a>00555 <span class="comment">     */</span>
<a name="l00556" id="l00556"></a>00556     <span class="keywordflow">if</span> (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l00557" id="l00557"></a>00557         scopedPduLen = ROUNDUP8(scopedPduLen);
<a name="l00558" id="l00558"></a>00558 
<a name="l00559" id="l00559"></a>00559         <span class="keywordflow">if</span> ((*datalen =
<a name="l00560" id="l00560"></a>00560              asn_predict_length(ASN_OCTET_STR, NULL, scopedPduLen)) == -1) {
<a name="l00561" id="l00561"></a>00561             <span class="keywordflow">return</span> -1;
<a name="l00562" id="l00562"></a>00562         }
<a name="l00563" id="l00563"></a>00563     } <span class="keywordflow">else</span> {
<a name="l00564" id="l00564"></a>00564         *datalen = scopedPduLen;
<a name="l00565" id="l00565"></a>00565     }
<a name="l00566" id="l00566"></a>00566 
<a name="l00567" id="l00567"></a>00567     *dataOffset = globalDataLen + *msgSecParmLen +
<a name="l00568" id="l00568"></a>00568         (*datalen - scopedPduLen);
<a name="l00569" id="l00569"></a>00569     *theTotalLength = globalDataLen + *msgSecParmLen + *datalen;
<a name="l00570" id="l00570"></a>00570 
<a name="l00571" id="l00571"></a>00571     <span class="keywordflow">return</span> 0;
<a name="l00572" id="l00572"></a>00572 
<a name="l00573" id="l00573"></a>00573 }                               <span class="comment">/* end usm_calc_offsets() */</span>
<a name="l00574" id="l00574"></a>00574 
<a name="l00575" id="l00575"></a>00575 
<a name="l00576" id="l00576"></a>00576 
<a name="l00577" id="l00577"></a>00577 
<a name="l00578" id="l00578"></a>00578 
<a name="l00579" id="l00579"></a>00579 <span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l00580" id="l00580"></a>00580 <span class=
"comment">/*******************************************************************-o-******</span>
<a name="l00581" id="l00581"></a>00581 <span class="comment"> * usm_set_salt</span>
<a name="l00582" id="l00582"></a>00582 <span class="comment"> *</span>
<a name="l00583" id="l00583"></a>00583 <span class="comment"> * Parameters:</span>
<a name="l00584" id="l00584"></a>00584 <span class="comment"> *      *iv               (O)   Buffer to contain IV.</span>
<a name="l00585" id="l00585"></a>00585 <span class="comment"> *      *iv_length        (O)   Length of iv.</span>
<a name="l00586" id="l00586"></a>00586 <span class="comment"> *      *priv_salt        (I)   Salt portion of private key.</span>
<a name="l00587" id="l00587"></a>00587 <span class="comment"> *       priv_salt_length (I)   Length of priv_salt.</span>
<a name="l00588" id="l00588"></a>00588 <span class=
"comment"> *      *msgSalt          (I/O) Pointer salt portion of outgoing msg buffer.</span>
<a name="l00589" id="l00589"></a>00589 <span class="comment"> *      </span>
<a name="l00590" id="l00590"></a>00590 <span class="comment"> * Returns:</span>
<a name="l00591" id="l00591"></a>00591 <span class="comment"> *      0       On success,</span>
<a name="l00592" id="l00592"></a>00592 <span class="comment"> *      -1      Otherwise.</span>
<a name="l00593" id="l00593"></a>00593 <span class="comment"> *</span>
<a name="l00594" id="l00594"></a>00594 <span class=
"comment"> *      Determine the initialization vector for the DES-CBC encryption.</span>
<a name="l00595" id="l00595"></a>00595 <span class="comment"> *      (Cf. RFC 2274, 8.1.1.1.)</span>
<a name="l00596" id="l00596"></a>00596 <span class="comment"> *</span>
<a name="l00597" id="l00597"></a>00597 <span class=
"comment"> *      iv is defined as the concatenation of engineBoots and the</span>
<a name="l00598" id="l00598"></a>00598 <span class="comment"> *              salt integer.</span>
<a name="l00599" id="l00599"></a>00599 <span class="comment"> *      The salt integer is incremented.</span>
<a name="l00600" id="l00600"></a>00600 <span class="comment"> *      The resulting salt is copied into the msgSalt buffer.</span>
<a name="l00601" id="l00601"></a>00601 <span class=
"comment"> *      The result of the concatenation is then XORed with the salt</span>
<a name="l00602" id="l00602"></a>00602 <span class="comment"> *              portion of the private key (last 8 bytes).</span>
<a name="l00603" id="l00603"></a>00603 <span class=
"comment"> *      The IV result is returned individually for further use.</span>
<a name="l00604" id="l00604"></a>00604 <span class="comment"> */</span>
<a name="l00605" id="l00605"></a>00605 <span class="keywordtype">int</span>
<a name="l00606" id="l00606"></a>00606 usm_set_salt(u_char * iv,
<a name="l00607" id="l00607"></a>00607              <span class="keywordtype">size_t</span> * iv_length,
<a name="l00608" id="l00608"></a>00608              u_char * priv_salt, <span class=
"keywordtype">size_t</span> priv_salt_length, u_char * msgSalt)
<a name="l00609" id="l00609"></a>00609 {
<a name="l00610" id="l00610"></a>00610     <span class=
"keywordtype">size_t</span>          propersize_salt = BYTESIZE(USM_DES_SALT_LENGTH);
<a name="l00611" id="l00611"></a>00611     <span class="keywordtype">int</span>             net_boots;
<a name="l00612" id="l00612"></a>00612     <span class="keywordtype">int</span>             net_salt_int;
<a name="l00613" id="l00613"></a>00613     <span class="comment">/*</span>
<a name="l00614" id="l00614"></a>00614 <span class=
"comment">     * net_* should be encoded in network byte order.  XXX  Why?</span>
<a name="l00615" id="l00615"></a>00615 <span class="comment">     */</span>
<a name="l00616" id="l00616"></a>00616     <span class="keywordtype">int</span>             iindex;
<a name="l00617" id="l00617"></a>00617 
<a name="l00618" id="l00618"></a>00618 
<a name="l00619" id="l00619"></a>00619     <span class="comment">/*</span>
<a name="l00620" id="l00620"></a>00620 <span class="comment">     * Sanity check.</span>
<a name="l00621" id="l00621"></a>00621 <span class="comment">     */</span>
<a name="l00622" id="l00622"></a>00622     <span class=
"keywordflow">if</span> (!iv || !iv_length || !priv_salt || (*iv_length != propersize_salt)
<a name="l00623" id="l00623"></a>00623         || (priv_salt_length &lt; propersize_salt)) {
<a name="l00624" id="l00624"></a>00624         <span class="keywordflow">return</span> -1;
<a name="l00625" id="l00625"></a>00625     }
<a name="l00626" id="l00626"></a>00626 
<a name="l00627" id="l00627"></a>00627 
<a name="l00628" id="l00628"></a>00628     net_boots = htonl(snmpv3_local_snmpEngineBoots());
<a name="l00629" id="l00629"></a>00629     net_salt_int = htonl(salt_integer);
<a name="l00630" id="l00630"></a>00630 
<a name="l00631" id="l00631"></a>00631     salt_integer += 1;
<a name="l00632" id="l00632"></a>00632 
<a name="l00633" id="l00633"></a>00633     memcpy(iv, &amp;net_boots, propersize_salt / 2);
<a name="l00634" id="l00634"></a>00634     memcpy(iv + (propersize_salt / 2), &amp;net_salt_int, propersize_salt / 2);
<a name="l00635" id="l00635"></a>00635 
<a name="l00636" id="l00636"></a>00636     <span class="keywordflow">if</span> (msgSalt)
<a name="l00637" id="l00637"></a>00637         memcpy(msgSalt, iv, propersize_salt);
<a name="l00638" id="l00638"></a>00638 
<a name="l00639" id="l00639"></a>00639 
<a name="l00640" id="l00640"></a>00640     <span class="comment">/*</span>
<a name="l00641" id="l00641"></a>00641 <span class=
"comment">     * Turn the salt into an IV: XOR &lt;boots, salt_int&gt; with salt</span>
<a name="l00642" id="l00642"></a>00642 <span class="comment">     * portion of priv_key.</span>
<a name="l00643" id="l00643"></a>00643 <span class="comment">     */</span>
<a name="l00644" id="l00644"></a>00644     <span class=
"keywordflow">for</span> (iindex = 0; iindex &lt; (int) propersize_salt; iindex++)
<a name="l00645" id="l00645"></a>00645         iv[iindex] ^= priv_salt[iindex];
<a name="l00646" id="l00646"></a>00646 
<a name="l00647" id="l00647"></a>00647 
<a name="l00648" id="l00648"></a>00648     <span class="keywordflow">return</span> 0;
<a name="l00649" id="l00649"></a>00649 
<a name="l00650" id="l00650"></a>00650 }                               <span class="comment">/* end usm_set_salt() */</span>
<a name="l00651" id="l00651"></a>00651 <span class="preprocessor">#endif</span>
<a name="l00652" id="l00652"></a>00652 
<a name="l00653" id="l00653"></a>00653 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l00654" id="l00654"></a>00654 <span class=
"comment">/*******************************************************************-o-******</span>
<a name="l00655" id="l00655"></a>00655 <span class="comment"> * usm_set_aes_iv</span>
<a name="l00656" id="l00656"></a>00656 <span class="comment"> *</span>
<a name="l00657" id="l00657"></a>00657 <span class="comment"> * Parameters:</span>
<a name="l00658" id="l00658"></a>00658 <span class="comment"> *      *iv               (O)   Buffer to contain IV.</span>
<a name="l00659" id="l00659"></a>00659 <span class="comment"> *      *iv_length        (O)   Length of iv.</span>
<a name="l00660" id="l00660"></a>00660 <span class=
"comment"> *      net_boots         (I)   the network byte order of the authEng boots val</span>
<a name="l00661" id="l00661"></a>00661 <span class=
"comment"> *      net_time         (I)   the network byte order of the authEng time val</span>
<a name="l00662" id="l00662"></a>00662 <span class=
"comment"> *      *salt             (O)   A buffer for the outgoing salt (= 8 bytes of iv)</span>
<a name="l00663" id="l00663"></a>00663 <span class="comment"> *      </span>
<a name="l00664" id="l00664"></a>00664 <span class="comment"> * Returns:</span>
<a name="l00665" id="l00665"></a>00665 <span class="comment"> *      0       On success,</span>
<a name="l00666" id="l00666"></a>00666 <span class="comment"> *      -1      Otherwise.</span>
<a name="l00667" id="l00667"></a>00667 <span class="comment"> *</span>
<a name="l00668" id="l00668"></a>00668 <span class=
"comment"> *      Determine the initialization vector for AES encryption.</span>
<a name="l00669" id="l00669"></a>00669 <span class="comment"> *      (draft-blumenthal-aes-usm-03.txt, 3.1.2.2)</span>
<a name="l00670" id="l00670"></a>00670 <span class="comment"> *</span>
<a name="l00671" id="l00671"></a>00671 <span class=
"comment"> *      iv is defined as the concatenation of engineBoots, engineTime</span>
<a name="l00672" id="l00672"></a>00672 <span class="comment">        and a 64 bit salt-integer.</span>
<a name="l00673" id="l00673"></a>00673 <span class="comment"> *      The 64 bit salt integer is incremented.</span>
<a name="l00674" id="l00674"></a>00674 <span class="comment"> *      The resulting salt is copied into the salt buffer.</span>
<a name="l00675" id="l00675"></a>00675 <span class=
"comment"> *      The IV result is returned individually for further use.</span>
<a name="l00676" id="l00676"></a>00676 <span class="comment"> */</span>
<a name="l00677" id="l00677"></a>00677 <span class="keywordtype">int</span>
<a name="l00678" id="l00678"></a>00678 usm_set_aes_iv(u_char * iv,
<a name="l00679" id="l00679"></a>00679                <span class="keywordtype">size_t</span> * iv_length,
<a name="l00680" id="l00680"></a>00680                u_int net_boots,
<a name="l00681" id="l00681"></a>00681                u_int net_time,
<a name="l00682" id="l00682"></a>00682                u_char * salt)
<a name="l00683" id="l00683"></a>00683 {
<a name="l00684" id="l00684"></a>00684     <span class="comment">/*</span>
<a name="l00685" id="l00685"></a>00685 <span class="comment">     * net_* should be encoded in network byte order.</span>
<a name="l00686" id="l00686"></a>00686 <span class="comment">     */</span>
<a name="l00687" id="l00687"></a>00687     <span class="keywordtype">int</span>             net_salt_int1, net_salt_int2;
<a name="l00688" id="l00688"></a>00688 <span class="preprocessor">#define PROPER_AES_IV_SIZE 64</span>
<a name="l00689" id="l00689"></a>00689 
<a name="l00690" id="l00690"></a>00690     <span class="comment">/*</span>
<a name="l00691" id="l00691"></a>00691 <span class="comment">     * Sanity check.</span>
<a name="l00692" id="l00692"></a>00692 <span class="comment">     */</span>
<a name="l00693" id="l00693"></a>00693     <span class="keywordflow">if</span> (!iv || !iv_length) {
<a name="l00694" id="l00694"></a>00694         <span class="keywordflow">return</span> -1;
<a name="l00695" id="l00695"></a>00695     }
<a name="l00696" id="l00696"></a>00696 
<a name="l00697" id="l00697"></a>00697     net_salt_int1 = htonl(salt_integer64_1);
<a name="l00698" id="l00698"></a>00698     net_salt_int2 = htonl(salt_integer64_2);
<a name="l00699" id="l00699"></a>00699 
<a name="l00700" id="l00700"></a>00700     <span class="keywordflow">if</span> ((salt_integer64_2 += 1) == 0)
<a name="l00701" id="l00701"></a>00701         salt_integer64_2 += 1;
<a name="l00702" id="l00702"></a>00702     
<a name="l00703" id="l00703"></a>00703     <span class="comment">/* XXX: warning: hard coded proper lengths */</span>
<a name="l00704" id="l00704"></a>00704     memcpy(iv, &amp;net_boots, 4);
<a name="l00705" id="l00705"></a>00705     memcpy(iv+4, &amp;net_time, 4);
<a name="l00706" id="l00706"></a>00706     memcpy(iv+8, &amp;net_salt_int1, 4);
<a name="l00707" id="l00707"></a>00707     memcpy(iv+12, &amp;net_salt_int2, 4);
<a name="l00708" id="l00708"></a>00708 
<a name="l00709" id="l00709"></a>00709     memcpy(salt, iv+8, 8); <span class="comment">/* only copy the needed portion */</span>
<a name="l00710" id="l00710"></a>00710     <span class="keywordflow">return</span> 0;
<a name="l00711" id="l00711"></a>00711 }                               <span class="comment">/* end usm_set_salt() */</span>
<a name="l00712" id="l00712"></a>00712 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_AES */</span>
<a name="l00713" id="l00713"></a>00713 
<a name="l00714" id="l00714"></a>00714 <span class="keywordtype">int</span>
<a name="l00715" id="l00715"></a>00715 usm_secmod_generate_out_msg(<span class="keyword">struct</span> <a class="code" href=
"structsnmp__secmod__outgoing__params.html">snmp_secmod_outgoing_params</a> *parms)
<a name="l00716" id="l00716"></a>00716 {
<a name="l00717" id="l00717"></a>00717     <span class="keywordflow">if</span> (!parms)
<a name="l00718" id="l00718"></a>00718         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l00719" id="l00719"></a>00719 
<a name="l00720" id="l00720"></a>00720     <span class="keywordflow">return</span> usm_generate_out_msg(parms-&gt;msgProcModel,
<a name="l00721" id="l00721"></a>00721                                 parms-&gt;globalData, parms-&gt;globalDataLen,
<a name="l00722" id="l00722"></a>00722                                 parms-&gt;maxMsgSize, parms-&gt;secModel,
<a name="l00723" id="l00723"></a>00723                                 parms-&gt;secEngineID, parms-&gt;secEngineIDLen,
<a name="l00724" id="l00724"></a>00724                                 parms-&gt;secName, parms-&gt;secNameLen,
<a name="l00725" id="l00725"></a>00725                                 parms-&gt;secLevel,
<a name="l00726" id="l00726"></a>00726                                 parms-&gt;scopedPdu, parms-&gt;scopedPduLen,
<a name="l00727" id="l00727"></a>00727                                 parms-&gt;secStateRef,
<a name="l00728" id="l00728"></a>00728                                 parms-&gt;secParams, parms-&gt;secParamsLen,
<a name="l00729" id="l00729"></a>00729                                 parms-&gt;wholeMsg, parms-&gt;wholeMsgLen);
<a name="l00730" id="l00730"></a>00730 }
<a name="l00731" id="l00731"></a>00731 
<a name="l00732" id="l00732"></a>00732 <span class=
"comment">/*******************************************************************-o-******</span>
<a name="l00733" id="l00733"></a>00733 <span class="comment"> * usm_generate_out_msg</span>
<a name="l00734" id="l00734"></a>00734 <span class="comment"> *</span>
<a name="l00735" id="l00735"></a>00735 <span class="comment"> * Parameters:</span>
<a name="l00736" id="l00736"></a>00736 <span class="comment"> *      (See list below...)</span>
<a name="l00737" id="l00737"></a>00737 <span class="comment"> *      </span>
<a name="l00738" id="l00738"></a>00738 <span class="comment"> * Returns:</span>
<a name="l00739" id="l00739"></a>00739 <span class="comment"> *      SNMPERR_SUCCESS                 On success.</span>
<a name="l00740" id="l00740"></a>00740 <span class="comment"> *      SNMPERR_USM_AUTHENTICATIONFAILURE</span>
<a name="l00741" id="l00741"></a>00741 <span class="comment"> *      SNMPERR_USM_ENCRYPTIONERROR</span>
<a name="l00742" id="l00742"></a>00742 <span class="comment"> *      SNMPERR_USM_GENERICERROR</span>
<a name="l00743" id="l00743"></a>00743 <span class="comment"> *      SNMPERR_USM_UNKNOWNSECURITYNAME</span>
<a name="l00744" id="l00744"></a>00744 <span class="comment"> *      SNMPERR_USM_GENERICERROR</span>
<a name="l00745" id="l00745"></a>00745 <span class="comment"> *      SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL</span>
<a name="l00746" id="l00746"></a>00746 <span class="comment"> *      </span>
<a name="l00747" id="l00747"></a>00747 <span class="comment"> *</span>
<a name="l00748" id="l00748"></a>00748 <span class="comment"> * Generates an outgoing message.</span>
<a name="l00749" id="l00749"></a>00749 <span class="comment"> *</span>
<a name="l00750" id="l00750"></a>00750 <span class="comment"> * XXX  Beware of misnomers!</span>
<a name="l00751" id="l00751"></a>00751 <span class="comment"> */</span>
<a name="l00752" id="l00752"></a>00752 <span class="keywordtype">int</span>
<a name="l00753" id="l00753"></a>00753 usm_generate_out_msg(<span class="keywordtype">int</span> msgProcModel,  <span class=
"comment">/* (UNUSED) */</span>
<a name="l00754" id="l00754"></a>00754                      u_char * globalData,       <span class="comment">/* IN */</span>
<a name="l00755" id="l00755"></a>00755                      <span class="comment">/*</span>
<a name="l00756" id="l00756"></a>00756 <span class=
"comment">                      * Pointer to msg header data will point to the beginning</span>
<a name="l00757" id="l00757"></a>00757 <span class=
"comment">                      * * of the entire packet buffer to be transmitted on wire,</span>
<a name="l00758" id="l00758"></a>00758 <span class=
"comment">                      * * memory will be contiguous with secParams, typically</span>
<a name="l00759" id="l00759"></a>00759 <span class=
"comment">                      * * this pointer will be passed back as beginning of</span>
<a name="l00760" id="l00760"></a>00760 <span class=
"comment">                      * * wholeMsg below.  asn seq. length is updated w/ new length.</span>
<a name="l00761" id="l00761"></a>00761 <span class="comment">                      * *</span>
<a name="l00762" id="l00762"></a>00762 <span class=
"comment">                      * * While this points to a buffer that should be big enough</span>
<a name="l00763" id="l00763"></a>00763 <span class=
"comment">                      * * for the whole message, only the first two parts</span>
<a name="l00764" id="l00764"></a>00764 <span class=
"comment">                      * * of the message are completed, namely SNMPv3Message and</span>
<a name="l00765" id="l00765"></a>00765 <span class=
"comment">                      * * HeaderData.  globalDataLen (next parameter) represents</span>
<a name="l00766" id="l00766"></a>00766 <span class=
"comment">                      * * the length of these two completed parts.</span>
<a name="l00767" id="l00767"></a>00767 <span class="comment">                      */</span>
<a name="l00768" id="l00768"></a>00768                      <span class=
"keywordtype">size_t</span> globalDataLen,      <span class="comment">/* IN - Length of msg header data.      */</span>
<a name="l00769" id="l00769"></a>00769                      <span class="keywordtype">int</span> maxMsgSize,    <span class=
"comment">/* (UNUSED) */</span>
<a name="l00770" id="l00770"></a>00770                      <span class="keywordtype">int</span> secModel,      <span class=
"comment">/* (UNUSED) */</span>
<a name="l00771" id="l00771"></a>00771                      u_char * secEngineID,      <span class=
"comment">/* IN - Pointer snmpEngineID.           */</span>
<a name="l00772" id="l00772"></a>00772                      <span class=
"keywordtype">size_t</span> secEngineIDLen,     <span class="comment">/* IN - SnmpEngineID length.            */</span>
<a name="l00773" id="l00773"></a>00773                      <span class="keywordtype">char</span> *secName,     <span class=
"comment">/* IN - Pointer to securityName.        */</span>
<a name="l00774" id="l00774"></a>00774                      <span class="keywordtype">size_t</span> secNameLen, <span class=
"comment">/* IN - SecurityName length.            */</span>
<a name="l00775" id="l00775"></a>00775                      <span class="keywordtype">int</span> secLevel,      <span class=
"comment">/* IN - AuthNoPriv, authPriv etc.       */</span>
<a name="l00776" id="l00776"></a>00776                      u_char * scopedPdu,        <span class="comment">/* IN */</span>
<a name="l00777" id="l00777"></a>00777                      <span class="comment">/*</span>
<a name="l00778" id="l00778"></a>00778 <span class=
"comment">                      * Pointer to scopedPdu will be encrypted by USM if needed</span>
<a name="l00779" id="l00779"></a>00779 <span class=
"comment">                      * * and written to packet buffer immediately following</span>
<a name="l00780" id="l00780"></a>00780 <span class=
"comment">                      * * securityParameters, entire msg will be authenticated by</span>
<a name="l00781" id="l00781"></a>00781 <span class="comment">                      * * USM if needed.</span>
<a name="l00782" id="l00782"></a>00782 <span class="comment">                      */</span>
<a name="l00783" id="l00783"></a>00783                      <span class=
"keywordtype">size_t</span> scopedPduLen,       <span class="comment">/* IN - scopedPdu length. */</span>
<a name="l00784" id="l00784"></a>00784                      <span class="keywordtype">void</span> *secStateRef, <span class=
"comment">/* IN */</span>
<a name="l00785" id="l00785"></a>00785                      <span class="comment">/*</span>
<a name="l00786" id="l00786"></a>00786 <span class=
"comment">                      * secStateRef, pointer to cached info provided only for</span>
<a name="l00787" id="l00787"></a>00787 <span class="comment">                      * * Response, otherwise NULL.</span>
<a name="l00788" id="l00788"></a>00788 <span class="comment">                      */</span>
<a name="l00789" id="l00789"></a>00789                      u_char * secParams,        <span class="comment">/* OUT */</span>
<a name="l00790" id="l00790"></a>00790                      <span class="comment">/*</span>
<a name="l00791" id="l00791"></a>00791 <span class=
"comment">                      * BER encoded securityParameters pointer to offset within</span>
<a name="l00792" id="l00792"></a>00792 <span class=
"comment">                      * * packet buffer where secParams should be written, the</span>
<a name="l00793" id="l00793"></a>00793 <span class=
"comment">                      * * entire BER encoded OCTET STRING (including header) is</span>
<a name="l00794" id="l00794"></a>00794 <span class=
"comment">                      * * written here by USM secParams = globalData +</span>
<a name="l00795" id="l00795"></a>00795 <span class="comment">                      * * globalDataLen.</span>
<a name="l00796" id="l00796"></a>00796 <span class="comment">                      */</span>
<a name="l00797" id="l00797"></a>00797                      <span class=
"keywordtype">size_t</span> * secParamsLen,     <span class="comment">/* IN/OUT - Len available, len returned. */</span>
<a name="l00798" id="l00798"></a>00798                      u_char ** wholeMsg,        <span class="comment">/* OUT */</span>
<a name="l00799" id="l00799"></a>00799                      <span class="comment">/*</span>
<a name="l00800" id="l00800"></a>00800 <span class=
"comment">                      * Complete authenticated/encrypted message - typically</span>
<a name="l00801" id="l00801"></a>00801 <span class=
"comment">                      * * the pointer to start of packet buffer provided in</span>
<a name="l00802" id="l00802"></a>00802 <span class=
"comment">                      * * globalData is returned here, could also be a separate</span>
<a name="l00803" id="l00803"></a>00803 <span class="comment">                      * * buffer.</span>
<a name="l00804" id="l00804"></a>00804 <span class="comment">                      */</span>
<a name="l00805" id="l00805"></a>00805                      <span class="keywordtype">size_t</span> * wholeMsgLen)
<a name="l00806" id="l00806"></a>00806 {                               <span class=
"comment">/* IN/OUT - Len available, len returned. */</span>
<a name="l00807" id="l00807"></a>00807     <span class="keywordtype">size_t</span>          otstlen;
<a name="l00808" id="l00808"></a>00808     <span class="keywordtype">size_t</span>          seq_len;
<a name="l00809" id="l00809"></a>00809     <span class="keywordtype">size_t</span>          msgAuthParmLen;
<a name="l00810" id="l00810"></a>00810     <span class="keywordtype">size_t</span>          msgPrivParmLen;
<a name="l00811" id="l00811"></a>00811     <span class="keywordtype">size_t</span>          msgSecParmLen;
<a name="l00812" id="l00812"></a>00812     <span class="keywordtype">size_t</span>          authParamsOffset;
<a name="l00813" id="l00813"></a>00813     <span class="keywordtype">size_t</span>          privParamsOffset;
<a name="l00814" id="l00814"></a>00814     <span class="keywordtype">size_t</span>          datalen;
<a name="l00815" id="l00815"></a>00815     <span class="keywordtype">size_t</span>          dataOffset;
<a name="l00816" id="l00816"></a>00816     <span class="keywordtype">size_t</span>          theTotalLength;
<a name="l00817" id="l00817"></a>00817 
<a name="l00818" id="l00818"></a>00818     u_char         *ptr;
<a name="l00819" id="l00819"></a>00819     <span class="keywordtype">size_t</span>          ptr_len;
<a name="l00820" id="l00820"></a>00820     <span class="keywordtype">size_t</span>          remaining;
<a name="l00821" id="l00821"></a>00821     <span class="keywordtype">size_t</span>          offSet;
<a name="l00822" id="l00822"></a>00822     u_int           boots_uint;
<a name="l00823" id="l00823"></a>00823     u_int           time_uint;
<a name="l00824" id="l00824"></a>00824     <span class="keywordtype">long</span>            boots_long;
<a name="l00825" id="l00825"></a>00825     <span class="keywordtype">long</span>            time_long;
<a name="l00826" id="l00826"></a>00826 
<a name="l00827" id="l00827"></a>00827     <span class="comment">/*</span>
<a name="l00828" id="l00828"></a>00828 <span class=
"comment">     * Indirection because secStateRef values override parameters.</span>
<a name="l00829" id="l00829"></a>00829 <span class="comment">     * </span>
<a name="l00830" id="l00830"></a>00830 <span class=
"comment">     * None of these are to be free'd - they are either pointing to</span>
<a name="l00831" id="l00831"></a>00831 <span class=
"comment">     * what's in the secStateRef or to something either in the</span>
<a name="l00832" id="l00832"></a>00832 <span class="comment">     * actual prarmeter list or the user list.</span>
<a name="l00833" id="l00833"></a>00833 <span class="comment">     */</span>
<a name="l00834" id="l00834"></a>00834 
<a name="l00835" id="l00835"></a>00835     <span class="keywordtype">char</span>           *theName = NULL;
<a name="l00836" id="l00836"></a>00836     u_int           theNameLength = 0;
<a name="l00837" id="l00837"></a>00837     u_char         *theEngineID = NULL;
<a name="l00838" id="l00838"></a>00838     u_int           theEngineIDLength = 0;
<a name="l00839" id="l00839"></a>00839     u_char         *theAuthKey = NULL;
<a name="l00840" id="l00840"></a>00840     u_int           theAuthKeyLength = 0;
<a name="l00841" id="l00841"></a>00841     <span class="keyword">const</span> oid      *theAuthProtocol = NULL;
<a name="l00842" id="l00842"></a>00842     u_int           theAuthProtocolLength = 0;
<a name="l00843" id="l00843"></a>00843     u_char         *thePrivKey = NULL;
<a name="l00844" id="l00844"></a>00844     u_int           thePrivKeyLength = 0;
<a name="l00845" id="l00845"></a>00845     <span class="keyword">const</span> oid      *thePrivProtocol = NULL;
<a name="l00846" id="l00846"></a>00846     u_int           thePrivProtocolLength = 0;
<a name="l00847" id="l00847"></a>00847     <span class="keywordtype">int</span>             theSecLevel = 0;    <span class=
"comment">/* No defined const for bad</span>
<a name="l00848" id="l00848"></a>00848 <span class=
"comment">                                         * value (other then err).</span>
<a name="l00849" id="l00849"></a>00849 <span class="comment">                                         */</span>
<a name="l00850" id="l00850"></a>00850 
<a name="l00851" id="l00851"></a>00851     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"USM processing has begun.\n"</span>));
<a name="l00852" id="l00852"></a>00852 
<a name="l00853" id="l00853"></a>00853     <span class="keywordflow">if</span> (secStateRef != NULL) {
<a name="l00854" id="l00854"></a>00854         <span class="comment">/*</span>
<a name="l00855" id="l00855"></a>00855 <span class="comment">         * To hush the compiler for now.  XXX </span>
<a name="l00856" id="l00856"></a>00856 <span class="comment">         */</span>
<a name="l00857" id="l00857"></a>00857         <span class="keyword">struct </span><a class="code" href=
"structusmStateReference.html">usmStateReference</a> *ref
<a name="l00858" id="l00858"></a>00858             = (<span class="keyword">struct </span><a class="code" href=
"structusmStateReference.html">usmStateReference</a> *) secStateRef;
<a name="l00859" id="l00859"></a>00859 
<a name="l00860" id="l00860"></a>00860         theName = ref-&gt;usr_name;
<a name="l00861" id="l00861"></a>00861         theNameLength = ref-&gt;usr_name_length;
<a name="l00862" id="l00862"></a>00862         theEngineID = ref-&gt;usr_engine_id;
<a name="l00863" id="l00863"></a>00863         theEngineIDLength = ref-&gt;usr_engine_id_length;
<a name="l00864" id="l00864"></a>00864 
<a name="l00865" id="l00865"></a>00865         <span class="keywordflow">if</span> (!theEngineIDLength) {
<a name="l00866" id="l00866"></a>00866             theEngineID = secEngineID;
<a name="l00867" id="l00867"></a>00867             theEngineIDLength = secEngineIDLen;
<a name="l00868" id="l00868"></a>00868         }
<a name="l00869" id="l00869"></a>00869 
<a name="l00870" id="l00870"></a>00870         theAuthProtocol = ref-&gt;usr_auth_protocol;
<a name="l00871" id="l00871"></a>00871         theAuthProtocolLength = ref-&gt;usr_auth_protocol_length;
<a name="l00872" id="l00872"></a>00872         theAuthKey = ref-&gt;usr_auth_key;
<a name="l00873" id="l00873"></a>00873         theAuthKeyLength = ref-&gt;usr_auth_key_length;
<a name="l00874" id="l00874"></a>00874         thePrivProtocol = ref-&gt;usr_priv_protocol;
<a name="l00875" id="l00875"></a>00875         thePrivProtocolLength = ref-&gt;usr_priv_protocol_length;
<a name="l00876" id="l00876"></a>00876         thePrivKey = ref-&gt;usr_priv_key;
<a name="l00877" id="l00877"></a>00877         thePrivKeyLength = ref-&gt;usr_priv_key_length;
<a name="l00878" id="l00878"></a>00878         theSecLevel = ref-&gt;usr_sec_level;
<a name="l00879" id="l00879"></a>00879     }
<a name="l00880" id="l00880"></a>00880 
<a name="l00881" id="l00881"></a>00881     <span class="comment">/*</span>
<a name="l00882" id="l00882"></a>00882 <span class="comment">     * Identify the user record.</span>
<a name="l00883" id="l00883"></a>00883 <span class="comment">     */</span>
<a name="l00884" id="l00884"></a>00884     <span class="keywordflow">else</span> {
<a name="l00885" id="l00885"></a>00885         <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *user;
<a name="l00886" id="l00886"></a>00886 
<a name="l00887" id="l00887"></a>00887         <span class="comment">/*</span>
<a name="l00888" id="l00888"></a>00888 <span class="comment">         * we do allow an unknown user name for</span>
<a name="l00889" id="l00889"></a>00889 <span class="comment">         * unauthenticated requests. </span>
<a name="l00890" id="l00890"></a>00890 <span class="comment">         */</span>
<a name="l00891" id="l00891"></a>00891         <span class=
"keywordflow">if</span> ((user = usm_get_user(secEngineID, secEngineIDLen, secName))
<a name="l00892" id="l00892"></a>00892             == NULL &amp;&amp; secLevel != SNMP_SEC_LEVEL_NOAUTH) {
<a name="l00893" id="l00893"></a>00893             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Unknown User(%s)\n"</span>, secName));
<a name="l00894" id="l00894"></a>00894             usm_free_usmStateReference(secStateRef);
<a name="l00895" id="l00895"></a>00895             <span class="keywordflow">return</span> SNMPERR_USM_UNKNOWNSECURITYNAME;
<a name="l00896" id="l00896"></a>00896         }
<a name="l00897" id="l00897"></a>00897 
<a name="l00898" id="l00898"></a>00898         theName = secName;
<a name="l00899" id="l00899"></a>00899         theNameLength = secNameLen;
<a name="l00900" id="l00900"></a>00900         theEngineID = secEngineID;
<a name="l00901" id="l00901"></a>00901         theSecLevel = secLevel;
<a name="l00902" id="l00902"></a>00902         theEngineIDLength = secEngineIDLen;
<a name="l00903" id="l00903"></a>00903         <span class="keywordflow">if</span> (user) {
<a name="l00904" id="l00904"></a>00904             theAuthProtocol = user-&gt;authProtocol;
<a name="l00905" id="l00905"></a>00905             theAuthProtocolLength = user-&gt;authProtocolLen;
<a name="l00906" id="l00906"></a>00906             theAuthKey = user-&gt;authKey;
<a name="l00907" id="l00907"></a>00907             theAuthKeyLength = user-&gt;authKeyLen;
<a name="l00908" id="l00908"></a>00908             thePrivProtocol = user-&gt;privProtocol;
<a name="l00909" id="l00909"></a>00909             thePrivProtocolLength = user-&gt;privProtocolLen;
<a name="l00910" id="l00910"></a>00910             thePrivKey = user-&gt;privKey;
<a name="l00911" id="l00911"></a>00911             thePrivKeyLength = user-&gt;privKeyLen;
<a name="l00912" id="l00912"></a>00912         } <span class="keywordflow">else</span> {
<a name="l00913" id="l00913"></a>00913             <span class="comment">/*</span>
<a name="l00914" id="l00914"></a>00914 <span class=
"comment">             * unknown users can not do authentication (obviously) </span>
<a name="l00915" id="l00915"></a>00915 <span class="comment">             */</span>
<a name="l00916" id="l00916"></a>00916             theAuthProtocol = usmNoAuthProtocol;
<a name="l00917" id="l00917"></a>00917             theAuthProtocolLength =
<a name="l00918" id="l00918"></a>00918                 <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class=
"keyword">sizeof</span>(oid);
<a name="l00919" id="l00919"></a>00919             theAuthKey = NULL;
<a name="l00920" id="l00920"></a>00920             theAuthKeyLength = 0;
<a name="l00921" id="l00921"></a>00921             thePrivProtocol = usmNoPrivProtocol;
<a name="l00922" id="l00922"></a>00922             thePrivProtocolLength =
<a name="l00923" id="l00923"></a>00923                 <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class=
"keyword">sizeof</span>(oid);
<a name="l00924" id="l00924"></a>00924             thePrivKey = NULL;
<a name="l00925" id="l00925"></a>00925             thePrivKeyLength = 0;
<a name="l00926" id="l00926"></a>00926         }
<a name="l00927" id="l00927"></a>00927     }                           <span class=
"comment">/* endif -- secStateRef==NULL */</span>
<a name="l00928" id="l00928"></a>00928 
<a name="l00929" id="l00929"></a>00929 
<a name="l00930" id="l00930"></a>00930     <span class="comment">/*</span>
<a name="l00931" id="l00931"></a>00931 <span class=
"comment">     * From here to the end of the function, avoid reference to</span>
<a name="l00932" id="l00932"></a>00932 <span class=
"comment">     * secName, secEngineID, secLevel, and associated lengths.</span>
<a name="l00933" id="l00933"></a>00933 <span class="comment">     */</span>
<a name="l00934" id="l00934"></a>00934 
<a name="l00935" id="l00935"></a>00935 
<a name="l00936" id="l00936"></a>00936     <span class="comment">/*</span>
<a name="l00937" id="l00937"></a>00937 <span class=
"comment">     * Check to see if the user can use the requested sec services.</span>
<a name="l00938" id="l00938"></a>00938 <span class="comment">     */</span>
<a name="l00939" id="l00939"></a>00939     <span class="keywordflow">if</span> (usm_check_secLevel_vs_protocols(theSecLevel,
<a name="l00940" id="l00940"></a>00940                                         theAuthProtocol,
<a name="l00941" id="l00941"></a>00941                                         theAuthProtocolLength,
<a name="l00942" id="l00942"></a>00942                                         thePrivProtocol,
<a name="l00943" id="l00943"></a>00943                                         thePrivProtocolLength) == 1) {
<a name="l00944" id="l00944"></a>00944         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Unsupported Security Level (%d)\n"</span>,
<a name="l00945" id="l00945"></a>00945                     theSecLevel));
<a name="l00946" id="l00946"></a>00946         usm_free_usmStateReference(secStateRef);
<a name="l00947" id="l00947"></a>00947         <span class="keywordflow">return</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;
<a name="l00948" id="l00948"></a>00948     }
<a name="l00949" id="l00949"></a>00949 
<a name="l00950" id="l00950"></a>00950 
<a name="l00951" id="l00951"></a>00951     <span class="comment">/*</span>
<a name="l00952" id="l00952"></a>00952 <span class="comment">     * Retrieve the engine information.</span>
<a name="l00953" id="l00953"></a>00953 <span class="comment">     *</span>
<a name="l00954" id="l00954"></a>00954 <span class=
"comment">     * XXX  No error is declared in the EoP when sending messages to</span>
<a name="l00955" id="l00955"></a>00955 <span class=
"comment">     *      unknown engines, processing continues w/ boots/time == (0,0).</span>
<a name="l00956" id="l00956"></a>00956 <span class="comment">     */</span>
<a name="l00957" id="l00957"></a>00957     <span class="keywordflow">if</span> (get_enginetime(theEngineID, theEngineIDLength,
<a name="l00958" id="l00958"></a>00958                        &amp;boots_uint, &amp;time_uint, FALSE) == -1) {
<a name="l00959" id="l00959"></a>00959         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Failed to find engine data."</span>));
<a name="l00960" id="l00960"></a>00960     }
<a name="l00961" id="l00961"></a>00961 
<a name="l00962" id="l00962"></a>00962     boots_long = boots_uint;
<a name="l00963" id="l00963"></a>00963     time_long = time_uint;
<a name="l00964" id="l00964"></a>00964 
<a name="l00965" id="l00965"></a>00965 
<a name="l00966" id="l00966"></a>00966     <span class="comment">/*</span>
<a name="l00967" id="l00967"></a>00967 <span class="comment">     * Set up the Offsets.</span>
<a name="l00968" id="l00968"></a>00968 <span class="comment">     */</span>
<a name="l00969" id="l00969"></a>00969     <span class=
"keywordflow">if</span> (usm_calc_offsets(globalDataLen, theSecLevel, theEngineIDLength,
<a name="l00970" id="l00970"></a>00970                          theNameLength, scopedPduLen, boots_long,
<a name="l00971" id="l00971"></a>00971                          time_long, &amp;theTotalLength, &amp;authParamsOffset,
<a name="l00972" id="l00972"></a>00972                          &amp;privParamsOffset, &amp;dataOffset, &amp;datalen,
<a name="l00973" id="l00973"></a>00973                          &amp;msgAuthParmLen, &amp;msgPrivParmLen, &amp;otstlen,
<a name="l00974" id="l00974"></a>00974                          &amp;seq_len, &amp;msgSecParmLen) == -1) {
<a name="l00975" id="l00975"></a>00975         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Failed calculating offsets.\n"</span>));
<a name="l00976" id="l00976"></a>00976         usm_free_usmStateReference(secStateRef);
<a name="l00977" id="l00977"></a>00977         <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l00978" id="l00978"></a>00978     }
<a name="l00979" id="l00979"></a>00979 
<a name="l00980" id="l00980"></a>00980     <span class="comment">/*</span>
<a name="l00981" id="l00981"></a>00981 <span class=
"comment">     * So, we have the offsets for the three parts that need to be</span>
<a name="l00982" id="l00982"></a>00982 <span class=
"comment">     * determined, and an overall length.  Now we need to make</span>
<a name="l00983" id="l00983"></a>00983 <span class="comment">     * sure all of this would fit in the outgoing buffer, and</span>
<a name="l00984" id="l00984"></a>00984 <span class="comment">     * whether or not we need to make a new buffer, etc.</span>
<a name="l00985" id="l00985"></a>00985 <span class="comment">     */</span>
<a name="l00986" id="l00986"></a>00986 
<a name="l00987" id="l00987"></a>00987 
<a name="l00988" id="l00988"></a>00988     <span class="comment">/*</span>
<a name="l00989" id="l00989"></a>00989 <span class=
"comment">     * Set wholeMsg as a pointer to globalData.  Sanity check for</span>
<a name="l00990" id="l00990"></a>00990 <span class="comment">     * the proper size.</span>
<a name="l00991" id="l00991"></a>00991 <span class="comment">     * </span>
<a name="l00992" id="l00992"></a>00992 <span class=
"comment">     * Mark workspace in the message with bytes of all 1's to make it</span>
<a name="l00993" id="l00993"></a>00993 <span class="comment">     * easier to find mistakes in raw message dumps.</span>
<a name="l00994" id="l00994"></a>00994 <span class="comment">     */</span>
<a name="l00995" id="l00995"></a>00995     ptr = *wholeMsg = globalData;
<a name="l00996" id="l00996"></a>00996     <span class="keywordflow">if</span> (theTotalLength &gt; *wholeMsgLen) {
<a name="l00997" id="l00997"></a>00997         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Message won't fit in buffer.\n"</span>));
<a name="l00998" id="l00998"></a>00998         usm_free_usmStateReference(secStateRef);
<a name="l00999" id="l00999"></a>00999         <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01000" id="l01000"></a>01000     }
<a name="l01001" id="l01001"></a>01001 
<a name="l01002" id="l01002"></a>01002     ptr_len = *wholeMsgLen = theTotalLength;
<a name="l01003" id="l01003"></a>01003 
<a name="l01004" id="l01004"></a>01004 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l01005" id="l01005"></a>01005     memset(&amp;ptr[globalDataLen], 0xFF, theTotalLength - globalDataLen);
<a name="l01006" id="l01006"></a>01006 <span class="preprocessor">#endif                          </span><span class=
"comment">/* NETSNMP_ENABLE_TESTING_CODE */</span>
<a name="l01007" id="l01007"></a>01007 
<a name="l01008" id="l01008"></a>01008     <span class="comment">/*</span>
<a name="l01009" id="l01009"></a>01009 <span class="comment">     * Do the encryption.</span>
<a name="l01010" id="l01010"></a>01010 <span class="comment">     */</span>
<a name="l01011" id="l01011"></a>01011     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01012" id="l01012"></a>01012         <span class=
"keywordtype">size_t</span>          encrypted_length = theTotalLength - dataOffset;
<a name="l01013" id="l01013"></a>01013         <span class=
"keywordtype">size_t</span>          salt_length = BYTESIZE(USM_MAX_SALT_LENGTH);
<a name="l01014" id="l01014"></a>01014         u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];
<a name="l01015" id="l01015"></a>01015 
<a name="l01016" id="l01016"></a>01016         <span class="comment">/*</span>
<a name="l01017" id="l01017"></a>01017 <span class="comment">         * XXX  Hardwired to seek into a 1DES private key!</span>
<a name="l01018" id="l01018"></a>01018 <span class="comment">         */</span>
<a name="l01019" id="l01019"></a>01019 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l01020" id="l01020"></a>01020         <span class="keywordflow">if</span> (ISTRANSFORM(thePrivProtocol, AESPriv)) {
<a name="l01021" id="l01021"></a>01021             <span class="keywordflow">if</span> (!thePrivKey ||
<a name="l01022" id="l01022"></a>01022                 usm_set_aes_iv(salt, &amp;salt_length,
<a name="l01023" id="l01023"></a>01023                                htonl(boots_uint), htonl(time_uint),
<a name="l01024" id="l01024"></a>01024                                &amp;ptr[privParamsOffset]) == -1) {
<a name="l01025" id="l01025"></a>01025                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Can't set AES iv.\n"</span>));
<a name="l01026" id="l01026"></a>01026                 usm_free_usmStateReference(secStateRef);
<a name="l01027" id="l01027"></a>01027                 <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01028" id="l01028"></a>01028             }
<a name="l01029" id="l01029"></a>01029         } 
<a name="l01030" id="l01030"></a>01030 <span class="preprocessor">#endif</span>
<a name="l01031" id="l01031"></a>01031 <span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l01032" id="l01032"></a>01032         <span class="keywordflow">if</span> (ISTRANSFORM(thePrivProtocol, DESPriv)) {
<a name="l01033" id="l01033"></a>01033             <span class="keywordflow">if</span> (!thePrivKey ||
<a name="l01034" id="l01034"></a>01034                 (usm_set_salt(salt, &amp;salt_length,
<a name="l01035" id="l01035"></a>01035                               thePrivKey + 8, thePrivKeyLength - 8,
<a name="l01036" id="l01036"></a>01036                               &amp;ptr[privParamsOffset])
<a name="l01037" id="l01037"></a>01037                  == -1)) {
<a name="l01038" id="l01038"></a>01038                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Can't set DES-CBC salt.\n"</span>));
<a name="l01039" id="l01039"></a>01039                 usm_free_usmStateReference(secStateRef);
<a name="l01040" id="l01040"></a>01040                 <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01041" id="l01041"></a>01041             }
<a name="l01042" id="l01042"></a>01042         }
<a name="l01043" id="l01043"></a>01043 <span class="preprocessor">#endif</span>
<a name="l01044" id="l01044"></a>01044 
<a name="l01045" id="l01045"></a>01045         <span class=
"keywordflow">if</span> (sc_encrypt(thePrivProtocol, thePrivProtocolLength,
<a name="l01046" id="l01046"></a>01046                        thePrivKey, thePrivKeyLength,
<a name="l01047" id="l01047"></a>01047                        salt, salt_length,
<a name="l01048" id="l01048"></a>01048                        scopedPdu, scopedPduLen,
<a name="l01049" id="l01049"></a>01049                        &amp;ptr[dataOffset], &amp;encrypted_length)
<a name="l01050" id="l01050"></a>01050             != SNMP_ERR_NOERROR) {
<a name="l01051" id="l01051"></a>01051             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"encryption error.\n"</span>));
<a name="l01052" id="l01052"></a>01052             usm_free_usmStateReference(secStateRef);
<a name="l01053" id="l01053"></a>01053             <span class="keywordflow">return</span> SNMPERR_USM_ENCRYPTIONERROR;
<a name="l01054" id="l01054"></a>01054         }
<a name="l01055" id="l01055"></a>01055 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l01056" id="l01056"></a>01056         <span class="keywordflow">if</span> (debug_is_token_registered(<span class=
"stringliteral">"usm/dump"</span>) == SNMPERR_SUCCESS) {
<a name="l01057" id="l01057"></a>01057             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"This data was encrypted:"</span>,
<a name="l01058" id="l01058"></a>01058                        scopedPdu, scopedPduLen);
<a name="l01059" id="l01059"></a>01059             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"salt + Encrypted form:"</span>,
<a name="l01060" id="l01060"></a>01060                        salt, salt_length);
<a name="l01061" id="l01061"></a>01061             dump_chunk(<span class="stringliteral">"usm/dump"</span>, NULL,
<a name="l01062" id="l01062"></a>01062                        &amp;ptr[dataOffset], encrypted_length);
<a name="l01063" id="l01063"></a>01063             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"*wholeMsg:"</span>,
<a name="l01064" id="l01064"></a>01064                        *wholeMsg, theTotalLength);
<a name="l01065" id="l01065"></a>01065         }
<a name="l01066" id="l01066"></a>01066 <span class="preprocessor">#endif</span>
<a name="l01067" id="l01067"></a>01067 
<a name="l01068" id="l01068"></a>01068 
<a name="l01069" id="l01069"></a>01069         ptr = *wholeMsg;
<a name="l01070" id="l01070"></a>01070         ptr_len = *wholeMsgLen = theTotalLength;
<a name="l01071" id="l01071"></a>01071 
<a name="l01072" id="l01072"></a>01072 
<a name="l01073" id="l01073"></a>01073         <span class="comment">/*</span>
<a name="l01074" id="l01074"></a>01074 <span class=
"comment">         * XXX  Sanity check for salt length should be moved up</span>
<a name="l01075" id="l01075"></a>01075 <span class="comment">         *      under usm_calc_offsets() or tossed.</span>
<a name="l01076" id="l01076"></a>01076 <span class="comment">         */</span>
<a name="l01077" id="l01077"></a>01077         <span class=
"keywordflow">if</span> ((encrypted_length != (theTotalLength - dataOffset))
<a name="l01078" id="l01078"></a>01078             || (salt_length != msgPrivParmLen)) {
<a name="l01079" id="l01079"></a>01079             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"encryption length error.\n"</span>));
<a name="l01080" id="l01080"></a>01080             usm_free_usmStateReference(secStateRef);
<a name="l01081" id="l01081"></a>01081             <span class="keywordflow">return</span> SNMPERR_USM_ENCRYPTIONERROR;
<a name="l01082" id="l01082"></a>01082         }
<a name="l01083" id="l01083"></a>01083 
<a name="l01084" id="l01084"></a>01084         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Encryption successful.\n"</span>));
<a name="l01085" id="l01085"></a>01085     }
<a name="l01086" id="l01086"></a>01086 
<a name="l01087" id="l01087"></a>01087     <span class="comment">/*</span>
<a name="l01088" id="l01088"></a>01088 <span class="comment">     * No encryption for you!</span>
<a name="l01089" id="l01089"></a>01089 <span class="comment">     */</span>
<a name="l01090" id="l01090"></a>01090     <span class="keywordflow">else</span> {
<a name="l01091" id="l01091"></a>01091         memcpy(&amp;ptr[dataOffset], scopedPdu, scopedPduLen);
<a name="l01092" id="l01092"></a>01092     }
<a name="l01093" id="l01093"></a>01093 
<a name="l01094" id="l01094"></a>01094 
<a name="l01095" id="l01095"></a>01095 
<a name="l01096" id="l01096"></a>01096     <span class="comment">/*</span>
<a name="l01097" id="l01097"></a>01097 <span class=
"comment">     * Start filling in the other fields (in prep for authentication).</span>
<a name="l01098" id="l01098"></a>01098 <span class="comment">     * </span>
<a name="l01099" id="l01099"></a>01099 <span class=
"comment">     * offSet is an octet string header, which is different from all</span>
<a name="l01100" id="l01100"></a>01100 <span class="comment">     * the other headers.</span>
<a name="l01101" id="l01101"></a>01101 <span class="comment">     */</span>
<a name="l01102" id="l01102"></a>01102     remaining = ptr_len - globalDataLen;
<a name="l01103" id="l01103"></a>01103 
<a name="l01104" id="l01104"></a>01104     offSet = ptr_len - remaining;
<a name="l01105" id="l01105"></a>01105     asn_build_header(&amp;ptr[offSet], &amp;remaining,
<a name="l01106" id="l01106"></a>01106                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01107" id="l01107"></a>01107                                ASN_OCTET_STR), otstlen);
<a name="l01108" id="l01108"></a>01108 
<a name="l01109" id="l01109"></a>01109     offSet = ptr_len - remaining;
<a name="l01110" id="l01110"></a>01110     asn_build_sequence(&amp;ptr[offSet], &amp;remaining,
<a name="l01111" id="l01111"></a>01111                        (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR), seq_len);
<a name="l01112" id="l01112"></a>01112 
<a name="l01113" id="l01113"></a>01113     offSet = ptr_len - remaining;
<a name="l01114" id="l01114"></a>01114     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineID"</span>);
<a name="l01115" id="l01115"></a>01115     asn_build_string(&amp;ptr[offSet], &amp;remaining,
<a name="l01116" id="l01116"></a>01116                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01117" id="l01117"></a>01117                                ASN_OCTET_STR), theEngineID,
<a name="l01118" id="l01118"></a>01118                      theEngineIDLength);
<a name="l01119" id="l01119"></a>01119     DEBUGINDENTLESS();
<a name="l01120" id="l01120"></a>01120 
<a name="l01121" id="l01121"></a>01121     offSet = ptr_len - remaining;
<a name="l01122" id="l01122"></a>01122     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineBoots"</span>);
<a name="l01123" id="l01123"></a>01123     asn_build_int(&amp;ptr[offSet], &amp;remaining,
<a name="l01124" id="l01124"></a>01124                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
<a name="l01125" id="l01125"></a>01125                   &amp;boots_long, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
<a name="l01126" id="l01126"></a>01126     DEBUGINDENTLESS();
<a name="l01127" id="l01127"></a>01127 
<a name="l01128" id="l01128"></a>01128     offSet = ptr_len - remaining;
<a name="l01129" id="l01129"></a>01129     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineTime"</span>);
<a name="l01130" id="l01130"></a>01130     asn_build_int(&amp;ptr[offSet], &amp;remaining,
<a name="l01131" id="l01131"></a>01131                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
<a name="l01132" id="l01132"></a>01132                   &amp;time_long, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
<a name="l01133" id="l01133"></a>01133     DEBUGINDENTLESS();
<a name="l01134" id="l01134"></a>01134 
<a name="l01135" id="l01135"></a>01135     offSet = ptr_len - remaining;
<a name="l01136" id="l01136"></a>01136     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgUserName"</span>);
<a name="l01137" id="l01137"></a>01137     asn_build_string(&amp;ptr[offSet], &amp;remaining,
<a name="l01138" id="l01138"></a>01138                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01139" id="l01139"></a>01139                                ASN_OCTET_STR), (u_char *) theName,
<a name="l01140" id="l01140"></a>01140                      theNameLength);
<a name="l01141" id="l01141"></a>01141     DEBUGINDENTLESS();
<a name="l01142" id="l01142"></a>01142 
<a name="l01143" id="l01143"></a>01143 
<a name="l01144" id="l01144"></a>01144     <span class="comment">/*</span>
<a name="l01145" id="l01145"></a>01145 <span class="comment">     * Note: if there is no authentication being done,</span>
<a name="l01146" id="l01146"></a>01146 <span class=
"comment">     * msgAuthParmLen is 0, and there is no effect (other than</span>
<a name="l01147" id="l01147"></a>01147 <span class="comment">     * inserting a zero-length header) of the following</span>
<a name="l01148" id="l01148"></a>01148 <span class="comment">     * statements.</span>
<a name="l01149" id="l01149"></a>01149 <span class="comment">     */</span>
<a name="l01150" id="l01150"></a>01150 
<a name="l01151" id="l01151"></a>01151     offSet = ptr_len - remaining;
<a name="l01152" id="l01152"></a>01152     asn_build_header(&amp;ptr[offSet],
<a name="l01153" id="l01153"></a>01153                      &amp;remaining,
<a name="l01154" id="l01154"></a>01154                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01155" id="l01155"></a>01155                                ASN_OCTET_STR), msgAuthParmLen);
<a name="l01156" id="l01156"></a>01156 
<a name="l01157" id="l01157"></a>01157     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
<a name="l01158" id="l01158"></a>01158         || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01159" id="l01159"></a>01159         offSet = ptr_len - remaining;
<a name="l01160" id="l01160"></a>01160         memset(&amp;ptr[offSet], 0, msgAuthParmLen);
<a name="l01161" id="l01161"></a>01161     }
<a name="l01162" id="l01162"></a>01162 
<a name="l01163" id="l01163"></a>01163     remaining -= msgAuthParmLen;
<a name="l01164" id="l01164"></a>01164 
<a name="l01165" id="l01165"></a>01165 
<a name="l01166" id="l01166"></a>01166     <span class="comment">/*</span>
<a name="l01167" id="l01167"></a>01167 <span class=
"comment">     * Note: if there is no encryption being done, msgPrivParmLen</span>
<a name="l01168" id="l01168"></a>01168 <span class="comment">     * is 0, and there is no effect (other than inserting a</span>
<a name="l01169" id="l01169"></a>01169 <span class="comment">     * zero-length header) of the following statements.</span>
<a name="l01170" id="l01170"></a>01170 <span class="comment">     */</span>
<a name="l01171" id="l01171"></a>01171 
<a name="l01172" id="l01172"></a>01172     offSet = ptr_len - remaining;
<a name="l01173" id="l01173"></a>01173     asn_build_header(&amp;ptr[offSet],
<a name="l01174" id="l01174"></a>01174                      &amp;remaining,
<a name="l01175" id="l01175"></a>01175                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01176" id="l01176"></a>01176                                ASN_OCTET_STR), msgPrivParmLen);
<a name="l01177" id="l01177"></a>01177 
<a name="l01178" id="l01178"></a>01178     remaining -= msgPrivParmLen;        <span class=
"comment">/* Skipping the IV already there. */</span>
<a name="l01179" id="l01179"></a>01179 
<a name="l01180" id="l01180"></a>01180 
<a name="l01181" id="l01181"></a>01181     <span class="comment">/*</span>
<a name="l01182" id="l01182"></a>01182 <span class=
"comment">     * For privacy, need to add the octet string header for it.</span>
<a name="l01183" id="l01183"></a>01183 <span class="comment">     */</span>
<a name="l01184" id="l01184"></a>01184     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01185" id="l01185"></a>01185         offSet = ptr_len - remaining;
<a name="l01186" id="l01186"></a>01186         asn_build_header(&amp;ptr[offSet],
<a name="l01187" id="l01187"></a>01187                          &amp;remaining,
<a name="l01188" id="l01188"></a>01188                          (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01189" id="l01189"></a>01189                                    ASN_OCTET_STR),
<a name="l01190" id="l01190"></a>01190                          theTotalLength - dataOffset);
<a name="l01191" id="l01191"></a>01191     }
<a name="l01192" id="l01192"></a>01192 
<a name="l01193" id="l01193"></a>01193 
<a name="l01194" id="l01194"></a>01194     <span class="comment">/*</span>
<a name="l01195" id="l01195"></a>01195 <span class=
"comment">     * Adjust overall length and store it as the first SEQ length</span>
<a name="l01196" id="l01196"></a>01196 <span class="comment">     * of the SNMPv3Message.</span>
<a name="l01197" id="l01197"></a>01197 <span class="comment">     *</span>
<a name="l01198" id="l01198"></a>01198 <span class="comment">     * FIX  4 is a magic number!</span>
<a name="l01199" id="l01199"></a>01199 <span class="comment">     */</span>
<a name="l01200" id="l01200"></a>01200     remaining = theTotalLength;
<a name="l01201" id="l01201"></a>01201     asn_build_sequence(ptr, &amp;remaining,
<a name="l01202" id="l01202"></a>01202                        (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
<a name="l01203" id="l01203"></a>01203                        theTotalLength - 4);
<a name="l01204" id="l01204"></a>01204 
<a name="l01205" id="l01205"></a>01205 
<a name="l01206" id="l01206"></a>01206     <span class="comment">/*</span>
<a name="l01207" id="l01207"></a>01207 <span class="comment">     * Now, time to consider / do authentication.</span>
<a name="l01208" id="l01208"></a>01208 <span class="comment">     */</span>
<a name="l01209" id="l01209"></a>01209     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
<a name="l01210" id="l01210"></a>01210         || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01211" id="l01211"></a>01211         <span class="keywordtype">size_t</span>          temp_sig_len = msgAuthParmLen;
<a name="l01212" id="l01212"></a>01212         u_char         *temp_sig = (u_char *) malloc(temp_sig_len);
<a name="l01213" id="l01213"></a>01213 
<a name="l01214" id="l01214"></a>01214         <span class="keywordflow">if</span> (temp_sig == NULL) {
<a name="l01215" id="l01215"></a>01215             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Out of memory.\n"</span>));
<a name="l01216" id="l01216"></a>01216             usm_free_usmStateReference(secStateRef);
<a name="l01217" id="l01217"></a>01217             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01218" id="l01218"></a>01218         }
<a name="l01219" id="l01219"></a>01219 
<a name="l01220" id="l01220"></a>01220         <span class=
"keywordflow">if</span> (sc_generate_keyed_hash(theAuthProtocol, theAuthProtocolLength,
<a name="l01221" id="l01221"></a>01221                                    theAuthKey, theAuthKeyLength,
<a name="l01222" id="l01222"></a>01222                                    ptr, ptr_len, temp_sig, &amp;temp_sig_len)
<a name="l01223" id="l01223"></a>01223             != SNMP_ERR_NOERROR) {
<a name="l01224" id="l01224"></a>01224             <span class="comment">/*</span>
<a name="l01225" id="l01225"></a>01225 <span class="comment">             * FIX temp_sig_len defined?!</span>
<a name="l01226" id="l01226"></a>01226 <span class="comment">             */</span>
<a name="l01227" id="l01227"></a>01227             <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227"
title="Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(temp_sig, temp_sig_len);
<a name="l01228" id="l01228"></a>01228             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6"
title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(temp_sig);
<a name="l01229" id="l01229"></a>01229             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Signing failed.\n"</span>));
<a name="l01230" id="l01230"></a>01230             usm_free_usmStateReference(secStateRef);
<a name="l01231" id="l01231"></a>01231             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
<a name="l01232" id="l01232"></a>01232         }
<a name="l01233" id="l01233"></a>01233 
<a name="l01234" id="l01234"></a>01234         <span class="keywordflow">if</span> (temp_sig_len != msgAuthParmLen) {
<a name="l01235" id="l01235"></a>01235             <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227"
title="Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(temp_sig, temp_sig_len);
<a name="l01236" id="l01236"></a>01236             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6"
title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(temp_sig);
<a name="l01237" id="l01237"></a>01237             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Signing lengths failed.\n"</span>));
<a name="l01238" id="l01238"></a>01238             usm_free_usmStateReference(secStateRef);
<a name="l01239" id="l01239"></a>01239             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
<a name="l01240" id="l01240"></a>01240         }
<a name="l01241" id="l01241"></a>01241 
<a name="l01242" id="l01242"></a>01242         memcpy(&amp;ptr[authParamsOffset], temp_sig, msgAuthParmLen);
<a name="l01243" id="l01243"></a>01243 
<a name="l01244" id="l01244"></a>01244         <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title=
"Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(temp_sig, temp_sig_len);
<a name="l01245" id="l01245"></a>01245         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(temp_sig);
<a name="l01246" id="l01246"></a>01246 
<a name="l01247" id="l01247"></a>01247     }
<a name="l01248" id="l01248"></a>01248 
<a name="l01249" id="l01249"></a>01249     <span class="comment">/*</span>
<a name="l01250" id="l01250"></a>01250 <span class="comment">     * endif -- create keyed hash </span>
<a name="l01251" id="l01251"></a>01251 <span class="comment">     */</span>
<a name="l01252" id="l01252"></a>01252     usm_free_usmStateReference(secStateRef);
<a name="l01253" id="l01253"></a>01253 
<a name="l01254" id="l01254"></a>01254     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"USM processing completed.\n"</span>));
<a name="l01255" id="l01255"></a>01255 
<a name="l01256" id="l01256"></a>01256     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l01257" id="l01257"></a>01257 
<a name="l01258" id="l01258"></a>01258 }                               <span class=
"comment">/* end usm_generate_out_msg() */</span>
<a name="l01259" id="l01259"></a>01259 
<a name="l01260" id="l01260"></a>01260 <span class="preprocessor">#ifdef NETSNMP_USE_REVERSE_ASNENCODING</span>
<a name="l01261" id="l01261"></a>01261 <span class="keywordtype">int</span>
<a name="l01262" id="l01262"></a>01262 usm_secmod_rgenerate_out_msg(<span class="keyword">struct</span> <a class="code" href=
"structsnmp__secmod__outgoing__params.html">snmp_secmod_outgoing_params</a> *parms)
<a name="l01263" id="l01263"></a>01263 {
<a name="l01264" id="l01264"></a>01264     <span class="keywordflow">if</span> (!parms)
<a name="l01265" id="l01265"></a>01265         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l01266" id="l01266"></a>01266 
<a name="l01267" id="l01267"></a>01267     <span class="keywordflow">return</span> usm_rgenerate_out_msg(parms-&gt;msgProcModel,
<a name="l01268" id="l01268"></a>01268                                  parms-&gt;globalData, parms-&gt;globalDataLen,
<a name="l01269" id="l01269"></a>01269                                  parms-&gt;maxMsgSize, parms-&gt;secModel,
<a name="l01270" id="l01270"></a>01270                                  parms-&gt;secEngineID, parms-&gt;secEngineIDLen,
<a name="l01271" id="l01271"></a>01271                                  parms-&gt;secName, parms-&gt;secNameLen,
<a name="l01272" id="l01272"></a>01272                                  parms-&gt;secLevel,
<a name="l01273" id="l01273"></a>01273                                  parms-&gt;scopedPdu, parms-&gt;scopedPduLen,
<a name="l01274" id="l01274"></a>01274                                  parms-&gt;secStateRef,
<a name="l01275" id="l01275"></a>01275                                  parms-&gt;wholeMsg, parms-&gt;wholeMsgLen,
<a name="l01276" id="l01276"></a>01276                                  parms-&gt;wholeMsgOffset);
<a name="l01277" id="l01277"></a>01277 }
<a name="l01278" id="l01278"></a>01278 
<a name="l01279" id="l01279"></a>01279 <span class="keywordtype">int</span>
<a name="l01280" id="l01280"></a>01280 usm_rgenerate_out_msg(<span class="keywordtype">int</span> msgProcModel, <span class=
"comment">/* (UNUSED) */</span>
<a name="l01281" id="l01281"></a>01281                       u_char * globalData,      <span class="comment">/* IN */</span>
<a name="l01282" id="l01282"></a>01282                       <span class="comment">/*</span>
<a name="l01283" id="l01283"></a>01283 <span class=
"comment">                       * points at the msgGlobalData, which is of length given by next </span>
<a name="l01284" id="l01284"></a>01284 <span class="comment">                       * parameter.  </span>
<a name="l01285" id="l01285"></a>01285 <span class="comment">                       */</span>
<a name="l01286" id="l01286"></a>01286                       <span class=
"keywordtype">size_t</span> globalDataLen,     <span class="comment">/* IN - Length of msg header data.      */</span>
<a name="l01287" id="l01287"></a>01287                       <span class="keywordtype">int</span> maxMsgSize,   <span class=
"comment">/* (UNUSED) */</span>
<a name="l01288" id="l01288"></a>01288                       <span class="keywordtype">int</span> secModel,     <span class=
"comment">/* (UNUSED) */</span>
<a name="l01289" id="l01289"></a>01289                       u_char * secEngineID,     <span class=
"comment">/* IN - Pointer snmpEngineID.           */</span>
<a name="l01290" id="l01290"></a>01290                       <span class=
"keywordtype">size_t</span> secEngineIDLen,    <span class="comment">/* IN - SnmpEngineID length.            */</span>
<a name="l01291" id="l01291"></a>01291                       <span class="keywordtype">char</span> *secName,    <span class=
"comment">/* IN - Pointer to securityName.        */</span>
<a name="l01292" id="l01292"></a>01292                       <span class=
"keywordtype">size_t</span> secNameLen,        <span class="comment">/* IN - SecurityName length.            */</span>
<a name="l01293" id="l01293"></a>01293                       <span class="keywordtype">int</span> secLevel,     <span class=
"comment">/* IN - AuthNoPriv, authPriv etc.       */</span>
<a name="l01294" id="l01294"></a>01294                       u_char * scopedPdu,       <span class="comment">/* IN */</span>
<a name="l01295" id="l01295"></a>01295                       <span class="comment">/*</span>
<a name="l01296" id="l01296"></a>01296 <span class=
"comment">                       * Pointer to scopedPdu will be encrypted by USM if needed</span>
<a name="l01297" id="l01297"></a>01297 <span class=
"comment">                       * * and written to packet buffer immediately following</span>
<a name="l01298" id="l01298"></a>01298 <span class=
"comment">                       * * securityParameters, entire msg will be authenticated by</span>
<a name="l01299" id="l01299"></a>01299 <span class="comment">                       * * USM if needed.</span>
<a name="l01300" id="l01300"></a>01300 <span class="comment">                       */</span>
<a name="l01301" id="l01301"></a>01301                       <span class=
"keywordtype">size_t</span> scopedPduLen,      <span class="comment">/* IN - scopedPdu length. */</span>
<a name="l01302" id="l01302"></a>01302                       <span class=
"keywordtype">void</span> *secStateRef,        <span class="comment">/* IN */</span>
<a name="l01303" id="l01303"></a>01303                       <span class="comment">/*</span>
<a name="l01304" id="l01304"></a>01304 <span class=
"comment">                       * secStateRef, pointer to cached info provided only for</span>
<a name="l01305" id="l01305"></a>01305 <span class="comment">                       * * Response, otherwise NULL.</span>
<a name="l01306" id="l01306"></a>01306 <span class="comment">                       */</span>
<a name="l01307" id="l01307"></a>01307                       u_char ** wholeMsg,       <span class=
"comment">/*  IN/OUT  */</span>
<a name="l01308" id="l01308"></a>01308                       <span class="comment">/*</span>
<a name="l01309" id="l01309"></a>01309 <span class=
"comment">                       * Points at the pointer to the packet buffer, which might get extended</span>
<a name="l01310" id="l01310"></a>01310 <span class="comment">                       * if necessary via realloc().  </span>
<a name="l01311" id="l01311"></a>01311 <span class="comment">                       */</span>
<a name="l01312" id="l01312"></a>01312                       <span class=
"keywordtype">size_t</span> * wholeMsgLen,     <span class="comment">/*  IN/OUT  */</span>
<a name="l01313" id="l01313"></a>01313                       <span class="comment">/*</span>
<a name="l01314" id="l01314"></a>01314 <span class=
"comment">                       * Length of the entire packet buffer, **not** the length of the</span>
<a name="l01315" id="l01315"></a>01315 <span class="comment">                       * packet.  </span>
<a name="l01316" id="l01316"></a>01316 <span class="comment">                       */</span>
<a name="l01317" id="l01317"></a>01317                       <span class="keywordtype">size_t</span> * offset   <span class=
"comment">/*  IN/OUT  */</span>
<a name="l01318" id="l01318"></a>01318                       <span class="comment">/*</span>
<a name="l01319" id="l01319"></a>01319 <span class=
"comment">                       * Offset from the end of the packet buffer to the start of the packet,</span>
<a name="l01320" id="l01320"></a>01320 <span class="comment">                       * also known as the packet length.  </span>
<a name="l01321" id="l01321"></a>01321 <span class="comment">                       */</span>
<a name="l01322" id="l01322"></a>01322     )
<a name="l01323" id="l01323"></a>01323 {
<a name="l01324" id="l01324"></a>01324     <span class="keywordtype">size_t</span>          msgAuthParmLen = 0;
<a name="l01325" id="l01325"></a>01325 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l01326" id="l01326"></a>01326     <span class="keywordtype">size_t</span>          theTotalLength;
<a name="l01327" id="l01327"></a>01327 <span class="preprocessor">#endif</span>
<a name="l01328" id="l01328"></a>01328 
<a name="l01329" id="l01329"></a>01329     u_int           boots_uint;
<a name="l01330" id="l01330"></a>01330     u_int           time_uint;
<a name="l01331" id="l01331"></a>01331     <span class="keywordtype">long</span>            boots_long;
<a name="l01332" id="l01332"></a>01332     <span class="keywordtype">long</span>            time_long;
<a name="l01333" id="l01333"></a>01333 
<a name="l01334" id="l01334"></a>01334     <span class="comment">/*</span>
<a name="l01335" id="l01335"></a>01335 <span class=
"comment">     * Indirection because secStateRef values override parameters.</span>
<a name="l01336" id="l01336"></a>01336 <span class="comment">     * </span>
<a name="l01337" id="l01337"></a>01337 <span class=
"comment">     * None of these are to be free'd - they are either pointing to</span>
<a name="l01338" id="l01338"></a>01338 <span class=
"comment">     * what's in the secStateRef or to something either in the</span>
<a name="l01339" id="l01339"></a>01339 <span class="comment">     * actual parameter list or the user list.</span>
<a name="l01340" id="l01340"></a>01340 <span class="comment">     */</span>
<a name="l01341" id="l01341"></a>01341 
<a name="l01342" id="l01342"></a>01342     <span class="keywordtype">char</span>           *theName = NULL;
<a name="l01343" id="l01343"></a>01343     u_int           theNameLength = 0;
<a name="l01344" id="l01344"></a>01344     u_char         *theEngineID = NULL;
<a name="l01345" id="l01345"></a>01345     u_int           theEngineIDLength = 0;
<a name="l01346" id="l01346"></a>01346     u_char         *theAuthKey = NULL;
<a name="l01347" id="l01347"></a>01347     u_int           theAuthKeyLength = 0;
<a name="l01348" id="l01348"></a>01348     <span class="keyword">const</span> oid      *theAuthProtocol = NULL;
<a name="l01349" id="l01349"></a>01349     u_int           theAuthProtocolLength = 0;
<a name="l01350" id="l01350"></a>01350     u_char         *thePrivKey = NULL;
<a name="l01351" id="l01351"></a>01351     u_int           thePrivKeyLength = 0;
<a name="l01352" id="l01352"></a>01352     <span class="keyword">const</span> oid      *thePrivProtocol = NULL;
<a name="l01353" id="l01353"></a>01353     u_int           thePrivProtocolLength = 0;
<a name="l01354" id="l01354"></a>01354     <span class="keywordtype">int</span>             theSecLevel = 0;    <span class=
"comment">/* No defined const for bad</span>
<a name="l01355" id="l01355"></a>01355 <span class=
"comment">                                         * value (other then err). */</span>
<a name="l01356" id="l01356"></a>01356     <span class=
"keywordtype">size_t</span>          salt_length = 0, save_salt_length = 0, save_salt_offset = 0;
<a name="l01357" id="l01357"></a>01357     u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];
<a name="l01358" id="l01358"></a>01358     u_char          authParams[USM_MAX_AUTHSIZE];
<a name="l01359" id="l01359"></a>01359     u_char          iv[BYTESIZE(USM_MAX_SALT_LENGTH)];
<a name="l01360" id="l01360"></a>01360     <span class="keywordtype">size_t</span>          sp_offset = 0, mac_offset = 0;
<a name="l01361" id="l01361"></a>01361     <span class="keywordtype">int</span>             rc = 0;
<a name="l01362" id="l01362"></a>01362 
<a name="l01363" id="l01363"></a>01363     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"USM processing has begun (offset %d)\n"</span>, (<span class="keywordtype">int</span>)*offset));
<a name="l01364" id="l01364"></a>01364 
<a name="l01365" id="l01365"></a>01365     <span class="keywordflow">if</span> (secStateRef != NULL) {
<a name="l01366" id="l01366"></a>01366         <span class="comment">/*</span>
<a name="l01367" id="l01367"></a>01367 <span class="comment">         * To hush the compiler for now.  XXX </span>
<a name="l01368" id="l01368"></a>01368 <span class="comment">         */</span>
<a name="l01369" id="l01369"></a>01369         <span class="keyword">struct </span><a class="code" href=
"structusmStateReference.html">usmStateReference</a> *ref
<a name="l01370" id="l01370"></a>01370             = (<span class="keyword">struct </span><a class="code" href=
"structusmStateReference.html">usmStateReference</a> *) secStateRef;
<a name="l01371" id="l01371"></a>01371 
<a name="l01372" id="l01372"></a>01372         theName = ref-&gt;usr_name;
<a name="l01373" id="l01373"></a>01373         theNameLength = ref-&gt;usr_name_length;
<a name="l01374" id="l01374"></a>01374         theEngineID = ref-&gt;usr_engine_id;
<a name="l01375" id="l01375"></a>01375         theEngineIDLength = ref-&gt;usr_engine_id_length;
<a name="l01376" id="l01376"></a>01376 
<a name="l01377" id="l01377"></a>01377         <span class="keywordflow">if</span> (!theEngineIDLength) {
<a name="l01378" id="l01378"></a>01378             theEngineID = secEngineID;
<a name="l01379" id="l01379"></a>01379             theEngineIDLength = secEngineIDLen;
<a name="l01380" id="l01380"></a>01380         }
<a name="l01381" id="l01381"></a>01381 
<a name="l01382" id="l01382"></a>01382         theAuthProtocol = ref-&gt;usr_auth_protocol;
<a name="l01383" id="l01383"></a>01383         theAuthProtocolLength = ref-&gt;usr_auth_protocol_length;
<a name="l01384" id="l01384"></a>01384         theAuthKey = ref-&gt;usr_auth_key;
<a name="l01385" id="l01385"></a>01385         theAuthKeyLength = ref-&gt;usr_auth_key_length;
<a name="l01386" id="l01386"></a>01386         thePrivProtocol = ref-&gt;usr_priv_protocol;
<a name="l01387" id="l01387"></a>01387         thePrivProtocolLength = ref-&gt;usr_priv_protocol_length;
<a name="l01388" id="l01388"></a>01388         thePrivKey = ref-&gt;usr_priv_key;
<a name="l01389" id="l01389"></a>01389         thePrivKeyLength = ref-&gt;usr_priv_key_length;
<a name="l01390" id="l01390"></a>01390         theSecLevel = ref-&gt;usr_sec_level;
<a name="l01391" id="l01391"></a>01391     }
<a name="l01392" id="l01392"></a>01392 
<a name="l01393" id="l01393"></a>01393     <span class="comment">/*</span>
<a name="l01394" id="l01394"></a>01394 <span class="comment">     * * Identify the user record.</span>
<a name="l01395" id="l01395"></a>01395 <span class="comment">     */</span>
<a name="l01396" id="l01396"></a>01396     <span class="keywordflow">else</span> {
<a name="l01397" id="l01397"></a>01397         <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *user;
<a name="l01398" id="l01398"></a>01398 
<a name="l01399" id="l01399"></a>01399         <span class="comment">/*</span>
<a name="l01400" id="l01400"></a>01400 <span class="comment">         * we do allow an unknown user name for</span>
<a name="l01401" id="l01401"></a>01401 <span class="comment">         * unauthenticated requests. </span>
<a name="l01402" id="l01402"></a>01402 <span class="comment">         */</span>
<a name="l01403" id="l01403"></a>01403         <span class=
"keywordflow">if</span> ((user = usm_get_user(secEngineID, secEngineIDLen, secName))
<a name="l01404" id="l01404"></a>01404             == NULL &amp;&amp; secLevel != SNMP_SEC_LEVEL_NOAUTH) {
<a name="l01405" id="l01405"></a>01405             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Unknown User\n"</span>));
<a name="l01406" id="l01406"></a>01406             usm_free_usmStateReference(secStateRef);
<a name="l01407" id="l01407"></a>01407             <span class="keywordflow">return</span> SNMPERR_USM_UNKNOWNSECURITYNAME;
<a name="l01408" id="l01408"></a>01408         }
<a name="l01409" id="l01409"></a>01409 
<a name="l01410" id="l01410"></a>01410         theName = secName;
<a name="l01411" id="l01411"></a>01411         theNameLength = secNameLen;
<a name="l01412" id="l01412"></a>01412         theEngineID = secEngineID;
<a name="l01413" id="l01413"></a>01413         theSecLevel = secLevel;
<a name="l01414" id="l01414"></a>01414         theEngineIDLength = secEngineIDLen;
<a name="l01415" id="l01415"></a>01415         <span class="keywordflow">if</span> (user) {
<a name="l01416" id="l01416"></a>01416             theAuthProtocol = user-&gt;authProtocol;
<a name="l01417" id="l01417"></a>01417             theAuthProtocolLength = user-&gt;authProtocolLen;
<a name="l01418" id="l01418"></a>01418             theAuthKey = user-&gt;authKey;
<a name="l01419" id="l01419"></a>01419             theAuthKeyLength = user-&gt;authKeyLen;
<a name="l01420" id="l01420"></a>01420             thePrivProtocol = user-&gt;privProtocol;
<a name="l01421" id="l01421"></a>01421             thePrivProtocolLength = user-&gt;privProtocolLen;
<a name="l01422" id="l01422"></a>01422             thePrivKey = user-&gt;privKey;
<a name="l01423" id="l01423"></a>01423             thePrivKeyLength = user-&gt;privKeyLen;
<a name="l01424" id="l01424"></a>01424         } <span class="keywordflow">else</span> {
<a name="l01425" id="l01425"></a>01425             <span class="comment">/*</span>
<a name="l01426" id="l01426"></a>01426 <span class=
"comment">             * unknown users can not do authentication (obviously) </span>
<a name="l01427" id="l01427"></a>01427 <span class="comment">             */</span>
<a name="l01428" id="l01428"></a>01428             theAuthProtocol = usmNoAuthProtocol;
<a name="l01429" id="l01429"></a>01429             theAuthProtocolLength =
<a name="l01430" id="l01430"></a>01430                 <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class=
"keyword">sizeof</span>(oid);
<a name="l01431" id="l01431"></a>01431             theAuthKey = NULL;
<a name="l01432" id="l01432"></a>01432             theAuthKeyLength = 0;
<a name="l01433" id="l01433"></a>01433             thePrivProtocol = usmNoPrivProtocol;
<a name="l01434" id="l01434"></a>01434             thePrivProtocolLength =
<a name="l01435" id="l01435"></a>01435                 <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class=
"keyword">sizeof</span>(oid);
<a name="l01436" id="l01436"></a>01436             thePrivKey = NULL;
<a name="l01437" id="l01437"></a>01437             thePrivKeyLength = 0;
<a name="l01438" id="l01438"></a>01438         }
<a name="l01439" id="l01439"></a>01439     }                           <span class=
"comment">/* endif -- secStateRef==NULL */</span>
<a name="l01440" id="l01440"></a>01440 
<a name="l01441" id="l01441"></a>01441 
<a name="l01442" id="l01442"></a>01442     <span class="comment">/*</span>
<a name="l01443" id="l01443"></a>01443 <span class=
"comment">     * From here to the end of the function, avoid reference to</span>
<a name="l01444" id="l01444"></a>01444 <span class=
"comment">     * secName, secEngineID, secLevel, and associated lengths.</span>
<a name="l01445" id="l01445"></a>01445 <span class="comment">     */</span>
<a name="l01446" id="l01446"></a>01446 
<a name="l01447" id="l01447"></a>01447 
<a name="l01448" id="l01448"></a>01448     <span class="comment">/*</span>
<a name="l01449" id="l01449"></a>01449 <span class=
"comment">     * Check to see if the user can use the requested sec services.</span>
<a name="l01450" id="l01450"></a>01450 <span class="comment">     */</span>
<a name="l01451" id="l01451"></a>01451     <span class="keywordflow">if</span> (usm_check_secLevel_vs_protocols(theSecLevel,
<a name="l01452" id="l01452"></a>01452                                         theAuthProtocol,
<a name="l01453" id="l01453"></a>01453                                         theAuthProtocolLength,
<a name="l01454" id="l01454"></a>01454                                         thePrivProtocol,
<a name="l01455" id="l01455"></a>01455                                         thePrivProtocolLength) == 1) {
<a name="l01456" id="l01456"></a>01456         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Unsupported Security Level or type (%d)\n"</span>,
<a name="l01457" id="l01457"></a>01457                     theSecLevel));
<a name="l01458" id="l01458"></a>01458 
<a name="l01459" id="l01459"></a>01459         usm_free_usmStateReference(secStateRef);
<a name="l01460" id="l01460"></a>01460         <span class="keywordflow">return</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;
<a name="l01461" id="l01461"></a>01461     }
<a name="l01462" id="l01462"></a>01462 
<a name="l01463" id="l01463"></a>01463 
<a name="l01464" id="l01464"></a>01464     <span class="comment">/*</span>
<a name="l01465" id="l01465"></a>01465 <span class="comment">     * * Retrieve the engine information.</span>
<a name="l01466" id="l01466"></a>01466 <span class="comment">     * *</span>
<a name="l01467" id="l01467"></a>01467 <span class=
"comment">     * * XXX    No error is declared in the EoP when sending messages to</span>
<a name="l01468" id="l01468"></a>01468 <span class=
"comment">     * *        unknown engines, processing continues w/ boots/time == (0,0).</span>
<a name="l01469" id="l01469"></a>01469 <span class="comment">     */</span>
<a name="l01470" id="l01470"></a>01470     <span class="keywordflow">if</span> (get_enginetime(theEngineID, theEngineIDLength,
<a name="l01471" id="l01471"></a>01471                        &amp;boots_uint, &amp;time_uint, FALSE) == -1) {
<a name="l01472" id="l01472"></a>01472         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Failed to find engine data."</span>));
<a name="l01473" id="l01473"></a>01473     }
<a name="l01474" id="l01474"></a>01474 
<a name="l01475" id="l01475"></a>01475     boots_long = boots_uint;
<a name="l01476" id="l01476"></a>01476     time_long = time_uint;
<a name="l01477" id="l01477"></a>01477 
<a name="l01478" id="l01478"></a>01478     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01479" id="l01479"></a>01479         <span class="comment">/*</span>
<a name="l01480" id="l01480"></a>01480 <span class=
"comment">         * Initially assume that the ciphertext will end up the same size as</span>
<a name="l01481" id="l01481"></a>01481 <span class=
"comment">         * the plaintext plus some padding.  Really sc_encrypt ought to be able</span>
<a name="l01482" id="l01482"></a>01482 <span class=
"comment">         * to grow this for us, a la asn_realloc_rbuild_&lt;type&gt; functions, but</span>
<a name="l01483" id="l01483"></a>01483 <span class="comment">         * this will do for now.  </span>
<a name="l01484" id="l01484"></a>01484 <span class="comment">         */</span>
<a name="l01485" id="l01485"></a>01485         u_char         *ciphertext = NULL;
<a name="l01486" id="l01486"></a>01486         <span class=
"keywordtype">size_t</span>          ciphertextlen = scopedPduLen + 64;
<a name="l01487" id="l01487"></a>01487 
<a name="l01488" id="l01488"></a>01488         <span class=
"keywordflow">if</span> ((ciphertext = (u_char *) malloc(ciphertextlen)) == NULL) {
<a name="l01489" id="l01489"></a>01489             DEBUGMSGTL((<span class="stringliteral">"usm"</span>,
<a name="l01490" id="l01490"></a>01490                         <span class=
"stringliteral">"couldn't malloc %d bytes for encrypted PDU\n"</span>,
<a name="l01491" id="l01491"></a>01491                         (<span class="keywordtype">int</span>)ciphertextlen));
<a name="l01492" id="l01492"></a>01492             usm_free_usmStateReference(secStateRef);
<a name="l01493" id="l01493"></a>01493             <span class="keywordflow">return</span> SNMPERR_MALLOC;
<a name="l01494" id="l01494"></a>01494         }
<a name="l01495" id="l01495"></a>01495 
<a name="l01496" id="l01496"></a>01496         <span class="comment">/*</span>
<a name="l01497" id="l01497"></a>01497 <span class="comment">         * XXX Hardwired to seek into a 1DES private key!  </span>
<a name="l01498" id="l01498"></a>01498 <span class="comment">         */</span>
<a name="l01499" id="l01499"></a>01499 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l01500" id="l01500"></a>01500         <span class="keywordflow">if</span> (ISTRANSFORM(thePrivProtocol, AESPriv)) {
<a name="l01501" id="l01501"></a>01501             salt_length = BYTESIZE(USM_AES_SALT_LENGTH);
<a name="l01502" id="l01502"></a>01502             save_salt_length = BYTESIZE(USM_AES_SALT_LENGTH)/2;
<a name="l01503" id="l01503"></a>01503             save_salt_offset = 0;
<a name="l01504" id="l01504"></a>01504             <span class="keywordflow">if</span> (!thePrivKey ||
<a name="l01505" id="l01505"></a>01505                 usm_set_aes_iv(salt, &amp;salt_length,
<a name="l01506" id="l01506"></a>01506                                htonl(boots_uint), htonl(time_uint),
<a name="l01507" id="l01507"></a>01507                                iv) == -1) {
<a name="l01508" id="l01508"></a>01508                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Can't set AES iv.\n"</span>));
<a name="l01509" id="l01509"></a>01509                 usm_free_usmStateReference(secStateRef);
<a name="l01510" id="l01510"></a>01510                 <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6"
title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(ciphertext);
<a name="l01511" id="l01511"></a>01511                 <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01512" id="l01512"></a>01512             }
<a name="l01513" id="l01513"></a>01513         } 
<a name="l01514" id="l01514"></a>01514 <span class="preprocessor">#endif</span>
<a name="l01515" id="l01515"></a>01515 <span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l01516" id="l01516"></a>01516         <span class="keywordflow">if</span> (ISTRANSFORM(thePrivProtocol, DESPriv)) {
<a name="l01517" id="l01517"></a>01517             salt_length = BYTESIZE(USM_DES_SALT_LENGTH);
<a name="l01518" id="l01518"></a>01518             save_salt_length = BYTESIZE(USM_DES_SALT_LENGTH);
<a name="l01519" id="l01519"></a>01519             save_salt_offset = 0;
<a name="l01520" id="l01520"></a>01520             <span class=
"keywordflow">if</span> (!thePrivKey || (usm_set_salt(salt, &amp;salt_length,
<a name="l01521" id="l01521"></a>01521                                              thePrivKey + 8,
<a name="l01522" id="l01522"></a>01522                                              thePrivKeyLength - 8,
<a name="l01523" id="l01523"></a>01523                                              iv) == -1)) {
<a name="l01524" id="l01524"></a>01524                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Can't set DES-CBC salt.\n"</span>));
<a name="l01525" id="l01525"></a>01525                 usm_free_usmStateReference(secStateRef);
<a name="l01526" id="l01526"></a>01526                 <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6"
title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(ciphertext);
<a name="l01527" id="l01527"></a>01527                 <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01528" id="l01528"></a>01528             }
<a name="l01529" id="l01529"></a>01529         }
<a name="l01530" id="l01530"></a>01530 <span class="preprocessor">#endif</span>
<a name="l01531" id="l01531"></a>01531 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l01532" id="l01532"></a>01532         <span class="keywordflow">if</span> (debug_is_token_registered(<span class=
"stringliteral">"usm/dump"</span>) == SNMPERR_SUCCESS) {
<a name="l01533" id="l01533"></a>01533             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"This data was encrypted:"</span>,
<a name="l01534" id="l01534"></a>01534                        scopedPdu, scopedPduLen);
<a name="l01535" id="l01535"></a>01535         }
<a name="l01536" id="l01536"></a>01536 <span class="preprocessor">#endif</span>
<a name="l01537" id="l01537"></a>01537 
<a name="l01538" id="l01538"></a>01538         <span class=
"keywordflow">if</span> (sc_encrypt(thePrivProtocol, thePrivProtocolLength,
<a name="l01539" id="l01539"></a>01539                        thePrivKey, thePrivKeyLength,
<a name="l01540" id="l01540"></a>01540                        salt, salt_length,
<a name="l01541" id="l01541"></a>01541                        scopedPdu, scopedPduLen,
<a name="l01542" id="l01542"></a>01542                        ciphertext, &amp;ciphertextlen) != SNMP_ERR_NOERROR) {
<a name="l01543" id="l01543"></a>01543             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"encryption error.\n"</span>));
<a name="l01544" id="l01544"></a>01544             usm_free_usmStateReference(secStateRef);
<a name="l01545" id="l01545"></a>01545             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6"
title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(ciphertext);
<a name="l01546" id="l01546"></a>01546             <span class="keywordflow">return</span> SNMPERR_USM_ENCRYPTIONERROR;
<a name="l01547" id="l01547"></a>01547         }
<a name="l01548" id="l01548"></a>01548 
<a name="l01549" id="l01549"></a>01549         <span class="comment">/*</span>
<a name="l01550" id="l01550"></a>01550 <span class=
"comment">         * Write the encrypted scopedPdu back into the packet buffer.  </span>
<a name="l01551" id="l01551"></a>01551 <span class="comment">         */</span>
<a name="l01552" id="l01552"></a>01552 
<a name="l01553" id="l01553"></a>01553 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l01554" id="l01554"></a>01554         theTotalLength = *wholeMsgLen;
<a name="l01555" id="l01555"></a>01555 <span class="preprocessor">#endif</span>
<a name="l01556" id="l01556"></a>01556         *offset = 0;
<a name="l01557" id="l01557"></a>01557         rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01558" id="l01558"></a>01558                                        (u_char) (ASN_UNIVERSAL |
<a name="l01559" id="l01559"></a>01559                                                  ASN_PRIMITIVE |
<a name="l01560" id="l01560"></a>01560                                                  ASN_OCTET_STR),
<a name="l01561" id="l01561"></a>01561                                        ciphertext, ciphertextlen);
<a name="l01562" id="l01562"></a>01562         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01563" id="l01563"></a>01563             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Encryption failed.\n"</span>));
<a name="l01564" id="l01564"></a>01564             usm_free_usmStateReference(secStateRef);
<a name="l01565" id="l01565"></a>01565             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6"
title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(ciphertext);
<a name="l01566" id="l01566"></a>01566             <span class="keywordflow">return</span> SNMPERR_USM_ENCRYPTIONERROR;
<a name="l01567" id="l01567"></a>01567         }
<a name="l01568" id="l01568"></a>01568 
<a name="l01569" id="l01569"></a>01569 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l01570" id="l01570"></a>01570         <span class="keywordflow">if</span> (debug_is_token_registered(<span class=
"stringliteral">"usm/dump"</span>) == SNMPERR_SUCCESS) {
<a name="l01571" id="l01571"></a>01571             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"salt + Encrypted form: "</span>, salt,
<a name="l01572" id="l01572"></a>01572                        salt_length);
<a name="l01573" id="l01573"></a>01573             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"wholeMsg:"</span>,
<a name="l01574" id="l01574"></a>01574                        (*wholeMsg + *wholeMsgLen - *offset), *offset);
<a name="l01575" id="l01575"></a>01575         }
<a name="l01576" id="l01576"></a>01576 <span class="preprocessor">#endif</span>
<a name="l01577" id="l01577"></a>01577 
<a name="l01578" id="l01578"></a>01578         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Encryption successful.\n"</span>));
<a name="l01579" id="l01579"></a>01579         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(ciphertext);
<a name="l01580" id="l01580"></a>01580     } <span class="keywordflow">else</span> {
<a name="l01581" id="l01581"></a>01581         <span class="comment">/*</span>
<a name="l01582" id="l01582"></a>01582 <span class="comment">         * theSecLevel != SNMP_SEC_LEVEL_AUTHPRIV  </span>
<a name="l01583" id="l01583"></a>01583 <span class="comment">         */</span>
<a name="l01584" id="l01584"></a>01584     }
<a name="l01585" id="l01585"></a>01585 
<a name="l01586" id="l01586"></a>01586     <span class="comment">/*</span>
<a name="l01587" id="l01587"></a>01587 <span class="comment">     * Start encoding the msgSecurityParameters.  </span>
<a name="l01588" id="l01588"></a>01588 <span class="comment">     */</span>
<a name="l01589" id="l01589"></a>01589 
<a name="l01590" id="l01590"></a>01590     sp_offset = *offset;
<a name="l01591" id="l01591"></a>01591 
<a name="l01592" id="l01592"></a>01592     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgPrivacyParameters"</span>);
<a name="l01593" id="l01593"></a>01593     <span class="comment">/*</span>
<a name="l01594" id="l01594"></a>01594 <span class="comment">     * msgPrivacyParameters (warning: assumes DES salt).  </span>
<a name="l01595" id="l01595"></a>01595 <span class="comment">     */</span>
<a name="l01596" id="l01596"></a>01596     rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01597" id="l01597"></a>01597                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
<a name="l01598" id="l01598"></a>01598                                              | ASN_OCTET_STR),
<a name="l01599" id="l01599"></a>01599                                    iv,
<a name="l01600" id="l01600"></a>01600                                    save_salt_length);
<a name="l01601" id="l01601"></a>01601     DEBUGINDENTLESS();
<a name="l01602" id="l01602"></a>01602     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01603" id="l01603"></a>01603         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building privParams failed.\n"</span>));
<a name="l01604" id="l01604"></a>01604         usm_free_usmStateReference(secStateRef);
<a name="l01605" id="l01605"></a>01605         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01606" id="l01606"></a>01606     }
<a name="l01607" id="l01607"></a>01607 
<a name="l01608" id="l01608"></a>01608     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthenticationParameters"</span>);
<a name="l01609" id="l01609"></a>01609     <span class="comment">/*</span>
<a name="l01610" id="l01610"></a>01610 <span class=
"comment">     * msgAuthenticationParameters (warnings assumes 0x00 by 12).  </span>
<a name="l01611" id="l01611"></a>01611 <span class="comment">     */</span>
<a name="l01612" id="l01612"></a>01612     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
<a name="l01613" id="l01613"></a>01613         || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01614" id="l01614"></a>01614         memset(authParams, 0, USM_MD5_AND_SHA_AUTH_LEN);
<a name="l01615" id="l01615"></a>01615         msgAuthParmLen = USM_MD5_AND_SHA_AUTH_LEN;
<a name="l01616" id="l01616"></a>01616     }
<a name="l01617" id="l01617"></a>01617 
<a name="l01618" id="l01618"></a>01618     rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01619" id="l01619"></a>01619                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
<a name="l01620" id="l01620"></a>01620                                              | ASN_OCTET_STR), authParams,
<a name="l01621" id="l01621"></a>01621                                    msgAuthParmLen);
<a name="l01622" id="l01622"></a>01622     DEBUGINDENTLESS();
<a name="l01623" id="l01623"></a>01623     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01624" id="l01624"></a>01624         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building authParams failed.\n"</span>));
<a name="l01625" id="l01625"></a>01625         usm_free_usmStateReference(secStateRef);
<a name="l01626" id="l01626"></a>01626         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01627" id="l01627"></a>01627     }
<a name="l01628" id="l01628"></a>01628 
<a name="l01629" id="l01629"></a>01629     <span class="comment">/*</span>
<a name="l01630" id="l01630"></a>01630 <span class=
"comment">     * Remember where to put the actual HMAC we calculate later on.  An</span>
<a name="l01631" id="l01631"></a>01631 <span class=
"comment">     * encoded OCTET STRING of length USM_MD5_AND_SHA_AUTH_LEN has an ASN.1</span>
<a name="l01632" id="l01632"></a>01632 <span class="comment">     * header of length 2, hence the fudge factor.  </span>
<a name="l01633" id="l01633"></a>01633 <span class="comment">     */</span>
<a name="l01634" id="l01634"></a>01634 
<a name="l01635" id="l01635"></a>01635     mac_offset = *offset - 2;
<a name="l01636" id="l01636"></a>01636 
<a name="l01637" id="l01637"></a>01637     <span class="comment">/*</span>
<a name="l01638" id="l01638"></a>01638 <span class="comment">     * msgUserName.  </span>
<a name="l01639" id="l01639"></a>01639 <span class="comment">     */</span>
<a name="l01640" id="l01640"></a>01640     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgUserName"</span>);
<a name="l01641" id="l01641"></a>01641     rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01642" id="l01642"></a>01642                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
<a name="l01643" id="l01643"></a>01643                                              | ASN_OCTET_STR),
<a name="l01644" id="l01644"></a>01644                                    (u_char *) theName, theNameLength);
<a name="l01645" id="l01645"></a>01645     DEBUGINDENTLESS();
<a name="l01646" id="l01646"></a>01646     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01647" id="l01647"></a>01647         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building authParams failed.\n"</span>));
<a name="l01648" id="l01648"></a>01648         usm_free_usmStateReference(secStateRef);
<a name="l01649" id="l01649"></a>01649         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01650" id="l01650"></a>01650     }
<a name="l01651" id="l01651"></a>01651 
<a name="l01652" id="l01652"></a>01652     <span class="comment">/*</span>
<a name="l01653" id="l01653"></a>01653 <span class="comment">     * msgAuthoritativeEngineTime.  </span>
<a name="l01654" id="l01654"></a>01654 <span class="comment">     */</span>
<a name="l01655" id="l01655"></a>01655     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineTime"</span>);
<a name="l01656" id="l01656"></a>01656     rc = asn_realloc_rbuild_int(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01657" id="l01657"></a>01657                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01658" id="l01658"></a>01658                                           ASN_INTEGER), &amp;time_long,
<a name="l01659" id="l01659"></a>01659                                 <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
<a name="l01660" id="l01660"></a>01660     DEBUGINDENTLESS();
<a name="l01661" id="l01661"></a>01661     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01662" id="l01662"></a>01662         DEBUGMSGTL((<span class="stringliteral">"usm"</span>,
<a name="l01663" id="l01663"></a>01663                     <span class=
"stringliteral">"building msgAuthoritativeEngineTime failed.\n"</span>));
<a name="l01664" id="l01664"></a>01664         usm_free_usmStateReference(secStateRef);
<a name="l01665" id="l01665"></a>01665         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01666" id="l01666"></a>01666     }
<a name="l01667" id="l01667"></a>01667 
<a name="l01668" id="l01668"></a>01668     <span class="comment">/*</span>
<a name="l01669" id="l01669"></a>01669 <span class="comment">     * msgAuthoritativeEngineBoots.  </span>
<a name="l01670" id="l01670"></a>01670 <span class="comment">     */</span>
<a name="l01671" id="l01671"></a>01671     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineBoots"</span>);
<a name="l01672" id="l01672"></a>01672     rc = asn_realloc_rbuild_int(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01673" id="l01673"></a>01673                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01674" id="l01674"></a>01674                                           ASN_INTEGER), &amp;boots_long,
<a name="l01675" id="l01675"></a>01675                                 <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
<a name="l01676" id="l01676"></a>01676     DEBUGINDENTLESS();
<a name="l01677" id="l01677"></a>01677     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01678" id="l01678"></a>01678         DEBUGMSGTL((<span class="stringliteral">"usm"</span>,
<a name="l01679" id="l01679"></a>01679                     <span class=
"stringliteral">"building msgAuthoritativeEngineBoots failed.\n"</span>));
<a name="l01680" id="l01680"></a>01680         usm_free_usmStateReference(secStateRef);
<a name="l01681" id="l01681"></a>01681         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01682" id="l01682"></a>01682     }
<a name="l01683" id="l01683"></a>01683 
<a name="l01684" id="l01684"></a>01684     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineID"</span>);
<a name="l01685" id="l01685"></a>01685     rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01686" id="l01686"></a>01686                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
<a name="l01687" id="l01687"></a>01687                                              | ASN_OCTET_STR), theEngineID,
<a name="l01688" id="l01688"></a>01688                                    theEngineIDLength);
<a name="l01689" id="l01689"></a>01689     DEBUGINDENTLESS();
<a name="l01690" id="l01690"></a>01690     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01691" id="l01691"></a>01691         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building msgAuthoritativeEngineID failed.\n"</span>));
<a name="l01692" id="l01692"></a>01692         usm_free_usmStateReference(secStateRef);
<a name="l01693" id="l01693"></a>01693         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01694" id="l01694"></a>01694     }
<a name="l01695" id="l01695"></a>01695 
<a name="l01696" id="l01696"></a>01696     <span class="comment">/*</span>
<a name="l01697" id="l01697"></a>01697 <span class="comment">     * USM msgSecurityParameters sequence header  </span>
<a name="l01698" id="l01698"></a>01698 <span class="comment">     */</span>
<a name="l01699" id="l01699"></a>01699     rc = asn_realloc_rbuild_sequence(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01700" id="l01700"></a>01700                                      (u_char) (ASN_SEQUENCE |
<a name="l01701" id="l01701"></a>01701                                                ASN_CONSTRUCTOR),
<a name="l01702" id="l01702"></a>01702                                      *offset - sp_offset);
<a name="l01703" id="l01703"></a>01703     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01704" id="l01704"></a>01704         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building usm security parameters failed.\n"</span>));
<a name="l01705" id="l01705"></a>01705         usm_free_usmStateReference(secStateRef);
<a name="l01706" id="l01706"></a>01706         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01707" id="l01707"></a>01707     }
<a name="l01708" id="l01708"></a>01708 
<a name="l01709" id="l01709"></a>01709     <span class="comment">/*</span>
<a name="l01710" id="l01710"></a>01710 <span class="comment">     * msgSecurityParameters OCTET STRING wrapper.  </span>
<a name="l01711" id="l01711"></a>01711 <span class="comment">     */</span>
<a name="l01712" id="l01712"></a>01712     rc = asn_realloc_rbuild_header(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01713" id="l01713"></a>01713                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
<a name="l01714" id="l01714"></a>01714                                              | ASN_OCTET_STR),
<a name="l01715" id="l01715"></a>01715                                    *offset - sp_offset);
<a name="l01716" id="l01716"></a>01716 
<a name="l01717" id="l01717"></a>01717     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01718" id="l01718"></a>01718         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building msgSecurityParameters failed.\n"</span>));
<a name="l01719" id="l01719"></a>01719         usm_free_usmStateReference(secStateRef);
<a name="l01720" id="l01720"></a>01720         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01721" id="l01721"></a>01721     }
<a name="l01722" id="l01722"></a>01722 
<a name="l01723" id="l01723"></a>01723     <span class="comment">/*</span>
<a name="l01724" id="l01724"></a>01724 <span class="comment">     * Copy in the msgGlobalData and msgVersion.  </span>
<a name="l01725" id="l01725"></a>01725 <span class="comment">     */</span>
<a name="l01726" id="l01726"></a>01726     <span class="keywordflow">while</span> ((*wholeMsgLen - *offset) &lt; globalDataLen) {
<a name="l01727" id="l01727"></a>01727         <span class="keywordflow">if</span> (!asn_realloc(wholeMsg, wholeMsgLen)) {
<a name="l01728" id="l01728"></a>01728             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building global data failed.\n"</span>));
<a name="l01729" id="l01729"></a>01729             usm_free_usmStateReference(secStateRef);
<a name="l01730" id="l01730"></a>01730             <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01731" id="l01731"></a>01731         }
<a name="l01732" id="l01732"></a>01732     }
<a name="l01733" id="l01733"></a>01733 
<a name="l01734" id="l01734"></a>01734     *offset += globalDataLen;
<a name="l01735" id="l01735"></a>01735     memcpy(*wholeMsg + *wholeMsgLen - *offset, globalData, globalDataLen);
<a name="l01736" id="l01736"></a>01736 
<a name="l01737" id="l01737"></a>01737     <span class="comment">/*</span>
<a name="l01738" id="l01738"></a>01738 <span class="comment">     * Total packet sequence.  </span>
<a name="l01739" id="l01739"></a>01739 <span class="comment">     */</span>
<a name="l01740" id="l01740"></a>01740     rc = asn_realloc_rbuild_sequence(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01741" id="l01741"></a>01741                                      (u_char) (ASN_SEQUENCE |
<a name="l01742" id="l01742"></a>01742                                                ASN_CONSTRUCTOR), *offset);
<a name="l01743" id="l01743"></a>01743     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01744" id="l01744"></a>01744         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building master packet sequence failed.\n"</span>));
<a name="l01745" id="l01745"></a>01745         usm_free_usmStateReference(secStateRef);
<a name="l01746" id="l01746"></a>01746         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01747" id="l01747"></a>01747     }
<a name="l01748" id="l01748"></a>01748 
<a name="l01749" id="l01749"></a>01749     <span class="comment">/*</span>
<a name="l01750" id="l01750"></a>01750 <span class="comment">     * Now consider / do authentication.  </span>
<a name="l01751" id="l01751"></a>01751 <span class="comment">     */</span>
<a name="l01752" id="l01752"></a>01752 
<a name="l01753" id="l01753"></a>01753     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV ||
<a name="l01754" id="l01754"></a>01754         theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01755" id="l01755"></a>01755         <span class="keywordtype">size_t</span>          temp_sig_len = msgAuthParmLen;
<a name="l01756" id="l01756"></a>01756         u_char         *temp_sig = (u_char *) malloc(temp_sig_len);
<a name="l01757" id="l01757"></a>01757         u_char         *proto_msg = *wholeMsg + *wholeMsgLen - *offset;
<a name="l01758" id="l01758"></a>01758         <span class="keywordtype">size_t</span>          proto_msg_len = *offset;
<a name="l01759" id="l01759"></a>01759 
<a name="l01760" id="l01760"></a>01760 
<a name="l01761" id="l01761"></a>01761         <span class="keywordflow">if</span> (temp_sig == NULL) {
<a name="l01762" id="l01762"></a>01762             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Out of memory.\n"</span>));
<a name="l01763" id="l01763"></a>01763             usm_free_usmStateReference(secStateRef);
<a name="l01764" id="l01764"></a>01764             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01765" id="l01765"></a>01765         }
<a name="l01766" id="l01766"></a>01766 
<a name="l01767" id="l01767"></a>01767         <span class=
"keywordflow">if</span> (sc_generate_keyed_hash(theAuthProtocol, theAuthProtocolLength,
<a name="l01768" id="l01768"></a>01768                                    theAuthKey, theAuthKeyLength,
<a name="l01769" id="l01769"></a>01769                                    proto_msg, proto_msg_len,
<a name="l01770" id="l01770"></a>01770                                    temp_sig, &amp;temp_sig_len)
<a name="l01771" id="l01771"></a>01771             != SNMP_ERR_NOERROR) {
<a name="l01772" id="l01772"></a>01772             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6"
title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(temp_sig);
<a name="l01773" id="l01773"></a>01773             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Signing failed.\n"</span>));
<a name="l01774" id="l01774"></a>01774             usm_free_usmStateReference(secStateRef);
<a name="l01775" id="l01775"></a>01775             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
<a name="l01776" id="l01776"></a>01776         }
<a name="l01777" id="l01777"></a>01777 
<a name="l01778" id="l01778"></a>01778         <span class="keywordflow">if</span> (temp_sig_len != msgAuthParmLen) {
<a name="l01779" id="l01779"></a>01779             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6"
title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(temp_sig);
<a name="l01780" id="l01780"></a>01780             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Signing lengths failed.\n"</span>));
<a name="l01781" id="l01781"></a>01781             usm_free_usmStateReference(secStateRef);
<a name="l01782" id="l01782"></a>01782             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
<a name="l01783" id="l01783"></a>01783         }
<a name="l01784" id="l01784"></a>01784 
<a name="l01785" id="l01785"></a>01785         memcpy(*wholeMsg + *wholeMsgLen - mac_offset, temp_sig,
<a name="l01786" id="l01786"></a>01786                msgAuthParmLen);
<a name="l01787" id="l01787"></a>01787         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(temp_sig);
<a name="l01788" id="l01788"></a>01788     }
<a name="l01789" id="l01789"></a>01789     <span class="comment">/*</span>
<a name="l01790" id="l01790"></a>01790 <span class="comment">     * endif -- create keyed hash </span>
<a name="l01791" id="l01791"></a>01791 <span class="comment">     */</span>
<a name="l01792" id="l01792"></a>01792     usm_free_usmStateReference(secStateRef);
<a name="l01793" id="l01793"></a>01793     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"USM processing completed.\n"</span>));
<a name="l01794" id="l01794"></a>01794     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l01795" id="l01795"></a>01795 }                               <span class=
"comment">/* end usm_rgenerate_out_msg() */</span>
<a name="l01796" id="l01796"></a>01796 
<a name="l01797" id="l01797"></a>01797 <span class="preprocessor">#endif                          </span><span class=
"comment">/* */</span>
<a name="l01798" id="l01798"></a>01798 
<a name="l01799" id="l01799"></a>01799 
<a name="l01800" id="l01800"></a>01800 
<a name="l01801" id="l01801"></a>01801 <span class=
"comment">/*******************************************************************-o-******</span>
<a name="l01802" id="l01802"></a>01802 <span class="comment"> * usm_parse_security_parameters</span>
<a name="l01803" id="l01803"></a>01803 <span class="comment"> *</span>
<a name="l01804" id="l01804"></a>01804 <span class="comment"> * Parameters:</span>
<a name="l01805" id="l01805"></a>01805 <span class="comment"> *      (See list below...)</span>
<a name="l01806" id="l01806"></a>01806 <span class="comment"> *      </span>
<a name="l01807" id="l01807"></a>01807 <span class="comment"> * Returns:</span>
<a name="l01808" id="l01808"></a>01808 <span class="comment"> *      0       On success,</span>
<a name="l01809" id="l01809"></a>01809 <span class="comment"> *      -1      Otherwise.</span>
<a name="l01810" id="l01810"></a>01810 <span class="comment"> *</span>
<a name="l01811" id="l01811"></a>01811 <span class="comment"> *      tab stop 4</span>
<a name="l01812" id="l01812"></a>01812 <span class="comment"> *</span>
<a name="l01813" id="l01813"></a>01813 <span class=
"comment"> *      Extracts values from the security header and data portions of the</span>
<a name="l01814" id="l01814"></a>01814 <span class="comment"> *      incoming buffer.</span>
<a name="l01815" id="l01815"></a>01815 <span class="comment"> */</span>
<a name="l01816" id="l01816"></a>01816 <span class="keywordtype">int</span>
<a name="l01817" id="l01817"></a>01817 usm_parse_security_parameters(u_char * secParams,
<a name="l01818" id="l01818"></a>01818                               <span class="keywordtype">size_t</span> remaining,
<a name="l01819" id="l01819"></a>01819                               u_char * secEngineID,
<a name="l01820" id="l01820"></a>01820                               <span class="keywordtype">size_t</span> * secEngineIDLen,
<a name="l01821" id="l01821"></a>01821                               u_int * boots_uint,
<a name="l01822" id="l01822"></a>01822                               u_int * time_uint,
<a name="l01823" id="l01823"></a>01823                               <span class="keywordtype">char</span> *secName,
<a name="l01824" id="l01824"></a>01824                               <span class="keywordtype">size_t</span> * secNameLen,
<a name="l01825" id="l01825"></a>01825                               u_char * signature,
<a name="l01826" id="l01826"></a>01826                               <span class="keywordtype">size_t</span> * signature_length,
<a name="l01827" id="l01827"></a>01827                               u_char * salt,
<a name="l01828" id="l01828"></a>01828                               <span class=
"keywordtype">size_t</span> * salt_length, u_char ** data_ptr)
<a name="l01829" id="l01829"></a>01829 {
<a name="l01830" id="l01830"></a>01830     u_char         *parse_ptr = secParams;
<a name="l01831" id="l01831"></a>01831     u_char         *value_ptr;
<a name="l01832" id="l01832"></a>01832     u_char         *next_ptr;
<a name="l01833" id="l01833"></a>01833     u_char          type_value;
<a name="l01834" id="l01834"></a>01834 
<a name="l01835" id="l01835"></a>01835     <span class="keywordtype">size_t</span>          octet_string_length = remaining;
<a name="l01836" id="l01836"></a>01836     <span class="keywordtype">size_t</span>          sequence_length;
<a name="l01837" id="l01837"></a>01837     <span class="keywordtype">size_t</span>          remaining_bytes;
<a name="l01838" id="l01838"></a>01838 
<a name="l01839" id="l01839"></a>01839     <span class="keywordtype">long</span>            boots_long;
<a name="l01840" id="l01840"></a>01840     <span class="keywordtype">long</span>            time_long;
<a name="l01841" id="l01841"></a>01841 
<a name="l01842" id="l01842"></a>01842     u_int           origNameLen;
<a name="l01843" id="l01843"></a>01843 
<a name="l01844" id="l01844"></a>01844 
<a name="l01845" id="l01845"></a>01845     <span class="comment">/*</span>
<a name="l01846" id="l01846"></a>01846 <span class="comment">     * Eat the first octet header.</span>
<a name="l01847" id="l01847"></a>01847 <span class="comment">     */</span>
<a name="l01848" id="l01848"></a>01848     <span class=
"keywordflow">if</span> ((value_ptr = asn_parse_sequence(parse_ptr, &amp;octet_string_length,
<a name="l01849" id="l01849"></a>01849                                         &amp;type_value,
<a name="l01850" id="l01850"></a>01850                                         (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01851" id="l01851"></a>01851                                          ASN_OCTET_STR),
<a name="l01852" id="l01852"></a>01852                                         <span class=
"stringliteral">"usm first octet"</span>)) == NULL) {
<a name="l01853" id="l01853"></a>01853         <span class="comment">/*</span>
<a name="l01854" id="l01854"></a>01854 <span class="comment">         * RETURN parse error </span>
<a name="l01855" id="l01855"></a>01855 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01856" id="l01856"></a>01856     }
<a name="l01857" id="l01857"></a>01857 
<a name="l01858" id="l01858"></a>01858 
<a name="l01859" id="l01859"></a>01859     <span class="comment">/*</span>
<a name="l01860" id="l01860"></a>01860 <span class="comment">     * Eat the sequence header.</span>
<a name="l01861" id="l01861"></a>01861 <span class="comment">     */</span>
<a name="l01862" id="l01862"></a>01862     parse_ptr = value_ptr;
<a name="l01863" id="l01863"></a>01863     sequence_length = octet_string_length;
<a name="l01864" id="l01864"></a>01864 
<a name="l01865" id="l01865"></a>01865     <span class=
"keywordflow">if</span> ((value_ptr = asn_parse_sequence(parse_ptr, &amp;sequence_length,
<a name="l01866" id="l01866"></a>01866                                         &amp;type_value,
<a name="l01867" id="l01867"></a>01867                                         (ASN_SEQUENCE | ASN_CONSTRUCTOR),
<a name="l01868" id="l01868"></a>01868                                         <span class=
"stringliteral">"usm sequence"</span>)) == NULL) {
<a name="l01869" id="l01869"></a>01869         <span class="comment">/*</span>
<a name="l01870" id="l01870"></a>01870 <span class="comment">         * RETURN parse error </span>
<a name="l01871" id="l01871"></a>01871 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01872" id="l01872"></a>01872     }
<a name="l01873" id="l01873"></a>01873 
<a name="l01874" id="l01874"></a>01874 
<a name="l01875" id="l01875"></a>01875     <span class="comment">/*</span>
<a name="l01876" id="l01876"></a>01876 <span class="comment">     * Retrieve the engineID.</span>
<a name="l01877" id="l01877"></a>01877 <span class="comment">     */</span>
<a name="l01878" id="l01878"></a>01878     parse_ptr = value_ptr;
<a name="l01879" id="l01879"></a>01879     remaining_bytes = sequence_length;
<a name="l01880" id="l01880"></a>01880 
<a name="l01881" id="l01881"></a>01881     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineID"</span>);
<a name="l01882" id="l01882"></a>01882     <span class="keywordflow">if</span> ((next_ptr
<a name="l01883" id="l01883"></a>01883          = asn_parse_string(parse_ptr, &amp;remaining_bytes, &amp;type_value,
<a name="l01884" id="l01884"></a>01884                             secEngineID, secEngineIDLen)) == NULL) {
<a name="l01885" id="l01885"></a>01885         DEBUGINDENTLESS();
<a name="l01886" id="l01886"></a>01886         <span class="comment">/*</span>
<a name="l01887" id="l01887"></a>01887 <span class="comment">         * RETURN parse error </span>
<a name="l01888" id="l01888"></a>01888 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01889" id="l01889"></a>01889     }
<a name="l01890" id="l01890"></a>01890     DEBUGINDENTLESS();
<a name="l01891" id="l01891"></a>01891 
<a name="l01892" id="l01892"></a>01892     <span class="keywordflow">if</span> (type_value !=
<a name="l01893" id="l01893"></a>01893         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {
<a name="l01894" id="l01894"></a>01894         <span class="comment">/*</span>
<a name="l01895" id="l01895"></a>01895 <span class="comment">         * RETURN parse error </span>
<a name="l01896" id="l01896"></a>01896 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01897" id="l01897"></a>01897     }
<a name="l01898" id="l01898"></a>01898 
<a name="l01899" id="l01899"></a>01899 
<a name="l01900" id="l01900"></a>01900     <span class="comment">/*</span>
<a name="l01901" id="l01901"></a>01901 <span class=
"comment">     * Retrieve the engine boots, notice switch in the way next_ptr and</span>
<a name="l01902" id="l01902"></a>01902 <span class="comment">     * remaining_bytes are used (to accomodate the asn code).</span>
<a name="l01903" id="l01903"></a>01903 <span class="comment">     */</span>
<a name="l01904" id="l01904"></a>01904     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineBoots"</span>);
<a name="l01905" id="l01905"></a>01905     <span class=
"keywordflow">if</span> ((next_ptr = asn_parse_int(next_ptr, &amp;remaining_bytes, &amp;type_value,
<a name="l01906" id="l01906"></a>01906                                   &amp;boots_long, <span class=
"keyword">sizeof</span>(<span class="keywordtype">long</span>))) == NULL) {
<a name="l01907" id="l01907"></a>01907         DEBUGINDENTLESS();
<a name="l01908" id="l01908"></a>01908         <span class="comment">/*</span>
<a name="l01909" id="l01909"></a>01909 <span class="comment">         * RETURN parse error </span>
<a name="l01910" id="l01910"></a>01910 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01911" id="l01911"></a>01911     }
<a name="l01912" id="l01912"></a>01912     DEBUGINDENTLESS();
<a name="l01913" id="l01913"></a>01913 
<a name="l01914" id="l01914"></a>01914     <span class="keywordflow">if</span> (type_value !=
<a name="l01915" id="l01915"></a>01915         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER)) {
<a name="l01916" id="l01916"></a>01916         DEBUGINDENTLESS();
<a name="l01917" id="l01917"></a>01917         <span class="comment">/*</span>
<a name="l01918" id="l01918"></a>01918 <span class="comment">         * RETURN parse error </span>
<a name="l01919" id="l01919"></a>01919 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01920" id="l01920"></a>01920     }
<a name="l01921" id="l01921"></a>01921 
<a name="l01922" id="l01922"></a>01922     *boots_uint = (u_int) boots_long;
<a name="l01923" id="l01923"></a>01923 
<a name="l01924" id="l01924"></a>01924 
<a name="l01925" id="l01925"></a>01925     <span class="comment">/*</span>
<a name="l01926" id="l01926"></a>01926 <span class="comment">     * Retrieve the time value.</span>
<a name="l01927" id="l01927"></a>01927 <span class="comment">     */</span>
<a name="l01928" id="l01928"></a>01928     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineTime"</span>);
<a name="l01929" id="l01929"></a>01929     <span class=
"keywordflow">if</span> ((next_ptr = asn_parse_int(next_ptr, &amp;remaining_bytes, &amp;type_value,
<a name="l01930" id="l01930"></a>01930                                   &amp;time_long, <span class=
"keyword">sizeof</span>(<span class="keywordtype">long</span>))) == NULL) {
<a name="l01931" id="l01931"></a>01931         <span class="comment">/*</span>
<a name="l01932" id="l01932"></a>01932 <span class="comment">         * RETURN parse error </span>
<a name="l01933" id="l01933"></a>01933 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01934" id="l01934"></a>01934     }
<a name="l01935" id="l01935"></a>01935     DEBUGINDENTLESS();
<a name="l01936" id="l01936"></a>01936 
<a name="l01937" id="l01937"></a>01937     <span class="keywordflow">if</span> (type_value !=
<a name="l01938" id="l01938"></a>01938         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER)) {
<a name="l01939" id="l01939"></a>01939         <span class="comment">/*</span>
<a name="l01940" id="l01940"></a>01940 <span class="comment">         * RETURN parse error </span>
<a name="l01941" id="l01941"></a>01941 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01942" id="l01942"></a>01942     }
<a name="l01943" id="l01943"></a>01943 
<a name="l01944" id="l01944"></a>01944     *time_uint = (u_int) time_long;
<a name="l01945" id="l01945"></a>01945 
<a name="l01946" id="l01946"></a>01946     <span class=
"keywordflow">if</span> (*boots_uint &gt; ENGINEBOOT_MAX || *time_uint &gt; ENGINETIME_MAX) {
<a name="l01947" id="l01947"></a>01947         <span class="keywordflow">return</span> -1;
<a name="l01948" id="l01948"></a>01948     }
<a name="l01949" id="l01949"></a>01949 
<a name="l01950" id="l01950"></a>01950     <span class="comment">/*</span>
<a name="l01951" id="l01951"></a>01951 <span class="comment">     * Retrieve the secName.</span>
<a name="l01952" id="l01952"></a>01952 <span class="comment">     */</span>
<a name="l01953" id="l01953"></a>01953     origNameLen = *secNameLen;
<a name="l01954" id="l01954"></a>01954 
<a name="l01955" id="l01955"></a>01955 
<a name="l01956" id="l01956"></a>01956     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"msgUserName"</span>);
<a name="l01957" id="l01957"></a>01957     <span class="keywordflow">if</span> ((next_ptr
<a name="l01958" id="l01958"></a>01958          = asn_parse_string(next_ptr, &amp;remaining_bytes, &amp;type_value,
<a name="l01959" id="l01959"></a>01959                             (u_char *) secName, secNameLen)) == NULL) {
<a name="l01960" id="l01960"></a>01960         DEBUGINDENTLESS();
<a name="l01961" id="l01961"></a>01961         <span class="comment">/*</span>
<a name="l01962" id="l01962"></a>01962 <span class="comment">         * RETURN parse error </span>
<a name="l01963" id="l01963"></a>01963 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01964" id="l01964"></a>01964     }
<a name="l01965" id="l01965"></a>01965     DEBUGINDENTLESS();
<a name="l01966" id="l01966"></a>01966 
<a name="l01967" id="l01967"></a>01967     <span class="comment">/*</span>
<a name="l01968" id="l01968"></a>01968 <span class="comment">     * FIX -- doesn't this also indicate a buffer overrun?</span>
<a name="l01969" id="l01969"></a>01969 <span class="comment">     */</span>
<a name="l01970" id="l01970"></a>01970     <span class="keywordflow">if</span> ((<span class=
"keywordtype">int</span>) origNameLen &lt; *secNameLen + 1) {
<a name="l01971" id="l01971"></a>01971         <span class="comment">/*</span>
<a name="l01972" id="l01972"></a>01972 <span class=
"comment">         * RETURN parse error, but it's really a parameter error </span>
<a name="l01973" id="l01973"></a>01973 <span class="comment">         */</span>
<a name="l01974" id="l01974"></a>01974         <span class="keywordflow">return</span> -1;
<a name="l01975" id="l01975"></a>01975     }
<a name="l01976" id="l01976"></a>01976 
<a name="l01977" id="l01977"></a>01977     <span class="keywordflow">if</span> (*secNameLen &gt; 32) {
<a name="l01978" id="l01978"></a>01978         <span class="comment">/*</span>
<a name="l01979" id="l01979"></a>01979 <span class=
"comment">         * This is a USM-specific limitation over and above the above</span>
<a name="l01980" id="l01980"></a>01980 <span class=
"comment">         * limitation (which will probably default to the length of an</span>
<a name="l01981" id="l01981"></a>01981 <span class=
"comment">         * SnmpAdminString, i.e. 255).  See RFC 2574, sec. 2.4.  </span>
<a name="l01982" id="l01982"></a>01982 <span class="comment">         */</span>
<a name="l01983" id="l01983"></a>01983         <span class="keywordflow">return</span> -1;
<a name="l01984" id="l01984"></a>01984     }
<a name="l01985" id="l01985"></a>01985 
<a name="l01986" id="l01986"></a>01986     secName[*secNameLen] = <span class="charliteral">'\0'</span>;
<a name="l01987" id="l01987"></a>01987 
<a name="l01988" id="l01988"></a>01988     <span class="keywordflow">if</span> (type_value !=
<a name="l01989" id="l01989"></a>01989         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {
<a name="l01990" id="l01990"></a>01990         <span class="comment">/*</span>
<a name="l01991" id="l01991"></a>01991 <span class="comment">         * RETURN parse error </span>
<a name="l01992" id="l01992"></a>01992 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01993" id="l01993"></a>01993     }
<a name="l01994" id="l01994"></a>01994 
<a name="l01995" id="l01995"></a>01995 
<a name="l01996" id="l01996"></a>01996     <span class="comment">/*</span>
<a name="l01997" id="l01997"></a>01997 <span class="comment">     * Retrieve the signature and blank it if there.</span>
<a name="l01998" id="l01998"></a>01998 <span class="comment">     */</span>
<a name="l01999" id="l01999"></a>01999     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"msgAuthenticationParameters"</span>);
<a name="l02000" id="l02000"></a>02000     <span class="keywordflow">if</span> ((next_ptr
<a name="l02001" id="l02001"></a>02001          = asn_parse_string(next_ptr, &amp;remaining_bytes, &amp;type_value,
<a name="l02002" id="l02002"></a>02002                             signature, signature_length)) == NULL) {
<a name="l02003" id="l02003"></a>02003         DEBUGINDENTLESS();
<a name="l02004" id="l02004"></a>02004         <span class="comment">/*</span>
<a name="l02005" id="l02005"></a>02005 <span class="comment">         * RETURN parse error </span>
<a name="l02006" id="l02006"></a>02006 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l02007" id="l02007"></a>02007     }
<a name="l02008" id="l02008"></a>02008     DEBUGINDENTLESS();
<a name="l02009" id="l02009"></a>02009 
<a name="l02010" id="l02010"></a>02010     <span class="keywordflow">if</span> (type_value !=
<a name="l02011" id="l02011"></a>02011         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {
<a name="l02012" id="l02012"></a>02012         <span class="comment">/*</span>
<a name="l02013" id="l02013"></a>02013 <span class="comment">         * RETURN parse error </span>
<a name="l02014" id="l02014"></a>02014 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l02015" id="l02015"></a>02015     }
<a name="l02016" id="l02016"></a>02016 
<a name="l02017" id="l02017"></a>02017     <span class="keywordflow">if</span> (*signature_length != 0) {       <span class=
"comment">/* Blanking for authentication step later */</span>
<a name="l02018" id="l02018"></a>02018         memset(next_ptr - (u_long) * signature_length,
<a name="l02019" id="l02019"></a>02019                0, *signature_length);
<a name="l02020" id="l02020"></a>02020     }
<a name="l02021" id="l02021"></a>02021 
<a name="l02022" id="l02022"></a>02022 
<a name="l02023" id="l02023"></a>02023     <span class="comment">/*</span>
<a name="l02024" id="l02024"></a>02024 <span class="comment">     * Retrieve the salt.</span>
<a name="l02025" id="l02025"></a>02025 <span class="comment">     *</span>
<a name="l02026" id="l02026"></a>02026 <span class=
"comment">     * Note that the next ptr is where the data section starts.</span>
<a name="l02027" id="l02027"></a>02027 <span class="comment">     */</span>
<a name="l02028" id="l02028"></a>02028     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"msgPrivacyParameters"</span>);
<a name="l02029" id="l02029"></a>02029     <span class="keywordflow">if</span> ((*data_ptr
<a name="l02030" id="l02030"></a>02030          = asn_parse_string(next_ptr, &amp;remaining_bytes, &amp;type_value,
<a name="l02031" id="l02031"></a>02031                             salt, salt_length)) == NULL) {
<a name="l02032" id="l02032"></a>02032         DEBUGINDENTLESS();
<a name="l02033" id="l02033"></a>02033         <span class="comment">/*</span>
<a name="l02034" id="l02034"></a>02034 <span class="comment">         * RETURN parse error </span>
<a name="l02035" id="l02035"></a>02035 <span class="comment">         */</span> <span class="keywordflow">return</span> -2;
<a name="l02036" id="l02036"></a>02036     }
<a name="l02037" id="l02037"></a>02037     DEBUGINDENTLESS();
<a name="l02038" id="l02038"></a>02038 
<a name="l02039" id="l02039"></a>02039     <span class="keywordflow">if</span> (type_value !=
<a name="l02040" id="l02040"></a>02040         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {
<a name="l02041" id="l02041"></a>02041         <span class="comment">/*</span>
<a name="l02042" id="l02042"></a>02042 <span class="comment">         * RETURN parse error </span>
<a name="l02043" id="l02043"></a>02043 <span class="comment">         */</span> <span class="keywordflow">return</span> -2;
<a name="l02044" id="l02044"></a>02044     }
<a name="l02045" id="l02045"></a>02045 
<a name="l02046" id="l02046"></a>02046     <span class="keywordflow">return</span> 0;
<a name="l02047" id="l02047"></a>02047 
<a name="l02048" id="l02048"></a>02048 }                               <span class=
"comment">/* end usm_parse_security_parameters() */</span>
<a name="l02049" id="l02049"></a>02049 
<a name="l02050" id="l02050"></a>02050 
<a name="l02051" id="l02051"></a>02051 
<a name="l02052" id="l02052"></a>02052 
<a name="l02053" id="l02053"></a>02053 <span class=
"comment">/*******************************************************************-o-******</span>
<a name="l02054" id="l02054"></a>02054 <span class="comment"> * usm_check_and_update_timeliness</span>
<a name="l02055" id="l02055"></a>02055 <span class="comment"> *</span>
<a name="l02056" id="l02056"></a>02056 <span class="comment"> * Parameters:</span>
<a name="l02057" id="l02057"></a>02057 <span class="comment"> *      *secEngineID</span>
<a name="l02058" id="l02058"></a>02058 <span class="comment"> *       secEngineIDen</span>
<a name="l02059" id="l02059"></a>02059 <span class="comment"> *       boots_uint</span>
<a name="l02060" id="l02060"></a>02060 <span class="comment"> *       time_uint</span>
<a name="l02061" id="l02061"></a>02061 <span class="comment"> *      *error</span>
<a name="l02062" id="l02062"></a>02062 <span class="comment"> *      </span>
<a name="l02063" id="l02063"></a>02063 <span class="comment"> * Returns:</span>
<a name="l02064" id="l02064"></a>02064 <span class="comment"> *      0       On success,</span>
<a name="l02065" id="l02065"></a>02065 <span class="comment"> *      -1      Otherwise.</span>
<a name="l02066" id="l02066"></a>02066 <span class="comment"> *      </span>
<a name="l02067" id="l02067"></a>02067 <span class="comment"> *</span>
<a name="l02068" id="l02068"></a>02068 <span class="comment"> * Performs the incoming timeliness checking and setting.</span>
<a name="l02069" id="l02069"></a>02069 <span class="comment"> */</span>
<a name="l02070" id="l02070"></a>02070 <span class="keywordtype">int</span>
<a name="l02071" id="l02071"></a>02071 usm_check_and_update_timeliness(u_char * secEngineID,
<a name="l02072" id="l02072"></a>02072                                 <span class="keywordtype">size_t</span> secEngineIDLen,
<a name="l02073" id="l02073"></a>02073                                 u_int boots_uint,
<a name="l02074" id="l02074"></a>02074                                 u_int time_uint, <span class=
"keywordtype">int</span> *error)
<a name="l02075" id="l02075"></a>02075 {
<a name="l02076" id="l02076"></a>02076     u_char          myID[USM_MAX_ID_LENGTH];
<a name="l02077" id="l02077"></a>02077     u_long          myIDLength =
<a name="l02078" id="l02078"></a>02078         snmpv3_get_engineID(myID, USM_MAX_ID_LENGTH);
<a name="l02079" id="l02079"></a>02079     u_int           myBoots;
<a name="l02080" id="l02080"></a>02080     u_int           myTime;
<a name="l02081" id="l02081"></a>02081 
<a name="l02082" id="l02082"></a>02082 
<a name="l02083" id="l02083"></a>02083 
<a name="l02084" id="l02084"></a>02084     <span class=
"keywordflow">if</span> ((myIDLength &gt; USM_MAX_ID_LENGTH) || (myIDLength == 0)) {
<a name="l02085" id="l02085"></a>02085         <span class="comment">/*</span>
<a name="l02086" id="l02086"></a>02086 <span class=
"comment">         * We're probably already screwed...buffer overwrite.  XXX? </span>
<a name="l02087" id="l02087"></a>02087 <span class="comment">         */</span>
<a name="l02088" id="l02088"></a>02088         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Buffer overflow.\n"</span>));
<a name="l02089" id="l02089"></a>02089         *error = SNMPERR_USM_GENERICERROR;
<a name="l02090" id="l02090"></a>02090         <span class="keywordflow">return</span> -1;
<a name="l02091" id="l02091"></a>02091     }
<a name="l02092" id="l02092"></a>02092 
<a name="l02093" id="l02093"></a>02093     myBoots = snmpv3_local_snmpEngineBoots();
<a name="l02094" id="l02094"></a>02094     myTime = snmpv3_local_snmpEngineTime();
<a name="l02095" id="l02095"></a>02095 
<a name="l02096" id="l02096"></a>02096 
<a name="l02097" id="l02097"></a>02097     <span class="comment">/*</span>
<a name="l02098" id="l02098"></a>02098 <span class="comment">     * IF the time involved is local</span>
<a name="l02099" id="l02099"></a>02099 <span class="comment">     *     Make sure  message is inside the time window </span>
<a name="l02100" id="l02100"></a>02100 <span class="comment">     * ELSE </span>
<a name="l02101" id="l02101"></a>02101 <span class=
"comment">     *      IF boots is higher or boots is the same and time is higher</span>
<a name="l02102" id="l02102"></a>02102 <span class="comment">     *              remember this new data</span>
<a name="l02103" id="l02103"></a>02103 <span class="comment">     *      ELSE</span>
<a name="l02104" id="l02104"></a>02104 <span class=
"comment">     *              IF !(boots same and time within USM_TIME_WINDOW secs)</span>
<a name="l02105" id="l02105"></a>02105 <span class="comment">     *                      Message is too old </span>
<a name="l02106" id="l02106"></a>02106 <span class="comment">     *              ELSE    </span>
<a name="l02107" id="l02107"></a>02107 <span class=
"comment">     *                      Message is ok, but don't take time</span>
<a name="l02108" id="l02108"></a>02108 <span class="comment">     *              ENDIF</span>
<a name="l02109" id="l02109"></a>02109 <span class="comment">     *      ENDIF</span>
<a name="l02110" id="l02110"></a>02110 <span class="comment">     * ENDIF</span>
<a name="l02111" id="l02111"></a>02111 <span class="comment">     */</span>
<a name="l02112" id="l02112"></a>02112 
<a name="l02113" id="l02113"></a>02113     <span class="comment">/*</span>
<a name="l02114" id="l02114"></a>02114 <span class="comment">     * This is a local reference.</span>
<a name="l02115" id="l02115"></a>02115 <span class="comment">     */</span>
<a name="l02116" id="l02116"></a>02116     <span class="keywordflow">if</span> ((<span class=
"keywordtype">int</span>) secEngineIDLen == myIDLength
<a name="l02117" id="l02117"></a>02117         &amp;&amp; memcmp(secEngineID, myID, myIDLength) == 0) {
<a name="l02118" id="l02118"></a>02118         u_int           time_difference = myTime &gt; time_uint ?
<a name="l02119" id="l02119"></a>02119             myTime - time_uint : time_uint - myTime;
<a name="l02120" id="l02120"></a>02120 
<a name="l02121" id="l02121"></a>02121         <span class="keywordflow">if</span> (boots_uint == ENGINEBOOT_MAX
<a name="l02122" id="l02122"></a>02122             || boots_uint != myBoots
<a name="l02123" id="l02123"></a>02123             || time_difference &gt; USM_TIME_WINDOW) {
<a name="l02124" id="l02124"></a>02124             <span class=
"keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSNOTINTIMEWINDOWS) ==
<a name="l02125" id="l02125"></a>02125                 0) {
<a name="l02126" id="l02126"></a>02126                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>,
<a name="l02127" id="l02127"></a>02127                             <span class=
"stringliteral">"Failed to increment statistic."</span>));
<a name="l02128" id="l02128"></a>02128             }
<a name="l02129" id="l02129"></a>02129 
<a name="l02130" id="l02130"></a>02130             DEBUGMSGTL((<span class="stringliteral">"usm"</span>,
<a name="l02131" id="l02131"></a>02131                         <span class=
"stringliteral">"boot_uint %u myBoots %u time_diff %u =&gt; not in time window\n"</span>,
<a name="l02132" id="l02132"></a>02132                         boots_uint, myBoots, time_difference));
<a name="l02133" id="l02133"></a>02133             *error = SNMPERR_USM_NOTINTIMEWINDOW;
<a name="l02134" id="l02134"></a>02134             <span class="keywordflow">return</span> -1;
<a name="l02135" id="l02135"></a>02135         }
<a name="l02136" id="l02136"></a>02136 
<a name="l02137" id="l02137"></a>02137         *error = SNMPERR_SUCCESS;
<a name="l02138" id="l02138"></a>02138         <span class="keywordflow">return</span> 0;
<a name="l02139" id="l02139"></a>02139     }
<a name="l02140" id="l02140"></a>02140 
<a name="l02141" id="l02141"></a>02141     <span class="comment">/*</span>
<a name="l02142" id="l02142"></a>02142 <span class="comment">     * This is a remote reference.</span>
<a name="l02143" id="l02143"></a>02143 <span class="comment">     */</span>
<a name="l02144" id="l02144"></a>02144     <span class="keywordflow">else</span> {
<a name="l02145" id="l02145"></a>02145         u_int           theirBoots, theirTime, theirLastTime;
<a name="l02146" id="l02146"></a>02146         u_int           time_difference;
<a name="l02147" id="l02147"></a>02147 
<a name="l02148" id="l02148"></a>02148         <span class=
"keywordflow">if</span> (get_enginetime_ex(secEngineID, secEngineIDLen,
<a name="l02149" id="l02149"></a>02149                               &amp;theirBoots, &amp;theirTime,
<a name="l02150" id="l02150"></a>02150                               &amp;theirLastTime, TRUE)
<a name="l02151" id="l02151"></a>02151             != SNMPERR_SUCCESS) {
<a name="l02152" id="l02152"></a>02152             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>,
<a name="l02153" id="l02153"></a>02153                         <span class=
"stringliteral">"Failed to get remote engine's times."</span>));
<a name="l02154" id="l02154"></a>02154 
<a name="l02155" id="l02155"></a>02155             *error = SNMPERR_USM_GENERICERROR;
<a name="l02156" id="l02156"></a>02156             <span class="keywordflow">return</span> -1;
<a name="l02157" id="l02157"></a>02157         }
<a name="l02158" id="l02158"></a>02158 
<a name="l02159" id="l02159"></a>02159         time_difference = theirTime &gt; time_uint ?
<a name="l02160" id="l02160"></a>02160             theirTime - time_uint : time_uint - theirTime;
<a name="l02161" id="l02161"></a>02161 
<a name="l02162" id="l02162"></a>02162 
<a name="l02163" id="l02163"></a>02163         <span class="comment">/*</span>
<a name="l02164" id="l02164"></a>02164 <span class="comment">         * XXX  Contrary to the pseudocode:</span>
<a name="l02165" id="l02165"></a>02165 <span class="comment">         *      See if boots is invalid first.</span>
<a name="l02166" id="l02166"></a>02166 <span class="comment">         */</span>
<a name="l02167" id="l02167"></a>02167         <span class=
"keywordflow">if</span> (theirBoots == ENGINEBOOT_MAX || theirBoots &gt; boots_uint) {
<a name="l02168" id="l02168"></a>02168             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Remote boot count invalid."</span>));
<a name="l02169" id="l02169"></a>02169 
<a name="l02170" id="l02170"></a>02170             *error = SNMPERR_USM_NOTINTIMEWINDOW;
<a name="l02171" id="l02171"></a>02171             <span class="keywordflow">return</span> -1;
<a name="l02172" id="l02172"></a>02172         }
<a name="l02173" id="l02173"></a>02173 
<a name="l02174" id="l02174"></a>02174 
<a name="l02175" id="l02175"></a>02175         <span class="comment">/*</span>
<a name="l02176" id="l02176"></a>02176 <span class=
"comment">         * Boots is ok, see if the boots is the same but the time</span>
<a name="l02177" id="l02177"></a>02177 <span class="comment">         * is old.</span>
<a name="l02178" id="l02178"></a>02178 <span class="comment">         */</span>
<a name="l02179" id="l02179"></a>02179         <span class=
"keywordflow">if</span> (theirBoots == boots_uint &amp;&amp; time_uint &lt; theirLastTime) {
<a name="l02180" id="l02180"></a>02180             <span class="keywordflow">if</span> (time_difference &gt; USM_TIME_WINDOW) {
<a name="l02181" id="l02181"></a>02181                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Message too old."</span>));
<a name="l02182" id="l02182"></a>02182                 *error = SNMPERR_USM_NOTINTIMEWINDOW;
<a name="l02183" id="l02183"></a>02183                 <span class="keywordflow">return</span> -1;
<a name="l02184" id="l02184"></a>02184             }
<a name="l02185" id="l02185"></a>02185 
<a name="l02186" id="l02186"></a>02186             <span class="keywordflow">else</span> {              <span class=
"comment">/* Old, but acceptable */</span>
<a name="l02187" id="l02187"></a>02187 
<a name="l02188" id="l02188"></a>02188                 *error = SNMPERR_SUCCESS;
<a name="l02189" id="l02189"></a>02189                 <span class="keywordflow">return</span> 0;
<a name="l02190" id="l02190"></a>02190             }
<a name="l02191" id="l02191"></a>02191         }
<a name="l02192" id="l02192"></a>02192 
<a name="l02193" id="l02193"></a>02193 
<a name="l02194" id="l02194"></a>02194         <span class="comment">/*</span>
<a name="l02195" id="l02195"></a>02195 <span class="comment">         * Message is ok, either boots has been advanced, or</span>
<a name="l02196" id="l02196"></a>02196 <span class="comment">         * time is greater than before with the same boots.</span>
<a name="l02197" id="l02197"></a>02197 <span class="comment">         */</span>
<a name="l02198" id="l02198"></a>02198 
<a name="l02199" id="l02199"></a>02199         <span class="keywordflow">if</span> (set_enginetime(secEngineID, secEngineIDLen,
<a name="l02200" id="l02200"></a>02200                            boots_uint, time_uint, TRUE)
<a name="l02201" id="l02201"></a>02201             != SNMPERR_SUCCESS) {
<a name="l02202" id="l02202"></a>02202             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>,
<a name="l02203" id="l02203"></a>02203                         <span class=
"stringliteral">"Failed updating remote boot/time."</span>));
<a name="l02204" id="l02204"></a>02204             *error = SNMPERR_USM_GENERICERROR;
<a name="l02205" id="l02205"></a>02205             <span class="keywordflow">return</span> -1;
<a name="l02206" id="l02206"></a>02206         }
<a name="l02207" id="l02207"></a>02207 
<a name="l02208" id="l02208"></a>02208         *error = SNMPERR_SUCCESS;
<a name="l02209" id="l02209"></a>02209         <span class="keywordflow">return</span> 0;               <span class=
"comment">/* Fresh message and time updated */</span>
<a name="l02210" id="l02210"></a>02210 
<a name="l02211" id="l02211"></a>02211     }                           <span class=
"comment">/* endif -- local or remote time reference. */</span>
<a name="l02212" id="l02212"></a>02212 
<a name="l02213" id="l02213"></a>02213 
<a name="l02214" id="l02214"></a>02214 }                               <span class=
"comment">/* end usm_check_and_update_timeliness() */</span>
<a name="l02215" id="l02215"></a>02215 
<a name="l02216" id="l02216"></a>02216 
<a name="l02217" id="l02217"></a>02217 
<a name="l02218" id="l02218"></a>02218 <span class="keywordtype">int</span>
<a name="l02219" id="l02219"></a>02219 usm_secmod_process_in_msg(<span class="keyword">struct</span> <a class="code" href=
"structsnmp__secmod__incoming__params.html">snmp_secmod_incoming_params</a> *parms)
<a name="l02220" id="l02220"></a>02220 {
<a name="l02221" id="l02221"></a>02221     <span class="keywordflow">if</span> (!parms)
<a name="l02222" id="l02222"></a>02222         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l02223" id="l02223"></a>02223 
<a name="l02224" id="l02224"></a>02224     <span class="keywordflow">return</span> usm_process_in_msg(parms-&gt;msgProcModel,
<a name="l02225" id="l02225"></a>02225                               parms-&gt;maxMsgSize,
<a name="l02226" id="l02226"></a>02226                               parms-&gt;secParams,
<a name="l02227" id="l02227"></a>02227                               parms-&gt;secModel,
<a name="l02228" id="l02228"></a>02228                               parms-&gt;secLevel,
<a name="l02229" id="l02229"></a>02229                               parms-&gt;wholeMsg,
<a name="l02230" id="l02230"></a>02230                               parms-&gt;wholeMsgLen,
<a name="l02231" id="l02231"></a>02231                               parms-&gt;secEngineID,
<a name="l02232" id="l02232"></a>02232                               parms-&gt;secEngineIDLen,
<a name="l02233" id="l02233"></a>02233                               parms-&gt;secName,
<a name="l02234" id="l02234"></a>02234                               parms-&gt;secNameLen,
<a name="l02235" id="l02235"></a>02235                               parms-&gt;scopedPdu,
<a name="l02236" id="l02236"></a>02236                               parms-&gt;scopedPduLen,
<a name="l02237" id="l02237"></a>02237                               parms-&gt;maxSizeResponse,
<a name="l02238" id="l02238"></a>02238                               parms-&gt;secStateRef,
<a name="l02239" id="l02239"></a>02239                               parms-&gt;sess, parms-&gt;msg_flags);
<a name="l02240" id="l02240"></a>02240 }
<a name="l02241" id="l02241"></a>02241 
<a name="l02242" id="l02242"></a>02242 <span class=
"comment">/*******************************************************************-o-******</span>
<a name="l02243" id="l02243"></a>02243 <span class="comment"> * usm_process_in_msg</span>
<a name="l02244" id="l02244"></a>02244 <span class="comment"> *</span>
<a name="l02245" id="l02245"></a>02245 <span class="comment"> * Parameters:</span>
<a name="l02246" id="l02246"></a>02246 <span class="comment"> *      (See list below...)</span>
<a name="l02247" id="l02247"></a>02247 <span class="comment"> *      </span>
<a name="l02248" id="l02248"></a>02248 <span class="comment"> * Returns:</span>
<a name="l02249" id="l02249"></a>02249 <span class="comment"> *      SNMPERR_SUCCESS                 On success.</span>
<a name="l02250" id="l02250"></a>02250 <span class="comment"> *      SNMPERR_USM_AUTHENTICATIONFAILURE</span>
<a name="l02251" id="l02251"></a>02251 <span class="comment"> *      SNMPERR_USM_DECRYPTIONERROR</span>
<a name="l02252" id="l02252"></a>02252 <span class="comment"> *      SNMPERR_USM_GENERICERROR</span>
<a name="l02253" id="l02253"></a>02253 <span class="comment"> *      SNMPERR_USM_PARSEERROR</span>
<a name="l02254" id="l02254"></a>02254 <span class="comment"> *      SNMPERR_USM_UNKNOWNENGINEID</span>
<a name="l02255" id="l02255"></a>02255 <span class="comment"> *      SNMPERR_USM_PARSEERROR</span>
<a name="l02256" id="l02256"></a>02256 <span class="comment"> *      SNMPERR_USM_UNKNOWNSECURITYNAME</span>
<a name="l02257" id="l02257"></a>02257 <span class="comment"> *      SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL</span>
<a name="l02258" id="l02258"></a>02258 <span class="comment"> *</span>
<a name="l02259" id="l02259"></a>02259 <span class="comment"> *</span>
<a name="l02260" id="l02260"></a>02260 <span class=
"comment"> * ASSUMES size of decrypt_buf will always be &gt;= size of encrypted sPDU.</span>
<a name="l02261" id="l02261"></a>02261 <span class="comment"> *</span>
<a name="l02262" id="l02262"></a>02262 <span class=
"comment"> * FIX  Memory leaks if secStateRef is allocated and a return occurs</span>
<a name="l02263" id="l02263"></a>02263 <span class="comment"> *      without cleaning up.  May contain secrets...</span>
<a name="l02264" id="l02264"></a>02264 <span class="comment"> */</span>
<a name="l02265" id="l02265"></a>02265 <span class="keywordtype">int</span>
<a name="l02266" id="l02266"></a>02266 usm_process_in_msg(<span class="keywordtype">int</span> msgProcModel,    <span class=
"comment">/* (UNUSED) */</span>
<a name="l02267" id="l02267"></a>02267                    <span class="keywordtype">size_t</span> maxMsgSize,   <span class=
"comment">/* IN     - Used to calc maxSizeResponse.  */</span>
<a name="l02268" id="l02268"></a>02268                    u_char * secParams,  <span class=
"comment">/* IN     - BER encoded securityParameters. */</span>
<a name="l02269" id="l02269"></a>02269                    <span class="keywordtype">int</span> secModel,        <span class=
"comment">/* (UNUSED) */</span>
<a name="l02270" id="l02270"></a>02270                    <span class="keywordtype">int</span> secLevel,        <span class=
"comment">/* IN     - AuthNoPriv, authPriv etc.      */</span>
<a name="l02271" id="l02271"></a>02271                    u_char * wholeMsg,   <span class=
"comment">/* IN     - Original v3 message.           */</span>
<a name="l02272" id="l02272"></a>02272                    <span class="keywordtype">size_t</span> wholeMsgLen,  <span class=
"comment">/* IN     - Msg length.                    */</span>
<a name="l02273" id="l02273"></a>02273                    u_char * secEngineID,        <span class=
"comment">/* OUT    - Pointer snmpEngineID.          */</span>
<a name="l02274" id="l02274"></a>02274                    <span class=
"keywordtype">size_t</span> * secEngineIDLen,     <span class="comment">/* IN/OUT - Len available, len returned.   */</span>
<a name="l02275" id="l02275"></a>02275                    <span class="comment">/*</span>
<a name="l02276" id="l02276"></a>02276 <span class="comment">                    * NOTE: Memory provided by caller.      </span>
<a name="l02277" id="l02277"></a>02277 <span class="comment">                    */</span>
<a name="l02278" id="l02278"></a>02278                    <span class="keywordtype">char</span> *secName,       <span class=
"comment">/* OUT    - Pointer to securityName.       */</span>
<a name="l02279" id="l02279"></a>02279                    <span class="keywordtype">size_t</span> * secNameLen, <span class=
"comment">/* IN/OUT - Len available, len returned.   */</span>
<a name="l02280" id="l02280"></a>02280                    u_char ** scopedPdu, <span class=
"comment">/* OUT    - Pointer to plaintext scopedPdu. */</span>
<a name="l02281" id="l02281"></a>02281                    <span class=
"keywordtype">size_t</span> * scopedPduLen,       <span class="comment">/* IN/OUT - Len available, len returned.   */</span>
<a name="l02282" id="l02282"></a>02282                    <span class=
"keywordtype">size_t</span> * maxSizeResponse,    <span class="comment">/* OUT    - Max size of Response PDU.      */</span>
<a name="l02283" id="l02283"></a>02283                    <span class="keywordtype">void</span> **secStateRf,   <span class=
"comment">/* OUT    - Ref to security state.         */</span>
<a name="l02284" id="l02284"></a>02284                    <a class="code" href="structsnmp__session.html" title=
"The snmp session structure.">netsnmp_session</a> * sess,      <span class=
"comment">/* IN     - session which got the message  */</span>
<a name="l02285" id="l02285"></a>02285                    u_char msg_flags)
<a name="l02286" id="l02286"></a>02286 {                               <span class=
"comment">/* IN     - v3 Message flags.              */</span>
<a name="l02287" id="l02287"></a>02287     <span class="keywordtype">size_t</span>          remaining = wholeMsgLen - (u_int)
<a name="l02288" id="l02288"></a>02288         ((u_long) * secParams - (u_long) * wholeMsg);
<a name="l02289" id="l02289"></a>02289     u_int           boots_uint;
<a name="l02290" id="l02290"></a>02290     u_int           time_uint;
<a name="l02291" id="l02291"></a>02291 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l02292" id="l02292"></a>02292     u_int           net_boots, net_time;
<a name="l02293" id="l02293"></a>02293 <span class="preprocessor">#endif</span>
<a name="l02294" id="l02294"></a>02294     u_char          signature[BYTESIZE(USM_MAX_KEYEDHASH_LENGTH)];
<a name="l02295" id="l02295"></a>02295     <span class=
"keywordtype">size_t</span>          signature_length = BYTESIZE(USM_MAX_KEYEDHASH_LENGTH);
<a name="l02296" id="l02296"></a>02296     u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];
<a name="l02297" id="l02297"></a>02297     <span class=
"keywordtype">size_t</span>          salt_length = BYTESIZE(USM_MAX_SALT_LENGTH);
<a name="l02298" id="l02298"></a>02298     u_char          iv[BYTESIZE(USM_MAX_SALT_LENGTH)];
<a name="l02299" id="l02299"></a>02299     u_int           iv_length = BYTESIZE(USM_MAX_SALT_LENGTH);
<a name="l02300" id="l02300"></a>02300     u_char         *data_ptr;
<a name="l02301" id="l02301"></a>02301     u_char         *value_ptr;
<a name="l02302" id="l02302"></a>02302     u_char          type_value;
<a name="l02303" id="l02303"></a>02303     u_char         *end_of_overhead = NULL;
<a name="l02304" id="l02304"></a>02304     <span class="keywordtype">int</span>             error;
<a name="l02305" id="l02305"></a>02305     <span class="keywordtype">int</span>             i, rc = 0;
<a name="l02306" id="l02306"></a>02306     <span class="keyword">struct </span><a class="code" href=
"structusmStateReference.html">usmStateReference</a> **secStateRef =
<a name="l02307" id="l02307"></a>02307         (<span class="keyword">struct </span><a class="code" href=
"structusmStateReference.html">usmStateReference</a> **) secStateRf;
<a name="l02308" id="l02308"></a>02308 
<a name="l02309" id="l02309"></a>02309     <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *user;
<a name="l02310" id="l02310"></a>02310 
<a name="l02311" id="l02311"></a>02311 
<a name="l02312" id="l02312"></a>02312     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"USM processing begun...\n"</span>));
<a name="l02313" id="l02313"></a>02313 
<a name="l02314" id="l02314"></a>02314 
<a name="l02315" id="l02315"></a>02315     <span class="keywordflow">if</span> (secStateRef) {
<a name="l02316" id="l02316"></a>02316         usm_free_usmStateReference(*secStateRef);
<a name="l02317" id="l02317"></a>02317         *secStateRef = usm_malloc_usmStateReference();
<a name="l02318" id="l02318"></a>02318         <span class="keywordflow">if</span> (*secStateRef == NULL) {
<a name="l02319" id="l02319"></a>02319             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Out of memory.\n"</span>));
<a name="l02320" id="l02320"></a>02320             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02321" id="l02321"></a>02321         }
<a name="l02322" id="l02322"></a>02322     }
<a name="l02323" id="l02323"></a>02323 
<a name="l02324" id="l02324"></a>02324 
<a name="l02325" id="l02325"></a>02325     <span class="comment">/*</span>
<a name="l02326" id="l02326"></a>02326 <span class="comment">     * Make sure the *secParms is an OCTET STRING.</span>
<a name="l02327" id="l02327"></a>02327 <span class="comment">     * Extract the user name, engine ID, and security level.</span>
<a name="l02328" id="l02328"></a>02328 <span class="comment">     */</span>
<a name="l02329" id="l02329"></a>02329     <span class=
"keywordflow">if</span> ((rc = usm_parse_security_parameters(secParams, remaining,
<a name="l02330" id="l02330"></a>02330                                             secEngineID, secEngineIDLen,
<a name="l02331" id="l02331"></a>02331                                             &amp;boots_uint, &amp;time_uint,
<a name="l02332" id="l02332"></a>02332                                             secName, secNameLen,
<a name="l02333" id="l02333"></a>02333                                             signature, &amp;signature_length,
<a name="l02334" id="l02334"></a>02334                                             salt, &amp;salt_length,
<a name="l02335" id="l02335"></a>02335                                             &amp;data_ptr)) &lt; 0) {
<a name="l02336" id="l02336"></a>02336         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Parsing failed (rc %d).\n"</span>, rc));
<a name="l02337" id="l02337"></a>02337         <span class="keywordflow">if</span> (rc == -2) {
<a name="l02338" id="l02338"></a>02338             <span class="comment">/*</span>
<a name="l02339" id="l02339"></a>02339 <span class="comment">             * This indicates a decryptionError.  </span>
<a name="l02340" id="l02340"></a>02340 <span class="comment">             */</span>
<a name="l02341" id="l02341"></a>02341             <span class=
"keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS) ==
<a name="l02342" id="l02342"></a>02342                 0) {
<a name="l02343" id="l02343"></a>02343                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>,
<a name="l02344" id="l02344"></a>02344                             <span class=
"stringliteral">"Failed to increment statistic."</span>));
<a name="l02345" id="l02345"></a>02345             }
<a name="l02346" id="l02346"></a>02346             <span class="keywordflow">return</span> SNMPERR_USM_DECRYPTIONERROR;
<a name="l02347" id="l02347"></a>02347         }
<a name="l02348" id="l02348"></a>02348         <span class=
"keywordflow">if</span> (snmp_increment_statistic(STAT_SNMPINASNPARSEERRS) == 0) {
<a name="l02349" id="l02349"></a>02349             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Failed to increment statistic."</span>));
<a name="l02350" id="l02350"></a>02350         }
<a name="l02351" id="l02351"></a>02351         <span class="keywordflow">return</span> SNMPERR_USM_PARSEERROR;
<a name="l02352" id="l02352"></a>02352     }
<a name="l02353" id="l02353"></a>02353 
<a name="l02354" id="l02354"></a>02354     <span class="comment">/*</span>
<a name="l02355" id="l02355"></a>02355 <span class="comment">     * RFC 2574 section 8.3.2</span>
<a name="l02356" id="l02356"></a>02356 <span class=
"comment">     * 1)  If the privParameters field is not an 8-octet OCTET STRING,</span>
<a name="l02357" id="l02357"></a>02357 <span class=
"comment">     * then an error indication (decryptionError) is returned to the</span>
<a name="l02358" id="l02358"></a>02358 <span class="comment">     * calling module.</span>
<a name="l02359" id="l02359"></a>02359 <span class="comment">     */</span>
<a name="l02360" id="l02360"></a>02360     <span class=
"keywordflow">if</span> ((secLevel == SNMP_SEC_LEVEL_AUTHPRIV) &amp;&amp; (salt_length != 8)) {
<a name="l02361" id="l02361"></a>02361         <span class=
"keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS) == 
<a name="l02362" id="l02362"></a>02362             0) {
<a name="l02363" id="l02363"></a>02363             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Failed increment statistic."</span>));
<a name="l02364" id="l02364"></a>02364         }
<a name="l02365" id="l02365"></a>02365         <span class="keywordflow">return</span> SNMPERR_USM_DECRYPTIONERROR;
<a name="l02366" id="l02366"></a>02366     }
<a name="l02367" id="l02367"></a>02367 
<a name="l02368" id="l02368"></a>02368     <span class="keywordflow">if</span> (secLevel != SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l02369" id="l02369"></a>02369         <span class="comment">/*</span>
<a name="l02370" id="l02370"></a>02370 <span class="comment">         * pull these out now so reports can use them </span>
<a name="l02371" id="l02371"></a>02371 <span class="comment">         */</span>
<a name="l02372" id="l02372"></a>02372         *scopedPdu = data_ptr;
<a name="l02373" id="l02373"></a>02373         *scopedPduLen = wholeMsgLen - (data_ptr - wholeMsg);
<a name="l02374" id="l02374"></a>02374         end_of_overhead = data_ptr;
<a name="l02375" id="l02375"></a>02375     }
<a name="l02376" id="l02376"></a>02376 
<a name="l02377" id="l02377"></a>02377     <span class="keywordflow">if</span> (secStateRef) {
<a name="l02378" id="l02378"></a>02378         <span class="comment">/*</span>
<a name="l02379" id="l02379"></a>02379 <span class="comment">         * Cache the name, engine ID, and security level,</span>
<a name="l02380" id="l02380"></a>02380 <span class="comment">         * * per step 2 (section 3.2)</span>
<a name="l02381" id="l02381"></a>02381 <span class="comment">         */</span>
<a name="l02382" id="l02382"></a>02382         <span class="keywordflow">if</span> (usm_set_usmStateReference_name
<a name="l02383" id="l02383"></a>02383             (*secStateRef, secName, *secNameLen) == -1) {
<a name="l02384" id="l02384"></a>02384             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Couldn't cache name."</span>));
<a name="l02385" id="l02385"></a>02385             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02386" id="l02386"></a>02386         }
<a name="l02387" id="l02387"></a>02387 
<a name="l02388" id="l02388"></a>02388         <span class="keywordflow">if</span> (usm_set_usmStateReference_engine_id
<a name="l02389" id="l02389"></a>02389             (*secStateRef, secEngineID, *secEngineIDLen) == -1) {
<a name="l02390" id="l02390"></a>02390             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Couldn't cache engine id."</span>));
<a name="l02391" id="l02391"></a>02391             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02392" id="l02392"></a>02392         }
<a name="l02393" id="l02393"></a>02393 
<a name="l02394" id="l02394"></a>02394         <span class=
"keywordflow">if</span> (usm_set_usmStateReference_sec_level(*secStateRef, secLevel) ==
<a name="l02395" id="l02395"></a>02395             -1) {
<a name="l02396" id="l02396"></a>02396             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Couldn't cache security level."</span>));
<a name="l02397" id="l02397"></a>02397             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02398" id="l02398"></a>02398         }
<a name="l02399" id="l02399"></a>02399     }
<a name="l02400" id="l02400"></a>02400 
<a name="l02401" id="l02401"></a>02401 
<a name="l02402" id="l02402"></a>02402     <span class="comment">/*</span>
<a name="l02403" id="l02403"></a>02403 <span class="comment">     * Locate the engine ID record.</span>
<a name="l02404" id="l02404"></a>02404 <span class=
"comment">     * If it is unknown, then either create one or note this as an error.</span>
<a name="l02405" id="l02405"></a>02405 <span class="comment">     */</span>
<a name="l02406" id="l02406"></a>02406     <span class="keywordflow">if</span> ((sess &amp;&amp; (sess-&gt;<a class="code" href=
"structsnmp__session.html#a9284be33e69062f7f90723a4ee04409b" title=
"are we the authoritative engine?">isAuthoritative</a> == SNMP_SESS_AUTHORITATIVE ||
<a name="l02407" id="l02407"></a>02407                   (sess-&gt;<a class="code" href=
"structsnmp__session.html#a9284be33e69062f7f90723a4ee04409b" title=
"are we the authoritative engine?">isAuthoritative</a> == SNMP_SESS_UNKNOWNAUTH &amp;&amp;
<a name="l02408" id="l02408"></a>02408                    (msg_flags &amp; SNMP_MSG_FLAG_RPRT_BIT)))) ||
<a name="l02409" id="l02409"></a>02409         (!sess &amp;&amp; (msg_flags &amp; SNMP_MSG_FLAG_RPRT_BIT))) {
<a name="l02410" id="l02410"></a>02410         <span class=
"keywordflow">if</span> (ISENGINEKNOWN(secEngineID, *secEngineIDLen) == FALSE) {
<a name="l02411" id="l02411"></a>02411             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Unknown Engine ID.\n"</span>));
<a name="l02412" id="l02412"></a>02412             <span class=
"keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSUNKNOWNENGINEIDS) ==
<a name="l02413" id="l02413"></a>02413                 0) {
<a name="l02414" id="l02414"></a>02414                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>,
<a name="l02415" id="l02415"></a>02415                             <span class=
"stringliteral">"Failed to increment statistic."</span>));
<a name="l02416" id="l02416"></a>02416             }
<a name="l02417" id="l02417"></a>02417             <span class="keywordflow">return</span> SNMPERR_USM_UNKNOWNENGINEID;
<a name="l02418" id="l02418"></a>02418         }
<a name="l02419" id="l02419"></a>02419     } <span class="keywordflow">else</span> {
<a name="l02420" id="l02420"></a>02420         <span class=
"keywordflow">if</span> (ENSURE_ENGINE_RECORD(secEngineID, *secEngineIDLen)
<a name="l02421" id="l02421"></a>02421             != SNMPERR_SUCCESS) {
<a name="l02422" id="l02422"></a>02422             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Couldn't ensure engine record."</span>));
<a name="l02423" id="l02423"></a>02423             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02424" id="l02424"></a>02424         }
<a name="l02425" id="l02425"></a>02425 
<a name="l02426" id="l02426"></a>02426     }
<a name="l02427" id="l02427"></a>02427 
<a name="l02428" id="l02428"></a>02428 
<a name="l02429" id="l02429"></a>02429     <span class="comment">/*</span>
<a name="l02430" id="l02430"></a>02430 <span class="comment">     * Locate the User record.</span>
<a name="l02431" id="l02431"></a>02431 <span class=
"comment">     * If the user/engine ID is unknown, report this as an error.</span>
<a name="l02432" id="l02432"></a>02432 <span class="comment">     */</span>
<a name="l02433" id="l02433"></a>02433     <span class=
"keywordflow">if</span> ((user = usm_get_user_from_list(secEngineID, *secEngineIDLen,
<a name="l02434" id="l02434"></a>02434                                        secName, userList,
<a name="l02435" id="l02435"></a>02435                                        (((sess &amp;&amp; sess-&gt;<a class="code" href=
"structsnmp__session.html#a9284be33e69062f7f90723a4ee04409b" title="are we the authoritative engine?">isAuthoritative</a> ==
<a name="l02436" id="l02436"></a>02436                                           SNMP_SESS_AUTHORITATIVE) ||
<a name="l02437" id="l02437"></a>02437                                          (!sess)) ? 0 : 1)))
<a name="l02438" id="l02438"></a>02438         == NULL) {
<a name="l02439" id="l02439"></a>02439         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Unknown User(%s)\n"</span>, secName));
<a name="l02440" id="l02440"></a>02440         <span class=
"keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSUNKNOWNUSERNAMES) == 0) {
<a name="l02441" id="l02441"></a>02441             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Failed to increment statistic."</span>));
<a name="l02442" id="l02442"></a>02442         }
<a name="l02443" id="l02443"></a>02443         <span class="keywordflow">return</span> SNMPERR_USM_UNKNOWNSECURITYNAME;
<a name="l02444" id="l02444"></a>02444     }
<a name="l02445" id="l02445"></a>02445 
<a name="l02446" id="l02446"></a>02446 
<a name="l02447" id="l02447"></a>02447     <span class="comment">/*</span>
<a name="l02448" id="l02448"></a>02448 <span class="comment">     * Make sure the security level is appropriate.</span>
<a name="l02449" id="l02449"></a>02449 <span class="comment">     */</span>
<a name="l02450" id="l02450"></a>02450     <span class="keywordflow">if</span> (usm_check_secLevel(secLevel, user) == 1) {
<a name="l02451" id="l02451"></a>02451         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Unsupported Security Level (%d).\n"</span>,
<a name="l02452" id="l02452"></a>02452                     secLevel));
<a name="l02453" id="l02453"></a>02453         <span class="keywordflow">if</span> (snmp_increment_statistic
<a name="l02454" id="l02454"></a>02454             (STAT_USMSTATSUNSUPPORTEDSECLEVELS) == 0) {
<a name="l02455" id="l02455"></a>02455             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Failed to increment statistic."</span>));
<a name="l02456" id="l02456"></a>02456         }
<a name="l02457" id="l02457"></a>02457         <span class="keywordflow">return</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;
<a name="l02458" id="l02458"></a>02458     }
<a name="l02459" id="l02459"></a>02459 
<a name="l02460" id="l02460"></a>02460 
<a name="l02461" id="l02461"></a>02461     <span class="comment">/*</span>
<a name="l02462" id="l02462"></a>02462 <span class="comment">     * Check the authentication credentials of the message.</span>
<a name="l02463" id="l02463"></a>02463 <span class="comment">     */</span>
<a name="l02464" id="l02464"></a>02464     <span class="keywordflow">if</span> (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
<a name="l02465" id="l02465"></a>02465         || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l02466" id="l02466"></a>02466         <span class=
"keywordflow">if</span> (sc_check_keyed_hash(user-&gt;authProtocol, user-&gt;authProtocolLen,
<a name="l02467" id="l02467"></a>02467                                 user-&gt;authKey, user-&gt;authKeyLen,
<a name="l02468" id="l02468"></a>02468                                 wholeMsg, wholeMsgLen,
<a name="l02469" id="l02469"></a>02469                                 signature, signature_length)
<a name="l02470" id="l02470"></a>02470             != SNMP_ERR_NOERROR) {
<a name="l02471" id="l02471"></a>02471             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Verification failed.\n"</span>));
<a name="l02472" id="l02472"></a>02472             <span class=
"keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSWRONGDIGESTS) == 0) {
<a name="l02473" id="l02473"></a>02473                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>,
<a name="l02474" id="l02474"></a>02474                             <span class=
"stringliteral">"Failed to increment statistic."</span>));
<a name="l02475" id="l02475"></a>02475             }
<a name="l02476" id="l02476"></a>02476             <a class="code" href=
"group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title=
"This snmp logging function allows variable argument list given the specified format...">snmp_log</a>(LOG_WARNING, <span class=
"stringliteral">"Authentication failed for %s\n"</span>,
<a name="l02477" id="l02477"></a>02477                                 user-&gt;name);
<a name="l02478" id="l02478"></a>02478             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
<a name="l02479" id="l02479"></a>02479         }
<a name="l02480" id="l02480"></a>02480 
<a name="l02481" id="l02481"></a>02481         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Verification succeeded.\n"</span>));
<a name="l02482" id="l02482"></a>02482     }
<a name="l02483" id="l02483"></a>02483 
<a name="l02484" id="l02484"></a>02484 
<a name="l02485" id="l02485"></a>02485     <span class="comment">/*</span>
<a name="l02486" id="l02486"></a>02486 <span class=
"comment">     * Steps 10-11  user is already set - relocated before timeliness </span>
<a name="l02487" id="l02487"></a>02487 <span class=
"comment">     * check in case it fails - still save user data for response.</span>
<a name="l02488" id="l02488"></a>02488 <span class="comment">     *</span>
<a name="l02489" id="l02489"></a>02489 <span class="comment">     * Cache the keys and protocol oids, per step 11 (s3.2).</span>
<a name="l02490" id="l02490"></a>02490 <span class="comment">     */</span>
<a name="l02491" id="l02491"></a>02491     <span class="keywordflow">if</span> (secStateRef) {
<a name="l02492" id="l02492"></a>02492         <span class=
"keywordflow">if</span> (usm_set_usmStateReference_auth_protocol(*secStateRef,
<a name="l02493" id="l02493"></a>02493                                                     user-&gt;authProtocol,
<a name="l02494" id="l02494"></a>02494                                                     user-&gt;
<a name="l02495" id="l02495"></a>02495                                                     authProtocolLen) ==
<a name="l02496" id="l02496"></a>02496             -1) {
<a name="l02497" id="l02497"></a>02497             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>,
<a name="l02498" id="l02498"></a>02498                         <span class=
"stringliteral">"Couldn't cache authentication protocol."</span>));
<a name="l02499" id="l02499"></a>02499             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02500" id="l02500"></a>02500         }
<a name="l02501" id="l02501"></a>02501 
<a name="l02502" id="l02502"></a>02502         <span class=
"keywordflow">if</span> (usm_set_usmStateReference_auth_key(*secStateRef,
<a name="l02503" id="l02503"></a>02503                                                user-&gt;authKey,
<a name="l02504" id="l02504"></a>02504                                                user-&gt;authKeyLen) == -1) {
<a name="l02505" id="l02505"></a>02505             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>,
<a name="l02506" id="l02506"></a>02506                         <span class=
"stringliteral">"Couldn't cache authentication key."</span>));
<a name="l02507" id="l02507"></a>02507             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02508" id="l02508"></a>02508         }
<a name="l02509" id="l02509"></a>02509 
<a name="l02510" id="l02510"></a>02510         <span class=
"keywordflow">if</span> (usm_set_usmStateReference_priv_protocol(*secStateRef,
<a name="l02511" id="l02511"></a>02511                                                     user-&gt;privProtocol,
<a name="l02512" id="l02512"></a>02512                                                     user-&gt;
<a name="l02513" id="l02513"></a>02513                                                     privProtocolLen) ==
<a name="l02514" id="l02514"></a>02514             -1) {
<a name="l02515" id="l02515"></a>02515             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>,
<a name="l02516" id="l02516"></a>02516                         <span class=
"stringliteral">"Couldn't cache privacy protocol."</span>));
<a name="l02517" id="l02517"></a>02517             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02518" id="l02518"></a>02518         }
<a name="l02519" id="l02519"></a>02519 
<a name="l02520" id="l02520"></a>02520         <span class=
"keywordflow">if</span> (usm_set_usmStateReference_priv_key(*secStateRef,
<a name="l02521" id="l02521"></a>02521                                                user-&gt;privKey,
<a name="l02522" id="l02522"></a>02522                                                user-&gt;privKeyLen) == -1) {
<a name="l02523" id="l02523"></a>02523             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Couldn't cache privacy key."</span>));
<a name="l02524" id="l02524"></a>02524             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02525" id="l02525"></a>02525         }
<a name="l02526" id="l02526"></a>02526     }
<a name="l02527" id="l02527"></a>02527 
<a name="l02528" id="l02528"></a>02528 
<a name="l02529" id="l02529"></a>02529     <span class="comment">/*</span>
<a name="l02530" id="l02530"></a>02530 <span class="comment">     * Perform the timeliness/time manager functions.</span>
<a name="l02531" id="l02531"></a>02531 <span class="comment">     */</span>
<a name="l02532" id="l02532"></a>02532     <span class="keywordflow">if</span> (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
<a name="l02533" id="l02533"></a>02533         || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l02534" id="l02534"></a>02534         <span class=
"keywordflow">if</span> (usm_check_and_update_timeliness(secEngineID, *secEngineIDLen,
<a name="l02535" id="l02535"></a>02535                                             boots_uint, time_uint,
<a name="l02536" id="l02536"></a>02536                                             &amp;error) == -1) {
<a name="l02537" id="l02537"></a>02537             <span class="keywordflow">return</span> error;
<a name="l02538" id="l02538"></a>02538         }
<a name="l02539" id="l02539"></a>02539     }
<a name="l02540" id="l02540"></a>02540 <span class=
"preprocessor">#ifdef                                                  LCD_TIME_SYNC_OPT</span>
<a name="l02541" id="l02541"></a>02541     <span class="comment">/*</span>
<a name="l02542" id="l02542"></a>02542 <span class=
"comment">     * Cache the unauthenticated time to use in case we don't have</span>
<a name="l02543" id="l02543"></a>02543 <span class=
"comment">     * anything better - this guess will be no worse than (0,0)</span>
<a name="l02544" id="l02544"></a>02544 <span class="comment">     * that we normally use.</span>
<a name="l02545" id="l02545"></a>02545 <span class="comment">     */</span>
<a name="l02546" id="l02546"></a>02546     <span class="keywordflow">else</span> {
<a name="l02547" id="l02547"></a>02547         set_enginetime(secEngineID, *secEngineIDLen,
<a name="l02548" id="l02548"></a>02548                        boots_uint, time_uint, FALSE);
<a name="l02549" id="l02549"></a>02549     }
<a name="l02550" id="l02550"></a>02550 <span class="preprocessor">#endif                          </span><span class=
"comment">/* LCD_TIME_SYNC_OPT */</span>
<a name="l02551" id="l02551"></a>02551 
<a name="l02552" id="l02552"></a>02552 
<a name="l02553" id="l02553"></a>02553     <span class="comment">/*</span>
<a name="l02554" id="l02554"></a>02554 <span class="comment">     * If needed, decrypt the scoped PDU.</span>
<a name="l02555" id="l02555"></a>02555 <span class="comment">     */</span>
<a name="l02556" id="l02556"></a>02556     <span class="keywordflow">if</span> (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l02557" id="l02557"></a>02557         remaining = wholeMsgLen - (data_ptr - wholeMsg);
<a name="l02558" id="l02558"></a>02558 
<a name="l02559" id="l02559"></a>02559         <span class=
"keywordflow">if</span> ((value_ptr = asn_parse_sequence(data_ptr, &amp;remaining,
<a name="l02560" id="l02560"></a>02560                                             &amp;type_value,
<a name="l02561" id="l02561"></a>02561                                             (ASN_UNIVERSAL | ASN_PRIMITIVE
<a name="l02562" id="l02562"></a>02562                                              | ASN_OCTET_STR),
<a name="l02563" id="l02563"></a>02563                                             <span class=
"stringliteral">"encrypted sPDU"</span>)) == NULL) {
<a name="l02564" id="l02564"></a>02564             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>,
<a name="l02565" id="l02565"></a>02565                         <span class=
"stringliteral">"Failed while parsing encrypted sPDU."</span>));
<a name="l02566" id="l02566"></a>02566             <span class=
"keywordflow">if</span> (snmp_increment_statistic(STAT_SNMPINASNPARSEERRS) == 0) {
<a name="l02567" id="l02567"></a>02567                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Failed increment statistic."</span>));
<a name="l02568" id="l02568"></a>02568             }
<a name="l02569" id="l02569"></a>02569             usm_free_usmStateReference(*secStateRef);
<a name="l02570" id="l02570"></a>02570             *secStateRef = NULL;
<a name="l02571" id="l02571"></a>02571             <span class="keywordflow">return</span> SNMPERR_USM_PARSEERROR;
<a name="l02572" id="l02572"></a>02572         }
<a name="l02573" id="l02573"></a>02573 
<a name="l02574" id="l02574"></a>02574 <span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l02575" id="l02575"></a>02575         <span class=
"keywordflow">if</span> (ISTRANSFORM(user-&gt;privProtocol, DESPriv)) {
<a name="l02576" id="l02576"></a>02576             <span class="comment">/*</span>
<a name="l02577" id="l02577"></a>02577 <span class="comment">             * From RFC2574:</span>
<a name="l02578" id="l02578"></a>02578 <span class="comment">             * </span>
<a name="l02579" id="l02579"></a>02579 <span class=
"comment">             * "Before decryption, the encrypted data length is verified.</span>
<a name="l02580" id="l02580"></a>02580 <span class=
"comment">             * If the length of the OCTET STRING to be decrypted is not</span>
<a name="l02581" id="l02581"></a>02581 <span class=
"comment">             * an integral multiple of 8 octets, the decryption process</span>
<a name="l02582" id="l02582"></a>02582 <span class=
"comment">             * is halted and an appropriate exception noted."  </span>
<a name="l02583" id="l02583"></a>02583 <span class="comment">             */</span>
<a name="l02584" id="l02584"></a>02584 
<a name="l02585" id="l02585"></a>02585             <span class="keywordflow">if</span> (remaining % 8 != 0) {
<a name="l02586" id="l02586"></a>02586                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>,
<a name="l02587" id="l02587"></a>02587                             <span class=
"stringliteral">"Ciphertext is %lu bytes, not an integer multiple of 8 (rem %lu)\n"</span>,
<a name="l02588" id="l02588"></a>02588                             (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)remaining, (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)remaining % 8));
<a name="l02589" id="l02589"></a>02589                 <span class=
"keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS) ==
<a name="l02590" id="l02590"></a>02590                     0) {
<a name="l02591" id="l02591"></a>02591                     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Failed increment statistic."</span>));
<a name="l02592" id="l02592"></a>02592                 }
<a name="l02593" id="l02593"></a>02593                 usm_free_usmStateReference(*secStateRef);
<a name="l02594" id="l02594"></a>02594                 *secStateRef = NULL;
<a name="l02595" id="l02595"></a>02595                 <span class="keywordflow">return</span> SNMPERR_USM_DECRYPTIONERROR;
<a name="l02596" id="l02596"></a>02596             }
<a name="l02597" id="l02597"></a>02597 
<a name="l02598" id="l02598"></a>02598             end_of_overhead = value_ptr;
<a name="l02599" id="l02599"></a>02599 
<a name="l02600" id="l02600"></a>02600             <span class="comment">/*</span>
<a name="l02601" id="l02601"></a>02601 <span class="comment">             * XOR the salt with the last (iv_length) bytes</span>
<a name="l02602" id="l02602"></a>02602 <span class="comment">             * of the priv_key to obtain the IV.</span>
<a name="l02603" id="l02603"></a>02603 <span class="comment">             */</span>
<a name="l02604" id="l02604"></a>02604             iv_length = BYTESIZE(USM_DES_SALT_LENGTH);
<a name="l02605" id="l02605"></a>02605             <span class="keywordflow">for</span> (i = 0; i &lt; (int) iv_length; i++)
<a name="l02606" id="l02606"></a>02606                 iv[i] = salt[i] ^ user-&gt;privKey[iv_length + i];
<a name="l02607" id="l02607"></a>02607         }
<a name="l02608" id="l02608"></a>02608 <span class="preprocessor">#endif</span>
<a name="l02609" id="l02609"></a>02609 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l02610" id="l02610"></a>02610         <span class=
"keywordflow">if</span> (ISTRANSFORM(user-&gt;privProtocol, AESPriv)) {
<a name="l02611" id="l02611"></a>02611             iv_length = BYTESIZE(USM_AES_SALT_LENGTH);
<a name="l02612" id="l02612"></a>02612             net_boots = ntohl(boots_uint);
<a name="l02613" id="l02613"></a>02613             net_time = ntohl(time_uint);
<a name="l02614" id="l02614"></a>02614             memcpy(iv, &amp;net_boots, 4);
<a name="l02615" id="l02615"></a>02615             memcpy(iv+4, &amp;net_time, 4);
<a name="l02616" id="l02616"></a>02616             memcpy(iv+8, salt, salt_length);
<a name="l02617" id="l02617"></a>02617         }
<a name="l02618" id="l02618"></a>02618 <span class="preprocessor">#endif</span>
<a name="l02619" id="l02619"></a>02619         
<a name="l02620" id="l02620"></a>02620         <span class=
"keywordflow">if</span> (sc_decrypt(user-&gt;privProtocol, user-&gt;privProtocolLen,
<a name="l02621" id="l02621"></a>02621                        user-&gt;privKey, user-&gt;privKeyLen,
<a name="l02622" id="l02622"></a>02622                        iv, iv_length,
<a name="l02623" id="l02623"></a>02623                        value_ptr, remaining, *scopedPdu, scopedPduLen)
<a name="l02624" id="l02624"></a>02624             != SNMP_ERR_NOERROR) {
<a name="l02625" id="l02625"></a>02625             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Failed decryption."</span>));
<a name="l02626" id="l02626"></a>02626             <span class="keywordflow">if</span> (snmp_increment_statistic
<a name="l02627" id="l02627"></a>02627                 (STAT_USMSTATSDECRYPTIONERRORS) == 0) {
<a name="l02628" id="l02628"></a>02628                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Failed increment statistic."</span>));
<a name="l02629" id="l02629"></a>02629             }
<a name="l02630" id="l02630"></a>02630             <span class="keywordflow">return</span> SNMPERR_USM_DECRYPTIONERROR;
<a name="l02631" id="l02631"></a>02631         }
<a name="l02632" id="l02632"></a>02632 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l02633" id="l02633"></a>02633         <span class="keywordflow">if</span> (debug_is_token_registered(<span class=
"stringliteral">"usm/dump"</span>) == SNMPERR_SUCCESS) {
<a name="l02634" id="l02634"></a>02634             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"Cypher Text"</span>, value_ptr, remaining);
<a name="l02635" id="l02635"></a>02635             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"salt + Encrypted form:"</span>,
<a name="l02636" id="l02636"></a>02636                        salt, salt_length);
<a name="l02637" id="l02637"></a>02637             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"IV + Encrypted form:"</span>, iv, iv_length);
<a name="l02638" id="l02638"></a>02638             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"Decrypted chunk:"</span>,
<a name="l02639" id="l02639"></a>02639                        *scopedPdu, *scopedPduLen);
<a name="l02640" id="l02640"></a>02640         }
<a name="l02641" id="l02641"></a>02641 <span class="preprocessor">#endif</span>
<a name="l02642" id="l02642"></a>02642     }
<a name="l02643" id="l02643"></a>02643     <span class="comment">/*</span>
<a name="l02644" id="l02644"></a>02644 <span class="comment">     * sPDU is plaintext.</span>
<a name="l02645" id="l02645"></a>02645 <span class="comment">     */</span>
<a name="l02646" id="l02646"></a>02646     <span class="keywordflow">else</span> {
<a name="l02647" id="l02647"></a>02647         *scopedPdu = data_ptr;
<a name="l02648" id="l02648"></a>02648         *scopedPduLen = wholeMsgLen - (data_ptr - wholeMsg);
<a name="l02649" id="l02649"></a>02649         end_of_overhead = data_ptr;
<a name="l02650" id="l02650"></a>02650 
<a name="l02651" id="l02651"></a>02651     }                           <span class="comment">/* endif -- PDU decryption */</span>
<a name="l02652" id="l02652"></a>02652 
<a name="l02653" id="l02653"></a>02653 
<a name="l02654" id="l02654"></a>02654     <span class="comment">/*</span>
<a name="l02655" id="l02655"></a>02655 <span class=
"comment">     * Calculate the biggest sPDU for the response (i.e., whole - ovrhd).</span>
<a name="l02656" id="l02656"></a>02656 <span class="comment">     *</span>
<a name="l02657" id="l02657"></a>02657 <span class="comment">     * FIX  Correct? </span>
<a name="l02658" id="l02658"></a>02658 <span class="comment">     */</span>
<a name="l02659" id="l02659"></a>02659     *maxSizeResponse = maxMsgSize - (int)
<a name="l02660" id="l02660"></a>02660         ((u_long) end_of_overhead - (u_long) wholeMsg);
<a name="l02661" id="l02661"></a>02661 
<a name="l02662" id="l02662"></a>02662 
<a name="l02663" id="l02663"></a>02663     DEBUGMSGTL(("usm", "USM processing completed.\n"));
<a name="l02664" id="l02664"></a>02664 
<a name="l02665" id="l02665"></a>02665     return SNMPERR_SUCCESS;
<a name="l02666" id="l02666"></a>02666 
<a name="l02667" id="l02667"></a>02667 }                               <span class=
"comment">/* end usm_process_in_msg() */</span>
<a name="l02668" id="l02668"></a>02668 
<a name="l02669" id="l02669"></a>02669 <span class="keywordtype">void</span>
<a name="l02670" id="l02670"></a>02670 usm_handle_report(<span class="keywordtype">void</span> *sessp,
<a name="l02671" id="l02671"></a>02671                   <a class="code" href=
"structnetsnmp__transport__s.html">netsnmp_transport</a> *transport, <a class="code" href="structsnmp__session.html" title=
"The snmp session structure.">netsnmp_session</a> *session,
<a name="l02672" id="l02672"></a>02672                   <span class="keywordtype">int</span> result, <a class="code" href=
"structsnmp__pdu.html" title="The snmp protocol data unit.">netsnmp_pdu</a> *pdu)
<a name="l02673" id="l02673"></a>02673 {
<a name="l02674" id="l02674"></a>02674     <span class="comment">/*</span>
<a name="l02675" id="l02675"></a>02675 <span class="comment">     * handle reportable errors </span>
<a name="l02676" id="l02676"></a>02676 <span class="comment">     */</span>
<a name="l02677" id="l02677"></a>02677 
<a name="l02678" id="l02678"></a>02678     <span class="comment">/* this will get in our way */</span>
<a name="l02679" id="l02679"></a>02679     usm_free_usmStateReference(pdu-&gt;securityStateRef);
<a name="l02680" id="l02680"></a>02680     pdu-&gt;securityStateRef = NULL;
<a name="l02681" id="l02681"></a>02681 
<a name="l02682" id="l02682"></a>02682     <span class="keywordflow">switch</span> (result) {
<a name="l02683" id="l02683"></a>02683     <span class="keywordflow">case</span> SNMPERR_USM_AUTHENTICATIONFAILURE:
<a name="l02684" id="l02684"></a>02684     {
<a name="l02685" id="l02685"></a>02685         <span class="keywordtype">int</span> res = session-&gt;s_snmp_errno;
<a name="l02686" id="l02686"></a>02686         session-&gt;s_snmp_errno = result;
<a name="l02687" id="l02687"></a>02687         <span class="keywordflow">if</span> (session-&gt;callback) {
<a name="l02688" id="l02688"></a>02688             session-&gt;callback(NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE,
<a name="l02689" id="l02689"></a>02689                               session, pdu-&gt;reqid, pdu,
<a name="l02690" id="l02690"></a>02690                               session-&gt;callback_magic);
<a name="l02691" id="l02691"></a>02691         }
<a name="l02692" id="l02692"></a>02692         session-&gt;s_snmp_errno = res;
<a name="l02693" id="l02693"></a>02693     }  
<a name="l02694" id="l02694"></a>02694     <span class="keywordflow">case</span> SNMPERR_USM_UNKNOWNENGINEID:
<a name="l02695" id="l02695"></a>02695     <span class="keywordflow">case</span> SNMPERR_USM_UNKNOWNSECURITYNAME:
<a name="l02696" id="l02696"></a>02696     <span class="keywordflow">case</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL:
<a name="l02697" id="l02697"></a>02697     <span class="keywordflow">case</span> SNMPERR_USM_NOTINTIMEWINDOW:
<a name="l02698" id="l02698"></a>02698     <span class="keywordflow">case</span> SNMPERR_USM_DECRYPTIONERROR:
<a name="l02699" id="l02699"></a>02699 
<a name="l02700" id="l02700"></a>02700         <span class="keywordflow">if</span> (SNMP_CMD_CONFIRMED(pdu-&gt;command) ||
<a name="l02701" id="l02701"></a>02701             (pdu-&gt;command == 0
<a name="l02702" id="l02702"></a>02702              &amp;&amp; (pdu-&gt;flags &amp; SNMP_MSG_FLAG_RPRT_BIT))) {
<a name="l02703" id="l02703"></a>02703             <a class="code" href="structsnmp__pdu.html" title=
"The snmp protocol data unit.">netsnmp_pdu</a>    *pdu2;
<a name="l02704" id="l02704"></a>02704             <span class="keywordtype">int</span>             flags = pdu-&gt;flags;
<a name="l02705" id="l02705"></a>02705 
<a name="l02706" id="l02706"></a>02706             pdu-&gt;flags |= UCD_MSG_FLAG_FORCE_PDU_COPY;
<a name="l02707" id="l02707"></a>02707             pdu2 = snmp_clone_pdu(pdu);
<a name="l02708" id="l02708"></a>02708             pdu-&gt;flags = pdu2-&gt;flags = flags;
<a name="l02709" id="l02709"></a>02709             snmpv3_make_report(pdu2, result);
<a name="l02710" id="l02710"></a>02710             <span class="keywordflow">if</span> (0 == snmp_sess_send(sessp, pdu2)) {
<a name="l02711" id="l02711"></a>02711                 snmp_free_pdu(pdu2);
<a name="l02712" id="l02712"></a>02712                 <span class="comment">/*</span>
<a name="l02713" id="l02713"></a>02713 <span class="comment">                 * TODO: indicate error </span>
<a name="l02714" id="l02714"></a>02714 <span class="comment">                 */</span>
<a name="l02715" id="l02715"></a>02715             }
<a name="l02716" id="l02716"></a>02716         }
<a name="l02717" id="l02717"></a>02717         <span class="keywordflow">break</span>;
<a name="l02718" id="l02718"></a>02718     }       
<a name="l02719" id="l02719"></a>02719 }
<a name="l02720" id="l02720"></a>02720 <span class="keywordtype">void</span>
<a name="l02721" id="l02721"></a>02721 init_usm(<span class="keywordtype">void</span>)
<a name="l02722" id="l02722"></a>02722 {
<a name="l02723" id="l02723"></a>02723     <span class="keyword">struct </span><a class="code" href=
"structsnmp__secmod__def.html">snmp_secmod_def</a> *def;
<a name="l02724" id="l02724"></a>02724 
<a name="l02725" id="l02725"></a>02725     DEBUGMSGTL((<span class="stringliteral">"init_usm"</span>, <span class=
"stringliteral">"unit_usm: %lu %lu\n"</span>, usmNoPrivProtocol[0],
<a name="l02726" id="l02726"></a>02726                 usmNoPrivProtocol[1]));
<a name="l02727" id="l02727"></a>02727 
<a name="l02728" id="l02728"></a>02728     sc_init();                  <span class="comment">/* initalize scapi code */</span>
<a name="l02729" id="l02729"></a>02729 
<a name="l02730" id="l02730"></a>02730     <span class="comment">/*</span>
<a name="l02731" id="l02731"></a>02731 <span class="comment">     * register ourselves as a security service </span>
<a name="l02732" id="l02732"></a>02732 <span class="comment">     */</span>
<a name="l02733" id="l02733"></a>02733     def = <a class="code" href="group__util.html#ga6356941968481380ea6f4a646df4aaf9"
title="Mallocs memory of sizeof(struct s), zeros it and returns a pointer to it.">SNMP_MALLOC_STRUCT</a>(<a class="code" href=
"structsnmp__secmod__def.html">snmp_secmod_def</a>);
<a name="l02734" id="l02734"></a>02734     <span class="keywordflow">if</span> (def == NULL)
<a name="l02735" id="l02735"></a>02735         <span class="keywordflow">return</span>;
<a name="l02736" id="l02736"></a>02736     <span class="comment">/*</span>
<a name="l02737" id="l02737"></a>02737 <span class=
"comment">     * XXX: def-&gt;init_sess_secmod move stuff from snmp_api.c </span>
<a name="l02738" id="l02738"></a>02738 <span class="comment">     */</span>
<a name="l02739" id="l02739"></a>02739     def-&gt;encode_reverse = usm_secmod_rgenerate_out_msg;
<a name="l02740" id="l02740"></a>02740     def-&gt;encode_forward = usm_secmod_generate_out_msg;
<a name="l02741" id="l02741"></a>02741     def-&gt;decode = usm_secmod_process_in_msg;
<a name="l02742" id="l02742"></a>02742     def-&gt;pdu_free_state_ref = usm_free_usmStateReference;
<a name="l02743" id="l02743"></a>02743     def-&gt;handle_report = usm_handle_report;
<a name="l02744" id="l02744"></a>02744     register_sec_mod(USM_SEC_MODEL_NUMBER, <span class="stringliteral">"usm"</span>, def);
<a name="l02745" id="l02745"></a>02745 
<a name="l02746" id="l02746"></a>02746     <a class="code" href="group__callback.html#gaa74bcb0ea6a8b7270f5e26746ba1fff1" title=
"This function registers a generic callback function.">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
<a name="l02747" id="l02747"></a>02747                            SNMP_CALLBACK_POST_PREMIB_READ_CONFIG,
<a name="l02748" id="l02748"></a>02748                            init_usm_post_config, NULL);
<a name="l02749" id="l02749"></a>02749 
<a name="l02750" id="l02750"></a>02750     <a class="code" href="group__callback.html#gaa74bcb0ea6a8b7270f5e26746ba1fff1" title=
"This function registers a generic callback function.">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
<a name="l02751" id="l02751"></a>02751                            SNMP_CALLBACK_SHUTDOWN,
<a name="l02752" id="l02752"></a>02752                            deinit_usm_post_config, NULL);
<a name="l02753" id="l02753"></a>02753 
<a name="l02754" id="l02754"></a>02754     <a class="code" href="group__callback.html#gaa74bcb0ea6a8b7270f5e26746ba1fff1" title=
"This function registers a generic callback function.">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
<a name="l02755" id="l02755"></a>02755                            SNMP_CALLBACK_SHUTDOWN,
<a name="l02756" id="l02756"></a>02756                            free_engineID, NULL);
<a name="l02757" id="l02757"></a>02757 
<a name="l02758" id="l02758"></a>02758 }
<a name="l02759" id="l02759"></a>02759 
<a name="l02760" id="l02760"></a>02760 <span class="keywordtype">void</span>
<a name="l02761" id="l02761"></a>02761 init_usm_conf(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *app)
<a name="l02762" id="l02762"></a>02762 {
<a name="l02763" id="l02763"></a>02763     <a class="code" href="group__read__config.html#ga9a3e481d8eb7d3ef08efa25b9a186c3b"
title=
"register_config_handler registers handlers for certain tokens specified in certain...">register_config_handler</a>(app, <span class="stringliteral">"usmUser"</span>,
<a name="l02764" id="l02764"></a>02764                                   usm_parse_config_usmUser, NULL, NULL);
<a name="l02765" id="l02765"></a>02765     <a class="code" href="group__read__config.html#ga9a3e481d8eb7d3ef08efa25b9a186c3b"
title=
"register_config_handler registers handlers for certain tokens specified in certain...">register_config_handler</a>(app, <span class="stringliteral">"createUser"</span>,
<a name="l02766" id="l02766"></a>02766                                   usm_parse_create_usmUser, NULL,
<a name="l02767" id="l02767"></a>02767                                   <span class=
"stringliteral">"username [-e ENGINEID] (MD5|SHA) authpassphrase [DES [privpassphrase]]"</span>);
<a name="l02768" id="l02768"></a>02768 
<a name="l02769" id="l02769"></a>02769     <span class="comment">/*</span>
<a name="l02770" id="l02770"></a>02770 <span class="comment">     * we need to be called back later </span>
<a name="l02771" id="l02771"></a>02771 <span class="comment">     */</span>
<a name="l02772" id="l02772"></a>02772     <a class="code" href="group__callback.html#gaa74bcb0ea6a8b7270f5e26746ba1fff1" title=
"This function registers a generic callback function.">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
<a name="l02773" id="l02773"></a>02773                            usm_store_users, NULL);
<a name="l02774" id="l02774"></a>02774 }
<a name="l02775" id="l02775"></a>02775 
<a name="l02776" id="l02776"></a>02776 <span class="comment">/*</span>
<a name="l02777" id="l02777"></a>02777 <span class="comment"> * initializations for the USM.</span>
<a name="l02778" id="l02778"></a>02778 <span class="comment"> *</span>
<a name="l02779" id="l02779"></a>02779 <span class=
"comment"> * Should be called after the (engineid) configuration files have been read.</span>
<a name="l02780" id="l02780"></a>02780 <span class="comment"> *</span>
<a name="l02781" id="l02781"></a>02781 <span class="comment"> * Set "arbitrary" portion of salt to a random number.</span>
<a name="l02782" id="l02782"></a>02782 <span class="comment"> */</span>
<a name="l02783" id="l02783"></a>02783 <span class="keywordtype">int</span>
<a name="l02784" id="l02784"></a>02784 init_usm_post_config(<span class="keywordtype">int</span> majorid, <span class=
"keywordtype">int</span> minorid, <span class="keywordtype">void</span> *serverarg,
<a name="l02785" id="l02785"></a>02785                      <span class="keywordtype">void</span> *clientarg)
<a name="l02786" id="l02786"></a>02786 {
<a name="l02787" id="l02787"></a>02787     <span class="keywordtype">size_t</span>          salt_integer_len = <span class=
"keyword">sizeof</span>(salt_integer);
<a name="l02788" id="l02788"></a>02788 
<a name="l02789" id="l02789"></a>02789     <span class=
"keywordflow">if</span> (sc_random((u_char *) &amp; salt_integer, &amp;salt_integer_len) !=
<a name="l02790" id="l02790"></a>02790         SNMPERR_SUCCESS) {
<a name="l02791" id="l02791"></a>02791         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"sc_random() failed: using time() as salt.\n"</span>));
<a name="l02792" id="l02792"></a>02792         salt_integer = (u_int) time(NULL);
<a name="l02793" id="l02793"></a>02793     }
<a name="l02794" id="l02794"></a>02794 
<a name="l02795" id="l02795"></a>02795 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l02796" id="l02796"></a>02796     salt_integer_len = <span class="keyword">sizeof</span> (salt_integer64_1);
<a name="l02797" id="l02797"></a>02797     <span class=
"keywordflow">if</span> (sc_random((u_char *) &amp; salt_integer64_1, &amp;salt_integer_len) !=
<a name="l02798" id="l02798"></a>02798         SNMPERR_SUCCESS) {
<a name="l02799" id="l02799"></a>02799         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"sc_random() failed: using time() as aes1 salt.\n"</span>));
<a name="l02800" id="l02800"></a>02800         salt_integer64_1 = (u_int) time(NULL);
<a name="l02801" id="l02801"></a>02801     }
<a name="l02802" id="l02802"></a>02802     salt_integer_len = <span class="keyword">sizeof</span> (salt_integer64_1);
<a name="l02803" id="l02803"></a>02803     <span class=
"keywordflow">if</span> (sc_random((u_char *) &amp; salt_integer64_2, &amp;salt_integer_len) !=
<a name="l02804" id="l02804"></a>02804         SNMPERR_SUCCESS) {
<a name="l02805" id="l02805"></a>02805         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"sc_random() failed: using time() as aes2 salt.\n"</span>));
<a name="l02806" id="l02806"></a>02806         salt_integer64_2 = (u_int) time(NULL);
<a name="l02807" id="l02807"></a>02807     }
<a name="l02808" id="l02808"></a>02808 <span class="preprocessor">#endif</span>
<a name="l02809" id="l02809"></a>02809     
<a name="l02810" id="l02810"></a>02810 <span class="preprocessor">#ifndef NETSNMP_DISABLE_MD5</span>
<a name="l02811" id="l02811"></a>02811     noNameUser = usm_create_initial_user(<span class=
"stringliteral">""</span>, usmHMACMD5AuthProtocol,
<a name="l02812" id="l02812"></a>02812                                          USM_LENGTH_OID_TRANSFORM,
<a name="l02813" id="l02813"></a>02813 #ifndef NETSNMP_DISABLE_DES
<a name="l02814" id="l02814"></a>02814                                          usmDESPrivProtocol,
<a name="l02815" id="l02815"></a>02815 #<span class="keywordflow">else</span>
<a name="l02816" id="l02816"></a>02816                                          usmAESPrivProtocol,
<a name="l02817" id="l02817"></a>02817 #endif
<a name="l02818" id="l02818"></a>02818                                          USM_LENGTH_OID_TRANSFORM);
<a name="l02819" id="l02819"></a>02819 <span class="preprocessor">#else</span>
<a name="l02820" id="l02820"></a>02820     noNameUser = usm_create_initial_user(<span class=
"stringliteral">""</span>, usmHMACSHA1AuthProtocol,
<a name="l02821" id="l02821"></a>02821                                          USM_LENGTH_OID_TRANSFORM,
<a name="l02822" id="l02822"></a>02822 #ifndef NETSNMP_DISABLE_DES
<a name="l02823" id="l02823"></a>02823                                          usmDESPrivProtocol,
<a name="l02824" id="l02824"></a>02824 #<span class="keywordflow">else</span>
<a name="l02825" id="l02825"></a>02825                                          usmAESPrivProtocol,
<a name="l02826" id="l02826"></a>02826 #endif
<a name="l02827" id="l02827"></a>02827                                          USM_LENGTH_OID_TRANSFORM);
<a name="l02828" id="l02828"></a>02828 <span class="preprocessor">#endif</span>
<a name="l02829" id="l02829"></a>02829 
<a name="l02830" id="l02830"></a>02830     <span class="keywordflow">if</span> ( noNameUser ) {
<a name="l02831" id="l02831"></a>02831         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(noNameUser-&gt;engineID);
<a name="l02832" id="l02832"></a>02832         noNameUser-&gt;engineIDLen = 0;
<a name="l02833" id="l02833"></a>02833     }
<a name="l02834" id="l02834"></a>02834 
<a name="l02835" id="l02835"></a>02835     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l02836" id="l02836"></a>02836 }                               <span class=
"comment">/* end init_usm_post_config() */</span>
<a name="l02837" id="l02837"></a>02837 
<a name="l02838" id="l02838"></a>02838 <span class="keywordtype">int</span>
<a name="l02839" id="l02839"></a>02839 deinit_usm_post_config(<span class="keywordtype">int</span> majorid, <span class=
"keywordtype">int</span> minorid, <span class="keywordtype">void</span> *serverarg,
<a name="l02840" id="l02840"></a>02840                        <span class="keywordtype">void</span> *clientarg)
<a name="l02841" id="l02841"></a>02841 {
<a name="l02842" id="l02842"></a>02842     <span class="keywordflow">if</span> (usm_free_user(noNameUser) != NULL) {
<a name="l02843" id="l02843"></a>02843         DEBUGMSGTL((<span class=
"stringliteral">"deinit_usm_post_config"</span>, <span class="stringliteral">"could not free initial user\n"</span>));
<a name="l02844" id="l02844"></a>02844         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l02845" id="l02845"></a>02845     }
<a name="l02846" id="l02846"></a>02846     noNameUser = NULL;
<a name="l02847" id="l02847"></a>02847 
<a name="l02848" id="l02848"></a>02848     DEBUGMSGTL((<span class="stringliteral">"deinit_usm_post_config"</span>, <span class=
"stringliteral">"initial user removed\n"</span>));
<a name="l02849" id="l02849"></a>02849     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l02850" id="l02850"></a>02850 }                               <span class=
"comment">/* end deinit_usm_post_config() */</span>
<a name="l02851" id="l02851"></a>02851 
<a name="l02852" id="l02852"></a>02852 <span class="keywordtype">void</span>
<a name="l02853" id="l02853"></a>02853 clear_user_list(<span class="keywordtype">void</span>)
<a name="l02854" id="l02854"></a>02854 {
<a name="l02855" id="l02855"></a>02855     <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *tmp = userList, *next = NULL;
<a name="l02856" id="l02856"></a>02856 
<a name="l02857" id="l02857"></a>02857     <span class="keywordflow">while</span> (tmp != NULL) {
<a name="l02858" id="l02858"></a>02858         next = tmp-&gt;next;
<a name="l02859" id="l02859"></a>02859         usm_free_user(tmp);
<a name="l02860" id="l02860"></a>02860         tmp = next;
<a name="l02861" id="l02861"></a>02861     }
<a name="l02862" id="l02862"></a>02862     userList = NULL;
<a name="l02863" id="l02863"></a>02863 
<a name="l02864" id="l02864"></a>02864 }
<a name="l02865" id="l02865"></a>02865 
<a name="l02866" id="l02866"></a>02866 <span class=
"comment">/*******************************************************************-o-******</span>
<a name="l02867" id="l02867"></a>02867 <span class="comment"> * usm_check_secLevel</span>
<a name="l02868" id="l02868"></a>02868 <span class="comment"> *</span>
<a name="l02869" id="l02869"></a>02869 <span class="comment"> * Parameters:</span>
<a name="l02870" id="l02870"></a>02870 <span class="comment"> *       level</span>
<a name="l02871" id="l02871"></a>02871 <span class="comment"> *      *user</span>
<a name="l02872" id="l02872"></a>02872 <span class="comment"> *      </span>
<a name="l02873" id="l02873"></a>02873 <span class="comment"> * Returns:</span>
<a name="l02874" id="l02874"></a>02874 <span class="comment"> *      0       On success,</span>
<a name="l02875" id="l02875"></a>02875 <span class="comment"> *      -1      Otherwise.</span>
<a name="l02876" id="l02876"></a>02876 <span class="comment"> *</span>
<a name="l02877" id="l02877"></a>02877 <span class=
"comment"> * Checks that a given security level is valid for a given user.</span>
<a name="l02878" id="l02878"></a>02878 <span class="comment"> */</span>
<a name="l02879" id="l02879"></a>02879 <span class="keywordtype">int</span>
<a name="l02880" id="l02880"></a>02880 usm_check_secLevel(<span class="keywordtype">int</span> level, <span class=
"keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *user)
<a name="l02881" id="l02881"></a>02881 {
<a name="l02882" id="l02882"></a>02882 
<a name="l02883" id="l02883"></a>02883     <span class="keywordflow">if</span> (user-&gt;userStatus != RS_ACTIVE)
<a name="l02884" id="l02884"></a>02884         <span class="keywordflow">return</span> -1;
<a name="l02885" id="l02885"></a>02885 
<a name="l02886" id="l02886"></a>02886     DEBUGMSGTL((<span class="stringliteral">"comparex"</span>, <span class=
"stringliteral">"Comparing: %lu %lu "</span>, usmNoPrivProtocol[0],
<a name="l02887" id="l02887"></a>02887                 usmNoPrivProtocol[1]));
<a name="l02888" id="l02888"></a>02888     DEBUGMSGOID((<span class="stringliteral">"comparex"</span>, usmNoPrivProtocol,
<a name="l02889" id="l02889"></a>02889                  <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class=
"keyword">sizeof</span>(oid)));
<a name="l02890" id="l02890"></a>02890     DEBUGMSG((<span class="stringliteral">"comparex"</span>, <span class=
"stringliteral">"\n"</span>));
<a name="l02891" id="l02891"></a>02891     <span class="keywordflow">if</span> (level == SNMP_SEC_LEVEL_AUTHPRIV
<a name="l02892" id="l02892"></a>02892         &amp;&amp; (<a class="code" href=
"group__library.html#gae881bb815fa4afe6eadb60a43165ee06" title=
"Compares 2 OIDs to determine if they are exactly equal.">netsnmp_oid_equals</a>(user-&gt;privProtocol, user-&gt;privProtocolLen,
<a name="l02893" id="l02893"></a>02893                              usmNoPrivProtocol,
<a name="l02894" id="l02894"></a>02894                              <span class=
"keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid)) ==
<a name="l02895" id="l02895"></a>02895             0)) {
<a name="l02896" id="l02896"></a>02896         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Level: %d\n"</span>, level));
<a name="l02897" id="l02897"></a>02897         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"User (%s) Auth Protocol: "</span>, user-&gt;name));
<a name="l02898" id="l02898"></a>02898         DEBUGMSGOID((<span class=
"stringliteral">"usm"</span>, user-&gt;authProtocol, user-&gt;authProtocolLen));
<a name="l02899" id="l02899"></a>02899         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">", User Priv Protocol: "</span>));
<a name="l02900" id="l02900"></a>02900         DEBUGMSGOID((<span class=
"stringliteral">"usm"</span>, user-&gt;privProtocol, user-&gt;privProtocolLen));
<a name="l02901" id="l02901"></a>02901         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"\n"</span>));
<a name="l02902" id="l02902"></a>02902         <span class="keywordflow">return</span> 1;
<a name="l02903" id="l02903"></a>02903     }
<a name="l02904" id="l02904"></a>02904     <span class="keywordflow">if</span> ((level == SNMP_SEC_LEVEL_AUTHPRIV
<a name="l02905" id="l02905"></a>02905          || level == SNMP_SEC_LEVEL_AUTHNOPRIV)
<a name="l02906" id="l02906"></a>02906         &amp;&amp;
<a name="l02907" id="l02907"></a>02907         (<a class="code" href="group__library.html#gae881bb815fa4afe6eadb60a43165ee06"
title="Compares 2 OIDs to determine if they are exactly equal.">netsnmp_oid_equals</a>
<a name="l02908" id="l02908"></a>02908          (user-&gt;authProtocol, user-&gt;authProtocolLen, usmNoAuthProtocol,
<a name="l02909" id="l02909"></a>02909           <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class=
"keyword">sizeof</span>(oid)) == 0)) {
<a name="l02910" id="l02910"></a>02910         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Level: %d\n"</span>, level));
<a name="l02911" id="l02911"></a>02911         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"User (%s) Auth Protocol: "</span>, user-&gt;name));
<a name="l02912" id="l02912"></a>02912         DEBUGMSGOID((<span class=
"stringliteral">"usm"</span>, user-&gt;authProtocol, user-&gt;authProtocolLen));
<a name="l02913" id="l02913"></a>02913         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">", User Priv Protocol: "</span>));
<a name="l02914" id="l02914"></a>02914         DEBUGMSGOID((<span class=
"stringliteral">"usm"</span>, user-&gt;privProtocol, user-&gt;privProtocolLen));
<a name="l02915" id="l02915"></a>02915         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"\n"</span>));
<a name="l02916" id="l02916"></a>02916         <span class="keywordflow">return</span> 1;
<a name="l02917" id="l02917"></a>02917     }
<a name="l02918" id="l02918"></a>02918 
<a name="l02919" id="l02919"></a>02919     <span class="keywordflow">return</span> 0;
<a name="l02920" id="l02920"></a>02920 
<a name="l02921" id="l02921"></a>02921 }                               <span class=
"comment">/* end usm_check_secLevel() */</span>
<a name="l02922" id="l02922"></a>02922 
<a name="l02923" id="l02923"></a>02923 
<a name="l02924" id="l02924"></a>02924 
<a name="l02925" id="l02925"></a>02925 
<a name="l02926" id="l02926"></a>02926 <span class=
"comment">/*******************************************************************-o-******</span>
<a name="l02927" id="l02927"></a>02927 <span class="comment"> * usm_check_secLevel_vs_protocols</span>
<a name="l02928" id="l02928"></a>02928 <span class="comment"> *</span>
<a name="l02929" id="l02929"></a>02929 <span class="comment"> * Parameters:</span>
<a name="l02930" id="l02930"></a>02930 <span class="comment"> *       level</span>
<a name="l02931" id="l02931"></a>02931 <span class="comment"> *      *authProtocol</span>
<a name="l02932" id="l02932"></a>02932 <span class="comment"> *       authProtocolLen</span>
<a name="l02933" id="l02933"></a>02933 <span class="comment"> *      *privProtocol</span>
<a name="l02934" id="l02934"></a>02934 <span class="comment"> *       privProtocolLen</span>
<a name="l02935" id="l02935"></a>02935 <span class="comment"> *      </span>
<a name="l02936" id="l02936"></a>02936 <span class="comment"> * Returns:</span>
<a name="l02937" id="l02937"></a>02937 <span class="comment"> *      0       On success,</span>
<a name="l02938" id="l02938"></a>02938 <span class="comment"> *      1       Otherwise.</span>
<a name="l02939" id="l02939"></a>02939 <span class="comment"> *</span>
<a name="l02940" id="l02940"></a>02940 <span class=
"comment"> * Same as above but with explicitly named transform types instead of taking</span>
<a name="l02941" id="l02941"></a>02941 <span class="comment"> * from the usmUser structure.</span>
<a name="l02942" id="l02942"></a>02942 <span class="comment"> */</span>
<a name="l02943" id="l02943"></a>02943 <span class="keywordtype">int</span>
<a name="l02944" id="l02944"></a>02944 usm_check_secLevel_vs_protocols(<span class="keywordtype">int</span> level,
<a name="l02945" id="l02945"></a>02945                                 <span class="keyword">const</span> oid * authProtocol,
<a name="l02946" id="l02946"></a>02946                                 u_int authProtocolLen,
<a name="l02947" id="l02947"></a>02947                                 <span class="keyword">const</span> oid * privProtocol,
<a name="l02948" id="l02948"></a>02948                                 u_int privProtocolLen)
<a name="l02949" id="l02949"></a>02949 {
<a name="l02950" id="l02950"></a>02950 
<a name="l02951" id="l02951"></a>02951     <span class="keywordflow">if</span> (level == SNMP_SEC_LEVEL_AUTHPRIV
<a name="l02952" id="l02952"></a>02952         &amp;&amp;
<a name="l02953" id="l02953"></a>02953         (<a class="code" href="group__library.html#gae881bb815fa4afe6eadb60a43165ee06"
title="Compares 2 OIDs to determine if they are exactly equal.">netsnmp_oid_equals</a>
<a name="l02954" id="l02954"></a>02954          (privProtocol, privProtocolLen, usmNoPrivProtocol,
<a name="l02955" id="l02955"></a>02955           <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class=
"keyword">sizeof</span>(oid)) == 0)) {
<a name="l02956" id="l02956"></a>02956         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Level: %d\n"</span>, level));
<a name="l02957" id="l02957"></a>02957         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Auth Protocol: "</span>));
<a name="l02958" id="l02958"></a>02958         DEBUGMSGOID((<span class=
"stringliteral">"usm"</span>, authProtocol, authProtocolLen));
<a name="l02959" id="l02959"></a>02959         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">", Priv Protocol: "</span>));
<a name="l02960" id="l02960"></a>02960         DEBUGMSGOID((<span class=
"stringliteral">"usm"</span>, privProtocol, privProtocolLen));
<a name="l02961" id="l02961"></a>02961         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"\n"</span>));
<a name="l02962" id="l02962"></a>02962         <span class="keywordflow">return</span> 1;
<a name="l02963" id="l02963"></a>02963     }
<a name="l02964" id="l02964"></a>02964     <span class="keywordflow">if</span> ((level == SNMP_SEC_LEVEL_AUTHPRIV
<a name="l02965" id="l02965"></a>02965          || level == SNMP_SEC_LEVEL_AUTHNOPRIV)
<a name="l02966" id="l02966"></a>02966         &amp;&amp;
<a name="l02967" id="l02967"></a>02967         (<a class="code" href="group__library.html#gae881bb815fa4afe6eadb60a43165ee06"
title="Compares 2 OIDs to determine if they are exactly equal.">netsnmp_oid_equals</a>
<a name="l02968" id="l02968"></a>02968          (authProtocol, authProtocolLen, usmNoAuthProtocol,
<a name="l02969" id="l02969"></a>02969           <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class=
"keyword">sizeof</span>(oid)) == 0)) {
<a name="l02970" id="l02970"></a>02970         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Level: %d\n"</span>, level));
<a name="l02971" id="l02971"></a>02971         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Auth Protocol: "</span>));
<a name="l02972" id="l02972"></a>02972         DEBUGMSGOID((<span class=
"stringliteral">"usm"</span>, authProtocol, authProtocolLen));
<a name="l02973" id="l02973"></a>02973         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">", Priv Protocol: "</span>));
<a name="l02974" id="l02974"></a>02974         DEBUGMSGOID((<span class=
"stringliteral">"usm"</span>, privProtocol, privProtocolLen));
<a name="l02975" id="l02975"></a>02975         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"\n"</span>));
<a name="l02976" id="l02976"></a>02976         <span class="keywordflow">return</span> 1;
<a name="l02977" id="l02977"></a>02977     }
<a name="l02978" id="l02978"></a>02978 
<a name="l02979" id="l02979"></a>02979     <span class="keywordflow">return</span> 0;
<a name="l02980" id="l02980"></a>02980 
<a name="l02981" id="l02981"></a>02981 }                               <span class=
"comment">/* end usm_check_secLevel_vs_protocols() */</span>
<a name="l02982" id="l02982"></a>02982 
<a name="l02983" id="l02983"></a>02983 
<a name="l02984" id="l02984"></a>02984 
<a name="l02985" id="l02985"></a>02985 
<a name="l02986" id="l02986"></a>02986 <span class="comment">/*</span>
<a name="l02987" id="l02987"></a>02987 <span class=
"comment"> * usm_get_user(): Returns a user from userList based on the engineID,</span>
<a name="l02988" id="l02988"></a>02988 <span class="comment"> * engineIDLen and name of the requested user. </span>
<a name="l02989" id="l02989"></a>02989 <span class="comment"> */</span>
<a name="l02990" id="l02990"></a>02990 
<a name="l02991" id="l02991"></a>02991 <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *
<a name="l02992" id="l02992"></a>02992 usm_get_user(u_char * engineID, <span class=
"keywordtype">size_t</span> engineIDLen, <span class="keywordtype">char</span> *name)
<a name="l02993" id="l02993"></a>02993 {
<a name="l02994" id="l02994"></a>02994     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"getting user %s\n"</span>, name));
<a name="l02995" id="l02995"></a>02995     <span class=
"keywordflow">return</span> usm_get_user_from_list(engineID, engineIDLen, name, userList,
<a name="l02996" id="l02996"></a>02996                                   1);
<a name="l02997" id="l02997"></a>02997 }
<a name="l02998" id="l02998"></a>02998 
<a name="l02999" id="l02999"></a>02999 <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *
<a name="l03000" id="l03000"></a>03000 usm_get_user_from_list(u_char * engineID, <span class=
"keywordtype">size_t</span> engineIDLen,
<a name="l03001" id="l03001"></a>03001                        <span class="keywordtype">char</span> *name, <span class=
"keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *puserList,
<a name="l03002" id="l03002"></a>03002                        <span class="keywordtype">int</span> use_default)
<a name="l03003" id="l03003"></a>03003 {
<a name="l03004" id="l03004"></a>03004     <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *ptr;
<a name="l03005" id="l03005"></a>03005     <span class="keywordtype">char</span>            noName[] = <span class=
"stringliteral">""</span>;
<a name="l03006" id="l03006"></a>03006     <span class="keywordflow">if</span> (name == NULL)
<a name="l03007" id="l03007"></a>03007         name = noName;
<a name="l03008" id="l03008"></a>03008     <span class=
"keywordflow">for</span> (ptr = puserList; ptr != NULL; ptr = ptr-&gt;next) {
<a name="l03009" id="l03009"></a>03009         <span class=
"keywordflow">if</span> (ptr-&gt;name &amp;&amp; !strcmp(ptr-&gt;name, name)) {
<a name="l03010" id="l03010"></a>03010           DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"match on user %s\n"</span>, ptr-&gt;name));
<a name="l03011" id="l03011"></a>03011           <span class=
"keywordflow">if</span> (ptr-&gt;engineIDLen == engineIDLen &amp;&amp;
<a name="l03012" id="l03012"></a>03012             ((ptr-&gt;engineID == NULL &amp;&amp; engineID == NULL) ||
<a name="l03013" id="l03013"></a>03013              (ptr-&gt;engineID != NULL &amp;&amp; engineID != NULL &amp;&amp;
<a name="l03014" id="l03014"></a>03014               memcmp(ptr-&gt;engineID, engineID, engineIDLen) == 0)))
<a name="l03015" id="l03015"></a>03015             <span class="keywordflow">return</span> ptr;
<a name="l03016" id="l03016"></a>03016           DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"no match on engineID ("</span>));
<a name="l03017" id="l03017"></a>03017           DEBUGMSGHEX((<span class="stringliteral">"usm"</span>, engineID, engineIDLen));
<a name="l03018" id="l03018"></a>03018           DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">")\n"</span>));
<a name="l03019" id="l03019"></a>03019         }
<a name="l03020" id="l03020"></a>03020     }
<a name="l03021" id="l03021"></a>03021 
<a name="l03022" id="l03022"></a>03022     <span class="comment">/*</span>
<a name="l03023" id="l03023"></a>03023 <span class="comment">     * return "" user used to facilitate engineID discovery </span>
<a name="l03024" id="l03024"></a>03024 <span class="comment">     */</span>
<a name="l03025" id="l03025"></a>03025     <span class="keywordflow">if</span> (use_default &amp;&amp; !strcmp(name, <span class=
"stringliteral">""</span>))
<a name="l03026" id="l03026"></a>03026         <span class="keywordflow">return</span> noNameUser;
<a name="l03027" id="l03027"></a>03027     <span class="keywordflow">return</span> NULL;
<a name="l03028" id="l03028"></a>03028 }
<a name="l03029" id="l03029"></a>03029 
<a name="l03030" id="l03030"></a>03030 <span class="comment">/*</span>
<a name="l03031" id="l03031"></a>03031 <span class=
"comment"> * usm_add_user(): Add's a user to the userList, sorted by the</span>
<a name="l03032" id="l03032"></a>03032 <span class=
"comment"> * engineIDLength then the engineID then the name length then the name</span>
<a name="l03033" id="l03033"></a>03033 <span class=
"comment"> * to facilitate getNext calls on a usmUser table which is indexed by</span>
<a name="l03034" id="l03034"></a>03034 <span class="comment"> * these values.</span>
<a name="l03035" id="l03035"></a>03035 <span class="comment"> * </span>
<a name="l03036" id="l03036"></a>03036 <span class=
"comment"> * returns the head of the list (which could change due to this add).</span>
<a name="l03037" id="l03037"></a>03037 <span class="comment"> */</span>
<a name="l03038" id="l03038"></a>03038 
<a name="l03039" id="l03039"></a>03039 <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *
<a name="l03040" id="l03040"></a>03040 usm_add_user(<span class="keyword">struct</span> <a class="code" href=
"structusmUser.html">usmUser</a> *user)
<a name="l03041" id="l03041"></a>03041 {
<a name="l03042" id="l03042"></a>03042     <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *uptr;
<a name="l03043" id="l03043"></a>03043     uptr = usm_add_user_to_list(user, userList);
<a name="l03044" id="l03044"></a>03044     <span class="keywordflow">if</span> (uptr != NULL)
<a name="l03045" id="l03045"></a>03045         userList = uptr;
<a name="l03046" id="l03046"></a>03046     <span class="keywordflow">return</span> uptr;
<a name="l03047" id="l03047"></a>03047 }
<a name="l03048" id="l03048"></a>03048 
<a name="l03049" id="l03049"></a>03049 <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *
<a name="l03050" id="l03050"></a>03050 usm_add_user_to_list(<span class="keyword">struct</span> <a class="code" href=
"structusmUser.html">usmUser</a> *user, <span class="keyword">struct</span> <a class="code" href=
"structusmUser.html">usmUser</a> *puserList)
<a name="l03051" id="l03051"></a>03051 {
<a name="l03052" id="l03052"></a>03052     <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *nptr, *pptr, *optr;
<a name="l03053" id="l03053"></a>03053 
<a name="l03054" id="l03054"></a>03054     <span class="comment">/*</span>
<a name="l03055" id="l03055"></a>03055 <span class=
"comment">     * loop through puserList till we find the proper, sorted place to</span>
<a name="l03056" id="l03056"></a>03056 <span class="comment">     * insert the new user </span>
<a name="l03057" id="l03057"></a>03057 <span class="comment">     */</span>
<a name="l03058" id="l03058"></a>03058     <span class="comment">/* XXX - how to handle a NULL user-&gt;name ?? */</span>
<a name="l03059" id="l03059"></a>03059     <span class="comment">/* XXX - similarly for a NULL nptr-&gt;name ?? */</span>
<a name="l03060" id="l03060"></a>03060     <span class="keywordflow">for</span> (nptr = puserList, pptr = NULL; nptr != NULL;
<a name="l03061" id="l03061"></a>03061          pptr = nptr, nptr = nptr-&gt;next) {
<a name="l03062" id="l03062"></a>03062         <span class=
"keywordflow">if</span> (nptr-&gt;engineIDLen &gt; user-&gt;engineIDLen)
<a name="l03063" id="l03063"></a>03063             <span class="keywordflow">break</span>;
<a name="l03064" id="l03064"></a>03064 
<a name="l03065" id="l03065"></a>03065         <span class=
"keywordflow">if</span> (user-&gt;engineID == NULL &amp;&amp; nptr-&gt;engineID != NULL)
<a name="l03066" id="l03066"></a>03066             <span class="keywordflow">break</span>;
<a name="l03067" id="l03067"></a>03067 
<a name="l03068" id="l03068"></a>03068         <span class=
"keywordflow">if</span> (nptr-&gt;engineIDLen == user-&gt;engineIDLen &amp;&amp;
<a name="l03069" id="l03069"></a>03069             (nptr-&gt;engineID != NULL &amp;&amp; user-&gt;engineID != NULL &amp;&amp;
<a name="l03070" id="l03070"></a>03070              memcmp(nptr-&gt;engineID, user-&gt;engineID,
<a name="l03071" id="l03071"></a>03071                     user-&gt;engineIDLen) &gt; 0))
<a name="l03072" id="l03072"></a>03072             <span class="keywordflow">break</span>;
<a name="l03073" id="l03073"></a>03073 
<a name="l03074" id="l03074"></a>03074         <span class=
"keywordflow">if</span> (!(nptr-&gt;engineID == NULL &amp;&amp; user-&gt;engineID != NULL)) {
<a name="l03075" id="l03075"></a>03075             <span class=
"keywordflow">if</span> (nptr-&gt;engineIDLen == user-&gt;engineIDLen &amp;&amp;
<a name="l03076" id="l03076"></a>03076                 ((nptr-&gt;engineID == NULL &amp;&amp; user-&gt;engineID == NULL) ||
<a name="l03077" id="l03077"></a>03077                  memcmp(nptr-&gt;engineID, user-&gt;engineID,
<a name="l03078" id="l03078"></a>03078                         user-&gt;engineIDLen) == 0)
<a name="l03079" id="l03079"></a>03079                 &amp;&amp; strlen(nptr-&gt;name) &gt; strlen(user-&gt;name))
<a name="l03080" id="l03080"></a>03080                 <span class="keywordflow">break</span>;
<a name="l03081" id="l03081"></a>03081 
<a name="l03082" id="l03082"></a>03082             <span class=
"keywordflow">if</span> (nptr-&gt;engineIDLen == user-&gt;engineIDLen &amp;&amp;
<a name="l03083" id="l03083"></a>03083                 ((nptr-&gt;engineID == NULL &amp;&amp; user-&gt;engineID == NULL) ||
<a name="l03084" id="l03084"></a>03084                  memcmp(nptr-&gt;engineID, user-&gt;engineID,
<a name="l03085" id="l03085"></a>03085                         user-&gt;engineIDLen) == 0)
<a name="l03086" id="l03086"></a>03086                 &amp;&amp; strlen(nptr-&gt;name) == strlen(user-&gt;name)
<a name="l03087" id="l03087"></a>03087                 &amp;&amp; strcmp(nptr-&gt;name, user-&gt;name) &gt; 0)
<a name="l03088" id="l03088"></a>03088                 <span class="keywordflow">break</span>;
<a name="l03089" id="l03089"></a>03089 
<a name="l03090" id="l03090"></a>03090             <span class=
"keywordflow">if</span> (nptr-&gt;engineIDLen == user-&gt;engineIDLen &amp;&amp;
<a name="l03091" id="l03091"></a>03091                 ((nptr-&gt;engineID == NULL &amp;&amp; user-&gt;engineID == NULL) ||
<a name="l03092" id="l03092"></a>03092                  memcmp(nptr-&gt;engineID, user-&gt;engineID,
<a name="l03093" id="l03093"></a>03093                         user-&gt;engineIDLen) == 0)
<a name="l03094" id="l03094"></a>03094                 &amp;&amp; strlen(nptr-&gt;name) == strlen(user-&gt;name)
<a name="l03095" id="l03095"></a>03095                 &amp;&amp; strcmp(nptr-&gt;name, user-&gt;name) == 0) {
<a name="l03096" id="l03096"></a>03096                 <span class="comment">/*</span>
<a name="l03097" id="l03097"></a>03097 <span class=
"comment">                 * the user is an exact match of a previous entry.</span>
<a name="l03098" id="l03098"></a>03098 <span class=
"comment">                 * Credentials may be different, though, so remove</span>
<a name="l03099" id="l03099"></a>03099 <span class="comment">                 * the old entry (and add the new one)!</span>
<a name="l03100" id="l03100"></a>03100 <span class="comment">                 */</span>
<a name="l03101" id="l03101"></a>03101                 <span class="keywordflow">if</span> (pptr) { <span class=
"comment">/* change prev's next pointer */</span>
<a name="l03102" id="l03102"></a>03102                   pptr-&gt;next = nptr-&gt;next;
<a name="l03103" id="l03103"></a>03103                 }
<a name="l03104" id="l03104"></a>03104                 <span class="keywordflow">if</span> (nptr-&gt;next) { <span class=
"comment">/* change next's prev pointer */</span>
<a name="l03105" id="l03105"></a>03105                   nptr-&gt;next-&gt;prev = pptr;
<a name="l03106" id="l03106"></a>03106                 } 
<a name="l03107" id="l03107"></a>03107                 optr = nptr;
<a name="l03108" id="l03108"></a>03108                 nptr = optr-&gt;next; <span class=
"comment">/* add new user at this position */</span>
<a name="l03109" id="l03109"></a>03109                 <span class="comment">/* free the old user */</span>
<a name="l03110" id="l03110"></a>03110                 optr-&gt;next=NULL;
<a name="l03111" id="l03111"></a>03111                 optr-&gt;prev=NULL;
<a name="l03112" id="l03112"></a>03112                 usm_free_user(optr); 
<a name="l03113" id="l03113"></a>03113                 <span class="keywordflow">break</span>; <span class=
"comment">/* new user will be added below */</span>
<a name="l03114" id="l03114"></a>03114             }
<a name="l03115" id="l03115"></a>03115         }
<a name="l03116" id="l03116"></a>03116     }
<a name="l03117" id="l03117"></a>03117 
<a name="l03118" id="l03118"></a>03118     <span class="comment">/*</span>
<a name="l03119" id="l03119"></a>03119 <span class=
"comment">     * nptr should now point to the user that we need to add ourselves</span>
<a name="l03120" id="l03120"></a>03120 <span class="comment">     * in front of, and pptr should be our new 'prev'. </span>
<a name="l03121" id="l03121"></a>03121 <span class="comment">     */</span>
<a name="l03122" id="l03122"></a>03122 
<a name="l03123" id="l03123"></a>03123     <span class="comment">/*</span>
<a name="l03124" id="l03124"></a>03124 <span class="comment">     * change our pointers </span>
<a name="l03125" id="l03125"></a>03125 <span class="comment">     */</span>
<a name="l03126" id="l03126"></a>03126     user-&gt;prev = pptr;
<a name="l03127" id="l03127"></a>03127     user-&gt;next = nptr;
<a name="l03128" id="l03128"></a>03128 
<a name="l03129" id="l03129"></a>03129     <span class="comment">/*</span>
<a name="l03130" id="l03130"></a>03130 <span class="comment">     * change the next's prev pointer </span>
<a name="l03131" id="l03131"></a>03131 <span class="comment">     */</span>
<a name="l03132" id="l03132"></a>03132     <span class="keywordflow">if</span> (user-&gt;next)
<a name="l03133" id="l03133"></a>03133         user-&gt;next-&gt;prev = user;
<a name="l03134" id="l03134"></a>03134 
<a name="l03135" id="l03135"></a>03135     <span class="comment">/*</span>
<a name="l03136" id="l03136"></a>03136 <span class="comment">     * change the prev's next pointer </span>
<a name="l03137" id="l03137"></a>03137 <span class="comment">     */</span>
<a name="l03138" id="l03138"></a>03138     <span class="keywordflow">if</span> (user-&gt;prev)
<a name="l03139" id="l03139"></a>03139         user-&gt;prev-&gt;next = user;
<a name="l03140" id="l03140"></a>03140 
<a name="l03141" id="l03141"></a>03141     <span class="comment">/*</span>
<a name="l03142" id="l03142"></a>03142 <span class=
"comment">     * rewind to the head of the list and return it (since the new head</span>
<a name="l03143" id="l03143"></a>03143 <span class=
"comment">     * could be us, we need to notify the above routine who the head now is. </span>
<a name="l03144" id="l03144"></a>03144 <span class="comment">     */</span>
<a name="l03145" id="l03145"></a>03145     <span class=
"keywordflow">for</span> (pptr = user; pptr-&gt;prev != NULL; pptr = pptr-&gt;prev);
<a name="l03146" id="l03146"></a>03146     <span class="keywordflow">return</span> pptr;
<a name="l03147" id="l03147"></a>03147 }
<a name="l03148" id="l03148"></a>03148 
<a name="l03149" id="l03149"></a>03149 <span class="comment">/*</span>
<a name="l03150" id="l03150"></a>03150 <span class="comment"> * usm_remove_user(): finds and removes a user from a list </span>
<a name="l03151" id="l03151"></a>03151 <span class="comment"> */</span>
<a name="l03152" id="l03152"></a>03152 <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *
<a name="l03153" id="l03153"></a>03153 usm_remove_user(<span class="keyword">struct</span> <a class="code" href=
"structusmUser.html">usmUser</a> *user)
<a name="l03154" id="l03154"></a>03154 {
<a name="l03155" id="l03155"></a>03155     <span class=
"keywordflow">return</span> usm_remove_user_from_list(user, &amp;userList);
<a name="l03156" id="l03156"></a>03156 }
<a name="l03157" id="l03157"></a>03157 
<a name="l03158" id="l03158"></a>03158 <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *
<a name="l03159" id="l03159"></a>03159 usm_remove_user_from_list(<span class="keyword">struct</span> <a class="code" href=
"structusmUser.html">usmUser</a> *user,
<a name="l03160" id="l03160"></a>03160                           <span class="keyword">struct</span> <a class="code" href=
"structusmUser.html">usmUser</a> **ppuserList)
<a name="l03161" id="l03161"></a>03161 {
<a name="l03162" id="l03162"></a>03162     <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *nptr, *pptr;
<a name="l03163" id="l03163"></a>03163 
<a name="l03164" id="l03164"></a>03164     <span class="comment">/*</span>
<a name="l03165" id="l03165"></a>03165 <span class="comment">     * NULL pointers aren't allowed </span>
<a name="l03166" id="l03166"></a>03166 <span class="comment">     */</span>
<a name="l03167" id="l03167"></a>03167     <span class="keywordflow">if</span> (ppuserList == NULL)
<a name="l03168" id="l03168"></a>03168         <span class="keywordflow">return</span> NULL;
<a name="l03169" id="l03169"></a>03169 
<a name="l03170" id="l03170"></a>03170     <span class="keywordflow">if</span> (*ppuserList == NULL)
<a name="l03171" id="l03171"></a>03171         <span class="keywordflow">return</span> NULL;
<a name="l03172" id="l03172"></a>03172 
<a name="l03173" id="l03173"></a>03173     <span class="comment">/*</span>
<a name="l03174" id="l03174"></a>03174 <span class="comment">     * find the user in the list </span>
<a name="l03175" id="l03175"></a>03175 <span class="comment">     */</span>
<a name="l03176" id="l03176"></a>03176     <span class="keywordflow">for</span> (nptr = *ppuserList, pptr = NULL; nptr != NULL;
<a name="l03177" id="l03177"></a>03177          pptr = nptr, nptr = nptr-&gt;next) {
<a name="l03178" id="l03178"></a>03178         <span class="keywordflow">if</span> (nptr == user)
<a name="l03179" id="l03179"></a>03179             <span class="keywordflow">break</span>;
<a name="l03180" id="l03180"></a>03180     }
<a name="l03181" id="l03181"></a>03181 
<a name="l03182" id="l03182"></a>03182     <span class="keywordflow">if</span> (nptr) {
<a name="l03183" id="l03183"></a>03183         <span class="comment">/*</span>
<a name="l03184" id="l03184"></a>03184 <span class="comment">         * remove the user from the linked list </span>
<a name="l03185" id="l03185"></a>03185 <span class="comment">         */</span>
<a name="l03186" id="l03186"></a>03186         <span class="keywordflow">if</span> (pptr) {
<a name="l03187" id="l03187"></a>03187             pptr-&gt;next = nptr-&gt;next;
<a name="l03188" id="l03188"></a>03188         }
<a name="l03189" id="l03189"></a>03189         <span class="keywordflow">if</span> (nptr-&gt;next) {
<a name="l03190" id="l03190"></a>03190             nptr-&gt;next-&gt;prev = pptr;
<a name="l03191" id="l03191"></a>03191         }
<a name="l03192" id="l03192"></a>03192     } <span class="keywordflow">else</span> {
<a name="l03193" id="l03193"></a>03193         <span class="comment">/*</span>
<a name="l03194" id="l03194"></a>03194 <span class="comment">         * user didn't exist </span>
<a name="l03195" id="l03195"></a>03195 <span class="comment">         */</span>
<a name="l03196" id="l03196"></a>03196         <span class="keywordflow">return</span> NULL;
<a name="l03197" id="l03197"></a>03197     }
<a name="l03198" id="l03198"></a>03198     <span class="keywordflow">if</span> (nptr == *ppuserList)    <span class=
"comment">/* we're the head of the list, need to change</span>
<a name="l03199" id="l03199"></a>03199 <span class=
"comment">                                 * * the head to the next user */</span>
<a name="l03200" id="l03200"></a>03200         *ppuserList = nptr-&gt;next;
<a name="l03201" id="l03201"></a>03201     <span class="keywordflow">return</span> *ppuserList;
<a name="l03202" id="l03202"></a>03202 }                               <span class=
"comment">/* end usm_remove_user_from_list() */</span>
<a name="l03203" id="l03203"></a>03203 
<a name="l03204" id="l03204"></a>03204 
<a name="l03205" id="l03205"></a>03205 
<a name="l03206" id="l03206"></a>03206 
<a name="l03207" id="l03207"></a>03207 <span class="comment">/*</span>
<a name="l03208" id="l03208"></a>03208 <span class=
"comment"> * usm_free_user():  calls free() on all needed parts of struct usmUser and</span>
<a name="l03209" id="l03209"></a>03209 <span class="comment"> * the user himself.</span>
<a name="l03210" id="l03210"></a>03210 <span class="comment"> * </span>
<a name="l03211" id="l03211"></a>03211 <span class=
"comment"> * Note: This should *not* be called on an object in a list (IE,</span>
<a name="l03212" id="l03212"></a>03212 <span class=
"comment"> * remove it from the list first, and set next and prev to NULL), but</span>
<a name="l03213" id="l03213"></a>03213 <span class=
"comment"> * will try to reconnect the list pieces again if it is called this</span>
<a name="l03214" id="l03214"></a>03214 <span class=
"comment"> * way.  If called on the head of the list, the entire list will be</span>
<a name="l03215" id="l03215"></a>03215 <span class="comment"> * lost. </span>
<a name="l03216" id="l03216"></a>03216 <span class="comment"> */</span>
<a name="l03217" id="l03217"></a>03217 <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *
<a name="l03218" id="l03218"></a>03218 usm_free_user(<span class="keyword">struct</span> <a class="code" href=
"structusmUser.html">usmUser</a> *user)
<a name="l03219" id="l03219"></a>03219 {
<a name="l03220" id="l03220"></a>03220     <span class="keywordflow">if</span> (user == NULL)
<a name="l03221" id="l03221"></a>03221         <span class="keywordflow">return</span> NULL;
<a name="l03222" id="l03222"></a>03222 
<a name="l03223" id="l03223"></a>03223     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;engineID);
<a name="l03224" id="l03224"></a>03224     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;name);
<a name="l03225" id="l03225"></a>03225     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;secName);
<a name="l03226" id="l03226"></a>03226     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;cloneFrom);
<a name="l03227" id="l03227"></a>03227     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;userPublicString);
<a name="l03228" id="l03228"></a>03228     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;authProtocol);
<a name="l03229" id="l03229"></a>03229     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;privProtocol);
<a name="l03230" id="l03230"></a>03230 
<a name="l03231" id="l03231"></a>03231     <span class="keywordflow">if</span> (user-&gt;authKey != NULL) {
<a name="l03232" id="l03232"></a>03232         <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title=
"Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(user-&gt;authKey, user-&gt;authKeyLen);
<a name="l03233" id="l03233"></a>03233         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;authKey);
<a name="l03234" id="l03234"></a>03234     }
<a name="l03235" id="l03235"></a>03235 
<a name="l03236" id="l03236"></a>03236     <span class="keywordflow">if</span> (user-&gt;privKey != NULL) {
<a name="l03237" id="l03237"></a>03237         <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title=
"Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(user-&gt;privKey, user-&gt;privKeyLen);
<a name="l03238" id="l03238"></a>03238         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;privKey);
<a name="l03239" id="l03239"></a>03239     }
<a name="l03240" id="l03240"></a>03240 
<a name="l03241" id="l03241"></a>03241 
<a name="l03242" id="l03242"></a>03242     <span class="comment">/*</span>
<a name="l03243" id="l03243"></a>03243 <span class="comment">     * FIX  Why not put this check *first?*</span>
<a name="l03244" id="l03244"></a>03244 <span class="comment">     */</span>
<a name="l03245" id="l03245"></a>03245     <span class="keywordflow">if</span> (user-&gt;prev != NULL) {   <span class=
"comment">/* ack, this shouldn't happen */</span>
<a name="l03246" id="l03246"></a>03246         user-&gt;prev-&gt;next = user-&gt;next;
<a name="l03247" id="l03247"></a>03247     }
<a name="l03248" id="l03248"></a>03248     <span class="keywordflow">if</span> (user-&gt;next != NULL) {
<a name="l03249" id="l03249"></a>03249         user-&gt;next-&gt;prev = user-&gt;prev;
<a name="l03250" id="l03250"></a>03250         <span class="keywordflow">if</span> (user-&gt;prev != NULL) <span class=
"comment">/* ack this is really bad, because it means</span>
<a name="l03251" id="l03251"></a>03251 <span class=
"comment">                                 * * we'll loose the head of some structure tree */</span>
<a name="l03252" id="l03252"></a>03252             DEBUGMSGTL((<span class="stringliteral">"usm"</span>,
<a name="l03253" id="l03253"></a>03253                         <span class=
"stringliteral">"Severe: Asked to free the head of a usmUser tree somewhere."</span>));
<a name="l03254" id="l03254"></a>03254     }
<a name="l03255" id="l03255"></a>03255 
<a name="l03256" id="l03256"></a>03256 
<a name="l03257" id="l03257"></a>03257     <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title=
"Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(user, <span class="keyword">sizeof</span>(*user));
<a name="l03258" id="l03258"></a>03258     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user);
<a name="l03259" id="l03259"></a>03259 
<a name="l03260" id="l03260"></a>03260     <span class="keywordflow">return</span> NULL;                <span class=
"comment">/* for convenience to returns from calling functions */</span>
<a name="l03261" id="l03261"></a>03261 
<a name="l03262" id="l03262"></a>03262 }                               <span class="comment">/* end usm_free_user() */</span>
<a name="l03263" id="l03263"></a>03263 
<a name="l03264" id="l03264"></a>03264 
<a name="l03265" id="l03265"></a>03265 
<a name="l03266" id="l03266"></a>03266 
<a name="l03267" id="l03267"></a>03267 <span class="comment">/*</span>
<a name="l03268" id="l03268"></a>03268 <span class=
"comment"> * take a given user and clone the security info into another </span>
<a name="l03269" id="l03269"></a>03269 <span class="comment"> */</span>
<a name="l03270" id="l03270"></a>03270 <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *
<a name="l03271" id="l03271"></a>03271 usm_cloneFrom_user(<span class="keyword">struct</span> <a class="code" href=
"structusmUser.html">usmUser</a> *from, <span class="keyword">struct</span> <a class="code" href=
"structusmUser.html">usmUser</a> *to)
<a name="l03272" id="l03272"></a>03272 {
<a name="l03273" id="l03273"></a>03273     <span class="comment">/*</span>
<a name="l03274" id="l03274"></a>03274 <span class="comment">     * copy the authProtocol oid row pointer </span>
<a name="l03275" id="l03275"></a>03275 <span class="comment">     */</span>
<a name="l03276" id="l03276"></a>03276     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(to-&gt;authProtocol);
<a name="l03277" id="l03277"></a>03277 
<a name="l03278" id="l03278"></a>03278     <span class="keywordflow">if</span> ((to-&gt;authProtocol =
<a name="l03279" id="l03279"></a>03279          snmp_duplicate_objid(from-&gt;authProtocol,
<a name="l03280" id="l03280"></a>03280                               from-&gt;authProtocolLen)) != NULL)
<a name="l03281" id="l03281"></a>03281         to-&gt;authProtocolLen = from-&gt;authProtocolLen;
<a name="l03282" id="l03282"></a>03282     <span class="keywordflow">else</span>
<a name="l03283" id="l03283"></a>03283         to-&gt;authProtocolLen = 0;
<a name="l03284" id="l03284"></a>03284 
<a name="l03285" id="l03285"></a>03285 
<a name="l03286" id="l03286"></a>03286     <span class="comment">/*</span>
<a name="l03287" id="l03287"></a>03287 <span class="comment">     * copy the authKey </span>
<a name="l03288" id="l03288"></a>03288 <span class="comment">     */</span>
<a name="l03289" id="l03289"></a>03289     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(to-&gt;authKey);
<a name="l03290" id="l03290"></a>03290 
<a name="l03291" id="l03291"></a>03291     <span class="keywordflow">if</span> (from-&gt;authKeyLen &gt; 0 &amp;&amp;
<a name="l03292" id="l03292"></a>03292         (to-&gt;authKey = (u_char *) malloc(from-&gt;authKeyLen))
<a name="l03293" id="l03293"></a>03293         != NULL) {
<a name="l03294" id="l03294"></a>03294         to-&gt;authKeyLen = from-&gt;authKeyLen;
<a name="l03295" id="l03295"></a>03295         memcpy(to-&gt;authKey, from-&gt;authKey, to-&gt;authKeyLen);
<a name="l03296" id="l03296"></a>03296     } <span class="keywordflow">else</span> {
<a name="l03297" id="l03297"></a>03297         to-&gt;authKey = NULL;
<a name="l03298" id="l03298"></a>03298         to-&gt;authKeyLen = 0;
<a name="l03299" id="l03299"></a>03299     }
<a name="l03300" id="l03300"></a>03300 
<a name="l03301" id="l03301"></a>03301 
<a name="l03302" id="l03302"></a>03302     <span class="comment">/*</span>
<a name="l03303" id="l03303"></a>03303 <span class="comment">     * copy the privProtocol oid row pointer </span>
<a name="l03304" id="l03304"></a>03304 <span class="comment">     */</span>
<a name="l03305" id="l03305"></a>03305     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(to-&gt;privProtocol);
<a name="l03306" id="l03306"></a>03306 
<a name="l03307" id="l03307"></a>03307     <span class="keywordflow">if</span> ((to-&gt;privProtocol =
<a name="l03308" id="l03308"></a>03308          snmp_duplicate_objid(from-&gt;privProtocol,
<a name="l03309" id="l03309"></a>03309                               from-&gt;privProtocolLen)) != NULL)
<a name="l03310" id="l03310"></a>03310         to-&gt;privProtocolLen = from-&gt;privProtocolLen;
<a name="l03311" id="l03311"></a>03311     <span class="keywordflow">else</span>
<a name="l03312" id="l03312"></a>03312         to-&gt;privProtocolLen = 0;
<a name="l03313" id="l03313"></a>03313 
<a name="l03314" id="l03314"></a>03314     <span class="comment">/*</span>
<a name="l03315" id="l03315"></a>03315 <span class="comment">     * copy the privKey </span>
<a name="l03316" id="l03316"></a>03316 <span class="comment">     */</span>
<a name="l03317" id="l03317"></a>03317     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(to-&gt;privKey);
<a name="l03318" id="l03318"></a>03318 
<a name="l03319" id="l03319"></a>03319     <span class="keywordflow">if</span> (from-&gt;privKeyLen &gt; 0 &amp;&amp;
<a name="l03320" id="l03320"></a>03320         (to-&gt;privKey = (u_char *) malloc(from-&gt;privKeyLen))
<a name="l03321" id="l03321"></a>03321         != NULL) {
<a name="l03322" id="l03322"></a>03322         to-&gt;privKeyLen = from-&gt;privKeyLen;
<a name="l03323" id="l03323"></a>03323         memcpy(to-&gt;privKey, from-&gt;privKey, to-&gt;privKeyLen);
<a name="l03324" id="l03324"></a>03324     } <span class="keywordflow">else</span> {
<a name="l03325" id="l03325"></a>03325         to-&gt;privKey = NULL;
<a name="l03326" id="l03326"></a>03326         to-&gt;privKeyLen = 0;
<a name="l03327" id="l03327"></a>03327     }
<a name="l03328" id="l03328"></a>03328     <span class="keywordflow">return</span> to;
<a name="l03329" id="l03329"></a>03329 }
<a name="l03330" id="l03330"></a>03330 
<a name="l03331" id="l03331"></a>03331 <span class="comment">/*</span>
<a name="l03332" id="l03332"></a>03332 <span class="comment"> * usm_create_user(void):</span>
<a name="l03333" id="l03333"></a>03333 <span class=
"comment"> * create a default empty user, instantiating only the auth/priv</span>
<a name="l03334" id="l03334"></a>03334 <span class="comment"> * protocols to noAuth and noPriv OID pointers</span>
<a name="l03335" id="l03335"></a>03335 <span class="comment"> */</span>
<a name="l03336" id="l03336"></a>03336 <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *
<a name="l03337" id="l03337"></a>03337 usm_create_user(<span class="keywordtype">void</span>)
<a name="l03338" id="l03338"></a>03338 {
<a name="l03339" id="l03339"></a>03339     <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *newUser;
<a name="l03340" id="l03340"></a>03340 
<a name="l03341" id="l03341"></a>03341     <span class="comment">/*</span>
<a name="l03342" id="l03342"></a>03342 <span class="comment">     * create the new user </span>
<a name="l03343" id="l03343"></a>03343 <span class="comment">     */</span>
<a name="l03344" id="l03344"></a>03344     newUser = (<span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *) calloc(1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class=
"code" href="structusmUser.html">usmUser</a>));
<a name="l03345" id="l03345"></a>03345     <span class="keywordflow">if</span> (newUser == NULL)
<a name="l03346" id="l03346"></a>03346         <span class="keywordflow">return</span> NULL;
<a name="l03347" id="l03347"></a>03347 
<a name="l03348" id="l03348"></a>03348     <span class="comment">/*</span>
<a name="l03349" id="l03349"></a>03349 <span class="comment">     * fill the auth/priv protocols </span>
<a name="l03350" id="l03350"></a>03350 <span class="comment">     */</span>
<a name="l03351" id="l03351"></a>03351     <span class="keywordflow">if</span> ((newUser-&gt;authProtocol =
<a name="l03352" id="l03352"></a>03352          snmp_duplicate_objid(usmNoAuthProtocol,
<a name="l03353" id="l03353"></a>03353                               <span class=
"keyword">sizeof</span>(usmNoAuthProtocol) / <span class="keyword">sizeof</span>(oid))) ==
<a name="l03354" id="l03354"></a>03354         NULL)
<a name="l03355" id="l03355"></a>03355         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03356" id="l03356"></a>03356     newUser-&gt;authProtocolLen = <span class=
"keyword">sizeof</span>(usmNoAuthProtocol) / <span class="keyword">sizeof</span>(oid);
<a name="l03357" id="l03357"></a>03357 
<a name="l03358" id="l03358"></a>03358     <span class="keywordflow">if</span> ((newUser-&gt;privProtocol =
<a name="l03359" id="l03359"></a>03359          snmp_duplicate_objid(usmNoPrivProtocol,
<a name="l03360" id="l03360"></a>03360                               <span class=
"keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid))) ==
<a name="l03361" id="l03361"></a>03361         NULL)
<a name="l03362" id="l03362"></a>03362         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03363" id="l03363"></a>03363     newUser-&gt;privProtocolLen = <span class=
"keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid);
<a name="l03364" id="l03364"></a>03364 
<a name="l03365" id="l03365"></a>03365     <span class="comment">/*</span>
<a name="l03366" id="l03366"></a>03366 <span class=
"comment">     * set the storage type to nonvolatile, and the status to ACTIVE </span>
<a name="l03367" id="l03367"></a>03367 <span class="comment">     */</span>
<a name="l03368" id="l03368"></a>03368     newUser-&gt;userStorageType = ST_NONVOLATILE;
<a name="l03369" id="l03369"></a>03369     newUser-&gt;userStatus = RS_ACTIVE;
<a name="l03370" id="l03370"></a>03370     <span class="keywordflow">return</span> newUser;
<a name="l03371" id="l03371"></a>03371 
<a name="l03372" id="l03372"></a>03372 }                               <span class="comment">/* end usm_clone_user() */</span>
<a name="l03373" id="l03373"></a>03373 
<a name="l03374" id="l03374"></a>03374 
<a name="l03375" id="l03375"></a>03375 
<a name="l03376" id="l03376"></a>03376 
<a name="l03377" id="l03377"></a>03377 <span class="comment">/*</span>
<a name="l03378" id="l03378"></a>03378 <span class="comment"> * usm_create_initial_user(void):</span>
<a name="l03379" id="l03379"></a>03379 <span class=
"comment"> * creates an initial user, filled with the defaults defined in the</span>
<a name="l03380" id="l03380"></a>03380 <span class="comment"> * USM document.</span>
<a name="l03381" id="l03381"></a>03381 <span class="comment"> */</span>
<a name="l03382" id="l03382"></a>03382 <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *
<a name="l03383" id="l03383"></a>03383 usm_create_initial_user(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *name,
<a name="l03384" id="l03384"></a>03384                         <span class=
"keyword">const</span> oid * authProtocol, <span class="keywordtype">size_t</span> authProtocolLen,
<a name="l03385" id="l03385"></a>03385                         <span class=
"keyword">const</span> oid * privProtocol, <span class="keywordtype">size_t</span> privProtocolLen)
<a name="l03386" id="l03386"></a>03386 {
<a name="l03387" id="l03387"></a>03387     <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *newUser = usm_create_user();
<a name="l03388" id="l03388"></a>03388     <span class="keywordflow">if</span> (newUser == NULL)
<a name="l03389" id="l03389"></a>03389         <span class="keywordflow">return</span> NULL;
<a name="l03390" id="l03390"></a>03390 
<a name="l03391" id="l03391"></a>03391     <span class="keywordflow">if</span> ((newUser-&gt;name = strdup(name)) == NULL)
<a name="l03392" id="l03392"></a>03392         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03393" id="l03393"></a>03393 
<a name="l03394" id="l03394"></a>03394     <span class="keywordflow">if</span> ((newUser-&gt;secName = strdup(name)) == NULL)
<a name="l03395" id="l03395"></a>03395         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03396" id="l03396"></a>03396 
<a name="l03397" id="l03397"></a>03397     <span class="keywordflow">if</span> ((newUser-&gt;engineID =
<a name="l03398" id="l03398"></a>03398          snmpv3_generate_engineID(&amp;newUser-&gt;engineIDLen)) == NULL)
<a name="l03399" id="l03399"></a>03399         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03400" id="l03400"></a>03400 
<a name="l03401" id="l03401"></a>03401     <span class=
"keywordflow">if</span> ((newUser-&gt;cloneFrom = (oid *) malloc(<span class="keyword">sizeof</span>(oid) * 2)) == NULL)
<a name="l03402" id="l03402"></a>03402         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03403" id="l03403"></a>03403     newUser-&gt;cloneFrom[0] = 0;
<a name="l03404" id="l03404"></a>03404     newUser-&gt;cloneFrom[1] = 0;
<a name="l03405" id="l03405"></a>03405     newUser-&gt;cloneFromLen = 2;
<a name="l03406" id="l03406"></a>03406 
<a name="l03407" id="l03407"></a>03407     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(newUser-&gt;privProtocol);
<a name="l03408" id="l03408"></a>03408     <span class=
"keywordflow">if</span> ((newUser-&gt;privProtocol = snmp_duplicate_objid(privProtocol,
<a name="l03409" id="l03409"></a>03409                                                       privProtocolLen)) ==
<a name="l03410" id="l03410"></a>03410         NULL) {
<a name="l03411" id="l03411"></a>03411         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03412" id="l03412"></a>03412     }
<a name="l03413" id="l03413"></a>03413     newUser-&gt;privProtocolLen = privProtocolLen;
<a name="l03414" id="l03414"></a>03414 
<a name="l03415" id="l03415"></a>03415     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(newUser-&gt;authProtocol);
<a name="l03416" id="l03416"></a>03416     <span class=
"keywordflow">if</span> ((newUser-&gt;authProtocol = snmp_duplicate_objid(authProtocol,
<a name="l03417" id="l03417"></a>03417                                                       authProtocolLen)) ==
<a name="l03418" id="l03418"></a>03418         NULL) {
<a name="l03419" id="l03419"></a>03419         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03420" id="l03420"></a>03420     }
<a name="l03421" id="l03421"></a>03421     newUser-&gt;authProtocolLen = authProtocolLen;
<a name="l03422" id="l03422"></a>03422 
<a name="l03423" id="l03423"></a>03423     newUser-&gt;userStatus = RS_ACTIVE;
<a name="l03424" id="l03424"></a>03424     newUser-&gt;userStorageType = ST_READONLY;
<a name="l03425" id="l03425"></a>03425 
<a name="l03426" id="l03426"></a>03426     <span class="keywordflow">return</span> newUser;
<a name="l03427" id="l03427"></a>03427 }
<a name="l03428" id="l03428"></a>03428 
<a name="l03429" id="l03429"></a>03429 <span class="comment">/*</span>
<a name="l03430" id="l03430"></a>03430 <span class=
"comment"> * this is a callback that can store all known users based on a</span>
<a name="l03431" id="l03431"></a>03431 <span class="comment"> * previously registered application ID </span>
<a name="l03432" id="l03432"></a>03432 <span class="comment"> */</span>
<a name="l03433" id="l03433"></a>03433 <span class="keywordtype">int</span>
<a name="l03434" id="l03434"></a>03434 usm_store_users(<span class="keywordtype">int</span> majorID, <span class=
"keywordtype">int</span> minorID, <span class="keywordtype">void</span> *serverarg, <span class=
"keywordtype">void</span> *clientarg)
<a name="l03435" id="l03435"></a>03435 {
<a name="l03436" id="l03436"></a>03436     <span class="comment">/*</span>
<a name="l03437" id="l03437"></a>03437 <span class="comment">     * figure out our application name </span>
<a name="l03438" id="l03438"></a>03438 <span class="comment">     */</span>
<a name="l03439" id="l03439"></a>03439     <span class="keywordtype">char</span>           *appname = (<span class=
"keywordtype">char</span> *) clientarg;
<a name="l03440" id="l03440"></a>03440     <span class="keywordflow">if</span> (appname == NULL) {
<a name="l03441" id="l03441"></a>03441         appname = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
<a name="l03442" id="l03442"></a>03442                                         NETSNMP_DS_LIB_APPTYPE);
<a name="l03443" id="l03443"></a>03443     }
<a name="l03444" id="l03444"></a>03444 
<a name="l03445" id="l03445"></a>03445     <span class="comment">/*</span>
<a name="l03446" id="l03446"></a>03446 <span class="comment">     * save the user base </span>
<a name="l03447" id="l03447"></a>03447 <span class="comment">     */</span>
<a name="l03448" id="l03448"></a>03448     usm_save_users(<span class="stringliteral">"usmUser"</span>, appname);
<a name="l03449" id="l03449"></a>03449 
<a name="l03450" id="l03450"></a>03450     <span class="comment">/*</span>
<a name="l03451" id="l03451"></a>03451 <span class="comment">     * never fails </span>
<a name="l03452" id="l03452"></a>03452 <span class="comment">     */</span>
<a name="l03453" id="l03453"></a>03453     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l03454" id="l03454"></a>03454 }
<a name="l03455" id="l03455"></a>03455 
<a name="l03456" id="l03456"></a>03456 
<a name="l03457" id="l03457"></a>03457 <span class="comment">/*</span>
<a name="l03458" id="l03458"></a>03458 <span class=
"comment"> * usm_save_users(): saves a list of users to the persistent cache </span>
<a name="l03459" id="l03459"></a>03459 <span class="comment"> */</span>
<a name="l03460" id="l03460"></a>03460 <span class="keywordtype">void</span>
<a name="l03461" id="l03461"></a>03461 usm_save_users(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *token, <span class="keyword">const</span> <span class="keywordtype">char</span> *type)
<a name="l03462" id="l03462"></a>03462 {
<a name="l03463" id="l03463"></a>03463     usm_save_users_from_list(userList, token, type);
<a name="l03464" id="l03464"></a>03464 }
<a name="l03465" id="l03465"></a>03465 
<a name="l03466" id="l03466"></a>03466 <span class="keywordtype">void</span>
<a name="l03467" id="l03467"></a>03467 usm_save_users_from_list(<span class="keyword">struct</span> <a class="code" href=
"structusmUser.html">usmUser</a> *puserList, <span class="keyword">const</span> <span class="keywordtype">char</span> *token,
<a name="l03468" id="l03468"></a>03468                          <span class="keyword">const</span> <span class=
"keywordtype">char</span> *type)
<a name="l03469" id="l03469"></a>03469 {
<a name="l03470" id="l03470"></a>03470     <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *uptr;
<a name="l03471" id="l03471"></a>03471     <span class=
"keywordflow">for</span> (uptr = puserList; uptr != NULL; uptr = uptr-&gt;next) {
<a name="l03472" id="l03472"></a>03472         <span class="keywordflow">if</span> (uptr-&gt;userStorageType == ST_NONVOLATILE)
<a name="l03473" id="l03473"></a>03473             usm_save_user(uptr, token, type);
<a name="l03474" id="l03474"></a>03474     }
<a name="l03475" id="l03475"></a>03475 }
<a name="l03476" id="l03476"></a>03476 
<a name="l03477" id="l03477"></a>03477 <span class="comment">/*</span>
<a name="l03478" id="l03478"></a>03478 <span class="comment"> * usm_save_user(): saves a user to the persistent cache </span>
<a name="l03479" id="l03479"></a>03479 <span class="comment"> */</span>
<a name="l03480" id="l03480"></a>03480 <span class="keywordtype">void</span>
<a name="l03481" id="l03481"></a>03481 usm_save_user(<span class="keyword">struct</span> <a class="code" href=
"structusmUser.html">usmUser</a> *user, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *token, <span class="keyword">const</span> <span class="keywordtype">char</span> *type)
<a name="l03482" id="l03482"></a>03482 {
<a name="l03483" id="l03483"></a>03483     <span class="keywordtype">char</span>            line[4096];
<a name="l03484" id="l03484"></a>03484     <span class="keywordtype">char</span>           *cptr;
<a name="l03485" id="l03485"></a>03485 
<a name="l03486" id="l03486"></a>03486     memset(line, 0, <span class="keyword">sizeof</span>(line));
<a name="l03487" id="l03487"></a>03487 
<a name="l03488" id="l03488"></a>03488     sprintf(line, <span class=
"stringliteral">"%s %d %d "</span>, token, user-&gt;userStatus,
<a name="l03489" id="l03489"></a>03489             user-&gt;userStorageType);
<a name="l03490" id="l03490"></a>03490     cptr = &amp;line[strlen(line)]; <span class="comment">/* the NULL */</span>
<a name="l03491" id="l03491"></a>03491     cptr =
<a name="l03492" id="l03492"></a>03492         read_config_save_octet_string(cptr, user-&gt;engineID,
<a name="l03493" id="l03493"></a>03493                                       user-&gt;engineIDLen);
<a name="l03494" id="l03494"></a>03494     *cptr++ = <span class="charliteral">' '</span>;
<a name="l03495" id="l03495"></a>03495     cptr = read_config_save_octet_string(cptr, (u_char *) user-&gt;name,
<a name="l03496" id="l03496"></a>03496                                          (user-&gt;name == NULL) ? 0 :
<a name="l03497" id="l03497"></a>03497                                          strlen(user-&gt;name) + 1);
<a name="l03498" id="l03498"></a>03498     *cptr++ = <span class="charliteral">' '</span>;
<a name="l03499" id="l03499"></a>03499     cptr = read_config_save_octet_string(cptr, (u_char *) user-&gt;secName,
<a name="l03500" id="l03500"></a>03500                                          (user-&gt;secName == NULL) ? 0 :
<a name="l03501" id="l03501"></a>03501                                          strlen(user-&gt;secName) + 1);
<a name="l03502" id="l03502"></a>03502     *cptr++ = <span class="charliteral">' '</span>;
<a name="l03503" id="l03503"></a>03503     cptr =
<a name="l03504" id="l03504"></a>03504         read_config_save_objid(cptr, user-&gt;cloneFrom, user-&gt;cloneFromLen);
<a name="l03505" id="l03505"></a>03505     *cptr++ = <span class="charliteral">' '</span>;
<a name="l03506" id="l03506"></a>03506     cptr = read_config_save_objid(cptr, user-&gt;authProtocol,
<a name="l03507" id="l03507"></a>03507                                   user-&gt;authProtocolLen);
<a name="l03508" id="l03508"></a>03508     *cptr++ = <span class="charliteral">' '</span>;
<a name="l03509" id="l03509"></a>03509     cptr =
<a name="l03510" id="l03510"></a>03510         read_config_save_octet_string(cptr, user-&gt;authKey,
<a name="l03511" id="l03511"></a>03511                                       user-&gt;authKeyLen);
<a name="l03512" id="l03512"></a>03512     *cptr++ = <span class="charliteral">' '</span>;
<a name="l03513" id="l03513"></a>03513     cptr = read_config_save_objid(cptr, user-&gt;privProtocol,
<a name="l03514" id="l03514"></a>03514                                   user-&gt;privProtocolLen);
<a name="l03515" id="l03515"></a>03515     *cptr++ = <span class="charliteral">' '</span>;
<a name="l03516" id="l03516"></a>03516     cptr =
<a name="l03517" id="l03517"></a>03517         read_config_save_octet_string(cptr, user-&gt;privKey,
<a name="l03518" id="l03518"></a>03518                                       user-&gt;privKeyLen);
<a name="l03519" id="l03519"></a>03519     *cptr++ = <span class="charliteral">' '</span>;
<a name="l03520" id="l03520"></a>03520     cptr = read_config_save_octet_string(cptr, user-&gt;userPublicString,
<a name="l03521" id="l03521"></a>03521                                          user-&gt;userPublicStringLen);
<a name="l03522" id="l03522"></a>03522 
<a name="l03523" id="l03523"></a>03523     <a class="code" href="group__read__config.html#gae3adadf24d35a919f4b7a603e47583df"
title="read_config_store intended for use by applications to store permenant configuration...">read_config_store</a>(type, line);
<a name="l03524" id="l03524"></a>03524 }
<a name="l03525" id="l03525"></a>03525 
<a name="l03526" id="l03526"></a>03526 <span class="comment">/*</span>
<a name="l03527" id="l03527"></a>03527 <span class=
"comment"> * usm_parse_user(): reads in a line containing a saved user profile</span>
<a name="l03528" id="l03528"></a>03528 <span class="comment"> * and returns a pointer to a newly created struct usmUser. </span>
<a name="l03529" id="l03529"></a>03529 <span class="comment"> */</span>
<a name="l03530" id="l03530"></a>03530 <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *
<a name="l03531" id="l03531"></a>03531 usm_read_user(<span class="keywordtype">char</span> *line)
<a name="l03532" id="l03532"></a>03532 {
<a name="l03533" id="l03533"></a>03533     <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *user;
<a name="l03534" id="l03534"></a>03534     <span class="keywordtype">size_t</span>          len;
<a name="l03535" id="l03535"></a>03535     <span class="keywordtype">size_t</span> expected_privKeyLen = 0;
<a name="l03536" id="l03536"></a>03536 
<a name="l03537" id="l03537"></a>03537     user = usm_create_user();
<a name="l03538" id="l03538"></a>03538     <span class="keywordflow">if</span> (user == NULL)
<a name="l03539" id="l03539"></a>03539         <span class="keywordflow">return</span> NULL;
<a name="l03540" id="l03540"></a>03540 
<a name="l03541" id="l03541"></a>03541     user-&gt;userStatus = atoi(line);
<a name="l03542" id="l03542"></a>03542     line = skip_token(line);
<a name="l03543" id="l03543"></a>03543     user-&gt;userStorageType = atoi(line);
<a name="l03544" id="l03544"></a>03544     line = skip_token(line);
<a name="l03545" id="l03545"></a>03545     line = read_config_read_octet_string(line, &amp;user-&gt;engineID,
<a name="l03546" id="l03546"></a>03546                                          &amp;user-&gt;engineIDLen);
<a name="l03547" id="l03547"></a>03547 
<a name="l03548" id="l03548"></a>03548     <span class="comment">/*</span>
<a name="l03549" id="l03549"></a>03549 <span class=
"comment">     * set the lcd entry for this engineID to the minimum boots/time</span>
<a name="l03550" id="l03550"></a>03550 <span class=
"comment">     * values so that its a known engineid and won't return a report pdu.</span>
<a name="l03551" id="l03551"></a>03551 <span class=
"comment">     * This is mostly important when receiving v3 traps so that the usm</span>
<a name="l03552" id="l03552"></a>03552 <span class="comment">     * will at least continue processing them. </span>
<a name="l03553" id="l03553"></a>03553 <span class="comment">     */</span>
<a name="l03554" id="l03554"></a>03554     set_enginetime(user-&gt;engineID, user-&gt;engineIDLen, 1, 0, 0);
<a name="l03555" id="l03555"></a>03555 
<a name="l03556" id="l03556"></a>03556     line = read_config_read_octet_string(line, (u_char **) &amp; user-&gt;name,
<a name="l03557" id="l03557"></a>03557                                          &amp;len);
<a name="l03558" id="l03558"></a>03558     line = read_config_read_octet_string(line, (u_char **) &amp; user-&gt;secName,
<a name="l03559" id="l03559"></a>03559                                          &amp;len);
<a name="l03560" id="l03560"></a>03560     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;cloneFrom);
<a name="l03561" id="l03561"></a>03561     user-&gt;cloneFromLen = 0;
<a name="l03562" id="l03562"></a>03562 
<a name="l03563" id="l03563"></a>03563     line =
<a name="l03564" id="l03564"></a>03564         read_config_read_objid(line, &amp;user-&gt;cloneFrom,
<a name="l03565" id="l03565"></a>03565                                &amp;user-&gt;cloneFromLen);
<a name="l03566" id="l03566"></a>03566 
<a name="l03567" id="l03567"></a>03567     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;authProtocol);
<a name="l03568" id="l03568"></a>03568     user-&gt;authProtocolLen = 0;
<a name="l03569" id="l03569"></a>03569 
<a name="l03570" id="l03570"></a>03570     line = read_config_read_objid(line, &amp;user-&gt;authProtocol,
<a name="l03571" id="l03571"></a>03571                                   &amp;user-&gt;authProtocolLen);
<a name="l03572" id="l03572"></a>03572     line = read_config_read_octet_string(line, &amp;user-&gt;authKey,
<a name="l03573" id="l03573"></a>03573                                          &amp;user-&gt;authKeyLen);
<a name="l03574" id="l03574"></a>03574     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;privProtocol);
<a name="l03575" id="l03575"></a>03575     user-&gt;privProtocolLen = 0;
<a name="l03576" id="l03576"></a>03576 
<a name="l03577" id="l03577"></a>03577     line = read_config_read_objid(line, &amp;user-&gt;privProtocol,
<a name="l03578" id="l03578"></a>03578                                   &amp;user-&gt;privProtocolLen);
<a name="l03579" id="l03579"></a>03579     line = read_config_read_octet_string(line, &amp;user-&gt;privKey,
<a name="l03580" id="l03580"></a>03580                                          &amp;user-&gt;privKeyLen);
<a name="l03581" id="l03581"></a>03581 <span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l03582" id="l03582"></a>03582     <span class="keywordflow">if</span> (ISTRANSFORM(user-&gt;privProtocol, DESPriv)) {
<a name="l03583" id="l03583"></a>03583         <span class=
"comment">/* DES uses a 128 bit key, 64 bits of which is a salt */</span>
<a name="l03584" id="l03584"></a>03584         expected_privKeyLen = 16;
<a name="l03585" id="l03585"></a>03585     }
<a name="l03586" id="l03586"></a>03586 <span class="preprocessor">#endif</span>
<a name="l03587" id="l03587"></a>03587 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l03588" id="l03588"></a>03588     <span class="keywordflow">if</span> (ISTRANSFORM(user-&gt;privProtocol, AESPriv)) {
<a name="l03589" id="l03589"></a>03589         expected_privKeyLen = 16;
<a name="l03590" id="l03590"></a>03590     }
<a name="l03591" id="l03591"></a>03591 <span class="preprocessor">#endif</span>
<a name="l03592" id="l03592"></a>03592     <span class="comment">/* For backwards compatibility */</span>
<a name="l03593" id="l03593"></a>03593     <span class="keywordflow">if</span> (user-&gt;privKeyLen &gt; expected_privKeyLen) {
<a name="l03594" id="l03594"></a>03594           user-&gt;privKeyLen = expected_privKeyLen;
<a name="l03595" id="l03595"></a>03595     }
<a name="l03596" id="l03596"></a>03596 
<a name="l03597" id="l03597"></a>03597     line = read_config_read_octet_string(line, &amp;user-&gt;userPublicString,
<a name="l03598" id="l03598"></a>03598                                          &amp;user-&gt;userPublicStringLen);
<a name="l03599" id="l03599"></a>03599     <span class="keywordflow">return</span> user;
<a name="l03600" id="l03600"></a>03600 }
<a name="l03601" id="l03601"></a>03601 
<a name="l03602" id="l03602"></a>03602 <span class="comment">/*</span>
<a name="l03603" id="l03603"></a>03603 <span class="comment"> * snmpd.conf parsing routines </span>
<a name="l03604" id="l03604"></a>03604 <span class="comment"> */</span>
<a name="l03605" id="l03605"></a>03605 <span class="keywordtype">void</span>
<a name="l03606" id="l03606"></a>03606 usm_parse_config_usmUser(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *token, <span class="keywordtype">char</span> *line)
<a name="l03607" id="l03607"></a>03607 {
<a name="l03608" id="l03608"></a>03608     <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *uptr;
<a name="l03609" id="l03609"></a>03609 
<a name="l03610" id="l03610"></a>03610     uptr = usm_read_user(line);
<a name="l03611" id="l03611"></a>03611     <span class="keywordflow">if</span> ( uptr)
<a name="l03612" id="l03612"></a>03612         usm_add_user(uptr);
<a name="l03613" id="l03613"></a>03613 }
<a name="l03614" id="l03614"></a>03614 
<a name="l03615" id="l03615"></a>03615 
<a name="l03616" id="l03616"></a>03616 
<a name="l03617" id="l03617"></a>03617 
<a name="l03618" id="l03618"></a>03618 <span class=
"comment">/*******************************************************************-o-******</span>
<a name="l03619" id="l03619"></a>03619 <span class="comment"> * usm_set_password</span>
<a name="l03620" id="l03620"></a>03620 <span class="comment"> *</span>
<a name="l03621" id="l03621"></a>03621 <span class="comment"> * Parameters:</span>
<a name="l03622" id="l03622"></a>03622 <span class="comment"> *      *token</span>
<a name="l03623" id="l03623"></a>03623 <span class="comment"> *      *line</span>
<a name="l03624" id="l03624"></a>03624 <span class="comment"> *      </span>
<a name="l03625" id="l03625"></a>03625 <span class="comment"> *</span>
<a name="l03626" id="l03626"></a>03626 <span class=
"comment"> * format: userSetAuthPass     secname engineIDLen engineID pass</span>
<a name="l03627" id="l03627"></a>03627 <span class=
"comment"> *     or: userSetPrivPass     secname engineIDLen engineID pass </span>
<a name="l03628" id="l03628"></a>03628 <span class=
"comment"> *     or: userSetAuthKey      secname engineIDLen engineID KuLen Ku</span>
<a name="l03629" id="l03629"></a>03629 <span class=
"comment"> *     or: userSetPrivKey      secname engineIDLen engineID KuLen Ku </span>
<a name="l03630" id="l03630"></a>03630 <span class=
"comment"> *     or: userSetAuthLocalKey secname engineIDLen engineID KulLen Kul</span>
<a name="l03631" id="l03631"></a>03631 <span class=
"comment"> *     or: userSetPrivLocalKey secname engineIDLen engineID KulLen Kul </span>
<a name="l03632" id="l03632"></a>03632 <span class="comment"> *</span>
<a name="l03633" id="l03633"></a>03633 <span class="comment"> * type is:     1=passphrase; 2=Ku; 3=Kul.</span>
<a name="l03634" id="l03634"></a>03634 <span class="comment"> *</span>
<a name="l03635" id="l03635"></a>03635 <span class="comment"> *</span>
<a name="l03636" id="l03636"></a>03636 <span class="comment"> * ASSUMES  Passwords are null-terminated printable strings.</span>
<a name="l03637" id="l03637"></a>03637 <span class="comment"> */</span>
<a name="l03638" id="l03638"></a>03638 <span class="keywordtype">void</span>
<a name="l03639" id="l03639"></a>03639 usm_set_password(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *token, <span class="keywordtype">char</span> *line)
<a name="l03640" id="l03640"></a>03640 {
<a name="l03641" id="l03641"></a>03641     <span class="keywordtype">char</span>           *cp;
<a name="l03642" id="l03642"></a>03642     <span class="keywordtype">char</span>            nameBuf[SNMP_MAXBUF];
<a name="l03643" id="l03643"></a>03643     u_char         *engineID;
<a name="l03644" id="l03644"></a>03644     <span class="keywordtype">size_t</span>          engineIDLen;
<a name="l03645" id="l03645"></a>03645     <span class="keyword">struct </span><a class="code" href=
"structusmUser.html">usmUser</a> *user;
<a name="l03646" id="l03646"></a>03646 
<a name="l03647" id="l03647"></a>03647     cp = copy_nword(line, nameBuf, <span class="keyword">sizeof</span>(nameBuf));
<a name="l03648" id="l03648"></a>03648     <span class="keywordflow">if</span> (cp == NULL) {
<a name="l03649" id="l03649"></a>03649         config_perror(<span class="stringliteral">"invalid name specifier"</span>);
<a name="l03650" id="l03650"></a>03650         <span class="keywordflow">return</span>;
<a name="l03651" id="l03651"></a>03651     }
<a name="l03652" id="l03652"></a>03652 
<a name="l03653" id="l03653"></a>03653     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"comparing: %s and %s\n"</span>, cp, WILDCARDSTRING));
<a name="l03654" id="l03654"></a>03654     <span class=
"keywordflow">if</span> (strncmp(cp, WILDCARDSTRING, strlen(WILDCARDSTRING)) == 0) {
<a name="l03655" id="l03655"></a>03655         <span class="comment">/*</span>
<a name="l03656" id="l03656"></a>03656 <span class="comment">         * match against all engineIDs we know about </span>
<a name="l03657" id="l03657"></a>03657 <span class="comment">         */</span>
<a name="l03658" id="l03658"></a>03658         cp = skip_token(cp);
<a name="l03659" id="l03659"></a>03659         <span class=
"keywordflow">for</span> (user = userList; user != NULL; user = user-&gt;next) {
<a name="l03660" id="l03660"></a>03660             <span class=
"keywordflow">if</span> (user-&gt;secName &amp;&amp; strcmp(user-&gt;secName, nameBuf) == 0) {
<a name="l03661" id="l03661"></a>03661                 usm_set_user_password(user, token, cp);
<a name="l03662" id="l03662"></a>03662             }
<a name="l03663" id="l03663"></a>03663         }
<a name="l03664" id="l03664"></a>03664     } <span class="keywordflow">else</span> {
<a name="l03665" id="l03665"></a>03665         cp = read_config_read_octet_string(cp, &amp;engineID, &amp;engineIDLen);
<a name="l03666" id="l03666"></a>03666         <span class="keywordflow">if</span> (cp == NULL) {
<a name="l03667" id="l03667"></a>03667             config_perror(<span class=
"stringliteral">"invalid engineID specifier"</span>);
<a name="l03668" id="l03668"></a>03668             <span class="keywordflow">return</span>;
<a name="l03669" id="l03669"></a>03669         }
<a name="l03670" id="l03670"></a>03670 
<a name="l03671" id="l03671"></a>03671         user = usm_get_user(engineID, engineIDLen, nameBuf);
<a name="l03672" id="l03672"></a>03672         <span class="keywordflow">if</span> (user == NULL) {
<a name="l03673" id="l03673"></a>03673             config_perror(<span class=
"stringliteral">"not a valid user/engineID pair"</span>);
<a name="l03674" id="l03674"></a>03674             <span class="keywordflow">return</span>;
<a name="l03675" id="l03675"></a>03675         }
<a name="l03676" id="l03676"></a>03676         usm_set_user_password(user, token, cp);
<a name="l03677" id="l03677"></a>03677     }
<a name="l03678" id="l03678"></a>03678 }
<a name="l03679" id="l03679"></a>03679 
<a name="l03680" id="l03680"></a>03680 <span class="comment">/*</span>
<a name="l03681" id="l03681"></a>03681 <span class=
"comment"> * uses the rest of LINE to configure USER's password of type TOKEN </span>
<a name="l03682" id="l03682"></a>03682 <span class="comment"> */</span>
<a name="l03683" id="l03683"></a>03683 <span class="keywordtype">void</span>
<a name="l03684" id="l03684"></a>03684 usm_set_user_password(<span class="keyword">struct</span> <a class="code" href=
"structusmUser.html">usmUser</a> *user, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *token, <span class="keywordtype">char</span> *line)
<a name="l03685" id="l03685"></a>03685 {
<a name="l03686" id="l03686"></a>03686     <span class="keywordtype">char</span>           *cp = line;
<a name="l03687" id="l03687"></a>03687     u_char         *engineID = user-&gt;engineID;
<a name="l03688" id="l03688"></a>03688     <span class="keywordtype">size_t</span>          engineIDLen = user-&gt;engineIDLen;
<a name="l03689" id="l03689"></a>03689 
<a name="l03690" id="l03690"></a>03690     u_char        **key;
<a name="l03691" id="l03691"></a>03691     <span class="keywordtype">size_t</span>         *keyLen;
<a name="l03692" id="l03692"></a>03692     u_char          userKey[SNMP_MAXBUF_SMALL];
<a name="l03693" id="l03693"></a>03693     <span class="keywordtype">size_t</span>          userKeyLen = SNMP_MAXBUF_SMALL;
<a name="l03694" id="l03694"></a>03694     u_char         *userKeyP = userKey;
<a name="l03695" id="l03695"></a>03695     <span class="keywordtype">int</span>             type, ret;
<a name="l03696" id="l03696"></a>03696 
<a name="l03697" id="l03697"></a>03697     <span class="comment">/*</span>
<a name="l03698" id="l03698"></a>03698 <span class="comment">     * Retrieve the "old" key and set the key type.</span>
<a name="l03699" id="l03699"></a>03699 <span class="comment">     */</span>
<a name="l03700" id="l03700"></a>03700     <span class="keywordflow">if</span> (!token) {
<a name="l03701" id="l03701"></a>03701         <span class="keywordflow">return</span>;
<a name="l03702" id="l03702"></a>03702     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strcmp(token, <span class="stringliteral">"userSetAuthPass"</span>) == 0) {
<a name="l03703" id="l03703"></a>03703         key = &amp;user-&gt;authKey;
<a name="l03704" id="l03704"></a>03704         keyLen = &amp;user-&gt;authKeyLen;
<a name="l03705" id="l03705"></a>03705         type = 0;
<a name="l03706" id="l03706"></a>03706     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strcmp(token, <span class="stringliteral">"userSetPrivPass"</span>) == 0) {
<a name="l03707" id="l03707"></a>03707         key = &amp;user-&gt;privKey;
<a name="l03708" id="l03708"></a>03708         keyLen = &amp;user-&gt;privKeyLen;
<a name="l03709" id="l03709"></a>03709         type = 0;
<a name="l03710" id="l03710"></a>03710     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strcmp(token, <span class="stringliteral">"userSetAuthKey"</span>) == 0) {
<a name="l03711" id="l03711"></a>03711         key = &amp;user-&gt;authKey;
<a name="l03712" id="l03712"></a>03712         keyLen = &amp;user-&gt;authKeyLen;
<a name="l03713" id="l03713"></a>03713         type = 1;
<a name="l03714" id="l03714"></a>03714     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strcmp(token, <span class="stringliteral">"userSetPrivKey"</span>) == 0) {
<a name="l03715" id="l03715"></a>03715         key = &amp;user-&gt;privKey;
<a name="l03716" id="l03716"></a>03716         keyLen = &amp;user-&gt;privKeyLen;
<a name="l03717" id="l03717"></a>03717         type = 1;
<a name="l03718" id="l03718"></a>03718     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strcmp(token, <span class="stringliteral">"userSetAuthLocalKey"</span>) == 0) {
<a name="l03719" id="l03719"></a>03719         key = &amp;user-&gt;authKey;
<a name="l03720" id="l03720"></a>03720         keyLen = &amp;user-&gt;authKeyLen;
<a name="l03721" id="l03721"></a>03721         type = 2;
<a name="l03722" id="l03722"></a>03722     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strcmp(token, <span class="stringliteral">"userSetPrivLocalKey"</span>) == 0) {
<a name="l03723" id="l03723"></a>03723         key = &amp;user-&gt;privKey;
<a name="l03724" id="l03724"></a>03724         keyLen = &amp;user-&gt;privKeyLen;
<a name="l03725" id="l03725"></a>03725         type = 2;
<a name="l03726" id="l03726"></a>03726     } <span class="keywordflow">else</span> {
<a name="l03727" id="l03727"></a>03727         <span class="comment">/*</span>
<a name="l03728" id="l03728"></a>03728 <span class="comment">         * no old key, or token was not recognized </span>
<a name="l03729" id="l03729"></a>03729 <span class="comment">         */</span>
<a name="l03730" id="l03730"></a>03730         <span class="keywordflow">return</span>;
<a name="l03731" id="l03731"></a>03731     }
<a name="l03732" id="l03732"></a>03732 
<a name="l03733" id="l03733"></a>03733     <span class="keywordflow">if</span> (*key) {
<a name="l03734" id="l03734"></a>03734         <span class="comment">/*</span>
<a name="l03735" id="l03735"></a>03735 <span class="comment">         * (destroy and) free the old key </span>
<a name="l03736" id="l03736"></a>03736 <span class="comment">         */</span>
<a name="l03737" id="l03737"></a>03737         memset(*key, 0, *keyLen);
<a name="l03738" id="l03738"></a>03738         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title=
"Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(*key);
<a name="l03739" id="l03739"></a>03739     }
<a name="l03740" id="l03740"></a>03740 
<a name="l03741" id="l03741"></a>03741     <span class="keywordflow">if</span> (type == 0) {
<a name="l03742" id="l03742"></a>03742         <span class="comment">/*</span>
<a name="l03743" id="l03743"></a>03743 <span class="comment">         * convert the password into a key </span>
<a name="l03744" id="l03744"></a>03744 <span class="comment">         */</span>
<a name="l03745" id="l03745"></a>03745         <span class="keywordflow">if</span> (cp == NULL) {
<a name="l03746" id="l03746"></a>03746             config_perror(<span class="stringliteral">"missing user password"</span>);
<a name="l03747" id="l03747"></a>03747             <span class="keywordflow">return</span>;
<a name="l03748" id="l03748"></a>03748         }
<a name="l03749" id="l03749"></a>03749         ret = generate_Ku(user-&gt;authProtocol, user-&gt;authProtocolLen,
<a name="l03750" id="l03750"></a>03750                           (u_char *) cp, strlen(cp), userKey, &amp;userKeyLen);
<a name="l03751" id="l03751"></a>03751 
<a name="l03752" id="l03752"></a>03752         <span class="keywordflow">if</span> (ret != SNMPERR_SUCCESS) {
<a name="l03753" id="l03753"></a>03753             config_perror(<span class=
"stringliteral">"setting key failed (in sc_genKu())"</span>);
<a name="l03754" id="l03754"></a>03754             <span class="keywordflow">return</span>;
<a name="l03755" id="l03755"></a>03755         }
<a name="l03756" id="l03756"></a>03756     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (type == 1) {
<a name="l03757" id="l03757"></a>03757         cp = read_config_read_octet_string(cp, &amp;userKeyP, &amp;userKeyLen);
<a name="l03758" id="l03758"></a>03758 
<a name="l03759" id="l03759"></a>03759         <span class="keywordflow">if</span> (cp == NULL) {
<a name="l03760" id="l03760"></a>03760             config_perror(<span class="stringliteral">"invalid user key"</span>);
<a name="l03761" id="l03761"></a>03761             <span class="keywordflow">return</span>;
<a name="l03762" id="l03762"></a>03762         }
<a name="l03763" id="l03763"></a>03763     }
<a name="l03764" id="l03764"></a>03764 
<a name="l03765" id="l03765"></a>03765     <span class="keywordflow">if</span> (type &lt; 2) {
<a name="l03766" id="l03766"></a>03766         *key = (u_char *) malloc(SNMP_MAXBUF_SMALL);
<a name="l03767" id="l03767"></a>03767         *keyLen = SNMP_MAXBUF_SMALL;
<a name="l03768" id="l03768"></a>03768         ret = generate_kul(user-&gt;authProtocol, user-&gt;authProtocolLen,
<a name="l03769" id="l03769"></a>03769                            engineID, engineIDLen,
<a name="l03770" id="l03770"></a>03770                            userKey, userKeyLen, *key, keyLen);
<a name="l03771" id="l03771"></a>03771         <span class="keywordflow">if</span> (ret != SNMPERR_SUCCESS) {
<a name="l03772" id="l03772"></a>03772             config_perror(<span class=
"stringliteral">"setting key failed (in generate_kul())"</span>);
<a name="l03773" id="l03773"></a>03773             <span class="keywordflow">return</span>;
<a name="l03774" id="l03774"></a>03774         }
<a name="l03775" id="l03775"></a>03775 
<a name="l03776" id="l03776"></a>03776         <span class="comment">/*</span>
<a name="l03777" id="l03777"></a>03777 <span class="comment">         * (destroy and) free the old key </span>
<a name="l03778" id="l03778"></a>03778 <span class="comment">         */</span>
<a name="l03779" id="l03779"></a>03779         memset(userKey, 0, <span class="keyword">sizeof</span>(userKey));
<a name="l03780" id="l03780"></a>03780 
<a name="l03781" id="l03781"></a>03781     } <span class="keywordflow">else</span> {
<a name="l03782" id="l03782"></a>03782         <span class="comment">/*</span>
<a name="l03783" id="l03783"></a>03783 <span class="comment">         * the key is given, copy it in </span>
<a name="l03784" id="l03784"></a>03784 <span class="comment">         */</span>
<a name="l03785" id="l03785"></a>03785         cp = read_config_read_octet_string(cp, key, keyLen);
<a name="l03786" id="l03786"></a>03786 
<a name="l03787" id="l03787"></a>03787         <span class="keywordflow">if</span> (cp == NULL) {
<a name="l03788" id="l03788"></a>03788             config_perror(<span class=
"stringliteral">"invalid localized user key"</span>);
<a name="l03789" id="l03789"></a>03789             <span class="keywordflow">return</span>;
<a name="l03790" id="l03790"></a>03790         }
<a name="l03791" id="l03791"></a>03791     }
<a name="l03792" id="l03792"></a>03792 }                               <span class="comment">/* end usm_set_password() */</span>
</pre>
    </div>
  </div>
  <hr size="1" />

  <address style="text-align: right;">
    <small>Generated on 28 Sep 2009 for net-snmp by  <a href="http://www.doxygen.org/index.html"><img class="footer" src=
    "doxygen.png" alt="doxygen" /></a> 1.6.1</small>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

