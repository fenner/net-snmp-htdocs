<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>net-snmp: snmpusm.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">net-snmp&#160;<span id="projectnumber">5.7</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">snmpusm.c</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
<a name="l00002"></a>00002 <span class="comment"> * the Net-SNMP&#39;s COPYING file for more details and other copyrights</span>
<a name="l00003"></a>00003 <span class="comment"> * that may apply:</span>
<a name="l00004"></a>00004 <span class="comment"> */</span>
<a name="l00005"></a>00005 <span class="comment">/*</span>
<a name="l00006"></a>00006 <span class="comment"> * Portions of this file are copyrighted by:</span>
<a name="l00007"></a>00007 <span class="comment"> * Copyright © 2003 Sun Microsystems, Inc. All rights reserved.</span>
<a name="l00008"></a>00008 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
<a name="l00009"></a>00009 <span class="comment"> * distributed with the Net-SNMP package.</span>
<a name="l00010"></a>00010 <span class="comment"> */</span>
<a name="l00011"></a>00011 <span class="comment">/*</span>
<a name="l00012"></a>00012 <span class="comment"> * snmpusm.c</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> * Routines to manipulate a information about a &quot;user&quot; as</span>
<a name="l00015"></a>00015 <span class="comment"> * defined by the SNMP-USER-BASED-SM-MIB MIB.</span>
<a name="l00016"></a>00016 <span class="comment"> *</span>
<a name="l00017"></a>00017 <span class="comment"> * All functions usm_set_usmStateReference_*() return 0 on success, -1</span>
<a name="l00018"></a>00018 <span class="comment"> * otherwise.</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> * !! Tab stops set to 4 in some parts of this file. !!</span>
<a name="l00021"></a>00021 <span class="comment"> *    (Designated on a per function.)</span>
<a name="l00022"></a>00022 <span class="comment"> */</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;net-snmp/net-snmp-features.h&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#ifdef HAVE_STDLIB_H</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#endif</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor"># include &lt;sys/time.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor"># include &lt;time.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#else</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor"># if HAVE_SYS_TIME_H</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor"># else</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#  include &lt;time.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor"># endif</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#if HAVE_STRING_H</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#else</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#include &lt;strings.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#endif</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_NETINET_IN_H</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#endif</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>
<a name="l00051"></a>00051 <span class="preprocessor">#if HAVE_UNISTD_H</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#endif</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#if HAVE_DMALLOC_H</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#endif</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>
<a name="l00058"></a>00058 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="preprocessor">#include &lt;net-snmp/library/asn1.h&gt;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &lt;<a class="code" href="tools_8h.html">net-snmp/library/tools.h</a>&gt;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &lt;net-snmp/library/keytools.h&gt;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &lt;net-snmp/library/snmpv3.h&gt;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &lt;net-snmp/library/lcd_time.h&gt;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &lt;net-snmp/library/scapi.h&gt;</span>
<a name="l00071"></a>00071 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
<a name="l00072"></a>00072 <span class="preprocessor">#include &lt;net-snmp/library/snmp_secmod.h&gt;</span>
<a name="l00073"></a>00073 <span class="preprocessor">#include &lt;net-snmp/library/snmpusm.h&gt;</span>
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 netsnmp_feature_child_of(usm_all, libnetsnmp)
<a name="l00076"></a>00076 netsnmp_feature_child_of(usm_support, usm_all)
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 netsnmp_feature_require(usm_support)
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 oid             usmNoAuthProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 1, 1 };
<a name="l00081"></a>00081 <span class="preprocessor">#ifndef NETSNMP_DISABLE_MD5</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span>oid             usmHMACMD5AuthProtocol[10] =
<a name="l00083"></a>00083     { 1, 3, 6, 1, 6, 3, 10, 1, 1, 2 };
<a name="l00084"></a>00084 <span class="preprocessor">#endif</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span>oid             usmHMACSHA1AuthProtocol[10] =
<a name="l00086"></a>00086     { 1, 3, 6, 1, 6, 3, 10, 1, 1, 3 };
<a name="l00087"></a>00087 oid             usmNoPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 1 };
<a name="l00088"></a>00088 <span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span>oid             usmDESPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 2 };
<a name="l00090"></a>00090 <span class="preprocessor">#endif</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span>oid             usmAESPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 4 };
<a name="l00092"></a>00092 <span class="comment">/* backwards compat */</span>
<a name="l00093"></a>00093 oid             *usmAES128PrivProtocol = usmAESPrivProtocol;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="keyword">static</span> u_int    dummy_etime, dummy_eboot;       <span class="comment">/* For ISENGINEKNOWN(). */</span>
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="comment">/*</span>
<a name="l00098"></a>00098 <span class="comment"> * Set up default snmpv3 parameter value storage.</span>
<a name="l00099"></a>00099 <span class="comment"> */</span>
<a name="l00100"></a>00100 <span class="preprocessor">#ifdef NETSNMP_SECMOD_USM</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> oid *defaultAuthType = NULL;
<a name="l00102"></a>00102 <span class="keyword">static</span> <span class="keywordtype">size_t</span>   defaultAuthTypeLen = 0;
<a name="l00103"></a>00103 <span class="keyword">static</span> <span class="keyword">const</span> oid *defaultPrivType = NULL;
<a name="l00104"></a>00104 <span class="keyword">static</span> <span class="keywordtype">size_t</span>   defaultPrivTypeLen = 0;
<a name="l00105"></a>00105 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_SECMOD_USM */</span>
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="comment">/*</span>
<a name="l00108"></a>00108 <span class="comment"> * Globals.</span>
<a name="l00109"></a>00109 <span class="comment"> */</span>
<a name="l00110"></a>00110 <span class="keyword">static</span> u_int    salt_integer;
<a name="l00111"></a>00111 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span><span class="keyword">static</span> u_int    salt_integer64_1, salt_integer64_2;
<a name="l00113"></a>00113 <span class="preprocessor">#endif</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span>        <span class="comment">/*</span>
<a name="l00115"></a>00115 <span class="comment">         * 1/2 of seed for the salt.   Cf. RFC2274, Sect 8.1.1.1.</span>
<a name="l00116"></a>00116 <span class="comment">         */</span>
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *noNameUser = NULL;
<a name="l00119"></a>00119 <span class="comment">/*</span>
<a name="l00120"></a>00120 <span class="comment"> * Local storage (LCD) of the default user list.</span>
<a name="l00121"></a>00121 <span class="comment"> */</span>
<a name="l00122"></a>00122 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *userList = NULL;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="comment">/*</span>
<a name="l00125"></a>00125 <span class="comment"> * Prototypes</span>
<a name="l00126"></a>00126 <span class="comment"> */</span>
<a name="l00127"></a>00127 <span class="keywordtype">int</span>
<a name="l00128"></a>00128                 usm_check_secLevel_vs_protocols(<span class="keywordtype">int</span> level,
<a name="l00129"></a>00129                                                 <span class="keyword">const</span> oid * authProtocol,
<a name="l00130"></a>00130                                                 u_int authProtocolLen,
<a name="l00131"></a>00131                                                 <span class="keyword">const</span> oid * privProtocol,
<a name="l00132"></a>00132                                                 u_int privProtocolLen);
<a name="l00133"></a>00133 <span class="keywordtype">int</span>
<a name="l00134"></a>00134                 usm_calc_offsets(<span class="keywordtype">size_t</span> globalDataLen,
<a name="l00135"></a>00135                                  <span class="keywordtype">int</span> secLevel, <span class="keywordtype">size_t</span> secEngineIDLen,
<a name="l00136"></a>00136                                  <span class="keywordtype">size_t</span> secNameLen, <span class="keywordtype">size_t</span> scopedPduLen,
<a name="l00137"></a>00137                                  u_long engineboots, <span class="keywordtype">long</span> engine_time,
<a name="l00138"></a>00138                                  <span class="keywordtype">size_t</span> * theTotalLength,
<a name="l00139"></a>00139                                  <span class="keywordtype">size_t</span> * authParamsOffset,
<a name="l00140"></a>00140                                  <span class="keywordtype">size_t</span> * privParamsOffset,
<a name="l00141"></a>00141                                  <span class="keywordtype">size_t</span> * dataOffset, <span class="keywordtype">size_t</span> * datalen,
<a name="l00142"></a>00142                                  <span class="keywordtype">size_t</span> * msgAuthParmLen,
<a name="l00143"></a>00143                                  <span class="keywordtype">size_t</span> * msgPrivParmLen, <span class="keywordtype">size_t</span> * otstlen,
<a name="l00144"></a>00144                                  <span class="keywordtype">size_t</span> * seq_len, <span class="keywordtype">size_t</span> * msgSecParmLen);
<a name="l00145"></a>00145 <span class="comment">/*</span>
<a name="l00146"></a>00146 <span class="comment"> * Set a given field of the secStateRef.</span>
<a name="l00147"></a>00147 <span class="comment"> *</span>
<a name="l00148"></a>00148 <span class="comment"> * Allocate &lt;len&gt; bytes for type &lt;type&gt; pointed to by ref-&gt;&lt;field&gt;.</span>
<a name="l00149"></a>00149 <span class="comment"> * Then copy in &lt;item&gt; and record its length in ref-&gt;&lt;field_len&gt;.</span>
<a name="l00150"></a>00150 <span class="comment"> *</span>
<a name="l00151"></a>00151 <span class="comment"> * Return 0 on success, -1 otherwise.</span>
<a name="l00152"></a>00152 <span class="comment"> */</span>
<a name="l00153"></a>00153 <span class="preprocessor">#define MAKE_ENTRY( type, item, len, field, field_len )                 \</span>
<a name="l00154"></a>00154 <span class="preprocessor">{                                                                       \</span>
<a name="l00155"></a>00155 <span class="preprocessor">        if (ref == NULL)                                                \</span>
<a name="l00156"></a>00156 <span class="preprocessor">                return -1;                                              \</span>
<a name="l00157"></a>00157 <span class="preprocessor">        if (ref-&gt;field != NULL) {                                       \</span>
<a name="l00158"></a>00158 <span class="preprocessor">                SNMP_ZERO(ref-&gt;field, ref-&gt;field_len);                  \</span>
<a name="l00159"></a>00159 <span class="preprocessor">                SNMP_FREE(ref-&gt;field);                                  \</span>
<a name="l00160"></a>00160 <span class="preprocessor">        }                                                               \</span>
<a name="l00161"></a>00161 <span class="preprocessor">        ref-&gt;field_len = 0;                                             \</span>
<a name="l00162"></a>00162 <span class="preprocessor">        if (len == 0 || item == NULL) {                                 \</span>
<a name="l00163"></a>00163 <span class="preprocessor">                return 0;                                               \</span>
<a name="l00164"></a>00164 <span class="preprocessor">        }                                                               \</span>
<a name="l00165"></a>00165 <span class="preprocessor">        if ((ref-&gt;field = (type*) malloc (len * sizeof(type))) == NULL) \</span>
<a name="l00166"></a>00166 <span class="preprocessor">        {                                                               \</span>
<a name="l00167"></a>00167 <span class="preprocessor">                return -1;                                              \</span>
<a name="l00168"></a>00168 <span class="preprocessor">        }                                                               \</span>
<a name="l00169"></a>00169 <span class="preprocessor">                                                                        \</span>
<a name="l00170"></a>00170 <span class="preprocessor">        memcpy (ref-&gt;field, item, len * sizeof(type));                  \</span>
<a name="l00171"></a>00171 <span class="preprocessor">        ref-&gt;field_len = len;                                           \</span>
<a name="l00172"></a>00172 <span class="preprocessor">                                                                        \</span>
<a name="l00173"></a>00173 <span class="preprocessor">        return 0;                                                       \</span>
<a name="l00174"></a>00174 <span class="preprocessor">}</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span>
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="keywordtype">int</span>
<a name="l00178"></a>00178 free_enginetime_on_shutdown(<span class="keywordtype">int</span> majorid, <span class="keywordtype">int</span> minorid, <span class="keywordtype">void</span> *serverarg,
<a name="l00179"></a>00179                             <span class="keywordtype">void</span> *clientarg)
<a name="l00180"></a>00180 {
<a name="l00181"></a>00181     u_char engineID[SNMP_MAX_ENG_SIZE];
<a name="l00182"></a>00182     <span class="keywordtype">size_t</span> engineID_len = <span class="keyword">sizeof</span>(engineID);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184     DEBUGMSGTL((<span class="stringliteral">&quot;snmpv3&quot;</span>, <span class="stringliteral">&quot;free enginetime callback called\n&quot;</span>));
<a name="l00185"></a>00185 
<a name="l00186"></a>00186     engineID_len = snmpv3_get_engineID(engineID, engineID_len);
<a name="l00187"></a>00187     <span class="keywordflow">if</span> (engineID_len &gt; 0)
<a name="l00188"></a>00188         free_enginetime(engineID, engineID_len);
<a name="l00189"></a>00189     <span class="keywordflow">return</span> 0;
<a name="l00190"></a>00190 }
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <span class="keyword">struct </span><a class="code" href="structusmStateReference.html">usmStateReference</a> *
<a name="l00193"></a>00193 usm_malloc_usmStateReference(<span class="keywordtype">void</span>)
<a name="l00194"></a>00194 {
<a name="l00195"></a>00195     <span class="keyword">struct </span><a class="code" href="structusmStateReference.html">usmStateReference</a> *retval = (<span class="keyword">struct </span><a class="code" href="structusmStateReference.html">usmStateReference</a> *)
<a name="l00196"></a>00196         calloc(1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusmStateReference.html">usmStateReference</a>));
<a name="l00197"></a>00197 
<a name="l00198"></a>00198     <span class="keywordflow">return</span> retval;
<a name="l00199"></a>00199 }                               <span class="comment">/* end usm_malloc_usmStateReference() */</span>
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="keywordtype">void</span>
<a name="l00203"></a>00203 usm_free_usmStateReference(<span class="keywordtype">void</span> *old)
<a name="l00204"></a>00204 {
<a name="l00205"></a>00205     <span class="keyword">struct </span><a class="code" href="structusmStateReference.html">usmStateReference</a> *old_ref = (<span class="keyword">struct </span><a class="code" href="structusmStateReference.html">usmStateReference</a> *) old;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207     <span class="keywordflow">if</span> (old_ref) {
<a name="l00208"></a>00208 
<a name="l00209"></a>00209         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref-&gt;usr_name);
<a name="l00210"></a>00210         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref-&gt;usr_engine_id);
<a name="l00211"></a>00211         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref-&gt;usr_auth_protocol);
<a name="l00212"></a>00212         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref-&gt;usr_priv_protocol);
<a name="l00213"></a>00213 
<a name="l00214"></a>00214         <span class="keywordflow">if</span> (old_ref-&gt;usr_auth_key) {
<a name="l00215"></a>00215             <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title="Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(old_ref-&gt;usr_auth_key, old_ref-&gt;usr_auth_key_length);
<a name="l00216"></a>00216             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref-&gt;usr_auth_key);
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218         <span class="keywordflow">if</span> (old_ref-&gt;usr_priv_key) {
<a name="l00219"></a>00219             <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title="Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(old_ref-&gt;usr_priv_key, old_ref-&gt;usr_priv_key_length);
<a name="l00220"></a>00220             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref-&gt;usr_priv_key);
<a name="l00221"></a>00221         }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223         <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title="Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(old_ref, <span class="keyword">sizeof</span>(*old_ref));
<a name="l00224"></a>00224         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(old_ref);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226     }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 }                               <span class="comment">/* end usm_free_usmStateReference() */</span>
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *
<a name="l00231"></a>00231 usm_get_userList(<span class="keywordtype">void</span>)
<a name="l00232"></a>00232 {
<a name="l00233"></a>00233     <span class="keywordflow">return</span> userList;
<a name="l00234"></a>00234 }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="keywordtype">int</span>
<a name="l00237"></a>00237 usm_set_usmStateReference_name(<span class="keyword">struct</span> <a class="code" href="structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00238"></a>00238                                <span class="keywordtype">char</span> *name, <span class="keywordtype">size_t</span> name_len)
<a name="l00239"></a>00239 {
<a name="l00240"></a>00240     MAKE_ENTRY(<span class="keywordtype">char</span>, name, name_len, usr_name, usr_name_length);
<a name="l00241"></a>00241 }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="keywordtype">int</span>
<a name="l00244"></a>00244 usm_set_usmStateReference_engine_id(<span class="keyword">struct</span> <a class="code" href="structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00245"></a>00245                                     u_char * engine_id,
<a name="l00246"></a>00246                                     <span class="keywordtype">size_t</span> engine_id_len)
<a name="l00247"></a>00247 {
<a name="l00248"></a>00248     MAKE_ENTRY(u_char, engine_id, engine_id_len,
<a name="l00249"></a>00249                usr_engine_id, usr_engine_id_length);
<a name="l00250"></a>00250 }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 <span class="keywordtype">int</span>
<a name="l00253"></a>00253 usm_set_usmStateReference_auth_protocol(<span class="keyword">struct</span> <a class="code" href="structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00254"></a>00254                                         oid * auth_protocol,
<a name="l00255"></a>00255                                         <span class="keywordtype">size_t</span> auth_protocol_len)
<a name="l00256"></a>00256 {
<a name="l00257"></a>00257     MAKE_ENTRY(oid, auth_protocol, auth_protocol_len,
<a name="l00258"></a>00258                usr_auth_protocol, usr_auth_protocol_length);
<a name="l00259"></a>00259 }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 <span class="keywordtype">int</span>
<a name="l00262"></a>00262 usm_set_usmStateReference_auth_key(<span class="keyword">struct</span> <a class="code" href="structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00263"></a>00263                                    u_char * auth_key, <span class="keywordtype">size_t</span> auth_key_len)
<a name="l00264"></a>00264 {
<a name="l00265"></a>00265     MAKE_ENTRY(u_char, auth_key, auth_key_len,
<a name="l00266"></a>00266                usr_auth_key, usr_auth_key_length);
<a name="l00267"></a>00267 }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 <span class="keywordtype">int</span>
<a name="l00270"></a>00270 usm_set_usmStateReference_priv_protocol(<span class="keyword">struct</span> <a class="code" href="structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00271"></a>00271                                         oid * priv_protocol,
<a name="l00272"></a>00272                                         <span class="keywordtype">size_t</span> priv_protocol_len)
<a name="l00273"></a>00273 {
<a name="l00274"></a>00274     MAKE_ENTRY(oid, priv_protocol, priv_protocol_len,
<a name="l00275"></a>00275                usr_priv_protocol, usr_priv_protocol_length);
<a name="l00276"></a>00276 }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="keywordtype">int</span>
<a name="l00279"></a>00279 usm_set_usmStateReference_priv_key(<span class="keyword">struct</span> <a class="code" href="structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00280"></a>00280                                    u_char * priv_key, <span class="keywordtype">size_t</span> priv_key_len)
<a name="l00281"></a>00281 {
<a name="l00282"></a>00282     MAKE_ENTRY(u_char, priv_key, priv_key_len,
<a name="l00283"></a>00283                usr_priv_key, usr_priv_key_length);
<a name="l00284"></a>00284 }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 <span class="keywordtype">int</span>
<a name="l00287"></a>00287 usm_set_usmStateReference_sec_level(<span class="keyword">struct</span> <a class="code" href="structusmStateReference.html">usmStateReference</a> *ref,
<a name="l00288"></a>00288                                     <span class="keywordtype">int</span> sec_level)
<a name="l00289"></a>00289 {
<a name="l00290"></a>00290     <span class="keywordflow">if</span> (ref == NULL)
<a name="l00291"></a>00291         <span class="keywordflow">return</span> -1;
<a name="l00292"></a>00292     ref-&gt;usr_sec_level = sec_level;
<a name="l00293"></a>00293     <span class="keywordflow">return</span> 0;
<a name="l00294"></a>00294 }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l00299"></a>00299 <span class="preprocessor"></span><span class="comment">/*******************************************************************-o-******</span>
<a name="l00300"></a>00300 <span class="comment"> * emergency_print</span>
<a name="l00301"></a>00301 <span class="comment"> *</span>
<a name="l00302"></a>00302 <span class="comment"> * Parameters:</span>
<a name="l00303"></a>00303 <span class="comment"> *      *field</span>
<a name="l00304"></a>00304 <span class="comment"> *       length</span>
<a name="l00305"></a>00305 <span class="comment"> *      </span>
<a name="l00306"></a>00306 <span class="comment"> *      This is a print routine that is solely included so that it can be</span>
<a name="l00307"></a>00307 <span class="comment"> *      used in gdb.  Don&#39;t use it as a function, it will be pulled before</span>
<a name="l00308"></a>00308 <span class="comment"> *      a real release of the code.</span>
<a name="l00309"></a>00309 <span class="comment"> *</span>
<a name="l00310"></a>00310 <span class="comment"> *      tab stop 4</span>
<a name="l00311"></a>00311 <span class="comment"> *</span>
<a name="l00312"></a>00312 <span class="comment"> *      XXX fflush() only works on FreeBSD; core dumps on Sun OS&#39;s</span>
<a name="l00313"></a>00313 <span class="comment"> */</span>
<a name="l00314"></a>00314 <span class="keywordtype">void</span>
<a name="l00315"></a>00315 emergency_print(u_char * field, u_int length)
<a name="l00316"></a>00316 {
<a name="l00317"></a>00317     <span class="keywordtype">int</span>             iindex;
<a name="l00318"></a>00318     <span class="keywordtype">int</span>             start = 0;
<a name="l00319"></a>00319     <span class="keywordtype">int</span>             stop = 25;
<a name="l00320"></a>00320 
<a name="l00321"></a>00321     <span class="keywordflow">while</span> (start &lt; stop) {
<a name="l00322"></a>00322         <span class="keywordflow">for</span> (iindex = start; iindex &lt; stop; iindex++)
<a name="l00323"></a>00323             printf(<span class="stringliteral">&quot;%02X &quot;</span>, field[iindex]);
<a name="l00324"></a>00324 
<a name="l00325"></a>00325         printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00326"></a>00326         start = stop;
<a name="l00327"></a>00327         stop = stop + 25 &lt; length ? stop + 25 : length;
<a name="l00328"></a>00328     }
<a name="l00329"></a>00329     fflush(0);
<a name="l00330"></a>00330 
<a name="l00331"></a>00331 }                               <span class="comment">/* end emergency_print() */</span>
<a name="l00332"></a>00332 <span class="preprocessor">#endif                          </span><span class="comment">/* NETSNMP_ENABLE_TESTING_CODE */</span>
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="comment">/*******************************************************************-o-******</span>
<a name="l00336"></a>00336 <span class="comment"> * asn_predict_int_length</span>
<a name="l00337"></a>00337 <span class="comment"> *</span>
<a name="l00338"></a>00338 <span class="comment"> * Parameters:</span>
<a name="l00339"></a>00339 <span class="comment"> *      type    (UNUSED)</span>
<a name="l00340"></a>00340 <span class="comment"> *      number</span>
<a name="l00341"></a>00341 <span class="comment"> *      len</span>
<a name="l00342"></a>00342 <span class="comment"> *      </span>
<a name="l00343"></a>00343 <span class="comment"> * Returns:</span>
<a name="l00344"></a>00344 <span class="comment"> *      Number of bytes necessary to store the ASN.1 encoded value of &#39;number&#39;.</span>
<a name="l00345"></a>00345 <span class="comment"> *</span>
<a name="l00346"></a>00346 <span class="comment"> *</span>
<a name="l00347"></a>00347 <span class="comment"> *      This gives the number of bytes that the ASN.1 encoder (in asn1.c) will</span>
<a name="l00348"></a>00348 <span class="comment"> *      use to encode a particular integer value.</span>
<a name="l00349"></a>00349 <span class="comment"> *</span>
<a name="l00350"></a>00350 <span class="comment"> *      Returns the length of the integer -- NOT THE HEADER!</span>
<a name="l00351"></a>00351 <span class="comment"> *</span>
<a name="l00352"></a>00352 <span class="comment"> *      Do this the same way as asn_build_int()...</span>
<a name="l00353"></a>00353 <span class="comment"> */</span>
<a name="l00354"></a>00354 <span class="keywordtype">int</span>
<a name="l00355"></a>00355 asn_predict_int_length(<span class="keywordtype">int</span> type, <span class="keywordtype">long</span> number, <span class="keywordtype">size_t</span> len)
<a name="l00356"></a>00356 {
<a name="l00357"></a>00357     <span class="keyword">register</span> u_long mask;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 
<a name="l00360"></a>00360     <span class="keywordflow">if</span> (len != <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>))
<a name="l00361"></a>00361         <span class="keywordflow">return</span> -1;
<a name="l00362"></a>00362 
<a name="l00363"></a>00363     mask = ((u_long) 0x1FF) &lt;&lt; ((8 * (<span class="keyword">sizeof</span>(long) - 1)) - 1);
<a name="l00364"></a>00364     <span class="comment">/*</span>
<a name="l00365"></a>00365 <span class="comment">     * mask is 0xFF800000 on a big-endian machine </span>
<a name="l00366"></a>00366 <span class="comment">     */</span>
<a name="l00367"></a>00367 
<a name="l00368"></a>00368     <span class="keywordflow">while</span> ((((number &amp; mask) == 0) || ((number &amp; mask) == mask))
<a name="l00369"></a>00369            &amp;&amp; len &gt; 1) {
<a name="l00370"></a>00370         len--;
<a name="l00371"></a>00371         number &lt;&lt;= 8;
<a name="l00372"></a>00372     }
<a name="l00373"></a>00373 
<a name="l00374"></a>00374     <span class="keywordflow">return</span> len;
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 }                               <span class="comment">/* end asn_predict_length() */</span>
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 <span class="comment">/*******************************************************************-o-******</span>
<a name="l00382"></a>00382 <span class="comment"> * asn_predict_length</span>
<a name="l00383"></a>00383 <span class="comment"> *</span>
<a name="l00384"></a>00384 <span class="comment"> * Parameters:</span>
<a name="l00385"></a>00385 <span class="comment"> *       type</span>
<a name="l00386"></a>00386 <span class="comment"> *      *ptr</span>
<a name="l00387"></a>00387 <span class="comment"> *       u_char_len</span>
<a name="l00388"></a>00388 <span class="comment"> *      </span>
<a name="l00389"></a>00389 <span class="comment"> * Returns:</span>
<a name="l00390"></a>00390 <span class="comment"> *      Length in bytes:        1 + &lt;n&gt; + &lt;u_char_len&gt;, where</span>
<a name="l00391"></a>00391 <span class="comment"> *</span>
<a name="l00392"></a>00392 <span class="comment"> *              1               For the ASN.1 type.</span>
<a name="l00393"></a>00393 <span class="comment"> *              &lt;n&gt;             # of bytes to store length of data.</span>
<a name="l00394"></a>00394 <span class="comment"> *              &lt;u_char_len&gt;    Length of data associated with ASN.1 type.</span>
<a name="l00395"></a>00395 <span class="comment"> *</span>
<a name="l00396"></a>00396 <span class="comment"> *      This gives the number of bytes that the ASN.1 encoder (in asn1.c) will</span>
<a name="l00397"></a>00397 <span class="comment"> *      use to encode a particular integer value.  This is as broken as the</span>
<a name="l00398"></a>00398 <span class="comment"> *      currently used encoder.</span>
<a name="l00399"></a>00399 <span class="comment"> *</span>
<a name="l00400"></a>00400 <span class="comment"> * XXX  How is &lt;n&gt; chosen, exactly??</span>
<a name="l00401"></a>00401 <span class="comment"> */</span>
<a name="l00402"></a>00402 <span class="keywordtype">int</span>
<a name="l00403"></a>00403 asn_predict_length(<span class="keywordtype">int</span> type, u_char * ptr, <span class="keywordtype">size_t</span> u_char_len)
<a name="l00404"></a>00404 {
<a name="l00405"></a>00405 
<a name="l00406"></a>00406     <span class="keywordflow">if</span> (type &amp; ASN_SEQUENCE)
<a name="l00407"></a>00407         <span class="keywordflow">return</span> 1 + 3 + u_char_len;
<a name="l00408"></a>00408 
<a name="l00409"></a>00409     <span class="keywordflow">if</span> (type &amp; ASN_INTEGER) {
<a name="l00410"></a>00410         u_long          value;
<a name="l00411"></a>00411         memcpy(&amp;value, ptr, u_char_len);
<a name="l00412"></a>00412         u_char_len = asn_predict_int_length(type, value, u_char_len);
<a name="l00413"></a>00413     }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415     <span class="keywordflow">if</span> (u_char_len &lt; 0x80)
<a name="l00416"></a>00416         <span class="keywordflow">return</span> 1 + 1 + u_char_len;
<a name="l00417"></a>00417     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (u_char_len &lt; 0xFF)
<a name="l00418"></a>00418         <span class="keywordflow">return</span> 1 + 2 + u_char_len;
<a name="l00419"></a>00419     <span class="keywordflow">else</span>
<a name="l00420"></a>00420         <span class="keywordflow">return</span> 1 + 3 + u_char_len;
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 }                               <span class="comment">/* end asn_predict_length() */</span>
<a name="l00423"></a>00423 
<a name="l00424"></a>00424 
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="comment">/*******************************************************************-o-******</span>
<a name="l00428"></a>00428 <span class="comment"> * usm_calc_offsets</span>
<a name="l00429"></a>00429 <span class="comment"> *</span>
<a name="l00430"></a>00430 <span class="comment"> * Parameters:</span>
<a name="l00431"></a>00431 <span class="comment"> *      (See list below...)</span>
<a name="l00432"></a>00432 <span class="comment"> *      </span>
<a name="l00433"></a>00433 <span class="comment"> * Returns:</span>
<a name="l00434"></a>00434 <span class="comment"> *      0       On success,</span>
<a name="l00435"></a>00435 <span class="comment"> *      -1      Otherwise.</span>
<a name="l00436"></a>00436 <span class="comment"> *</span>
<a name="l00437"></a>00437 <span class="comment"> *</span>
<a name="l00438"></a>00438 <span class="comment"> *      This routine calculates the offsets into an outgoing message buffer</span>
<a name="l00439"></a>00439 <span class="comment"> *      for the necessary values.  The outgoing buffer will generically</span>
<a name="l00440"></a>00440 <span class="comment"> *      look like this:</span>
<a name="l00441"></a>00441 <span class="comment"> *</span>
<a name="l00442"></a>00442 <span class="comment"> *      SNMPv3 Message</span>
<a name="l00443"></a>00443 <span class="comment"> *      SEQ len[11]</span>
<a name="l00444"></a>00444 <span class="comment"> *              INT len version</span>
<a name="l00445"></a>00445 <span class="comment"> *      Header</span>
<a name="l00446"></a>00446 <span class="comment"> *              SEQ len</span>
<a name="l00447"></a>00447 <span class="comment"> *                      INT len MsgID</span>
<a name="l00448"></a>00448 <span class="comment"> *                      INT len msgMaxSize</span>
<a name="l00449"></a>00449 <span class="comment"> *                      OST len msgFlags (OST = OCTET STRING)</span>
<a name="l00450"></a>00450 <span class="comment"> *                      INT len msgSecurityModel</span>
<a name="l00451"></a>00451 <span class="comment"> *      MsgSecurityParameters</span>
<a name="l00452"></a>00452 <span class="comment"> *              [1] OST len[2]</span>
<a name="l00453"></a>00453 <span class="comment"> *                      SEQ len[3]</span>
<a name="l00454"></a>00454 <span class="comment"> *                              OST len msgAuthoritativeEngineID</span>
<a name="l00455"></a>00455 <span class="comment"> *                              INT len msgAuthoritativeEngineBoots</span>
<a name="l00456"></a>00456 <span class="comment"> *                              INT len msgAuthoritativeEngineTime</span>
<a name="l00457"></a>00457 <span class="comment"> *                              OST len msgUserName</span>
<a name="l00458"></a>00458 <span class="comment"> *                              OST len[4] [5] msgAuthenticationParameters</span>
<a name="l00459"></a>00459 <span class="comment"> *                              OST len[6] [7] msgPrivacyParameters</span>
<a name="l00460"></a>00460 <span class="comment"> *      MsgData</span>
<a name="l00461"></a>00461 <span class="comment"> *              [8] OST len[9] [10] encryptedPDU</span>
<a name="l00462"></a>00462 <span class="comment"> *              or</span>
<a name="l00463"></a>00463 <span class="comment"> *              [8,10] SEQUENCE len[9] scopedPDU</span>
<a name="l00464"></a>00464 <span class="comment"> *      [12]</span>
<a name="l00465"></a>00465 <span class="comment"> *</span>
<a name="l00466"></a>00466 <span class="comment"> *      The bracketed points will be needed to be identified ([x] is an index</span>
<a name="l00467"></a>00467 <span class="comment"> *      value, len[x] means a length value).  Here is a semantic guide to them:</span>
<a name="l00468"></a>00468 <span class="comment"> *</span>
<a name="l00469"></a>00469 <span class="comment"> *      [1] = globalDataLen (input)</span>
<a name="l00470"></a>00470 <span class="comment"> *      [2] = otstlen</span>
<a name="l00471"></a>00471 <span class="comment"> *      [3] = seq_len</span>
<a name="l00472"></a>00472 <span class="comment"> *      [4] = msgAuthParmLen (may be 0 or 12)</span>
<a name="l00473"></a>00473 <span class="comment"> *      [5] = authParamsOffset</span>
<a name="l00474"></a>00474 <span class="comment"> *      [6] = msgPrivParmLen (may be 0 or 8)</span>
<a name="l00475"></a>00475 <span class="comment"> *      [7] = privParamsOffset</span>
<a name="l00476"></a>00476 <span class="comment"> *      [8] = globalDataLen + msgSecParmLen</span>
<a name="l00477"></a>00477 <span class="comment"> *      [9] = datalen</span>
<a name="l00478"></a>00478 <span class="comment"> *      [10] = dataOffset</span>
<a name="l00479"></a>00479 <span class="comment"> *      [11] = theTotalLength - the length of the header itself</span>
<a name="l00480"></a>00480 <span class="comment"> *      [12] = theTotalLength</span>
<a name="l00481"></a>00481 <span class="comment"> */</span>
<a name="l00482"></a>00482 <span class="keywordtype">int</span>
<a name="l00483"></a>00483 usm_calc_offsets(<span class="keywordtype">size_t</span> globalDataLen,  <span class="comment">/* SNMPv3Message + HeaderData */</span>
<a name="l00484"></a>00484                  <span class="keywordtype">int</span> secLevel, <span class="keywordtype">size_t</span> secEngineIDLen, <span class="keywordtype">size_t</span> secNameLen, <span class="keywordtype">size_t</span> scopedPduLen,   <span class="comment">/* An BER encoded sequence. */</span>
<a name="l00485"></a>00485                  u_long engineboots,    <span class="comment">/* XXX (asn1.c works in long, not int.) */</span>
<a name="l00486"></a>00486                  <span class="keywordtype">long</span> engine_time,      <span class="comment">/* XXX (asn1.c works in long, not int.) */</span>
<a name="l00487"></a>00487                  <span class="keywordtype">size_t</span> * theTotalLength,       <span class="comment">/* globalDataLen + msgSecurityP. + msgData */</span>
<a name="l00488"></a>00488                  <span class="keywordtype">size_t</span> * authParamsOffset,     <span class="comment">/* Distance to auth bytes.                 */</span>
<a name="l00489"></a>00489                  <span class="keywordtype">size_t</span> * privParamsOffset,     <span class="comment">/* Distance to priv bytes.                 */</span>
<a name="l00490"></a>00490                  <span class="keywordtype">size_t</span> * dataOffset,   <span class="comment">/* Distance to scopedPdu SEQ  -or-  the</span>
<a name="l00491"></a>00491 <span class="comment">                                         *   crypted (data) portion of msgData.    */</span>
<a name="l00492"></a>00492                  <span class="keywordtype">size_t</span> * datalen,      <span class="comment">/* Size of msgData OCTET STRING encoding.  */</span>
<a name="l00493"></a>00493                  <span class="keywordtype">size_t</span> * msgAuthParmLen,       <span class="comment">/* Size of msgAuthenticationParameters.    */</span>
<a name="l00494"></a>00494                  <span class="keywordtype">size_t</span> * msgPrivParmLen,       <span class="comment">/* Size of msgPrivacyParameters.           */</span>
<a name="l00495"></a>00495                  <span class="keywordtype">size_t</span> * otstlen,      <span class="comment">/* Size of msgSecurityP. O.S. encoding.    */</span>
<a name="l00496"></a>00496                  <span class="keywordtype">size_t</span> * seq_len,      <span class="comment">/* Size of msgSecurityP. SEQ data.         */</span>
<a name="l00497"></a>00497                  <span class="keywordtype">size_t</span> * msgSecParmLen)
<a name="l00498"></a>00498 {                               <span class="comment">/* Size of msgSecurityP. SEQ.              */</span>
<a name="l00499"></a>00499     <span class="keywordtype">int</span>             engIDlen,   <span class="comment">/* Sizes of OCTET STRING and SEQ encodings */</span>
<a name="l00500"></a>00500                     engBtlen,   <span class="comment">/*   for fields within                     */</span>
<a name="l00501"></a>00501                     engTmlen,   <span class="comment">/*   msgSecurityParameters portion of      */</span>
<a name="l00502"></a>00502                     namelen,    <span class="comment">/*   SNMPv3Message.                        */</span>
<a name="l00503"></a>00503                     authlen, privlen, ret;
<a name="l00504"></a>00504 
<a name="l00505"></a>00505     <span class="comment">/*</span>
<a name="l00506"></a>00506 <span class="comment">     * If doing authentication, msgAuthParmLen = 12 else msgAuthParmLen = 0.</span>
<a name="l00507"></a>00507 <span class="comment">     * If doing encryption,     msgPrivParmLen = 8  else msgPrivParmLen = 0.</span>
<a name="l00508"></a>00508 <span class="comment">     */</span>
<a name="l00509"></a>00509     *msgAuthParmLen = (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
<a name="l00510"></a>00510                        || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) ? 12 : 0;
<a name="l00511"></a>00511 
<a name="l00512"></a>00512     *msgPrivParmLen = (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) ? 8 : 0;
<a name="l00513"></a>00513 
<a name="l00514"></a>00514 
<a name="l00515"></a>00515     <span class="comment">/*</span>
<a name="l00516"></a>00516 <span class="comment">     * Calculate lengths.</span>
<a name="l00517"></a>00517 <span class="comment">     */</span>
<a name="l00518"></a>00518     <span class="keywordflow">if</span> ((engIDlen = asn_predict_length(ASN_OCTET_STR,
<a name="l00519"></a>00519                                        NULL, secEngineIDLen)) == -1) {
<a name="l00520"></a>00520         <span class="keywordflow">return</span> -1;
<a name="l00521"></a>00521     }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523     <span class="keywordflow">if</span> ((engBtlen = asn_predict_length(ASN_INTEGER,
<a name="l00524"></a>00524                                        (u_char *) &amp; engineboots,
<a name="l00525"></a>00525                                        <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>))) == -1) {
<a name="l00526"></a>00526         <span class="keywordflow">return</span> -1;
<a name="l00527"></a>00527     }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529     <span class="keywordflow">if</span> ((engTmlen = asn_predict_length(ASN_INTEGER,
<a name="l00530"></a>00530                                        (u_char *) &amp; engine_time,
<a name="l00531"></a>00531                                        <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>))) == -1) {
<a name="l00532"></a>00532         <span class="keywordflow">return</span> -1;
<a name="l00533"></a>00533     }
<a name="l00534"></a>00534 
<a name="l00535"></a>00535     <span class="keywordflow">if</span> ((namelen = asn_predict_length(ASN_OCTET_STR,
<a name="l00536"></a>00536                                       NULL, secNameLen)) == -1) {
<a name="l00537"></a>00537         <span class="keywordflow">return</span> -1;
<a name="l00538"></a>00538     }
<a name="l00539"></a>00539 
<a name="l00540"></a>00540     <span class="keywordflow">if</span> ((authlen = asn_predict_length(ASN_OCTET_STR,
<a name="l00541"></a>00541                                       NULL, *msgAuthParmLen)) == -1) {
<a name="l00542"></a>00542         <span class="keywordflow">return</span> -1;
<a name="l00543"></a>00543     }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545     <span class="keywordflow">if</span> ((privlen = asn_predict_length(ASN_OCTET_STR,
<a name="l00546"></a>00546                                       NULL, *msgPrivParmLen)) == -1) {
<a name="l00547"></a>00547         <span class="keywordflow">return</span> -1;
<a name="l00548"></a>00548     }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550     *seq_len =
<a name="l00551"></a>00551         engIDlen + engBtlen + engTmlen + namelen + authlen + privlen;
<a name="l00552"></a>00552 
<a name="l00553"></a>00553     <span class="keywordflow">if</span> ((ret = asn_predict_length(ASN_SEQUENCE,
<a name="l00554"></a>00554                                       NULL, *seq_len)) == -1) {
<a name="l00555"></a>00555         <span class="keywordflow">return</span> -1;
<a name="l00556"></a>00556     }
<a name="l00557"></a>00557     *otstlen = (size_t)ret;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559     <span class="keywordflow">if</span> ((ret = asn_predict_length(ASN_OCTET_STR,
<a name="l00560"></a>00560                                       NULL, *otstlen)) == -1) {
<a name="l00561"></a>00561         <span class="keywordflow">return</span> -1;
<a name="l00562"></a>00562     }
<a name="l00563"></a>00563     *msgSecParmLen = (size_t)ret;
<a name="l00564"></a>00564 
<a name="l00565"></a>00565     *authParamsOffset = globalDataLen + +(*msgSecParmLen - *seq_len)
<a name="l00566"></a>00566         + engIDlen + engBtlen + engTmlen + namelen
<a name="l00567"></a>00567         + (authlen - *msgAuthParmLen);
<a name="l00568"></a>00568 
<a name="l00569"></a>00569     *privParamsOffset = *authParamsOffset + *msgAuthParmLen
<a name="l00570"></a>00570         + (privlen - *msgPrivParmLen);
<a name="l00571"></a>00571 
<a name="l00572"></a>00572 
<a name="l00573"></a>00573     <span class="comment">/*</span>
<a name="l00574"></a>00574 <span class="comment">     * Compute the size of the plaintext.  Round up to account for cipher</span>
<a name="l00575"></a>00575 <span class="comment">     * block size, if necessary.</span>
<a name="l00576"></a>00576 <span class="comment">     *</span>
<a name="l00577"></a>00577 <span class="comment">     * XXX  This is hardwired for 1DES... If scopedPduLen is already</span>
<a name="l00578"></a>00578 <span class="comment">     *      a multiple of 8, then *add* 8 more; otherwise, round up</span>
<a name="l00579"></a>00579 <span class="comment">     *      to the next multiple of 8.</span>
<a name="l00580"></a>00580 <span class="comment">     *</span>
<a name="l00581"></a>00581 <span class="comment">     * FIX  Calculation of encrypted portion of msgData and consequent</span>
<a name="l00582"></a>00582 <span class="comment">     *      setting and sanity checking of theTotalLength, et al. should</span>
<a name="l00583"></a>00583 <span class="comment">     *      occur *after* encryption has taken place.</span>
<a name="l00584"></a>00584 <span class="comment">     */</span>
<a name="l00585"></a>00585     <span class="keywordflow">if</span> (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l00586"></a>00586         scopedPduLen = ROUNDUP8(scopedPduLen);
<a name="l00587"></a>00587 
<a name="l00588"></a>00588         <span class="keywordflow">if</span> ((ret = asn_predict_length(ASN_OCTET_STR, NULL, scopedPduLen)) == -1) {
<a name="l00589"></a>00589             <span class="keywordflow">return</span> -1;
<a name="l00590"></a>00590         }
<a name="l00591"></a>00591         *datalen = (size_t)ret;
<a name="l00592"></a>00592     } <span class="keywordflow">else</span> {
<a name="l00593"></a>00593         *datalen = scopedPduLen;
<a name="l00594"></a>00594     }
<a name="l00595"></a>00595 
<a name="l00596"></a>00596     *dataOffset = globalDataLen + *msgSecParmLen +
<a name="l00597"></a>00597         (*datalen - scopedPduLen);
<a name="l00598"></a>00598     *theTotalLength = globalDataLen + *msgSecParmLen + *datalen;
<a name="l00599"></a>00599 
<a name="l00600"></a>00600     <span class="keywordflow">return</span> 0;
<a name="l00601"></a>00601 
<a name="l00602"></a>00602 }                               <span class="comment">/* end usm_calc_offsets() */</span>
<a name="l00603"></a>00603 
<a name="l00604"></a>00604 
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 
<a name="l00607"></a>00607 
<a name="l00608"></a>00608 <span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l00609"></a>00609 <span class="preprocessor"></span><span class="comment">/*******************************************************************-o-******</span>
<a name="l00610"></a>00610 <span class="comment"> * usm_set_salt</span>
<a name="l00611"></a>00611 <span class="comment"> *</span>
<a name="l00612"></a>00612 <span class="comment"> * Parameters:</span>
<a name="l00613"></a>00613 <span class="comment"> *      *iv               (O)   Buffer to contain IV.</span>
<a name="l00614"></a>00614 <span class="comment"> *      *iv_length        (O)   Length of iv.</span>
<a name="l00615"></a>00615 <span class="comment"> *      *priv_salt        (I)   Salt portion of private key.</span>
<a name="l00616"></a>00616 <span class="comment"> *       priv_salt_length (I)   Length of priv_salt.</span>
<a name="l00617"></a>00617 <span class="comment"> *      *msgSalt          (I/O) Pointer salt portion of outgoing msg buffer.</span>
<a name="l00618"></a>00618 <span class="comment"> *      </span>
<a name="l00619"></a>00619 <span class="comment"> * Returns:</span>
<a name="l00620"></a>00620 <span class="comment"> *      0       On success,</span>
<a name="l00621"></a>00621 <span class="comment"> *      -1      Otherwise.</span>
<a name="l00622"></a>00622 <span class="comment"> *</span>
<a name="l00623"></a>00623 <span class="comment"> *      Determine the initialization vector for the DES-CBC encryption.</span>
<a name="l00624"></a>00624 <span class="comment"> *      (Cf. RFC 2274, 8.1.1.1.)</span>
<a name="l00625"></a>00625 <span class="comment"> *</span>
<a name="l00626"></a>00626 <span class="comment"> *      iv is defined as the concatenation of engineBoots and the</span>
<a name="l00627"></a>00627 <span class="comment"> *              salt integer.</span>
<a name="l00628"></a>00628 <span class="comment"> *      The salt integer is incremented.</span>
<a name="l00629"></a>00629 <span class="comment"> *      The resulting salt is copied into the msgSalt buffer.</span>
<a name="l00630"></a>00630 <span class="comment"> *      The result of the concatenation is then XORed with the salt</span>
<a name="l00631"></a>00631 <span class="comment"> *              portion of the private key (last 8 bytes).</span>
<a name="l00632"></a>00632 <span class="comment"> *      The IV result is returned individually for further use.</span>
<a name="l00633"></a>00633 <span class="comment"> */</span>
<a name="l00634"></a>00634 <span class="keywordtype">int</span>
<a name="l00635"></a>00635 usm_set_salt(u_char * iv,
<a name="l00636"></a>00636              <span class="keywordtype">size_t</span> * iv_length,
<a name="l00637"></a>00637              u_char * priv_salt, <span class="keywordtype">size_t</span> priv_salt_length, u_char * msgSalt)
<a name="l00638"></a>00638 {
<a name="l00639"></a>00639     <span class="keywordtype">size_t</span>          propersize_salt = BYTESIZE(USM_DES_SALT_LENGTH);
<a name="l00640"></a>00640     <span class="keywordtype">int</span>             net_boots;
<a name="l00641"></a>00641     <span class="keywordtype">int</span>             net_salt_int;
<a name="l00642"></a>00642     <span class="comment">/*</span>
<a name="l00643"></a>00643 <span class="comment">     * net_* should be encoded in network byte order.  XXX  Why?</span>
<a name="l00644"></a>00644 <span class="comment">     */</span>
<a name="l00645"></a>00645     <span class="keywordtype">int</span>             iindex;
<a name="l00646"></a>00646 
<a name="l00647"></a>00647 
<a name="l00648"></a>00648     <span class="comment">/*</span>
<a name="l00649"></a>00649 <span class="comment">     * Sanity check.</span>
<a name="l00650"></a>00650 <span class="comment">     */</span>
<a name="l00651"></a>00651     <span class="keywordflow">if</span> (!iv || !iv_length || !priv_salt || (*iv_length != propersize_salt)
<a name="l00652"></a>00652         || (priv_salt_length &lt; propersize_salt)) {
<a name="l00653"></a>00653         <span class="keywordflow">return</span> -1;
<a name="l00654"></a>00654     }
<a name="l00655"></a>00655 
<a name="l00656"></a>00656 
<a name="l00657"></a>00657     net_boots = htonl(snmpv3_local_snmpEngineBoots());
<a name="l00658"></a>00658     net_salt_int = htonl(salt_integer);
<a name="l00659"></a>00659 
<a name="l00660"></a>00660     salt_integer += 1;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662     memcpy(iv, &amp;net_boots, propersize_salt / 2);
<a name="l00663"></a>00663     memcpy(iv + (propersize_salt / 2), &amp;net_salt_int, propersize_salt / 2);
<a name="l00664"></a>00664 
<a name="l00665"></a>00665     <span class="keywordflow">if</span> (msgSalt)
<a name="l00666"></a>00666         memcpy(msgSalt, iv, propersize_salt);
<a name="l00667"></a>00667 
<a name="l00668"></a>00668 
<a name="l00669"></a>00669     <span class="comment">/*</span>
<a name="l00670"></a>00670 <span class="comment">     * Turn the salt into an IV: XOR &lt;boots, salt_int&gt; with salt</span>
<a name="l00671"></a>00671 <span class="comment">     * portion of priv_key.</span>
<a name="l00672"></a>00672 <span class="comment">     */</span>
<a name="l00673"></a>00673     <span class="keywordflow">for</span> (iindex = 0; iindex &lt; (int) propersize_salt; iindex++)
<a name="l00674"></a>00674         iv[iindex] ^= priv_salt[iindex];
<a name="l00675"></a>00675 
<a name="l00676"></a>00676 
<a name="l00677"></a>00677     <span class="keywordflow">return</span> 0;
<a name="l00678"></a>00678 
<a name="l00679"></a>00679 }                               <span class="comment">/* end usm_set_salt() */</span>
<a name="l00680"></a>00680 <span class="preprocessor">#endif</span>
<a name="l00681"></a>00681 <span class="preprocessor"></span>
<a name="l00682"></a>00682 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l00683"></a>00683 <span class="preprocessor"></span><span class="comment">/*******************************************************************-o-******</span>
<a name="l00684"></a>00684 <span class="comment"> * usm_set_aes_iv</span>
<a name="l00685"></a>00685 <span class="comment"> *</span>
<a name="l00686"></a>00686 <span class="comment"> * Parameters:</span>
<a name="l00687"></a>00687 <span class="comment"> *      *iv               (O)   Buffer to contain IV.</span>
<a name="l00688"></a>00688 <span class="comment"> *      *iv_length        (O)   Length of iv.</span>
<a name="l00689"></a>00689 <span class="comment"> *      net_boots         (I)   the network byte order of the authEng boots val</span>
<a name="l00690"></a>00690 <span class="comment"> *      net_time         (I)   the network byte order of the authEng time val</span>
<a name="l00691"></a>00691 <span class="comment"> *      *salt             (O)   A buffer for the outgoing salt (= 8 bytes of iv)</span>
<a name="l00692"></a>00692 <span class="comment"> *      </span>
<a name="l00693"></a>00693 <span class="comment"> * Returns:</span>
<a name="l00694"></a>00694 <span class="comment"> *      0       On success,</span>
<a name="l00695"></a>00695 <span class="comment"> *      -1      Otherwise.</span>
<a name="l00696"></a>00696 <span class="comment"> *</span>
<a name="l00697"></a>00697 <span class="comment"> *      Determine the initialization vector for AES encryption.</span>
<a name="l00698"></a>00698 <span class="comment"> *      (draft-blumenthal-aes-usm-03.txt, 3.1.2.2)</span>
<a name="l00699"></a>00699 <span class="comment"> *</span>
<a name="l00700"></a>00700 <span class="comment"> *      iv is defined as the concatenation of engineBoots, engineTime</span>
<a name="l00701"></a>00701 <span class="comment">        and a 64 bit salt-integer.</span>
<a name="l00702"></a>00702 <span class="comment"> *      The 64 bit salt integer is incremented.</span>
<a name="l00703"></a>00703 <span class="comment"> *      The resulting salt is copied into the salt buffer.</span>
<a name="l00704"></a>00704 <span class="comment"> *      The IV result is returned individually for further use.</span>
<a name="l00705"></a>00705 <span class="comment"> */</span>
<a name="l00706"></a>00706 <span class="keywordtype">int</span>
<a name="l00707"></a>00707 usm_set_aes_iv(u_char * iv,
<a name="l00708"></a>00708                <span class="keywordtype">size_t</span> * iv_length,
<a name="l00709"></a>00709                u_int net_boots,
<a name="l00710"></a>00710                u_int net_time,
<a name="l00711"></a>00711                u_char * salt)
<a name="l00712"></a>00712 {
<a name="l00713"></a>00713     <span class="comment">/*</span>
<a name="l00714"></a>00714 <span class="comment">     * net_* should be encoded in network byte order.</span>
<a name="l00715"></a>00715 <span class="comment">     */</span>
<a name="l00716"></a>00716     <span class="keywordtype">int</span>             net_salt_int1, net_salt_int2;
<a name="l00717"></a>00717 <span class="preprocessor">#define PROPER_AES_IV_SIZE 64</span>
<a name="l00718"></a>00718 <span class="preprocessor"></span>
<a name="l00719"></a>00719     <span class="comment">/*</span>
<a name="l00720"></a>00720 <span class="comment">     * Sanity check.</span>
<a name="l00721"></a>00721 <span class="comment">     */</span>
<a name="l00722"></a>00722     <span class="keywordflow">if</span> (!iv || !iv_length) {
<a name="l00723"></a>00723         <span class="keywordflow">return</span> -1;
<a name="l00724"></a>00724     }
<a name="l00725"></a>00725 
<a name="l00726"></a>00726     net_salt_int1 = htonl(salt_integer64_1);
<a name="l00727"></a>00727     net_salt_int2 = htonl(salt_integer64_2);
<a name="l00728"></a>00728 
<a name="l00729"></a>00729     <span class="keywordflow">if</span> ((salt_integer64_2 += 1) == 0)
<a name="l00730"></a>00730         salt_integer64_2 += 1;
<a name="l00731"></a>00731     
<a name="l00732"></a>00732     <span class="comment">/* XXX: warning: hard coded proper lengths */</span>
<a name="l00733"></a>00733     memcpy(iv, &amp;net_boots, 4);
<a name="l00734"></a>00734     memcpy(iv+4, &amp;net_time, 4);
<a name="l00735"></a>00735     memcpy(iv+8, &amp;net_salt_int1, 4);
<a name="l00736"></a>00736     memcpy(iv+12, &amp;net_salt_int2, 4);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738     memcpy(salt, iv+8, 8); <span class="comment">/* only copy the needed portion */</span>
<a name="l00739"></a>00739     <span class="keywordflow">return</span> 0;
<a name="l00740"></a>00740 }                               <span class="comment">/* end usm_set_salt() */</span>
<a name="l00741"></a>00741 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_AES */</span>
<a name="l00742"></a>00742 
<a name="l00743"></a>00743 <span class="keywordtype">int</span>
<a name="l00744"></a>00744 usm_secmod_generate_out_msg(<span class="keyword">struct</span> <a class="code" href="structsnmp__secmod__outgoing__params.html">snmp_secmod_outgoing_params</a> *parms)
<a name="l00745"></a>00745 {
<a name="l00746"></a>00746     <span class="keywordflow">if</span> (!parms)
<a name="l00747"></a>00747         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749     <span class="keywordflow">return</span> usm_generate_out_msg(parms-&gt;msgProcModel,
<a name="l00750"></a>00750                                 parms-&gt;globalData, parms-&gt;globalDataLen,
<a name="l00751"></a>00751                                 parms-&gt;maxMsgSize, parms-&gt;secModel,
<a name="l00752"></a>00752                                 parms-&gt;secEngineID, parms-&gt;secEngineIDLen,
<a name="l00753"></a>00753                                 parms-&gt;secName, parms-&gt;secNameLen,
<a name="l00754"></a>00754                                 parms-&gt;secLevel,
<a name="l00755"></a>00755                                 parms-&gt;scopedPdu, parms-&gt;scopedPduLen,
<a name="l00756"></a>00756                                 parms-&gt;secStateRef,
<a name="l00757"></a>00757                                 parms-&gt;secParams, parms-&gt;secParamsLen,
<a name="l00758"></a>00758                                 parms-&gt;wholeMsg, parms-&gt;wholeMsgLen);
<a name="l00759"></a>00759 }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761 <span class="comment">/*******************************************************************-o-******</span>
<a name="l00762"></a>00762 <span class="comment"> * usm_generate_out_msg</span>
<a name="l00763"></a>00763 <span class="comment"> *</span>
<a name="l00764"></a>00764 <span class="comment"> * Parameters:</span>
<a name="l00765"></a>00765 <span class="comment"> *      (See list below...)</span>
<a name="l00766"></a>00766 <span class="comment"> *      </span>
<a name="l00767"></a>00767 <span class="comment"> * Returns:</span>
<a name="l00768"></a>00768 <span class="comment"> *      SNMPERR_SUCCESS                 On success.</span>
<a name="l00769"></a>00769 <span class="comment"> *      SNMPERR_USM_AUTHENTICATIONFAILURE</span>
<a name="l00770"></a>00770 <span class="comment"> *      SNMPERR_USM_ENCRYPTIONERROR</span>
<a name="l00771"></a>00771 <span class="comment"> *      SNMPERR_USM_GENERICERROR</span>
<a name="l00772"></a>00772 <span class="comment"> *      SNMPERR_USM_UNKNOWNSECURITYNAME</span>
<a name="l00773"></a>00773 <span class="comment"> *      SNMPERR_USM_GENERICERROR</span>
<a name="l00774"></a>00774 <span class="comment"> *      SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL</span>
<a name="l00775"></a>00775 <span class="comment"> *      </span>
<a name="l00776"></a>00776 <span class="comment"> *</span>
<a name="l00777"></a>00777 <span class="comment"> * Generates an outgoing message.</span>
<a name="l00778"></a>00778 <span class="comment"> *</span>
<a name="l00779"></a>00779 <span class="comment"> * XXX  Beware of misnomers!</span>
<a name="l00780"></a>00780 <span class="comment"> */</span>
<a name="l00781"></a>00781 <span class="keywordtype">int</span>
<a name="l00782"></a>00782 usm_generate_out_msg(<span class="keywordtype">int</span> msgProcModel,  <span class="comment">/* (UNUSED) */</span>
<a name="l00783"></a>00783                      u_char * globalData,       <span class="comment">/* IN */</span>
<a name="l00784"></a>00784                      <span class="comment">/*</span>
<a name="l00785"></a>00785 <span class="comment">                      * Pointer to msg header data will point to the beginning</span>
<a name="l00786"></a>00786 <span class="comment">                      * * of the entire packet buffer to be transmitted on wire,</span>
<a name="l00787"></a>00787 <span class="comment">                      * * memory will be contiguous with secParams, typically</span>
<a name="l00788"></a>00788 <span class="comment">                      * * this pointer will be passed back as beginning of</span>
<a name="l00789"></a>00789 <span class="comment">                      * * wholeMsg below.  asn seq. length is updated w/ new length.</span>
<a name="l00790"></a>00790 <span class="comment">                      * *</span>
<a name="l00791"></a>00791 <span class="comment">                      * * While this points to a buffer that should be big enough</span>
<a name="l00792"></a>00792 <span class="comment">                      * * for the whole message, only the first two parts</span>
<a name="l00793"></a>00793 <span class="comment">                      * * of the message are completed, namely SNMPv3Message and</span>
<a name="l00794"></a>00794 <span class="comment">                      * * HeaderData.  globalDataLen (next parameter) represents</span>
<a name="l00795"></a>00795 <span class="comment">                      * * the length of these two completed parts.</span>
<a name="l00796"></a>00796 <span class="comment">                      */</span>
<a name="l00797"></a>00797                      <span class="keywordtype">size_t</span> globalDataLen,      <span class="comment">/* IN - Length of msg header data.      */</span>
<a name="l00798"></a>00798                      <span class="keywordtype">int</span> maxMsgSize,    <span class="comment">/* (UNUSED) */</span>
<a name="l00799"></a>00799                      <span class="keywordtype">int</span> secModel,      <span class="comment">/* (UNUSED) */</span>
<a name="l00800"></a>00800                      u_char * secEngineID,      <span class="comment">/* IN - Pointer snmpEngineID.           */</span>
<a name="l00801"></a>00801                      <span class="keywordtype">size_t</span> secEngineIDLen,     <span class="comment">/* IN - SnmpEngineID length.            */</span>
<a name="l00802"></a>00802                      <span class="keywordtype">char</span> *secName,     <span class="comment">/* IN - Pointer to securityName.        */</span>
<a name="l00803"></a>00803                      <span class="keywordtype">size_t</span> secNameLen, <span class="comment">/* IN - SecurityName length.            */</span>
<a name="l00804"></a>00804                      <span class="keywordtype">int</span> secLevel,      <span class="comment">/* IN - AuthNoPriv, authPriv etc.       */</span>
<a name="l00805"></a>00805                      u_char * scopedPdu,        <span class="comment">/* IN */</span>
<a name="l00806"></a>00806                      <span class="comment">/*</span>
<a name="l00807"></a>00807 <span class="comment">                      * Pointer to scopedPdu will be encrypted by USM if needed</span>
<a name="l00808"></a>00808 <span class="comment">                      * * and written to packet buffer immediately following</span>
<a name="l00809"></a>00809 <span class="comment">                      * * securityParameters, entire msg will be authenticated by</span>
<a name="l00810"></a>00810 <span class="comment">                      * * USM if needed.</span>
<a name="l00811"></a>00811 <span class="comment">                      */</span>
<a name="l00812"></a>00812                      <span class="keywordtype">size_t</span> scopedPduLen,       <span class="comment">/* IN - scopedPdu length. */</span>
<a name="l00813"></a>00813                      <span class="keywordtype">void</span> *secStateRef, <span class="comment">/* IN */</span>
<a name="l00814"></a>00814                      <span class="comment">/*</span>
<a name="l00815"></a>00815 <span class="comment">                      * secStateRef, pointer to cached info provided only for</span>
<a name="l00816"></a>00816 <span class="comment">                      * * Response, otherwise NULL.</span>
<a name="l00817"></a>00817 <span class="comment">                      */</span>
<a name="l00818"></a>00818                      u_char * secParams,        <span class="comment">/* OUT */</span>
<a name="l00819"></a>00819                      <span class="comment">/*</span>
<a name="l00820"></a>00820 <span class="comment">                      * BER encoded securityParameters pointer to offset within</span>
<a name="l00821"></a>00821 <span class="comment">                      * * packet buffer where secParams should be written, the</span>
<a name="l00822"></a>00822 <span class="comment">                      * * entire BER encoded OCTET STRING (including header) is</span>
<a name="l00823"></a>00823 <span class="comment">                      * * written here by USM secParams = globalData +</span>
<a name="l00824"></a>00824 <span class="comment">                      * * globalDataLen.</span>
<a name="l00825"></a>00825 <span class="comment">                      */</span>
<a name="l00826"></a>00826                      <span class="keywordtype">size_t</span> * secParamsLen,     <span class="comment">/* IN/OUT - Len available, len returned. */</span>
<a name="l00827"></a>00827                      u_char ** wholeMsg,        <span class="comment">/* OUT */</span>
<a name="l00828"></a>00828                      <span class="comment">/*</span>
<a name="l00829"></a>00829 <span class="comment">                      * Complete authenticated/encrypted message - typically</span>
<a name="l00830"></a>00830 <span class="comment">                      * * the pointer to start of packet buffer provided in</span>
<a name="l00831"></a>00831 <span class="comment">                      * * globalData is returned here, could also be a separate</span>
<a name="l00832"></a>00832 <span class="comment">                      * * buffer.</span>
<a name="l00833"></a>00833 <span class="comment">                      */</span>
<a name="l00834"></a>00834                      <span class="keywordtype">size_t</span> * wholeMsgLen)
<a name="l00835"></a>00835 {                               <span class="comment">/* IN/OUT - Len available, len returned. */</span>
<a name="l00836"></a>00836     <span class="keywordtype">size_t</span>          otstlen;
<a name="l00837"></a>00837     <span class="keywordtype">size_t</span>          seq_len;
<a name="l00838"></a>00838     <span class="keywordtype">size_t</span>          msgAuthParmLen;
<a name="l00839"></a>00839     <span class="keywordtype">size_t</span>          msgPrivParmLen;
<a name="l00840"></a>00840     <span class="keywordtype">size_t</span>          msgSecParmLen;
<a name="l00841"></a>00841     <span class="keywordtype">size_t</span>          authParamsOffset;
<a name="l00842"></a>00842     <span class="keywordtype">size_t</span>          privParamsOffset;
<a name="l00843"></a>00843     <span class="keywordtype">size_t</span>          datalen;
<a name="l00844"></a>00844     <span class="keywordtype">size_t</span>          dataOffset;
<a name="l00845"></a>00845     <span class="keywordtype">size_t</span>          theTotalLength;
<a name="l00846"></a>00846 
<a name="l00847"></a>00847     u_char         *ptr;
<a name="l00848"></a>00848     <span class="keywordtype">size_t</span>          ptr_len;
<a name="l00849"></a>00849     <span class="keywordtype">size_t</span>          remaining;
<a name="l00850"></a>00850     <span class="keywordtype">size_t</span>          offSet;
<a name="l00851"></a>00851     u_int           boots_uint;
<a name="l00852"></a>00852     u_int           time_uint;
<a name="l00853"></a>00853     <span class="keywordtype">long</span>            boots_long;
<a name="l00854"></a>00854     <span class="keywordtype">long</span>            time_long;
<a name="l00855"></a>00855 
<a name="l00856"></a>00856     <span class="comment">/*</span>
<a name="l00857"></a>00857 <span class="comment">     * Indirection because secStateRef values override parameters.</span>
<a name="l00858"></a>00858 <span class="comment">     * </span>
<a name="l00859"></a>00859 <span class="comment">     * None of these are to be free&#39;d - they are either pointing to</span>
<a name="l00860"></a>00860 <span class="comment">     * what&#39;s in the secStateRef or to something either in the</span>
<a name="l00861"></a>00861 <span class="comment">     * actual prarmeter list or the user list.</span>
<a name="l00862"></a>00862 <span class="comment">     */</span>
<a name="l00863"></a>00863 
<a name="l00864"></a>00864     <span class="keywordtype">char</span>           *theName = NULL;
<a name="l00865"></a>00865     u_int           theNameLength = 0;
<a name="l00866"></a>00866     u_char         *theEngineID = NULL;
<a name="l00867"></a>00867     u_int           theEngineIDLength = 0;
<a name="l00868"></a>00868     u_char         *theAuthKey = NULL;
<a name="l00869"></a>00869     u_int           theAuthKeyLength = 0;
<a name="l00870"></a>00870     <span class="keyword">const</span> oid      *theAuthProtocol = NULL;
<a name="l00871"></a>00871     u_int           theAuthProtocolLength = 0;
<a name="l00872"></a>00872     u_char         *thePrivKey = NULL;
<a name="l00873"></a>00873     u_int           thePrivKeyLength = 0;
<a name="l00874"></a>00874     <span class="keyword">const</span> oid      *thePrivProtocol = NULL;
<a name="l00875"></a>00875     u_int           thePrivProtocolLength = 0;
<a name="l00876"></a>00876     <span class="keywordtype">int</span>             theSecLevel = 0;    <span class="comment">/* No defined const for bad</span>
<a name="l00877"></a>00877 <span class="comment">                                         * value (other then err).</span>
<a name="l00878"></a>00878 <span class="comment">                                         */</span>
<a name="l00879"></a>00879 
<a name="l00880"></a>00880     DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;USM processing has begun.\n&quot;</span>));
<a name="l00881"></a>00881 
<a name="l00882"></a>00882     <span class="keywordflow">if</span> (secStateRef != NULL) {
<a name="l00883"></a>00883         <span class="comment">/*</span>
<a name="l00884"></a>00884 <span class="comment">         * To hush the compiler for now.  XXX </span>
<a name="l00885"></a>00885 <span class="comment">         */</span>
<a name="l00886"></a>00886         <span class="keyword">struct </span><a class="code" href="structusmStateReference.html">usmStateReference</a> *ref
<a name="l00887"></a>00887             = (<span class="keyword">struct </span><a class="code" href="structusmStateReference.html">usmStateReference</a> *) secStateRef;
<a name="l00888"></a>00888 
<a name="l00889"></a>00889         theName = ref-&gt;usr_name;
<a name="l00890"></a>00890         theNameLength = ref-&gt;usr_name_length;
<a name="l00891"></a>00891         theEngineID = ref-&gt;usr_engine_id;
<a name="l00892"></a>00892         theEngineIDLength = ref-&gt;usr_engine_id_length;
<a name="l00893"></a>00893 
<a name="l00894"></a>00894         <span class="keywordflow">if</span> (!theEngineIDLength) {
<a name="l00895"></a>00895             theEngineID = secEngineID;
<a name="l00896"></a>00896             theEngineIDLength = secEngineIDLen;
<a name="l00897"></a>00897         }
<a name="l00898"></a>00898 
<a name="l00899"></a>00899         theAuthProtocol = ref-&gt;usr_auth_protocol;
<a name="l00900"></a>00900         theAuthProtocolLength = ref-&gt;usr_auth_protocol_length;
<a name="l00901"></a>00901         theAuthKey = ref-&gt;usr_auth_key;
<a name="l00902"></a>00902         theAuthKeyLength = ref-&gt;usr_auth_key_length;
<a name="l00903"></a>00903         thePrivProtocol = ref-&gt;usr_priv_protocol;
<a name="l00904"></a>00904         thePrivProtocolLength = ref-&gt;usr_priv_protocol_length;
<a name="l00905"></a>00905         thePrivKey = ref-&gt;usr_priv_key;
<a name="l00906"></a>00906         thePrivKeyLength = ref-&gt;usr_priv_key_length;
<a name="l00907"></a>00907         theSecLevel = ref-&gt;usr_sec_level;
<a name="l00908"></a>00908     }
<a name="l00909"></a>00909 
<a name="l00910"></a>00910     <span class="comment">/*</span>
<a name="l00911"></a>00911 <span class="comment">     * Identify the user record.</span>
<a name="l00912"></a>00912 <span class="comment">     */</span>
<a name="l00913"></a>00913     <span class="keywordflow">else</span> {
<a name="l00914"></a>00914         <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *user;
<a name="l00915"></a>00915 
<a name="l00916"></a>00916         <span class="comment">/*</span>
<a name="l00917"></a>00917 <span class="comment">         * we do allow an unknown user name for</span>
<a name="l00918"></a>00918 <span class="comment">         * unauthenticated requests. </span>
<a name="l00919"></a>00919 <span class="comment">         */</span>
<a name="l00920"></a>00920         <span class="keywordflow">if</span> ((user = usm_get_user(secEngineID, secEngineIDLen, secName))
<a name="l00921"></a>00921             == NULL &amp;&amp; secLevel != SNMP_SEC_LEVEL_NOAUTH) {
<a name="l00922"></a>00922             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Unknown User(%s)\n&quot;</span>, secName));
<a name="l00923"></a>00923             usm_free_usmStateReference(secStateRef);
<a name="l00924"></a>00924             <span class="keywordflow">return</span> SNMPERR_USM_UNKNOWNSECURITYNAME;
<a name="l00925"></a>00925         }
<a name="l00926"></a>00926 
<a name="l00927"></a>00927         theName = secName;
<a name="l00928"></a>00928         theNameLength = secNameLen;
<a name="l00929"></a>00929         theEngineID = secEngineID;
<a name="l00930"></a>00930         theSecLevel = secLevel;
<a name="l00931"></a>00931         theEngineIDLength = secEngineIDLen;
<a name="l00932"></a>00932         <span class="keywordflow">if</span> (user) {
<a name="l00933"></a>00933             theAuthProtocol = user-&gt;authProtocol;
<a name="l00934"></a>00934             theAuthProtocolLength = user-&gt;authProtocolLen;
<a name="l00935"></a>00935             theAuthKey = user-&gt;authKey;
<a name="l00936"></a>00936             theAuthKeyLength = user-&gt;authKeyLen;
<a name="l00937"></a>00937             thePrivProtocol = user-&gt;privProtocol;
<a name="l00938"></a>00938             thePrivProtocolLength = user-&gt;privProtocolLen;
<a name="l00939"></a>00939             thePrivKey = user-&gt;privKey;
<a name="l00940"></a>00940             thePrivKeyLength = user-&gt;privKeyLen;
<a name="l00941"></a>00941         } <span class="keywordflow">else</span> {
<a name="l00942"></a>00942             <span class="comment">/*</span>
<a name="l00943"></a>00943 <span class="comment">             * unknown users can not do authentication (obviously) </span>
<a name="l00944"></a>00944 <span class="comment">             */</span>
<a name="l00945"></a>00945             theAuthProtocol = usmNoAuthProtocol;
<a name="l00946"></a>00946             theAuthProtocolLength =
<a name="l00947"></a>00947                 <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class="keyword">sizeof</span>(oid);
<a name="l00948"></a>00948             theAuthKey = NULL;
<a name="l00949"></a>00949             theAuthKeyLength = 0;
<a name="l00950"></a>00950             thePrivProtocol = usmNoPrivProtocol;
<a name="l00951"></a>00951             thePrivProtocolLength =
<a name="l00952"></a>00952                 <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid);
<a name="l00953"></a>00953             thePrivKey = NULL;
<a name="l00954"></a>00954             thePrivKeyLength = 0;
<a name="l00955"></a>00955         }
<a name="l00956"></a>00956     }                           <span class="comment">/* endif -- secStateRef==NULL */</span>
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 
<a name="l00959"></a>00959     <span class="comment">/*</span>
<a name="l00960"></a>00960 <span class="comment">     * From here to the end of the function, avoid reference to</span>
<a name="l00961"></a>00961 <span class="comment">     * secName, secEngineID, secLevel, and associated lengths.</span>
<a name="l00962"></a>00962 <span class="comment">     */</span>
<a name="l00963"></a>00963 
<a name="l00964"></a>00964 
<a name="l00965"></a>00965     <span class="comment">/*</span>
<a name="l00966"></a>00966 <span class="comment">     * Check to see if the user can use the requested sec services.</span>
<a name="l00967"></a>00967 <span class="comment">     */</span>
<a name="l00968"></a>00968     <span class="keywordflow">if</span> (usm_check_secLevel_vs_protocols(theSecLevel,
<a name="l00969"></a>00969                                         theAuthProtocol,
<a name="l00970"></a>00970                                         theAuthProtocolLength,
<a name="l00971"></a>00971                                         thePrivProtocol,
<a name="l00972"></a>00972                                         thePrivProtocolLength) == 1) {
<a name="l00973"></a>00973         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Unsupported Security Level (%d)\n&quot;</span>,
<a name="l00974"></a>00974                     theSecLevel));
<a name="l00975"></a>00975         usm_free_usmStateReference(secStateRef);
<a name="l00976"></a>00976         <span class="keywordflow">return</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;
<a name="l00977"></a>00977     }
<a name="l00978"></a>00978 
<a name="l00979"></a>00979 
<a name="l00980"></a>00980     <span class="comment">/*</span>
<a name="l00981"></a>00981 <span class="comment">     * Retrieve the engine information.</span>
<a name="l00982"></a>00982 <span class="comment">     *</span>
<a name="l00983"></a>00983 <span class="comment">     * XXX  No error is declared in the EoP when sending messages to</span>
<a name="l00984"></a>00984 <span class="comment">     *      unknown engines, processing continues w/ boots/time == (0,0).</span>
<a name="l00985"></a>00985 <span class="comment">     */</span>
<a name="l00986"></a>00986     <span class="keywordflow">if</span> (get_enginetime(theEngineID, theEngineIDLength,
<a name="l00987"></a>00987                        &amp;boots_uint, &amp;time_uint, FALSE) == -1) {
<a name="l00988"></a>00988         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>, <span class="stringliteral">&quot;Failed to find engine data.&quot;</span>));
<a name="l00989"></a>00989     }
<a name="l00990"></a>00990 
<a name="l00991"></a>00991     boots_long = boots_uint;
<a name="l00992"></a>00992     time_long = time_uint;
<a name="l00993"></a>00993 
<a name="l00994"></a>00994 
<a name="l00995"></a>00995     <span class="comment">/*</span>
<a name="l00996"></a>00996 <span class="comment">     * Set up the Offsets.</span>
<a name="l00997"></a>00997 <span class="comment">     */</span>
<a name="l00998"></a>00998     <span class="keywordflow">if</span> (usm_calc_offsets(globalDataLen, theSecLevel, theEngineIDLength,
<a name="l00999"></a>00999                          theNameLength, scopedPduLen, boots_long,
<a name="l01000"></a>01000                          time_long, &amp;theTotalLength, &amp;authParamsOffset,
<a name="l01001"></a>01001                          &amp;privParamsOffset, &amp;dataOffset, &amp;datalen,
<a name="l01002"></a>01002                          &amp;msgAuthParmLen, &amp;msgPrivParmLen, &amp;otstlen,
<a name="l01003"></a>01003                          &amp;seq_len, &amp;msgSecParmLen) == -1) {
<a name="l01004"></a>01004         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Failed calculating offsets.\n&quot;</span>));
<a name="l01005"></a>01005         usm_free_usmStateReference(secStateRef);
<a name="l01006"></a>01006         <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01007"></a>01007     }
<a name="l01008"></a>01008 
<a name="l01009"></a>01009     <span class="comment">/*</span>
<a name="l01010"></a>01010 <span class="comment">     * So, we have the offsets for the three parts that need to be</span>
<a name="l01011"></a>01011 <span class="comment">     * determined, and an overall length.  Now we need to make</span>
<a name="l01012"></a>01012 <span class="comment">     * sure all of this would fit in the outgoing buffer, and</span>
<a name="l01013"></a>01013 <span class="comment">     * whether or not we need to make a new buffer, etc.</span>
<a name="l01014"></a>01014 <span class="comment">     */</span>
<a name="l01015"></a>01015 
<a name="l01016"></a>01016 
<a name="l01017"></a>01017     <span class="comment">/*</span>
<a name="l01018"></a>01018 <span class="comment">     * Set wholeMsg as a pointer to globalData.  Sanity check for</span>
<a name="l01019"></a>01019 <span class="comment">     * the proper size.</span>
<a name="l01020"></a>01020 <span class="comment">     * </span>
<a name="l01021"></a>01021 <span class="comment">     * Mark workspace in the message with bytes of all 1&#39;s to make it</span>
<a name="l01022"></a>01022 <span class="comment">     * easier to find mistakes in raw message dumps.</span>
<a name="l01023"></a>01023 <span class="comment">     */</span>
<a name="l01024"></a>01024     ptr = *wholeMsg = globalData;
<a name="l01025"></a>01025     <span class="keywordflow">if</span> (theTotalLength &gt; *wholeMsgLen) {
<a name="l01026"></a>01026         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Message won&#39;t fit in buffer.\n&quot;</span>));
<a name="l01027"></a>01027         usm_free_usmStateReference(secStateRef);
<a name="l01028"></a>01028         <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01029"></a>01029     }
<a name="l01030"></a>01030 
<a name="l01031"></a>01031     ptr_len = *wholeMsgLen = theTotalLength;
<a name="l01032"></a>01032 
<a name="l01033"></a>01033 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l01034"></a>01034 <span class="preprocessor"></span>    memset(&amp;ptr[globalDataLen], 0xFF, theTotalLength - globalDataLen);
<a name="l01035"></a>01035 <span class="preprocessor">#endif                          </span><span class="comment">/* NETSNMP_ENABLE_TESTING_CODE */</span>
<a name="l01036"></a>01036 
<a name="l01037"></a>01037     <span class="comment">/*</span>
<a name="l01038"></a>01038 <span class="comment">     * Do the encryption.</span>
<a name="l01039"></a>01039 <span class="comment">     */</span>
<a name="l01040"></a>01040     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01041"></a>01041         <span class="keywordtype">size_t</span>          encrypted_length = theTotalLength - dataOffset;
<a name="l01042"></a>01042         <span class="keywordtype">size_t</span>          salt_length = BYTESIZE(USM_MAX_SALT_LENGTH);
<a name="l01043"></a>01043         u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];
<a name="l01044"></a>01044 
<a name="l01045"></a>01045         <span class="comment">/*</span>
<a name="l01046"></a>01046 <span class="comment">         * XXX  Hardwired to seek into a 1DES private key!</span>
<a name="l01047"></a>01047 <span class="comment">         */</span>
<a name="l01048"></a>01048 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l01049"></a>01049 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (ISTRANSFORM(thePrivProtocol, AESPriv)) {
<a name="l01050"></a>01050             <span class="keywordflow">if</span> (!thePrivKey ||
<a name="l01051"></a>01051                 usm_set_aes_iv(salt, &amp;salt_length,
<a name="l01052"></a>01052                                htonl(boots_uint), htonl(time_uint),
<a name="l01053"></a>01053                                &amp;ptr[privParamsOffset]) == -1) {
<a name="l01054"></a>01054                 DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Can&#39;t set AES iv.\n&quot;</span>));
<a name="l01055"></a>01055                 usm_free_usmStateReference(secStateRef);
<a name="l01056"></a>01056                 <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01057"></a>01057             }
<a name="l01058"></a>01058         } 
<a name="l01059"></a>01059 <span class="preprocessor">#endif</span>
<a name="l01060"></a>01060 <span class="preprocessor"></span><span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l01061"></a>01061 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (ISTRANSFORM(thePrivProtocol, DESPriv)) {
<a name="l01062"></a>01062             <span class="keywordflow">if</span> (!thePrivKey ||
<a name="l01063"></a>01063                 (usm_set_salt(salt, &amp;salt_length,
<a name="l01064"></a>01064                               thePrivKey + 8, thePrivKeyLength - 8,
<a name="l01065"></a>01065                               &amp;ptr[privParamsOffset])
<a name="l01066"></a>01066                  == -1)) {
<a name="l01067"></a>01067                 DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Can&#39;t set DES-CBC salt.\n&quot;</span>));
<a name="l01068"></a>01068                 usm_free_usmStateReference(secStateRef);
<a name="l01069"></a>01069                 <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01070"></a>01070             }
<a name="l01071"></a>01071         }
<a name="l01072"></a>01072 <span class="preprocessor">#endif</span>
<a name="l01073"></a>01073 <span class="preprocessor"></span>
<a name="l01074"></a>01074         <span class="keywordflow">if</span> (sc_encrypt(thePrivProtocol, thePrivProtocolLength,
<a name="l01075"></a>01075                        thePrivKey, thePrivKeyLength,
<a name="l01076"></a>01076                        salt, salt_length,
<a name="l01077"></a>01077                        scopedPdu, scopedPduLen,
<a name="l01078"></a>01078                        &amp;ptr[dataOffset], &amp;encrypted_length)
<a name="l01079"></a>01079             != SNMP_ERR_NOERROR) {
<a name="l01080"></a>01080             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;encryption error.\n&quot;</span>));
<a name="l01081"></a>01081             usm_free_usmStateReference(secStateRef);
<a name="l01082"></a>01082             <span class="keywordflow">return</span> SNMPERR_USM_ENCRYPTIONERROR;
<a name="l01083"></a>01083         }
<a name="l01084"></a>01084 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l01085"></a>01085 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (debug_is_token_registered(<span class="stringliteral">&quot;usm/dump&quot;</span>) == SNMPERR_SUCCESS) {
<a name="l01086"></a>01086             dump_chunk(<span class="stringliteral">&quot;usm/dump&quot;</span>, <span class="stringliteral">&quot;This data was encrypted:&quot;</span>,
<a name="l01087"></a>01087                        scopedPdu, scopedPduLen);
<a name="l01088"></a>01088             dump_chunk(<span class="stringliteral">&quot;usm/dump&quot;</span>, <span class="stringliteral">&quot;salt + Encrypted form:&quot;</span>,
<a name="l01089"></a>01089                        salt, salt_length);
<a name="l01090"></a>01090             dump_chunk(<span class="stringliteral">&quot;usm/dump&quot;</span>, NULL,
<a name="l01091"></a>01091                        &amp;ptr[dataOffset], encrypted_length);
<a name="l01092"></a>01092             dump_chunk(<span class="stringliteral">&quot;usm/dump&quot;</span>, <span class="stringliteral">&quot;*wholeMsg:&quot;</span>,
<a name="l01093"></a>01093                        *wholeMsg, theTotalLength);
<a name="l01094"></a>01094         }
<a name="l01095"></a>01095 <span class="preprocessor">#endif</span>
<a name="l01096"></a>01096 <span class="preprocessor"></span>
<a name="l01097"></a>01097 
<a name="l01098"></a>01098         ptr = *wholeMsg;
<a name="l01099"></a>01099         ptr_len = *wholeMsgLen = theTotalLength;
<a name="l01100"></a>01100 
<a name="l01101"></a>01101 
<a name="l01102"></a>01102         <span class="comment">/*</span>
<a name="l01103"></a>01103 <span class="comment">         * XXX  Sanity check for salt length should be moved up</span>
<a name="l01104"></a>01104 <span class="comment">         *      under usm_calc_offsets() or tossed.</span>
<a name="l01105"></a>01105 <span class="comment">         */</span>
<a name="l01106"></a>01106         <span class="keywordflow">if</span> ((encrypted_length != (theTotalLength - dataOffset))
<a name="l01107"></a>01107             || (salt_length != msgPrivParmLen)) {
<a name="l01108"></a>01108             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;encryption length error.\n&quot;</span>));
<a name="l01109"></a>01109             usm_free_usmStateReference(secStateRef);
<a name="l01110"></a>01110             <span class="keywordflow">return</span> SNMPERR_USM_ENCRYPTIONERROR;
<a name="l01111"></a>01111         }
<a name="l01112"></a>01112 
<a name="l01113"></a>01113         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Encryption successful.\n&quot;</span>));
<a name="l01114"></a>01114     }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116     <span class="comment">/*</span>
<a name="l01117"></a>01117 <span class="comment">     * No encryption for you!</span>
<a name="l01118"></a>01118 <span class="comment">     */</span>
<a name="l01119"></a>01119     <span class="keywordflow">else</span> {
<a name="l01120"></a>01120         memcpy(&amp;ptr[dataOffset], scopedPdu, scopedPduLen);
<a name="l01121"></a>01121     }
<a name="l01122"></a>01122 
<a name="l01123"></a>01123 
<a name="l01124"></a>01124 
<a name="l01125"></a>01125     <span class="comment">/*</span>
<a name="l01126"></a>01126 <span class="comment">     * Start filling in the other fields (in prep for authentication).</span>
<a name="l01127"></a>01127 <span class="comment">     * </span>
<a name="l01128"></a>01128 <span class="comment">     * offSet is an octet string header, which is different from all</span>
<a name="l01129"></a>01129 <span class="comment">     * the other headers.</span>
<a name="l01130"></a>01130 <span class="comment">     */</span>
<a name="l01131"></a>01131     remaining = ptr_len - globalDataLen;
<a name="l01132"></a>01132 
<a name="l01133"></a>01133     offSet = ptr_len - remaining;
<a name="l01134"></a>01134     asn_build_header(&amp;ptr[offSet], &amp;remaining,
<a name="l01135"></a>01135                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01136"></a>01136                                ASN_OCTET_STR), otstlen);
<a name="l01137"></a>01137 
<a name="l01138"></a>01138     offSet = ptr_len - remaining;
<a name="l01139"></a>01139     asn_build_sequence(&amp;ptr[offSet], &amp;remaining,
<a name="l01140"></a>01140                        (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR), seq_len);
<a name="l01141"></a>01141 
<a name="l01142"></a>01142     offSet = ptr_len - remaining;
<a name="l01143"></a>01143     DEBUGDUMPHEADER(<span class="stringliteral">&quot;send&quot;</span>, <span class="stringliteral">&quot;msgAuthoritativeEngineID&quot;</span>);
<a name="l01144"></a>01144     asn_build_string(&amp;ptr[offSet], &amp;remaining,
<a name="l01145"></a>01145                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01146"></a>01146                                ASN_OCTET_STR), theEngineID,
<a name="l01147"></a>01147                      theEngineIDLength);
<a name="l01148"></a>01148     DEBUGINDENTLESS();
<a name="l01149"></a>01149 
<a name="l01150"></a>01150     offSet = ptr_len - remaining;
<a name="l01151"></a>01151     DEBUGDUMPHEADER(<span class="stringliteral">&quot;send&quot;</span>, <span class="stringliteral">&quot;msgAuthoritativeEngineBoots&quot;</span>);
<a name="l01152"></a>01152     asn_build_int(&amp;ptr[offSet], &amp;remaining,
<a name="l01153"></a>01153                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
<a name="l01154"></a>01154                   &amp;boots_long, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l01155"></a>01155     DEBUGINDENTLESS();
<a name="l01156"></a>01156 
<a name="l01157"></a>01157     offSet = ptr_len - remaining;
<a name="l01158"></a>01158     DEBUGDUMPHEADER(<span class="stringliteral">&quot;send&quot;</span>, <span class="stringliteral">&quot;msgAuthoritativeEngineTime&quot;</span>);
<a name="l01159"></a>01159     asn_build_int(&amp;ptr[offSet], &amp;remaining,
<a name="l01160"></a>01160                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
<a name="l01161"></a>01161                   &amp;time_long, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l01162"></a>01162     DEBUGINDENTLESS();
<a name="l01163"></a>01163 
<a name="l01164"></a>01164     offSet = ptr_len - remaining;
<a name="l01165"></a>01165     DEBUGDUMPHEADER(<span class="stringliteral">&quot;send&quot;</span>, <span class="stringliteral">&quot;msgUserName&quot;</span>);
<a name="l01166"></a>01166     asn_build_string(&amp;ptr[offSet], &amp;remaining,
<a name="l01167"></a>01167                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01168"></a>01168                                ASN_OCTET_STR), (u_char *) theName,
<a name="l01169"></a>01169                      theNameLength);
<a name="l01170"></a>01170     DEBUGINDENTLESS();
<a name="l01171"></a>01171 
<a name="l01172"></a>01172 
<a name="l01173"></a>01173     <span class="comment">/*</span>
<a name="l01174"></a>01174 <span class="comment">     * Note: if there is no authentication being done,</span>
<a name="l01175"></a>01175 <span class="comment">     * msgAuthParmLen is 0, and there is no effect (other than</span>
<a name="l01176"></a>01176 <span class="comment">     * inserting a zero-length header) of the following</span>
<a name="l01177"></a>01177 <span class="comment">     * statements.</span>
<a name="l01178"></a>01178 <span class="comment">     */</span>
<a name="l01179"></a>01179 
<a name="l01180"></a>01180     offSet = ptr_len - remaining;
<a name="l01181"></a>01181     asn_build_header(&amp;ptr[offSet],
<a name="l01182"></a>01182                      &amp;remaining,
<a name="l01183"></a>01183                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01184"></a>01184                                ASN_OCTET_STR), msgAuthParmLen);
<a name="l01185"></a>01185 
<a name="l01186"></a>01186     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
<a name="l01187"></a>01187         || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01188"></a>01188         offSet = ptr_len - remaining;
<a name="l01189"></a>01189         memset(&amp;ptr[offSet], 0, msgAuthParmLen);
<a name="l01190"></a>01190     }
<a name="l01191"></a>01191 
<a name="l01192"></a>01192     remaining -= msgAuthParmLen;
<a name="l01193"></a>01193 
<a name="l01194"></a>01194 
<a name="l01195"></a>01195     <span class="comment">/*</span>
<a name="l01196"></a>01196 <span class="comment">     * Note: if there is no encryption being done, msgPrivParmLen</span>
<a name="l01197"></a>01197 <span class="comment">     * is 0, and there is no effect (other than inserting a</span>
<a name="l01198"></a>01198 <span class="comment">     * zero-length header) of the following statements.</span>
<a name="l01199"></a>01199 <span class="comment">     */</span>
<a name="l01200"></a>01200 
<a name="l01201"></a>01201     offSet = ptr_len - remaining;
<a name="l01202"></a>01202     asn_build_header(&amp;ptr[offSet],
<a name="l01203"></a>01203                      &amp;remaining,
<a name="l01204"></a>01204                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01205"></a>01205                                ASN_OCTET_STR), msgPrivParmLen);
<a name="l01206"></a>01206 
<a name="l01207"></a>01207     remaining -= msgPrivParmLen;        <span class="comment">/* Skipping the IV already there. */</span>
<a name="l01208"></a>01208 
<a name="l01209"></a>01209 
<a name="l01210"></a>01210     <span class="comment">/*</span>
<a name="l01211"></a>01211 <span class="comment">     * For privacy, need to add the octet string header for it.</span>
<a name="l01212"></a>01212 <span class="comment">     */</span>
<a name="l01213"></a>01213     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01214"></a>01214         offSet = ptr_len - remaining;
<a name="l01215"></a>01215         asn_build_header(&amp;ptr[offSet],
<a name="l01216"></a>01216                          &amp;remaining,
<a name="l01217"></a>01217                          (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01218"></a>01218                                    ASN_OCTET_STR),
<a name="l01219"></a>01219                          theTotalLength - dataOffset);
<a name="l01220"></a>01220     }
<a name="l01221"></a>01221 
<a name="l01222"></a>01222 
<a name="l01223"></a>01223     <span class="comment">/*</span>
<a name="l01224"></a>01224 <span class="comment">     * Adjust overall length and store it as the first SEQ length</span>
<a name="l01225"></a>01225 <span class="comment">     * of the SNMPv3Message.</span>
<a name="l01226"></a>01226 <span class="comment">     *</span>
<a name="l01227"></a>01227 <span class="comment">     * FIX  4 is a magic number!</span>
<a name="l01228"></a>01228 <span class="comment">     */</span>
<a name="l01229"></a>01229     remaining = theTotalLength;
<a name="l01230"></a>01230     asn_build_sequence(ptr, &amp;remaining,
<a name="l01231"></a>01231                        (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
<a name="l01232"></a>01232                        theTotalLength - 4);
<a name="l01233"></a>01233 
<a name="l01234"></a>01234 
<a name="l01235"></a>01235     <span class="comment">/*</span>
<a name="l01236"></a>01236 <span class="comment">     * Now, time to consider / do authentication.</span>
<a name="l01237"></a>01237 <span class="comment">     */</span>
<a name="l01238"></a>01238     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
<a name="l01239"></a>01239         || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01240"></a>01240         <span class="keywordtype">size_t</span>          temp_sig_len = msgAuthParmLen;
<a name="l01241"></a>01241         u_char         *temp_sig = (u_char *) malloc(temp_sig_len);
<a name="l01242"></a>01242 
<a name="l01243"></a>01243         <span class="keywordflow">if</span> (temp_sig == NULL) {
<a name="l01244"></a>01244             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Out of memory.\n&quot;</span>));
<a name="l01245"></a>01245             usm_free_usmStateReference(secStateRef);
<a name="l01246"></a>01246             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01247"></a>01247         }
<a name="l01248"></a>01248 
<a name="l01249"></a>01249         <span class="keywordflow">if</span> (sc_generate_keyed_hash(theAuthProtocol, theAuthProtocolLength,
<a name="l01250"></a>01250                                    theAuthKey, theAuthKeyLength,
<a name="l01251"></a>01251                                    ptr, ptr_len, temp_sig, &amp;temp_sig_len)
<a name="l01252"></a>01252             != SNMP_ERR_NOERROR) {
<a name="l01253"></a>01253             <span class="comment">/*</span>
<a name="l01254"></a>01254 <span class="comment">             * FIX temp_sig_len defined?!</span>
<a name="l01255"></a>01255 <span class="comment">             */</span>
<a name="l01256"></a>01256             <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title="Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(temp_sig, temp_sig_len);
<a name="l01257"></a>01257             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(temp_sig);
<a name="l01258"></a>01258             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Signing failed.\n&quot;</span>));
<a name="l01259"></a>01259             usm_free_usmStateReference(secStateRef);
<a name="l01260"></a>01260             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
<a name="l01261"></a>01261         }
<a name="l01262"></a>01262 
<a name="l01263"></a>01263         <span class="keywordflow">if</span> (temp_sig_len != msgAuthParmLen) {
<a name="l01264"></a>01264             <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title="Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(temp_sig, temp_sig_len);
<a name="l01265"></a>01265             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(temp_sig);
<a name="l01266"></a>01266             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Signing lengths failed.\n&quot;</span>));
<a name="l01267"></a>01267             usm_free_usmStateReference(secStateRef);
<a name="l01268"></a>01268             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
<a name="l01269"></a>01269         }
<a name="l01270"></a>01270 
<a name="l01271"></a>01271         memcpy(&amp;ptr[authParamsOffset], temp_sig, msgAuthParmLen);
<a name="l01272"></a>01272 
<a name="l01273"></a>01273         <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title="Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(temp_sig, temp_sig_len);
<a name="l01274"></a>01274         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(temp_sig);
<a name="l01275"></a>01275 
<a name="l01276"></a>01276     }
<a name="l01277"></a>01277 
<a name="l01278"></a>01278     <span class="comment">/*</span>
<a name="l01279"></a>01279 <span class="comment">     * endif -- create keyed hash </span>
<a name="l01280"></a>01280 <span class="comment">     */</span>
<a name="l01281"></a>01281     usm_free_usmStateReference(secStateRef);
<a name="l01282"></a>01282 
<a name="l01283"></a>01283     DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;USM processing completed.\n&quot;</span>));
<a name="l01284"></a>01284 
<a name="l01285"></a>01285     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l01286"></a>01286 
<a name="l01287"></a>01287 }                               <span class="comment">/* end usm_generate_out_msg() */</span>
<a name="l01288"></a>01288 
<a name="l01289"></a>01289 <span class="preprocessor">#ifdef NETSNMP_USE_REVERSE_ASNENCODING</span>
<a name="l01290"></a>01290 <span class="preprocessor"></span><span class="keywordtype">int</span>
<a name="l01291"></a>01291 usm_secmod_rgenerate_out_msg(<span class="keyword">struct</span> <a class="code" href="structsnmp__secmod__outgoing__params.html">snmp_secmod_outgoing_params</a> *parms)
<a name="l01292"></a>01292 {
<a name="l01293"></a>01293     <span class="keywordflow">if</span> (!parms)
<a name="l01294"></a>01294         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l01295"></a>01295 
<a name="l01296"></a>01296     <span class="keywordflow">return</span> usm_rgenerate_out_msg(parms-&gt;msgProcModel,
<a name="l01297"></a>01297                                  parms-&gt;globalData, parms-&gt;globalDataLen,
<a name="l01298"></a>01298                                  parms-&gt;maxMsgSize, parms-&gt;secModel,
<a name="l01299"></a>01299                                  parms-&gt;secEngineID, parms-&gt;secEngineIDLen,
<a name="l01300"></a>01300                                  parms-&gt;secName, parms-&gt;secNameLen,
<a name="l01301"></a>01301                                  parms-&gt;secLevel,
<a name="l01302"></a>01302                                  parms-&gt;scopedPdu, parms-&gt;scopedPduLen,
<a name="l01303"></a>01303                                  parms-&gt;secStateRef,
<a name="l01304"></a>01304                                  parms-&gt;wholeMsg, parms-&gt;wholeMsgLen,
<a name="l01305"></a>01305                                  parms-&gt;wholeMsgOffset);
<a name="l01306"></a>01306 }
<a name="l01307"></a>01307 
<a name="l01308"></a>01308 <span class="keywordtype">int</span>
<a name="l01309"></a>01309 usm_rgenerate_out_msg(<span class="keywordtype">int</span> msgProcModel, <span class="comment">/* (UNUSED) */</span>
<a name="l01310"></a>01310                       u_char * globalData,      <span class="comment">/* IN */</span>
<a name="l01311"></a>01311                       <span class="comment">/*</span>
<a name="l01312"></a>01312 <span class="comment">                       * points at the msgGlobalData, which is of length given by next </span>
<a name="l01313"></a>01313 <span class="comment">                       * parameter.  </span>
<a name="l01314"></a>01314 <span class="comment">                       */</span>
<a name="l01315"></a>01315                       <span class="keywordtype">size_t</span> globalDataLen,     <span class="comment">/* IN - Length of msg header data.      */</span>
<a name="l01316"></a>01316                       <span class="keywordtype">int</span> maxMsgSize,   <span class="comment">/* (UNUSED) */</span>
<a name="l01317"></a>01317                       <span class="keywordtype">int</span> secModel,     <span class="comment">/* (UNUSED) */</span>
<a name="l01318"></a>01318                       u_char * secEngineID,     <span class="comment">/* IN - Pointer snmpEngineID.           */</span>
<a name="l01319"></a>01319                       <span class="keywordtype">size_t</span> secEngineIDLen,    <span class="comment">/* IN - SnmpEngineID length.            */</span>
<a name="l01320"></a>01320                       <span class="keywordtype">char</span> *secName,    <span class="comment">/* IN - Pointer to securityName.        */</span>
<a name="l01321"></a>01321                       <span class="keywordtype">size_t</span> secNameLen,        <span class="comment">/* IN - SecurityName length.            */</span>
<a name="l01322"></a>01322                       <span class="keywordtype">int</span> secLevel,     <span class="comment">/* IN - AuthNoPriv, authPriv etc.       */</span>
<a name="l01323"></a>01323                       u_char * scopedPdu,       <span class="comment">/* IN */</span>
<a name="l01324"></a>01324                       <span class="comment">/*</span>
<a name="l01325"></a>01325 <span class="comment">                       * Pointer to scopedPdu will be encrypted by USM if needed</span>
<a name="l01326"></a>01326 <span class="comment">                       * * and written to packet buffer immediately following</span>
<a name="l01327"></a>01327 <span class="comment">                       * * securityParameters, entire msg will be authenticated by</span>
<a name="l01328"></a>01328 <span class="comment">                       * * USM if needed.</span>
<a name="l01329"></a>01329 <span class="comment">                       */</span>
<a name="l01330"></a>01330                       <span class="keywordtype">size_t</span> scopedPduLen,      <span class="comment">/* IN - scopedPdu length. */</span>
<a name="l01331"></a>01331                       <span class="keywordtype">void</span> *secStateRef,        <span class="comment">/* IN */</span>
<a name="l01332"></a>01332                       <span class="comment">/*</span>
<a name="l01333"></a>01333 <span class="comment">                       * secStateRef, pointer to cached info provided only for</span>
<a name="l01334"></a>01334 <span class="comment">                       * * Response, otherwise NULL.</span>
<a name="l01335"></a>01335 <span class="comment">                       */</span>
<a name="l01336"></a>01336                       u_char ** wholeMsg,       <span class="comment">/*  IN/OUT  */</span>
<a name="l01337"></a>01337                       <span class="comment">/*</span>
<a name="l01338"></a>01338 <span class="comment">                       * Points at the pointer to the packet buffer, which might get extended</span>
<a name="l01339"></a>01339 <span class="comment">                       * if necessary via realloc().  </span>
<a name="l01340"></a>01340 <span class="comment">                       */</span>
<a name="l01341"></a>01341                       <span class="keywordtype">size_t</span> * wholeMsgLen,     <span class="comment">/*  IN/OUT  */</span>
<a name="l01342"></a>01342                       <span class="comment">/*</span>
<a name="l01343"></a>01343 <span class="comment">                       * Length of the entire packet buffer, **not** the length of the</span>
<a name="l01344"></a>01344 <span class="comment">                       * packet.  </span>
<a name="l01345"></a>01345 <span class="comment">                       */</span>
<a name="l01346"></a>01346                       <span class="keywordtype">size_t</span> * offset   <span class="comment">/*  IN/OUT  */</span>
<a name="l01347"></a>01347                       <span class="comment">/*</span>
<a name="l01348"></a>01348 <span class="comment">                       * Offset from the end of the packet buffer to the start of the packet,</span>
<a name="l01349"></a>01349 <span class="comment">                       * also known as the packet length.  </span>
<a name="l01350"></a>01350 <span class="comment">                       */</span>
<a name="l01351"></a>01351     )
<a name="l01352"></a>01352 {
<a name="l01353"></a>01353     <span class="keywordtype">size_t</span>          msgAuthParmLen = 0;
<a name="l01354"></a>01354 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l01355"></a>01355 <span class="preprocessor"></span>    <span class="keywordtype">size_t</span>          theTotalLength;
<a name="l01356"></a>01356 <span class="preprocessor">#endif</span>
<a name="l01357"></a>01357 <span class="preprocessor"></span>
<a name="l01358"></a>01358     u_int           boots_uint;
<a name="l01359"></a>01359     u_int           time_uint;
<a name="l01360"></a>01360     <span class="keywordtype">long</span>            boots_long;
<a name="l01361"></a>01361     <span class="keywordtype">long</span>            time_long;
<a name="l01362"></a>01362 
<a name="l01363"></a>01363     <span class="comment">/*</span>
<a name="l01364"></a>01364 <span class="comment">     * Indirection because secStateRef values override parameters.</span>
<a name="l01365"></a>01365 <span class="comment">     * </span>
<a name="l01366"></a>01366 <span class="comment">     * None of these are to be free&#39;d - they are either pointing to</span>
<a name="l01367"></a>01367 <span class="comment">     * what&#39;s in the secStateRef or to something either in the</span>
<a name="l01368"></a>01368 <span class="comment">     * actual parameter list or the user list.</span>
<a name="l01369"></a>01369 <span class="comment">     */</span>
<a name="l01370"></a>01370 
<a name="l01371"></a>01371     <span class="keywordtype">char</span>           *theName = NULL;
<a name="l01372"></a>01372     u_int           theNameLength = 0;
<a name="l01373"></a>01373     u_char         *theEngineID = NULL;
<a name="l01374"></a>01374     u_int           theEngineIDLength = 0;
<a name="l01375"></a>01375     u_char         *theAuthKey = NULL;
<a name="l01376"></a>01376     u_int           theAuthKeyLength = 0;
<a name="l01377"></a>01377     <span class="keyword">const</span> oid      *theAuthProtocol = NULL;
<a name="l01378"></a>01378     u_int           theAuthProtocolLength = 0;
<a name="l01379"></a>01379     u_char         *thePrivKey = NULL;
<a name="l01380"></a>01380     u_int           thePrivKeyLength = 0;
<a name="l01381"></a>01381     <span class="keyword">const</span> oid      *thePrivProtocol = NULL;
<a name="l01382"></a>01382     u_int           thePrivProtocolLength = 0;
<a name="l01383"></a>01383     <span class="keywordtype">int</span>             theSecLevel = 0;    <span class="comment">/* No defined const for bad</span>
<a name="l01384"></a>01384 <span class="comment">                                         * value (other then err). */</span>
<a name="l01385"></a>01385     <span class="keywordtype">size_t</span>          salt_length = 0, save_salt_length = 0, save_salt_offset = 0;
<a name="l01386"></a>01386     u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];
<a name="l01387"></a>01387     u_char          authParams[USM_MAX_AUTHSIZE];
<a name="l01388"></a>01388     u_char          iv[BYTESIZE(USM_MAX_SALT_LENGTH)];
<a name="l01389"></a>01389     <span class="keywordtype">size_t</span>          sp_offset = 0, mac_offset = 0;
<a name="l01390"></a>01390     <span class="keywordtype">int</span>             rc = 0;
<a name="l01391"></a>01391 
<a name="l01392"></a>01392     DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;USM processing has begun (offset %d)\n&quot;</span>, (<span class="keywordtype">int</span>)*offset));
<a name="l01393"></a>01393 
<a name="l01394"></a>01394     <span class="keywordflow">if</span> (secStateRef != NULL) {
<a name="l01395"></a>01395         <span class="comment">/*</span>
<a name="l01396"></a>01396 <span class="comment">         * To hush the compiler for now.  XXX </span>
<a name="l01397"></a>01397 <span class="comment">         */</span>
<a name="l01398"></a>01398         <span class="keyword">struct </span><a class="code" href="structusmStateReference.html">usmStateReference</a> *ref
<a name="l01399"></a>01399             = (<span class="keyword">struct </span><a class="code" href="structusmStateReference.html">usmStateReference</a> *) secStateRef;
<a name="l01400"></a>01400 
<a name="l01401"></a>01401         theName = ref-&gt;usr_name;
<a name="l01402"></a>01402         theNameLength = ref-&gt;usr_name_length;
<a name="l01403"></a>01403         theEngineID = ref-&gt;usr_engine_id;
<a name="l01404"></a>01404         theEngineIDLength = ref-&gt;usr_engine_id_length;
<a name="l01405"></a>01405 
<a name="l01406"></a>01406         <span class="keywordflow">if</span> (!theEngineIDLength) {
<a name="l01407"></a>01407             theEngineID = secEngineID;
<a name="l01408"></a>01408             theEngineIDLength = secEngineIDLen;
<a name="l01409"></a>01409         }
<a name="l01410"></a>01410 
<a name="l01411"></a>01411         theAuthProtocol = ref-&gt;usr_auth_protocol;
<a name="l01412"></a>01412         theAuthProtocolLength = ref-&gt;usr_auth_protocol_length;
<a name="l01413"></a>01413         theAuthKey = ref-&gt;usr_auth_key;
<a name="l01414"></a>01414         theAuthKeyLength = ref-&gt;usr_auth_key_length;
<a name="l01415"></a>01415         thePrivProtocol = ref-&gt;usr_priv_protocol;
<a name="l01416"></a>01416         thePrivProtocolLength = ref-&gt;usr_priv_protocol_length;
<a name="l01417"></a>01417         thePrivKey = ref-&gt;usr_priv_key;
<a name="l01418"></a>01418         thePrivKeyLength = ref-&gt;usr_priv_key_length;
<a name="l01419"></a>01419         theSecLevel = ref-&gt;usr_sec_level;
<a name="l01420"></a>01420     }
<a name="l01421"></a>01421 
<a name="l01422"></a>01422     <span class="comment">/*</span>
<a name="l01423"></a>01423 <span class="comment">     * * Identify the user record.</span>
<a name="l01424"></a>01424 <span class="comment">     */</span>
<a name="l01425"></a>01425     <span class="keywordflow">else</span> {
<a name="l01426"></a>01426         <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *user;
<a name="l01427"></a>01427 
<a name="l01428"></a>01428         <span class="comment">/*</span>
<a name="l01429"></a>01429 <span class="comment">         * we do allow an unknown user name for</span>
<a name="l01430"></a>01430 <span class="comment">         * unauthenticated requests. </span>
<a name="l01431"></a>01431 <span class="comment">         */</span>
<a name="l01432"></a>01432         <span class="keywordflow">if</span> ((user = usm_get_user(secEngineID, secEngineIDLen, secName))
<a name="l01433"></a>01433             == NULL &amp;&amp; secLevel != SNMP_SEC_LEVEL_NOAUTH) {
<a name="l01434"></a>01434             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Unknown User\n&quot;</span>));
<a name="l01435"></a>01435             usm_free_usmStateReference(secStateRef);
<a name="l01436"></a>01436             <span class="keywordflow">return</span> SNMPERR_USM_UNKNOWNSECURITYNAME;
<a name="l01437"></a>01437         }
<a name="l01438"></a>01438 
<a name="l01439"></a>01439         theName = secName;
<a name="l01440"></a>01440         theNameLength = secNameLen;
<a name="l01441"></a>01441         theEngineID = secEngineID;
<a name="l01442"></a>01442         theSecLevel = secLevel;
<a name="l01443"></a>01443         theEngineIDLength = secEngineIDLen;
<a name="l01444"></a>01444         <span class="keywordflow">if</span> (user) {
<a name="l01445"></a>01445             theAuthProtocol = user-&gt;authProtocol;
<a name="l01446"></a>01446             theAuthProtocolLength = user-&gt;authProtocolLen;
<a name="l01447"></a>01447             theAuthKey = user-&gt;authKey;
<a name="l01448"></a>01448             theAuthKeyLength = user-&gt;authKeyLen;
<a name="l01449"></a>01449             thePrivProtocol = user-&gt;privProtocol;
<a name="l01450"></a>01450             thePrivProtocolLength = user-&gt;privProtocolLen;
<a name="l01451"></a>01451             thePrivKey = user-&gt;privKey;
<a name="l01452"></a>01452             thePrivKeyLength = user-&gt;privKeyLen;
<a name="l01453"></a>01453         } <span class="keywordflow">else</span> {
<a name="l01454"></a>01454             <span class="comment">/*</span>
<a name="l01455"></a>01455 <span class="comment">             * unknown users can not do authentication (obviously) </span>
<a name="l01456"></a>01456 <span class="comment">             */</span>
<a name="l01457"></a>01457             theAuthProtocol = usmNoAuthProtocol;
<a name="l01458"></a>01458             theAuthProtocolLength =
<a name="l01459"></a>01459                 <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class="keyword">sizeof</span>(oid);
<a name="l01460"></a>01460             theAuthKey = NULL;
<a name="l01461"></a>01461             theAuthKeyLength = 0;
<a name="l01462"></a>01462             thePrivProtocol = usmNoPrivProtocol;
<a name="l01463"></a>01463             thePrivProtocolLength =
<a name="l01464"></a>01464                 <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid);
<a name="l01465"></a>01465             thePrivKey = NULL;
<a name="l01466"></a>01466             thePrivKeyLength = 0;
<a name="l01467"></a>01467         }
<a name="l01468"></a>01468     }                           <span class="comment">/* endif -- secStateRef==NULL */</span>
<a name="l01469"></a>01469 
<a name="l01470"></a>01470 
<a name="l01471"></a>01471     <span class="comment">/*</span>
<a name="l01472"></a>01472 <span class="comment">     * From here to the end of the function, avoid reference to</span>
<a name="l01473"></a>01473 <span class="comment">     * secName, secEngineID, secLevel, and associated lengths.</span>
<a name="l01474"></a>01474 <span class="comment">     */</span>
<a name="l01475"></a>01475 
<a name="l01476"></a>01476 
<a name="l01477"></a>01477     <span class="comment">/*</span>
<a name="l01478"></a>01478 <span class="comment">     * Check to see if the user can use the requested sec services.</span>
<a name="l01479"></a>01479 <span class="comment">     */</span>
<a name="l01480"></a>01480     <span class="keywordflow">if</span> (usm_check_secLevel_vs_protocols(theSecLevel,
<a name="l01481"></a>01481                                         theAuthProtocol,
<a name="l01482"></a>01482                                         theAuthProtocolLength,
<a name="l01483"></a>01483                                         thePrivProtocol,
<a name="l01484"></a>01484                                         thePrivProtocolLength) == 1) {
<a name="l01485"></a>01485         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Unsupported Security Level or type (%d)\n&quot;</span>,
<a name="l01486"></a>01486                     theSecLevel));
<a name="l01487"></a>01487 
<a name="l01488"></a>01488         usm_free_usmStateReference(secStateRef);
<a name="l01489"></a>01489         <span class="keywordflow">return</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;
<a name="l01490"></a>01490     }
<a name="l01491"></a>01491 
<a name="l01492"></a>01492 
<a name="l01493"></a>01493     <span class="comment">/*</span>
<a name="l01494"></a>01494 <span class="comment">     * * Retrieve the engine information.</span>
<a name="l01495"></a>01495 <span class="comment">     * *</span>
<a name="l01496"></a>01496 <span class="comment">     * * XXX    No error is declared in the EoP when sending messages to</span>
<a name="l01497"></a>01497 <span class="comment">     * *        unknown engines, processing continues w/ boots/time == (0,0).</span>
<a name="l01498"></a>01498 <span class="comment">     */</span>
<a name="l01499"></a>01499     <span class="keywordflow">if</span> (get_enginetime(theEngineID, theEngineIDLength,
<a name="l01500"></a>01500                        &amp;boots_uint, &amp;time_uint, FALSE) == -1) {
<a name="l01501"></a>01501         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>, <span class="stringliteral">&quot;Failed to find engine data.&quot;</span>));
<a name="l01502"></a>01502     }
<a name="l01503"></a>01503 
<a name="l01504"></a>01504     boots_long = boots_uint;
<a name="l01505"></a>01505     time_long = time_uint;
<a name="l01506"></a>01506 
<a name="l01507"></a>01507     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01508"></a>01508         <span class="comment">/*</span>
<a name="l01509"></a>01509 <span class="comment">         * Initially assume that the ciphertext will end up the same size as</span>
<a name="l01510"></a>01510 <span class="comment">         * the plaintext plus some padding.  Really sc_encrypt ought to be able</span>
<a name="l01511"></a>01511 <span class="comment">         * to grow this for us, a la asn_realloc_rbuild_&lt;type&gt; functions, but</span>
<a name="l01512"></a>01512 <span class="comment">         * this will do for now.  </span>
<a name="l01513"></a>01513 <span class="comment">         */</span>
<a name="l01514"></a>01514         u_char         *ciphertext = NULL;
<a name="l01515"></a>01515         <span class="keywordtype">size_t</span>          ciphertextlen = scopedPduLen + 64;
<a name="l01516"></a>01516 
<a name="l01517"></a>01517         <span class="keywordflow">if</span> ((ciphertext = (u_char *) malloc(ciphertextlen)) == NULL) {
<a name="l01518"></a>01518             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>,
<a name="l01519"></a>01519                         <span class="stringliteral">&quot;couldn&#39;t malloc %d bytes for encrypted PDU\n&quot;</span>,
<a name="l01520"></a>01520                         (<span class="keywordtype">int</span>)ciphertextlen));
<a name="l01521"></a>01521             usm_free_usmStateReference(secStateRef);
<a name="l01522"></a>01522             <span class="keywordflow">return</span> SNMPERR_MALLOC;
<a name="l01523"></a>01523         }
<a name="l01524"></a>01524 
<a name="l01525"></a>01525         <span class="comment">/*</span>
<a name="l01526"></a>01526 <span class="comment">         * XXX Hardwired to seek into a 1DES private key!  </span>
<a name="l01527"></a>01527 <span class="comment">         */</span>
<a name="l01528"></a>01528 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l01529"></a>01529 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (ISTRANSFORM(thePrivProtocol, AESPriv)) {
<a name="l01530"></a>01530             salt_length = BYTESIZE(USM_AES_SALT_LENGTH);
<a name="l01531"></a>01531             save_salt_length = BYTESIZE(USM_AES_SALT_LENGTH)/2;
<a name="l01532"></a>01532             save_salt_offset = 0;
<a name="l01533"></a>01533             <span class="keywordflow">if</span> (!thePrivKey ||
<a name="l01534"></a>01534                 usm_set_aes_iv(salt, &amp;salt_length,
<a name="l01535"></a>01535                                htonl(boots_uint), htonl(time_uint),
<a name="l01536"></a>01536                                iv) == -1) {
<a name="l01537"></a>01537                 DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Can&#39;t set AES iv.\n&quot;</span>));
<a name="l01538"></a>01538                 usm_free_usmStateReference(secStateRef);
<a name="l01539"></a>01539                 <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(ciphertext);
<a name="l01540"></a>01540                 <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01541"></a>01541             }
<a name="l01542"></a>01542         } 
<a name="l01543"></a>01543 <span class="preprocessor">#endif</span>
<a name="l01544"></a>01544 <span class="preprocessor"></span><span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l01545"></a>01545 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (ISTRANSFORM(thePrivProtocol, DESPriv)) {
<a name="l01546"></a>01546             salt_length = BYTESIZE(USM_DES_SALT_LENGTH);
<a name="l01547"></a>01547             save_salt_length = BYTESIZE(USM_DES_SALT_LENGTH);
<a name="l01548"></a>01548             save_salt_offset = 0;
<a name="l01549"></a>01549             <span class="keywordflow">if</span> (!thePrivKey || (usm_set_salt(salt, &amp;salt_length,
<a name="l01550"></a>01550                                              thePrivKey + 8,
<a name="l01551"></a>01551                                              thePrivKeyLength - 8,
<a name="l01552"></a>01552                                              iv) == -1)) {
<a name="l01553"></a>01553                 DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Can&#39;t set DES-CBC salt.\n&quot;</span>));
<a name="l01554"></a>01554                 usm_free_usmStateReference(secStateRef);
<a name="l01555"></a>01555                 <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(ciphertext);
<a name="l01556"></a>01556                 <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01557"></a>01557             }
<a name="l01558"></a>01558         }
<a name="l01559"></a>01559 <span class="preprocessor">#endif</span>
<a name="l01560"></a>01560 <span class="preprocessor"></span><span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l01561"></a>01561 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (debug_is_token_registered(<span class="stringliteral">&quot;usm/dump&quot;</span>) == SNMPERR_SUCCESS) {
<a name="l01562"></a>01562             dump_chunk(<span class="stringliteral">&quot;usm/dump&quot;</span>, <span class="stringliteral">&quot;This data was encrypted:&quot;</span>,
<a name="l01563"></a>01563                        scopedPdu, scopedPduLen);
<a name="l01564"></a>01564         }
<a name="l01565"></a>01565 <span class="preprocessor">#endif</span>
<a name="l01566"></a>01566 <span class="preprocessor"></span>
<a name="l01567"></a>01567         <span class="keywordflow">if</span> (sc_encrypt(thePrivProtocol, thePrivProtocolLength,
<a name="l01568"></a>01568                        thePrivKey, thePrivKeyLength,
<a name="l01569"></a>01569                        salt, salt_length,
<a name="l01570"></a>01570                        scopedPdu, scopedPduLen,
<a name="l01571"></a>01571                        ciphertext, &amp;ciphertextlen) != SNMP_ERR_NOERROR) {
<a name="l01572"></a>01572             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;encryption error.\n&quot;</span>));
<a name="l01573"></a>01573             usm_free_usmStateReference(secStateRef);
<a name="l01574"></a>01574             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(ciphertext);
<a name="l01575"></a>01575             <span class="keywordflow">return</span> SNMPERR_USM_ENCRYPTIONERROR;
<a name="l01576"></a>01576         }
<a name="l01577"></a>01577 
<a name="l01578"></a>01578         <span class="comment">/*</span>
<a name="l01579"></a>01579 <span class="comment">         * Write the encrypted scopedPdu back into the packet buffer.  </span>
<a name="l01580"></a>01580 <span class="comment">         */</span>
<a name="l01581"></a>01581 
<a name="l01582"></a>01582 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l01583"></a>01583 <span class="preprocessor"></span>        theTotalLength = *wholeMsgLen;
<a name="l01584"></a>01584 <span class="preprocessor">#endif</span>
<a name="l01585"></a>01585 <span class="preprocessor"></span>        *offset = 0;
<a name="l01586"></a>01586         rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01587"></a>01587                                        (u_char) (ASN_UNIVERSAL |
<a name="l01588"></a>01588                                                  ASN_PRIMITIVE |
<a name="l01589"></a>01589                                                  ASN_OCTET_STR),
<a name="l01590"></a>01590                                        ciphertext, ciphertextlen);
<a name="l01591"></a>01591         <span class="keywordflow">if</span> (rc == 0) {
<a name="l01592"></a>01592             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Encryption failed.\n&quot;</span>));
<a name="l01593"></a>01593             usm_free_usmStateReference(secStateRef);
<a name="l01594"></a>01594             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(ciphertext);
<a name="l01595"></a>01595             <span class="keywordflow">return</span> SNMPERR_USM_ENCRYPTIONERROR;
<a name="l01596"></a>01596         }
<a name="l01597"></a>01597 
<a name="l01598"></a>01598 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l01599"></a>01599 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (debug_is_token_registered(<span class="stringliteral">&quot;usm/dump&quot;</span>) == SNMPERR_SUCCESS) {
<a name="l01600"></a>01600             dump_chunk(<span class="stringliteral">&quot;usm/dump&quot;</span>, <span class="stringliteral">&quot;salt + Encrypted form: &quot;</span>, salt,
<a name="l01601"></a>01601                        salt_length);
<a name="l01602"></a>01602             dump_chunk(<span class="stringliteral">&quot;usm/dump&quot;</span>, <span class="stringliteral">&quot;wholeMsg:&quot;</span>,
<a name="l01603"></a>01603                        (*wholeMsg + *wholeMsgLen - *offset), *offset);
<a name="l01604"></a>01604         }
<a name="l01605"></a>01605 <span class="preprocessor">#endif</span>
<a name="l01606"></a>01606 <span class="preprocessor"></span>
<a name="l01607"></a>01607         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Encryption successful.\n&quot;</span>));
<a name="l01608"></a>01608         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(ciphertext);
<a name="l01609"></a>01609     } <span class="keywordflow">else</span> {
<a name="l01610"></a>01610         <span class="comment">/*</span>
<a name="l01611"></a>01611 <span class="comment">         * theSecLevel != SNMP_SEC_LEVEL_AUTHPRIV  </span>
<a name="l01612"></a>01612 <span class="comment">         */</span>
<a name="l01613"></a>01613     }
<a name="l01614"></a>01614 
<a name="l01615"></a>01615     <span class="comment">/*</span>
<a name="l01616"></a>01616 <span class="comment">     * Start encoding the msgSecurityParameters.  </span>
<a name="l01617"></a>01617 <span class="comment">     */</span>
<a name="l01618"></a>01618 
<a name="l01619"></a>01619     sp_offset = *offset;
<a name="l01620"></a>01620 
<a name="l01621"></a>01621     DEBUGDUMPHEADER(<span class="stringliteral">&quot;send&quot;</span>, <span class="stringliteral">&quot;msgPrivacyParameters&quot;</span>);
<a name="l01622"></a>01622     <span class="comment">/*</span>
<a name="l01623"></a>01623 <span class="comment">     * msgPrivacyParameters (warning: assumes DES salt).  </span>
<a name="l01624"></a>01624 <span class="comment">     */</span>
<a name="l01625"></a>01625     rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01626"></a>01626                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
<a name="l01627"></a>01627                                              | ASN_OCTET_STR),
<a name="l01628"></a>01628                                    iv,
<a name="l01629"></a>01629                                    save_salt_length);
<a name="l01630"></a>01630     DEBUGINDENTLESS();
<a name="l01631"></a>01631     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01632"></a>01632         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;building privParams failed.\n&quot;</span>));
<a name="l01633"></a>01633         usm_free_usmStateReference(secStateRef);
<a name="l01634"></a>01634         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01635"></a>01635     }
<a name="l01636"></a>01636 
<a name="l01637"></a>01637     DEBUGDUMPHEADER(<span class="stringliteral">&quot;send&quot;</span>, <span class="stringliteral">&quot;msgAuthenticationParameters&quot;</span>);
<a name="l01638"></a>01638     <span class="comment">/*</span>
<a name="l01639"></a>01639 <span class="comment">     * msgAuthenticationParameters (warnings assumes 0x00 by 12).  </span>
<a name="l01640"></a>01640 <span class="comment">     */</span>
<a name="l01641"></a>01641     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
<a name="l01642"></a>01642         || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01643"></a>01643         memset(authParams, 0, USM_MD5_AND_SHA_AUTH_LEN);
<a name="l01644"></a>01644         msgAuthParmLen = USM_MD5_AND_SHA_AUTH_LEN;
<a name="l01645"></a>01645     }
<a name="l01646"></a>01646 
<a name="l01647"></a>01647     rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01648"></a>01648                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
<a name="l01649"></a>01649                                              | ASN_OCTET_STR), authParams,
<a name="l01650"></a>01650                                    msgAuthParmLen);
<a name="l01651"></a>01651     DEBUGINDENTLESS();
<a name="l01652"></a>01652     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01653"></a>01653         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;building authParams failed.\n&quot;</span>));
<a name="l01654"></a>01654         usm_free_usmStateReference(secStateRef);
<a name="l01655"></a>01655         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01656"></a>01656     }
<a name="l01657"></a>01657 
<a name="l01658"></a>01658     <span class="comment">/*</span>
<a name="l01659"></a>01659 <span class="comment">     * Remember where to put the actual HMAC we calculate later on.  An</span>
<a name="l01660"></a>01660 <span class="comment">     * encoded OCTET STRING of length USM_MD5_AND_SHA_AUTH_LEN has an ASN.1</span>
<a name="l01661"></a>01661 <span class="comment">     * header of length 2, hence the fudge factor.  </span>
<a name="l01662"></a>01662 <span class="comment">     */</span>
<a name="l01663"></a>01663 
<a name="l01664"></a>01664     mac_offset = *offset - 2;
<a name="l01665"></a>01665 
<a name="l01666"></a>01666     <span class="comment">/*</span>
<a name="l01667"></a>01667 <span class="comment">     * msgUserName.  </span>
<a name="l01668"></a>01668 <span class="comment">     */</span>
<a name="l01669"></a>01669     DEBUGDUMPHEADER(<span class="stringliteral">&quot;send&quot;</span>, <span class="stringliteral">&quot;msgUserName&quot;</span>);
<a name="l01670"></a>01670     rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01671"></a>01671                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
<a name="l01672"></a>01672                                              | ASN_OCTET_STR),
<a name="l01673"></a>01673                                    (u_char *) theName, theNameLength);
<a name="l01674"></a>01674     DEBUGINDENTLESS();
<a name="l01675"></a>01675     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01676"></a>01676         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;building authParams failed.\n&quot;</span>));
<a name="l01677"></a>01677         usm_free_usmStateReference(secStateRef);
<a name="l01678"></a>01678         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01679"></a>01679     }
<a name="l01680"></a>01680 
<a name="l01681"></a>01681     <span class="comment">/*</span>
<a name="l01682"></a>01682 <span class="comment">     * msgAuthoritativeEngineTime.  </span>
<a name="l01683"></a>01683 <span class="comment">     */</span>
<a name="l01684"></a>01684     DEBUGDUMPHEADER(<span class="stringliteral">&quot;send&quot;</span>, <span class="stringliteral">&quot;msgAuthoritativeEngineTime&quot;</span>);
<a name="l01685"></a>01685     rc = asn_realloc_rbuild_int(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01686"></a>01686                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01687"></a>01687                                           ASN_INTEGER), &amp;time_long,
<a name="l01688"></a>01688                                 <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l01689"></a>01689     DEBUGINDENTLESS();
<a name="l01690"></a>01690     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01691"></a>01691         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>,
<a name="l01692"></a>01692                     <span class="stringliteral">&quot;building msgAuthoritativeEngineTime failed.\n&quot;</span>));
<a name="l01693"></a>01693         usm_free_usmStateReference(secStateRef);
<a name="l01694"></a>01694         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01695"></a>01695     }
<a name="l01696"></a>01696 
<a name="l01697"></a>01697     <span class="comment">/*</span>
<a name="l01698"></a>01698 <span class="comment">     * msgAuthoritativeEngineBoots.  </span>
<a name="l01699"></a>01699 <span class="comment">     */</span>
<a name="l01700"></a>01700     DEBUGDUMPHEADER(<span class="stringliteral">&quot;send&quot;</span>, <span class="stringliteral">&quot;msgAuthoritativeEngineBoots&quot;</span>);
<a name="l01701"></a>01701     rc = asn_realloc_rbuild_int(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01702"></a>01702                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01703"></a>01703                                           ASN_INTEGER), &amp;boots_long,
<a name="l01704"></a>01704                                 <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l01705"></a>01705     DEBUGINDENTLESS();
<a name="l01706"></a>01706     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01707"></a>01707         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>,
<a name="l01708"></a>01708                     <span class="stringliteral">&quot;building msgAuthoritativeEngineBoots failed.\n&quot;</span>));
<a name="l01709"></a>01709         usm_free_usmStateReference(secStateRef);
<a name="l01710"></a>01710         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01711"></a>01711     }
<a name="l01712"></a>01712 
<a name="l01713"></a>01713     DEBUGDUMPHEADER(<span class="stringliteral">&quot;send&quot;</span>, <span class="stringliteral">&quot;msgAuthoritativeEngineID&quot;</span>);
<a name="l01714"></a>01714     rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01715"></a>01715                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
<a name="l01716"></a>01716                                              | ASN_OCTET_STR), theEngineID,
<a name="l01717"></a>01717                                    theEngineIDLength);
<a name="l01718"></a>01718     DEBUGINDENTLESS();
<a name="l01719"></a>01719     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01720"></a>01720         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;building msgAuthoritativeEngineID failed.\n&quot;</span>));
<a name="l01721"></a>01721         usm_free_usmStateReference(secStateRef);
<a name="l01722"></a>01722         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01723"></a>01723     }
<a name="l01724"></a>01724 
<a name="l01725"></a>01725     <span class="comment">/*</span>
<a name="l01726"></a>01726 <span class="comment">     * USM msgSecurityParameters sequence header  </span>
<a name="l01727"></a>01727 <span class="comment">     */</span>
<a name="l01728"></a>01728     rc = asn_realloc_rbuild_sequence(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01729"></a>01729                                      (u_char) (ASN_SEQUENCE |
<a name="l01730"></a>01730                                                ASN_CONSTRUCTOR),
<a name="l01731"></a>01731                                      *offset - sp_offset);
<a name="l01732"></a>01732     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01733"></a>01733         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;building usm security parameters failed.\n&quot;</span>));
<a name="l01734"></a>01734         usm_free_usmStateReference(secStateRef);
<a name="l01735"></a>01735         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01736"></a>01736     }
<a name="l01737"></a>01737 
<a name="l01738"></a>01738     <span class="comment">/*</span>
<a name="l01739"></a>01739 <span class="comment">     * msgSecurityParameters OCTET STRING wrapper.  </span>
<a name="l01740"></a>01740 <span class="comment">     */</span>
<a name="l01741"></a>01741     rc = asn_realloc_rbuild_header(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01742"></a>01742                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
<a name="l01743"></a>01743                                              | ASN_OCTET_STR),
<a name="l01744"></a>01744                                    *offset - sp_offset);
<a name="l01745"></a>01745 
<a name="l01746"></a>01746     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01747"></a>01747         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;building msgSecurityParameters failed.\n&quot;</span>));
<a name="l01748"></a>01748         usm_free_usmStateReference(secStateRef);
<a name="l01749"></a>01749         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01750"></a>01750     }
<a name="l01751"></a>01751 
<a name="l01752"></a>01752     <span class="comment">/*</span>
<a name="l01753"></a>01753 <span class="comment">     * Copy in the msgGlobalData and msgVersion.  </span>
<a name="l01754"></a>01754 <span class="comment">     */</span>
<a name="l01755"></a>01755     <span class="keywordflow">while</span> ((*wholeMsgLen - *offset) &lt; globalDataLen) {
<a name="l01756"></a>01756         <span class="keywordflow">if</span> (!asn_realloc(wholeMsg, wholeMsgLen)) {
<a name="l01757"></a>01757             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;building global data failed.\n&quot;</span>));
<a name="l01758"></a>01758             usm_free_usmStateReference(secStateRef);
<a name="l01759"></a>01759             <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01760"></a>01760         }
<a name="l01761"></a>01761     }
<a name="l01762"></a>01762 
<a name="l01763"></a>01763     *offset += globalDataLen;
<a name="l01764"></a>01764     memcpy(*wholeMsg + *wholeMsgLen - *offset, globalData, globalDataLen);
<a name="l01765"></a>01765 
<a name="l01766"></a>01766     <span class="comment">/*</span>
<a name="l01767"></a>01767 <span class="comment">     * Total packet sequence.  </span>
<a name="l01768"></a>01768 <span class="comment">     */</span>
<a name="l01769"></a>01769     rc = asn_realloc_rbuild_sequence(wholeMsg, wholeMsgLen, offset, 1,
<a name="l01770"></a>01770                                      (u_char) (ASN_SEQUENCE |
<a name="l01771"></a>01771                                                ASN_CONSTRUCTOR), *offset);
<a name="l01772"></a>01772     <span class="keywordflow">if</span> (rc == 0) {
<a name="l01773"></a>01773         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;building master packet sequence failed.\n&quot;</span>));
<a name="l01774"></a>01774         usm_free_usmStateReference(secStateRef);
<a name="l01775"></a>01775         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
<a name="l01776"></a>01776     }
<a name="l01777"></a>01777 
<a name="l01778"></a>01778     <span class="comment">/*</span>
<a name="l01779"></a>01779 <span class="comment">     * Now consider / do authentication.  </span>
<a name="l01780"></a>01780 <span class="comment">     */</span>
<a name="l01781"></a>01781 
<a name="l01782"></a>01782     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV ||
<a name="l01783"></a>01783         theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l01784"></a>01784         <span class="keywordtype">size_t</span>          temp_sig_len = msgAuthParmLen;
<a name="l01785"></a>01785         u_char         *temp_sig = (u_char *) malloc(temp_sig_len);
<a name="l01786"></a>01786         u_char         *proto_msg = *wholeMsg + *wholeMsgLen - *offset;
<a name="l01787"></a>01787         <span class="keywordtype">size_t</span>          proto_msg_len = *offset;
<a name="l01788"></a>01788 
<a name="l01789"></a>01789 
<a name="l01790"></a>01790         <span class="keywordflow">if</span> (temp_sig == NULL) {
<a name="l01791"></a>01791             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Out of memory.\n&quot;</span>));
<a name="l01792"></a>01792             usm_free_usmStateReference(secStateRef);
<a name="l01793"></a>01793             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l01794"></a>01794         }
<a name="l01795"></a>01795 
<a name="l01796"></a>01796         <span class="keywordflow">if</span> (sc_generate_keyed_hash(theAuthProtocol, theAuthProtocolLength,
<a name="l01797"></a>01797                                    theAuthKey, theAuthKeyLength,
<a name="l01798"></a>01798                                    proto_msg, proto_msg_len,
<a name="l01799"></a>01799                                    temp_sig, &amp;temp_sig_len)
<a name="l01800"></a>01800             != SNMP_ERR_NOERROR) {
<a name="l01801"></a>01801             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(temp_sig);
<a name="l01802"></a>01802             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Signing failed.\n&quot;</span>));
<a name="l01803"></a>01803             usm_free_usmStateReference(secStateRef);
<a name="l01804"></a>01804             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
<a name="l01805"></a>01805         }
<a name="l01806"></a>01806 
<a name="l01807"></a>01807         <span class="keywordflow">if</span> (temp_sig_len != msgAuthParmLen) {
<a name="l01808"></a>01808             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(temp_sig);
<a name="l01809"></a>01809             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Signing lengths failed.\n&quot;</span>));
<a name="l01810"></a>01810             usm_free_usmStateReference(secStateRef);
<a name="l01811"></a>01811             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
<a name="l01812"></a>01812         }
<a name="l01813"></a>01813 
<a name="l01814"></a>01814         memcpy(*wholeMsg + *wholeMsgLen - mac_offset, temp_sig,
<a name="l01815"></a>01815                msgAuthParmLen);
<a name="l01816"></a>01816         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(temp_sig);
<a name="l01817"></a>01817     }
<a name="l01818"></a>01818     <span class="comment">/*</span>
<a name="l01819"></a>01819 <span class="comment">     * endif -- create keyed hash </span>
<a name="l01820"></a>01820 <span class="comment">     */</span>
<a name="l01821"></a>01821     usm_free_usmStateReference(secStateRef);
<a name="l01822"></a>01822     DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;USM processing completed.\n&quot;</span>));
<a name="l01823"></a>01823     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l01824"></a>01824 }                               <span class="comment">/* end usm_rgenerate_out_msg() */</span>
<a name="l01825"></a>01825 
<a name="l01826"></a>01826 <span class="preprocessor">#endif                          </span><span class="comment">/* */</span>
<a name="l01827"></a>01827 
<a name="l01828"></a>01828 
<a name="l01829"></a>01829 
<a name="l01830"></a>01830 <span class="comment">/*******************************************************************-o-******</span>
<a name="l01831"></a>01831 <span class="comment"> * usm_parse_security_parameters</span>
<a name="l01832"></a>01832 <span class="comment"> *</span>
<a name="l01833"></a>01833 <span class="comment"> * Parameters:</span>
<a name="l01834"></a>01834 <span class="comment"> *      (See list below...)</span>
<a name="l01835"></a>01835 <span class="comment"> *      </span>
<a name="l01836"></a>01836 <span class="comment"> * Returns:</span>
<a name="l01837"></a>01837 <span class="comment"> *      0       On success,</span>
<a name="l01838"></a>01838 <span class="comment"> *      -1      Otherwise.</span>
<a name="l01839"></a>01839 <span class="comment"> *</span>
<a name="l01840"></a>01840 <span class="comment"> *      tab stop 4</span>
<a name="l01841"></a>01841 <span class="comment"> *</span>
<a name="l01842"></a>01842 <span class="comment"> *      Extracts values from the security header and data portions of the</span>
<a name="l01843"></a>01843 <span class="comment"> *      incoming buffer.</span>
<a name="l01844"></a>01844 <span class="comment"> */</span>
<a name="l01845"></a>01845 <span class="keywordtype">int</span>
<a name="l01846"></a>01846 usm_parse_security_parameters(u_char * secParams,
<a name="l01847"></a>01847                               <span class="keywordtype">size_t</span> remaining,
<a name="l01848"></a>01848                               u_char * secEngineID,
<a name="l01849"></a>01849                               <span class="keywordtype">size_t</span> * secEngineIDLen,
<a name="l01850"></a>01850                               u_int * boots_uint,
<a name="l01851"></a>01851                               u_int * time_uint,
<a name="l01852"></a>01852                               <span class="keywordtype">char</span> *secName,
<a name="l01853"></a>01853                               <span class="keywordtype">size_t</span> * secNameLen,
<a name="l01854"></a>01854                               u_char * signature,
<a name="l01855"></a>01855                               <span class="keywordtype">size_t</span> * signature_length,
<a name="l01856"></a>01856                               u_char * salt,
<a name="l01857"></a>01857                               <span class="keywordtype">size_t</span> * salt_length, u_char ** data_ptr)
<a name="l01858"></a>01858 {
<a name="l01859"></a>01859     u_char         *parse_ptr = secParams;
<a name="l01860"></a>01860     u_char         *value_ptr;
<a name="l01861"></a>01861     u_char         *next_ptr;
<a name="l01862"></a>01862     u_char          type_value;
<a name="l01863"></a>01863 
<a name="l01864"></a>01864     <span class="keywordtype">size_t</span>          octet_string_length = remaining;
<a name="l01865"></a>01865     <span class="keywordtype">size_t</span>          sequence_length;
<a name="l01866"></a>01866     <span class="keywordtype">size_t</span>          remaining_bytes;
<a name="l01867"></a>01867 
<a name="l01868"></a>01868     <span class="keywordtype">long</span>            boots_long;
<a name="l01869"></a>01869     <span class="keywordtype">long</span>            time_long;
<a name="l01870"></a>01870 
<a name="l01871"></a>01871     u_int           origNameLen;
<a name="l01872"></a>01872 
<a name="l01873"></a>01873 
<a name="l01874"></a>01874     <span class="comment">/*</span>
<a name="l01875"></a>01875 <span class="comment">     * Eat the first octet header.</span>
<a name="l01876"></a>01876 <span class="comment">     */</span>
<a name="l01877"></a>01877     <span class="keywordflow">if</span> ((value_ptr = asn_parse_sequence(parse_ptr, &amp;octet_string_length,
<a name="l01878"></a>01878                                         &amp;type_value,
<a name="l01879"></a>01879                                         (ASN_UNIVERSAL | ASN_PRIMITIVE |
<a name="l01880"></a>01880                                          ASN_OCTET_STR),
<a name="l01881"></a>01881                                         <span class="stringliteral">&quot;usm first octet&quot;</span>)) == NULL) {
<a name="l01882"></a>01882         <span class="comment">/*</span>
<a name="l01883"></a>01883 <span class="comment">         * RETURN parse error </span>
<a name="l01884"></a>01884 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01885"></a>01885     }
<a name="l01886"></a>01886 
<a name="l01887"></a>01887 
<a name="l01888"></a>01888     <span class="comment">/*</span>
<a name="l01889"></a>01889 <span class="comment">     * Eat the sequence header.</span>
<a name="l01890"></a>01890 <span class="comment">     */</span>
<a name="l01891"></a>01891     parse_ptr = value_ptr;
<a name="l01892"></a>01892     sequence_length = octet_string_length;
<a name="l01893"></a>01893 
<a name="l01894"></a>01894     <span class="keywordflow">if</span> ((value_ptr = asn_parse_sequence(parse_ptr, &amp;sequence_length,
<a name="l01895"></a>01895                                         &amp;type_value,
<a name="l01896"></a>01896                                         (ASN_SEQUENCE | ASN_CONSTRUCTOR),
<a name="l01897"></a>01897                                         <span class="stringliteral">&quot;usm sequence&quot;</span>)) == NULL) {
<a name="l01898"></a>01898         <span class="comment">/*</span>
<a name="l01899"></a>01899 <span class="comment">         * RETURN parse error </span>
<a name="l01900"></a>01900 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01901"></a>01901     }
<a name="l01902"></a>01902 
<a name="l01903"></a>01903 
<a name="l01904"></a>01904     <span class="comment">/*</span>
<a name="l01905"></a>01905 <span class="comment">     * Retrieve the engineID.</span>
<a name="l01906"></a>01906 <span class="comment">     */</span>
<a name="l01907"></a>01907     parse_ptr = value_ptr;
<a name="l01908"></a>01908     remaining_bytes = sequence_length;
<a name="l01909"></a>01909 
<a name="l01910"></a>01910     DEBUGDUMPHEADER(<span class="stringliteral">&quot;recv&quot;</span>, <span class="stringliteral">&quot;msgAuthoritativeEngineID&quot;</span>);
<a name="l01911"></a>01911     <span class="keywordflow">if</span> ((next_ptr
<a name="l01912"></a>01912          = asn_parse_string(parse_ptr, &amp;remaining_bytes, &amp;type_value,
<a name="l01913"></a>01913                             secEngineID, secEngineIDLen)) == NULL) {
<a name="l01914"></a>01914         DEBUGINDENTLESS();
<a name="l01915"></a>01915         <span class="comment">/*</span>
<a name="l01916"></a>01916 <span class="comment">         * RETURN parse error </span>
<a name="l01917"></a>01917 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01918"></a>01918     }
<a name="l01919"></a>01919     DEBUGINDENTLESS();
<a name="l01920"></a>01920 
<a name="l01921"></a>01921     <span class="keywordflow">if</span> (type_value !=
<a name="l01922"></a>01922         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {
<a name="l01923"></a>01923         <span class="comment">/*</span>
<a name="l01924"></a>01924 <span class="comment">         * RETURN parse error </span>
<a name="l01925"></a>01925 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01926"></a>01926     }
<a name="l01927"></a>01927 
<a name="l01928"></a>01928 
<a name="l01929"></a>01929     <span class="comment">/*</span>
<a name="l01930"></a>01930 <span class="comment">     * Retrieve the engine boots, notice switch in the way next_ptr and</span>
<a name="l01931"></a>01931 <span class="comment">     * remaining_bytes are used (to accomodate the asn code).</span>
<a name="l01932"></a>01932 <span class="comment">     */</span>
<a name="l01933"></a>01933     DEBUGDUMPHEADER(<span class="stringliteral">&quot;recv&quot;</span>, <span class="stringliteral">&quot;msgAuthoritativeEngineBoots&quot;</span>);
<a name="l01934"></a>01934     <span class="keywordflow">if</span> ((next_ptr = asn_parse_int(next_ptr, &amp;remaining_bytes, &amp;type_value,
<a name="l01935"></a>01935                                   &amp;boots_long, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>))) == NULL) {
<a name="l01936"></a>01936         DEBUGINDENTLESS();
<a name="l01937"></a>01937         <span class="comment">/*</span>
<a name="l01938"></a>01938 <span class="comment">         * RETURN parse error </span>
<a name="l01939"></a>01939 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01940"></a>01940     }
<a name="l01941"></a>01941     DEBUGINDENTLESS();
<a name="l01942"></a>01942 
<a name="l01943"></a>01943     <span class="keywordflow">if</span> (type_value !=
<a name="l01944"></a>01944         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER)) {
<a name="l01945"></a>01945         DEBUGINDENTLESS();
<a name="l01946"></a>01946         <span class="comment">/*</span>
<a name="l01947"></a>01947 <span class="comment">         * RETURN parse error </span>
<a name="l01948"></a>01948 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01949"></a>01949     }
<a name="l01950"></a>01950 
<a name="l01951"></a>01951     *boots_uint = (u_int) boots_long;
<a name="l01952"></a>01952 
<a name="l01953"></a>01953 
<a name="l01954"></a>01954     <span class="comment">/*</span>
<a name="l01955"></a>01955 <span class="comment">     * Retrieve the time value.</span>
<a name="l01956"></a>01956 <span class="comment">     */</span>
<a name="l01957"></a>01957     DEBUGDUMPHEADER(<span class="stringliteral">&quot;recv&quot;</span>, <span class="stringliteral">&quot;msgAuthoritativeEngineTime&quot;</span>);
<a name="l01958"></a>01958     <span class="keywordflow">if</span> ((next_ptr = asn_parse_int(next_ptr, &amp;remaining_bytes, &amp;type_value,
<a name="l01959"></a>01959                                   &amp;time_long, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>))) == NULL) {
<a name="l01960"></a>01960         <span class="comment">/*</span>
<a name="l01961"></a>01961 <span class="comment">         * RETURN parse error </span>
<a name="l01962"></a>01962 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01963"></a>01963     }
<a name="l01964"></a>01964     DEBUGINDENTLESS();
<a name="l01965"></a>01965 
<a name="l01966"></a>01966     <span class="keywordflow">if</span> (type_value !=
<a name="l01967"></a>01967         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER)) {
<a name="l01968"></a>01968         <span class="comment">/*</span>
<a name="l01969"></a>01969 <span class="comment">         * RETURN parse error </span>
<a name="l01970"></a>01970 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01971"></a>01971     }
<a name="l01972"></a>01972 
<a name="l01973"></a>01973     *time_uint = (u_int) time_long;
<a name="l01974"></a>01974 
<a name="l01975"></a>01975     <span class="keywordflow">if</span> (*boots_uint &gt; ENGINEBOOT_MAX || *time_uint &gt; ENGINETIME_MAX) {
<a name="l01976"></a>01976         <span class="keywordflow">return</span> -1;
<a name="l01977"></a>01977     }
<a name="l01978"></a>01978 
<a name="l01979"></a>01979     <span class="comment">/*</span>
<a name="l01980"></a>01980 <span class="comment">     * Retrieve the secName.</span>
<a name="l01981"></a>01981 <span class="comment">     */</span>
<a name="l01982"></a>01982     origNameLen = *secNameLen;
<a name="l01983"></a>01983 
<a name="l01984"></a>01984 
<a name="l01985"></a>01985     DEBUGDUMPHEADER(<span class="stringliteral">&quot;recv&quot;</span>, <span class="stringliteral">&quot;msgUserName&quot;</span>);
<a name="l01986"></a>01986     <span class="keywordflow">if</span> ((next_ptr
<a name="l01987"></a>01987          = asn_parse_string(next_ptr, &amp;remaining_bytes, &amp;type_value,
<a name="l01988"></a>01988                             (u_char *) secName, secNameLen)) == NULL) {
<a name="l01989"></a>01989         DEBUGINDENTLESS();
<a name="l01990"></a>01990         <span class="comment">/*</span>
<a name="l01991"></a>01991 <span class="comment">         * RETURN parse error </span>
<a name="l01992"></a>01992 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l01993"></a>01993     }
<a name="l01994"></a>01994     DEBUGINDENTLESS();
<a name="l01995"></a>01995 
<a name="l01996"></a>01996     <span class="comment">/*</span>
<a name="l01997"></a>01997 <span class="comment">     * FIX -- doesn&#39;t this also indicate a buffer overrun?</span>
<a name="l01998"></a>01998 <span class="comment">     */</span>
<a name="l01999"></a>01999     <span class="keywordflow">if</span> (origNameLen &lt; *secNameLen + 1) {
<a name="l02000"></a>02000         <span class="comment">/*</span>
<a name="l02001"></a>02001 <span class="comment">         * RETURN parse error, but it&#39;s really a parameter error </span>
<a name="l02002"></a>02002 <span class="comment">         */</span>
<a name="l02003"></a>02003         <span class="keywordflow">return</span> -1;
<a name="l02004"></a>02004     }
<a name="l02005"></a>02005 
<a name="l02006"></a>02006     <span class="keywordflow">if</span> (*secNameLen &gt; 32) {
<a name="l02007"></a>02007         <span class="comment">/*</span>
<a name="l02008"></a>02008 <span class="comment">         * This is a USM-specific limitation over and above the above</span>
<a name="l02009"></a>02009 <span class="comment">         * limitation (which will probably default to the length of an</span>
<a name="l02010"></a>02010 <span class="comment">         * SnmpAdminString, i.e. 255).  See RFC 2574, sec. 2.4.  </span>
<a name="l02011"></a>02011 <span class="comment">         */</span>
<a name="l02012"></a>02012         <span class="keywordflow">return</span> -1;
<a name="l02013"></a>02013     }
<a name="l02014"></a>02014 
<a name="l02015"></a>02015     secName[*secNameLen] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02016"></a>02016 
<a name="l02017"></a>02017     <span class="keywordflow">if</span> (type_value !=
<a name="l02018"></a>02018         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {
<a name="l02019"></a>02019         <span class="comment">/*</span>
<a name="l02020"></a>02020 <span class="comment">         * RETURN parse error </span>
<a name="l02021"></a>02021 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l02022"></a>02022     }
<a name="l02023"></a>02023 
<a name="l02024"></a>02024 
<a name="l02025"></a>02025     <span class="comment">/*</span>
<a name="l02026"></a>02026 <span class="comment">     * Retrieve the signature and blank it if there.</span>
<a name="l02027"></a>02027 <span class="comment">     */</span>
<a name="l02028"></a>02028     DEBUGDUMPHEADER(<span class="stringliteral">&quot;recv&quot;</span>, <span class="stringliteral">&quot;msgAuthenticationParameters&quot;</span>);
<a name="l02029"></a>02029     <span class="keywordflow">if</span> ((next_ptr
<a name="l02030"></a>02030          = asn_parse_string(next_ptr, &amp;remaining_bytes, &amp;type_value,
<a name="l02031"></a>02031                             signature, signature_length)) == NULL) {
<a name="l02032"></a>02032         DEBUGINDENTLESS();
<a name="l02033"></a>02033         <span class="comment">/*</span>
<a name="l02034"></a>02034 <span class="comment">         * RETURN parse error </span>
<a name="l02035"></a>02035 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l02036"></a>02036     }
<a name="l02037"></a>02037     DEBUGINDENTLESS();
<a name="l02038"></a>02038 
<a name="l02039"></a>02039     <span class="keywordflow">if</span> (type_value !=
<a name="l02040"></a>02040         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {
<a name="l02041"></a>02041         <span class="comment">/*</span>
<a name="l02042"></a>02042 <span class="comment">         * RETURN parse error </span>
<a name="l02043"></a>02043 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
<a name="l02044"></a>02044     }
<a name="l02045"></a>02045 
<a name="l02046"></a>02046     <span class="keywordflow">if</span> (*signature_length != 0) {       <span class="comment">/* Blanking for authentication step later */</span>
<a name="l02047"></a>02047         memset(next_ptr - (u_long) * signature_length,
<a name="l02048"></a>02048                0, *signature_length);
<a name="l02049"></a>02049     }
<a name="l02050"></a>02050 
<a name="l02051"></a>02051 
<a name="l02052"></a>02052     <span class="comment">/*</span>
<a name="l02053"></a>02053 <span class="comment">     * Retrieve the salt.</span>
<a name="l02054"></a>02054 <span class="comment">     *</span>
<a name="l02055"></a>02055 <span class="comment">     * Note that the next ptr is where the data section starts.</span>
<a name="l02056"></a>02056 <span class="comment">     */</span>
<a name="l02057"></a>02057     DEBUGDUMPHEADER(<span class="stringliteral">&quot;recv&quot;</span>, <span class="stringliteral">&quot;msgPrivacyParameters&quot;</span>);
<a name="l02058"></a>02058     <span class="keywordflow">if</span> ((*data_ptr
<a name="l02059"></a>02059          = asn_parse_string(next_ptr, &amp;remaining_bytes, &amp;type_value,
<a name="l02060"></a>02060                             salt, salt_length)) == NULL) {
<a name="l02061"></a>02061         DEBUGINDENTLESS();
<a name="l02062"></a>02062         <span class="comment">/*</span>
<a name="l02063"></a>02063 <span class="comment">         * RETURN parse error </span>
<a name="l02064"></a>02064 <span class="comment">         */</span> <span class="keywordflow">return</span> -2;
<a name="l02065"></a>02065     }
<a name="l02066"></a>02066     DEBUGINDENTLESS();
<a name="l02067"></a>02067 
<a name="l02068"></a>02068     <span class="keywordflow">if</span> (type_value !=
<a name="l02069"></a>02069         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {
<a name="l02070"></a>02070         <span class="comment">/*</span>
<a name="l02071"></a>02071 <span class="comment">         * RETURN parse error </span>
<a name="l02072"></a>02072 <span class="comment">         */</span> <span class="keywordflow">return</span> -2;
<a name="l02073"></a>02073     }
<a name="l02074"></a>02074 
<a name="l02075"></a>02075     <span class="keywordflow">return</span> 0;
<a name="l02076"></a>02076 
<a name="l02077"></a>02077 }                               <span class="comment">/* end usm_parse_security_parameters() */</span>
<a name="l02078"></a>02078 
<a name="l02079"></a>02079 
<a name="l02080"></a>02080 
<a name="l02081"></a>02081 
<a name="l02082"></a>02082 <span class="comment">/*******************************************************************-o-******</span>
<a name="l02083"></a>02083 <span class="comment"> * usm_check_and_update_timeliness</span>
<a name="l02084"></a>02084 <span class="comment"> *</span>
<a name="l02085"></a>02085 <span class="comment"> * Parameters:</span>
<a name="l02086"></a>02086 <span class="comment"> *      *secEngineID</span>
<a name="l02087"></a>02087 <span class="comment"> *       secEngineIDen</span>
<a name="l02088"></a>02088 <span class="comment"> *       boots_uint</span>
<a name="l02089"></a>02089 <span class="comment"> *       time_uint</span>
<a name="l02090"></a>02090 <span class="comment"> *      *error</span>
<a name="l02091"></a>02091 <span class="comment"> *      </span>
<a name="l02092"></a>02092 <span class="comment"> * Returns:</span>
<a name="l02093"></a>02093 <span class="comment"> *      0       On success,</span>
<a name="l02094"></a>02094 <span class="comment"> *      -1      Otherwise.</span>
<a name="l02095"></a>02095 <span class="comment"> *      </span>
<a name="l02096"></a>02096 <span class="comment"> *</span>
<a name="l02097"></a>02097 <span class="comment"> * Performs the incoming timeliness checking and setting.</span>
<a name="l02098"></a>02098 <span class="comment"> */</span>
<a name="l02099"></a>02099 <span class="keywordtype">int</span>
<a name="l02100"></a>02100 usm_check_and_update_timeliness(u_char * secEngineID,
<a name="l02101"></a>02101                                 <span class="keywordtype">size_t</span> secEngineIDLen,
<a name="l02102"></a>02102                                 u_int boots_uint,
<a name="l02103"></a>02103                                 u_int time_uint, <span class="keywordtype">int</span> *error)
<a name="l02104"></a>02104 {
<a name="l02105"></a>02105     u_char          myID[USM_MAX_ID_LENGTH];
<a name="l02106"></a>02106     u_long          myIDLength =
<a name="l02107"></a>02107         snmpv3_get_engineID(myID, USM_MAX_ID_LENGTH);
<a name="l02108"></a>02108     u_int           myBoots;
<a name="l02109"></a>02109     u_int           myTime;
<a name="l02110"></a>02110 
<a name="l02111"></a>02111 
<a name="l02112"></a>02112 
<a name="l02113"></a>02113     <span class="keywordflow">if</span> ((myIDLength &gt; USM_MAX_ID_LENGTH) || (myIDLength == 0)) {
<a name="l02114"></a>02114         <span class="comment">/*</span>
<a name="l02115"></a>02115 <span class="comment">         * We&#39;re probably already screwed...buffer overwrite.  XXX? </span>
<a name="l02116"></a>02116 <span class="comment">         */</span>
<a name="l02117"></a>02117         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Buffer overflow.\n&quot;</span>));
<a name="l02118"></a>02118         *error = SNMPERR_USM_GENERICERROR;
<a name="l02119"></a>02119         <span class="keywordflow">return</span> -1;
<a name="l02120"></a>02120     }
<a name="l02121"></a>02121 
<a name="l02122"></a>02122     myBoots = snmpv3_local_snmpEngineBoots();
<a name="l02123"></a>02123     myTime = snmpv3_local_snmpEngineTime();
<a name="l02124"></a>02124 
<a name="l02125"></a>02125 
<a name="l02126"></a>02126     <span class="comment">/*</span>
<a name="l02127"></a>02127 <span class="comment">     * IF the time involved is local</span>
<a name="l02128"></a>02128 <span class="comment">     *     Make sure  message is inside the time window </span>
<a name="l02129"></a>02129 <span class="comment">     * ELSE </span>
<a name="l02130"></a>02130 <span class="comment">     *      IF boots is higher or boots is the same and time is higher</span>
<a name="l02131"></a>02131 <span class="comment">     *              remember this new data</span>
<a name="l02132"></a>02132 <span class="comment">     *      ELSE</span>
<a name="l02133"></a>02133 <span class="comment">     *              IF !(boots same and time within USM_TIME_WINDOW secs)</span>
<a name="l02134"></a>02134 <span class="comment">     *                      Message is too old </span>
<a name="l02135"></a>02135 <span class="comment">     *              ELSE    </span>
<a name="l02136"></a>02136 <span class="comment">     *                      Message is ok, but don&#39;t take time</span>
<a name="l02137"></a>02137 <span class="comment">     *              ENDIF</span>
<a name="l02138"></a>02138 <span class="comment">     *      ENDIF</span>
<a name="l02139"></a>02139 <span class="comment">     * ENDIF</span>
<a name="l02140"></a>02140 <span class="comment">     */</span>
<a name="l02141"></a>02141 
<a name="l02142"></a>02142     <span class="comment">/*</span>
<a name="l02143"></a>02143 <span class="comment">     * This is a local reference.</span>
<a name="l02144"></a>02144 <span class="comment">     */</span>
<a name="l02145"></a>02145     <span class="keywordflow">if</span> (secEngineIDLen == myIDLength
<a name="l02146"></a>02146         &amp;&amp; memcmp(secEngineID, myID, myIDLength) == 0) {
<a name="l02147"></a>02147         u_int           time_difference = myTime &gt; time_uint ?
<a name="l02148"></a>02148             myTime - time_uint : time_uint - myTime;
<a name="l02149"></a>02149 
<a name="l02150"></a>02150         <span class="keywordflow">if</span> (boots_uint == ENGINEBOOT_MAX
<a name="l02151"></a>02151             || boots_uint != myBoots
<a name="l02152"></a>02152             || time_difference &gt; USM_TIME_WINDOW) {
<a name="l02153"></a>02153             snmp_increment_statistic(STAT_USMSTATSNOTINTIMEWINDOWS);
<a name="l02154"></a>02154 
<a name="l02155"></a>02155             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>,
<a name="l02156"></a>02156                         <span class="stringliteral">&quot;boot_uint %u myBoots %u time_diff %u =&gt; not in time window\n&quot;</span>,
<a name="l02157"></a>02157                         boots_uint, myBoots, time_difference));
<a name="l02158"></a>02158             *error = SNMPERR_USM_NOTINTIMEWINDOW;
<a name="l02159"></a>02159             <span class="keywordflow">return</span> -1;
<a name="l02160"></a>02160         }
<a name="l02161"></a>02161 
<a name="l02162"></a>02162         *error = SNMPERR_SUCCESS;
<a name="l02163"></a>02163         <span class="keywordflow">return</span> 0;
<a name="l02164"></a>02164     }
<a name="l02165"></a>02165 
<a name="l02166"></a>02166     <span class="comment">/*</span>
<a name="l02167"></a>02167 <span class="comment">     * This is a remote reference.</span>
<a name="l02168"></a>02168 <span class="comment">     */</span>
<a name="l02169"></a>02169     <span class="keywordflow">else</span> {
<a name="l02170"></a>02170         u_int           theirBoots, theirTime, theirLastTime;
<a name="l02171"></a>02171         u_int           time_difference;
<a name="l02172"></a>02172 
<a name="l02173"></a>02173         <span class="keywordflow">if</span> (get_enginetime_ex(secEngineID, secEngineIDLen,
<a name="l02174"></a>02174                               &amp;theirBoots, &amp;theirTime,
<a name="l02175"></a>02175                               &amp;theirLastTime, TRUE)
<a name="l02176"></a>02176             != SNMPERR_SUCCESS) {
<a name="l02177"></a>02177             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>,
<a name="l02178"></a>02178                         <span class="stringliteral">&quot;Failed to get remote engine&#39;s times.&quot;</span>));
<a name="l02179"></a>02179 
<a name="l02180"></a>02180             *error = SNMPERR_USM_GENERICERROR;
<a name="l02181"></a>02181             <span class="keywordflow">return</span> -1;
<a name="l02182"></a>02182         }
<a name="l02183"></a>02183 
<a name="l02184"></a>02184         time_difference = theirTime &gt; time_uint ?
<a name="l02185"></a>02185             theirTime - time_uint : time_uint - theirTime;
<a name="l02186"></a>02186 
<a name="l02187"></a>02187 
<a name="l02188"></a>02188         <span class="comment">/*</span>
<a name="l02189"></a>02189 <span class="comment">         * XXX  Contrary to the pseudocode:</span>
<a name="l02190"></a>02190 <span class="comment">         *      See if boots is invalid first.</span>
<a name="l02191"></a>02191 <span class="comment">         */</span>
<a name="l02192"></a>02192         <span class="keywordflow">if</span> (theirBoots == ENGINEBOOT_MAX || theirBoots &gt; boots_uint) {
<a name="l02193"></a>02193             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>, <span class="stringliteral">&quot;Remote boot count invalid.&quot;</span>));
<a name="l02194"></a>02194 
<a name="l02195"></a>02195             *error = SNMPERR_USM_NOTINTIMEWINDOW;
<a name="l02196"></a>02196             <span class="keywordflow">return</span> -1;
<a name="l02197"></a>02197         }
<a name="l02198"></a>02198 
<a name="l02199"></a>02199 
<a name="l02200"></a>02200         <span class="comment">/*</span>
<a name="l02201"></a>02201 <span class="comment">         * Boots is ok, see if the boots is the same but the time</span>
<a name="l02202"></a>02202 <span class="comment">         * is old.</span>
<a name="l02203"></a>02203 <span class="comment">         */</span>
<a name="l02204"></a>02204         <span class="keywordflow">if</span> (theirBoots == boots_uint &amp;&amp; time_uint &lt; theirLastTime) {
<a name="l02205"></a>02205             <span class="keywordflow">if</span> (time_difference &gt; USM_TIME_WINDOW) {
<a name="l02206"></a>02206                 DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>, <span class="stringliteral">&quot;Message too old.&quot;</span>));
<a name="l02207"></a>02207                 *error = SNMPERR_USM_NOTINTIMEWINDOW;
<a name="l02208"></a>02208                 <span class="keywordflow">return</span> -1;
<a name="l02209"></a>02209             }
<a name="l02210"></a>02210 
<a name="l02211"></a>02211             <span class="keywordflow">else</span> {              <span class="comment">/* Old, but acceptable */</span>
<a name="l02212"></a>02212 
<a name="l02213"></a>02213                 *error = SNMPERR_SUCCESS;
<a name="l02214"></a>02214                 <span class="keywordflow">return</span> 0;
<a name="l02215"></a>02215             }
<a name="l02216"></a>02216         }
<a name="l02217"></a>02217 
<a name="l02218"></a>02218 
<a name="l02219"></a>02219         <span class="comment">/*</span>
<a name="l02220"></a>02220 <span class="comment">         * Message is ok, either boots has been advanced, or</span>
<a name="l02221"></a>02221 <span class="comment">         * time is greater than before with the same boots.</span>
<a name="l02222"></a>02222 <span class="comment">         */</span>
<a name="l02223"></a>02223 
<a name="l02224"></a>02224         <span class="keywordflow">if</span> (set_enginetime(secEngineID, secEngineIDLen,
<a name="l02225"></a>02225                            boots_uint, time_uint, TRUE)
<a name="l02226"></a>02226             != SNMPERR_SUCCESS) {
<a name="l02227"></a>02227             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>,
<a name="l02228"></a>02228                         <span class="stringliteral">&quot;Failed updating remote boot/time.&quot;</span>));
<a name="l02229"></a>02229             *error = SNMPERR_USM_GENERICERROR;
<a name="l02230"></a>02230             <span class="keywordflow">return</span> -1;
<a name="l02231"></a>02231         }
<a name="l02232"></a>02232 
<a name="l02233"></a>02233         *error = SNMPERR_SUCCESS;
<a name="l02234"></a>02234         <span class="keywordflow">return</span> 0;               <span class="comment">/* Fresh message and time updated */</span>
<a name="l02235"></a>02235 
<a name="l02236"></a>02236     }                           <span class="comment">/* endif -- local or remote time reference. */</span>
<a name="l02237"></a>02237 
<a name="l02238"></a>02238 
<a name="l02239"></a>02239 }                               <span class="comment">/* end usm_check_and_update_timeliness() */</span>
<a name="l02240"></a>02240 
<a name="l02241"></a>02241 
<a name="l02242"></a>02242 
<a name="l02243"></a>02243 <span class="keywordtype">int</span>
<a name="l02244"></a>02244 usm_secmod_process_in_msg(<span class="keyword">struct</span> <a class="code" href="structsnmp__secmod__incoming__params.html">snmp_secmod_incoming_params</a> *parms)
<a name="l02245"></a>02245 {
<a name="l02246"></a>02246     <span class="keywordflow">if</span> (!parms)
<a name="l02247"></a>02247         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l02248"></a>02248 
<a name="l02249"></a>02249     <span class="keywordflow">return</span> usm_process_in_msg(parms-&gt;msgProcModel,
<a name="l02250"></a>02250                               parms-&gt;maxMsgSize,
<a name="l02251"></a>02251                               parms-&gt;secParams,
<a name="l02252"></a>02252                               parms-&gt;secModel,
<a name="l02253"></a>02253                               parms-&gt;secLevel,
<a name="l02254"></a>02254                               parms-&gt;wholeMsg,
<a name="l02255"></a>02255                               parms-&gt;wholeMsgLen,
<a name="l02256"></a>02256                               parms-&gt;secEngineID,
<a name="l02257"></a>02257                               parms-&gt;secEngineIDLen,
<a name="l02258"></a>02258                               parms-&gt;secName,
<a name="l02259"></a>02259                               parms-&gt;secNameLen,
<a name="l02260"></a>02260                               parms-&gt;scopedPdu,
<a name="l02261"></a>02261                               parms-&gt;scopedPduLen,
<a name="l02262"></a>02262                               parms-&gt;maxSizeResponse,
<a name="l02263"></a>02263                               parms-&gt;secStateRef,
<a name="l02264"></a>02264                               parms-&gt;sess, parms-&gt;msg_flags);
<a name="l02265"></a>02265 }
<a name="l02266"></a>02266 
<a name="l02267"></a>02267 <span class="comment">/*******************************************************************-o-******</span>
<a name="l02268"></a>02268 <span class="comment"> * usm_process_in_msg</span>
<a name="l02269"></a>02269 <span class="comment"> *</span>
<a name="l02270"></a>02270 <span class="comment"> * Parameters:</span>
<a name="l02271"></a>02271 <span class="comment"> *      (See list below...)</span>
<a name="l02272"></a>02272 <span class="comment"> *      </span>
<a name="l02273"></a>02273 <span class="comment"> * Returns:</span>
<a name="l02274"></a>02274 <span class="comment"> *      SNMPERR_SUCCESS                 On success.</span>
<a name="l02275"></a>02275 <span class="comment"> *      SNMPERR_USM_AUTHENTICATIONFAILURE</span>
<a name="l02276"></a>02276 <span class="comment"> *      SNMPERR_USM_DECRYPTIONERROR</span>
<a name="l02277"></a>02277 <span class="comment"> *      SNMPERR_USM_GENERICERROR</span>
<a name="l02278"></a>02278 <span class="comment"> *      SNMPERR_USM_PARSEERROR</span>
<a name="l02279"></a>02279 <span class="comment"> *      SNMPERR_USM_UNKNOWNENGINEID</span>
<a name="l02280"></a>02280 <span class="comment"> *      SNMPERR_USM_PARSEERROR</span>
<a name="l02281"></a>02281 <span class="comment"> *      SNMPERR_USM_UNKNOWNSECURITYNAME</span>
<a name="l02282"></a>02282 <span class="comment"> *      SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL</span>
<a name="l02283"></a>02283 <span class="comment"> *</span>
<a name="l02284"></a>02284 <span class="comment"> *</span>
<a name="l02285"></a>02285 <span class="comment"> * ASSUMES size of decrypt_buf will always be &gt;= size of encrypted sPDU.</span>
<a name="l02286"></a>02286 <span class="comment"> *</span>
<a name="l02287"></a>02287 <span class="comment"> * FIX  Memory leaks if secStateRef is allocated and a return occurs</span>
<a name="l02288"></a>02288 <span class="comment"> *      without cleaning up.  May contain secrets...</span>
<a name="l02289"></a>02289 <span class="comment"> */</span>
<a name="l02290"></a>02290 <span class="keywordtype">int</span>
<a name="l02291"></a>02291 usm_process_in_msg(<span class="keywordtype">int</span> msgProcModel,    <span class="comment">/* (UNUSED) */</span>
<a name="l02292"></a>02292                    <span class="keywordtype">size_t</span> maxMsgSize,   <span class="comment">/* IN     - Used to calc maxSizeResponse.  */</span>
<a name="l02293"></a>02293                    u_char * secParams,  <span class="comment">/* IN     - BER encoded securityParameters. */</span>
<a name="l02294"></a>02294                    <span class="keywordtype">int</span> secModel,        <span class="comment">/* (UNUSED) */</span>
<a name="l02295"></a>02295                    <span class="keywordtype">int</span> secLevel,        <span class="comment">/* IN     - AuthNoPriv, authPriv etc.      */</span>
<a name="l02296"></a>02296                    u_char * wholeMsg,   <span class="comment">/* IN     - Original v3 message.           */</span>
<a name="l02297"></a>02297                    <span class="keywordtype">size_t</span> wholeMsgLen,  <span class="comment">/* IN     - Msg length.                    */</span>
<a name="l02298"></a>02298                    u_char * secEngineID,        <span class="comment">/* OUT    - Pointer snmpEngineID.          */</span>
<a name="l02299"></a>02299                    <span class="keywordtype">size_t</span> * secEngineIDLen,     <span class="comment">/* IN/OUT - Len available, len returned.   */</span>
<a name="l02300"></a>02300                    <span class="comment">/*</span>
<a name="l02301"></a>02301 <span class="comment">                    * NOTE: Memory provided by caller.      </span>
<a name="l02302"></a>02302 <span class="comment">                    */</span>
<a name="l02303"></a>02303                    <span class="keywordtype">char</span> *secName,       <span class="comment">/* OUT    - Pointer to securityName.       */</span>
<a name="l02304"></a>02304                    <span class="keywordtype">size_t</span> * secNameLen, <span class="comment">/* IN/OUT - Len available, len returned.   */</span>
<a name="l02305"></a>02305                    u_char ** scopedPdu, <span class="comment">/* OUT    - Pointer to plaintext scopedPdu. */</span>
<a name="l02306"></a>02306                    <span class="keywordtype">size_t</span> * scopedPduLen,       <span class="comment">/* IN/OUT - Len available, len returned.   */</span>
<a name="l02307"></a>02307                    <span class="keywordtype">size_t</span> * maxSizeResponse,    <span class="comment">/* OUT    - Max size of Response PDU.      */</span>
<a name="l02308"></a>02308                    <span class="keywordtype">void</span> **secStateRf,   <span class="comment">/* OUT    - Ref to security state.         */</span>
<a name="l02309"></a>02309                    <a class="code" href="structsnmp__session.html" title="The snmp session structure.">netsnmp_session</a> * sess,      <span class="comment">/* IN     - session which got the message  */</span>
<a name="l02310"></a>02310                    u_char msg_flags)
<a name="l02311"></a>02311 {                               <span class="comment">/* IN     - v3 Message flags.              */</span>
<a name="l02312"></a>02312     <span class="keywordtype">size_t</span>          remaining = wholeMsgLen - (u_int)
<a name="l02313"></a>02313         ((u_long) * secParams - (u_long) * wholeMsg);
<a name="l02314"></a>02314     u_int           boots_uint;
<a name="l02315"></a>02315     u_int           time_uint;
<a name="l02316"></a>02316 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l02317"></a>02317 <span class="preprocessor"></span>    u_int           net_boots, net_time;
<a name="l02318"></a>02318 <span class="preprocessor">#endif</span>
<a name="l02319"></a>02319 <span class="preprocessor"></span>    u_char          signature[BYTESIZE(USM_MAX_KEYEDHASH_LENGTH)];
<a name="l02320"></a>02320     <span class="keywordtype">size_t</span>          signature_length = BYTESIZE(USM_MAX_KEYEDHASH_LENGTH);
<a name="l02321"></a>02321     u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];
<a name="l02322"></a>02322     <span class="keywordtype">size_t</span>          salt_length = BYTESIZE(USM_MAX_SALT_LENGTH);
<a name="l02323"></a>02323     u_char          iv[BYTESIZE(USM_MAX_SALT_LENGTH)];
<a name="l02324"></a>02324     u_int           iv_length = BYTESIZE(USM_MAX_SALT_LENGTH);
<a name="l02325"></a>02325     u_char         *data_ptr;
<a name="l02326"></a>02326     u_char         *value_ptr;
<a name="l02327"></a>02327     u_char          type_value;
<a name="l02328"></a>02328     u_char         *end_of_overhead = NULL;
<a name="l02329"></a>02329     <span class="keywordtype">int</span>             error;
<a name="l02330"></a>02330     <span class="keywordtype">int</span>             i, rc = 0;
<a name="l02331"></a>02331     <span class="keyword">struct </span><a class="code" href="structusmStateReference.html">usmStateReference</a> **secStateRef =
<a name="l02332"></a>02332         (<span class="keyword">struct </span><a class="code" href="structusmStateReference.html">usmStateReference</a> **) secStateRf;
<a name="l02333"></a>02333 
<a name="l02334"></a>02334     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *user;
<a name="l02335"></a>02335 
<a name="l02336"></a>02336 
<a name="l02337"></a>02337     DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;USM processing begun...\n&quot;</span>));
<a name="l02338"></a>02338 
<a name="l02339"></a>02339 
<a name="l02340"></a>02340     <span class="keywordflow">if</span> (secStateRef) {
<a name="l02341"></a>02341         usm_free_usmStateReference(*secStateRef);
<a name="l02342"></a>02342         *secStateRef = usm_malloc_usmStateReference();
<a name="l02343"></a>02343         <span class="keywordflow">if</span> (*secStateRef == NULL) {
<a name="l02344"></a>02344             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Out of memory.\n&quot;</span>));
<a name="l02345"></a>02345             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02346"></a>02346         }
<a name="l02347"></a>02347     }
<a name="l02348"></a>02348 
<a name="l02349"></a>02349 
<a name="l02350"></a>02350     <span class="comment">/*</span>
<a name="l02351"></a>02351 <span class="comment">     * Make sure the *secParms is an OCTET STRING.</span>
<a name="l02352"></a>02352 <span class="comment">     * Extract the user name, engine ID, and security level.</span>
<a name="l02353"></a>02353 <span class="comment">     */</span>
<a name="l02354"></a>02354     <span class="keywordflow">if</span> ((rc = usm_parse_security_parameters(secParams, remaining,
<a name="l02355"></a>02355                                             secEngineID, secEngineIDLen,
<a name="l02356"></a>02356                                             &amp;boots_uint, &amp;time_uint,
<a name="l02357"></a>02357                                             secName, secNameLen,
<a name="l02358"></a>02358                                             signature, &amp;signature_length,
<a name="l02359"></a>02359                                             salt, &amp;salt_length,
<a name="l02360"></a>02360                                             &amp;data_ptr)) &lt; 0) {
<a name="l02361"></a>02361         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Parsing failed (rc %d).\n&quot;</span>, rc));
<a name="l02362"></a>02362         <span class="keywordflow">if</span> (rc == -2) {
<a name="l02363"></a>02363             <span class="comment">/*</span>
<a name="l02364"></a>02364 <span class="comment">             * This indicates a decryptionError.  </span>
<a name="l02365"></a>02365 <span class="comment">             */</span>
<a name="l02366"></a>02366             snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);
<a name="l02367"></a>02367             <span class="keywordflow">return</span> SNMPERR_USM_DECRYPTIONERROR;
<a name="l02368"></a>02368         }
<a name="l02369"></a>02369         snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
<a name="l02370"></a>02370         <span class="keywordflow">return</span> SNMPERR_USM_PARSEERROR;
<a name="l02371"></a>02371     }
<a name="l02372"></a>02372 
<a name="l02373"></a>02373     <span class="comment">/*</span>
<a name="l02374"></a>02374 <span class="comment">     * RFC 2574 section 8.3.2</span>
<a name="l02375"></a>02375 <span class="comment">     * 1)  If the privParameters field is not an 8-octet OCTET STRING,</span>
<a name="l02376"></a>02376 <span class="comment">     * then an error indication (decryptionError) is returned to the</span>
<a name="l02377"></a>02377 <span class="comment">     * calling module.</span>
<a name="l02378"></a>02378 <span class="comment">     */</span>
<a name="l02379"></a>02379     <span class="keywordflow">if</span> ((secLevel == SNMP_SEC_LEVEL_AUTHPRIV) &amp;&amp; (salt_length != 8)) {
<a name="l02380"></a>02380         snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);
<a name="l02381"></a>02381         <span class="keywordflow">return</span> SNMPERR_USM_DECRYPTIONERROR;
<a name="l02382"></a>02382     }
<a name="l02383"></a>02383 
<a name="l02384"></a>02384     <span class="keywordflow">if</span> (secLevel != SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l02385"></a>02385         <span class="comment">/*</span>
<a name="l02386"></a>02386 <span class="comment">         * pull these out now so reports can use them </span>
<a name="l02387"></a>02387 <span class="comment">         */</span>
<a name="l02388"></a>02388         *scopedPdu = data_ptr;
<a name="l02389"></a>02389         *scopedPduLen = wholeMsgLen - (data_ptr - wholeMsg);
<a name="l02390"></a>02390         end_of_overhead = data_ptr;
<a name="l02391"></a>02391     }
<a name="l02392"></a>02392 
<a name="l02393"></a>02393     <span class="keywordflow">if</span> (secStateRef) {
<a name="l02394"></a>02394         <span class="comment">/*</span>
<a name="l02395"></a>02395 <span class="comment">         * Cache the name, engine ID, and security level,</span>
<a name="l02396"></a>02396 <span class="comment">         * * per step 2 (section 3.2)</span>
<a name="l02397"></a>02397 <span class="comment">         */</span>
<a name="l02398"></a>02398         <span class="keywordflow">if</span> (usm_set_usmStateReference_name
<a name="l02399"></a>02399             (*secStateRef, secName, *secNameLen) == -1) {
<a name="l02400"></a>02400             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>, <span class="stringliteral">&quot;Couldn&#39;t cache name.&quot;</span>));
<a name="l02401"></a>02401             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02402"></a>02402         }
<a name="l02403"></a>02403 
<a name="l02404"></a>02404         <span class="keywordflow">if</span> (usm_set_usmStateReference_engine_id
<a name="l02405"></a>02405             (*secStateRef, secEngineID, *secEngineIDLen) == -1) {
<a name="l02406"></a>02406             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>, <span class="stringliteral">&quot;Couldn&#39;t cache engine id.&quot;</span>));
<a name="l02407"></a>02407             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02408"></a>02408         }
<a name="l02409"></a>02409 
<a name="l02410"></a>02410         <span class="keywordflow">if</span> (usm_set_usmStateReference_sec_level(*secStateRef, secLevel) ==
<a name="l02411"></a>02411             -1) {
<a name="l02412"></a>02412             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>, <span class="stringliteral">&quot;Couldn&#39;t cache security level.&quot;</span>));
<a name="l02413"></a>02413             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02414"></a>02414         }
<a name="l02415"></a>02415     }
<a name="l02416"></a>02416 
<a name="l02417"></a>02417 
<a name="l02418"></a>02418     <span class="comment">/*</span>
<a name="l02419"></a>02419 <span class="comment">     * Locate the engine ID record.</span>
<a name="l02420"></a>02420 <span class="comment">     * If it is unknown, then either create one or note this as an error.</span>
<a name="l02421"></a>02421 <span class="comment">     */</span>
<a name="l02422"></a>02422     <span class="keywordflow">if</span> ((sess &amp;&amp; (sess-&gt;<a class="code" href="structsnmp__session.html#a9284be33e69062f7f90723a4ee04409b" title="are we the authoritative engine?">isAuthoritative</a> == SNMP_SESS_AUTHORITATIVE ||
<a name="l02423"></a>02423                   (sess-&gt;<a class="code" href="structsnmp__session.html#a9284be33e69062f7f90723a4ee04409b" title="are we the authoritative engine?">isAuthoritative</a> == SNMP_SESS_UNKNOWNAUTH &amp;&amp;
<a name="l02424"></a>02424                    (msg_flags &amp; SNMP_MSG_FLAG_RPRT_BIT)))) ||
<a name="l02425"></a>02425         (!sess &amp;&amp; (msg_flags &amp; SNMP_MSG_FLAG_RPRT_BIT))) {
<a name="l02426"></a>02426         <span class="keywordflow">if</span> (ISENGINEKNOWN(secEngineID, *secEngineIDLen) == FALSE) {
<a name="l02427"></a>02427             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Unknown Engine ID.\n&quot;</span>));
<a name="l02428"></a>02428             snmp_increment_statistic(STAT_USMSTATSUNKNOWNENGINEIDS);
<a name="l02429"></a>02429             <span class="keywordflow">return</span> SNMPERR_USM_UNKNOWNENGINEID;
<a name="l02430"></a>02430         }
<a name="l02431"></a>02431     } <span class="keywordflow">else</span> {
<a name="l02432"></a>02432         <span class="keywordflow">if</span> (ENSURE_ENGINE_RECORD(secEngineID, *secEngineIDLen)
<a name="l02433"></a>02433             != SNMPERR_SUCCESS) {
<a name="l02434"></a>02434             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>, <span class="stringliteral">&quot;Couldn&#39;t ensure engine record.&quot;</span>));
<a name="l02435"></a>02435             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02436"></a>02436         }
<a name="l02437"></a>02437 
<a name="l02438"></a>02438     }
<a name="l02439"></a>02439 
<a name="l02440"></a>02440 
<a name="l02441"></a>02441     <span class="comment">/*</span>
<a name="l02442"></a>02442 <span class="comment">     * Locate the User record.</span>
<a name="l02443"></a>02443 <span class="comment">     * If the user/engine ID is unknown, report this as an error.</span>
<a name="l02444"></a>02444 <span class="comment">     */</span>
<a name="l02445"></a>02445     <span class="keywordflow">if</span> ((user = usm_get_user_from_list(secEngineID, *secEngineIDLen,
<a name="l02446"></a>02446                                        secName, userList,
<a name="l02447"></a>02447                                        (((sess &amp;&amp; sess-&gt;<a class="code" href="structsnmp__session.html#a9284be33e69062f7f90723a4ee04409b" title="are we the authoritative engine?">isAuthoritative</a> ==
<a name="l02448"></a>02448                                           SNMP_SESS_AUTHORITATIVE) ||
<a name="l02449"></a>02449                                          (!sess)) ? 0 : 1)))
<a name="l02450"></a>02450         == NULL) {
<a name="l02451"></a>02451         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Unknown User(%s)\n&quot;</span>, secName));
<a name="l02452"></a>02452         snmp_increment_statistic(STAT_USMSTATSUNKNOWNUSERNAMES);
<a name="l02453"></a>02453         <span class="keywordflow">return</span> SNMPERR_USM_UNKNOWNSECURITYNAME;
<a name="l02454"></a>02454     }
<a name="l02455"></a>02455 
<a name="l02456"></a>02456     <span class="comment">/* ensure the user is active */</span>
<a name="l02457"></a>02457     <span class="keywordflow">if</span> (user-&gt;userStatus != RS_ACTIVE) {
<a name="l02458"></a>02458         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Attempt to use an inactive user.\n&quot;</span>));
<a name="l02459"></a>02459         <span class="keywordflow">return</span> SNMPERR_USM_UNKNOWNSECURITYNAME;
<a name="l02460"></a>02460     }
<a name="l02461"></a>02461 
<a name="l02462"></a>02462     <span class="comment">/*</span>
<a name="l02463"></a>02463 <span class="comment">     * Make sure the security level is appropriate.</span>
<a name="l02464"></a>02464 <span class="comment">     */</span>
<a name="l02465"></a>02465 
<a name="l02466"></a>02466     rc = usm_check_secLevel(secLevel, user);
<a name="l02467"></a>02467     <span class="keywordflow">if</span> (1 == rc) {
<a name="l02468"></a>02468         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Unsupported Security Level (%d).\n&quot;</span>,
<a name="l02469"></a>02469                     secLevel));
<a name="l02470"></a>02470         snmp_increment_statistic(STAT_USMSTATSUNSUPPORTEDSECLEVELS);
<a name="l02471"></a>02471         <span class="keywordflow">return</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;
<a name="l02472"></a>02472     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != 0) {
<a name="l02473"></a>02473         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Unknown issue.\n&quot;</span>));
<a name="l02474"></a>02474         <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02475"></a>02475     }
<a name="l02476"></a>02476 
<a name="l02477"></a>02477     <span class="comment">/*</span>
<a name="l02478"></a>02478 <span class="comment">     * Check the authentication credentials of the message.</span>
<a name="l02479"></a>02479 <span class="comment">     */</span>
<a name="l02480"></a>02480     <span class="keywordflow">if</span> (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
<a name="l02481"></a>02481         || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l02482"></a>02482         <span class="keywordflow">if</span> (sc_check_keyed_hash(user-&gt;authProtocol, user-&gt;authProtocolLen,
<a name="l02483"></a>02483                                 user-&gt;authKey, user-&gt;authKeyLen,
<a name="l02484"></a>02484                                 wholeMsg, wholeMsgLen,
<a name="l02485"></a>02485                                 signature, signature_length)
<a name="l02486"></a>02486             != SNMP_ERR_NOERROR) {
<a name="l02487"></a>02487             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Verification failed.\n&quot;</span>));
<a name="l02488"></a>02488             snmp_increment_statistic(STAT_USMSTATSWRONGDIGESTS);
<a name="l02489"></a>02489             <a class="code" href="group__snmp__logging.html#ga9ba905368ea1c551b969af44b13e37c2" title="This snmp logging function allows variable argument list given the specified format and priority...">snmp_log</a>(LOG_WARNING, <span class="stringliteral">&quot;Authentication failed for %s\n&quot;</span>,
<a name="l02490"></a>02490                                 user-&gt;name);
<a name="l02491"></a>02491             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
<a name="l02492"></a>02492         }
<a name="l02493"></a>02493 
<a name="l02494"></a>02494         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Verification succeeded.\n&quot;</span>));
<a name="l02495"></a>02495     }
<a name="l02496"></a>02496 
<a name="l02497"></a>02497 
<a name="l02498"></a>02498     <span class="comment">/*</span>
<a name="l02499"></a>02499 <span class="comment">     * Steps 10-11  user is already set - relocated before timeliness </span>
<a name="l02500"></a>02500 <span class="comment">     * check in case it fails - still save user data for response.</span>
<a name="l02501"></a>02501 <span class="comment">     *</span>
<a name="l02502"></a>02502 <span class="comment">     * Cache the keys and protocol oids, per step 11 (s3.2).</span>
<a name="l02503"></a>02503 <span class="comment">     */</span>
<a name="l02504"></a>02504     <span class="keywordflow">if</span> (secStateRef) {
<a name="l02505"></a>02505         <span class="keywordflow">if</span> (usm_set_usmStateReference_auth_protocol(*secStateRef,
<a name="l02506"></a>02506                                                     user-&gt;authProtocol,
<a name="l02507"></a>02507                                                     user-&gt;
<a name="l02508"></a>02508                                                     authProtocolLen) ==
<a name="l02509"></a>02509             -1) {
<a name="l02510"></a>02510             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>,
<a name="l02511"></a>02511                         <span class="stringliteral">&quot;Couldn&#39;t cache authentication protocol.&quot;</span>));
<a name="l02512"></a>02512             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02513"></a>02513         }
<a name="l02514"></a>02514 
<a name="l02515"></a>02515         <span class="keywordflow">if</span> (usm_set_usmStateReference_auth_key(*secStateRef,
<a name="l02516"></a>02516                                                user-&gt;authKey,
<a name="l02517"></a>02517                                                user-&gt;authKeyLen) == -1) {
<a name="l02518"></a>02518             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>,
<a name="l02519"></a>02519                         <span class="stringliteral">&quot;Couldn&#39;t cache authentication key.&quot;</span>));
<a name="l02520"></a>02520             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02521"></a>02521         }
<a name="l02522"></a>02522 
<a name="l02523"></a>02523         <span class="keywordflow">if</span> (usm_set_usmStateReference_priv_protocol(*secStateRef,
<a name="l02524"></a>02524                                                     user-&gt;privProtocol,
<a name="l02525"></a>02525                                                     user-&gt;
<a name="l02526"></a>02526                                                     privProtocolLen) ==
<a name="l02527"></a>02527             -1) {
<a name="l02528"></a>02528             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>,
<a name="l02529"></a>02529                         <span class="stringliteral">&quot;Couldn&#39;t cache privacy protocol.&quot;</span>));
<a name="l02530"></a>02530             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02531"></a>02531         }
<a name="l02532"></a>02532 
<a name="l02533"></a>02533         <span class="keywordflow">if</span> (usm_set_usmStateReference_priv_key(*secStateRef,
<a name="l02534"></a>02534                                                user-&gt;privKey,
<a name="l02535"></a>02535                                                user-&gt;privKeyLen) == -1) {
<a name="l02536"></a>02536             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>, <span class="stringliteral">&quot;Couldn&#39;t cache privacy key.&quot;</span>));
<a name="l02537"></a>02537             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
<a name="l02538"></a>02538         }
<a name="l02539"></a>02539     }
<a name="l02540"></a>02540 
<a name="l02541"></a>02541 
<a name="l02542"></a>02542     <span class="comment">/*</span>
<a name="l02543"></a>02543 <span class="comment">     * Perform the timeliness/time manager functions.</span>
<a name="l02544"></a>02544 <span class="comment">     */</span>
<a name="l02545"></a>02545     <span class="keywordflow">if</span> (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
<a name="l02546"></a>02546         || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l02547"></a>02547         <span class="keywordflow">if</span> (usm_check_and_update_timeliness(secEngineID, *secEngineIDLen,
<a name="l02548"></a>02548                                             boots_uint, time_uint,
<a name="l02549"></a>02549                                             &amp;error) == -1) {
<a name="l02550"></a>02550             <span class="keywordflow">return</span> error;
<a name="l02551"></a>02551         }
<a name="l02552"></a>02552     }
<a name="l02553"></a>02553 <span class="preprocessor">#ifdef                                                  LCD_TIME_SYNC_OPT</span>
<a name="l02554"></a>02554 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l02555"></a>02555 <span class="comment">     * Cache the unauthenticated time to use in case we don&#39;t have</span>
<a name="l02556"></a>02556 <span class="comment">     * anything better - this guess will be no worse than (0,0)</span>
<a name="l02557"></a>02557 <span class="comment">     * that we normally use.</span>
<a name="l02558"></a>02558 <span class="comment">     */</span>
<a name="l02559"></a>02559     <span class="keywordflow">else</span> {
<a name="l02560"></a>02560         set_enginetime(secEngineID, *secEngineIDLen,
<a name="l02561"></a>02561                        boots_uint, time_uint, FALSE);
<a name="l02562"></a>02562     }
<a name="l02563"></a>02563 <span class="preprocessor">#endif                          </span><span class="comment">/* LCD_TIME_SYNC_OPT */</span>
<a name="l02564"></a>02564 
<a name="l02565"></a>02565 
<a name="l02566"></a>02566     <span class="comment">/*</span>
<a name="l02567"></a>02567 <span class="comment">     * If needed, decrypt the scoped PDU.</span>
<a name="l02568"></a>02568 <span class="comment">     */</span>
<a name="l02569"></a>02569     <span class="keywordflow">if</span> (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
<a name="l02570"></a>02570         remaining = wholeMsgLen - (data_ptr - wholeMsg);
<a name="l02571"></a>02571 
<a name="l02572"></a>02572         <span class="keywordflow">if</span> ((value_ptr = asn_parse_sequence(data_ptr, &amp;remaining,
<a name="l02573"></a>02573                                             &amp;type_value,
<a name="l02574"></a>02574                                             (ASN_UNIVERSAL | ASN_PRIMITIVE
<a name="l02575"></a>02575                                              | ASN_OCTET_STR),
<a name="l02576"></a>02576                                             <span class="stringliteral">&quot;encrypted sPDU&quot;</span>)) == NULL) {
<a name="l02577"></a>02577             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>,
<a name="l02578"></a>02578                         <span class="stringliteral">&quot;Failed while parsing encrypted sPDU.&quot;</span>));
<a name="l02579"></a>02579             snmp_increment_statistic(STAT_SNMPINASNPARSEERRS);
<a name="l02580"></a>02580             usm_free_usmStateReference(*secStateRef);
<a name="l02581"></a>02581             *secStateRef = NULL;
<a name="l02582"></a>02582             <span class="keywordflow">return</span> SNMPERR_USM_PARSEERROR;
<a name="l02583"></a>02583         }
<a name="l02584"></a>02584 
<a name="l02585"></a>02585 <span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l02586"></a>02586 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (ISTRANSFORM(user-&gt;privProtocol, DESPriv)) {
<a name="l02587"></a>02587             <span class="comment">/*</span>
<a name="l02588"></a>02588 <span class="comment">             * From RFC2574:</span>
<a name="l02589"></a>02589 <span class="comment">             * </span>
<a name="l02590"></a>02590 <span class="comment">             * &quot;Before decryption, the encrypted data length is verified.</span>
<a name="l02591"></a>02591 <span class="comment">             * If the length of the OCTET STRING to be decrypted is not</span>
<a name="l02592"></a>02592 <span class="comment">             * an integral multiple of 8 octets, the decryption process</span>
<a name="l02593"></a>02593 <span class="comment">             * is halted and an appropriate exception noted.&quot;  </span>
<a name="l02594"></a>02594 <span class="comment">             */</span>
<a name="l02595"></a>02595 
<a name="l02596"></a>02596             <span class="keywordflow">if</span> (remaining % 8 != 0) {
<a name="l02597"></a>02597                 DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>,
<a name="l02598"></a>02598                             <span class="stringliteral">&quot;Ciphertext is %lu bytes, not an integer multiple of 8 (rem %lu)\n&quot;</span>,
<a name="l02599"></a>02599                             (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)remaining, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)remaining % 8));
<a name="l02600"></a>02600                 snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);
<a name="l02601"></a>02601                 usm_free_usmStateReference(*secStateRef);
<a name="l02602"></a>02602                 *secStateRef = NULL;
<a name="l02603"></a>02603                 <span class="keywordflow">return</span> SNMPERR_USM_DECRYPTIONERROR;
<a name="l02604"></a>02604             }
<a name="l02605"></a>02605 
<a name="l02606"></a>02606             end_of_overhead = value_ptr;
<a name="l02607"></a>02607 
<a name="l02608"></a>02608             <span class="keywordflow">if</span> ( !user-&gt;privKey ) {
<a name="l02609"></a>02609                 DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;No privacy pass phrase for %s\n&quot;</span>, user-&gt;secName));
<a name="l02610"></a>02610                 snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);
<a name="l02611"></a>02611                 usm_free_usmStateReference(*secStateRef);
<a name="l02612"></a>02612                 *secStateRef = NULL;
<a name="l02613"></a>02613                 <span class="keywordflow">return</span> SNMPERR_USM_DECRYPTIONERROR;
<a name="l02614"></a>02614             }
<a name="l02615"></a>02615 
<a name="l02616"></a>02616             <span class="comment">/*</span>
<a name="l02617"></a>02617 <span class="comment">             * XOR the salt with the last (iv_length) bytes</span>
<a name="l02618"></a>02618 <span class="comment">             * of the priv_key to obtain the IV.</span>
<a name="l02619"></a>02619 <span class="comment">             */</span>
<a name="l02620"></a>02620             iv_length = BYTESIZE(USM_DES_SALT_LENGTH);
<a name="l02621"></a>02621             <span class="keywordflow">for</span> (i = 0; i &lt; (int) iv_length; i++)
<a name="l02622"></a>02622                 iv[i] = salt[i] ^ user-&gt;privKey[iv_length + i];
<a name="l02623"></a>02623         }
<a name="l02624"></a>02624 <span class="preprocessor">#endif</span>
<a name="l02625"></a>02625 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l02626"></a>02626 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (ISTRANSFORM(user-&gt;privProtocol, AESPriv)) {
<a name="l02627"></a>02627             iv_length = BYTESIZE(USM_AES_SALT_LENGTH);
<a name="l02628"></a>02628             net_boots = ntohl(boots_uint);
<a name="l02629"></a>02629             net_time = ntohl(time_uint);
<a name="l02630"></a>02630             memcpy(iv, &amp;net_boots, 4);
<a name="l02631"></a>02631             memcpy(iv+4, &amp;net_time, 4);
<a name="l02632"></a>02632             memcpy(iv+8, salt, salt_length);
<a name="l02633"></a>02633         }
<a name="l02634"></a>02634 <span class="preprocessor">#endif</span>
<a name="l02635"></a>02635 <span class="preprocessor"></span>        
<a name="l02636"></a>02636         <span class="keywordflow">if</span> (sc_decrypt(user-&gt;privProtocol, user-&gt;privProtocolLen,
<a name="l02637"></a>02637                        user-&gt;privKey, user-&gt;privKeyLen,
<a name="l02638"></a>02638                        iv, iv_length,
<a name="l02639"></a>02639                        value_ptr, remaining, *scopedPdu, scopedPduLen)
<a name="l02640"></a>02640             != SNMP_ERR_NOERROR) {
<a name="l02641"></a>02641             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;%s\n&quot;</span>, <span class="stringliteral">&quot;Failed decryption.&quot;</span>));
<a name="l02642"></a>02642             snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS);
<a name="l02643"></a>02643             <span class="keywordflow">return</span> SNMPERR_USM_DECRYPTIONERROR;
<a name="l02644"></a>02644         }
<a name="l02645"></a>02645 <span class="preprocessor">#ifdef NETSNMP_ENABLE_TESTING_CODE</span>
<a name="l02646"></a>02646 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (debug_is_token_registered(<span class="stringliteral">&quot;usm/dump&quot;</span>) == SNMPERR_SUCCESS) {
<a name="l02647"></a>02647             dump_chunk(<span class="stringliteral">&quot;usm/dump&quot;</span>, <span class="stringliteral">&quot;Cypher Text&quot;</span>, value_ptr, remaining);
<a name="l02648"></a>02648             dump_chunk(<span class="stringliteral">&quot;usm/dump&quot;</span>, <span class="stringliteral">&quot;salt + Encrypted form:&quot;</span>,
<a name="l02649"></a>02649                        salt, salt_length);
<a name="l02650"></a>02650             dump_chunk(<span class="stringliteral">&quot;usm/dump&quot;</span>, <span class="stringliteral">&quot;IV + Encrypted form:&quot;</span>, iv, iv_length);
<a name="l02651"></a>02651             dump_chunk(<span class="stringliteral">&quot;usm/dump&quot;</span>, <span class="stringliteral">&quot;Decrypted chunk:&quot;</span>,
<a name="l02652"></a>02652                        *scopedPdu, *scopedPduLen);
<a name="l02653"></a>02653         }
<a name="l02654"></a>02654 <span class="preprocessor">#endif</span>
<a name="l02655"></a>02655 <span class="preprocessor"></span>    }
<a name="l02656"></a>02656     <span class="comment">/*</span>
<a name="l02657"></a>02657 <span class="comment">     * sPDU is plaintext.</span>
<a name="l02658"></a>02658 <span class="comment">     */</span>
<a name="l02659"></a>02659     <span class="keywordflow">else</span> {
<a name="l02660"></a>02660         *scopedPdu = data_ptr;
<a name="l02661"></a>02661         *scopedPduLen = wholeMsgLen - (data_ptr - wholeMsg);
<a name="l02662"></a>02662         end_of_overhead = data_ptr;
<a name="l02663"></a>02663 
<a name="l02664"></a>02664     }                           <span class="comment">/* endif -- PDU decryption */</span>
<a name="l02665"></a>02665 
<a name="l02666"></a>02666 
<a name="l02667"></a>02667     <span class="comment">/*</span>
<a name="l02668"></a>02668 <span class="comment">     * Calculate the biggest sPDU for the response (i.e., whole - ovrhd).</span>
<a name="l02669"></a>02669 <span class="comment">     *</span>
<a name="l02670"></a>02670 <span class="comment">     * FIX  Correct? </span>
<a name="l02671"></a>02671 <span class="comment">     */</span>
<a name="l02672"></a>02672     *maxSizeResponse = maxMsgSize - (end_of_overhead - wholeMsg);
<a name="l02673"></a>02673 
<a name="l02674"></a>02674 
<a name="l02675"></a>02675     DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;USM processing completed.\n&quot;</span>));
<a name="l02676"></a>02676 
<a name="l02677"></a>02677     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l02678"></a>02678 
<a name="l02679"></a>02679 }                               <span class="comment">/* end usm_process_in_msg() */</span>
<a name="l02680"></a>02680 
<a name="l02681"></a>02681 <span class="keywordtype">void</span>
<a name="l02682"></a>02682 usm_handle_report(<span class="keywordtype">void</span> *sessp,
<a name="l02683"></a>02683                   <a class="code" href="structnetsnmp__transport__s.html">netsnmp_transport</a> *transport, <a class="code" href="structsnmp__session.html" title="The snmp session structure.">netsnmp_session</a> *session,
<a name="l02684"></a>02684                   <span class="keywordtype">int</span> result, <a class="code" href="structsnmp__pdu.html" title="The snmp protocol data unit.">netsnmp_pdu</a> *pdu)
<a name="l02685"></a>02685 {
<a name="l02686"></a>02686     <span class="comment">/*</span>
<a name="l02687"></a>02687 <span class="comment">     * handle reportable errors </span>
<a name="l02688"></a>02688 <span class="comment">     */</span>
<a name="l02689"></a>02689 
<a name="l02690"></a>02690     <span class="comment">/* this will get in our way */</span>
<a name="l02691"></a>02691     usm_free_usmStateReference(pdu-&gt;securityStateRef);
<a name="l02692"></a>02692     pdu-&gt;securityStateRef = NULL;
<a name="l02693"></a>02693 
<a name="l02694"></a>02694     <span class="keywordflow">switch</span> (result) {
<a name="l02695"></a>02695     <span class="keywordflow">case</span> SNMPERR_USM_AUTHENTICATIONFAILURE:
<a name="l02696"></a>02696     {
<a name="l02697"></a>02697         <span class="keywordtype">int</span> res = session-&gt;<a class="code" href="structsnmp__session.html#afb3f06f6d767a95ebd59b35d2f10faf7" title="copy of library errno">s_snmp_errno</a>;
<a name="l02698"></a>02698         session-&gt;<a class="code" href="structsnmp__session.html#afb3f06f6d767a95ebd59b35d2f10faf7" title="copy of library errno">s_snmp_errno</a> = result;
<a name="l02699"></a>02699         <span class="keywordflow">if</span> (session-&gt;<a class="code" href="structsnmp__session.html#a3918c1cdd264f6a40ab06c457097a6d9" title="Function to interpret incoming data.">callback</a>) {
<a name="l02700"></a>02700             session-&gt;<a class="code" href="structsnmp__session.html#a3918c1cdd264f6a40ab06c457097a6d9" title="Function to interpret incoming data.">callback</a>(NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE,
<a name="l02701"></a>02701                               session, pdu-&gt;<a class="code" href="structsnmp__pdu.html#ad48db2c0383456117446e41e36f59b37" title="Request id - note: not incremented on retries.">reqid</a>, pdu,
<a name="l02702"></a>02702                               session-&gt;<a class="code" href="structsnmp__session.html#a8747794e036182a6967c3296aa5b251c" title="Pointer to data that the callback function may consider important.">callback_magic</a>);
<a name="l02703"></a>02703         }
<a name="l02704"></a>02704         session-&gt;<a class="code" href="structsnmp__session.html#afb3f06f6d767a95ebd59b35d2f10faf7" title="copy of library errno">s_snmp_errno</a> = res;
<a name="l02705"></a>02705     }  
<a name="l02706"></a>02706     <span class="keywordflow">case</span> SNMPERR_USM_UNKNOWNENGINEID:
<a name="l02707"></a>02707     <span class="keywordflow">case</span> SNMPERR_USM_UNKNOWNSECURITYNAME:
<a name="l02708"></a>02708     <span class="keywordflow">case</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL:
<a name="l02709"></a>02709     <span class="keywordflow">case</span> SNMPERR_USM_NOTINTIMEWINDOW:
<a name="l02710"></a>02710     <span class="keywordflow">case</span> SNMPERR_USM_DECRYPTIONERROR:
<a name="l02711"></a>02711 
<a name="l02712"></a>02712         <span class="keywordflow">if</span> (SNMP_CMD_CONFIRMED(pdu-&gt;<a class="code" href="structsnmp__pdu.html#a4b4dfa4964546623586c027cf1d68ca6" title="Type of this PDU.">command</a>) ||
<a name="l02713"></a>02713             (pdu-&gt;<a class="code" href="structsnmp__pdu.html#a4b4dfa4964546623586c027cf1d68ca6" title="Type of this PDU.">command</a> == 0
<a name="l02714"></a>02714              &amp;&amp; (pdu-&gt;flags &amp; SNMP_MSG_FLAG_RPRT_BIT))) {
<a name="l02715"></a>02715             <a class="code" href="structsnmp__pdu.html" title="The snmp protocol data unit.">netsnmp_pdu</a>    *pdu2;
<a name="l02716"></a>02716             <span class="keywordtype">int</span>             flags = pdu-&gt;flags;
<a name="l02717"></a>02717 
<a name="l02718"></a>02718             pdu-&gt;flags |= UCD_MSG_FLAG_FORCE_PDU_COPY;
<a name="l02719"></a>02719             pdu2 = snmp_clone_pdu(pdu);
<a name="l02720"></a>02720             pdu-&gt;flags = pdu2-&gt;flags = flags;
<a name="l02721"></a>02721             snmpv3_make_report(pdu2, result);
<a name="l02722"></a>02722             <span class="keywordflow">if</span> (0 == snmp_sess_send(sessp, pdu2)) {
<a name="l02723"></a>02723                 snmp_free_pdu(pdu2);
<a name="l02724"></a>02724                 <span class="comment">/*</span>
<a name="l02725"></a>02725 <span class="comment">                 * TODO: indicate error </span>
<a name="l02726"></a>02726 <span class="comment">                 */</span>
<a name="l02727"></a>02727             }
<a name="l02728"></a>02728         }
<a name="l02729"></a>02729         <span class="keywordflow">break</span>;
<a name="l02730"></a>02730     }       
<a name="l02731"></a>02731 }
<a name="l02732"></a>02732 
<a name="l02733"></a>02733 <span class="comment">/* sets up initial default session parameters */</span>
<a name="l02734"></a>02734 <span class="keywordtype">int</span>
<a name="l02735"></a>02735 usm_session_init(<a class="code" href="structsnmp__session.html" title="The snmp session structure.">netsnmp_session</a> *in_session, <a class="code" href="structsnmp__session.html" title="The snmp session structure.">netsnmp_session</a> *session)
<a name="l02736"></a>02736 {
<a name="l02737"></a>02737     <span class="keywordtype">char</span> *cp;
<a name="l02738"></a>02738     <span class="keywordtype">size_t</span> i;
<a name="l02739"></a>02739     
<a name="l02740"></a>02740     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href="structsnmp__session.html#af7a4c741fb6e45967ce17a3a6b71b740" title="Length of auth protocol oid.">securityAuthProtoLen</a> &gt; 0) {
<a name="l02741"></a>02741         session-&gt;<a class="code" href="structsnmp__session.html#acaa4215016fd2f317fbb61b4c55e66d5" title="auth protocol oid">securityAuthProto</a> =
<a name="l02742"></a>02742             snmp_duplicate_objid(in_session-&gt;<a class="code" href="structsnmp__session.html#acaa4215016fd2f317fbb61b4c55e66d5" title="auth protocol oid">securityAuthProto</a>,
<a name="l02743"></a>02743                                  in_session-&gt;<a class="code" href="structsnmp__session.html#af7a4c741fb6e45967ce17a3a6b71b740" title="Length of auth protocol oid.">securityAuthProtoLen</a>);
<a name="l02744"></a>02744         <span class="keywordflow">if</span> (session-&gt;<a class="code" href="structsnmp__session.html#acaa4215016fd2f317fbb61b4c55e66d5" title="auth protocol oid">securityAuthProto</a> == NULL) {
<a name="l02745"></a>02745             in_session-&gt;<a class="code" href="structsnmp__session.html#afb3f06f6d767a95ebd59b35d2f10faf7" title="copy of library errno">s_snmp_errno</a> = SNMPERR_MALLOC;
<a name="l02746"></a>02746             <span class="keywordflow">return</span> SNMPERR_MALLOC;
<a name="l02747"></a>02747         }
<a name="l02748"></a>02748     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (get_default_authtype(&amp;i) != NULL) {
<a name="l02749"></a>02749         session-&gt;<a class="code" href="structsnmp__session.html#acaa4215016fd2f317fbb61b4c55e66d5" title="auth protocol oid">securityAuthProto</a> =
<a name="l02750"></a>02750             snmp_duplicate_objid(get_default_authtype(NULL), i);
<a name="l02751"></a>02751         session-&gt;<a class="code" href="structsnmp__session.html#af7a4c741fb6e45967ce17a3a6b71b740" title="Length of auth protocol oid.">securityAuthProtoLen</a> = i;
<a name="l02752"></a>02752     }
<a name="l02753"></a>02753 
<a name="l02754"></a>02754     <span class="keywordflow">if</span> (in_session-&gt;<a class="code" href="structsnmp__session.html#a2cf935eb076df4886ffaf6c5047834fb" title="Length of priv protocol oid.">securityPrivProtoLen</a> &gt; 0) {
<a name="l02755"></a>02755         session-&gt;<a class="code" href="structsnmp__session.html#a065ac4c2ac34954a61cee33456cd2b55" title="priv protocol oid">securityPrivProto</a> =
<a name="l02756"></a>02756             snmp_duplicate_objid(in_session-&gt;<a class="code" href="structsnmp__session.html#a065ac4c2ac34954a61cee33456cd2b55" title="priv protocol oid">securityPrivProto</a>,
<a name="l02757"></a>02757                                  in_session-&gt;<a class="code" href="structsnmp__session.html#a2cf935eb076df4886ffaf6c5047834fb" title="Length of priv protocol oid.">securityPrivProtoLen</a>);
<a name="l02758"></a>02758         <span class="keywordflow">if</span> (session-&gt;<a class="code" href="structsnmp__session.html#a065ac4c2ac34954a61cee33456cd2b55" title="priv protocol oid">securityPrivProto</a> == NULL) {
<a name="l02759"></a>02759             in_session-&gt;<a class="code" href="structsnmp__session.html#afb3f06f6d767a95ebd59b35d2f10faf7" title="copy of library errno">s_snmp_errno</a> = SNMPERR_MALLOC;
<a name="l02760"></a>02760             <span class="keywordflow">return</span> SNMPERR_MALLOC;
<a name="l02761"></a>02761         }
<a name="l02762"></a>02762     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (get_default_privtype(&amp;i) != NULL) {
<a name="l02763"></a>02763         session-&gt;<a class="code" href="structsnmp__session.html#a065ac4c2ac34954a61cee33456cd2b55" title="priv protocol oid">securityPrivProto</a> =
<a name="l02764"></a>02764             snmp_duplicate_objid(get_default_privtype(NULL), i);
<a name="l02765"></a>02765         session-&gt;<a class="code" href="structsnmp__session.html#a2cf935eb076df4886ffaf6c5047834fb" title="Length of priv protocol oid.">securityPrivProtoLen</a> = i;
<a name="l02766"></a>02766     }
<a name="l02767"></a>02767 
<a name="l02768"></a>02768     <span class="keywordflow">if</span> ((in_session-&gt;<a class="code" href="structsnmp__session.html#a8149ffe5cea795e5080b3cb6f322b5c5" title="Length of Ku for auth protocol.">securityAuthKeyLen</a> &lt;= 0) &amp;&amp;
<a name="l02769"></a>02769         ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
<a name="l02770"></a>02770                                      NETSNMP_DS_LIB_AUTHMASTERKEY)))) {
<a name="l02771"></a>02771         <span class="keywordtype">size_t</span> buflen = <span class="keyword">sizeof</span>(session-&gt;<a class="code" href="structsnmp__session.html#a72b041b55b2b9ad6540644845cbe063f" title="Ku for auth protocol XXX.">securityAuthKey</a>);
<a name="l02772"></a>02772         u_char *tmpp = session-&gt;<a class="code" href="structsnmp__session.html#a72b041b55b2b9ad6540644845cbe063f" title="Ku for auth protocol XXX.">securityAuthKey</a>;
<a name="l02773"></a>02773         session-&gt;<a class="code" href="structsnmp__session.html#a8149ffe5cea795e5080b3cb6f322b5c5" title="Length of Ku for auth protocol.">securityAuthKeyLen</a> = 0;
<a name="l02774"></a>02774         <span class="comment">/* it will be a hex string */</span>
<a name="l02775"></a>02775         <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#gabcc7d0fd7e0145ef532da8d0949c9131" title="convert an ASCII hex string to binary">snmp_hex_to_binary</a>(&amp;tmpp, &amp;buflen,
<a name="l02776"></a>02776                                 &amp;session-&gt;<a class="code" href="structsnmp__session.html#a8149ffe5cea795e5080b3cb6f322b5c5" title="Length of Ku for auth protocol.">securityAuthKeyLen</a>, 0, cp)) {
<a name="l02777"></a>02777             snmp_set_detail(<span class="stringliteral">&quot;error parsing authentication master key&quot;</span>);
<a name="l02778"></a>02778             <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l02779"></a>02779         }
<a name="l02780"></a>02780     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((in_session-&gt;<a class="code" href="structsnmp__session.html#a8149ffe5cea795e5080b3cb6f322b5c5" title="Length of Ku for auth protocol.">securityAuthKeyLen</a> &lt;= 0) &amp;&amp;
<a name="l02781"></a>02781                ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
<a name="l02782"></a>02782                                             NETSNMP_DS_LIB_AUTHPASSPHRASE)) ||
<a name="l02783"></a>02783                 (cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
<a name="l02784"></a>02784                                             NETSNMP_DS_LIB_PASSPHRASE)))) {
<a name="l02785"></a>02785         session-&gt;<a class="code" href="structsnmp__session.html#a8149ffe5cea795e5080b3cb6f322b5c5" title="Length of Ku for auth protocol.">securityAuthKeyLen</a> = USM_AUTH_KU_LEN;
<a name="l02786"></a>02786         <span class="keywordflow">if</span> (generate_Ku(session-&gt;<a class="code" href="structsnmp__session.html#acaa4215016fd2f317fbb61b4c55e66d5" title="auth protocol oid">securityAuthProto</a>,
<a name="l02787"></a>02787                         session-&gt;<a class="code" href="structsnmp__session.html#af7a4c741fb6e45967ce17a3a6b71b740" title="Length of auth protocol oid.">securityAuthProtoLen</a>,
<a name="l02788"></a>02788                         (u_char *) cp, strlen(cp),
<a name="l02789"></a>02789                         session-&gt;<a class="code" href="structsnmp__session.html#a72b041b55b2b9ad6540644845cbe063f" title="Ku for auth protocol XXX.">securityAuthKey</a>,
<a name="l02790"></a>02790                         &amp;session-&gt;<a class="code" href="structsnmp__session.html#a8149ffe5cea795e5080b3cb6f322b5c5" title="Length of Ku for auth protocol.">securityAuthKeyLen</a>) != SNMPERR_SUCCESS) {
<a name="l02791"></a>02791             snmp_set_detail
<a name="l02792"></a>02792                 (<span class="stringliteral">&quot;Error generating a key (Ku) from the supplied authentication pass phrase.&quot;</span>);
<a name="l02793"></a>02793             <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l02794"></a>02794         }
<a name="l02795"></a>02795     }
<a name="l02796"></a>02796 
<a name="l02797"></a>02797     
<a name="l02798"></a>02798     <span class="keywordflow">if</span> ((in_session-&gt;<a class="code" href="structsnmp__session.html#a146582d1c5fb7ac68cc0302c673b97bb" title="Length of Ku for priv protocol.">securityPrivKeyLen</a> &lt;= 0) &amp;&amp;
<a name="l02799"></a>02799         ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
<a name="l02800"></a>02800                                      NETSNMP_DS_LIB_PRIVMASTERKEY)))) {
<a name="l02801"></a>02801         <span class="keywordtype">size_t</span> buflen = <span class="keyword">sizeof</span>(session-&gt;<a class="code" href="structsnmp__session.html#a19ec576d5360683569d1ade5c5a93031" title="Ku for privacy protocol XXX.">securityPrivKey</a>);
<a name="l02802"></a>02802         u_char *tmpp = session-&gt;<a class="code" href="structsnmp__session.html#a19ec576d5360683569d1ade5c5a93031" title="Ku for privacy protocol XXX.">securityPrivKey</a>;
<a name="l02803"></a>02803         session-&gt;<a class="code" href="structsnmp__session.html#a146582d1c5fb7ac68cc0302c673b97bb" title="Length of Ku for priv protocol.">securityPrivKeyLen</a> = 0;
<a name="l02804"></a>02804         <span class="comment">/* it will be a hex string */</span>
<a name="l02805"></a>02805         <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#gabcc7d0fd7e0145ef532da8d0949c9131" title="convert an ASCII hex string to binary">snmp_hex_to_binary</a>(&amp;tmpp, &amp;buflen,
<a name="l02806"></a>02806                                 &amp;session-&gt;<a class="code" href="structsnmp__session.html#a146582d1c5fb7ac68cc0302c673b97bb" title="Length of Ku for priv protocol.">securityPrivKeyLen</a>, 0, cp)) {
<a name="l02807"></a>02807             snmp_set_detail(<span class="stringliteral">&quot;error parsing encryption master key&quot;</span>);
<a name="l02808"></a>02808             <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l02809"></a>02809         }
<a name="l02810"></a>02810     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((in_session-&gt;<a class="code" href="structsnmp__session.html#a146582d1c5fb7ac68cc0302c673b97bb" title="Length of Ku for priv protocol.">securityPrivKeyLen</a> &lt;= 0) &amp;&amp;
<a name="l02811"></a>02811                ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
<a name="l02812"></a>02812                                             NETSNMP_DS_LIB_PRIVPASSPHRASE)) ||
<a name="l02813"></a>02813                 (cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
<a name="l02814"></a>02814                                             NETSNMP_DS_LIB_PASSPHRASE)))) {
<a name="l02815"></a>02815         session-&gt;<a class="code" href="structsnmp__session.html#a146582d1c5fb7ac68cc0302c673b97bb" title="Length of Ku for priv protocol.">securityPrivKeyLen</a> = USM_PRIV_KU_LEN;
<a name="l02816"></a>02816         <span class="keywordflow">if</span> (generate_Ku(session-&gt;<a class="code" href="structsnmp__session.html#acaa4215016fd2f317fbb61b4c55e66d5" title="auth protocol oid">securityAuthProto</a>,
<a name="l02817"></a>02817                         session-&gt;<a class="code" href="structsnmp__session.html#af7a4c741fb6e45967ce17a3a6b71b740" title="Length of auth protocol oid.">securityAuthProtoLen</a>,
<a name="l02818"></a>02818                         (u_char *) cp, strlen(cp),
<a name="l02819"></a>02819                         session-&gt;<a class="code" href="structsnmp__session.html#a19ec576d5360683569d1ade5c5a93031" title="Ku for privacy protocol XXX.">securityPrivKey</a>,
<a name="l02820"></a>02820                         &amp;session-&gt;<a class="code" href="structsnmp__session.html#a146582d1c5fb7ac68cc0302c673b97bb" title="Length of Ku for priv protocol.">securityPrivKeyLen</a>) != SNMPERR_SUCCESS) {
<a name="l02821"></a>02821             snmp_set_detail
<a name="l02822"></a>02822                 (<span class="stringliteral">&quot;Error generating a key (Ku) from the supplied privacy pass phrase.&quot;</span>);
<a name="l02823"></a>02823             <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l02824"></a>02824         }
<a name="l02825"></a>02825     }
<a name="l02826"></a>02826 
<a name="l02827"></a>02827     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l02828"></a>02828 }
<a name="l02829"></a>02829 
<a name="l02830"></a>02830 
<a name="l02831"></a>02831 <span class="comment">/*</span>
<a name="l02832"></a>02832 <span class="comment"> * usm_create_user_from_session(netsnmp_session *session):</span>
<a name="l02833"></a>02833 <span class="comment"> * </span>
<a name="l02834"></a>02834 <span class="comment"> * creates a user in the usm table from the information in a session.</span>
<a name="l02835"></a>02835 <span class="comment"> * If the user already exists, it is updated with the current</span>
<a name="l02836"></a>02836 <span class="comment"> * information from the session</span>
<a name="l02837"></a>02837 <span class="comment"> * </span>
<a name="l02838"></a>02838 <span class="comment"> * Parameters:</span>
<a name="l02839"></a>02839 <span class="comment"> * session -- IN: pointer to the session to use when creating the user.</span>
<a name="l02840"></a>02840 <span class="comment"> * </span>
<a name="l02841"></a>02841 <span class="comment"> * Returns:</span>
<a name="l02842"></a>02842 <span class="comment"> * SNMPERR_SUCCESS</span>
<a name="l02843"></a>02843 <span class="comment"> * SNMPERR_GENERR </span>
<a name="l02844"></a>02844 <span class="comment"> */</span>
<a name="l02845"></a>02845 <span class="keywordtype">int</span>
<a name="l02846"></a>02846 usm_create_user_from_session(<a class="code" href="structsnmp__session.html" title="The snmp session structure.">netsnmp_session</a> * session)
<a name="l02847"></a>02847 {
<a name="l02848"></a>02848     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *user;
<a name="l02849"></a>02849     <span class="keywordtype">int</span>             user_just_created = 0;
<a name="l02850"></a>02850     <span class="keywordtype">char</span> *cp;
<a name="l02851"></a>02851 
<a name="l02852"></a>02852     <span class="comment">/*</span>
<a name="l02853"></a>02853 <span class="comment">     * - don&#39;t create-another/copy-into user for this session by default</span>
<a name="l02854"></a>02854 <span class="comment">     * - bail now (no error) if we don&#39;t have an engineID</span>
<a name="l02855"></a>02855 <span class="comment">     */</span>
<a name="l02856"></a>02856     <span class="keywordflow">if</span> (SNMP_FLAGS_USER_CREATED == (session-&gt;flags &amp; SNMP_FLAGS_USER_CREATED) ||
<a name="l02857"></a>02857         session-&gt;<a class="code" href="structsnmp__session.html#a7bf36554eeaa2eedb5ba5ff7ec76f1a8" title="snmp security model, v1, v2c, usm">securityModel</a> != SNMP_SEC_MODEL_USM ||
<a name="l02858"></a>02858         session-&gt;<a class="code" href="structsnmp__session.html#ae50774f611e22f73df23e97094077e49" title="snmp version">version</a> != SNMP_VERSION_3 ||
<a name="l02859"></a>02859         session-&gt;<a class="code" href="structsnmp__session.html#aded39fd06dcaa1159633d3783b9e4941" title="Length of securityName.">securityNameLen</a> == 0 ||
<a name="l02860"></a>02860         session-&gt;<a class="code" href="structsnmp__session.html#a08a450c1b5acbf798b5473c36395edf5" title="Length of contextEngineID.">securityEngineIDLen</a> == 0)
<a name="l02861"></a>02861         <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l02862"></a>02862 
<a name="l02863"></a>02863     DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;no flag defined...  continuing\n&quot;</span>));
<a name="l02864"></a>02864     session-&gt;flags |= SNMP_FLAGS_USER_CREATED;
<a name="l02865"></a>02865 
<a name="l02866"></a>02866     <span class="comment">/*</span>
<a name="l02867"></a>02867 <span class="comment">     * now that we have the engineID, create an entry in the USM list</span>
<a name="l02868"></a>02868 <span class="comment">     * for this user using the information in the session </span>
<a name="l02869"></a>02869 <span class="comment">     */</span>
<a name="l02870"></a>02870     user = usm_get_user_from_list(session-&gt;<a class="code" href="structsnmp__session.html#aa11c998a39ac508258ccf9169ea22a89" title="authoritative snmpEngineID">securityEngineID</a>,
<a name="l02871"></a>02871                                   session-&gt;<a class="code" href="structsnmp__session.html#a08a450c1b5acbf798b5473c36395edf5" title="Length of contextEngineID.">securityEngineIDLen</a>,
<a name="l02872"></a>02872                                   session-&gt;<a class="code" href="structsnmp__session.html#a247882bf1e340be5ec1d22d41d5a0179" title="on behalf of this principal">securityName</a>,
<a name="l02873"></a>02873                                   usm_get_userList(), 0);
<a name="l02874"></a>02874     DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;user exists? x=%p\n&quot;</span>, user));
<a name="l02875"></a>02875     <span class="keywordflow">if</span> (user == NULL) {
<a name="l02876"></a>02876         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Building user %s...\n&quot;</span>,
<a name="l02877"></a>02877                     session-&gt;<a class="code" href="structsnmp__session.html#a247882bf1e340be5ec1d22d41d5a0179" title="on behalf of this principal">securityName</a>));
<a name="l02878"></a>02878         <span class="comment">/*</span>
<a name="l02879"></a>02879 <span class="comment">         * user doesn&#39;t exist so we create and add it </span>
<a name="l02880"></a>02880 <span class="comment">         */</span>
<a name="l02881"></a>02881         user = (<span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *) calloc(1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a>));
<a name="l02882"></a>02882         <span class="keywordflow">if</span> (user == NULL)
<a name="l02883"></a>02883             <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l02884"></a>02884 
<a name="l02885"></a>02885         <span class="comment">/*</span>
<a name="l02886"></a>02886 <span class="comment">         * copy in the securityName </span>
<a name="l02887"></a>02887 <span class="comment">         */</span>
<a name="l02888"></a>02888         <span class="keywordflow">if</span> (session-&gt;<a class="code" href="structsnmp__session.html#a247882bf1e340be5ec1d22d41d5a0179" title="on behalf of this principal">securityName</a>) {
<a name="l02889"></a>02889             user-&gt;name = strdup(session-&gt;<a class="code" href="structsnmp__session.html#a247882bf1e340be5ec1d22d41d5a0179" title="on behalf of this principal">securityName</a>);
<a name="l02890"></a>02890             user-&gt;secName = strdup(session-&gt;<a class="code" href="structsnmp__session.html#a247882bf1e340be5ec1d22d41d5a0179" title="on behalf of this principal">securityName</a>);
<a name="l02891"></a>02891             <span class="keywordflow">if</span> (user-&gt;name == NULL || user-&gt;secName == NULL) {
<a name="l02892"></a>02892                 usm_free_user(user);
<a name="l02893"></a>02893                 <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l02894"></a>02894             }
<a name="l02895"></a>02895         }
<a name="l02896"></a>02896 
<a name="l02897"></a>02897         <span class="comment">/*</span>
<a name="l02898"></a>02898 <span class="comment">         * copy in the engineID </span>
<a name="l02899"></a>02899 <span class="comment">         */</span>
<a name="l02900"></a>02900         <span class="keywordflow">if</span> (<a class="code" href="group__util.html#ga098ada1e30ad7ee207ba90b73db7000a" title="Duplicates a memory block.">memdup</a>(&amp;user-&gt;engineID, session-&gt;<a class="code" href="structsnmp__session.html#aa11c998a39ac508258ccf9169ea22a89" title="authoritative snmpEngineID">securityEngineID</a>,
<a name="l02901"></a>02901                    session-&gt;<a class="code" href="structsnmp__session.html#a08a450c1b5acbf798b5473c36395edf5" title="Length of contextEngineID.">securityEngineIDLen</a>) != SNMPERR_SUCCESS) {
<a name="l02902"></a>02902             usm_free_user(user);
<a name="l02903"></a>02903             <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l02904"></a>02904         }
<a name="l02905"></a>02905         user-&gt;engineIDLen = session-&gt;<a class="code" href="structsnmp__session.html#a08a450c1b5acbf798b5473c36395edf5" title="Length of contextEngineID.">securityEngineIDLen</a>;
<a name="l02906"></a>02906 
<a name="l02907"></a>02907         user_just_created = 1;
<a name="l02908"></a>02908     }
<a name="l02909"></a>02909 
<a name="l02910"></a>02910     <span class="comment">/*</span>
<a name="l02911"></a>02911 <span class="comment">     * copy the auth protocol </span>
<a name="l02912"></a>02912 <span class="comment">     */</span>
<a name="l02913"></a>02913     <span class="keywordflow">if</span> (user-&gt;authProtocol == NULL &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#acaa4215016fd2f317fbb61b4c55e66d5" title="auth protocol oid">securityAuthProto</a> != NULL) {
<a name="l02914"></a>02914         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;authProtocol);
<a name="l02915"></a>02915         user-&gt;authProtocol =
<a name="l02916"></a>02916             snmp_duplicate_objid(session-&gt;<a class="code" href="structsnmp__session.html#acaa4215016fd2f317fbb61b4c55e66d5" title="auth protocol oid">securityAuthProto</a>,
<a name="l02917"></a>02917                                  session-&gt;<a class="code" href="structsnmp__session.html#af7a4c741fb6e45967ce17a3a6b71b740" title="Length of auth protocol oid.">securityAuthProtoLen</a>);
<a name="l02918"></a>02918         <span class="keywordflow">if</span> (user-&gt;authProtocol == NULL) {
<a name="l02919"></a>02919             usm_free_user(user);
<a name="l02920"></a>02920             <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l02921"></a>02921         }
<a name="l02922"></a>02922         user-&gt;authProtocolLen = session-&gt;<a class="code" href="structsnmp__session.html#af7a4c741fb6e45967ce17a3a6b71b740" title="Length of auth protocol oid.">securityAuthProtoLen</a>;
<a name="l02923"></a>02923     }
<a name="l02924"></a>02924 
<a name="l02925"></a>02925     <span class="comment">/*</span>
<a name="l02926"></a>02926 <span class="comment">     * copy the priv protocol </span>
<a name="l02927"></a>02927 <span class="comment">     */</span>
<a name="l02928"></a>02928     <span class="keywordflow">if</span> (user-&gt;privProtocol == NULL &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#a065ac4c2ac34954a61cee33456cd2b55" title="priv protocol oid">securityPrivProto</a> != NULL) {
<a name="l02929"></a>02929         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;privProtocol);
<a name="l02930"></a>02930         user-&gt;privProtocol =
<a name="l02931"></a>02931             snmp_duplicate_objid(session-&gt;<a class="code" href="structsnmp__session.html#a065ac4c2ac34954a61cee33456cd2b55" title="priv protocol oid">securityPrivProto</a>,
<a name="l02932"></a>02932                                  session-&gt;<a class="code" href="structsnmp__session.html#a2cf935eb076df4886ffaf6c5047834fb" title="Length of priv protocol oid.">securityPrivProtoLen</a>);
<a name="l02933"></a>02933         <span class="keywordflow">if</span> (user-&gt;privProtocol == NULL) {
<a name="l02934"></a>02934             usm_free_user(user);
<a name="l02935"></a>02935             <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l02936"></a>02936         }
<a name="l02937"></a>02937         user-&gt;privProtocolLen = session-&gt;<a class="code" href="structsnmp__session.html#a2cf935eb076df4886ffaf6c5047834fb" title="Length of priv protocol oid.">securityPrivProtoLen</a>;
<a name="l02938"></a>02938     }
<a name="l02939"></a>02939 
<a name="l02940"></a>02940     <span class="comment">/*</span>
<a name="l02941"></a>02941 <span class="comment">     * copy in the authentication Key.  If not localized, localize it </span>
<a name="l02942"></a>02942 <span class="comment">     */</span>
<a name="l02943"></a>02943     <span class="keywordflow">if</span> (user-&gt;authKey == NULL) {
<a name="l02944"></a>02944         <span class="keywordflow">if</span> (session-&gt;<a class="code" href="structsnmp__session.html#ad75654aafbe5319b63296e8413a7f817" title="Kul for auth protocol.">securityAuthLocalKey</a> != NULL
<a name="l02945"></a>02945             &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#abfeac9d37631b38284a5dbd5a0c8dd86" title="Length of Kul for auth protocol XXX.">securityAuthLocalKeyLen</a> != 0) {
<a name="l02946"></a>02946             <span class="comment">/* already localized key passed in.  use it */</span>
<a name="l02947"></a>02947             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;authKey);
<a name="l02948"></a>02948             <span class="keywordflow">if</span> (<a class="code" href="group__util.html#ga098ada1e30ad7ee207ba90b73db7000a" title="Duplicates a memory block.">memdup</a>(&amp;user-&gt;authKey, session-&gt;<a class="code" href="structsnmp__session.html#ad75654aafbe5319b63296e8413a7f817" title="Kul for auth protocol.">securityAuthLocalKey</a>,
<a name="l02949"></a>02949                        session-&gt;<a class="code" href="structsnmp__session.html#abfeac9d37631b38284a5dbd5a0c8dd86" title="Length of Kul for auth protocol XXX.">securityAuthLocalKeyLen</a>) != SNMPERR_SUCCESS) {
<a name="l02950"></a>02950                 usm_free_user(user);
<a name="l02951"></a>02951                 <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l02952"></a>02952             }
<a name="l02953"></a>02953             user-&gt;authKeyLen = session-&gt;<a class="code" href="structsnmp__session.html#abfeac9d37631b38284a5dbd5a0c8dd86" title="Length of Kul for auth protocol XXX.">securityAuthLocalKeyLen</a>;
<a name="l02954"></a>02954         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (session-&gt;<a class="code" href="structsnmp__session.html#a72b041b55b2b9ad6540644845cbe063f" title="Ku for auth protocol XXX.">securityAuthKey</a> != NULL
<a name="l02955"></a>02955                    &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#a8149ffe5cea795e5080b3cb6f322b5c5" title="Length of Ku for auth protocol.">securityAuthKeyLen</a> != 0) {
<a name="l02956"></a>02956             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;authKey);
<a name="l02957"></a>02957             user-&gt;authKey = (u_char *) calloc(1, USM_LENGTH_KU_HASHBLOCK);
<a name="l02958"></a>02958             <span class="keywordflow">if</span> (user-&gt;authKey == NULL) {
<a name="l02959"></a>02959                 usm_free_user(user);
<a name="l02960"></a>02960                 <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l02961"></a>02961             }
<a name="l02962"></a>02962             user-&gt;authKeyLen = USM_LENGTH_KU_HASHBLOCK;
<a name="l02963"></a>02963             <span class="keywordflow">if</span> (generate_kul(user-&gt;authProtocol, user-&gt;authProtocolLen,
<a name="l02964"></a>02964                              session-&gt;<a class="code" href="structsnmp__session.html#aa11c998a39ac508258ccf9169ea22a89" title="authoritative snmpEngineID">securityEngineID</a>,
<a name="l02965"></a>02965                              session-&gt;<a class="code" href="structsnmp__session.html#a08a450c1b5acbf798b5473c36395edf5" title="Length of contextEngineID.">securityEngineIDLen</a>,
<a name="l02966"></a>02966                              session-&gt;<a class="code" href="structsnmp__session.html#a72b041b55b2b9ad6540644845cbe063f" title="Ku for auth protocol XXX.">securityAuthKey</a>,
<a name="l02967"></a>02967                              session-&gt;<a class="code" href="structsnmp__session.html#a8149ffe5cea795e5080b3cb6f322b5c5" title="Length of Ku for auth protocol.">securityAuthKeyLen</a>, user-&gt;authKey,
<a name="l02968"></a>02968                              &amp;user-&gt;authKeyLen) != SNMPERR_SUCCESS) {
<a name="l02969"></a>02969                 usm_free_user(user);
<a name="l02970"></a>02970                 <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l02971"></a>02971             }
<a name="l02972"></a>02972         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
<a name="l02973"></a>02973                                                NETSNMP_DS_LIB_AUTHLOCALIZEDKEY))) {
<a name="l02974"></a>02974             <span class="keywordtype">size_t</span> buflen = USM_AUTH_KU_LEN;
<a name="l02975"></a>02975             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;authKey);
<a name="l02976"></a>02976             user-&gt;authKey = (u_char *)malloc(buflen); <span class="comment">/* max length needed */</span>
<a name="l02977"></a>02977             user-&gt;authKeyLen = 0;
<a name="l02978"></a>02978             <span class="comment">/* it will be a hex string */</span>
<a name="l02979"></a>02979             <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#gabcc7d0fd7e0145ef532da8d0949c9131" title="convert an ASCII hex string to binary">snmp_hex_to_binary</a>(&amp;user-&gt;authKey, &amp;buflen, &amp;user-&gt;authKeyLen,
<a name="l02980"></a>02980                                     0, cp)) {
<a name="l02981"></a>02981                 usm_free_user(user);
<a name="l02982"></a>02982                 <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l02983"></a>02983             }
<a name="l02984"></a>02984         }
<a name="l02985"></a>02985     }
<a name="l02986"></a>02986 
<a name="l02987"></a>02987     <span class="comment">/*</span>
<a name="l02988"></a>02988 <span class="comment">     * copy in the privacy Key.  If not localized, localize it </span>
<a name="l02989"></a>02989 <span class="comment">     */</span>
<a name="l02990"></a>02990     <span class="keywordflow">if</span> (user-&gt;privKey == NULL) {
<a name="l02991"></a>02991         <span class="keywordflow">if</span> (session-&gt;<a class="code" href="structsnmp__session.html#a7c38601198b252b584f77daed313280e" title="Kul for priv protocol.">securityPrivLocalKey</a> != NULL
<a name="l02992"></a>02992             &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#a2ceedc6dca38076e132645a50afc2fbf" title="Length of Kul for priv protocol XXX.">securityPrivLocalKeyLen</a> != 0) {
<a name="l02993"></a>02993             <span class="comment">/* already localized key passed in.  use it */</span>
<a name="l02994"></a>02994             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;privKey);
<a name="l02995"></a>02995             <span class="keywordflow">if</span> (<a class="code" href="group__util.html#ga098ada1e30ad7ee207ba90b73db7000a" title="Duplicates a memory block.">memdup</a>(&amp;user-&gt;privKey, session-&gt;<a class="code" href="structsnmp__session.html#a7c38601198b252b584f77daed313280e" title="Kul for priv protocol.">securityPrivLocalKey</a>,
<a name="l02996"></a>02996                        session-&gt;<a class="code" href="structsnmp__session.html#a2ceedc6dca38076e132645a50afc2fbf" title="Length of Kul for priv protocol XXX.">securityPrivLocalKeyLen</a>) != SNMPERR_SUCCESS) {
<a name="l02997"></a>02997                 usm_free_user(user);
<a name="l02998"></a>02998                 <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l02999"></a>02999             }
<a name="l03000"></a>03000             user-&gt;privKeyLen = session-&gt;<a class="code" href="structsnmp__session.html#a2ceedc6dca38076e132645a50afc2fbf" title="Length of Kul for priv protocol XXX.">securityPrivLocalKeyLen</a>;
<a name="l03001"></a>03001         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (session-&gt;<a class="code" href="structsnmp__session.html#a19ec576d5360683569d1ade5c5a93031" title="Ku for privacy protocol XXX.">securityPrivKey</a> != NULL
<a name="l03002"></a>03002                    &amp;&amp; session-&gt;<a class="code" href="structsnmp__session.html#a146582d1c5fb7ac68cc0302c673b97bb" title="Length of Ku for priv protocol.">securityPrivKeyLen</a> != 0) {
<a name="l03003"></a>03003             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;privKey);
<a name="l03004"></a>03004             user-&gt;privKey = (u_char *) calloc(1, USM_LENGTH_KU_HASHBLOCK);
<a name="l03005"></a>03005             <span class="keywordflow">if</span> (user-&gt;privKey == NULL) {
<a name="l03006"></a>03006                 usm_free_user(user);
<a name="l03007"></a>03007                 <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l03008"></a>03008             }
<a name="l03009"></a>03009             user-&gt;privKeyLen = USM_LENGTH_KU_HASHBLOCK;
<a name="l03010"></a>03010             <span class="keywordflow">if</span> (generate_kul(user-&gt;authProtocol, user-&gt;authProtocolLen,
<a name="l03011"></a>03011                              session-&gt;<a class="code" href="structsnmp__session.html#aa11c998a39ac508258ccf9169ea22a89" title="authoritative snmpEngineID">securityEngineID</a>,
<a name="l03012"></a>03012                              session-&gt;<a class="code" href="structsnmp__session.html#a08a450c1b5acbf798b5473c36395edf5" title="Length of contextEngineID.">securityEngineIDLen</a>,
<a name="l03013"></a>03013                              session-&gt;<a class="code" href="structsnmp__session.html#a19ec576d5360683569d1ade5c5a93031" title="Ku for privacy protocol XXX.">securityPrivKey</a>,
<a name="l03014"></a>03014                              session-&gt;<a class="code" href="structsnmp__session.html#a146582d1c5fb7ac68cc0302c673b97bb" title="Length of Ku for priv protocol.">securityPrivKeyLen</a>, user-&gt;privKey,
<a name="l03015"></a>03015                              &amp;user-&gt;privKeyLen) != SNMPERR_SUCCESS) {
<a name="l03016"></a>03016                 usm_free_user(user);
<a name="l03017"></a>03017                 <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l03018"></a>03018             }
<a name="l03019"></a>03019         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((cp = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
<a name="l03020"></a>03020                                                NETSNMP_DS_LIB_PRIVLOCALIZEDKEY))) {
<a name="l03021"></a>03021             <span class="keywordtype">size_t</span> buflen = USM_PRIV_KU_LEN;
<a name="l03022"></a>03022             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;privKey);
<a name="l03023"></a>03023             user-&gt;privKey = (u_char *)malloc(buflen); <span class="comment">/* max length needed */</span>
<a name="l03024"></a>03024             user-&gt;privKeyLen = 0;
<a name="l03025"></a>03025             <span class="comment">/* it will be a hex string */</span>
<a name="l03026"></a>03026             <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#gabcc7d0fd7e0145ef532da8d0949c9131" title="convert an ASCII hex string to binary">snmp_hex_to_binary</a>(&amp;user-&gt;privKey, &amp;buflen, &amp;user-&gt;privKeyLen,
<a name="l03027"></a>03027                                     0, cp)) {
<a name="l03028"></a>03028                 usm_free_user(user);
<a name="l03029"></a>03029                 <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l03030"></a>03030             }
<a name="l03031"></a>03031         }
<a name="l03032"></a>03032     }
<a name="l03033"></a>03033 
<a name="l03034"></a>03034     <span class="keywordflow">if</span> (user_just_created) {
<a name="l03035"></a>03035         <span class="comment">/*</span>
<a name="l03036"></a>03036 <span class="comment">         * add the user into the database </span>
<a name="l03037"></a>03037 <span class="comment">         */</span>
<a name="l03038"></a>03038         user-&gt;userStatus = RS_ACTIVE;
<a name="l03039"></a>03039         user-&gt;userStorageType = ST_READONLY;
<a name="l03040"></a>03040         usm_add_user(user);
<a name="l03041"></a>03041     }
<a name="l03042"></a>03042 
<a name="l03043"></a>03043     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l03044"></a>03044 
<a name="l03045"></a>03045 
<a name="l03046"></a>03046 }
<a name="l03047"></a>03047 
<a name="l03048"></a>03048 <span class="comment">/* A wrapper around the hook */</span>
<a name="l03049"></a>03049 <span class="keywordtype">int</span>
<a name="l03050"></a>03050 usm_create_user_from_session_hook(<span class="keywordtype">void</span> *slp, <a class="code" href="structsnmp__session.html" title="The snmp session structure.">netsnmp_session</a> *session)
<a name="l03051"></a>03051 {
<a name="l03052"></a>03052     DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;potentially bootstrapping the USM table from session data\n&quot;</span>));
<a name="l03053"></a>03053     <span class="keywordflow">return</span> usm_create_user_from_session(session);
<a name="l03054"></a>03054 }
<a name="l03055"></a>03055 
<a name="l03056"></a>03056 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03057"></a>03057 usm_build_probe_pdu(<a class="code" href="structsnmp__pdu.html" title="The snmp protocol data unit.">netsnmp_pdu</a> **pdu)
<a name="l03058"></a>03058 {
<a name="l03059"></a>03059     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *user;
<a name="l03060"></a>03060 
<a name="l03061"></a>03061     <span class="comment">/*</span>
<a name="l03062"></a>03062 <span class="comment">     * create the pdu </span>
<a name="l03063"></a>03063 <span class="comment">     */</span>
<a name="l03064"></a>03064     <span class="keywordflow">if</span> (!pdu)
<a name="l03065"></a>03065         <span class="keywordflow">return</span> -1;
<a name="l03066"></a>03066     *pdu = snmp_pdu_create(SNMP_MSG_GET);
<a name="l03067"></a>03067     <span class="keywordflow">if</span> (!(*pdu))
<a name="l03068"></a>03068         <span class="keywordflow">return</span> -1;
<a name="l03069"></a>03069     (*pdu)-&gt;version = SNMP_VERSION_3;
<a name="l03070"></a>03070     (*pdu)-&gt;securityName = strdup(<span class="stringliteral">&quot;&quot;</span>);
<a name="l03071"></a>03071     (*pdu)-&gt;securityNameLen = strlen((*pdu)-&gt;securityName);
<a name="l03072"></a>03072     (*pdu)-&gt;securityLevel = SNMP_SEC_LEVEL_NOAUTH;
<a name="l03073"></a>03073     (*pdu)-&gt;securityModel = SNMP_SEC_MODEL_USM;
<a name="l03074"></a>03074 
<a name="l03075"></a>03075     <span class="comment">/*</span>
<a name="l03076"></a>03076 <span class="comment">     * create the empty user </span>
<a name="l03077"></a>03077 <span class="comment">     */</span>
<a name="l03078"></a>03078     user = usm_get_user(NULL, 0, (*pdu)-&gt;securityName);
<a name="l03079"></a>03079     <span class="keywordflow">if</span> (user == NULL) {
<a name="l03080"></a>03080         user = (<span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *) calloc(1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a>));
<a name="l03081"></a>03081         <span class="keywordflow">if</span> (user == NULL) {
<a name="l03082"></a>03082             snmp_free_pdu(*pdu);
<a name="l03083"></a>03083             *pdu = (<a class="code" href="structsnmp__pdu.html" title="The snmp protocol data unit.">netsnmp_pdu</a> *) NULL;
<a name="l03084"></a>03084             <span class="keywordflow">return</span> -1;
<a name="l03085"></a>03085         }
<a name="l03086"></a>03086         user-&gt;name = strdup((*pdu)-&gt;securityName);
<a name="l03087"></a>03087         user-&gt;secName = strdup((*pdu)-&gt;securityName);
<a name="l03088"></a>03088         user-&gt;authProtocolLen = <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class="keyword">sizeof</span>(oid);
<a name="l03089"></a>03089         user-&gt;authProtocol =
<a name="l03090"></a>03090             snmp_duplicate_objid(usmNoAuthProtocol, user-&gt;authProtocolLen);
<a name="l03091"></a>03091         user-&gt;privProtocolLen = <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid);
<a name="l03092"></a>03092         user-&gt;privProtocol =
<a name="l03093"></a>03093             snmp_duplicate_objid(usmNoPrivProtocol, user-&gt;privProtocolLen);
<a name="l03094"></a>03094         usm_add_user(user);
<a name="l03095"></a>03095     }
<a name="l03096"></a>03096     <span class="keywordflow">return</span> 0;
<a name="l03097"></a>03097 }
<a name="l03098"></a>03098 
<a name="l03099"></a>03099 <span class="keywordtype">int</span> usm_discover_engineid(<span class="keywordtype">void</span> *slpv, <a class="code" href="structsnmp__session.html" title="The snmp session structure.">netsnmp_session</a> *session) {
<a name="l03100"></a>03100     <a class="code" href="structsnmp__pdu.html" title="The snmp protocol data unit.">netsnmp_pdu</a>    *pdu = NULL, *response = NULL;
<a name="l03101"></a>03101     <span class="keywordtype">int</span> status, i;
<a name="l03102"></a>03102     <span class="keyword">struct </span><a class="code" href="structsession__list.html">session_list</a> *slp = (<span class="keyword">struct </span><a class="code" href="structsession__list.html">session_list</a> *) slpv;
<a name="l03103"></a>03103 
<a name="l03104"></a>03104     <span class="keywordflow">if</span> (usm_build_probe_pdu(&amp;pdu) != 0) {
<a name="l03105"></a>03105         DEBUGMSGTL((<span class="stringliteral">&quot;snmp_api&quot;</span>, <span class="stringliteral">&quot;unable to create probe PDU\n&quot;</span>));
<a name="l03106"></a>03106         <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l03107"></a>03107     }
<a name="l03108"></a>03108     DEBUGMSGTL((<span class="stringliteral">&quot;snmp_api&quot;</span>, <span class="stringliteral">&quot;probing for engineID...\n&quot;</span>));
<a name="l03109"></a>03109     session-&gt;flags |= SNMP_FLAGS_DONT_PROBE; <span class="comment">/* prevent recursion */</span>
<a name="l03110"></a>03110     status = snmp_sess_synch_response(slp, pdu, &amp;response);
<a name="l03111"></a>03111 
<a name="l03112"></a>03112     <span class="keywordflow">if</span> ((response == NULL) &amp;&amp; (status == STAT_SUCCESS)) {
<a name="l03113"></a>03113         status = STAT_ERROR;
<a name="l03114"></a>03114     }
<a name="l03115"></a>03115 
<a name="l03116"></a>03116     <span class="keywordflow">switch</span> (status) {
<a name="l03117"></a>03117     <span class="keywordflow">case</span> STAT_SUCCESS:
<a name="l03118"></a>03118         session-&gt;<a class="code" href="structsnmp__session.html#afb3f06f6d767a95ebd59b35d2f10faf7" title="copy of library errno">s_snmp_errno</a> = SNMPERR_INVALID_MSG; <span class="comment">/* XX?? */</span>
<a name="l03119"></a>03119         DEBUGMSGTL((<span class="stringliteral">&quot;snmp_sess_open&quot;</span>,
<a name="l03120"></a>03120                     <span class="stringliteral">&quot;error: expected Report as response to probe: %s (%ld)\n&quot;</span>,
<a name="l03121"></a>03121                     snmp_errstring(response-&gt;errstat),
<a name="l03122"></a>03122                     response-&gt;errstat));
<a name="l03123"></a>03123         <span class="keywordflow">break</span>;
<a name="l03124"></a>03124     <span class="keywordflow">case</span> STAT_ERROR:   <span class="comment">/* this is what we expected -&gt; Report == STAT_ERROR */</span>
<a name="l03125"></a>03125         session-&gt;<a class="code" href="structsnmp__session.html#afb3f06f6d767a95ebd59b35d2f10faf7" title="copy of library errno">s_snmp_errno</a> = SNMPERR_UNKNOWN_ENG_ID;
<a name="l03126"></a>03126         <span class="keywordflow">break</span>;
<a name="l03127"></a>03127     <span class="keywordflow">case</span> STAT_TIMEOUT:
<a name="l03128"></a>03128         session-&gt;<a class="code" href="structsnmp__session.html#afb3f06f6d767a95ebd59b35d2f10faf7" title="copy of library errno">s_snmp_errno</a> = SNMPERR_TIMEOUT;
<a name="l03129"></a>03129     <span class="keywordflow">default</span>:
<a name="l03130"></a>03130         DEBUGMSGTL((<span class="stringliteral">&quot;snmp_sess_open&quot;</span>,
<a name="l03131"></a>03131                     <span class="stringliteral">&quot;unable to connect with remote engine: %s (%d)\n&quot;</span>,
<a name="l03132"></a>03132                     snmp_api_errstring(session-&gt;<a class="code" href="structsnmp__session.html#afb3f06f6d767a95ebd59b35d2f10faf7" title="copy of library errno">s_snmp_errno</a>),
<a name="l03133"></a>03133                     session-&gt;<a class="code" href="structsnmp__session.html#afb3f06f6d767a95ebd59b35d2f10faf7" title="copy of library errno">s_snmp_errno</a>));
<a name="l03134"></a>03134         <span class="keywordflow">break</span>;
<a name="l03135"></a>03135     }
<a name="l03136"></a>03136 
<a name="l03137"></a>03137     <span class="keywordflow">if</span> (slp-&gt;session-&gt;<a class="code" href="structsnmp__session.html#a08a450c1b5acbf798b5473c36395edf5" title="Length of contextEngineID.">securityEngineIDLen</a> == 0) {
<a name="l03138"></a>03138         DEBUGMSGTL((<span class="stringliteral">&quot;snmp_api&quot;</span>,
<a name="l03139"></a>03139                     <span class="stringliteral">&quot;unable to determine remote engine ID\n&quot;</span>));
<a name="l03140"></a>03140         <span class="comment">/* clear the flag so that probe occurs on next inform */</span>
<a name="l03141"></a>03141         session-&gt;flags &amp;= ~SNMP_FLAGS_DONT_PROBE;
<a name="l03142"></a>03142         <span class="keywordflow">return</span> SNMP_ERR_GENERR;
<a name="l03143"></a>03143     }
<a name="l03144"></a>03144 
<a name="l03145"></a>03145     session-&gt;<a class="code" href="structsnmp__session.html#afb3f06f6d767a95ebd59b35d2f10faf7" title="copy of library errno">s_snmp_errno</a> = SNMPERR_SUCCESS;
<a name="l03146"></a>03146     <span class="keywordflow">if</span> (snmp_get_do_debugging()) {
<a name="l03147"></a>03147         DEBUGMSGTL((<span class="stringliteral">&quot;snmp_sess_open&quot;</span>,
<a name="l03148"></a>03148                     <span class="stringliteral">&quot;  probe found engineID:  &quot;</span>));
<a name="l03149"></a>03149         <span class="keywordflow">for</span> (i = 0; i &lt; slp-&gt;session-&gt;<a class="code" href="structsnmp__session.html#a08a450c1b5acbf798b5473c36395edf5" title="Length of contextEngineID.">securityEngineIDLen</a>; i++)
<a name="l03150"></a>03150             DEBUGMSG((<span class="stringliteral">&quot;snmp_sess_open&quot;</span>, <span class="stringliteral">&quot;%02x&quot;</span>,
<a name="l03151"></a>03151                       slp-&gt;session-&gt;<a class="code" href="structsnmp__session.html#aa11c998a39ac508258ccf9169ea22a89" title="authoritative snmpEngineID">securityEngineID</a>[i]));
<a name="l03152"></a>03152         DEBUGMSG((<span class="stringliteral">&quot;snmp_sess_open&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l03153"></a>03153     }
<a name="l03154"></a>03154 
<a name="l03155"></a>03155     <span class="comment">/*</span>
<a name="l03156"></a>03156 <span class="comment">     * if boot/time supplied set it for this engineID </span>
<a name="l03157"></a>03157 <span class="comment">     */</span>
<a name="l03158"></a>03158     <span class="keywordflow">if</span> (session-&gt;<a class="code" href="structsnmp__session.html#aa085375bfa95ac93f3496b45cc48c7c4" title="initial engineBoots for remote engine">engineBoots</a> || session-&gt;<a class="code" href="structsnmp__session.html#a2575d19e07c2472c7d2d90b2535a048a" title="initial engineTime for remote engine">engineTime</a>) {
<a name="l03159"></a>03159         set_enginetime(session-&gt;<a class="code" href="structsnmp__session.html#aa11c998a39ac508258ccf9169ea22a89" title="authoritative snmpEngineID">securityEngineID</a>,
<a name="l03160"></a>03160                        session-&gt;<a class="code" href="structsnmp__session.html#a08a450c1b5acbf798b5473c36395edf5" title="Length of contextEngineID.">securityEngineIDLen</a>,
<a name="l03161"></a>03161                        session-&gt;<a class="code" href="structsnmp__session.html#aa085375bfa95ac93f3496b45cc48c7c4" title="initial engineBoots for remote engine">engineBoots</a>, session-&gt;<a class="code" href="structsnmp__session.html#a2575d19e07c2472c7d2d90b2535a048a" title="initial engineTime for remote engine">engineTime</a>,
<a name="l03162"></a>03162                        TRUE);
<a name="l03163"></a>03163     }
<a name="l03164"></a>03164     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l03165"></a>03165 }
<a name="l03166"></a>03166 
<a name="l03167"></a>03167 <span class="keywordtype">void</span>
<a name="l03168"></a>03168 init_usm(<span class="keywordtype">void</span>)
<a name="l03169"></a>03169 {
<a name="l03170"></a>03170     <span class="keyword">struct </span><a class="code" href="structsnmp__secmod__def.html">snmp_secmod_def</a> *def;
<a name="l03171"></a>03171     <span class="keywordtype">char</span> *type;
<a name="l03172"></a>03172 
<a name="l03173"></a>03173     DEBUGMSGTL((<span class="stringliteral">&quot;init_usm&quot;</span>, <span class="stringliteral">&quot;unit_usm: %&quot;</span> NETSNMP_PRIo <span class="stringliteral">&quot;u %&quot;</span> NETSNMP_PRIo <span class="stringliteral">&quot;u\n&quot;</span>,
<a name="l03174"></a>03174                 usmNoPrivProtocol[0], usmNoPrivProtocol[1]));
<a name="l03175"></a>03175 
<a name="l03176"></a>03176     sc_init();                  <span class="comment">/* initalize scapi code */</span>
<a name="l03177"></a>03177 
<a name="l03178"></a>03178     <span class="comment">/*</span>
<a name="l03179"></a>03179 <span class="comment">     * register ourselves as a security service </span>
<a name="l03180"></a>03180 <span class="comment">     */</span>
<a name="l03181"></a>03181     def = <a class="code" href="group__util.html#ga6356941968481380ea6f4a646df4aaf9" title="Mallocs memory of sizeof(struct s), zeros it and returns a pointer to it.">SNMP_MALLOC_STRUCT</a>(<a class="code" href="structsnmp__secmod__def.html">snmp_secmod_def</a>);
<a name="l03182"></a>03182     <span class="keywordflow">if</span> (def == NULL)
<a name="l03183"></a>03183         <span class="keywordflow">return</span>;
<a name="l03184"></a>03184     <span class="comment">/*</span>
<a name="l03185"></a>03185 <span class="comment">     * XXX: def-&gt;init_sess_secmod move stuff from snmp_api.c </span>
<a name="l03186"></a>03186 <span class="comment">     */</span>
<a name="l03187"></a>03187     def-&gt;encode_reverse = usm_secmod_rgenerate_out_msg;
<a name="l03188"></a>03188     def-&gt;encode_forward = usm_secmod_generate_out_msg;
<a name="l03189"></a>03189     def-&gt;decode = usm_secmod_process_in_msg;
<a name="l03190"></a>03190     def-&gt;pdu_free_state_ref = usm_free_usmStateReference;
<a name="l03191"></a>03191     def-&gt;session_setup = usm_session_init;
<a name="l03192"></a>03192     def-&gt;handle_report = usm_handle_report;
<a name="l03193"></a>03193     def-&gt;probe_engineid = usm_discover_engineid;
<a name="l03194"></a>03194     def-&gt;post_probe_engineid = usm_create_user_from_session_hook;
<a name="l03195"></a>03195     register_sec_mod(USM_SEC_MODEL_NUMBER, <span class="stringliteral">&quot;usm&quot;</span>, def);
<a name="l03196"></a>03196 
<a name="l03197"></a>03197     <a class="code" href="group__callback.html#gaa74bcb0ea6a8b7270f5e26746ba1fff1" title="This function registers a generic callback function.">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
<a name="l03198"></a>03198                            SNMP_CALLBACK_POST_PREMIB_READ_CONFIG,
<a name="l03199"></a>03199                            init_usm_post_config, NULL);
<a name="l03200"></a>03200 
<a name="l03201"></a>03201     <a class="code" href="group__callback.html#gaa74bcb0ea6a8b7270f5e26746ba1fff1" title="This function registers a generic callback function.">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
<a name="l03202"></a>03202                            SNMP_CALLBACK_SHUTDOWN,
<a name="l03203"></a>03203                            deinit_usm_post_config, NULL);
<a name="l03204"></a>03204 
<a name="l03205"></a>03205     <a class="code" href="group__callback.html#gaa74bcb0ea6a8b7270f5e26746ba1fff1" title="This function registers a generic callback function.">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
<a name="l03206"></a>03206                            SNMP_CALLBACK_SHUTDOWN,
<a name="l03207"></a>03207                            free_engineID, NULL);
<a name="l03208"></a>03208 
<a name="l03209"></a>03209     <a class="code" href="group__read__config.html#ga9a3e481d8eb7d3ef08efa25b9a186c3b" title="register_config_handler registers handlers for certain tokens specified in certain types of files...">register_config_handler</a>(<span class="stringliteral">&quot;snmp&quot;</span>, <span class="stringliteral">&quot;defAuthType&quot;</span>, snmpv3_authtype_conf,
<a name="l03210"></a>03210                             NULL, <span class="stringliteral">&quot;MD5|SHA&quot;</span>);
<a name="l03211"></a>03211     <a class="code" href="group__read__config.html#ga9a3e481d8eb7d3ef08efa25b9a186c3b" title="register_config_handler registers handlers for certain tokens specified in certain types of files...">register_config_handler</a>(<span class="stringliteral">&quot;snmp&quot;</span>, <span class="stringliteral">&quot;defPrivType&quot;</span>, snmpv3_privtype_conf,
<a name="l03212"></a>03212                             NULL,
<a name="l03213"></a>03213 #ifdef HAVE_AES
<a name="l03214"></a>03214                             <span class="stringliteral">&quot;DES|AES&quot;</span>
<a name="l03215"></a>03215 #<span class="keywordflow">else</span>
<a name="l03216"></a>03216                             <span class="stringliteral">&quot;DES (AES support not available)&quot;</span>
<a name="l03217"></a>03217 #endif
<a name="l03218"></a>03218                            );
<a name="l03219"></a>03219 
<a name="l03220"></a>03220     <span class="comment">/*</span>
<a name="l03221"></a>03221 <span class="comment">     * Free stuff at shutdown time</span>
<a name="l03222"></a>03222 <span class="comment">     */</span>
<a name="l03223"></a>03223     <a class="code" href="group__callback.html#gaa74bcb0ea6a8b7270f5e26746ba1fff1" title="This function registers a generic callback function.">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
<a name="l03224"></a>03224                            SNMP_CALLBACK_SHUTDOWN,
<a name="l03225"></a>03225                            free_enginetime_on_shutdown, NULL);
<a name="l03226"></a>03226 
<a name="l03227"></a>03227 
<a name="l03228"></a>03228     type = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE);
<a name="l03229"></a>03229 
<a name="l03230"></a>03230     <a class="code" href="group__read__config.html#ga9a3e481d8eb7d3ef08efa25b9a186c3b" title="register_config_handler registers handlers for certain tokens specified in certain types of files...">register_config_handler</a>(type, <span class="stringliteral">&quot;userSetAuthPass&quot;</span>, usm_set_password,
<a name="l03231"></a>03231                             NULL, NULL);
<a name="l03232"></a>03232     <a class="code" href="group__read__config.html#ga9a3e481d8eb7d3ef08efa25b9a186c3b" title="register_config_handler registers handlers for certain tokens specified in certain types of files...">register_config_handler</a>(type, <span class="stringliteral">&quot;userSetPrivPass&quot;</span>, usm_set_password,
<a name="l03233"></a>03233                             NULL, NULL);
<a name="l03234"></a>03234     <a class="code" href="group__read__config.html#ga9a3e481d8eb7d3ef08efa25b9a186c3b" title="register_config_handler registers handlers for certain tokens specified in certain types of files...">register_config_handler</a>(type, <span class="stringliteral">&quot;userSetAuthKey&quot;</span>, usm_set_password, NULL,
<a name="l03235"></a>03235                             NULL);
<a name="l03236"></a>03236     <a class="code" href="group__read__config.html#ga9a3e481d8eb7d3ef08efa25b9a186c3b" title="register_config_handler registers handlers for certain tokens specified in certain types of files...">register_config_handler</a>(type, <span class="stringliteral">&quot;userSetPrivKey&quot;</span>, usm_set_password, NULL,
<a name="l03237"></a>03237                             NULL);
<a name="l03238"></a>03238     <a class="code" href="group__read__config.html#ga9a3e481d8eb7d3ef08efa25b9a186c3b" title="register_config_handler registers handlers for certain tokens specified in certain types of files...">register_config_handler</a>(type, <span class="stringliteral">&quot;userSetAuthLocalKey&quot;</span>, usm_set_password,
<a name="l03239"></a>03239                             NULL, NULL);
<a name="l03240"></a>03240     <a class="code" href="group__read__config.html#ga9a3e481d8eb7d3ef08efa25b9a186c3b" title="register_config_handler registers handlers for certain tokens specified in certain types of files...">register_config_handler</a>(type, <span class="stringliteral">&quot;userSetPrivLocalKey&quot;</span>, usm_set_password,
<a name="l03241"></a>03241                             NULL, NULL);
<a name="l03242"></a>03242 }
<a name="l03243"></a>03243 
<a name="l03244"></a>03244 <span class="keywordtype">void</span>
<a name="l03245"></a>03245 init_usm_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *app)
<a name="l03246"></a>03246 {
<a name="l03247"></a>03247     <a class="code" href="group__read__config.html#ga9a3e481d8eb7d3ef08efa25b9a186c3b" title="register_config_handler registers handlers for certain tokens specified in certain types of files...">register_config_handler</a>(app, <span class="stringliteral">&quot;usmUser&quot;</span>,
<a name="l03248"></a>03248                                   usm_parse_config_usmUser, NULL, NULL);
<a name="l03249"></a>03249     <a class="code" href="group__read__config.html#ga9a3e481d8eb7d3ef08efa25b9a186c3b" title="register_config_handler registers handlers for certain tokens specified in certain types of files...">register_config_handler</a>(app, <span class="stringliteral">&quot;createUser&quot;</span>,
<a name="l03250"></a>03250                                   usm_parse_create_usmUser, NULL,
<a name="l03251"></a>03251                                   <span class="stringliteral">&quot;username [-e ENGINEID] (MD5|SHA) authpassphrase [DES [privpassphrase]]&quot;</span>);
<a name="l03252"></a>03252 
<a name="l03253"></a>03253     <span class="comment">/*</span>
<a name="l03254"></a>03254 <span class="comment">     * we need to be called back later </span>
<a name="l03255"></a>03255 <span class="comment">     */</span>
<a name="l03256"></a>03256     <a class="code" href="group__callback.html#gaa74bcb0ea6a8b7270f5e26746ba1fff1" title="This function registers a generic callback function.">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
<a name="l03257"></a>03257                            usm_store_users, NULL);
<a name="l03258"></a>03258 }
<a name="l03259"></a>03259 
<a name="l03260"></a>03260 <span class="comment">/*</span>
<a name="l03261"></a>03261 <span class="comment"> * initializations for the USM.</span>
<a name="l03262"></a>03262 <span class="comment"> *</span>
<a name="l03263"></a>03263 <span class="comment"> * Should be called after the (engineid) configuration files have been read.</span>
<a name="l03264"></a>03264 <span class="comment"> *</span>
<a name="l03265"></a>03265 <span class="comment"> * Set &quot;arbitrary&quot; portion of salt to a random number.</span>
<a name="l03266"></a>03266 <span class="comment"> */</span>
<a name="l03267"></a>03267 <span class="keywordtype">int</span>
<a name="l03268"></a>03268 init_usm_post_config(<span class="keywordtype">int</span> majorid, <span class="keywordtype">int</span> minorid, <span class="keywordtype">void</span> *serverarg,
<a name="l03269"></a>03269                      <span class="keywordtype">void</span> *clientarg)
<a name="l03270"></a>03270 {
<a name="l03271"></a>03271     <span class="keywordtype">size_t</span>          salt_integer_len = <span class="keyword">sizeof</span>(salt_integer);
<a name="l03272"></a>03272 
<a name="l03273"></a>03273     <span class="keywordflow">if</span> (sc_random((u_char *) &amp; salt_integer, &amp;salt_integer_len) !=
<a name="l03274"></a>03274         SNMPERR_SUCCESS) {
<a name="l03275"></a>03275         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;sc_random() failed: using time() as salt.\n&quot;</span>));
<a name="l03276"></a>03276         salt_integer = (u_int) time(NULL);
<a name="l03277"></a>03277     }
<a name="l03278"></a>03278 
<a name="l03279"></a>03279 <span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l03280"></a>03280 <span class="preprocessor"></span>    salt_integer_len = <span class="keyword">sizeof</span> (salt_integer64_1);
<a name="l03281"></a>03281     <span class="keywordflow">if</span> (sc_random((u_char *) &amp; salt_integer64_1, &amp;salt_integer_len) !=
<a name="l03282"></a>03282         SNMPERR_SUCCESS) {
<a name="l03283"></a>03283         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;sc_random() failed: using time() as aes1 salt.\n&quot;</span>));
<a name="l03284"></a>03284         salt_integer64_1 = (u_int) time(NULL);
<a name="l03285"></a>03285     }
<a name="l03286"></a>03286     salt_integer_len = <span class="keyword">sizeof</span> (salt_integer64_1);
<a name="l03287"></a>03287     <span class="keywordflow">if</span> (sc_random((u_char *) &amp; salt_integer64_2, &amp;salt_integer_len) !=
<a name="l03288"></a>03288         SNMPERR_SUCCESS) {
<a name="l03289"></a>03289         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;sc_random() failed: using time() as aes2 salt.\n&quot;</span>));
<a name="l03290"></a>03290         salt_integer64_2 = (u_int) time(NULL);
<a name="l03291"></a>03291     }
<a name="l03292"></a>03292 <span class="preprocessor">#endif</span>
<a name="l03293"></a>03293 <span class="preprocessor"></span>    
<a name="l03294"></a>03294 <span class="preprocessor">#ifndef NETSNMP_DISABLE_MD5</span>
<a name="l03295"></a>03295 <span class="preprocessor"></span>    noNameUser = usm_create_initial_user(<span class="stringliteral">&quot;&quot;</span>, usmHMACMD5AuthProtocol,
<a name="l03296"></a>03296                                          USM_LENGTH_OID_TRANSFORM,
<a name="l03297"></a>03297 #ifndef NETSNMP_DISABLE_DES
<a name="l03298"></a>03298                                          usmDESPrivProtocol,
<a name="l03299"></a>03299 #<span class="keywordflow">else</span>
<a name="l03300"></a>03300                                          usmAESPrivProtocol,
<a name="l03301"></a>03301 #endif
<a name="l03302"></a>03302                                          USM_LENGTH_OID_TRANSFORM);
<a name="l03303"></a>03303 <span class="preprocessor">#else</span>
<a name="l03304"></a>03304 <span class="preprocessor"></span>    noNameUser = usm_create_initial_user(<span class="stringliteral">&quot;&quot;</span>, usmHMACSHA1AuthProtocol,
<a name="l03305"></a>03305                                          USM_LENGTH_OID_TRANSFORM,
<a name="l03306"></a>03306 #ifndef NETSNMP_DISABLE_DES
<a name="l03307"></a>03307                                          usmDESPrivProtocol,
<a name="l03308"></a>03308 #<span class="keywordflow">else</span>
<a name="l03309"></a>03309                                          usmAESPrivProtocol,
<a name="l03310"></a>03310 #endif
<a name="l03311"></a>03311                                          USM_LENGTH_OID_TRANSFORM);
<a name="l03312"></a>03312 <span class="preprocessor">#endif</span>
<a name="l03313"></a>03313 <span class="preprocessor"></span>
<a name="l03314"></a>03314     <span class="keywordflow">if</span> ( noNameUser ) {
<a name="l03315"></a>03315         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(noNameUser-&gt;engineID);
<a name="l03316"></a>03316         noNameUser-&gt;engineIDLen = 0;
<a name="l03317"></a>03317     }
<a name="l03318"></a>03318 
<a name="l03319"></a>03319     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l03320"></a>03320 }                               <span class="comment">/* end init_usm_post_config() */</span>
<a name="l03321"></a>03321 
<a name="l03322"></a>03322 <span class="keywordtype">int</span>
<a name="l03323"></a>03323 deinit_usm_post_config(<span class="keywordtype">int</span> majorid, <span class="keywordtype">int</span> minorid, <span class="keywordtype">void</span> *serverarg,
<a name="l03324"></a>03324                        <span class="keywordtype">void</span> *clientarg)
<a name="l03325"></a>03325 {
<a name="l03326"></a>03326     <span class="keywordflow">if</span> (usm_free_user(noNameUser) != NULL) {
<a name="l03327"></a>03327         DEBUGMSGTL((<span class="stringliteral">&quot;deinit_usm_post_config&quot;</span>, <span class="stringliteral">&quot;could not free initial user\n&quot;</span>));
<a name="l03328"></a>03328         <span class="keywordflow">return</span> SNMPERR_GENERR;
<a name="l03329"></a>03329     }
<a name="l03330"></a>03330     noNameUser = NULL;
<a name="l03331"></a>03331 
<a name="l03332"></a>03332     DEBUGMSGTL((<span class="stringliteral">&quot;deinit_usm_post_config&quot;</span>, <span class="stringliteral">&quot;initial user removed\n&quot;</span>));
<a name="l03333"></a>03333     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l03334"></a>03334 }                               <span class="comment">/* end deinit_usm_post_config() */</span>
<a name="l03335"></a>03335 
<a name="l03336"></a>03336 <span class="keywordtype">void</span>
<a name="l03337"></a>03337 clear_user_list(<span class="keywordtype">void</span>)
<a name="l03338"></a>03338 {
<a name="l03339"></a>03339     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *tmp = userList, *next = NULL;
<a name="l03340"></a>03340 
<a name="l03341"></a>03341     <span class="keywordflow">while</span> (tmp != NULL) {
<a name="l03342"></a>03342         next = tmp-&gt;next;
<a name="l03343"></a>03343         usm_free_user(tmp);
<a name="l03344"></a>03344         tmp = next;
<a name="l03345"></a>03345     }
<a name="l03346"></a>03346     userList = NULL;
<a name="l03347"></a>03347 
<a name="l03348"></a>03348 }
<a name="l03349"></a>03349 
<a name="l03350"></a>03350 <span class="keywordtype">void</span>
<a name="l03351"></a>03351 shutdown_usm(<span class="keywordtype">void</span>)
<a name="l03352"></a>03352 {
<a name="l03353"></a>03353     free_etimelist();
<a name="l03354"></a>03354     clear_user_list();
<a name="l03355"></a>03355 }
<a name="l03356"></a>03356 
<a name="l03357"></a>03357 <span class="comment">/*******************************************************************-o-******</span>
<a name="l03358"></a>03358 <span class="comment"> * usm_check_secLevel</span>
<a name="l03359"></a>03359 <span class="comment"> *</span>
<a name="l03360"></a>03360 <span class="comment"> * Parameters:</span>
<a name="l03361"></a>03361 <span class="comment"> *       level</span>
<a name="l03362"></a>03362 <span class="comment"> *      *user</span>
<a name="l03363"></a>03363 <span class="comment"> *      </span>
<a name="l03364"></a>03364 <span class="comment"> * Returns:</span>
<a name="l03365"></a>03365 <span class="comment"> *      0       On success,</span>
<a name="l03366"></a>03366 <span class="comment"> *      -1      Otherwise.</span>
<a name="l03367"></a>03367 <span class="comment"> *</span>
<a name="l03368"></a>03368 <span class="comment"> * Checks that a given security level is valid for a given user.</span>
<a name="l03369"></a>03369 <span class="comment"> */</span>
<a name="l03370"></a>03370 <span class="keywordtype">int</span>
<a name="l03371"></a>03371 usm_check_secLevel(<span class="keywordtype">int</span> level, <span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *user)
<a name="l03372"></a>03372 {
<a name="l03373"></a>03373 
<a name="l03374"></a>03374     <span class="keywordflow">if</span> (user-&gt;userStatus != RS_ACTIVE)
<a name="l03375"></a>03375         <span class="keywordflow">return</span> -1;
<a name="l03376"></a>03376 
<a name="l03377"></a>03377     DEBUGMSGTL((<span class="stringliteral">&quot;comparex&quot;</span>, <span class="stringliteral">&quot;Comparing: %&quot;</span> NETSNMP_PRIo <span class="stringliteral">&quot;u %&quot;</span> NETSNMP_PRIo <span class="stringliteral">&quot;u &quot;</span>,
<a name="l03378"></a>03378                 usmNoPrivProtocol[0], usmNoPrivProtocol[1]));
<a name="l03379"></a>03379     DEBUGMSGOID((<span class="stringliteral">&quot;comparex&quot;</span>, usmNoPrivProtocol,
<a name="l03380"></a>03380                  <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid)));
<a name="l03381"></a>03381     DEBUGMSG((<span class="stringliteral">&quot;comparex&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l03382"></a>03382     <span class="keywordflow">if</span> (level == SNMP_SEC_LEVEL_AUTHPRIV
<a name="l03383"></a>03383         &amp;&amp; (<a class="code" href="group__library.html#gae881bb815fa4afe6eadb60a43165ee06" title="Compares 2 OIDs to determine if they are exactly equal.">netsnmp_oid_equals</a>(user-&gt;privProtocol, user-&gt;privProtocolLen,
<a name="l03384"></a>03384                              usmNoPrivProtocol,
<a name="l03385"></a>03385                              <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid)) ==
<a name="l03386"></a>03386             0)) {
<a name="l03387"></a>03387         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Level: %d\n&quot;</span>, level));
<a name="l03388"></a>03388         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;User (%s) Auth Protocol: &quot;</span>, user-&gt;name));
<a name="l03389"></a>03389         DEBUGMSGOID((<span class="stringliteral">&quot;usm&quot;</span>, user-&gt;authProtocol, user-&gt;authProtocolLen));
<a name="l03390"></a>03390         DEBUGMSG((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;, User Priv Protocol: &quot;</span>));
<a name="l03391"></a>03391         DEBUGMSGOID((<span class="stringliteral">&quot;usm&quot;</span>, user-&gt;privProtocol, user-&gt;privProtocolLen));
<a name="l03392"></a>03392         DEBUGMSG((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l03393"></a>03393         <span class="keywordflow">return</span> 1;
<a name="l03394"></a>03394     }
<a name="l03395"></a>03395     <span class="keywordflow">if</span> ((level == SNMP_SEC_LEVEL_AUTHPRIV
<a name="l03396"></a>03396          || level == SNMP_SEC_LEVEL_AUTHNOPRIV)
<a name="l03397"></a>03397         &amp;&amp;
<a name="l03398"></a>03398         (<a class="code" href="group__library.html#gae881bb815fa4afe6eadb60a43165ee06" title="Compares 2 OIDs to determine if they are exactly equal.">netsnmp_oid_equals</a>
<a name="l03399"></a>03399          (user-&gt;authProtocol, user-&gt;authProtocolLen, usmNoAuthProtocol,
<a name="l03400"></a>03400           <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class="keyword">sizeof</span>(oid)) == 0)) {
<a name="l03401"></a>03401         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Level: %d\n&quot;</span>, level));
<a name="l03402"></a>03402         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;User (%s) Auth Protocol: &quot;</span>, user-&gt;name));
<a name="l03403"></a>03403         DEBUGMSGOID((<span class="stringliteral">&quot;usm&quot;</span>, user-&gt;authProtocol, user-&gt;authProtocolLen));
<a name="l03404"></a>03404         DEBUGMSG((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;, User Priv Protocol: &quot;</span>));
<a name="l03405"></a>03405         DEBUGMSGOID((<span class="stringliteral">&quot;usm&quot;</span>, user-&gt;privProtocol, user-&gt;privProtocolLen));
<a name="l03406"></a>03406         DEBUGMSG((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l03407"></a>03407         <span class="keywordflow">return</span> 1;
<a name="l03408"></a>03408     }
<a name="l03409"></a>03409 
<a name="l03410"></a>03410     <span class="keywordflow">return</span> 0;
<a name="l03411"></a>03411 
<a name="l03412"></a>03412 }                               <span class="comment">/* end usm_check_secLevel() */</span>
<a name="l03413"></a>03413 
<a name="l03414"></a>03414 
<a name="l03415"></a>03415 
<a name="l03416"></a>03416 
<a name="l03417"></a>03417 <span class="comment">/*******************************************************************-o-******</span>
<a name="l03418"></a>03418 <span class="comment"> * usm_check_secLevel_vs_protocols</span>
<a name="l03419"></a>03419 <span class="comment"> *</span>
<a name="l03420"></a>03420 <span class="comment"> * Parameters:</span>
<a name="l03421"></a>03421 <span class="comment"> *       level</span>
<a name="l03422"></a>03422 <span class="comment"> *      *authProtocol</span>
<a name="l03423"></a>03423 <span class="comment"> *       authProtocolLen</span>
<a name="l03424"></a>03424 <span class="comment"> *      *privProtocol</span>
<a name="l03425"></a>03425 <span class="comment"> *       privProtocolLen</span>
<a name="l03426"></a>03426 <span class="comment"> *      </span>
<a name="l03427"></a>03427 <span class="comment"> * Returns:</span>
<a name="l03428"></a>03428 <span class="comment"> *      0       On success,</span>
<a name="l03429"></a>03429 <span class="comment"> *      1       Otherwise.</span>
<a name="l03430"></a>03430 <span class="comment"> *</span>
<a name="l03431"></a>03431 <span class="comment"> * Same as above but with explicitly named transform types instead of taking</span>
<a name="l03432"></a>03432 <span class="comment"> * from the usmUser structure.</span>
<a name="l03433"></a>03433 <span class="comment"> */</span>
<a name="l03434"></a>03434 <span class="keywordtype">int</span>
<a name="l03435"></a>03435 usm_check_secLevel_vs_protocols(<span class="keywordtype">int</span> level,
<a name="l03436"></a>03436                                 <span class="keyword">const</span> oid * authProtocol,
<a name="l03437"></a>03437                                 u_int authProtocolLen,
<a name="l03438"></a>03438                                 <span class="keyword">const</span> oid * privProtocol,
<a name="l03439"></a>03439                                 u_int privProtocolLen)
<a name="l03440"></a>03440 {
<a name="l03441"></a>03441 
<a name="l03442"></a>03442     <span class="keywordflow">if</span> (level == SNMP_SEC_LEVEL_AUTHPRIV
<a name="l03443"></a>03443         &amp;&amp;
<a name="l03444"></a>03444         (<a class="code" href="group__library.html#gae881bb815fa4afe6eadb60a43165ee06" title="Compares 2 OIDs to determine if they are exactly equal.">netsnmp_oid_equals</a>
<a name="l03445"></a>03445          (privProtocol, privProtocolLen, usmNoPrivProtocol,
<a name="l03446"></a>03446           <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid)) == 0)) {
<a name="l03447"></a>03447         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Level: %d\n&quot;</span>, level));
<a name="l03448"></a>03448         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Auth Protocol: &quot;</span>));
<a name="l03449"></a>03449         DEBUGMSGOID((<span class="stringliteral">&quot;usm&quot;</span>, authProtocol, authProtocolLen));
<a name="l03450"></a>03450         DEBUGMSG((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;, Priv Protocol: &quot;</span>));
<a name="l03451"></a>03451         DEBUGMSGOID((<span class="stringliteral">&quot;usm&quot;</span>, privProtocol, privProtocolLen));
<a name="l03452"></a>03452         DEBUGMSG((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l03453"></a>03453         <span class="keywordflow">return</span> 1;
<a name="l03454"></a>03454     }
<a name="l03455"></a>03455     <span class="keywordflow">if</span> ((level == SNMP_SEC_LEVEL_AUTHPRIV
<a name="l03456"></a>03456          || level == SNMP_SEC_LEVEL_AUTHNOPRIV)
<a name="l03457"></a>03457         &amp;&amp;
<a name="l03458"></a>03458         (<a class="code" href="group__library.html#gae881bb815fa4afe6eadb60a43165ee06" title="Compares 2 OIDs to determine if they are exactly equal.">netsnmp_oid_equals</a>
<a name="l03459"></a>03459          (authProtocol, authProtocolLen, usmNoAuthProtocol,
<a name="l03460"></a>03460           <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class="keyword">sizeof</span>(oid)) == 0)) {
<a name="l03461"></a>03461         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Level: %d\n&quot;</span>, level));
<a name="l03462"></a>03462         DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Auth Protocol: &quot;</span>));
<a name="l03463"></a>03463         DEBUGMSGOID((<span class="stringliteral">&quot;usm&quot;</span>, authProtocol, authProtocolLen));
<a name="l03464"></a>03464         DEBUGMSG((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;, Priv Protocol: &quot;</span>));
<a name="l03465"></a>03465         DEBUGMSGOID((<span class="stringliteral">&quot;usm&quot;</span>, privProtocol, privProtocolLen));
<a name="l03466"></a>03466         DEBUGMSG((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l03467"></a>03467         <span class="keywordflow">return</span> 1;
<a name="l03468"></a>03468     }
<a name="l03469"></a>03469 
<a name="l03470"></a>03470     <span class="keywordflow">return</span> 0;
<a name="l03471"></a>03471 
<a name="l03472"></a>03472 }                               <span class="comment">/* end usm_check_secLevel_vs_protocols() */</span>
<a name="l03473"></a>03473 
<a name="l03474"></a>03474 
<a name="l03475"></a>03475 
<a name="l03476"></a>03476 
<a name="l03477"></a>03477 <span class="comment">/*</span>
<a name="l03478"></a>03478 <span class="comment"> * usm_get_user(): Returns a user from userList based on the engineID,</span>
<a name="l03479"></a>03479 <span class="comment"> * engineIDLen and name of the requested user. </span>
<a name="l03480"></a>03480 <span class="comment"> */</span>
<a name="l03481"></a>03481 
<a name="l03482"></a>03482 <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *
<a name="l03483"></a>03483 usm_get_user(u_char * engineID, <span class="keywordtype">size_t</span> engineIDLen, <span class="keywordtype">char</span> *name)
<a name="l03484"></a>03484 {
<a name="l03485"></a>03485     DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;getting user %s\n&quot;</span>, name));
<a name="l03486"></a>03486     <span class="keywordflow">return</span> usm_get_user_from_list(engineID, engineIDLen, name, userList,
<a name="l03487"></a>03487                                   1);
<a name="l03488"></a>03488 }
<a name="l03489"></a>03489 
<a name="l03490"></a>03490 <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *
<a name="l03491"></a>03491 usm_get_user_from_list(u_char * engineID, <span class="keywordtype">size_t</span> engineIDLen,
<a name="l03492"></a>03492                        <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *puserList,
<a name="l03493"></a>03493                        <span class="keywordtype">int</span> use_default)
<a name="l03494"></a>03494 {
<a name="l03495"></a>03495     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *ptr;
<a name="l03496"></a>03496     <span class="keywordtype">char</span>            noName[] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l03497"></a>03497     <span class="keywordflow">if</span> (name == NULL)
<a name="l03498"></a>03498         name = noName;
<a name="l03499"></a>03499     <span class="keywordflow">for</span> (ptr = puserList; ptr != NULL; ptr = ptr-&gt;next) {
<a name="l03500"></a>03500         <span class="keywordflow">if</span> (ptr-&gt;name &amp;&amp; !strcmp(ptr-&gt;name, name)) {
<a name="l03501"></a>03501           DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;match on user %s\n&quot;</span>, ptr-&gt;name));
<a name="l03502"></a>03502           <span class="keywordflow">if</span> (ptr-&gt;engineIDLen == engineIDLen &amp;&amp;
<a name="l03503"></a>03503             ((ptr-&gt;engineID == NULL &amp;&amp; engineID == NULL) ||
<a name="l03504"></a>03504              (ptr-&gt;engineID != NULL &amp;&amp; engineID != NULL &amp;&amp;
<a name="l03505"></a>03505               memcmp(ptr-&gt;engineID, engineID, engineIDLen) == 0)))
<a name="l03506"></a>03506             <span class="keywordflow">return</span> ptr;
<a name="l03507"></a>03507           DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;no match on engineID (&quot;</span>));
<a name="l03508"></a>03508           <span class="keywordflow">if</span> (engineID) {
<a name="l03509"></a>03509               DEBUGMSGHEX((<span class="stringliteral">&quot;usm&quot;</span>, engineID, engineIDLen));
<a name="l03510"></a>03510           } <span class="keywordflow">else</span> {
<a name="l03511"></a>03511               DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;Empty EngineID&quot;</span>));
<a name="l03512"></a>03512           }
<a name="l03513"></a>03513           DEBUGMSG((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;)\n&quot;</span>));
<a name="l03514"></a>03514         }
<a name="l03515"></a>03515     }
<a name="l03516"></a>03516 
<a name="l03517"></a>03517     <span class="comment">/*</span>
<a name="l03518"></a>03518 <span class="comment">     * return &quot;&quot; user used to facilitate engineID discovery </span>
<a name="l03519"></a>03519 <span class="comment">     */</span>
<a name="l03520"></a>03520     <span class="keywordflow">if</span> (use_default &amp;&amp; !strcmp(name, <span class="stringliteral">&quot;&quot;</span>))
<a name="l03521"></a>03521         <span class="keywordflow">return</span> noNameUser;
<a name="l03522"></a>03522     <span class="keywordflow">return</span> NULL;
<a name="l03523"></a>03523 }
<a name="l03524"></a>03524 
<a name="l03525"></a>03525 <span class="comment">/*</span>
<a name="l03526"></a>03526 <span class="comment"> * usm_add_user(): Add&#39;s a user to the userList, sorted by the</span>
<a name="l03527"></a>03527 <span class="comment"> * engineIDLength then the engineID then the name length then the name</span>
<a name="l03528"></a>03528 <span class="comment"> * to facilitate getNext calls on a usmUser table which is indexed by</span>
<a name="l03529"></a>03529 <span class="comment"> * these values.</span>
<a name="l03530"></a>03530 <span class="comment"> * </span>
<a name="l03531"></a>03531 <span class="comment"> * returns the head of the list (which could change due to this add).</span>
<a name="l03532"></a>03532 <span class="comment"> */</span>
<a name="l03533"></a>03533 
<a name="l03534"></a>03534 <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *
<a name="l03535"></a>03535 usm_add_user(<span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *user)
<a name="l03536"></a>03536 {
<a name="l03537"></a>03537     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *uptr;
<a name="l03538"></a>03538     uptr = usm_add_user_to_list(user, userList);
<a name="l03539"></a>03539     <span class="keywordflow">if</span> (uptr != NULL)
<a name="l03540"></a>03540         userList = uptr;
<a name="l03541"></a>03541     <span class="keywordflow">return</span> uptr;
<a name="l03542"></a>03542 }
<a name="l03543"></a>03543 
<a name="l03544"></a>03544 <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *
<a name="l03545"></a>03545 usm_add_user_to_list(<span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *user, <span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *puserList)
<a name="l03546"></a>03546 {
<a name="l03547"></a>03547     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *nptr, *pptr, *optr;
<a name="l03548"></a>03548 
<a name="l03549"></a>03549     <span class="comment">/*</span>
<a name="l03550"></a>03550 <span class="comment">     * loop through puserList till we find the proper, sorted place to</span>
<a name="l03551"></a>03551 <span class="comment">     * insert the new user </span>
<a name="l03552"></a>03552 <span class="comment">     */</span>
<a name="l03553"></a>03553     <span class="comment">/* XXX - how to handle a NULL user-&gt;name ?? */</span>
<a name="l03554"></a>03554     <span class="comment">/* XXX - similarly for a NULL nptr-&gt;name ?? */</span>
<a name="l03555"></a>03555     <span class="keywordflow">for</span> (nptr = puserList, pptr = NULL; nptr != NULL;
<a name="l03556"></a>03556          pptr = nptr, nptr = nptr-&gt;next) {
<a name="l03557"></a>03557         <span class="keywordflow">if</span> (nptr-&gt;engineIDLen &gt; user-&gt;engineIDLen)
<a name="l03558"></a>03558             <span class="keywordflow">break</span>;
<a name="l03559"></a>03559 
<a name="l03560"></a>03560         <span class="keywordflow">if</span> (user-&gt;engineID == NULL &amp;&amp; nptr-&gt;engineID != NULL)
<a name="l03561"></a>03561             <span class="keywordflow">break</span>;
<a name="l03562"></a>03562 
<a name="l03563"></a>03563         <span class="keywordflow">if</span> (nptr-&gt;engineIDLen == user-&gt;engineIDLen &amp;&amp;
<a name="l03564"></a>03564             (nptr-&gt;engineID != NULL &amp;&amp; user-&gt;engineID != NULL &amp;&amp;
<a name="l03565"></a>03565              memcmp(nptr-&gt;engineID, user-&gt;engineID,
<a name="l03566"></a>03566                     user-&gt;engineIDLen) &gt; 0))
<a name="l03567"></a>03567             <span class="keywordflow">break</span>;
<a name="l03568"></a>03568 
<a name="l03569"></a>03569         <span class="keywordflow">if</span> (!(nptr-&gt;engineID == NULL &amp;&amp; user-&gt;engineID != NULL)) {
<a name="l03570"></a>03570             <span class="keywordflow">if</span> (nptr-&gt;engineIDLen == user-&gt;engineIDLen &amp;&amp;
<a name="l03571"></a>03571                 ((nptr-&gt;engineID == NULL &amp;&amp; user-&gt;engineID == NULL) ||
<a name="l03572"></a>03572                  memcmp(nptr-&gt;engineID, user-&gt;engineID,
<a name="l03573"></a>03573                         user-&gt;engineIDLen) == 0)
<a name="l03574"></a>03574                 &amp;&amp; strlen(nptr-&gt;name) &gt; strlen(user-&gt;name))
<a name="l03575"></a>03575                 <span class="keywordflow">break</span>;
<a name="l03576"></a>03576 
<a name="l03577"></a>03577             <span class="keywordflow">if</span> (nptr-&gt;engineIDLen == user-&gt;engineIDLen &amp;&amp;
<a name="l03578"></a>03578                 ((nptr-&gt;engineID == NULL &amp;&amp; user-&gt;engineID == NULL) ||
<a name="l03579"></a>03579                  memcmp(nptr-&gt;engineID, user-&gt;engineID,
<a name="l03580"></a>03580                         user-&gt;engineIDLen) == 0)
<a name="l03581"></a>03581                 &amp;&amp; strlen(nptr-&gt;name) == strlen(user-&gt;name)
<a name="l03582"></a>03582                 &amp;&amp; strcmp(nptr-&gt;name, user-&gt;name) &gt; 0)
<a name="l03583"></a>03583                 <span class="keywordflow">break</span>;
<a name="l03584"></a>03584 
<a name="l03585"></a>03585             <span class="keywordflow">if</span> (nptr-&gt;engineIDLen == user-&gt;engineIDLen &amp;&amp;
<a name="l03586"></a>03586                 ((nptr-&gt;engineID == NULL &amp;&amp; user-&gt;engineID == NULL) ||
<a name="l03587"></a>03587                  memcmp(nptr-&gt;engineID, user-&gt;engineID,
<a name="l03588"></a>03588                         user-&gt;engineIDLen) == 0)
<a name="l03589"></a>03589                 &amp;&amp; strlen(nptr-&gt;name) == strlen(user-&gt;name)
<a name="l03590"></a>03590                 &amp;&amp; strcmp(nptr-&gt;name, user-&gt;name) == 0) {
<a name="l03591"></a>03591                 <span class="comment">/*</span>
<a name="l03592"></a>03592 <span class="comment">                 * the user is an exact match of a previous entry.</span>
<a name="l03593"></a>03593 <span class="comment">                 * Credentials may be different, though, so remove</span>
<a name="l03594"></a>03594 <span class="comment">                 * the old entry (and add the new one)!</span>
<a name="l03595"></a>03595 <span class="comment">                 */</span>
<a name="l03596"></a>03596                 <span class="keywordflow">if</span> (pptr) { <span class="comment">/* change prev&#39;s next pointer */</span>
<a name="l03597"></a>03597                   pptr-&gt;next = nptr-&gt;next;
<a name="l03598"></a>03598                 }
<a name="l03599"></a>03599                 <span class="keywordflow">if</span> (nptr-&gt;next) { <span class="comment">/* change next&#39;s prev pointer */</span>
<a name="l03600"></a>03600                   nptr-&gt;next-&gt;prev = pptr;
<a name="l03601"></a>03601                 } 
<a name="l03602"></a>03602                 optr = nptr;
<a name="l03603"></a>03603                 nptr = optr-&gt;next; <span class="comment">/* add new user at this position */</span>
<a name="l03604"></a>03604                 <span class="comment">/* free the old user */</span>
<a name="l03605"></a>03605                 optr-&gt;next=NULL;
<a name="l03606"></a>03606                 optr-&gt;prev=NULL;
<a name="l03607"></a>03607                 usm_free_user(optr); 
<a name="l03608"></a>03608                 <span class="keywordflow">break</span>; <span class="comment">/* new user will be added below */</span>
<a name="l03609"></a>03609             }
<a name="l03610"></a>03610         }
<a name="l03611"></a>03611     }
<a name="l03612"></a>03612 
<a name="l03613"></a>03613     <span class="comment">/*</span>
<a name="l03614"></a>03614 <span class="comment">     * nptr should now point to the user that we need to add ourselves</span>
<a name="l03615"></a>03615 <span class="comment">     * in front of, and pptr should be our new &#39;prev&#39;. </span>
<a name="l03616"></a>03616 <span class="comment">     */</span>
<a name="l03617"></a>03617 
<a name="l03618"></a>03618     <span class="comment">/*</span>
<a name="l03619"></a>03619 <span class="comment">     * change our pointers </span>
<a name="l03620"></a>03620 <span class="comment">     */</span>
<a name="l03621"></a>03621     user-&gt;prev = pptr;
<a name="l03622"></a>03622     user-&gt;next = nptr;
<a name="l03623"></a>03623 
<a name="l03624"></a>03624     <span class="comment">/*</span>
<a name="l03625"></a>03625 <span class="comment">     * change the next&#39;s prev pointer </span>
<a name="l03626"></a>03626 <span class="comment">     */</span>
<a name="l03627"></a>03627     <span class="keywordflow">if</span> (user-&gt;next)
<a name="l03628"></a>03628         user-&gt;next-&gt;prev = user;
<a name="l03629"></a>03629 
<a name="l03630"></a>03630     <span class="comment">/*</span>
<a name="l03631"></a>03631 <span class="comment">     * change the prev&#39;s next pointer </span>
<a name="l03632"></a>03632 <span class="comment">     */</span>
<a name="l03633"></a>03633     <span class="keywordflow">if</span> (user-&gt;prev)
<a name="l03634"></a>03634         user-&gt;prev-&gt;next = user;
<a name="l03635"></a>03635 
<a name="l03636"></a>03636     <span class="comment">/*</span>
<a name="l03637"></a>03637 <span class="comment">     * rewind to the head of the list and return it (since the new head</span>
<a name="l03638"></a>03638 <span class="comment">     * could be us, we need to notify the above routine who the head now is. </span>
<a name="l03639"></a>03639 <span class="comment">     */</span>
<a name="l03640"></a>03640     <span class="keywordflow">for</span> (pptr = user; pptr-&gt;prev != NULL; pptr = pptr-&gt;prev);
<a name="l03641"></a>03641     <span class="keywordflow">return</span> pptr;
<a name="l03642"></a>03642 }
<a name="l03643"></a>03643 
<a name="l03644"></a>03644 <span class="comment">/*</span>
<a name="l03645"></a>03645 <span class="comment"> * usm_remove_user(): finds and removes a user from a list </span>
<a name="l03646"></a>03646 <span class="comment"> */</span>
<a name="l03647"></a>03647 <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *
<a name="l03648"></a>03648 usm_remove_user(<span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *user)
<a name="l03649"></a>03649 {
<a name="l03650"></a>03650     <span class="keywordflow">return</span> usm_remove_user_from_list(user, &amp;userList);
<a name="l03651"></a>03651 }
<a name="l03652"></a>03652 
<a name="l03653"></a>03653 <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *
<a name="l03654"></a>03654 usm_remove_user_from_list(<span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *user,
<a name="l03655"></a>03655                           <span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> **ppuserList)
<a name="l03656"></a>03656 {
<a name="l03657"></a>03657     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *nptr, *pptr;
<a name="l03658"></a>03658 
<a name="l03659"></a>03659     <span class="comment">/*</span>
<a name="l03660"></a>03660 <span class="comment">     * NULL pointers aren&#39;t allowed </span>
<a name="l03661"></a>03661 <span class="comment">     */</span>
<a name="l03662"></a>03662     <span class="keywordflow">if</span> (ppuserList == NULL)
<a name="l03663"></a>03663         <span class="keywordflow">return</span> NULL;
<a name="l03664"></a>03664 
<a name="l03665"></a>03665     <span class="keywordflow">if</span> (*ppuserList == NULL)
<a name="l03666"></a>03666         <span class="keywordflow">return</span> NULL;
<a name="l03667"></a>03667 
<a name="l03668"></a>03668     <span class="comment">/*</span>
<a name="l03669"></a>03669 <span class="comment">     * find the user in the list </span>
<a name="l03670"></a>03670 <span class="comment">     */</span>
<a name="l03671"></a>03671     <span class="keywordflow">for</span> (nptr = *ppuserList, pptr = NULL; nptr != NULL;
<a name="l03672"></a>03672          pptr = nptr, nptr = nptr-&gt;next) {
<a name="l03673"></a>03673         <span class="keywordflow">if</span> (nptr == user)
<a name="l03674"></a>03674             <span class="keywordflow">break</span>;
<a name="l03675"></a>03675     }
<a name="l03676"></a>03676 
<a name="l03677"></a>03677     <span class="keywordflow">if</span> (nptr) {
<a name="l03678"></a>03678         <span class="comment">/*</span>
<a name="l03679"></a>03679 <span class="comment">         * remove the user from the linked list </span>
<a name="l03680"></a>03680 <span class="comment">         */</span>
<a name="l03681"></a>03681         <span class="keywordflow">if</span> (pptr) {
<a name="l03682"></a>03682             pptr-&gt;next = nptr-&gt;next;
<a name="l03683"></a>03683         }
<a name="l03684"></a>03684         <span class="keywordflow">if</span> (nptr-&gt;next) {
<a name="l03685"></a>03685             nptr-&gt;next-&gt;prev = pptr;
<a name="l03686"></a>03686         }
<a name="l03687"></a>03687     } <span class="keywordflow">else</span> {
<a name="l03688"></a>03688         <span class="comment">/*</span>
<a name="l03689"></a>03689 <span class="comment">         * user didn&#39;t exist </span>
<a name="l03690"></a>03690 <span class="comment">         */</span>
<a name="l03691"></a>03691         <span class="keywordflow">return</span> NULL;
<a name="l03692"></a>03692     }
<a name="l03693"></a>03693     <span class="keywordflow">if</span> (nptr == *ppuserList)    <span class="comment">/* we&#39;re the head of the list, need to change</span>
<a name="l03694"></a>03694 <span class="comment">                                 * * the head to the next user */</span>
<a name="l03695"></a>03695         *ppuserList = nptr-&gt;next;
<a name="l03696"></a>03696     <span class="keywordflow">return</span> *ppuserList;
<a name="l03697"></a>03697 }                               <span class="comment">/* end usm_remove_user_from_list() */</span>
<a name="l03698"></a>03698 
<a name="l03699"></a>03699 
<a name="l03700"></a>03700 
<a name="l03701"></a>03701 
<a name="l03702"></a>03702 <span class="comment">/*</span>
<a name="l03703"></a>03703 <span class="comment"> * usm_free_user():  calls free() on all needed parts of struct usmUser and</span>
<a name="l03704"></a>03704 <span class="comment"> * the user himself.</span>
<a name="l03705"></a>03705 <span class="comment"> * </span>
<a name="l03706"></a>03706 <span class="comment"> * Note: This should *not* be called on an object in a list (IE,</span>
<a name="l03707"></a>03707 <span class="comment"> * remove it from the list first, and set next and prev to NULL), but</span>
<a name="l03708"></a>03708 <span class="comment"> * will try to reconnect the list pieces again if it is called this</span>
<a name="l03709"></a>03709 <span class="comment"> * way.  If called on the head of the list, the entire list will be</span>
<a name="l03710"></a>03710 <span class="comment"> * lost. </span>
<a name="l03711"></a>03711 <span class="comment"> */</span>
<a name="l03712"></a>03712 <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *
<a name="l03713"></a>03713 usm_free_user(<span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *user)
<a name="l03714"></a>03714 {
<a name="l03715"></a>03715     <span class="keywordflow">if</span> (user == NULL)
<a name="l03716"></a>03716         <span class="keywordflow">return</span> NULL;
<a name="l03717"></a>03717 
<a name="l03718"></a>03718     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;engineID);
<a name="l03719"></a>03719     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;name);
<a name="l03720"></a>03720     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;secName);
<a name="l03721"></a>03721     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;cloneFrom);
<a name="l03722"></a>03722     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;userPublicString);
<a name="l03723"></a>03723     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;authProtocol);
<a name="l03724"></a>03724     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;privProtocol);
<a name="l03725"></a>03725 
<a name="l03726"></a>03726     <span class="keywordflow">if</span> (user-&gt;authKey != NULL) {
<a name="l03727"></a>03727         <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title="Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(user-&gt;authKey, user-&gt;authKeyLen);
<a name="l03728"></a>03728         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;authKey);
<a name="l03729"></a>03729     }
<a name="l03730"></a>03730 
<a name="l03731"></a>03731     <span class="keywordflow">if</span> (user-&gt;privKey != NULL) {
<a name="l03732"></a>03732         <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title="Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(user-&gt;privKey, user-&gt;privKeyLen);
<a name="l03733"></a>03733         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;privKey);
<a name="l03734"></a>03734     }
<a name="l03735"></a>03735 
<a name="l03736"></a>03736 
<a name="l03737"></a>03737     <span class="comment">/*</span>
<a name="l03738"></a>03738 <span class="comment">     * FIX  Why not put this check *first?*</span>
<a name="l03739"></a>03739 <span class="comment">     */</span>
<a name="l03740"></a>03740     <span class="keywordflow">if</span> (user-&gt;prev != NULL) {   <span class="comment">/* ack, this shouldn&#39;t happen */</span>
<a name="l03741"></a>03741         user-&gt;prev-&gt;next = user-&gt;next;
<a name="l03742"></a>03742     }
<a name="l03743"></a>03743     <span class="keywordflow">if</span> (user-&gt;next != NULL) {
<a name="l03744"></a>03744         user-&gt;next-&gt;prev = user-&gt;prev;
<a name="l03745"></a>03745         <span class="keywordflow">if</span> (user-&gt;prev != NULL) <span class="comment">/* ack this is really bad, because it means</span>
<a name="l03746"></a>03746 <span class="comment">                                 * * we&#39;ll loose the head of some structure tree */</span>
<a name="l03747"></a>03747             DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>,
<a name="l03748"></a>03748                         <span class="stringliteral">&quot;Severe: Asked to free the head of a usmUser tree somewhere.&quot;</span>));
<a name="l03749"></a>03749     }
<a name="l03750"></a>03750 
<a name="l03751"></a>03751 
<a name="l03752"></a>03752     <a class="code" href="group__util.html#ga190280d08c828c153ec2755b9c263227" title="Zeros l bytes of memory starting at s.">SNMP_ZERO</a>(user, <span class="keyword">sizeof</span>(*user));
<a name="l03753"></a>03753     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user);
<a name="l03754"></a>03754 
<a name="l03755"></a>03755     <span class="keywordflow">return</span> NULL;                <span class="comment">/* for convenience to returns from calling functions */</span>
<a name="l03756"></a>03756 
<a name="l03757"></a>03757 }                               <span class="comment">/* end usm_free_user() */</span>
<a name="l03758"></a>03758 
<a name="l03759"></a>03759 
<a name="l03760"></a>03760 
<a name="l03761"></a>03761 
<a name="l03762"></a>03762 <span class="preprocessor">#ifndef NETSNMP_NO_WRITE_SUPPORT</span>
<a name="l03763"></a>03763 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l03764"></a>03764 <span class="comment"> * take a given user and clone the security info into another </span>
<a name="l03765"></a>03765 <span class="comment"> */</span>
<a name="l03766"></a>03766 <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *
<a name="l03767"></a>03767 usm_cloneFrom_user(<span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *from, <span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *to)
<a name="l03768"></a>03768 {
<a name="l03769"></a>03769     <span class="comment">/*</span>
<a name="l03770"></a>03770 <span class="comment">     * copy the authProtocol oid row pointer </span>
<a name="l03771"></a>03771 <span class="comment">     */</span>
<a name="l03772"></a>03772     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(to-&gt;authProtocol);
<a name="l03773"></a>03773 
<a name="l03774"></a>03774     <span class="keywordflow">if</span> ((to-&gt;authProtocol =
<a name="l03775"></a>03775          snmp_duplicate_objid(from-&gt;authProtocol,
<a name="l03776"></a>03776                               from-&gt;authProtocolLen)) != NULL)
<a name="l03777"></a>03777         to-&gt;authProtocolLen = from-&gt;authProtocolLen;
<a name="l03778"></a>03778     <span class="keywordflow">else</span>
<a name="l03779"></a>03779         to-&gt;authProtocolLen = 0;
<a name="l03780"></a>03780 
<a name="l03781"></a>03781 
<a name="l03782"></a>03782     <span class="comment">/*</span>
<a name="l03783"></a>03783 <span class="comment">     * copy the authKey </span>
<a name="l03784"></a>03784 <span class="comment">     */</span>
<a name="l03785"></a>03785     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(to-&gt;authKey);
<a name="l03786"></a>03786 
<a name="l03787"></a>03787     <span class="keywordflow">if</span> (from-&gt;authKeyLen &gt; 0 &amp;&amp;
<a name="l03788"></a>03788         (to-&gt;authKey = (u_char *) malloc(from-&gt;authKeyLen))
<a name="l03789"></a>03789         != NULL) {
<a name="l03790"></a>03790         to-&gt;authKeyLen = from-&gt;authKeyLen;
<a name="l03791"></a>03791         memcpy(to-&gt;authKey, from-&gt;authKey, to-&gt;authKeyLen);
<a name="l03792"></a>03792     } <span class="keywordflow">else</span> {
<a name="l03793"></a>03793         to-&gt;authKey = NULL;
<a name="l03794"></a>03794         to-&gt;authKeyLen = 0;
<a name="l03795"></a>03795     }
<a name="l03796"></a>03796 
<a name="l03797"></a>03797 
<a name="l03798"></a>03798     <span class="comment">/*</span>
<a name="l03799"></a>03799 <span class="comment">     * copy the privProtocol oid row pointer </span>
<a name="l03800"></a>03800 <span class="comment">     */</span>
<a name="l03801"></a>03801     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(to-&gt;privProtocol);
<a name="l03802"></a>03802 
<a name="l03803"></a>03803     <span class="keywordflow">if</span> ((to-&gt;privProtocol =
<a name="l03804"></a>03804          snmp_duplicate_objid(from-&gt;privProtocol,
<a name="l03805"></a>03805                               from-&gt;privProtocolLen)) != NULL)
<a name="l03806"></a>03806         to-&gt;privProtocolLen = from-&gt;privProtocolLen;
<a name="l03807"></a>03807     <span class="keywordflow">else</span>
<a name="l03808"></a>03808         to-&gt;privProtocolLen = 0;
<a name="l03809"></a>03809 
<a name="l03810"></a>03810     <span class="comment">/*</span>
<a name="l03811"></a>03811 <span class="comment">     * copy the privKey </span>
<a name="l03812"></a>03812 <span class="comment">     */</span>
<a name="l03813"></a>03813     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(to-&gt;privKey);
<a name="l03814"></a>03814 
<a name="l03815"></a>03815     <span class="keywordflow">if</span> (from-&gt;privKeyLen &gt; 0 &amp;&amp;
<a name="l03816"></a>03816         (to-&gt;privKey = (u_char *) malloc(from-&gt;privKeyLen))
<a name="l03817"></a>03817         != NULL) {
<a name="l03818"></a>03818         to-&gt;privKeyLen = from-&gt;privKeyLen;
<a name="l03819"></a>03819         memcpy(to-&gt;privKey, from-&gt;privKey, to-&gt;privKeyLen);
<a name="l03820"></a>03820     } <span class="keywordflow">else</span> {
<a name="l03821"></a>03821         to-&gt;privKey = NULL;
<a name="l03822"></a>03822         to-&gt;privKeyLen = 0;
<a name="l03823"></a>03823     }
<a name="l03824"></a>03824     <span class="keywordflow">return</span> to;
<a name="l03825"></a>03825 }
<a name="l03826"></a>03826 <span class="preprocessor">#endif </span><span class="comment">/* NETSNMP_NO_WRITE_SUPPORT */</span>
<a name="l03827"></a>03827 
<a name="l03828"></a>03828 <span class="comment">/*</span>
<a name="l03829"></a>03829 <span class="comment"> * usm_create_user(void):</span>
<a name="l03830"></a>03830 <span class="comment"> * create a default empty user, instantiating only the auth/priv</span>
<a name="l03831"></a>03831 <span class="comment"> * protocols to noAuth and noPriv OID pointers</span>
<a name="l03832"></a>03832 <span class="comment"> */</span>
<a name="l03833"></a>03833 <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *
<a name="l03834"></a>03834 usm_create_user(<span class="keywordtype">void</span>)
<a name="l03835"></a>03835 {
<a name="l03836"></a>03836     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *newUser;
<a name="l03837"></a>03837 
<a name="l03838"></a>03838     <span class="comment">/*</span>
<a name="l03839"></a>03839 <span class="comment">     * create the new user </span>
<a name="l03840"></a>03840 <span class="comment">     */</span>
<a name="l03841"></a>03841     newUser = (<span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *) calloc(1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a>));
<a name="l03842"></a>03842     <span class="keywordflow">if</span> (newUser == NULL)
<a name="l03843"></a>03843         <span class="keywordflow">return</span> NULL;
<a name="l03844"></a>03844 
<a name="l03845"></a>03845     <span class="comment">/*</span>
<a name="l03846"></a>03846 <span class="comment">     * fill the auth/priv protocols </span>
<a name="l03847"></a>03847 <span class="comment">     */</span>
<a name="l03848"></a>03848     <span class="keywordflow">if</span> ((newUser-&gt;authProtocol =
<a name="l03849"></a>03849          snmp_duplicate_objid(usmNoAuthProtocol,
<a name="l03850"></a>03850                               <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class="keyword">sizeof</span>(oid))) ==
<a name="l03851"></a>03851         NULL)
<a name="l03852"></a>03852         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03853"></a>03853     newUser-&gt;authProtocolLen = <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class="keyword">sizeof</span>(oid);
<a name="l03854"></a>03854 
<a name="l03855"></a>03855     <span class="keywordflow">if</span> ((newUser-&gt;privProtocol =
<a name="l03856"></a>03856          snmp_duplicate_objid(usmNoPrivProtocol,
<a name="l03857"></a>03857                               <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid))) ==
<a name="l03858"></a>03858         NULL)
<a name="l03859"></a>03859         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03860"></a>03860     newUser-&gt;privProtocolLen = <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid);
<a name="l03861"></a>03861 
<a name="l03862"></a>03862     <span class="comment">/*</span>
<a name="l03863"></a>03863 <span class="comment">     * set the storage type to nonvolatile, and the status to ACTIVE </span>
<a name="l03864"></a>03864 <span class="comment">     */</span>
<a name="l03865"></a>03865     newUser-&gt;userStorageType = ST_NONVOLATILE;
<a name="l03866"></a>03866     newUser-&gt;userStatus = RS_ACTIVE;
<a name="l03867"></a>03867     <span class="keywordflow">return</span> newUser;
<a name="l03868"></a>03868 
<a name="l03869"></a>03869 }                               <span class="comment">/* end usm_clone_user() */</span>
<a name="l03870"></a>03870 
<a name="l03871"></a>03871 
<a name="l03872"></a>03872 
<a name="l03873"></a>03873 
<a name="l03874"></a>03874 <span class="comment">/*</span>
<a name="l03875"></a>03875 <span class="comment"> * usm_create_initial_user(void):</span>
<a name="l03876"></a>03876 <span class="comment"> * creates an initial user, filled with the defaults defined in the</span>
<a name="l03877"></a>03877 <span class="comment"> * USM document.</span>
<a name="l03878"></a>03878 <span class="comment"> */</span>
<a name="l03879"></a>03879 <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *
<a name="l03880"></a>03880 usm_create_initial_user(<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l03881"></a>03881                         <span class="keyword">const</span> oid * authProtocol, <span class="keywordtype">size_t</span> authProtocolLen,
<a name="l03882"></a>03882                         <span class="keyword">const</span> oid * privProtocol, <span class="keywordtype">size_t</span> privProtocolLen)
<a name="l03883"></a>03883 {
<a name="l03884"></a>03884     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *newUser = usm_create_user();
<a name="l03885"></a>03885     <span class="keywordflow">if</span> (newUser == NULL)
<a name="l03886"></a>03886         <span class="keywordflow">return</span> NULL;
<a name="l03887"></a>03887 
<a name="l03888"></a>03888     <span class="keywordflow">if</span> ((newUser-&gt;name = strdup(name)) == NULL)
<a name="l03889"></a>03889         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03890"></a>03890 
<a name="l03891"></a>03891     <span class="keywordflow">if</span> ((newUser-&gt;secName = strdup(name)) == NULL)
<a name="l03892"></a>03892         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03893"></a>03893 
<a name="l03894"></a>03894     <span class="keywordflow">if</span> ((newUser-&gt;engineID =
<a name="l03895"></a>03895          snmpv3_generate_engineID(&amp;newUser-&gt;engineIDLen)) == NULL)
<a name="l03896"></a>03896         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03897"></a>03897 
<a name="l03898"></a>03898     <span class="keywordflow">if</span> ((newUser-&gt;cloneFrom = (oid *) malloc(<span class="keyword">sizeof</span>(oid) * 2)) == NULL)
<a name="l03899"></a>03899         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03900"></a>03900     newUser-&gt;cloneFrom[0] = 0;
<a name="l03901"></a>03901     newUser-&gt;cloneFrom[1] = 0;
<a name="l03902"></a>03902     newUser-&gt;cloneFromLen = 2;
<a name="l03903"></a>03903 
<a name="l03904"></a>03904     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(newUser-&gt;privProtocol);
<a name="l03905"></a>03905     <span class="keywordflow">if</span> ((newUser-&gt;privProtocol = snmp_duplicate_objid(privProtocol,
<a name="l03906"></a>03906                                                       privProtocolLen)) ==
<a name="l03907"></a>03907         NULL) {
<a name="l03908"></a>03908         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03909"></a>03909     }
<a name="l03910"></a>03910     newUser-&gt;privProtocolLen = privProtocolLen;
<a name="l03911"></a>03911 
<a name="l03912"></a>03912     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(newUser-&gt;authProtocol);
<a name="l03913"></a>03913     <span class="keywordflow">if</span> ((newUser-&gt;authProtocol = snmp_duplicate_objid(authProtocol,
<a name="l03914"></a>03914                                                       authProtocolLen)) ==
<a name="l03915"></a>03915         NULL) {
<a name="l03916"></a>03916         <span class="keywordflow">return</span> usm_free_user(newUser);
<a name="l03917"></a>03917     }
<a name="l03918"></a>03918     newUser-&gt;authProtocolLen = authProtocolLen;
<a name="l03919"></a>03919 
<a name="l03920"></a>03920     newUser-&gt;userStatus = RS_ACTIVE;
<a name="l03921"></a>03921     newUser-&gt;userStorageType = ST_READONLY;
<a name="l03922"></a>03922 
<a name="l03923"></a>03923     <span class="keywordflow">return</span> newUser;
<a name="l03924"></a>03924 }
<a name="l03925"></a>03925 
<a name="l03926"></a>03926 <span class="comment">/*</span>
<a name="l03927"></a>03927 <span class="comment"> * this is a callback that can store all known users based on a</span>
<a name="l03928"></a>03928 <span class="comment"> * previously registered application ID </span>
<a name="l03929"></a>03929 <span class="comment"> */</span>
<a name="l03930"></a>03930 <span class="keywordtype">int</span>
<a name="l03931"></a>03931 usm_store_users(<span class="keywordtype">int</span> majorID, <span class="keywordtype">int</span> minorID, <span class="keywordtype">void</span> *serverarg, <span class="keywordtype">void</span> *clientarg)
<a name="l03932"></a>03932 {
<a name="l03933"></a>03933     <span class="comment">/*</span>
<a name="l03934"></a>03934 <span class="comment">     * figure out our application name </span>
<a name="l03935"></a>03935 <span class="comment">     */</span>
<a name="l03936"></a>03936     <span class="keywordtype">char</span>           *appname = (<span class="keywordtype">char</span> *) clientarg;
<a name="l03937"></a>03937     <span class="keywordflow">if</span> (appname == NULL) {
<a name="l03938"></a>03938         appname = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
<a name="l03939"></a>03939                                         NETSNMP_DS_LIB_APPTYPE);
<a name="l03940"></a>03940     }
<a name="l03941"></a>03941 
<a name="l03942"></a>03942     <span class="comment">/*</span>
<a name="l03943"></a>03943 <span class="comment">     * save the user base </span>
<a name="l03944"></a>03944 <span class="comment">     */</span>
<a name="l03945"></a>03945     usm_save_users(<span class="stringliteral">&quot;usmUser&quot;</span>, appname);
<a name="l03946"></a>03946 
<a name="l03947"></a>03947     <span class="comment">/*</span>
<a name="l03948"></a>03948 <span class="comment">     * never fails </span>
<a name="l03949"></a>03949 <span class="comment">     */</span>
<a name="l03950"></a>03950     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
<a name="l03951"></a>03951 }
<a name="l03952"></a>03952 
<a name="l03953"></a>03953 
<a name="l03954"></a>03954 <span class="comment">/*</span>
<a name="l03955"></a>03955 <span class="comment"> * usm_save_users(): saves a list of users to the persistent cache </span>
<a name="l03956"></a>03956 <span class="comment"> */</span>
<a name="l03957"></a>03957 <span class="keywordtype">void</span>
<a name="l03958"></a>03958 usm_save_users(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keyword">const</span> <span class="keywordtype">char</span> *type)
<a name="l03959"></a>03959 {
<a name="l03960"></a>03960     usm_save_users_from_list(userList, token, type);
<a name="l03961"></a>03961 }
<a name="l03962"></a>03962 
<a name="l03963"></a>03963 <span class="keywordtype">void</span>
<a name="l03964"></a>03964 usm_save_users_from_list(<span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *puserList, <span class="keyword">const</span> <span class="keywordtype">char</span> *token,
<a name="l03965"></a>03965                          <span class="keyword">const</span> <span class="keywordtype">char</span> *type)
<a name="l03966"></a>03966 {
<a name="l03967"></a>03967     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *uptr;
<a name="l03968"></a>03968     <span class="keywordflow">for</span> (uptr = puserList; uptr != NULL; uptr = uptr-&gt;next) {
<a name="l03969"></a>03969         <span class="keywordflow">if</span> (uptr-&gt;userStorageType == ST_NONVOLATILE)
<a name="l03970"></a>03970             usm_save_user(uptr, token, type);
<a name="l03971"></a>03971     }
<a name="l03972"></a>03972 }
<a name="l03973"></a>03973 
<a name="l03974"></a>03974 <span class="comment">/*</span>
<a name="l03975"></a>03975 <span class="comment"> * usm_save_user(): saves a user to the persistent cache </span>
<a name="l03976"></a>03976 <span class="comment"> */</span>
<a name="l03977"></a>03977 <span class="keywordtype">void</span>
<a name="l03978"></a>03978 usm_save_user(<span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *user, <span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keyword">const</span> <span class="keywordtype">char</span> *type)
<a name="l03979"></a>03979 {
<a name="l03980"></a>03980     <span class="keywordtype">char</span>            line[4096];
<a name="l03981"></a>03981     <span class="keywordtype">char</span>           *cptr;
<a name="l03982"></a>03982 
<a name="l03983"></a>03983     memset(line, 0, <span class="keyword">sizeof</span>(line));
<a name="l03984"></a>03984 
<a name="l03985"></a>03985     sprintf(line, <span class="stringliteral">&quot;%s %d %d &quot;</span>, token, user-&gt;userStatus,
<a name="l03986"></a>03986             user-&gt;userStorageType);
<a name="l03987"></a>03987     cptr = &amp;line[strlen(line)]; <span class="comment">/* the NULL */</span>
<a name="l03988"></a>03988     cptr =
<a name="l03989"></a>03989         read_config_save_octet_string(cptr, user-&gt;engineID,
<a name="l03990"></a>03990                                       user-&gt;engineIDLen);
<a name="l03991"></a>03991     *cptr++ = <span class="charliteral">&#39; &#39;</span>;
<a name="l03992"></a>03992     cptr = read_config_save_octet_string(cptr, (u_char *) user-&gt;name,
<a name="l03993"></a>03993                                          (user-&gt;name == NULL) ? 0 :
<a name="l03994"></a>03994                                          strlen(user-&gt;name));
<a name="l03995"></a>03995     *cptr++ = <span class="charliteral">&#39; &#39;</span>;
<a name="l03996"></a>03996     cptr = read_config_save_octet_string(cptr, (u_char *) user-&gt;secName,
<a name="l03997"></a>03997                                          (user-&gt;secName == NULL) ? 0 :
<a name="l03998"></a>03998                                          strlen(user-&gt;secName));
<a name="l03999"></a>03999     *cptr++ = <span class="charliteral">&#39; &#39;</span>;
<a name="l04000"></a>04000     cptr =
<a name="l04001"></a>04001         read_config_save_objid(cptr, user-&gt;cloneFrom, user-&gt;cloneFromLen);
<a name="l04002"></a>04002     *cptr++ = <span class="charliteral">&#39; &#39;</span>;
<a name="l04003"></a>04003     cptr = read_config_save_objid(cptr, user-&gt;authProtocol,
<a name="l04004"></a>04004                                   user-&gt;authProtocolLen);
<a name="l04005"></a>04005     *cptr++ = <span class="charliteral">&#39; &#39;</span>;
<a name="l04006"></a>04006     cptr =
<a name="l04007"></a>04007         read_config_save_octet_string(cptr, user-&gt;authKey,
<a name="l04008"></a>04008                                       user-&gt;authKeyLen);
<a name="l04009"></a>04009     *cptr++ = <span class="charliteral">&#39; &#39;</span>;
<a name="l04010"></a>04010     cptr = read_config_save_objid(cptr, user-&gt;privProtocol,
<a name="l04011"></a>04011                                   user-&gt;privProtocolLen);
<a name="l04012"></a>04012     *cptr++ = <span class="charliteral">&#39; &#39;</span>;
<a name="l04013"></a>04013     cptr =
<a name="l04014"></a>04014         read_config_save_octet_string(cptr, user-&gt;privKey,
<a name="l04015"></a>04015                                       user-&gt;privKeyLen);
<a name="l04016"></a>04016     *cptr++ = <span class="charliteral">&#39; &#39;</span>;
<a name="l04017"></a>04017     cptr = read_config_save_octet_string(cptr, user-&gt;userPublicString,
<a name="l04018"></a>04018                                          user-&gt;userPublicStringLen);
<a name="l04019"></a>04019 
<a name="l04020"></a>04020     <a class="code" href="group__read__config.html#gae3adadf24d35a919f4b7a603e47583df" title="read_config_store intended for use by applications to store permenant configuration information gener...">read_config_store</a>(type, line);
<a name="l04021"></a>04021 }
<a name="l04022"></a>04022 
<a name="l04023"></a>04023 <span class="comment">/*</span>
<a name="l04024"></a>04024 <span class="comment"> * usm_parse_user(): reads in a line containing a saved user profile</span>
<a name="l04025"></a>04025 <span class="comment"> * and returns a pointer to a newly created struct usmUser. </span>
<a name="l04026"></a>04026 <span class="comment"> */</span>
<a name="l04027"></a>04027 <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *
<a name="l04028"></a>04028 usm_read_user(<span class="keyword">const</span> <span class="keywordtype">char</span> *line)
<a name="l04029"></a>04029 {
<a name="l04030"></a>04030     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *user;
<a name="l04031"></a>04031     <span class="keywordtype">size_t</span>          len;
<a name="l04032"></a>04032     <span class="keywordtype">size_t</span> expected_privKeyLen = 0;
<a name="l04033"></a>04033 
<a name="l04034"></a>04034     user = usm_create_user();
<a name="l04035"></a>04035     <span class="keywordflow">if</span> (user == NULL)
<a name="l04036"></a>04036         <span class="keywordflow">return</span> NULL;
<a name="l04037"></a>04037 
<a name="l04038"></a>04038     user-&gt;userStatus = atoi(line);
<a name="l04039"></a>04039     line = skip_token_const(line);
<a name="l04040"></a>04040     user-&gt;userStorageType = atoi(line);
<a name="l04041"></a>04041     line = skip_token_const(line);
<a name="l04042"></a>04042     line = read_config_read_octet_string_const(line, &amp;user-&gt;engineID,
<a name="l04043"></a>04043                                                &amp;user-&gt;engineIDLen);
<a name="l04044"></a>04044 
<a name="l04045"></a>04045     <span class="comment">/*</span>
<a name="l04046"></a>04046 <span class="comment">     * set the lcd entry for this engineID to the minimum boots/time</span>
<a name="l04047"></a>04047 <span class="comment">     * values so that its a known engineid and won&#39;t return a report pdu.</span>
<a name="l04048"></a>04048 <span class="comment">     * This is mostly important when receiving v3 traps so that the usm</span>
<a name="l04049"></a>04049 <span class="comment">     * will at least continue processing them. </span>
<a name="l04050"></a>04050 <span class="comment">     */</span>
<a name="l04051"></a>04051     set_enginetime(user-&gt;engineID, user-&gt;engineIDLen, 1, 0, 0);
<a name="l04052"></a>04052 
<a name="l04053"></a>04053     line = <a class="code" href="group__read__config.html#gacced211ea069a9d17ca1b1d7621cb0b2" title="Reads an octet string that was saved by the read_config_save_octet_string() function.">read_config_read_octet_string</a>(line, (u_char **) &amp; user-&gt;name,
<a name="l04054"></a>04054                                          &amp;len);
<a name="l04055"></a>04055     line = <a class="code" href="group__read__config.html#gacced211ea069a9d17ca1b1d7621cb0b2" title="Reads an octet string that was saved by the read_config_save_octet_string() function.">read_config_read_octet_string</a>(line, (u_char **) &amp; user-&gt;secName,
<a name="l04056"></a>04056                                          &amp;len);
<a name="l04057"></a>04057     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;cloneFrom);
<a name="l04058"></a>04058     user-&gt;cloneFromLen = 0;
<a name="l04059"></a>04059 
<a name="l04060"></a>04060     line = read_config_read_objid_const(line, &amp;user-&gt;cloneFrom,
<a name="l04061"></a>04061                                         &amp;user-&gt;cloneFromLen);
<a name="l04062"></a>04062 
<a name="l04063"></a>04063     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;authProtocol);
<a name="l04064"></a>04064     user-&gt;authProtocolLen = 0;
<a name="l04065"></a>04065 
<a name="l04066"></a>04066     line = read_config_read_objid_const(line, &amp;user-&gt;authProtocol,
<a name="l04067"></a>04067                                         &amp;user-&gt;authProtocolLen);
<a name="l04068"></a>04068     line = read_config_read_octet_string_const(line, &amp;user-&gt;authKey,
<a name="l04069"></a>04069                                                &amp;user-&gt;authKeyLen);
<a name="l04070"></a>04070     <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(user-&gt;privProtocol);
<a name="l04071"></a>04071     user-&gt;privProtocolLen = 0;
<a name="l04072"></a>04072 
<a name="l04073"></a>04073     line = read_config_read_objid_const(line, &amp;user-&gt;privProtocol,
<a name="l04074"></a>04074                                         &amp;user-&gt;privProtocolLen);
<a name="l04075"></a>04075     line = <a class="code" href="group__read__config.html#gacced211ea069a9d17ca1b1d7621cb0b2" title="Reads an octet string that was saved by the read_config_save_octet_string() function.">read_config_read_octet_string</a>(line, &amp;user-&gt;privKey,
<a name="l04076"></a>04076                                          &amp;user-&gt;privKeyLen);
<a name="l04077"></a>04077 <span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l04078"></a>04078 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ISTRANSFORM(user-&gt;privProtocol, DESPriv)) {
<a name="l04079"></a>04079         <span class="comment">/* DES uses a 128 bit key, 64 bits of which is a salt */</span>
<a name="l04080"></a>04080         expected_privKeyLen = 16;
<a name="l04081"></a>04081     }
<a name="l04082"></a>04082 <span class="preprocessor">#endif</span>
<a name="l04083"></a>04083 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l04084"></a>04084 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ISTRANSFORM(user-&gt;privProtocol, AESPriv)) {
<a name="l04085"></a>04085         expected_privKeyLen = 16;
<a name="l04086"></a>04086     }
<a name="l04087"></a>04087 <span class="preprocessor">#endif</span>
<a name="l04088"></a>04088 <span class="preprocessor"></span>    <span class="comment">/* For backwards compatibility */</span>
<a name="l04089"></a>04089     <span class="keywordflow">if</span> (user-&gt;privKeyLen &gt; expected_privKeyLen) {
<a name="l04090"></a>04090           user-&gt;privKeyLen = expected_privKeyLen;
<a name="l04091"></a>04091     }
<a name="l04092"></a>04092 
<a name="l04093"></a>04093     line = <a class="code" href="group__read__config.html#gacced211ea069a9d17ca1b1d7621cb0b2" title="Reads an octet string that was saved by the read_config_save_octet_string() function.">read_config_read_octet_string</a>(line, &amp;user-&gt;userPublicString,
<a name="l04094"></a>04094                                          &amp;user-&gt;userPublicStringLen);
<a name="l04095"></a>04095     <span class="keywordflow">return</span> user;
<a name="l04096"></a>04096 }
<a name="l04097"></a>04097 
<a name="l04098"></a>04098 <span class="comment">/*</span>
<a name="l04099"></a>04099 <span class="comment"> * snmpd.conf parsing routines </span>
<a name="l04100"></a>04100 <span class="comment"> */</span>
<a name="l04101"></a>04101 <span class="keywordtype">void</span>
<a name="l04102"></a>04102 usm_parse_config_usmUser(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keywordtype">char</span> *line)
<a name="l04103"></a>04103 {
<a name="l04104"></a>04104     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *uptr;
<a name="l04105"></a>04105 
<a name="l04106"></a>04106     uptr = usm_read_user(line);
<a name="l04107"></a>04107     <span class="keywordflow">if</span> ( uptr)
<a name="l04108"></a>04108         usm_add_user(uptr);
<a name="l04109"></a>04109 }
<a name="l04110"></a>04110 
<a name="l04111"></a>04111 
<a name="l04112"></a>04112 
<a name="l04113"></a>04113 
<a name="l04114"></a>04114 <span class="comment">/*******************************************************************-o-******</span>
<a name="l04115"></a>04115 <span class="comment"> * usm_set_password</span>
<a name="l04116"></a>04116 <span class="comment"> *</span>
<a name="l04117"></a>04117 <span class="comment"> * Parameters:</span>
<a name="l04118"></a>04118 <span class="comment"> *      *token</span>
<a name="l04119"></a>04119 <span class="comment"> *      *line</span>
<a name="l04120"></a>04120 <span class="comment"> *      </span>
<a name="l04121"></a>04121 <span class="comment"> *</span>
<a name="l04122"></a>04122 <span class="comment"> * format: userSetAuthPass     secname engineIDLen engineID pass</span>
<a name="l04123"></a>04123 <span class="comment"> *     or: userSetPrivPass     secname engineIDLen engineID pass </span>
<a name="l04124"></a>04124 <span class="comment"> *     or: userSetAuthKey      secname engineIDLen engineID KuLen Ku</span>
<a name="l04125"></a>04125 <span class="comment"> *     or: userSetPrivKey      secname engineIDLen engineID KuLen Ku </span>
<a name="l04126"></a>04126 <span class="comment"> *     or: userSetAuthLocalKey secname engineIDLen engineID KulLen Kul</span>
<a name="l04127"></a>04127 <span class="comment"> *     or: userSetPrivLocalKey secname engineIDLen engineID KulLen Kul </span>
<a name="l04128"></a>04128 <span class="comment"> *</span>
<a name="l04129"></a>04129 <span class="comment"> * type is:     1=passphrase; 2=Ku; 3=Kul.</span>
<a name="l04130"></a>04130 <span class="comment"> *</span>
<a name="l04131"></a>04131 <span class="comment"> *</span>
<a name="l04132"></a>04132 <span class="comment"> * ASSUMES  Passwords are null-terminated printable strings.</span>
<a name="l04133"></a>04133 <span class="comment"> */</span>
<a name="l04134"></a>04134 <span class="keywordtype">void</span>
<a name="l04135"></a>04135 usm_set_password(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keywordtype">char</span> *line)
<a name="l04136"></a>04136 {
<a name="l04137"></a>04137     <span class="keywordtype">char</span>           *cp;
<a name="l04138"></a>04138     <span class="keywordtype">char</span>            nameBuf[SNMP_MAXBUF];
<a name="l04139"></a>04139     u_char         *engineID;
<a name="l04140"></a>04140     <span class="keywordtype">size_t</span>          engineIDLen;
<a name="l04141"></a>04141     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *user;
<a name="l04142"></a>04142 
<a name="l04143"></a>04143     cp = copy_nword(line, nameBuf, <span class="keyword">sizeof</span>(nameBuf));
<a name="l04144"></a>04144     <span class="keywordflow">if</span> (cp == NULL) {
<a name="l04145"></a>04145         config_perror(<span class="stringliteral">&quot;invalid name specifier&quot;</span>);
<a name="l04146"></a>04146         <span class="keywordflow">return</span>;
<a name="l04147"></a>04147     }
<a name="l04148"></a>04148 
<a name="l04149"></a>04149     DEBUGMSGTL((<span class="stringliteral">&quot;usm&quot;</span>, <span class="stringliteral">&quot;comparing: %s and %s\n&quot;</span>, cp, WILDCARDSTRING));
<a name="l04150"></a>04150     <span class="keywordflow">if</span> (strncmp(cp, WILDCARDSTRING, strlen(WILDCARDSTRING)) == 0) {
<a name="l04151"></a>04151         <span class="comment">/*</span>
<a name="l04152"></a>04152 <span class="comment">         * match against all engineIDs we know about </span>
<a name="l04153"></a>04153 <span class="comment">         */</span>
<a name="l04154"></a>04154         cp = skip_token(cp);
<a name="l04155"></a>04155         <span class="keywordflow">for</span> (user = userList; user != NULL; user = user-&gt;next) {
<a name="l04156"></a>04156             <span class="keywordflow">if</span> (user-&gt;secName &amp;&amp; strcmp(user-&gt;secName, nameBuf) == 0) {
<a name="l04157"></a>04157                 usm_set_user_password(user, token, cp);
<a name="l04158"></a>04158             }
<a name="l04159"></a>04159         }
<a name="l04160"></a>04160     } <span class="keywordflow">else</span> {
<a name="l04161"></a>04161         cp = <a class="code" href="group__read__config.html#gacced211ea069a9d17ca1b1d7621cb0b2" title="Reads an octet string that was saved by the read_config_save_octet_string() function.">read_config_read_octet_string</a>(cp, &amp;engineID, &amp;engineIDLen);
<a name="l04162"></a>04162         <span class="keywordflow">if</span> (cp == NULL) {
<a name="l04163"></a>04163             config_perror(<span class="stringliteral">&quot;invalid engineID specifier&quot;</span>);
<a name="l04164"></a>04164             <span class="keywordflow">return</span>;
<a name="l04165"></a>04165         }
<a name="l04166"></a>04166 
<a name="l04167"></a>04167         user = usm_get_user(engineID, engineIDLen, nameBuf);
<a name="l04168"></a>04168         <span class="keywordflow">if</span> (user == NULL) {
<a name="l04169"></a>04169             config_perror(<span class="stringliteral">&quot;not a valid user/engineID pair&quot;</span>);
<a name="l04170"></a>04170             <span class="keywordflow">return</span>;
<a name="l04171"></a>04171         }
<a name="l04172"></a>04172         usm_set_user_password(user, token, cp);
<a name="l04173"></a>04173     }
<a name="l04174"></a>04174 }
<a name="l04175"></a>04175 
<a name="l04176"></a>04176 <span class="comment">/*</span>
<a name="l04177"></a>04177 <span class="comment"> * uses the rest of LINE to configure USER&#39;s password of type TOKEN </span>
<a name="l04178"></a>04178 <span class="comment"> */</span>
<a name="l04179"></a>04179 <span class="keywordtype">void</span>
<a name="l04180"></a>04180 usm_set_user_password(<span class="keyword">struct</span> <a class="code" href="structusmUser.html">usmUser</a> *user, <span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keywordtype">char</span> *line)
<a name="l04181"></a>04181 {
<a name="l04182"></a>04182     <span class="keywordtype">char</span>           *cp = line;
<a name="l04183"></a>04183     u_char         *engineID = user-&gt;engineID;
<a name="l04184"></a>04184     <span class="keywordtype">size_t</span>          engineIDLen = user-&gt;engineIDLen;
<a name="l04185"></a>04185 
<a name="l04186"></a>04186     u_char        **key;
<a name="l04187"></a>04187     <span class="keywordtype">size_t</span>         *keyLen;
<a name="l04188"></a>04188     u_char          userKey[SNMP_MAXBUF_SMALL];
<a name="l04189"></a>04189     <span class="keywordtype">size_t</span>          userKeyLen = SNMP_MAXBUF_SMALL;
<a name="l04190"></a>04190     u_char         *userKeyP = userKey;
<a name="l04191"></a>04191     <span class="keywordtype">int</span>             type, ret;
<a name="l04192"></a>04192 
<a name="l04193"></a>04193     <span class="comment">/*</span>
<a name="l04194"></a>04194 <span class="comment">     * Retrieve the &quot;old&quot; key and set the key type.</span>
<a name="l04195"></a>04195 <span class="comment">     */</span>
<a name="l04196"></a>04196     <span class="keywordflow">if</span> (!token) {
<a name="l04197"></a>04197         <span class="keywordflow">return</span>;
<a name="l04198"></a>04198     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(token, <span class="stringliteral">&quot;userSetAuthPass&quot;</span>) == 0) {
<a name="l04199"></a>04199         key = &amp;user-&gt;authKey;
<a name="l04200"></a>04200         keyLen = &amp;user-&gt;authKeyLen;
<a name="l04201"></a>04201         type = 0;
<a name="l04202"></a>04202     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(token, <span class="stringliteral">&quot;userSetPrivPass&quot;</span>) == 0) {
<a name="l04203"></a>04203         key = &amp;user-&gt;privKey;
<a name="l04204"></a>04204         keyLen = &amp;user-&gt;privKeyLen;
<a name="l04205"></a>04205         type = 0;
<a name="l04206"></a>04206     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(token, <span class="stringliteral">&quot;userSetAuthKey&quot;</span>) == 0) {
<a name="l04207"></a>04207         key = &amp;user-&gt;authKey;
<a name="l04208"></a>04208         keyLen = &amp;user-&gt;authKeyLen;
<a name="l04209"></a>04209         type = 1;
<a name="l04210"></a>04210     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(token, <span class="stringliteral">&quot;userSetPrivKey&quot;</span>) == 0) {
<a name="l04211"></a>04211         key = &amp;user-&gt;privKey;
<a name="l04212"></a>04212         keyLen = &amp;user-&gt;privKeyLen;
<a name="l04213"></a>04213         type = 1;
<a name="l04214"></a>04214     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(token, <span class="stringliteral">&quot;userSetAuthLocalKey&quot;</span>) == 0) {
<a name="l04215"></a>04215         key = &amp;user-&gt;authKey;
<a name="l04216"></a>04216         keyLen = &amp;user-&gt;authKeyLen;
<a name="l04217"></a>04217         type = 2;
<a name="l04218"></a>04218     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(token, <span class="stringliteral">&quot;userSetPrivLocalKey&quot;</span>) == 0) {
<a name="l04219"></a>04219         key = &amp;user-&gt;privKey;
<a name="l04220"></a>04220         keyLen = &amp;user-&gt;privKeyLen;
<a name="l04221"></a>04221         type = 2;
<a name="l04222"></a>04222     } <span class="keywordflow">else</span> {
<a name="l04223"></a>04223         <span class="comment">/*</span>
<a name="l04224"></a>04224 <span class="comment">         * no old key, or token was not recognized </span>
<a name="l04225"></a>04225 <span class="comment">         */</span>
<a name="l04226"></a>04226         <span class="keywordflow">return</span>;
<a name="l04227"></a>04227     }
<a name="l04228"></a>04228 
<a name="l04229"></a>04229     <span class="keywordflow">if</span> (*key) {
<a name="l04230"></a>04230         <span class="comment">/*</span>
<a name="l04231"></a>04231 <span class="comment">         * (destroy and) free the old key </span>
<a name="l04232"></a>04232 <span class="comment">         */</span>
<a name="l04233"></a>04233         memset(*key, 0, *keyLen);
<a name="l04234"></a>04234         <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(*key);
<a name="l04235"></a>04235     }
<a name="l04236"></a>04236 
<a name="l04237"></a>04237     <span class="keywordflow">if</span> (type == 0) {
<a name="l04238"></a>04238         <span class="comment">/*</span>
<a name="l04239"></a>04239 <span class="comment">         * convert the password into a key </span>
<a name="l04240"></a>04240 <span class="comment">         */</span>
<a name="l04241"></a>04241         <span class="keywordflow">if</span> (cp == NULL) {
<a name="l04242"></a>04242             config_perror(<span class="stringliteral">&quot;missing user password&quot;</span>);
<a name="l04243"></a>04243             <span class="keywordflow">return</span>;
<a name="l04244"></a>04244         }
<a name="l04245"></a>04245         ret = generate_Ku(user-&gt;authProtocol, user-&gt;authProtocolLen,
<a name="l04246"></a>04246                           (u_char *) cp, strlen(cp), userKey, &amp;userKeyLen);
<a name="l04247"></a>04247 
<a name="l04248"></a>04248         <span class="keywordflow">if</span> (ret != SNMPERR_SUCCESS) {
<a name="l04249"></a>04249             config_perror(<span class="stringliteral">&quot;setting key failed (in sc_genKu())&quot;</span>);
<a name="l04250"></a>04250             <span class="keywordflow">return</span>;
<a name="l04251"></a>04251         }
<a name="l04252"></a>04252     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == 1) {
<a name="l04253"></a>04253         cp = <a class="code" href="group__read__config.html#gacced211ea069a9d17ca1b1d7621cb0b2" title="Reads an octet string that was saved by the read_config_save_octet_string() function.">read_config_read_octet_string</a>(cp, &amp;userKeyP, &amp;userKeyLen);
<a name="l04254"></a>04254 
<a name="l04255"></a>04255         <span class="keywordflow">if</span> (cp == NULL) {
<a name="l04256"></a>04256             config_perror(<span class="stringliteral">&quot;invalid user key&quot;</span>);
<a name="l04257"></a>04257             <span class="keywordflow">return</span>;
<a name="l04258"></a>04258         }
<a name="l04259"></a>04259     }
<a name="l04260"></a>04260 
<a name="l04261"></a>04261     <span class="keywordflow">if</span> (type &lt; 2) {
<a name="l04262"></a>04262         *key = (u_char *) malloc(SNMP_MAXBUF_SMALL);
<a name="l04263"></a>04263         *keyLen = SNMP_MAXBUF_SMALL;
<a name="l04264"></a>04264         ret = generate_kul(user-&gt;authProtocol, user-&gt;authProtocolLen,
<a name="l04265"></a>04265                            engineID, engineIDLen,
<a name="l04266"></a>04266                            userKey, userKeyLen, *key, keyLen);
<a name="l04267"></a>04267         <span class="keywordflow">if</span> (ret != SNMPERR_SUCCESS) {
<a name="l04268"></a>04268             config_perror(<span class="stringliteral">&quot;setting key failed (in generate_kul())&quot;</span>);
<a name="l04269"></a>04269             <span class="keywordflow">return</span>;
<a name="l04270"></a>04270         }
<a name="l04271"></a>04271 
<a name="l04272"></a>04272         <span class="comment">/*</span>
<a name="l04273"></a>04273 <span class="comment">         * (destroy and) free the old key </span>
<a name="l04274"></a>04274 <span class="comment">         */</span>
<a name="l04275"></a>04275         memset(userKey, 0, <span class="keyword">sizeof</span>(userKey));
<a name="l04276"></a>04276 
<a name="l04277"></a>04277     } <span class="keywordflow">else</span> {
<a name="l04278"></a>04278         <span class="comment">/*</span>
<a name="l04279"></a>04279 <span class="comment">         * the key is given, copy it in </span>
<a name="l04280"></a>04280 <span class="comment">         */</span>
<a name="l04281"></a>04281         cp = <a class="code" href="group__read__config.html#gacced211ea069a9d17ca1b1d7621cb0b2" title="Reads an octet string that was saved by the read_config_save_octet_string() function.">read_config_read_octet_string</a>(cp, key, keyLen);
<a name="l04282"></a>04282 
<a name="l04283"></a>04283         <span class="keywordflow">if</span> (cp == NULL) {
<a name="l04284"></a>04284             config_perror(<span class="stringliteral">&quot;invalid localized user key&quot;</span>);
<a name="l04285"></a>04285             <span class="keywordflow">return</span>;
<a name="l04286"></a>04286         }
<a name="l04287"></a>04287     }
<a name="l04288"></a>04288 }                               <span class="comment">/* end usm_set_password() */</span>
<a name="l04289"></a>04289 
<a name="l04290"></a>04290 <span class="keywordtype">void</span>
<a name="l04291"></a>04291 usm_parse_create_usmUser(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keywordtype">char</span> *line)
<a name="l04292"></a>04292 {
<a name="l04293"></a>04293     <span class="keywordtype">char</span>           *cp;
<a name="l04294"></a>04294     <span class="keywordtype">char</span>            buf[SNMP_MAXBUF_MEDIUM];
<a name="l04295"></a>04295     <span class="keyword">struct </span><a class="code" href="structusmUser.html">usmUser</a> *newuser;
<a name="l04296"></a>04296     u_char          userKey[SNMP_MAXBUF_SMALL], *tmpp;
<a name="l04297"></a>04297     <span class="keywordtype">size_t</span>          userKeyLen = SNMP_MAXBUF_SMALL;
<a name="l04298"></a>04298     <span class="keywordtype">size_t</span>          privKeyLen = 0;
<a name="l04299"></a>04299     <span class="keywordtype">size_t</span>          ret;
<a name="l04300"></a>04300     <span class="keywordtype">int</span>             ret2;
<a name="l04301"></a>04301     <span class="keywordtype">int</span>             testcase;
<a name="l04302"></a>04302 
<a name="l04303"></a>04303     newuser = usm_create_user();
<a name="l04304"></a>04304 
<a name="l04305"></a>04305     <span class="comment">/*</span>
<a name="l04306"></a>04306 <span class="comment">     * READ: Security Name </span>
<a name="l04307"></a>04307 <span class="comment">     */</span>
<a name="l04308"></a>04308     cp = copy_nword(line, buf, <span class="keyword">sizeof</span>(buf));
<a name="l04309"></a>04309 
<a name="l04310"></a>04310     <span class="comment">/*</span>
<a name="l04311"></a>04311 <span class="comment">     * might be a -e ENGINEID argument </span>
<a name="l04312"></a>04312 <span class="comment">     */</span>
<a name="l04313"></a>04313     <span class="keywordflow">if</span> (strcmp(buf, <span class="stringliteral">&quot;-e&quot;</span>) == 0) {
<a name="l04314"></a>04314         <span class="keywordtype">size_t</span>          ebuf_len = 32, eout_len = 0;
<a name="l04315"></a>04315         u_char         *ebuf = (u_char *) malloc(ebuf_len);
<a name="l04316"></a>04316 
<a name="l04317"></a>04317         <span class="keywordflow">if</span> (ebuf == NULL) {
<a name="l04318"></a>04318             config_perror(<span class="stringliteral">&quot;malloc failure processing -e flag&quot;</span>);
<a name="l04319"></a>04319             usm_free_user(newuser);
<a name="l04320"></a>04320             <span class="keywordflow">return</span>;
<a name="l04321"></a>04321         }
<a name="l04322"></a>04322 
<a name="l04323"></a>04323         <span class="comment">/*</span>
<a name="l04324"></a>04324 <span class="comment">         * Get the specified engineid from the line.  </span>
<a name="l04325"></a>04325 <span class="comment">         */</span>
<a name="l04326"></a>04326         cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
<a name="l04327"></a>04327         <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#gabcc7d0fd7e0145ef532da8d0949c9131" title="convert an ASCII hex string to binary">snmp_hex_to_binary</a>(&amp;ebuf, &amp;ebuf_len, &amp;eout_len, 1, buf)) {
<a name="l04328"></a>04328             config_perror(<span class="stringliteral">&quot;invalid EngineID argument to -e&quot;</span>);
<a name="l04329"></a>04329             usm_free_user(newuser);
<a name="l04330"></a>04330             <a class="code" href="group__util.html#ga951e93edb6f0ea941e26155e3f8912a6" title="Frees a pointer only if it is !NULL and sets its value to NULL.">SNMP_FREE</a>(ebuf);
<a name="l04331"></a>04331             <span class="keywordflow">return</span>;
<a name="l04332"></a>04332         }
<a name="l04333"></a>04333 
<a name="l04334"></a>04334         newuser-&gt;engineID = ebuf;
<a name="l04335"></a>04335         newuser-&gt;engineIDLen = eout_len;
<a name="l04336"></a>04336         cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
<a name="l04337"></a>04337     } <span class="keywordflow">else</span> {
<a name="l04338"></a>04338         newuser-&gt;engineID = snmpv3_generate_engineID(&amp;ret);
<a name="l04339"></a>04339         <span class="keywordflow">if</span> (ret == 0) {
<a name="l04340"></a>04340             usm_free_user(newuser);
<a name="l04341"></a>04341             <span class="keywordflow">return</span>;
<a name="l04342"></a>04342         }
<a name="l04343"></a>04343         newuser-&gt;engineIDLen = ret;
<a name="l04344"></a>04344     }
<a name="l04345"></a>04345 
<a name="l04346"></a>04346     newuser-&gt;secName = strdup(buf);
<a name="l04347"></a>04347     newuser-&gt;name = strdup(buf);
<a name="l04348"></a>04348 
<a name="l04349"></a>04349     <span class="keywordflow">if</span> (!cp)
<a name="l04350"></a>04350         <span class="keywordflow">goto</span> add;               <span class="comment">/* no authentication or privacy type */</span>
<a name="l04351"></a>04351 
<a name="l04352"></a>04352     <span class="comment">/*</span>
<a name="l04353"></a>04353 <span class="comment">     * READ: Authentication Type </span>
<a name="l04354"></a>04354 <span class="comment">     */</span>
<a name="l04355"></a>04355 <span class="preprocessor">#ifndef NETSNMP_DISABLE_MD5</span>
<a name="l04356"></a>04356 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (strncmp(cp, <span class="stringliteral">&quot;MD5&quot;</span>, 3) == 0) {
<a name="l04357"></a>04357         memcpy(newuser-&gt;authProtocol, usmHMACMD5AuthProtocol,
<a name="l04358"></a>04358                <span class="keyword">sizeof</span>(usmHMACMD5AuthProtocol));
<a name="l04359"></a>04359     } <span class="keywordflow">else</span>
<a name="l04360"></a>04360 <span class="preprocessor">#endif</span>
<a name="l04361"></a>04361 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (strncmp(cp, <span class="stringliteral">&quot;SHA&quot;</span>, 3) == 0) {
<a name="l04362"></a>04362         memcpy(newuser-&gt;authProtocol, usmHMACSHA1AuthProtocol,
<a name="l04363"></a>04363                <span class="keyword">sizeof</span>(usmHMACSHA1AuthProtocol));
<a name="l04364"></a>04364     } <span class="keywordflow">else</span> {
<a name="l04365"></a>04365         config_perror(<span class="stringliteral">&quot;Unknown authentication protocol&quot;</span>);
<a name="l04366"></a>04366         usm_free_user(newuser);
<a name="l04367"></a>04367         <span class="keywordflow">return</span>;
<a name="l04368"></a>04368     }
<a name="l04369"></a>04369 
<a name="l04370"></a>04370     cp = skip_token(cp);
<a name="l04371"></a>04371 
<a name="l04372"></a>04372     <span class="comment">/*</span>
<a name="l04373"></a>04373 <span class="comment">     * READ: Authentication Pass Phrase or key</span>
<a name="l04374"></a>04374 <span class="comment">     */</span>
<a name="l04375"></a>04375     <span class="keywordflow">if</span> (!cp) {
<a name="l04376"></a>04376         config_perror(<span class="stringliteral">&quot;no authentication pass phrase&quot;</span>);
<a name="l04377"></a>04377         usm_free_user(newuser);
<a name="l04378"></a>04378         <span class="keywordflow">return</span>;
<a name="l04379"></a>04379     }
<a name="l04380"></a>04380     cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
<a name="l04381"></a>04381     <span class="keywordflow">if</span> (strcmp(buf,<span class="stringliteral">&quot;-m&quot;</span>) == 0) {
<a name="l04382"></a>04382         <span class="comment">/* a master key is specified */</span>
<a name="l04383"></a>04383         cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
<a name="l04384"></a>04384         ret = <span class="keyword">sizeof</span>(userKey);
<a name="l04385"></a>04385         tmpp = userKey;
<a name="l04386"></a>04386         userKeyLen = 0;
<a name="l04387"></a>04387         <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#gabcc7d0fd7e0145ef532da8d0949c9131" title="convert an ASCII hex string to binary">snmp_hex_to_binary</a>(&amp;tmpp, &amp;ret, &amp;userKeyLen, 0, buf)) {
<a name="l04388"></a>04388             config_perror(<span class="stringliteral">&quot;invalid key value argument to -m&quot;</span>);
<a name="l04389"></a>04389             usm_free_user(newuser);
<a name="l04390"></a>04390             <span class="keywordflow">return</span>;
<a name="l04391"></a>04391         }
<a name="l04392"></a>04392     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(buf,<span class="stringliteral">&quot;-l&quot;</span>) != 0) {
<a name="l04393"></a>04393         <span class="comment">/* a password is specified */</span>
<a name="l04394"></a>04394         userKeyLen = <span class="keyword">sizeof</span>(userKey);
<a name="l04395"></a>04395         ret2 = generate_Ku(newuser-&gt;authProtocol, newuser-&gt;authProtocolLen,
<a name="l04396"></a>04396                           (u_char *) buf, strlen(buf), userKey, &amp;userKeyLen);
<a name="l04397"></a>04397         <span class="keywordflow">if</span> (ret2 != SNMPERR_SUCCESS) {
<a name="l04398"></a>04398             config_perror(<span class="stringliteral">&quot;could not generate the authentication key from the &quot;</span>
<a name="l04399"></a>04399                           <span class="stringliteral">&quot;supplied pass phrase.&quot;</span>);
<a name="l04400"></a>04400             usm_free_user(newuser);
<a name="l04401"></a>04401             <span class="keywordflow">return</span>;
<a name="l04402"></a>04402         }
<a name="l04403"></a>04403     }        
<a name="l04404"></a>04404         
<a name="l04405"></a>04405     <span class="comment">/*</span>
<a name="l04406"></a>04406 <span class="comment">     * And turn it into a localized key </span>
<a name="l04407"></a>04407 <span class="comment">     */</span>
<a name="l04408"></a>04408     ret2 = sc_get_properlength(newuser-&gt;authProtocol,
<a name="l04409"></a>04409                                newuser-&gt;authProtocolLen);
<a name="l04410"></a>04410     <span class="keywordflow">if</span> (ret2 &lt;= 0) {
<a name="l04411"></a>04411         config_perror(<span class="stringliteral">&quot;Could not get proper authentication protocol key length&quot;</span>);
<a name="l04412"></a>04412         usm_free_user(newuser);
<a name="l04413"></a>04413         <span class="keywordflow">return</span>;
<a name="l04414"></a>04414     }
<a name="l04415"></a>04415     newuser-&gt;authKey = (u_char *) malloc(ret2);
<a name="l04416"></a>04416 
<a name="l04417"></a>04417     <span class="keywordflow">if</span> (strcmp(buf,<span class="stringliteral">&quot;-l&quot;</span>) == 0) {
<a name="l04418"></a>04418         <span class="comment">/* a local key is directly specified */</span>
<a name="l04419"></a>04419         cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
<a name="l04420"></a>04420         newuser-&gt;authKeyLen = 0;
<a name="l04421"></a>04421         ret = ret2;
<a name="l04422"></a>04422         <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#gabcc7d0fd7e0145ef532da8d0949c9131" title="convert an ASCII hex string to binary">snmp_hex_to_binary</a>(&amp;newuser-&gt;authKey, &amp;ret,
<a name="l04423"></a>04423                                 &amp;newuser-&gt;authKeyLen, 0, buf)) {
<a name="l04424"></a>04424             config_perror(<span class="stringliteral">&quot;invalid key value argument to -l&quot;</span>);
<a name="l04425"></a>04425             usm_free_user(newuser);
<a name="l04426"></a>04426             <span class="keywordflow">return</span>;
<a name="l04427"></a>04427         }
<a name="l04428"></a>04428         <span class="keywordflow">if</span> (ret != newuser-&gt;authKeyLen) {
<a name="l04429"></a>04429             config_perror(<span class="stringliteral">&quot;improper key length to -l&quot;</span>);
<a name="l04430"></a>04430             usm_free_user(newuser);
<a name="l04431"></a>04431             <span class="keywordflow">return</span>;
<a name="l04432"></a>04432         }
<a name="l04433"></a>04433     } <span class="keywordflow">else</span> {
<a name="l04434"></a>04434         newuser-&gt;authKeyLen = ret2;
<a name="l04435"></a>04435         ret2 = generate_kul(newuser-&gt;authProtocol, newuser-&gt;authProtocolLen,
<a name="l04436"></a>04436                            newuser-&gt;engineID, newuser-&gt;engineIDLen,
<a name="l04437"></a>04437                            userKey, userKeyLen,
<a name="l04438"></a>04438                            newuser-&gt;authKey, &amp;newuser-&gt;authKeyLen);
<a name="l04439"></a>04439         <span class="keywordflow">if</span> (ret2 != SNMPERR_SUCCESS) {
<a name="l04440"></a>04440             config_perror(<span class="stringliteral">&quot;could not generate localized authentication key &quot;</span>
<a name="l04441"></a>04441                           <span class="stringliteral">&quot;(Kul) from the master key (Ku).&quot;</span>);
<a name="l04442"></a>04442             usm_free_user(newuser);
<a name="l04443"></a>04443             <span class="keywordflow">return</span>;
<a name="l04444"></a>04444         }
<a name="l04445"></a>04445     }
<a name="l04446"></a>04446 
<a name="l04447"></a>04447     <span class="keywordflow">if</span> (!cp)
<a name="l04448"></a>04448         <span class="keywordflow">goto</span> add;               <span class="comment">/* no privacy type (which is legal) */</span>
<a name="l04449"></a>04449 
<a name="l04450"></a>04450     <span class="comment">/*</span>
<a name="l04451"></a>04451 <span class="comment">     * READ: Privacy Type </span>
<a name="l04452"></a>04452 <span class="comment">     */</span>
<a name="l04453"></a>04453     testcase = 0;
<a name="l04454"></a>04454 <span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l04455"></a>04455 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (strncmp(cp, <span class="stringliteral">&quot;DES&quot;</span>, 3) == 0) {
<a name="l04456"></a>04456         memcpy(newuser-&gt;privProtocol, usmDESPrivProtocol,
<a name="l04457"></a>04457                <span class="keyword">sizeof</span>(usmDESPrivProtocol));
<a name="l04458"></a>04458         testcase = 1;
<a name="l04459"></a>04459         <span class="comment">/* DES uses a 128 bit key, 64 bits of which is a salt */</span>
<a name="l04460"></a>04460         privKeyLen = 16;
<a name="l04461"></a>04461     }
<a name="l04462"></a>04462 <span class="preprocessor">#endif</span>
<a name="l04463"></a>04463 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_AES</span>
<a name="l04464"></a>04464 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (strncmp(cp, <span class="stringliteral">&quot;AES128&quot;</span>, 6) == 0 ||
<a name="l04465"></a>04465                strncmp(cp, <span class="stringliteral">&quot;AES&quot;</span>, 3) == 0) {
<a name="l04466"></a>04466         memcpy(newuser-&gt;privProtocol, usmAESPrivProtocol,
<a name="l04467"></a>04467                <span class="keyword">sizeof</span>(usmAESPrivProtocol));
<a name="l04468"></a>04468         testcase = 1;
<a name="l04469"></a>04469         privKeyLen = 16;
<a name="l04470"></a>04470     }
<a name="l04471"></a>04471 <span class="preprocessor">#endif</span>
<a name="l04472"></a>04472 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (testcase == 0) {
<a name="l04473"></a>04473         config_perror(<span class="stringliteral">&quot;Unknown privacy protocol&quot;</span>);
<a name="l04474"></a>04474         usm_free_user(newuser);
<a name="l04475"></a>04475         <span class="keywordflow">return</span>;
<a name="l04476"></a>04476     }
<a name="l04477"></a>04477 
<a name="l04478"></a>04478     cp = skip_token(cp);
<a name="l04479"></a>04479     <span class="comment">/*</span>
<a name="l04480"></a>04480 <span class="comment">     * READ: Encryption Pass Phrase or key</span>
<a name="l04481"></a>04481 <span class="comment">     */</span>
<a name="l04482"></a>04482     <span class="keywordflow">if</span> (!cp) {
<a name="l04483"></a>04483         <span class="comment">/*</span>
<a name="l04484"></a>04484 <span class="comment">         * assume the same as the authentication key </span>
<a name="l04485"></a>04485 <span class="comment">         */</span>
<a name="l04486"></a>04486         <a class="code" href="group__util.html#ga098ada1e30ad7ee207ba90b73db7000a" title="Duplicates a memory block.">memdup</a>(&amp;newuser-&gt;privKey, newuser-&gt;authKey, newuser-&gt;authKeyLen);
<a name="l04487"></a>04487         newuser-&gt;privKeyLen = newuser-&gt;authKeyLen;
<a name="l04488"></a>04488     } <span class="keywordflow">else</span> {
<a name="l04489"></a>04489         cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
<a name="l04490"></a>04490         
<a name="l04491"></a>04491         <span class="keywordflow">if</span> (strcmp(buf,<span class="stringliteral">&quot;-m&quot;</span>) == 0) {
<a name="l04492"></a>04492             <span class="comment">/* a master key is specified */</span>
<a name="l04493"></a>04493             cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
<a name="l04494"></a>04494             ret = <span class="keyword">sizeof</span>(userKey);
<a name="l04495"></a>04495             tmpp = userKey;
<a name="l04496"></a>04496             userKeyLen = 0;
<a name="l04497"></a>04497             <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#gabcc7d0fd7e0145ef532da8d0949c9131" title="convert an ASCII hex string to binary">snmp_hex_to_binary</a>(&amp;tmpp, &amp;ret, &amp;userKeyLen, 0, buf)) {
<a name="l04498"></a>04498                 config_perror(<span class="stringliteral">&quot;invalid key value argument to -m&quot;</span>);
<a name="l04499"></a>04499                 usm_free_user(newuser);
<a name="l04500"></a>04500                 <span class="keywordflow">return</span>;
<a name="l04501"></a>04501             }
<a name="l04502"></a>04502         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(buf,<span class="stringliteral">&quot;-l&quot;</span>) != 0) {
<a name="l04503"></a>04503             <span class="comment">/* a password is specified */</span>
<a name="l04504"></a>04504             userKeyLen = <span class="keyword">sizeof</span>(userKey);
<a name="l04505"></a>04505             ret2 = generate_Ku(newuser-&gt;authProtocol, newuser-&gt;authProtocolLen,
<a name="l04506"></a>04506                               (u_char *) buf, strlen(buf), userKey, &amp;userKeyLen);
<a name="l04507"></a>04507             <span class="keywordflow">if</span> (ret2 != SNMPERR_SUCCESS) {
<a name="l04508"></a>04508                 config_perror(<span class="stringliteral">&quot;could not generate the privacy key from the &quot;</span>
<a name="l04509"></a>04509                               <span class="stringliteral">&quot;supplied pass phrase.&quot;</span>);
<a name="l04510"></a>04510                 usm_free_user(newuser);
<a name="l04511"></a>04511                 <span class="keywordflow">return</span>;
<a name="l04512"></a>04512             }
<a name="l04513"></a>04513         }        
<a name="l04514"></a>04514         
<a name="l04515"></a>04515         <span class="comment">/*</span>
<a name="l04516"></a>04516 <span class="comment">         * And turn it into a localized key </span>
<a name="l04517"></a>04517 <span class="comment">         */</span>
<a name="l04518"></a>04518         ret2 = sc_get_properlength(newuser-&gt;authProtocol,
<a name="l04519"></a>04519                                    newuser-&gt;authProtocolLen);
<a name="l04520"></a>04520         <span class="keywordflow">if</span> (ret2 &lt; 0) {
<a name="l04521"></a>04521             config_perror(<span class="stringliteral">&quot;could not get proper key length to use for the &quot;</span>
<a name="l04522"></a>04522                           <span class="stringliteral">&quot;privacy algorithm.&quot;</span>);
<a name="l04523"></a>04523             usm_free_user(newuser);
<a name="l04524"></a>04524             <span class="keywordflow">return</span>;
<a name="l04525"></a>04525         }
<a name="l04526"></a>04526         newuser-&gt;privKey = (u_char *) malloc(ret2);
<a name="l04527"></a>04527 
<a name="l04528"></a>04528         <span class="keywordflow">if</span> (strcmp(buf,<span class="stringliteral">&quot;-l&quot;</span>) == 0) {
<a name="l04529"></a>04529             <span class="comment">/* a local key is directly specified */</span>
<a name="l04530"></a>04530             cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
<a name="l04531"></a>04531             ret = ret2;
<a name="l04532"></a>04532             newuser-&gt;privKeyLen = 0;
<a name="l04533"></a>04533             <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#gabcc7d0fd7e0145ef532da8d0949c9131" title="convert an ASCII hex string to binary">snmp_hex_to_binary</a>(&amp;newuser-&gt;privKey, &amp;ret,
<a name="l04534"></a>04534                                     &amp;newuser-&gt;privKeyLen, 0, buf)) {
<a name="l04535"></a>04535                 config_perror(<span class="stringliteral">&quot;invalid key value argument to -l&quot;</span>);
<a name="l04536"></a>04536                 usm_free_user(newuser);
<a name="l04537"></a>04537                 <span class="keywordflow">return</span>;
<a name="l04538"></a>04538             }
<a name="l04539"></a>04539         } <span class="keywordflow">else</span> {
<a name="l04540"></a>04540             newuser-&gt;privKeyLen = ret2;
<a name="l04541"></a>04541             ret2 = generate_kul(newuser-&gt;authProtocol, newuser-&gt;authProtocolLen,
<a name="l04542"></a>04542                                newuser-&gt;engineID, newuser-&gt;engineIDLen,
<a name="l04543"></a>04543                                userKey, userKeyLen,
<a name="l04544"></a>04544                                newuser-&gt;privKey, &amp;newuser-&gt;privKeyLen);
<a name="l04545"></a>04545             <span class="keywordflow">if</span> (ret2 != SNMPERR_SUCCESS) {
<a name="l04546"></a>04546                 config_perror(<span class="stringliteral">&quot;could not generate localized privacy key &quot;</span>
<a name="l04547"></a>04547                               <span class="stringliteral">&quot;(Kul) from the master key (Ku).&quot;</span>);
<a name="l04548"></a>04548                 usm_free_user(newuser);
<a name="l04549"></a>04549                 <span class="keywordflow">return</span>;
<a name="l04550"></a>04550             }
<a name="l04551"></a>04551         }
<a name="l04552"></a>04552     }
<a name="l04553"></a>04553 
<a name="l04554"></a>04554     <span class="keywordflow">if</span> ((newuser-&gt;privKeyLen &gt;= privKeyLen) || (privKeyLen == 0)){
<a name="l04555"></a>04555       newuser-&gt;privKeyLen = privKeyLen;
<a name="l04556"></a>04556     }
<a name="l04557"></a>04557     <span class="keywordflow">else</span> {
<a name="l04558"></a>04558       <span class="comment">/* The privKey length is smaller than required by privProtocol */</span>
<a name="l04559"></a>04559       usm_free_user(newuser);
<a name="l04560"></a>04560       <span class="keywordflow">return</span>;
<a name="l04561"></a>04561     }
<a name="l04562"></a>04562 
<a name="l04563"></a>04563   add:
<a name="l04564"></a>04564     usm_add_user(newuser);
<a name="l04565"></a>04565     DEBUGMSGTL((<span class="stringliteral">&quot;usmUser&quot;</span>, <span class="stringliteral">&quot;created a new user %s at &quot;</span>, newuser-&gt;secName));
<a name="l04566"></a>04566     DEBUGMSGHEX((<span class="stringliteral">&quot;usmUser&quot;</span>, newuser-&gt;engineID, newuser-&gt;engineIDLen));
<a name="l04567"></a>04567     DEBUGMSG((<span class="stringliteral">&quot;usmUser&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>));
<a name="l04568"></a>04568 }
<a name="l04569"></a>04569 
<a name="l04570"></a>04570 <span class="keywordtype">void</span>
<a name="l04571"></a>04571 snmpv3_authtype_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class="keywordtype">char</span> *cptr)
<a name="l04572"></a>04572 {
<a name="l04573"></a>04573 <span class="preprocessor">#ifndef NETSNMP_DISABLE_MD5</span>
<a name="l04574"></a>04574 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (strcasecmp(cptr, <span class="stringliteral">&quot;MD5&quot;</span>) == 0)
<a name="l04575"></a>04575         defaultAuthType = usmHMACMD5AuthProtocol;
<a name="l04576"></a>04576     <span class="keywordflow">else</span>
<a name="l04577"></a>04577 <span class="preprocessor">#endif</span>
<a name="l04578"></a>04578 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (strcasecmp(cptr, <span class="stringliteral">&quot;SHA&quot;</span>) == 0)
<a name="l04579"></a>04579         defaultAuthType = usmHMACSHA1AuthProtocol;
<a name="l04580"></a>04580     <span class="keywordflow">else</span>
<a name="l04581"></a>04581         config_perror(<span class="stringliteral">&quot;Unknown authentication type&quot;</span>);
<a name="l04582"></a>04582     defaultAuthTypeLen = USM_LENGTH_OID_TRANSFORM;
<a name="l04583"></a>04583     DEBUGMSGTL((<span class="stringliteral">&quot;snmpv3&quot;</span>, <span class="stringliteral">&quot;set default authentication type: %s\n&quot;</span>, cptr));
<a name="l04584"></a>04584 }
<a name="l04585"></a>04585 
<a name="l04586"></a>04586 <span class="keyword">const</span> oid      *
<a name="l04587"></a>04587 get_default_authtype(<span class="keywordtype">size_t</span> * len)
<a name="l04588"></a>04588 {
<a name="l04589"></a>04589     <span class="keywordflow">if</span> (defaultAuthType == NULL) {
<a name="l04590"></a>04590         defaultAuthType = SNMP_DEFAULT_AUTH_PROTO;
<a name="l04591"></a>04591         defaultAuthTypeLen = SNMP_DEFAULT_AUTH_PROTOLEN;
<a name="l04592"></a>04592     }
<a name="l04593"></a>04593     <span class="keywordflow">if</span> (len)
<a name="l04594"></a>04594         *len = defaultAuthTypeLen;
<a name="l04595"></a>04595     <span class="keywordflow">return</span> defaultAuthType;
<a name="l04596"></a>04596 }
<a name="l04597"></a>04597 
<a name="l04598"></a>04598 <span class="keywordtype">void</span>
<a name="l04599"></a>04599 snmpv3_privtype_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class="keywordtype">char</span> *cptr)
<a name="l04600"></a>04600 {
<a name="l04601"></a>04601     <span class="keywordtype">int</span> testcase = 0;
<a name="l04602"></a>04602 
<a name="l04603"></a>04603 <span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l04604"></a>04604 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (strcasecmp(cptr, <span class="stringliteral">&quot;DES&quot;</span>) == 0) {
<a name="l04605"></a>04605         testcase = 1;
<a name="l04606"></a>04606         defaultPrivType = usmDESPrivProtocol;
<a name="l04607"></a>04607     }
<a name="l04608"></a>04608 <span class="preprocessor">#endif</span>
<a name="l04609"></a>04609 <span class="preprocessor"></span>
<a name="l04610"></a>04610 <span class="preprocessor">#if HAVE_AES</span>
<a name="l04611"></a>04611 <span class="preprocessor"></span>    <span class="comment">/* XXX AES: assumes oid length == des oid length */</span>
<a name="l04612"></a>04612     <span class="keywordflow">if</span> (strcasecmp(cptr, <span class="stringliteral">&quot;AES128&quot;</span>) == 0 ||
<a name="l04613"></a>04613         strcasecmp(cptr, <span class="stringliteral">&quot;AES&quot;</span>) == 0) {
<a name="l04614"></a>04614         testcase = 1;
<a name="l04615"></a>04615         defaultPrivType = usmAES128PrivProtocol;
<a name="l04616"></a>04616     }
<a name="l04617"></a>04617 <span class="preprocessor">#endif</span>
<a name="l04618"></a>04618 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (testcase == 0)
<a name="l04619"></a>04619         config_perror(<span class="stringliteral">&quot;Unknown privacy type&quot;</span>);
<a name="l04620"></a>04620     defaultPrivTypeLen = SNMP_DEFAULT_PRIV_PROTOLEN;
<a name="l04621"></a>04621     DEBUGMSGTL((<span class="stringliteral">&quot;snmpv3&quot;</span>, <span class="stringliteral">&quot;set default privacy type: %s\n&quot;</span>, cptr));
<a name="l04622"></a>04622 }
<a name="l04623"></a>04623 
<a name="l04624"></a>04624 <span class="keyword">const</span> oid      *
<a name="l04625"></a>04625 get_default_privtype(<span class="keywordtype">size_t</span> * len)
<a name="l04626"></a>04626 {
<a name="l04627"></a>04627     <span class="keywordflow">if</span> (defaultPrivType == NULL) {
<a name="l04628"></a>04628 <span class="preprocessor">#ifndef NETSNMP_DISABLE_DES</span>
<a name="l04629"></a>04629 <span class="preprocessor"></span>        defaultPrivType = usmDESPrivProtocol;
<a name="l04630"></a>04630 <span class="preprocessor">#else</span>
<a name="l04631"></a>04631 <span class="preprocessor"></span>        defaultPrivType = usmAESPrivProtocol;
<a name="l04632"></a>04632 <span class="preprocessor">#endif</span>
<a name="l04633"></a>04633 <span class="preprocessor"></span>        defaultPrivTypeLen = USM_LENGTH_OID_TRANSFORM;
<a name="l04634"></a>04634     }
<a name="l04635"></a>04635     <span class="keywordflow">if</span> (len)
<a name="l04636"></a>04636         *len = defaultPrivTypeLen;
<a name="l04637"></a>04637     <span class="keywordflow">return</span> defaultPrivType;
<a name="l04638"></a>04638 }
<a name="l04639"></a>04639 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jul 14 2011 for net-snmp by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
