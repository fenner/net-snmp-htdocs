<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>asn1.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * Abstract Syntax Notation One, ASN.1</span>
00003 <span class="comment"> * As defined in ISO/IS 8824 and ISO/IS 8825</span>
00004 <span class="comment"> * This implements a subset of the above International Standards that</span>
00005 <span class="comment"> * is sufficient to implement SNMP.</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * Encodes abstract data types into a machine independent stream of bytes.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> */</span>
00010 <span class="comment">/**********************************************************************</span>
00011 <span class="comment">        Copyright 1988, 1989, 1991, 1992 by Carnegie Mellon University</span>
00012 
00013 <span class="comment">                      All Rights Reserved</span>
00014 
00015 <span class="comment">Permission to use, copy, modify, and distribute this software and its </span>
00016 <span class="comment">documentation for any purpose and without fee is hereby granted, </span>
00017 <span class="comment">provided that the above copyright notice appear in all copies and that</span>
00018 <span class="comment">both that copyright notice and this permission notice appear in </span>
00019 <span class="comment">supporting documentation, and that the name of CMU not be</span>
00020 <span class="comment">used in advertising or publicity pertaining to distribution of the</span>
00021 <span class="comment">software without specific, written prior permission.  </span>
00022 
00023 <span class="comment">CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING</span>
00024 <span class="comment">ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL</span>
00025 <span class="comment">CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR</span>
00026 <span class="comment">ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</span>
00027 <span class="comment">WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,</span>
00028 <span class="comment">ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS</span>
00029 <span class="comment">SOFTWARE.</span>
00030 <span class="comment">******************************************************************/</span>
00156 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00157 
00158 <span class="preprocessor">#ifdef KINETICS</span>
00159 <span class="preprocessor">#include "gw.h"</span>
00160 <span class="preprocessor">#endif</span>
00161 
00162 <span class="preprocessor">#if HAVE_STRING_H</span>
00163 <span class="preprocessor">#include &lt;string.h&gt;</span>
00164 <span class="preprocessor">#else</span>
00165 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00166 <span class="preprocessor">#endif</span>
00167 
00168 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00169 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00170 <span class="preprocessor">#ifdef HAVE_STDLIB_H</span>
00171 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00172 <span class="preprocessor">#endif</span>
00173 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00174 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00175 <span class="preprocessor">#endif</span>
00176 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00177 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00178 <span class="preprocessor">#endif</span>
00179 
00180 <span class="preprocessor">#ifdef vms</span>
00181 <span class="preprocessor">#include &lt;in.h&gt;</span>
00182 <span class="preprocessor">#endif</span>
00183 
00184 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00185 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00186 <span class="preprocessor">#endif</span>
00187 
00188 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00189 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00190 
00191 <span class="preprocessor">#include &lt;net-snmp/library/asn1.h&gt;</span>
00192 <span class="preprocessor">#include &lt;net-snmp/library/int64.h&gt;</span>
00193 <span class="preprocessor">#include &lt;net-snmp/library/mib.h&gt;</span>
00194 
00195 <span class="preprocessor">#ifndef NULL</span>
00196 <span class="preprocessor">#define NULL    0</span>
00197 <span class="preprocessor">#endif</span>
00198 
00199 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00200 
00209 <span class="keyword">static</span>
00210     <span class="keywordtype">void</span>
00211 _asn_size_err(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *str, size_t wrongsize, size_t rightsize)
00212 {
00213     <span class="keywordtype">char</span>            ebuf[128];
00214 
00215     snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
00216             <span class="stringliteral">"%s size %lu: s/b %lu"</span>, str,
00217             (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)wrongsize, (<span class=
"keywordtype">unsigned</span> <span class="keywordtype">long</span>)rightsize);
00218     ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
00219     ERROR_MSG(ebuf);
00220 }
00221 
00230 <span class="keyword">static</span>
00231     <span class="keywordtype">void</span>
00232 _asn_length_err(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *str, size_t wrongsize, size_t rightsize)
00233 {
00234     <span class="keywordtype">char</span>            ebuf[128];
00235 
00236     snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
00237             <span class="stringliteral">"%s length %lu too large: exceeds %lu"</span>, str,
00238             (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)wrongsize, (<span class=
"keywordtype">unsigned</span> <span class="keywordtype">long</span>)rightsize);
00239     ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
00240     ERROR_MSG(ebuf);
00241 }
00242 
00255 <span class="keyword">static</span>
00256     <span class="keywordtype">int</span>
00257 _asn_parse_length_check(<span class="keyword">const</span> <span class="keywordtype">char</span> *str,
00258                         <span class="keyword">const</span> u_char * bufp, <span class="keyword">const</span> u_char * data,
00259                         u_long plen, size_t dlen)
00260 {
00261     <span class="keywordtype">char</span>            ebuf[128];
00262     size_t          header_len;
00263 
00264     <span class="keywordflow">if</span> (bufp == NULL) {
00265         <span class="comment">/*</span>
00266 <span class="comment">         * error message is set </span>
00267 <span class="comment">         */</span>
00268         <span class="keywordflow">return</span> 1;
00269     }
00270     header_len = bufp - data;
00271     <span class="keywordflow">if</span> (plen &gt; 0x7fffffff || header_len &gt; 0x7fffffff ||
00272         ((size_t) plen + header_len) &gt; dlen) {
00273         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
00274                 <span class="stringliteral">"%s: message overflow: %d len + %d delta &gt; %d len"</span>,
00275                 str, (<span class="keywordtype">int</span>) plen, (<span class=
"keywordtype">int</span>) header_len, (<span class="keywordtype">int</span>) dlen);
00276         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
00277         ERROR_MSG(ebuf);
00278         <span class="keywordflow">return</span> 1;
00279     }
00280     <span class="keywordflow">return</span> 0;
00281 }
00282 
00283 
00295 <span class="keyword">static</span>
00296     <span class="keywordtype">int</span>
00297 _asn_build_header_check(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class=
"keyword">const</span> u_char * data,
00298                         size_t datalen, size_t typedlen)
00299 {
00300     <span class="keywordtype">char</span>            ebuf[128];
00301 
00302     <span class="keywordflow">if</span> (data == NULL) {
00303         <span class="comment">/*</span>
00304 <span class="comment">         * error message is set </span>
00305 <span class="comment">         */</span>
00306         <span class="keywordflow">return</span> 1;
00307     }
00308     <span class="keywordflow">if</span> (datalen &lt; typedlen) {
00309         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
00310                 <span class="stringliteral">"%s: bad header, length too short: %lu &lt; %lu"</span>, str,
00311                 (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)datalen, (<span class=
"keywordtype">unsigned</span> <span class="keywordtype">long</span>)typedlen);
00312         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
00313         ERROR_MSG(ebuf);
00314         <span class="keywordflow">return</span> 1;
00315     }
00316     <span class="keywordflow">return</span> 0;
00317 }
00318 
00330 <span class="keyword">static</span>
00331     <span class="keywordtype">int</span>
00332 _asn_realloc_build_header_check(<span class="keyword">const</span> <span class="keywordtype">char</span> *str,
00333                                 u_char ** pkt,
00334                                 <span class="keyword">const</span> size_t * pkt_len, size_t typedlen)
00335 {
00336     <span class="keywordtype">char</span>            ebuf[128];
00337 
00338     <span class="keywordflow">if</span> (pkt == NULL || *pkt == NULL) {
00339         <span class="comment">/*</span>
00340 <span class="comment">         * Error message is set.  </span>
00341 <span class="comment">         */</span>
00342         <span class="keywordflow">return</span> 1;
00343     }
00344 
00345     <span class="keywordflow">if</span> (*pkt_len &lt; typedlen) {
00346         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
00347                 <span class="stringliteral">"%s: bad header, length too short: %lu &lt; %lu"</span>, str,
00348                 (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)*pkt_len, (<span class=
"keywordtype">unsigned</span> <span class="keywordtype">long</span>)typedlen);
00349         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
00350         ERROR_MSG(ebuf);
00351         <span class="keywordflow">return</span> 1;
00352     }
00353     <span class="keywordflow">return</span> 0;
00354 }
00355 
00365 <span class="keywordtype">int</span>
00366 asn_check_packet(u_char * pkt, size_t len)
00367 {
00368     u_long          asn_length;
00369 
00370     <span class="keywordflow">if</span> (len &lt; 2)
00371         <span class="keywordflow">return</span> 0;               <span class="comment">/* always too short */</span>
00372 
00373     <span class="keywordflow">if</span> (*pkt != (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR))
00374         <span class="keywordflow">return</span> -1;              <span class="comment">/* wrong type */</span>
00375 
00376     <span class="keywordflow">if</span> (*(pkt + 1) &amp; 0x80) {
00377         <span class="comment">/*</span>
00378 <span class="comment">         * long length </span>
00379 <span class="comment">         */</span>
00380         <span class="keywordflow">if</span> ((int) len &lt; (int) (*(pkt + 1) &amp; ~0x80) + 2)
00381             <span class="keywordflow">return</span> 0;           <span class=
"comment">/* still to short, incomplete length */</span>
00382         asn_parse_length(pkt + 1, &amp;asn_length);
00383         <span class="keywordflow">return</span> (asn_length + 2 + (*(pkt + 1) &amp; ~0x80));
00384     } <span class="keywordflow">else</span> {
00385         <span class="comment">/*</span>
00386 <span class="comment">         * short length </span>
00387 <span class="comment">         */</span>
00388         <span class="keywordflow">return</span> (*(pkt + 1) + 2);
00389     }
00390 }
00391 
00392 <span class="keyword">static</span>
00393     <span class="keywordtype">int</span>
00394 _asn_bitstring_check(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *str, size_t asn_length, u_char datum)
00395 {
00396     <span class="keywordtype">char</span>            ebuf[128];
00397 
00398     <span class="keywordflow">if</span> (asn_length &lt; 1) {
00399         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
00400                 <span class="stringliteral">"%s: length %d too small"</span>, str, (<span class=
"keywordtype">int</span>) asn_length);
00401         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
00402         ERROR_MSG(ebuf);
00403         <span class="keywordflow">return</span> 1;
00404     }
00405     <span class="comment">/*</span>
00406 <span class="comment">     * if (datum &gt; 7){</span>
00407 <span class="comment">     * sprintf(ebuf,"%s: datum %d &gt;7: too large", str, (int)(datum));</span>
00408 <span class="comment">     * ERROR_MSG(ebuf);</span>
00409 <span class="comment">     * return 1;</span>
00410 <span class="comment">     * }</span>
00411 <span class="comment">     */</span>
00412     <span class="keywordflow">return</span> 0;
00413 }
00414 
00436 u_char         *
00437 asn_parse_int(u_char * data,
00438               size_t * datalength,
00439               u_char * type, <span class="keywordtype">long</span> *intp, size_t intsize)
00440 {
00441     <span class="comment">/*</span>
00442 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
00443 <span class="comment">     */</span>
00444     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse int"</span>;
00445     <span class="keyword">register</span> u_char *bufp = data;
00446     u_long          asn_length;
00447     <span class="keyword">register</span> <span class="keywordtype">long</span>   value = 0;
00448 
00449     <span class="keywordflow">if</span> (intsize != <span class="keyword">sizeof</span>(long)) {
00450         _asn_size_err(errpre, intsize, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
00451         <span class="keywordflow">return</span> NULL;
00452     }
00453     *type = *bufp++;
00454     bufp = asn_parse_length(bufp, &amp;asn_length);
00455     <span class="keywordflow">if</span> (_asn_parse_length_check
00456         (errpre, bufp, data, asn_length, *datalength))
00457         <span class="keywordflow">return</span> NULL;
00458 
00459     <span class="keywordflow">if</span> ((size_t) asn_length &gt; intsize) {
00460         _asn_length_err(errpre, (size_t) asn_length, intsize);
00461         <span class="keywordflow">return</span> NULL;
00462     }
00463 
00464     *datalength -= (int) asn_length + (bufp - data);
00465     <span class="keywordflow">if</span> (*bufp &amp; 0x80)
00466         value = -1;             <span class="comment">/* integer is negative */</span>
00467 
00468     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data + asn_length);
00469 
00470     <span class="keywordflow">while</span> (asn_length--)
00471         value = (value &lt;&lt; 8) | *bufp++;
00472 
00473     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  Integer:\t%ld (0x%.2X)\n"</span>, value, value));
00474 
00475     *intp = value;
00476     <span class="keywordflow">return</span> bufp;
00477 }
00478 
00479 
00501 u_char         *
00502 asn_parse_unsigned_int(u_char * data,
00503                        size_t * datalength,
00504                        u_char * type, u_long * intp, size_t intsize)
00505 {
00506     <span class="comment">/*</span>
00507 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
00508 <span class="comment">     */</span>
00509     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse uint"</span>;
00510     <span class="keyword">register</span> u_char *bufp = data;
00511     u_long          asn_length;
00512     <span class="keyword">register</span> u_long value = 0;
00513 
00514     <span class="keywordflow">if</span> (intsize != <span class="keyword">sizeof</span>(long)) {
00515         _asn_size_err(errpre, intsize, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
00516         <span class="keywordflow">return</span> NULL;
00517     }
00518     *type = *bufp++;
00519     bufp = asn_parse_length(bufp, &amp;asn_length);
00520     <span class="keywordflow">if</span> (_asn_parse_length_check
00521         (errpre, bufp, data, asn_length, *datalength))
00522         <span class="keywordflow">return</span> NULL;
00523 
00524     <span class="keywordflow">if</span> (((int) asn_length &gt; (intsize + 1)) ||
00525         (((int) asn_length == intsize + 1) &amp;&amp; *bufp != 0x00)) {
00526         _asn_length_err(errpre, (size_t) asn_length, intsize);
00527         <span class="keywordflow">return</span> NULL;
00528     }
00529     *datalength -= (int) asn_length + (bufp - data);
00530     <span class="keywordflow">if</span> (*bufp &amp; 0x80)
00531         value = ~value;         <span class="comment">/* integer is negative */</span>
00532 
00533     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data + asn_length);
00534 
00535     <span class="keywordflow">while</span> (asn_length--)
00536         value = (value &lt;&lt; 8) | *bufp++;
00537 
00538     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  UInteger:\t%ld (0x%.2X)\n"</span>, value, value));
00539 
00540     *intp = value;
00541     <span class="keywordflow">return</span> bufp;
00542 }
00543 
00544 
00568 u_char         *
00569 asn_build_int(u_char * data,
00570            size_t * datalength, u_char type, <span class="keyword">const</span> <span class=
"keywordtype">long</span> *intp, size_t intsize)
00571 {
00572     <span class="comment">/*</span>
00573 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
00574 <span class="comment">     */</span>
00575     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build int"</span>;
00576     <span class="keyword">register</span> <span class="keywordtype">long</span>   integer;
00577     <span class="keyword">register</span> u_long mask;
00578 <span class="preprocessor">#ifndef SNMP_NO_DEBUGGING</span>
00579     u_char         *initdatap = data;
00580 <span class="preprocessor">#endif</span>
00581 
00582     <span class="keywordflow">if</span> (intsize != <span class="keyword">sizeof</span>(long)) {
00583         _asn_size_err(errpre, intsize, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
00584         <span class="keywordflow">return</span> NULL;
00585     }
00586     integer = *intp;
00587     <span class="comment">/*</span>
00588 <span class="comment">     * Truncate "unnecessary" bytes off of the most significant end of this</span>
00589 <span class="comment">     * 2's complement integer.  There should be no sequence of 9</span>
00590 <span class="comment">     * consecutive 1's or 0's at the most significant end of the</span>
00591 <span class="comment">     * integer.</span>
00592 <span class="comment">     */</span>
00593     mask = ((u_long) 0x1FF) &lt;&lt; ((8 * (<span class="keyword">sizeof</span>(long) - 1)) - 1);
00594     <span class="comment">/*</span>
00595 <span class="comment">     * mask is 0xFF800000 on a big-endian machine </span>
00596 <span class="comment">     */</span>
00597     <span class="keywordflow">while</span> ((((integer &amp; mask) == 0) || ((integer &amp; mask) == mask))
00598            &amp;&amp; intsize &gt; 1) {
00599         intsize--;
00600         integer &lt;&lt;= 8;
00601     }
00602     data = asn_build_header(data, datalength, type, intsize);
00603     <span class="keywordflow">if</span> (_asn_build_header_check(errpre, data, *datalength, intsize))
00604         <span class="keywordflow">return</span> NULL;
00605 
00606     *datalength -= intsize;
00607     mask = ((u_long) 0xFF) &lt;&lt; (8 * (<span class="keyword">sizeof</span>(long) - 1));
00608     <span class="comment">/*</span>
00609 <span class="comment">     * mask is 0xFF000000 on a big-endian machine </span>
00610 <span class="comment">     */</span>
00611     <span class="keywordflow">while</span> (intsize--) {
00612         *data++ = (u_char) ((integer &amp; mask) &gt;&gt; (8 * (<span class="keyword">sizeof</span>(long) - 1)));
00613         integer &lt;&lt;= 8;
00614     }
00615     DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, initdatap, data - initdatap);
00616     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  Integer:\t%ld (0x%.2X)\n"</span>, *intp, *intp));
00617     <span class="keywordflow">return</span> data;
00618 }
00619 
00620 
00621 
00645 u_char         *
00646 asn_build_unsigned_int(u_char * data,
00647                        size_t * datalength,
00648                        u_char type, <span class="keyword">const</span> u_long * intp, size_t intsize)
00649 {
00650     <span class="comment">/*</span>
00651 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
00652 <span class="comment">     */</span>
00653     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build uint"</span>;
00654     <span class="keyword">register</span> u_long integer;
00655     <span class="keyword">register</span> u_long mask;
00656     <span class="keywordtype">int</span>             add_null_byte = 0;
00657 <span class="preprocessor">#ifndef SNMP_NO_DEBUGGING</span>
00658     u_char         *initdatap = data;
00659 <span class="preprocessor">#endif</span>
00660 
00661     <span class="keywordflow">if</span> (intsize != <span class="keyword">sizeof</span>(long)) {
00662         _asn_size_err(errpre, intsize, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
00663         <span class="keywordflow">return</span> NULL;
00664     }
00665     integer = *intp;
00666     mask = ((u_long) 0xFF) &lt;&lt; (8 * (<span class="keyword">sizeof</span>(long) - 1));
00667     <span class="comment">/*</span>
00668 <span class="comment">     * mask is 0xFF000000 on a big-endian machine </span>
00669 <span class="comment">     */</span>
00670     <span class="keywordflow">if</span> ((u_char) ((integer &amp; mask) &gt;&gt; (8 * (<span class=
"keyword">sizeof</span>(long) - 1))) &amp; 0x80) {
00671         <span class="comment">/*</span>
00672 <span class="comment">         * if MSB is set </span>
00673 <span class="comment">         */</span>
00674         add_null_byte = 1;
00675         intsize++;
00676     } <span class="keywordflow">else</span> {
00677         <span class="comment">/*</span>
00678 <span class=
"comment">         * Truncate "unnecessary" bytes off of the most significant end of this 2's complement integer.</span>
00679 <span class=
"comment">         * There should be no sequence of 9 consecutive 1's or 0's at the most significant end of the</span>
00680 <span class="comment">         * integer.</span>
00681 <span class="comment">         */</span>
00682         mask = ((u_long) 0x1FF) &lt;&lt; ((8 * (<span class="keyword">sizeof</span>(long) - 1)) - 1);
00683         <span class="comment">/*</span>
00684 <span class="comment">         * mask is 0xFF800000 on a big-endian machine </span>
00685 <span class="comment">         */</span>
00686         <span class="keywordflow">while</span> ((((integer &amp; mask) == 0) || ((integer &amp; mask) == mask))
00687                &amp;&amp; intsize &gt; 1) {
00688             intsize--;
00689             integer &lt;&lt;= 8;
00690         }
00691     }
00692     data = asn_build_header(data, datalength, type, intsize);
00693     <span class="keywordflow">if</span> (_asn_build_header_check(errpre, data, *datalength, intsize))
00694         <span class="keywordflow">return</span> NULL;
00695 
00696     *datalength -= intsize;
00697     <span class="keywordflow">if</span> (add_null_byte == 1) {
00698         *data++ = <span class="charliteral">'\0'</span>;
00699         intsize--;
00700     }
00701     mask = ((u_long) 0xFF) &lt;&lt; (8 * (<span class="keyword">sizeof</span>(long) - 1));
00702     <span class="comment">/*</span>
00703 <span class="comment">     * mask is 0xFF000000 on a big-endian machine </span>
00704 <span class="comment">     */</span>
00705     <span class="keywordflow">while</span> (intsize--) {
00706         *data++ = (u_char) ((integer &amp; mask) &gt;&gt; (8 * (<span class="keyword">sizeof</span>(long) - 1)));
00707         integer &lt;&lt;= 8;
00708     }
00709     DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, initdatap, data - initdatap);
00710     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  UInteger:\t%ld (0x%.2X)\n"</span>, *intp, *intp));
00711     <span class="keywordflow">return</span> data;
00712 }
00713 
00714 
00743 u_char         *
00744 asn_parse_string(u_char * data,
00745                  size_t * datalength,
00746                  u_char * type, u_char * string, size_t * strlength)
00747 {
00748     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse string"</span>;
00749     u_char         *bufp = data;
00750     u_long          asn_length;
00751 
00752     *type = *bufp++;
00753     bufp = asn_parse_length(bufp, &amp;asn_length);
00754     <span class="keywordflow">if</span> (_asn_parse_length_check
00755         (errpre, bufp, data, asn_length, *datalength)) {
00756         <span class="keywordflow">return</span> NULL;
00757     }
00758 
00759     <span class="keywordflow">if</span> ((int) asn_length &gt; *strlength) {
00760         _asn_length_err(errpre, (size_t) asn_length, *strlength);
00761         <span class="keywordflow">return</span> NULL;
00762     }
00763 
00764     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data + asn_length);
00765 
00766     memmove(string, bufp, asn_length);
00767     <span class="keywordflow">if</span> (*strlength &gt; (int) asn_length)
00768         string[asn_length] = 0;
00769     *strlength = (int) asn_length;
00770     *datalength -= (int) asn_length + (bufp - data);
00771 
00772     DEBUGIF(<span class="stringliteral">"dumpv_recv"</span>) {
00773         u_char         *buf = (u_char *) malloc(1 + asn_length);
00774         size_t          l = (buf != NULL) ? (1 + asn_length) : 0, ol = 0;
00775 
00776         <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga27">sprint_realloc_asciistring</a>
00777             (&amp;buf, &amp;l, &amp;ol, 1, string, asn_length)) {
00778             DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  String:\t%s\n"</span>, buf));
00779         } <span class="keywordflow">else</span> {
00780             <span class="keywordflow">if</span> (buf == NULL) {
00781                 DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  String:\t[TRUNCATED]\n"</span>));
00782             } <span class="keywordflow">else</span> {
00783                 DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  String:\t%s [TRUNCATED]\n"</span>,
00784                           buf));
00785             }
00786         }
00787         <span class="keywordflow">if</span> (buf != NULL) {
00788             free(buf);
00789         }
00790     }
00791 
00792     <span class="keywordflow">return</span> bufp + asn_length;
00793 }
00794 
00795 
00818 u_char         *
00819 asn_build_string(u_char * data,
00820                  size_t * datalength,
00821                  u_char type, <span class="keyword">const</span> u_char * string, size_t strlength)
00822 {
00823     <span class="comment">/*</span>
00824 <span class="comment">     * ASN.1 octet string ::= primstring | cmpdstring</span>
00825 <span class="comment">     * primstring ::= 0x04 asnlength byte {byte}*</span>
00826 <span class="comment">     * cmpdstring ::= 0x24 asnlength string {string}*</span>
00827 <span class="comment">     * This code will never send a compound string.</span>
00828 <span class="comment">     */</span>
00829 <span class="preprocessor">#ifndef SNMP_NO_DEBUGGING</span>
00830     u_char         *initdatap = data;
00831 <span class="preprocessor">#endif</span>
00832     data = asn_build_header(data, datalength, type, strlength);
00833     <span class="keywordflow">if</span> (_asn_build_header_check
00834         (<span class="stringliteral">"build string"</span>, data, *datalength, strlength))
00835         <span class="keywordflow">return</span> NULL;
00836 
00837     <span class="keywordflow">if</span> (strlength) {
00838         <span class="keywordflow">if</span> (string == NULL) {
00839             memset(data, 0, strlength);
00840         } <span class="keywordflow">else</span> {
00841             memmove(data, string, strlength);
00842         }
00843     }
00844     *datalength -= strlength;
00845     DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, initdatap, data - initdatap + strlength);
00846     DEBUGIF(<span class="stringliteral">"dumpv_send"</span>) {
00847         u_char         *buf = (u_char *) malloc(1 + strlength);
00848         size_t          l = (buf != NULL) ? (1 + strlength) : 0, ol = 0;
00849 
00850         <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga27">sprint_realloc_asciistring</a>
00851             (&amp;buf, &amp;l, &amp;ol, 1, string, strlength)) {
00852             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  String:\t%s\n"</span>, buf));
00853         } <span class="keywordflow">else</span> {
00854             <span class="keywordflow">if</span> (buf == NULL) {
00855                 DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  String:\t[TRUNCATED]\n"</span>));
00856             } <span class="keywordflow">else</span> {
00857                 DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  String:\t%s [TRUNCATED]\n"</span>,
00858                           buf));
00859             }
00860         }
00861         <span class="keywordflow">if</span> (buf != NULL) {
00862             free(buf);
00863         }
00864     }
00865     <span class="keywordflow">return</span> data + strlength;
00866 }
00867 
00868 
00869 
00889 u_char         *
00890 asn_parse_header(u_char * data, size_t * datalength, u_char * type)
00891 {
00892     <span class="keyword">register</span> u_char *bufp;
00893     u_long          asn_length;
00894 
00895     <span class="keywordflow">if</span> (!data || !datalength || !type) {
00896         ERROR_MSG(<span class="stringliteral">"parse header: NULL pointer"</span>);
00897         <span class="keywordflow">return</span> NULL;
00898     }
00899     bufp = data;
00900     <span class="comment">/*</span>
00901 <span class="comment">     * this only works on data types &lt; 30, i.e. no extension octets </span>
00902 <span class="comment">     */</span>
00903     <span class="keywordflow">if</span> (IS_EXTENSION_ID(*bufp)) {
00904         ERROR_MSG(<span class="stringliteral">"can't process ID &gt;= 30"</span>);
00905         <span class="keywordflow">return</span> NULL;
00906     }
00907     *type = *bufp;
00908     bufp = asn_parse_length(bufp + 1, &amp;asn_length);
00909 
00910     <span class="keywordflow">if</span> (_asn_parse_length_check
00911         (<span class="stringliteral">"parse header"</span>, bufp, data, asn_length, *datalength))
00912         <span class="keywordflow">return</span> NULL;
00913 
00914 <span class="preprocessor">#ifdef DUMP_PRINT_HEADERS</span>
00915     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, (bufp - data));
00916     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  Header: 0x%.2X, len = %d (0x%X)\n"</span>, *data,
00917               asn_length, asn_length));
00918 <span class="preprocessor">#else</span>
00919     <span class="comment">/*</span>
00920 <span class="comment">     * DEBUGMSGHEXTLI(("recv",data,(bufp-data)));</span>
00921 <span class="comment">     * DEBUGMSG(("dumpH_recv","\n"));</span>
00922 <span class="comment">     */</span>
00923 <span class="preprocessor">#endif</span>
00924 
00925 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
00926 
00927     <span class="keywordflow">if</span> ((*type == ASN_OPAQUE) &amp;&amp; (*bufp == ASN_OPAQUE_TAG1)) {
00928 
00929         <span class="comment">/*</span>
00930 <span class="comment">         * check if 64-but counter </span>
00931 <span class="comment">         */</span>
00932         <span class="keywordflow">switch</span> (*(bufp + 1)) {
00933         <span class="keywordflow">case</span> ASN_OPAQUE_COUNTER64:
00934         <span class="keywordflow">case</span> ASN_OPAQUE_U64:
00935         <span class="keywordflow">case</span> ASN_OPAQUE_FLOAT:
00936         <span class="keywordflow">case</span> ASN_OPAQUE_DOUBLE:
00937         <span class="keywordflow">case</span> ASN_OPAQUE_I64:
00938             *type = *(bufp + 1);
00939             <span class="keywordflow">break</span>;
00940 
00941         <span class="keywordflow">default</span>:
00942             <span class="comment">/*</span>
00943 <span class="comment">             * just an Opaque </span>
00944 <span class="comment">             */</span>
00945             *datalength = (int) asn_length;
00946             <span class="keywordflow">return</span> bufp;
00947         }
00948         <span class="comment">/*</span>
00949 <span class="comment">         * value is encoded as special format </span>
00950 <span class="comment">         */</span>
00951         bufp = asn_parse_length(bufp + 2, &amp;asn_length);
00952         <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse opaque header"</span>, bufp, data,
00953                                     asn_length, *datalength))
00954             <span class="keywordflow">return</span> NULL;
00955     }
00956 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
00957 
00958     *datalength = (int) asn_length;
00959 
00960     <span class="keywordflow">return</span> bufp;
00961 }
00962 
00977 u_char         *
00978 asn_parse_sequence(u_char * data, size_t * datalength, u_char * type, u_char expected_type,     <span class=
"comment">/* must be this type */</span>
00979                    <span class="keyword">const</span> <span class="keywordtype">char</span> *estr)
00980 {                               <span class="comment">/* error message prefix */</span>
00981     data = asn_parse_header(data, datalength, type);
00982     <span class="keywordflow">if</span> (data &amp;&amp; (*type != expected_type)) {
00983         <span class="keywordtype">char</span>            ebuf[128];
00984         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
00985                  <span class="stringliteral">"%s header type %02X: s/b %02X"</span>, estr,
00986                 (u_char) * type, (u_char) expected_type);
00987         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
00988         ERROR_MSG(ebuf);
00989         <span class="keywordflow">return</span> NULL;
00990     }
00991     <span class="keywordflow">return</span> data;
00992 }
00993 
00994 
00995 
01018 u_char         *
01019 asn_build_header(u_char * data,
01020                  size_t * datalength, u_char type, size_t length)
01021 {
01022     <span class="keywordtype">char</span>            ebuf[128];
01023 
01024     <span class="keywordflow">if</span> (*datalength &lt; 1) {
01025         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
01026                 <span class="stringliteral">"bad header length &lt; 1 :%lu, %lu"</span>,
01027                 (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)*datalength, (<span class=
"keywordtype">unsigned</span> <span class="keywordtype">long</span>)length);
01028         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
01029         ERROR_MSG(ebuf);
01030         <span class="keywordflow">return</span> NULL;
01031     }
01032     *data++ = type;
01033     (*datalength)--;
01034     <span class="keywordflow">return</span> asn_build_length(data, datalength, length);
01035 }
01036 
01060 u_char         *
01061 asn_build_sequence(u_char * data,
01062                    size_t * datalength, u_char type, size_t length)
01063 {
01064     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build seq"</span>;
01065     <span class="keywordtype">char</span>            ebuf[128];
01066 
01067     <span class="keywordflow">if</span> (*datalength &lt; 4) {
01068         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
01069                 <span class="stringliteral">"%s: length %d &lt; 4: PUNT"</span>, errpre,
01070                 (<span class="keywordtype">int</span>) *datalength);
01071         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
01072         ERROR_MSG(ebuf);
01073         <span class="keywordflow">return</span> NULL;
01074     }
01075     *datalength -= 4;
01076     *data++ = type;
01077     *data++ = (u_char) (0x02 | ASN_LONG_LEN);
01078     *data++ = (u_char) ((length &gt;&gt; 8) &amp; 0xFF);
01079     *data++ = (u_char) (length &amp; 0xFF);
01080     <span class="keywordflow">return</span> data;
01081 }
01082 
01100 u_char         *
01101 asn_parse_length(u_char * data, u_long * length)
01102 {
01103     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse length"</span>;
01104     <span class="keywordtype">char</span>            ebuf[128];
01105     <span class="keyword">register</span> u_char lengthbyte;
01106 
01107     <span class="keywordflow">if</span> (!data || !length) {
01108         ERROR_MSG(<span class="stringliteral">"parse length: NULL pointer"</span>);
01109         <span class="keywordflow">return</span> NULL;
01110     }
01111     lengthbyte = *data;
01112 
01113     <span class="keywordflow">if</span> (lengthbyte &amp; ASN_LONG_LEN) {
01114         lengthbyte &amp;= ~ASN_LONG_LEN;    <span class="comment">/* turn MSb off */</span>
01115         <span class="keywordflow">if</span> (lengthbyte == 0) {
01116             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
01117                      <span class="stringliteral">"%s: indefinite length not supported"</span>, errpre);
01118             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
01119             ERROR_MSG(ebuf);
01120             <span class="keywordflow">return</span> NULL;
01121         }
01122         <span class="keywordflow">if</span> (lengthbyte &gt; <span class="keyword">sizeof</span>(long)) {
01123             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
01124                     <span class="stringliteral">"%s: data length %d &gt; %lu not supported"</span>, errpre,
01125                     lengthbyte, (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
01126             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
01127             ERROR_MSG(ebuf);
01128             <span class="keywordflow">return</span> NULL;
01129         }
01130         data++;
01131         *length = 0;            <span class="comment">/* protect against short lengths */</span>
01132         <span class="keywordflow">while</span> (lengthbyte--) {
01133             *length &lt;&lt;= 8;
01134             *length |= *data++;
01135         }
01136         <span class="keywordflow">if</span> ((long) *length &lt; 0) {
01137             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
01138                      <span class="stringliteral">"%s: negative data length %ld\n"</span>, errpre,
01139                      (<span class="keywordtype">long</span>) *length);
01140             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
01141             ERROR_MSG(ebuf);
01142             <span class="keywordflow">return</span> NULL;
01143         }
01144         <span class="keywordflow">return</span> data;
01145     } <span class="keywordflow">else</span> {                    <span class="comment">/* short asnlength */</span>
01146         *length = (long) lengthbyte;
01147         <span class="keywordflow">return</span> data + 1;
01148     }
01149 }
01150 
01171 u_char         *
01172 asn_build_length(u_char * data, size_t * datalength, size_t length)
01173 {
01174     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build length"</span>;
01175     <span class="keywordtype">char</span>            ebuf[128];
01176 
01177     u_char         *start_data = data;
01178 
01179     <span class="comment">/*</span>
01180 <span class="comment">     * no indefinite lengths sent </span>
01181 <span class="comment">     */</span>
01182     <span class="keywordflow">if</span> (length &lt; 0x80) {
01183         <span class="keywordflow">if</span> (*datalength &lt; 1) {
01184             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
01185                     <span class="stringliteral">"%s: bad length &lt; 1 :%lu, %lu"</span>, errpre,
01186                     (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)*datalength, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)length);
01187             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
01188             ERROR_MSG(ebuf);
01189             <span class="keywordflow">return</span> NULL;
01190         }
01191         *data++ = (u_char) length;
01192     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (length &lt;= 0xFF) {
01193         <span class="keywordflow">if</span> (*datalength &lt; 2) {
01194             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
01195                     <span class="stringliteral">"%s: bad length &lt; 2 :%lu, %lu"</span>, errpre,
01196                     (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)*datalength, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)length);
01197             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
01198             ERROR_MSG(ebuf);
01199             <span class="keywordflow">return</span> NULL;
01200         }
01201         *data++ = (u_char) (0x01 | ASN_LONG_LEN);
01202         *data++ = (u_char) length;
01203     } <span class="keywordflow">else</span> {                    <span class=
"comment">/* 0xFF &lt; length &lt;= 0xFFFF */</span>
01204         <span class="keywordflow">if</span> (*datalength &lt; 3) {
01205             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
01206                     <span class="stringliteral">"%s: bad length &lt; 3 :%lu, %lu"</span>, errpre,
01207                     (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)*datalength, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)length);
01208             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
01209             ERROR_MSG(ebuf);
01210             <span class="keywordflow">return</span> NULL;
01211         }
01212         *data++ = (u_char) (0x02 | ASN_LONG_LEN);
01213         *data++ = (u_char) ((length &gt;&gt; 8) &amp; 0xFF);
01214         *data++ = (u_char) (length &amp; 0xFF);
01215     }
01216     *datalength -= (data - start_data);
01217     <span class="keywordflow">return</span> data;
01218 
01219 }
01220 
01246 u_char         *
01247 asn_parse_objid(u_char * data,
01248                 size_t * datalength,
01249                 u_char * type, oid * objid, size_t * objidlength)
01250 {
01251     <span class="comment">/*</span>
01252 <span class="comment">     * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*</span>
01253 <span class="comment">     * subidentifier ::= {leadingbyte}* lastbyte</span>
01254 <span class="comment">     * leadingbyte ::= 1 7bitvalue</span>
01255 <span class="comment">     * lastbyte ::= 0 7bitvalue</span>
01256 <span class="comment">     */</span>
01257     <span class="keyword">register</span> u_char *bufp = data;
01258     <span class="keyword">register</span> oid   *oidp = objid + 1;
01259     <span class="keyword">register</span> u_long subidentifier;
01260     <span class="keyword">register</span> <span class="keywordtype">long</span>   length;
01261     u_long          asn_length;
01262 
01263     *type = *bufp++;
01264     bufp = asn_parse_length(bufp, &amp;asn_length);
01265     <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse objid"</span>, bufp, data,
01266                                 asn_length, *datalength))
01267         <span class="keywordflow">return</span> NULL;
01268 
01269     *datalength -= (int) asn_length + (bufp - data);
01270 
01271     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data + asn_length);
01272 
01273     <span class="comment">/*</span>
01274 <span class="comment">     * Handle invalid object identifier encodings of the form 06 00 robustly </span>
01275 <span class="comment">     */</span>
01276     <span class="keywordflow">if</span> (asn_length == 0)
01277         objid[0] = objid[1] = 0;
01278 
01279     length = asn_length;
01280     (*objidlength)--;           <span class="comment">/* account for expansion of first byte */</span>
01281 
01282     <span class="keywordflow">while</span> (length &gt; 0 &amp;&amp; (*objidlength)-- &gt; 0) {
01283         subidentifier = 0;
01284         <span class="keywordflow">do</span> {                    <span class=
"comment">/* shift and add in low order 7 bits */</span>
01285             subidentifier =
01286                 (subidentifier &lt;&lt; 7) + (*(u_char *) bufp &amp; ~ASN_BIT8);
01287             length--;
01288         } <span class="keywordflow">while</span> (*(u_char *) bufp++ &amp; ASN_BIT8);        <span class=
"comment">/* last byte has high bit clear */</span>
01289         <span class="comment">/*</span>
01290 <span class="comment">         * ?? note, this test will never be true, since the largest value</span>
01291 <span class="comment">         * of subidentifier is the value of MAX_SUBID! </span>
01292 <span class="comment">         *</span>
01293 <span class="comment">         * Yes: PC-LINT says the same thing</span>
01294 <span class="comment">         */</span>
01295         <span class="keywordflow">if</span> (subidentifier &gt; (u_long) MAX_SUBID) {
01296             ERROR_MSG(<span class="stringliteral">"subidentifier too large"</span>);
01297             <span class="keywordflow">return</span> NULL;
01298         }
01299         *oidp++ = (oid) subidentifier;
01300     }
01301 
01302     <span class="comment">/*</span>
01303 <span class="comment">     * The first two subidentifiers are encoded into the first component</span>
01304 <span class="comment">     * with the value (X * 40) + Y, where:</span>
01305 <span class="comment">     *  X is the value of the first subidentifier.</span>
01306 <span class="comment">     *  Y is the value of the second subidentifier.</span>
01307 <span class="comment">     */</span>
01308     subidentifier = (u_long) objid[1];
01309     <span class="keywordflow">if</span> (subidentifier == 0x2B) {
01310         objid[0] = 1;
01311         objid[1] = 3;
01312     } <span class="keywordflow">else</span> {
01313         <span class="keywordflow">if</span> (subidentifier &lt; 40) {
01314             objid[0] = 0;
01315             objid[1] = subidentifier;
01316         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (subidentifier &lt; 80) {
01317             objid[0] = 1;
01318             objid[1] = subidentifier - 40;
01319         } <span class="keywordflow">else</span> {
01320             objid[0] = 2;
01321             objid[1] = subidentifier - 80;
01322         }
01323     }
01324 
01325     *objidlength = (int) (oidp - objid);
01326 
01327     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class="stringliteral">"  ObjID: "</span>));
01328     DEBUGMSGOID((<span class="stringliteral">"dumpv_recv"</span>, objid, *objidlength));
01329     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class="stringliteral">"\n"</span>));
01330     <span class="keywordflow">return</span> bufp;
01331 }
01332 
01356 u_char         *
01357 asn_build_objid(u_char * data,
01358                 size_t * datalength,
01359                 u_char type, oid * objid, size_t objidlength)
01360 {
01361     <span class="comment">/*</span>
01362 <span class="comment">     * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*</span>
01363 <span class="comment">     * subidentifier ::= {leadingbyte}* lastbyte</span>
01364 <span class="comment">     * leadingbyte ::= 1 7bitvalue</span>
01365 <span class="comment">     * lastbyte ::= 0 7bitvalue</span>
01366 <span class="comment">     */</span>
01367     size_t          asnlength;
01368     <span class="keyword">register</span> oid   *op = objid;
01369     u_char          objid_size[MAX_OID_LEN];
01370     <span class="keyword">register</span> u_long objid_val;
01371     u_long          first_objid_val;
01372     <span class="keyword">register</span> <span class="keywordtype">int</span>    i;
01373 <span class="preprocessor">#ifndef SNMP_NO_DEBUGGING</span>
01374     u_char         *initdatap = data;
01375 <span class="preprocessor">#endif</span>
01376 
01377     <span class="comment">/*</span>
01378 <span class="comment">     * check if there are at least 2 sub-identifiers </span>
01379 <span class="comment">     */</span>
01380     <span class="keywordflow">if</span> (objidlength == 0) {
01381         <span class="comment">/*</span>
01382 <span class="comment">         * there are not, so make OID have two with value of zero </span>
01383 <span class="comment">         */</span>
01384         objid_val = 0;
01385         objidlength = 2;
01386     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (objid[0] &gt; 2) {
01387         ERROR_MSG(<span class="stringliteral">"build objid: bad first subidentifier"</span>);
01388         <span class="keywordflow">return</span> NULL;
01389     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (objidlength == 1) {
01390         <span class="comment">/*</span>
01391 <span class="comment">         * encode the first value </span>
01392 <span class="comment">         */</span>
01393         objid_val = (op[0] * 40);
01394         objidlength = 2;
01395         op++;
01396     } <span class="keywordflow">else</span> {
01397         <span class="comment">/*</span>
01398 <span class="comment">         * combine the first two values </span>
01399 <span class="comment">         */</span>
01400         <span class="keywordflow">if</span> ((op[1] &gt; 40) &amp;&amp;
01401             (op[0] &lt; 2)) {
01402             ERROR_MSG(<span class="stringliteral">"build objid: bad second subidentifier"</span>);
01403             <span class="keywordflow">return</span> NULL;
01404         }
01405         objid_val = (op[0] * 40) + op[1];
01406         op += 2;
01407     }
01408     first_objid_val = objid_val;
01409 
01410     <span class="comment">/*</span>
01411 <span class="comment">     * ditch illegal calls now </span>
01412 <span class="comment">     */</span>
01413     <span class="keywordflow">if</span> (objidlength &gt; MAX_OID_LEN)
01414         <span class="keywordflow">return</span> NULL;
01415 
01416     <span class="comment">/*</span>
01417 <span class="comment">     * calculate the number of bytes needed to store the encoded value </span>
01418 <span class="comment">     */</span>
01419     <span class="keywordflow">for</span> (i = 1, asnlength = 0;;) {
01420         <span class="keywordflow">if</span> (objid_val &lt; (unsigned) 0x80) {
01421             objid_size[i] = 1;
01422             asnlength += 1;
01423         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (objid_val &lt; (unsigned) 0x4000) {
01424             objid_size[i] = 2;
01425             asnlength += 2;
01426         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (objid_val &lt; (unsigned) 0x200000) {
01427             objid_size[i] = 3;
01428             asnlength += 3;
01429         } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (objid_val &lt; (unsigned) 0x10000000) {
01430             objid_size[i] = 4;
01431             asnlength += 4;
01432         } <span class="keywordflow">else</span> {
01433             objid_size[i] = 5;
01434             asnlength += 5;
01435         }
01436         i++;
01437         <span class="keywordflow">if</span> (i &gt;= (int) objidlength)
01438             <span class="keywordflow">break</span>;
01439         objid_val = *op++;      <span class="comment">/* XXX - doesn't handle 2.X (X &gt; 40) */</span>
01440     }
01441 
01442     <span class="comment">/*</span>
01443 <span class="comment">     * store the ASN.1 tag and length </span>
01444 <span class="comment">     */</span>
01445     data = asn_build_header(data, datalength, type, asnlength);
01446     <span class="keywordflow">if</span> (_asn_build_header_check
01447         (<span class="stringliteral">"build objid"</span>, data, *datalength, asnlength))
01448         <span class="keywordflow">return</span> NULL;
01449 
01450     <span class="comment">/*</span>
01451 <span class="comment">     * store the encoded OID value </span>
01452 <span class="comment">     */</span>
01453     <span class="keywordflow">for</span> (i = 1, objid_val = first_objid_val, op = objid + 2;
01454          i &lt; (int) objidlength; i++) {
01455         <span class="keywordflow">if</span> (i != 1)
01456             objid_val = *op++;
01457         <span class="keywordflow">switch</span> (objid_size[i]) {
01458         <span class="keywordflow">case</span> 1:
01459             *data++ = (u_char) objid_val;
01460             <span class="keywordflow">break</span>;
01461 
01462         <span class="keywordflow">case</span> 2:
01463             *data++ = (u_char) ((objid_val &gt;&gt; 7) | 0x80);
01464             *data++ = (u_char) (objid_val &amp; 0x07f);
01465             <span class="keywordflow">break</span>;
01466 
01467         <span class="keywordflow">case</span> 3:
01468             *data++ = (u_char) ((objid_val &gt;&gt; 14) | 0x80);
01469             *data++ = (u_char) ((objid_val &gt;&gt; 7 &amp; 0x7f) | 0x80);
01470             *data++ = (u_char) (objid_val &amp; 0x07f);
01471             <span class="keywordflow">break</span>;
01472 
01473         <span class="keywordflow">case</span> 4:
01474             *data++ = (u_char) ((objid_val &gt;&gt; 21) | 0x80);
01475             *data++ = (u_char) ((objid_val &gt;&gt; 14 &amp; 0x7f) | 0x80);
01476             *data++ = (u_char) ((objid_val &gt;&gt; 7 &amp; 0x7f) | 0x80);
01477             *data++ = (u_char) (objid_val &amp; 0x07f);
01478             <span class="keywordflow">break</span>;
01479 
01480         <span class="keywordflow">case</span> 5:
01481             *data++ = (u_char) ((objid_val &gt;&gt; 28) | 0x80);
01482             *data++ = (u_char) ((objid_val &gt;&gt; 21 &amp; 0x7f) | 0x80);
01483             *data++ = (u_char) ((objid_val &gt;&gt; 14 &amp; 0x7f) | 0x80);
01484             *data++ = (u_char) ((objid_val &gt;&gt; 7 &amp; 0x7f) | 0x80);
01485             *data++ = (u_char) (objid_val &amp; 0x07f);
01486             <span class="keywordflow">break</span>;
01487         }
01488     }
01489 
01490     <span class="comment">/*</span>
01491 <span class="comment">     * return the length and data ptr </span>
01492 <span class="comment">     */</span>
01493     *datalength -= asnlength;
01494     DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, initdatap, data - initdatap);
01495     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class="stringliteral">"  ObjID: "</span>));
01496     DEBUGMSGOID((<span class="stringliteral">"dumpv_send"</span>, objid, objidlength));
01497     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class="stringliteral">"\n"</span>));
01498     <span class="keywordflow">return</span> data;
01499 }
01500 
01520 u_char         *
01521 asn_parse_null(u_char * data, size_t * datalength, u_char * type)
01522 {
01523     <span class="comment">/*</span>
01524 <span class="comment">     * ASN.1 null ::= 0x05 0x00</span>
01525 <span class="comment">     */</span>
01526     <span class="keyword">register</span> u_char *bufp = data;
01527     u_long          asn_length;
01528 
01529     *type = *bufp++;
01530     bufp = asn_parse_length(bufp, &amp;asn_length);
01531     <span class="keywordflow">if</span> (bufp == NULL) {
01532         ERROR_MSG(<span class="stringliteral">"parse null: bad length"</span>);
01533         <span class="keywordflow">return</span> NULL;
01534     }
01535     <span class="keywordflow">if</span> (asn_length != 0) {
01536         ERROR_MSG(<span class="stringliteral">"parse null: malformed ASN.1 null"</span>);
01537         <span class="keywordflow">return</span> NULL;
01538     }
01539 
01540     *datalength -= (bufp - data);
01541 
01542     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data);
01543     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class="stringliteral">"  NULL\n"</span>));
01544 
01545     <span class="keywordflow">return</span> bufp + asn_length;
01546 }
01547 
01548 
01569 u_char         *
01570 asn_build_null(u_char * data, size_t * datalength, u_char type)
01571 {
01572     <span class="comment">/*</span>
01573 <span class="comment">     * ASN.1 null ::= 0x05 0x00</span>
01574 <span class="comment">     */</span>
01575 <span class="preprocessor">#ifndef SNMP_NO_DEBUGGING</span>
01576     u_char         *initdatap = data;
01577 <span class="preprocessor">#endif</span>
01578     data = asn_build_header(data, datalength, type, 0);
01579     DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, initdatap, data - initdatap);
01580     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class="stringliteral">"  NULL\n"</span>));
01581     <span class="keywordflow">return</span> data;
01582 }
01583 
01607 u_char         *
01608 asn_parse_bitstring(u_char * data,
01609                     size_t * datalength,
01610                     u_char * type, u_char * string, size_t * strlength)
01611 {
01612     <span class="comment">/*</span>
01613 <span class="comment">     * bitstring ::= 0x03 asnlength unused {byte}*</span>
01614 <span class="comment">     */</span>
01615     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse bitstring"</span>;
01616     <span class="keyword">register</span> u_char *bufp = data;
01617     u_long          asn_length;
01618 
01619     *type = *bufp++;
01620     bufp = asn_parse_length(bufp, &amp;asn_length);
01621     <span class="keywordflow">if</span> (_asn_parse_length_check(errpre, bufp, data,
01622                                 asn_length, *datalength))
01623         <span class="keywordflow">return</span> NULL;
01624 
01625     <span class="keywordflow">if</span> ((size_t) asn_length &gt; *strlength) {
01626         _asn_length_err(errpre, (size_t) asn_length, *strlength);
01627         <span class="keywordflow">return</span> NULL;
01628     }
01629     <span class="keywordflow">if</span> (_asn_bitstring_check(errpre, asn_length, *bufp))
01630         <span class="keywordflow">return</span> NULL;
01631 
01632     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data);
01633     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class="stringliteral">"  Bitstring: "</span>));
01634     DEBUGMSGHEX((<span class="stringliteral">"dumpv_recv"</span>, data, asn_length));
01635     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class="stringliteral">"\n"</span>));
01636 
01637     memmove(string, bufp, asn_length);
01638     *strlength = (int) asn_length;
01639     *datalength -= (int) asn_length + (bufp - data);
01640     <span class="keywordflow">return</span> bufp + asn_length;
01641 }
01642 
01643 
01666 u_char         *
01667 asn_build_bitstring(u_char * data,
01668                     size_t * datalength,
01669                     u_char type, <span class="keyword">const</span> u_char * string, size_t strlength)
01670 {
01671     <span class="comment">/*</span>
01672 <span class="comment">     * ASN.1 bit string ::= 0x03 asnlength unused {byte}*</span>
01673 <span class="comment">     */</span>
01674     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build bitstring"</span>;
01675     <span class="keywordflow">if</span> (_asn_bitstring_check
01676         (errpre, strlength, (u_char)((string) ? *string :  0)))
01677         <span class="keywordflow">return</span> NULL;
01678 
01679     data = asn_build_header(data, datalength, type, strlength);
01680     <span class="keywordflow">if</span> (_asn_build_header_check(errpre, data, *datalength, strlength))
01681         <span class="keywordflow">return</span> NULL;
01682 
01683     <span class="keywordflow">if</span> (strlength &gt; 0 &amp;&amp; string)
01684         memmove(data, string, strlength);
01685     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strlength &gt; 0 &amp;&amp; !string) {
01686         ERROR_MSG(<span class="stringliteral">"no string passed into asn_build_bitstring\n"</span>);
01687         <span class="keywordflow">return</span> NULL;
01688     }
01689 
01690     *datalength -= strlength;
01691     DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, data, strlength);
01692     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class="stringliteral">"  Bitstring: "</span>));
01693     DEBUGMSGHEX((<span class="stringliteral">"dumpv_send"</span>, data, strlength));
01694     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class="stringliteral">"\n"</span>));
01695     <span class="keywordflow">return</span> data + strlength;
01696 }
01697 
01720 u_char         *
01721 asn_parse_unsigned_int64(u_char * data,
01722                          size_t * datalength,
01723                          u_char * type,
01724                          <span class="keyword">struct</span> counter64 * cp, size_t countersize)
01725 {
01726     <span class="comment">/*</span>
01727 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
01728 <span class="comment">     */</span>
01729     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse uint64"</span>;
01730     <span class="keyword">const</span> <span class="keywordtype">int</span>       uint64sizelimit = (4 * 2) + 1;
01731     <span class="keyword">register</span> u_char *bufp = data;
01732     u_long          asn_length;
01733     <span class="keyword">register</span> u_long low = 0, high = 0;
01734 
01735     <span class="keywordflow">if</span> (countersize != <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>counter64)) {
01736         _asn_size_err(errpre, countersize, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> counter64));
01737         <span class="keywordflow">return</span> NULL;
01738     }
01739     *type = *bufp++;
01740     bufp = asn_parse_length(bufp, &amp;asn_length);
01741     <span class="keywordflow">if</span> (_asn_parse_length_check
01742         (errpre, bufp, data, asn_length, *datalength))
01743         <span class="keywordflow">return</span> NULL;
01744 
01745     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data);
01746 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
01747     <span class="comment">/*</span>
01748 <span class="comment">     * 64 bit counters as opaque </span>
01749 <span class="comment">     */</span>
01750     <span class="keywordflow">if</span> ((*type == ASN_OPAQUE) &amp;&amp;
01751         (asn_length &lt;= ASN_OPAQUE_COUNTER64_MX_BER_LEN) &amp;&amp;
01752         (*bufp == ASN_OPAQUE_TAG1) &amp;&amp;
01753         ((*(bufp + 1) == ASN_OPAQUE_COUNTER64) ||
01754          (*(bufp + 1) == ASN_OPAQUE_U64))) {
01755         <span class="comment">/*</span>
01756 <span class="comment">         * change type to Counter64 or U64 </span>
01757 <span class="comment">         */</span>
01758         *type = *(bufp + 1);
01759         <span class="comment">/*</span>
01760 <span class="comment">         * value is encoded as special format </span>
01761 <span class="comment">         */</span>
01762         bufp = asn_parse_length(bufp + 2, &amp;asn_length);
01763         <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse opaque uint64"</span>, bufp, data,
01764                                     asn_length, *datalength))
01765             <span class="keywordflow">return</span> NULL;
01766     }
01767 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
01768     <span class="keywordflow">if</span> (((int) asn_length &gt; uint64sizelimit) ||
01769         (((int) asn_length == uint64sizelimit) &amp;&amp; *bufp != 0x00)) {
01770         _asn_length_err(errpre, (size_t) asn_length, uint64sizelimit);
01771         <span class="keywordflow">return</span> NULL;
01772     }
01773     *datalength -= (int) asn_length + (bufp - data);
01774     <span class="keywordflow">if</span> (*bufp &amp; 0x80) {
01775         low = ~low;             <span class="comment">/* integer is negative */</span>
01776         high = ~high;
01777     }
01778 
01779     <span class="keywordflow">while</span> (asn_length--) {
01780         high = (high &lt;&lt; 8) | ((low &amp; 0xFF000000) &gt;&gt; 24);
01781         low = (low &lt;&lt; 8) | *bufp++;
01782     }
01783 
01784     cp-&gt;low = low;
01785     cp-&gt;high = high;
01786 
01787     DEBUGIF(<span class="stringliteral">"dumpv_recv"</span>) {
01788         <span class="keywordtype">char</span>            i64buf[I64CHARSZ + 1];
01789         printU64(i64buf, cp);
01790         DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"Counter64: %s"</span>, i64buf));
01791     }
01792 
01793     <span class="keywordflow">return</span> bufp;
01794 }
01795 
01796 
01818 u_char         *
01819 asn_build_unsigned_int64(u_char * data,
01820                          size_t * datalength,
01821                          u_char type,
01822                          <span class="keyword">const</span> <span class=
"keyword">struct</span> counter64 * cp, size_t countersize)
01823 {
01824     <span class="comment">/*</span>
01825 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
01826 <span class="comment">     */</span>
01827 
01828     <span class="keyword">register</span> u_long low, high;
01829     <span class="keyword">register</span> u_long mask, mask2;
01830     <span class="keywordtype">int</span>             add_null_byte = 0;
01831     size_t          intsize;
01832 <span class="preprocessor">#ifndef SNMP_NO_DEBUGGING</span>
01833     u_char         *initdatap = data;
01834 <span class="preprocessor">#endif</span>
01835 
01836     <span class="keywordflow">if</span> (countersize != <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>counter64)) {
01837         _asn_size_err(<span class="stringliteral">"build uint64"</span>, countersize,
01838                       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> counter64));
01839         <span class="keywordflow">return</span> NULL;
01840     }
01841     intsize = 8;
01842     low = cp-&gt;low;
01843     high = cp-&gt;high;
01844     mask = ((u_long) 0xFF) &lt;&lt; (8 * (<span class="keyword">sizeof</span>(long) - 1));
01845     <span class="comment">/*</span>
01846 <span class="comment">     * mask is 0xFF000000 on a big-endian machine </span>
01847 <span class="comment">     */</span>
01848     <span class="keywordflow">if</span> ((u_char) ((high &amp; mask) &gt;&gt; (8 * (<span class=
"keyword">sizeof</span>(long) - 1))) &amp; 0x80) {
01849         <span class="comment">/*</span>
01850 <span class="comment">         * if MSB is set </span>
01851 <span class="comment">         */</span>
01852         add_null_byte = 1;
01853         intsize++;
01854     } <span class="keywordflow">else</span> {
01855         <span class="comment">/*</span>
01856 <span class="comment">         * Truncate "unnecessary" bytes off of the most significant end of this 2's</span>
01857 <span class="comment">         * complement integer.</span>
01858 <span class="comment">         * There should be no sequence of 9 consecutive 1's or 0's at the most</span>
01859 <span class="comment">         * significant end of the integer.</span>
01860 <span class="comment">         */</span>
01861         mask2 = ((u_long) 0x1FF) &lt;&lt; ((8 * (<span class="keyword">sizeof</span>(long) - 1)) - 1);
01862         <span class="comment">/*</span>
01863 <span class="comment">         * mask2 is 0xFF800000 on a big-endian machine </span>
01864 <span class="comment">         */</span>
01865         <span class="keywordflow">while</span> ((((high &amp; mask2) == 0) || ((high &amp; mask2) == mask2))
01866                &amp;&amp; intsize &gt; 1) {
01867             intsize--;
01868             high = (high &lt;&lt; 8)
01869                 | ((low &amp; mask) &gt;&gt; (8 * (<span class="keyword">sizeof</span>(long) - 1)));
01870             low &lt;&lt;= 8;
01871         }
01872     }
01873 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
01874     <span class="comment">/*</span>
01875 <span class="comment">     * encode a Counter64 as an opaque (it also works in SNMPv1) </span>
01876 <span class="comment">     */</span>
01877     <span class="comment">/*</span>
01878 <span class="comment">     * turn into Opaque holding special tagged value </span>
01879 <span class="comment">     */</span>
01880     <span class="keywordflow">if</span> (type == ASN_OPAQUE_COUNTER64) {
01881         <span class="comment">/*</span>
01882 <span class="comment">         * put the tag and length for the Opaque wrapper </span>
01883 <span class="comment">         */</span>
01884         data = asn_build_header(data, datalength, ASN_OPAQUE, intsize + 3);
01885         <span class="keywordflow">if</span> (_asn_build_header_check
01886             (<span class="stringliteral">"build counter u64"</span>, data, *datalength, intsize + 3))
01887             <span class="keywordflow">return</span> NULL;
01888 
01889         <span class="comment">/*</span>
01890 <span class="comment">         * put the special tag and length </span>
01891 <span class="comment">         */</span>
01892         *data++ = ASN_OPAQUE_TAG1;
01893         *data++ = ASN_OPAQUE_COUNTER64;
01894         *data++ = (u_char) intsize;
01895         *datalength = *datalength - 3;
01896     } <span class="keywordflow">else</span>
01897         <span class="comment">/*</span>
01898 <span class="comment">         * Encode the Unsigned int64 in an opaque </span>
01899 <span class="comment">         */</span>
01900         <span class="comment">/*</span>
01901 <span class="comment">         * turn into Opaque holding special tagged value </span>
01902 <span class="comment">         */</span>
01903     <span class="keywordflow">if</span> (type == ASN_OPAQUE_U64) {
01904         <span class="comment">/*</span>
01905 <span class="comment">         * put the tag and length for the Opaque wrapper </span>
01906 <span class="comment">         */</span>
01907         data = asn_build_header(data, datalength, ASN_OPAQUE, intsize + 3);
01908         <span class="keywordflow">if</span> (_asn_build_header_check
01909             (<span class="stringliteral">"build opaque u64"</span>, data, *datalength, intsize + 3))
01910             <span class="keywordflow">return</span> NULL;
01911 
01912         <span class="comment">/*</span>
01913 <span class="comment">         * put the special tag and length </span>
01914 <span class="comment">         */</span>
01915         *data++ = ASN_OPAQUE_TAG1;
01916         *data++ = ASN_OPAQUE_U64;
01917         *data++ = (u_char) intsize;
01918         *datalength = *datalength - 3;
01919     } <span class="keywordflow">else</span> {
01920 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
01921         data = asn_build_header(data, datalength, type, intsize);
01922         <span class="keywordflow">if</span> (_asn_build_header_check
01923             (<span class="stringliteral">"build uint64"</span>, data, *datalength, intsize))
01924             <span class="keywordflow">return</span> NULL;
01925 
01926 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
01927     }
01928 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
01929     *datalength -= intsize;
01930     <span class="keywordflow">if</span> (add_null_byte == 1) {
01931         *data++ = <span class="charliteral">'\0'</span>;
01932         intsize--;
01933     }
01934     <span class="keywordflow">while</span> (intsize--) {
01935         *data++ = (u_char) ((high &amp; mask) &gt;&gt; (8 * (<span class="keyword">sizeof</span>(long) - 1)));
01936         high = (high &lt;&lt; 8)
01937             | ((low &amp; mask) &gt;&gt; (8 * (<span class="keyword">sizeof</span>(long) - 1)));
01938         low &lt;&lt;= 8;
01939 
01940     }
01941     DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, initdatap, data - initdatap);
01942     DEBUGIF(<span class="stringliteral">"dumpv_send"</span>) {
01943         <span class="keywordtype">char</span>            i64buf[I64CHARSZ + 1];
01944         printU64(i64buf, cp);
01945         DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, i64buf));
01946     }
01947     <span class="keywordflow">return</span> data;
01948 }
01949 
01950 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
01951 
01952 
01976 u_char         *
01977 asn_parse_signed_int64(u_char * data,
01978                        size_t * datalength,
01979                        u_char * type,
01980                        <span class="keyword">struct</span> counter64 * cp, size_t countersize)
01981 {
01982     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse int64"</span>;
01983     <span class="keyword">const</span> <span class="keywordtype">int</span>       int64sizelimit = (4 * 2) + 1;
01984     <span class="keywordtype">char</span>            ebuf[128];
01985     <span class="keyword">register</span> u_char *bufp = data;
01986     u_long          asn_length;
01987     <span class="keyword">register</span> u_int  low = 0, high = 0;
01988 
01989     <span class="keywordflow">if</span> (countersize != <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>counter64)) {
01990         _asn_size_err(errpre, countersize, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> counter64));
01991         <span class="keywordflow">return</span> NULL;
01992     }
01993     *type = *bufp++;
01994     bufp = asn_parse_length(bufp, &amp;asn_length);
01995     <span class="keywordflow">if</span> (_asn_parse_length_check
01996         (errpre, bufp, data, asn_length, *datalength))
01997         <span class="keywordflow">return</span> NULL;
01998 
01999     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data);
02000     <span class="keywordflow">if</span> ((*type == ASN_OPAQUE) &amp;&amp;
02001         (asn_length &lt;= ASN_OPAQUE_COUNTER64_MX_BER_LEN) &amp;&amp;
02002         (*bufp == ASN_OPAQUE_TAG1) &amp;&amp; (*(bufp + 1) == ASN_OPAQUE_I64)) {
02003         <span class="comment">/*</span>
02004 <span class="comment">         * change type to Int64 </span>
02005 <span class="comment">         */</span>
02006         *type = *(bufp + 1);
02007         <span class="comment">/*</span>
02008 <span class="comment">         * value is encoded as special format </span>
02009 <span class="comment">         */</span>
02010         bufp = asn_parse_length(bufp + 2, &amp;asn_length);
02011         <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse opaque int64"</span>, bufp, data,
02012                                     asn_length, *datalength))
02013             <span class="keywordflow">return</span> NULL;
02014     }
02015     <span class="comment">/*</span>
02016 <span class="comment">     * this should always have been true until snmp gets int64 PDU types </span>
02017 <span class="comment">     */</span>
02018     <span class="keywordflow">else</span> {
02019         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
02020                 <span class="stringliteral">"%s: wrong type: %d, len %d, buf bytes (%02X,%02X)"</span>,
02021                 errpre, *type, (<span class="keywordtype">int</span>) asn_length, *bufp, *(bufp + 1));
02022         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
02023         ERROR_MSG(ebuf);
02024         <span class="keywordflow">return</span> NULL;
02025     }
02026     <span class="keywordflow">if</span> (((int) asn_length &gt; int64sizelimit) ||
02027         (((int) asn_length == int64sizelimit) &amp;&amp; *bufp != 0x00)) {
02028         _asn_length_err(errpre, (size_t) asn_length, int64sizelimit);
02029         <span class="keywordflow">return</span> NULL;
02030     }
02031     *datalength -= (int) asn_length + (bufp - data);
02032     <span class="keywordflow">if</span> (*bufp &amp; 0x80) {
02033         low = ~low;             <span class="comment">/* integer is negative */</span>
02034         high = ~high;
02035     }
02036 
02037     <span class="keywordflow">while</span> (asn_length--) {
02038         high = (high &lt;&lt; 8) | ((low &amp; 0xFF000000) &gt;&gt; 24);
02039         low = (low &lt;&lt; 8) | *bufp++;
02040     }
02041 
02042     cp-&gt;low = low;
02043     cp-&gt;high = high;
02044 
02045     DEBUGIF(<span class="stringliteral">"dumpv_recv"</span>) {
02046         <span class="keywordtype">char</span>            i64buf[I64CHARSZ + 1];
02047         printI64(i64buf, cp);
02048         DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"Integer64: %s"</span>, i64buf));
02049     }
02050 
02051     <span class="keywordflow">return</span> bufp;
02052 }
02053 
02054 
02055 
02077 u_char         *
02078 asn_build_signed_int64(u_char * data,
02079                        size_t * datalength,
02080                        u_char type,
02081                        <span class="keyword">const</span> <span class=
"keyword">struct</span> counter64 * cp, size_t countersize)
02082 {
02083     <span class="comment">/*</span>
02084 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
02085 <span class="comment">     */</span>
02086 
02087     <span class="keyword">struct </span>counter64 c64;
02088     <span class="keyword">register</span> u_int  mask, mask2;
02089     u_long          low, high;
02090     size_t          intsize;
02091 <span class="preprocessor">#ifndef SNMP_NO_DEBUGGING</span>
02092     u_char         *initdatap = data;
02093 <span class="preprocessor">#endif</span>
02094 
02095     <span class="keywordflow">if</span> (countersize != <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>counter64)) {
02096         _asn_size_err(<span class="stringliteral">"build int64"</span>, countersize,
02097                       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> counter64));
02098         <span class="keywordflow">return</span> NULL;
02099     }
02100     intsize = 8;
02101     memcpy(&amp;c64, cp, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> counter64)); <span class=
"comment">/* we're may modify it */</span>
02102     low = c64.low;
02103     high = c64.high;
02104 
02105     <span class="comment">/*</span>
02106 <span class="comment">     * Truncate "unnecessary" bytes off of the most significant end of this</span>
02107 <span class="comment">     * 2's complement integer.  There should be no sequence of 9</span>
02108 <span class="comment">     * consecutive 1's or 0's at the most significant end of the</span>
02109 <span class="comment">     * integer.</span>
02110 <span class="comment">     */</span>
02111     mask = ((u_int) 0xFF) &lt;&lt; (8 * (<span class="keyword">sizeof</span>(u_int) - 1));
02112     mask2 = ((u_int) 0x1FF) &lt;&lt; ((8 * (<span class="keyword">sizeof</span>(u_int) - 1)) - 1);
02113     <span class="comment">/*</span>
02114 <span class="comment">     * mask is 0xFF800000 on a big-endian machine </span>
02115 <span class="comment">     */</span>
02116     <span class="keywordflow">while</span> ((((high &amp; mask2) == 0) || ((high &amp; mask2) == mask2))
02117            &amp;&amp; intsize &gt; 1) {
02118         intsize--;
02119         high = (high &lt;&lt; 8)
02120             | ((low &amp; mask) &gt;&gt; (8 * (<span class="keyword">sizeof</span>(u_int) - 1)));
02121         low &lt;&lt;= 8;
02122     }
02123     <span class="comment">/*</span>
02124 <span class="comment">     * until a real int64 gets incorperated into SNMP, we are going to</span>
02125 <span class="comment">     * encode it as an opaque instead.  First, we build the opaque</span>
02126 <span class="comment">     * header and then the int64 tag type we use to mark it as an</span>
02127 <span class="comment">     * int64 in the opaque string. </span>
02128 <span class="comment">     */</span>
02129     data = asn_build_header(data, datalength, ASN_OPAQUE, intsize + 3);
02130     <span class="keywordflow">if</span> (_asn_build_header_check
02131         (<span class="stringliteral">"build int64"</span>, data, *datalength, intsize + 3))
02132         <span class="keywordflow">return</span> NULL;
02133 
02134     *data++ = ASN_OPAQUE_TAG1;
02135     *data++ = ASN_OPAQUE_I64;
02136     *data++ = (u_char) intsize;
02137     *datalength -= (3 + intsize);
02138 
02139     <span class="keywordflow">while</span> (intsize--) {
02140         *data++ = (u_char) ((high &amp; mask) &gt;&gt; (8 * (<span class="keyword">sizeof</span>(u_int) - 1)));
02141         high = (high &lt;&lt; 8)
02142             | ((low &amp; mask) &gt;&gt; (8 * (<span class="keyword">sizeof</span>(u_int) - 1)));
02143         low &lt;&lt;= 8;
02144     }
02145     DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, initdatap, data - initdatap);
02146     DEBUGIF(<span class="stringliteral">"dumpv_send"</span>) {
02147         <span class="keywordtype">char</span>            i64buf[I64CHARSZ + 1];
02148         printU64(i64buf, cp);
02149         DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, i64buf));
02150     }
02151     <span class="keywordflow">return</span> data;
02152 }
02153 
02154 
02176 u_char         *
02177 asn_parse_float(u_char * data,
02178                 size_t * datalength,
02179                 u_char * type, <span class="keywordtype">float</span> *floatp, size_t floatsize)
02180 {
02181     <span class="keyword">register</span> u_char *bufp = data;
02182     u_long          asn_length;
02183     <span class="keyword">union </span>{
02184         <span class="keywordtype">float</span>           floatVal;
02185         <span class="keywordtype">long</span>            longVal;
02186         u_char          c[<span class="keyword">sizeof</span>(float)];
02187     } fu;
02188 
02189     <span class="keywordflow">if</span> (floatsize != <span class="keyword">sizeof</span>(float)) {
02190         _asn_size_err(<span class="stringliteral">"parse float"</span>, floatsize, <span class=
"keyword">sizeof</span>(<span class="keywordtype">float</span>));
02191         <span class="keywordflow">return</span> NULL;
02192     }
02193     *type = *bufp++;
02194     bufp = asn_parse_length(bufp, &amp;asn_length);
02195     <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse float"</span>, bufp, data,
02196                                 asn_length, *datalength))
02197         <span class="keywordflow">return</span> NULL;
02198 
02199     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data + asn_length);
02200     <span class="comment">/*</span>
02201 <span class="comment">     * the float is encoded as an opaque </span>
02202 <span class="comment">     */</span>
02203     <span class="keywordflow">if</span> ((*type == ASN_OPAQUE) &amp;&amp;
02204         (asn_length == ASN_OPAQUE_FLOAT_BER_LEN) &amp;&amp;
02205         (*bufp == ASN_OPAQUE_TAG1) &amp;&amp; (*(bufp + 1) == ASN_OPAQUE_FLOAT)) {
02206 
02207         <span class="comment">/*</span>
02208 <span class="comment">         * value is encoded as special format </span>
02209 <span class="comment">         */</span>
02210         bufp = asn_parse_length(bufp + 2, &amp;asn_length);
02211         <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse opaque float"</span>, bufp, data,
02212                                     asn_length, *datalength))
02213             <span class="keywordflow">return</span> NULL;
02214 
02215         <span class="comment">/*</span>
02216 <span class="comment">         * change type to Float </span>
02217 <span class="comment">         */</span>
02218         *type = ASN_OPAQUE_FLOAT;
02219     }
02220 
02221     <span class="keywordflow">if</span> (asn_length != <span class="keyword">sizeof</span>(float)) {
02222         _asn_size_err(<span class="stringliteral">"parse seq float"</span>, asn_length, <span class=
"keyword">sizeof</span>(<span class="keywordtype">float</span>));
02223         <span class="keywordflow">return</span> NULL;
02224     }
02225 
02226     *datalength -= (int) asn_length + (bufp - data);
02227     memcpy(&amp;fu.c[0], bufp, asn_length);
02228 
02229     <span class="comment">/*</span>
02230 <span class="comment">     * correct for endian differences </span>
02231 <span class="comment">     */</span>
02232     fu.longVal = ntohl(fu.longVal);
02233 
02234     *floatp = fu.floatVal;
02235 
02236     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"Opaque float: %f\n"</span>, *floatp));
02237     <span class="keywordflow">return</span> bufp;
02238 }
02239 
02263 u_char         *
02264 asn_build_float(u_char * data,
02265                 size_t * datalength,
02266                 u_char type, <span class="keyword">const</span> <span class=
"keywordtype">float</span> *floatp, size_t floatsize)
02267 {
02268     <span class="keyword">union </span>{
02269         <span class="keywordtype">float</span>           floatVal;
02270         <span class="keywordtype">int</span>             intVal;
02271         u_char          c[<span class="keyword">sizeof</span>(float)];
02272     } fu;
02273 <span class="preprocessor">#ifndef SNMP_NO_DEBUGGING</span>
02274     u_char         *initdatap = data;
02275 <span class="preprocessor">#endif</span>
02276 
02277     <span class="keywordflow">if</span> (floatsize != <span class="keyword">sizeof</span>(float)) {
02278         _asn_size_err(<span class="stringliteral">"build float"</span>, floatsize, <span class=
"keyword">sizeof</span>(<span class="keywordtype">float</span>));
02279         <span class="keywordflow">return</span> NULL;
02280     }
02281     <span class="comment">/*</span>
02282 <span class="comment">     * encode the float as an opaque </span>
02283 <span class="comment">     */</span>
02284     <span class="comment">/*</span>
02285 <span class="comment">     * turn into Opaque holding special tagged value </span>
02286 <span class="comment">     */</span>
02287 
02288     <span class="comment">/*</span>
02289 <span class="comment">     * put the tag and length for the Opaque wrapper </span>
02290 <span class="comment">     */</span>
02291     data = asn_build_header(data, datalength, ASN_OPAQUE, floatsize + 3);
02292     <span class="keywordflow">if</span> (_asn_build_header_check
02293         (<span class="stringliteral">"build float"</span>, data, *datalength, (floatsize + 3)))
02294         <span class="keywordflow">return</span> NULL;
02295 
02296     <span class="comment">/*</span>
02297 <span class="comment">     * put the special tag and length </span>
02298 <span class="comment">     */</span>
02299     *data++ = ASN_OPAQUE_TAG1;
02300     *data++ = ASN_OPAQUE_FLOAT;
02301     *data++ = (u_char) floatsize;
02302     *datalength = *datalength - 3;
02303 
02304     fu.floatVal = *floatp;
02305     <span class="comment">/*</span>
02306 <span class="comment">     * correct for endian differences </span>
02307 <span class="comment">     */</span>
02308     fu.intVal = htonl(fu.intVal);
02309 
02310     *datalength -= floatsize;
02311     memcpy(data, &amp;fu.c[0], floatsize);
02312 
02313     DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, initdatap, data - initdatap);
02314     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"Opaque float: %f\n"</span>, *floatp));
02315     data += floatsize;
02316     <span class="keywordflow">return</span> data;
02317 }
02318 
02319 
02341 u_char         *
02342 asn_parse_double(u_char * data,
02343                  size_t * datalength,
02344                  u_char * type, <span class="keywordtype">double</span> *doublep, size_t doublesize)
02345 {
02346     <span class="keyword">register</span> u_char *bufp = data;
02347     u_long          asn_length;
02348     <span class="keywordtype">long</span>            tmp;
02349     <span class="keyword">union </span>{
02350         <span class="keywordtype">double</span>          doubleVal;
02351         <span class="keywordtype">int</span>             intVal[2];
02352         u_char          c[<span class="keyword">sizeof</span>(double)];
02353     } fu;
02354 
02355 
02356     <span class="keywordflow">if</span> (doublesize != <span class="keyword">sizeof</span>(double)) {
02357         _asn_size_err(<span class="stringliteral">"parse double"</span>, doublesize, <span class=
"keyword">sizeof</span>(<span class="keywordtype">double</span>));
02358         <span class="keywordflow">return</span> NULL;
02359     }
02360     *type = *bufp++;
02361     bufp = asn_parse_length(bufp, &amp;asn_length);
02362     <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse double"</span>, bufp, data,
02363                                 asn_length, *datalength))
02364         <span class="keywordflow">return</span> NULL;
02365 
02366     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data + asn_length);
02367     <span class="comment">/*</span>
02368 <span class="comment">     * the double is encoded as an opaque </span>
02369 <span class="comment">     */</span>
02370     <span class="keywordflow">if</span> ((*type == ASN_OPAQUE) &amp;&amp;
02371         (asn_length == ASN_OPAQUE_DOUBLE_BER_LEN) &amp;&amp;
02372         (*bufp == ASN_OPAQUE_TAG1) &amp;&amp; (*(bufp + 1) == ASN_OPAQUE_DOUBLE)) {
02373 
02374         <span class="comment">/*</span>
02375 <span class="comment">         * value is encoded as special format </span>
02376 <span class="comment">         */</span>
02377         bufp = asn_parse_length(bufp + 2, &amp;asn_length);
02378         <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse opaque double"</span>, bufp, data,
02379                                     asn_length, *datalength))
02380             <span class="keywordflow">return</span> NULL;
02381 
02382         <span class="comment">/*</span>
02383 <span class="comment">         * change type to Double </span>
02384 <span class="comment">         */</span>
02385         *type = ASN_OPAQUE_DOUBLE;
02386     }
02387 
02388     <span class="keywordflow">if</span> (asn_length != <span class="keyword">sizeof</span>(double)) {
02389         _asn_size_err(<span class="stringliteral">"parse seq double"</span>, asn_length, <span class=
"keyword">sizeof</span>(<span class="keywordtype">double</span>));
02390         <span class="keywordflow">return</span> NULL;
02391     }
02392     *datalength -= (int) asn_length + (bufp - data);
02393     memcpy(&amp;fu.c[0], bufp, asn_length);
02394 
02395     <span class="comment">/*</span>
02396 <span class="comment">     * correct for endian differences </span>
02397 <span class="comment">     */</span>
02398 
02399     tmp = ntohl(fu.intVal[0]);
02400     fu.intVal[0] = ntohl(fu.intVal[1]);
02401     fu.intVal[1] = tmp;
02402 
02403     *doublep = fu.doubleVal;
02404     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  Opaque Double:\t%f\n"</span>, *doublep));
02405 
02406     <span class="keywordflow">return</span> bufp;
02407 }
02408 
02409 
02432 u_char         *
02433 asn_build_double(u_char * data,
02434                  size_t * datalength,
02435                  u_char type, <span class="keyword">const</span> <span class=
"keywordtype">double</span> *doublep, size_t doublesize)
02436 {
02437     <span class="keywordtype">long</span>            tmp;
02438     <span class="keyword">union </span>{
02439         <span class="keywordtype">double</span>          doubleVal;
02440         <span class="keywordtype">int</span>             intVal[2];
02441         u_char          c[<span class="keyword">sizeof</span>(double)];
02442     } fu;
02443 <span class="preprocessor">#ifndef SNMP_NO_DEBUGGING</span>
02444     u_char         *initdatap = data;
02445 <span class="preprocessor">#endif</span>
02446 
02447     <span class="keywordflow">if</span> (doublesize != <span class="keyword">sizeof</span>(double)) {
02448         _asn_size_err(<span class="stringliteral">"build double"</span>, doublesize, <span class=
"keyword">sizeof</span>(<span class="keywordtype">double</span>));
02449         <span class="keywordflow">return</span> NULL;
02450     }
02451 
02452     <span class="comment">/*</span>
02453 <span class="comment">     * encode the double as an opaque </span>
02454 <span class="comment">     */</span>
02455     <span class="comment">/*</span>
02456 <span class="comment">     * turn into Opaque holding special tagged value </span>
02457 <span class="comment">     */</span>
02458 
02459     <span class="comment">/*</span>
02460 <span class="comment">     * put the tag and length for the Opaque wrapper </span>
02461 <span class="comment">     */</span>
02462     data = asn_build_header(data, datalength, ASN_OPAQUE, doublesize + 3);
02463     <span class="keywordflow">if</span> (_asn_build_header_check
02464         (<span class="stringliteral">"build double"</span>, data, *datalength, doublesize + 3))
02465         <span class="keywordflow">return</span> NULL;
02466 
02467     <span class="comment">/*</span>
02468 <span class="comment">     * put the special tag and length </span>
02469 <span class="comment">     */</span>
02470     *data++ = ASN_OPAQUE_TAG1;
02471     *data++ = ASN_OPAQUE_DOUBLE;
02472     *data++ = (u_char) doublesize;
02473     *datalength = *datalength - 3;
02474 
02475     fu.doubleVal = *doublep;
02476     <span class="comment">/*</span>
02477 <span class="comment">     * correct for endian differences </span>
02478 <span class="comment">     */</span>
02479     tmp = htonl(fu.intVal[0]);
02480     fu.intVal[0] = htonl(fu.intVal[1]);
02481     fu.intVal[1] = tmp;
02482     *datalength -= doublesize;
02483     memcpy(data, &amp;fu.c[0], doublesize);
02484 
02485     data += doublesize;
02486     DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, initdatap, data - initdatap);
02487     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  Opaque double: %f"</span>, *doublep));
02488     <span class="keywordflow">return</span> data;
02489 }
02490 
02491 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
02492 
02493 
02508 <span class="keywordtype">int</span>
02509 asn_realloc(u_char ** pkt, size_t * pkt_len)
02510 {
02511     <span class="keywordflow">if</span> (pkt != NULL &amp;&amp; pkt_len != NULL) {
02512         size_t          old_pkt_len = *pkt_len;
02513 
02514         DEBUGMSGTL((<span class="stringliteral">"asn_realloc"</span>, <span class=
"stringliteral">" old_pkt %08p, old_pkt_len %08x\n"</span>,
02515                     *pkt, old_pkt_len));
02516 
02517         <span class="keywordflow">if</span> (<a class="code" href="group__util.html#ga1">snmp_realloc</a>(pkt, pkt_len)) {
02518             DEBUGMSGTL((<span class="stringliteral">"asn_realloc"</span>, <span class=
"stringliteral">" new_pkt %08p, new_pkt_len %08x\n"</span>,
02519                         *pkt, *pkt_len));
02520             DEBUGMSGTL((<span class="stringliteral">"asn_realloc"</span>,
02521                         <span class="stringliteral">" memmove(%08p + %08x, %08p, %08x)\n"</span>, *pkt,
02522                         (*pkt_len - old_pkt_len), *pkt, old_pkt_len));
02523             memmove(*pkt + (*pkt_len - old_pkt_len), *pkt, old_pkt_len);
02524             memset(*pkt, (<span class="keywordtype">int</span>) <span class=
"charliteral">' '</span>, *pkt_len - old_pkt_len);
02525             <span class="keywordflow">return</span> 1;
02526         } <span class="keywordflow">else</span> {
02527             DEBUGMSG((<span class="stringliteral">"asn_realloc"</span>, <span class=
"stringliteral">" CANNOT REALLOC()\n"</span>));
02528         }
02529     }
02530     <span class="keywordflow">return</span> 0;
02531 }
02532 
02533 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
02534 
02549 <span class="keywordtype">int</span>
02550 asn_realloc_rbuild_length(u_char ** pkt, size_t * pkt_len,
02551                           size_t * offset, <span class="keywordtype">int</span> r, size_t length)
02552 {
02553     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build length"</span>;
02554     <span class="keywordtype">char</span>            ebuf[128];
02555     <span class="keywordtype">int</span>             tmp_int;
02556     size_t          start_offset = *offset;
02557 
02558     <span class="keywordflow">if</span> (length &lt;= 0x7f) {
02559         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
02560             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02561             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
02562                     <span class="stringliteral">"%s: bad length &lt; 1 :%ld, %lu"</span>, errpre,
02563                     (<span class="keywordtype">long</span>)(*pkt_len - *offset), (<span class=
"keywordtype">unsigned</span> <span class="keywordtype">long</span>)length);
02564             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
02565             ERROR_MSG(ebuf);
02566             <span class="keywordflow">return</span> 0;
02567         }
02568         *(*pkt + *pkt_len - (++*offset)) = length;
02569     } <span class="keywordflow">else</span> {
02570         <span class="keywordflow">while</span> (length &gt; 0xff) {
02571             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
02572                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02573                 snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
02574                         <span class="stringliteral">"%s: bad length &lt; 1 :%ld, %lu"</span>, errpre,
02575                         (<span class="keywordtype">long</span>)(*pkt_len - *offset), (<span class=
"keywordtype">unsigned</span> <span class="keywordtype">long</span>)length);
02576                 ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
02577                 ERROR_MSG(ebuf);
02578                 <span class="keywordflow">return</span> 0;
02579             }
02580             *(*pkt + *pkt_len - (++*offset)) = length &amp; 0xff;
02581             length &gt;&gt;= 8;
02582         }
02583 
02584         <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; 2) {
02585             <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02586                 snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
02587                         <span class="stringliteral">"%s: bad length &lt; 1 :%ld, %lu"</span>, errpre,
02588                         (<span class="keywordtype">long</span>)(*pkt_len - *offset), (<span class=
"keywordtype">unsigned</span> <span class="keywordtype">long</span>)length);
02589                 ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
02590                 ERROR_MSG(ebuf);
02591                 <span class="keywordflow">return</span> 0;
02592             }
02593         }
02594 
02595         *(*pkt + *pkt_len - (++*offset)) = length &amp; 0xff;
02596         tmp_int = *offset - start_offset;
02597         *(*pkt + *pkt_len - (++*offset)) = tmp_int | 0x80;
02598     }
02599 
02600     <span class="keywordflow">return</span> 1;
02601 }
02602 
02620 <span class="keywordtype">int</span>
02621 asn_realloc_rbuild_header(u_char ** pkt, size_t * pkt_len,
02622                           size_t * offset, <span class="keywordtype">int</span> r,
02623                           u_char type, size_t length)
02624 {
02625     <span class="keywordtype">char</span>            ebuf[128];
02626 
02627     <span class="keywordflow">if</span> (asn_realloc_rbuild_length(pkt, pkt_len, offset, r, length)) {
02628         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
02629             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02630             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
02631                     <span class="stringliteral">"bad header length &lt; 1 :%ld, %lu"</span>,
02632                     (<span class="keywordtype">long</span>)(*pkt_len - *offset), (<span class=
"keywordtype">unsigned</span> <span class="keywordtype">long</span>)length);
02633             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
02634             ERROR_MSG(ebuf);
02635             <span class="keywordflow">return</span> 0;
02636         }
02637         *(*pkt + *pkt_len - (++*offset)) = type;
02638         <span class="keywordflow">return</span> 1;
02639     }
02640     <span class="keywordflow">return</span> 0;
02641 }
02642 
02660 <span class="keywordtype">int</span>
02661 asn_realloc_rbuild_int(u_char ** pkt, size_t * pkt_len,
02662                        size_t * offset, <span class="keywordtype">int</span> r,
02663                        u_char type, <span class="keyword">const</span> <span class=
"keywordtype">long</span> *intp, size_t intsize)
02664 {
02665     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build int"</span>;
02666     <span class="keyword">register</span> <span class="keywordtype">long</span>   integer = *intp;
02667     <span class="keywordtype">int</span>             testvalue = (*intp &lt; 0) ? -1 : 0;
02668     size_t          start_offset = *offset;
02669 
02670     <span class="keywordflow">if</span> (intsize != <span class="keyword">sizeof</span>(long)) {
02671         _asn_size_err(errpre, intsize, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
02672         <span class="keywordflow">return</span> 0;
02673     }
02674 
02675     <span class=
"keywordflow">if</span> (((*pkt_len - *offset) &lt; 1) &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02676         <span class="keywordflow">return</span> 0;
02677     }
02678     *(*pkt + *pkt_len - (++*offset)) = (u_char) integer;
02679     integer &gt;&gt;= 8;
02680 
02681     <span class="keywordflow">while</span> (integer != testvalue) {
02682         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
02683             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02684             <span class="keywordflow">return</span> 0;
02685         }
02686         *(*pkt + *pkt_len - (++*offset)) = (u_char) integer;
02687         integer &gt;&gt;= 8;
02688     }
02689 
02690     <span class="keywordflow">if</span> ((*(*pkt + *pkt_len - *offset) &amp; 0x80) != (testvalue &amp; 0x80)) {
02691         <span class="comment">/*</span>
02692 <span class="comment">         * Make sure left most bit is representational of the rest of the bits</span>
02693 <span class="comment">         * that aren't encoded.  </span>
02694 <span class="comment">         */</span>
02695         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
02696             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02697             <span class="keywordflow">return</span> 0;
02698         }
02699         *(*pkt + *pkt_len - (++*offset)) = testvalue &amp; 0xff;
02700     }
02701 
02702     <span class="keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r, type,
02703                                   (*offset - start_offset))) {
02704         <span class="keywordflow">if</span> (_asn_realloc_build_header_check(errpre, pkt, pkt_len,
02705                                             (*offset - start_offset))) {
02706             <span class="keywordflow">return</span> 0;
02707         } <span class="keywordflow">else</span> {
02708             DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
02709                            (*offset - start_offset));
02710             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  Integer:\t%ld (0x%.2X)\n"</span>, *intp,
02711                       *intp));
02712             <span class="keywordflow">return</span> 1;
02713         }
02714     }
02715 
02716     <span class="keywordflow">return</span> 0;
02717 }
02718 
02737 <span class="keywordtype">int</span>
02738 asn_realloc_rbuild_string(u_char ** pkt, size_t * pkt_len,
02739                           size_t * offset, <span class="keywordtype">int</span> r,
02740                           u_char type,
02741                           <span class="keyword">const</span> u_char * string, size_t strlength)
02742 {
02743     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build string"</span>;
02744     size_t          start_offset = *offset;
02745 
02746     <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; strlength) {
02747         <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02748             <span class="keywordflow">return</span> 0;
02749         }
02750     }
02751 
02752     *offset += strlength;
02753     memcpy(*pkt + *pkt_len - *offset, string, strlength);
02754 
02755     <span class="keywordflow">if</span> (asn_realloc_rbuild_header
02756         (pkt, pkt_len, offset, r, type, strlength)) {
02757         <span class="keywordflow">if</span> (_asn_realloc_build_header_check
02758             (errpre, pkt, pkt_len, strlength)) {
02759             <span class="keywordflow">return</span> 0;
02760         } <span class="keywordflow">else</span> {
02761             DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
02762                            *offset - start_offset);
02763             DEBUGIF(<span class="stringliteral">"dumpv_send"</span>) {
02764                 <span class="keywordflow">if</span> (strlength == 0) {
02765                     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  String: [NULL]\n"</span>));
02766                 } <span class="keywordflow">else</span> {
02767                     u_char         *buf = (u_char *) malloc(2 * strlength);
02768                     size_t          l =
02769                         (buf != NULL) ? (2 * strlength) : 0, ol = 0;
02770 
02771                     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga27">sprint_realloc_asciistring</a>
02772                         (&amp;buf, &amp;l, &amp;ol, 1, string, strlength)) {
02773                         DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  String:\t%s\n"</span>, buf));
02774                     } <span class="keywordflow">else</span> {
02775                         <span class="keywordflow">if</span> (buf == NULL) {
02776                             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>,
02777                                       <span class="stringliteral">"  String:\t[TRUNCATED]\n"</span>));
02778                         } <span class="keywordflow">else</span> {
02779                             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>,
02780                                       <span class="stringliteral">"  String:\t%s [TRUNCATED]\n"</span>, buf));
02781                         }
02782                     }
02783                     <span class="keywordflow">if</span> (buf != NULL) {
02784                         free(buf);
02785                     }
02786                 }
02787             }
02788         }
02789         <span class="keywordflow">return</span> 1;
02790     }
02791 
02792     <span class="keywordflow">return</span> 0;
02793 }
02794 
02812 <span class="keywordtype">int</span>
02813 asn_realloc_rbuild_unsigned_int(u_char ** pkt, size_t * pkt_len,
02814                                 size_t * offset, <span class="keywordtype">int</span> r,
02815                             u_char type, <span class="keyword">const</span> u_long * intp, size_t intsize)
02816 {
02817     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build uint"</span>;
02818     <span class="keyword">register</span> u_long integer = *intp;
02819     size_t          start_offset = *offset;
02820 
02821     <span class="keywordflow">if</span> (intsize != <span class="keyword">sizeof</span>(<span class=
"keywordtype">unsigned</span> long)) {
02822         _asn_size_err(errpre, intsize, <span class="keyword">sizeof</span>(<span class=
"keywordtype">unsigned</span> <span class="keywordtype">long</span>));
02823         <span class="keywordflow">return</span> 0;
02824     }
02825 
02826     <span class=
"keywordflow">if</span> (((*pkt_len - *offset) &lt; 1) &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02827         <span class="keywordflow">return</span> 0;
02828     }
02829     *(*pkt + *pkt_len - (++*offset)) = (u_char) integer;
02830     integer &gt;&gt;= 8;
02831 
02832     <span class="keywordflow">while</span> (integer != 0) {
02833         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
02834             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02835             <span class="keywordflow">return</span> 0;
02836         }
02837         *(*pkt + *pkt_len - (++*offset)) = (u_char) integer;
02838         integer &gt;&gt;= 8;
02839     }
02840 
02841     <span class="keywordflow">if</span> ((*(*pkt + *pkt_len - *offset) &amp; 0x80) != (0 &amp; 0x80)) {
02842         <span class="comment">/*</span>
02843 <span class="comment">         * Make sure left most bit is representational of the rest of the bits</span>
02844 <span class="comment">         * that aren't encoded.  </span>
02845 <span class="comment">         */</span>
02846         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
02847             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02848             <span class="keywordflow">return</span> 0;
02849         }
02850         *(*pkt + *pkt_len - (++*offset)) = 0;
02851     }
02852 
02853     <span class="keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r, type,
02854                                   (*offset - start_offset))) {
02855         <span class="keywordflow">if</span> (_asn_realloc_build_header_check(errpre, pkt, pkt_len,
02856                                             (*offset - start_offset))) {
02857             <span class="keywordflow">return</span> 0;
02858         } <span class="keywordflow">else</span> {
02859             DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
02860                            (*offset - start_offset));
02861             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  UInteger:\t%lu (0x%.2X)\n"</span>, *intp,
02862                       *intp));
02863             <span class="keywordflow">return</span> 1;
02864         }
02865     }
02866 
02867     <span class="keywordflow">return</span> 0;
02868 }
02869 
02887 <span class="keywordtype">int</span>
02888 asn_realloc_rbuild_sequence(u_char ** pkt, size_t * pkt_len,
02889                             size_t * offset, <span class="keywordtype">int</span> r,
02890                             u_char type, size_t length)
02891 {
02892     <span class="keywordflow">return</span> asn_realloc_rbuild_header(pkt, pkt_len, offset, r, type,
02893                                      length);
02894 }
02895 
02914 <span class="keywordtype">int</span>
02915 asn_realloc_rbuild_objid(u_char ** pkt, size_t * pkt_len,
02916                          size_t * offset, <span class="keywordtype">int</span> r,
02917                          u_char type,
02918                          <span class="keyword">const</span> oid * objid, size_t objidlength)
02919 {
02920     <span class="comment">/*</span>
02921 <span class="comment">     * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*</span>
02922 <span class="comment">     * subidentifier ::= {leadingbyte}* lastbyte</span>
02923 <span class="comment">     * leadingbyte ::= 1 7bitvalue</span>
02924 <span class="comment">     * lastbyte ::= 0 7bitvalue</span>
02925 <span class="comment">     */</span>
02926     <span class="keyword">register</span> size_t i;
02927     <span class="keyword">register</span> oid    tmpint;
02928     size_t          start_offset = *offset;
02929     <span class="keyword">const</span> <span class="keywordtype">char</span>     *errpre = <span class=
"stringliteral">"build objid"</span>;
02930 
02931     <span class="comment">/*</span>
02932 <span class="comment">     * Check if there are at least 2 sub-identifiers.  </span>
02933 <span class="comment">     */</span>
02934     <span class="keywordflow">if</span> (objidlength == 0) {
02935         <span class="comment">/*</span>
02936 <span class="comment">         * There are not, so make OID have two with value of zero.  </span>
02937 <span class="comment">         */</span>
02938         <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; 2) {
02939             <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02940                 <span class="keywordflow">return</span> 0;
02941             }
02942         }
02943 
02944         *(*pkt + *pkt_len - (++*offset)) = 0;
02945         *(*pkt + *pkt_len - (++*offset)) = 0;
02946     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (objid[0] &gt; 2) {
02947         ERROR_MSG(<span class="stringliteral">"build objid: bad first subidentifier"</span>);
02948         <span class="keywordflow">return</span> 0;
02949     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (objidlength == 1) {
02950         <span class="comment">/*</span>
02951 <span class="comment">         * Encode the first value.  </span>
02952 <span class="comment">         */</span>
02953         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
02954             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02955             <span class="keywordflow">return</span> 0;
02956         }
02957         *(*pkt + *pkt_len - (++*offset)) = (u_char) objid[0];
02958     } <span class="keywordflow">else</span> {
02959         <span class="keywordflow">for</span> (i = objidlength; i &gt; 2; i--) {
02960             tmpint = objid[i - 1];
02961 
02962             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
02963                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02964                 <span class="keywordflow">return</span> 0;
02965             }
02966             *(*pkt + *pkt_len - (++*offset)) = (u_char) tmpint &amp; 0x7f;
02967             tmpint &gt;&gt;= 7;
02968 
02969             <span class="keywordflow">while</span> (tmpint &gt; 0) {
02970                 <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
02971                     &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02972                     <span class="keywordflow">return</span> 0;
02973                 }
02974                 *(*pkt + *pkt_len - (++*offset)) =
02975                     (u_char) ((tmpint &amp; 0x7f) | 0x80);
02976                 tmpint &gt;&gt;= 7;
02977             }
02978         }
02979 
02980         <span class="comment">/*</span>
02981 <span class="comment">         * Combine the first two values.  </span>
02982 <span class="comment">         */</span>
02983         <span class="keywordflow">if</span> ((objid[1] &gt; 40) &amp;&amp;
02984             (objid[0] &lt; 2)) {
02985             ERROR_MSG(<span class="stringliteral">"build objid: bad second subidentifier"</span>);
02986             <span class="keywordflow">return</span> 0;
02987         }
02988         tmpint = ((objid[0] * 40) + objid[1]);
02989         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
02990             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02991             <span class="keywordflow">return</span> 0;
02992         }
02993         *(*pkt + *pkt_len - (++*offset)) = (u_char) tmpint &amp; 0x7f;
02994         tmpint &gt;&gt;= 7;
02995 
02996         <span class="keywordflow">while</span> (tmpint &gt; 0) {
02997             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
02998                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
02999                 <span class="keywordflow">return</span> 0;
03000             }
03001             *(*pkt + *pkt_len - (++*offset)) =
03002                 (u_char) ((tmpint &amp; 0x7f) | 0x80);
03003             tmpint &gt;&gt;= 7;
03004         }
03005     }
03006 
03007     tmpint = *offset - start_offset;
03008     <span class="keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r, type,
03009                                   (*offset - start_offset))) {
03010         <span class="keywordflow">if</span> (_asn_realloc_build_header_check(errpre, pkt, pkt_len,
03011                                             (*offset - start_offset))) {
03012             <span class="keywordflow">return</span> 0;
03013         } <span class="keywordflow">else</span> {
03014             DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
03015                            (*offset - start_offset));
03016             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class="stringliteral">"  ObjID: "</span>));
03017             DEBUGMSGOID((<span class="stringliteral">"dumpv_send"</span>, objid, objidlength));
03018             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class="stringliteral">"\n"</span>));
03019             <span class="keywordflow">return</span> 1;
03020         }
03021     }
03022 
03023     <span class="keywordflow">return</span> 0;
03024 }
03025 
03042 <span class="keywordtype">int</span>
03043 asn_realloc_rbuild_null(u_char ** pkt, size_t * pkt_len,
03044                         size_t * offset, <span class="keywordtype">int</span> r, u_char type)
03045 {
03046     <span class="comment">/*</span>
03047 <span class="comment">     * ASN.1 null ::= 0x05 0x00</span>
03048 <span class="comment">     */</span>
03049     size_t          start_offset = *offset;
03050 
03051     <span class="keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r, type, 0)) {
03052         DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
03053                        (*offset - start_offset));
03054         DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class="stringliteral">"  NULL\n"</span>));
03055         <span class="keywordflow">return</span> 1;
03056     } <span class="keywordflow">else</span> {
03057         <span class="keywordflow">return</span> 0;
03058     }
03059 }
03060 
03079 <span class="keywordtype">int</span>
03080 asn_realloc_rbuild_bitstring(u_char ** pkt, size_t * pkt_len,
03081                              size_t * offset, <span class="keywordtype">int</span> r,
03082                              u_char type,
03083                              <span class="keyword">const</span> u_char * string, size_t strlength)
03084 {
03085     <span class="comment">/*</span>
03086 <span class="comment">     * ASN.1 bit string ::= 0x03 asnlength unused {byte}*</span>
03087 <span class="comment">     */</span>
03088     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build bitstring"</span>;
03089     size_t          start_offset = *offset;
03090 
03091     <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; strlength) {
03092         <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03093             <span class="keywordflow">return</span> 0;
03094         }
03095     }
03096 
03097     *offset += strlength;
03098     memcpy(*pkt + *pkt_len - *offset, string, strlength);
03099 
03100     <span class="keywordflow">if</span> (asn_realloc_rbuild_header
03101         (pkt, pkt_len, offset, r, type, strlength)) {
03102         <span class="keywordflow">if</span> (_asn_realloc_build_header_check
03103             (errpre, pkt, pkt_len, strlength)) {
03104             <span class="keywordflow">return</span> 0;
03105         } <span class="keywordflow">else</span> {
03106             DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
03107                            *offset - start_offset);
03108             DEBUGIF(<span class="stringliteral">"dumpv_send"</span>) {
03109                 <span class="keywordflow">if</span> (strlength == 0) {
03110                     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  Bitstring: [NULL]\n"</span>));
03111                 } <span class="keywordflow">else</span> {
03112                     u_char         *buf = (u_char *) malloc(2 * strlength);
03113                     size_t          l =
03114                         (buf != NULL) ? (2 * strlength) : 0, ol = 0;
03115 
03116                     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga27">sprint_realloc_asciistring</a>
03117                         (&amp;buf, &amp;l, &amp;ol, 1, string, strlength)) {
03118                         DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  Bitstring:\t%s\n"</span>,
03119                                   buf));
03120                     } <span class="keywordflow">else</span> {
03121                         <span class="keywordflow">if</span> (buf == NULL) {
03122                             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>,
03123                                       <span class="stringliteral">"  Bitstring:\t[TRUNCATED]\n"</span>));
03124                         } <span class="keywordflow">else</span> {
03125                             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>,
03126                                       <span class="stringliteral">"  Bitstring:\t%s [TRUNCATED]\n"</span>,
03127                                       buf));
03128                         }
03129                     }
03130                     <span class="keywordflow">if</span> (buf != NULL) {
03131                         free(buf);
03132                     }
03133                 }
03134             }
03135         }
03136         <span class="keywordflow">return</span> 1;
03137     }
03138 
03139     <span class="keywordflow">return</span> 0;
03140 }
03141 
03159 <span class="keywordtype">int</span>
03160 asn_realloc_rbuild_unsigned_int64(u_char ** pkt, size_t * pkt_len,
03161                                   size_t * offset, <span class="keywordtype">int</span> r,
03162                                   u_char type,
03163                                <span class="keyword">const</span> <span class=
"keyword">struct</span> counter64 *cp, size_t countersize)
03164 {
03165     <span class="comment">/*</span>
03166 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
03167 <span class="comment">     */</span>
03168     <span class="keyword">register</span> u_long low = cp-&gt;low, high = cp-&gt;high;
03169     size_t          intsize, start_offset = *offset;
03170     <span class="keywordtype">int</span>             count;
03171 
03172     <span class="keywordflow">if</span> (countersize != <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>counter64)) {
03173         _asn_size_err(<span class="stringliteral">"build uint64"</span>, countersize,
03174                       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> counter64));
03175         <span class="keywordflow">return</span> 0;
03176     }
03177 
03178     <span class="comment">/*</span>
03179 <span class="comment">     * Encode the low 4 bytes first.  </span>
03180 <span class="comment">     */</span>
03181     <span class=
"keywordflow">if</span> (((*pkt_len - *offset) &lt; 1) &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03182         <span class="keywordflow">return</span> 0;
03183     }
03184     *(*pkt + *pkt_len - (++*offset)) = (u_char) low;
03185     low &gt;&gt;= 8;
03186     count = 1;
03187 
03188     <span class="keywordflow">while</span> (low != 0) {
03189         count++;
03190         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
03191             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03192             <span class="keywordflow">return</span> 0;
03193         }
03194         *(*pkt + *pkt_len - (++*offset)) = (u_char) low;
03195         low &gt;&gt;= 8;
03196     }
03197 
03198     <span class="comment">/*</span>
03199 <span class="comment">     * Then the high byte if present.  </span>
03200 <span class="comment">     */</span>
03201     <span class="keywordflow">if</span> (high) {
03202         <span class="comment">/*</span>
03203 <span class="comment">         * Do the rest of the low byte.  </span>
03204 <span class="comment">         */</span>
03205         <span class="keywordflow">for</span> (; count &lt; 4; count++) {
03206             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
03207                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03208                 <span class="keywordflow">return</span> 0;
03209             }
03210             *(*pkt + *pkt_len - (++*offset)) = 0;
03211         }
03212 
03213         <span class="comment">/*</span>
03214 <span class="comment">         * Do high byte.  </span>
03215 <span class="comment">         */</span>
03216         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
03217             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03218             <span class="keywordflow">return</span> 0;
03219         }
03220         *(*pkt + *pkt_len - (++*offset)) = (u_char) high;
03221         high &gt;&gt;= 8;
03222 
03223         <span class="keywordflow">while</span> (high != 0) {
03224             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
03225                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03226                 <span class="keywordflow">return</span> 0;
03227             }
03228             *(*pkt + *pkt_len - (++*offset)) = (u_char) high;
03229             high &gt;&gt;= 8;
03230         }
03231     }
03232 
03233     <span class="keywordflow">if</span> ((*(*pkt + *pkt_len - *offset) &amp; 0x80) != (0 &amp; 0x80)) {
03234         <span class="comment">/*</span>
03235 <span class="comment">         * Make sure left most bit is representational of the rest of the bits</span>
03236 <span class="comment">         * that aren't encoded.  </span>
03237 <span class="comment">         */</span>
03238         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
03239             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03240             <span class="keywordflow">return</span> 0;
03241         }
03242         *(*pkt + *pkt_len - (++*offset)) = 0;
03243     }
03244 
03245     intsize = *offset - start_offset;
03246 
03247 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
03248     <span class="comment">/*</span>
03249 <span class="comment">     * Encode a Counter64 as an opaque (it also works in SNMPv1).  </span>
03250 <span class="comment">     */</span>
03251     <span class="keywordflow">if</span> (type == ASN_OPAQUE_COUNTER64) {
03252         <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; 5) {
03253             <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03254                 <span class="keywordflow">return</span> 0;
03255             }
03256         }
03257 
03258         *(*pkt + *pkt_len - (++*offset)) = (u_char) intsize;
03259         *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_COUNTER64;
03260         *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_TAG1;
03261 
03262         <span class="comment">/*</span>
03263 <span class="comment">         * Put the tag and length for the Opaque wrapper.  </span>
03264 <span class="comment">         */</span>
03265         <span class="keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r,
03266                                       ASN_OPAQUE, intsize + 3)) {
03267             <span class="keywordflow">if</span> (_asn_realloc_build_header_check
03268                 (<span class="stringliteral">"build counter u64"</span>, pkt, pkt_len, intsize + 3)) {
03269                 <span class="keywordflow">return</span> 0;
03270             }
03271         } <span class="keywordflow">else</span> {
03272             <span class="keywordflow">return</span> 0;
03273         }
03274     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == ASN_OPAQUE_U64) {
03275         <span class="comment">/*</span>
03276 <span class="comment">         * Encode the Unsigned int64 in an opaque.  </span>
03277 <span class="comment">         */</span>
03278         <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; 5) {
03279             <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03280                 <span class="keywordflow">return</span> 0;
03281             }
03282         }
03283 
03284         *(*pkt + *pkt_len - (++*offset)) = (u_char) intsize;
03285         *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_U64;
03286         *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_TAG1;
03287 
03288         <span class="comment">/*</span>
03289 <span class="comment">         * Put the tag and length for the Opaque wrapper.  </span>
03290 <span class="comment">         */</span>
03291         <span class="keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r,
03292                                       ASN_OPAQUE, intsize + 3)) {
03293             <span class="keywordflow">if</span> (_asn_realloc_build_header_check
03294                 (<span class="stringliteral">"build counter u64"</span>, pkt, pkt_len, intsize + 3)) {
03295                 <span class="keywordflow">return</span> 0;
03296             }
03297         } <span class="keywordflow">else</span> {
03298             <span class="keywordflow">return</span> 0;
03299         }
03300     } <span class="keywordflow">else</span> {
03301 
03302 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
03303         <span class="keywordflow">if</span> (asn_realloc_rbuild_header
03304             (pkt, pkt_len, offset, r, type, intsize)) {
03305             <span class="keywordflow">if</span> (_asn_realloc_build_header_check
03306                 (<span class="stringliteral">"build uint64"</span>, pkt, pkt_len, intsize)) {
03307                 <span class="keywordflow">return</span> 0;
03308             }
03309         } <span class="keywordflow">else</span> {
03310             <span class="keywordflow">return</span> 0;
03311         }
03312 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
03313     }
03314 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
03315 
03316     DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, (*pkt + *pkt_len - *offset), intsize);
03317     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  U64:\t%lu %lu\n"</span>, cp-&gt;high, cp-&gt;low));
03318     <span class="keywordflow">return</span> 1;
03319 }
03320 
03321 <span class="preprocessor">#ifdef OPAQUE_SPECIAL_TYPES</span>
03322 
03323 
03341 <span class="keywordtype">int</span>
03342 asn_realloc_rbuild_signed_int64(u_char ** pkt, size_t * pkt_len,
03343                                 size_t * offset, <span class="keywordtype">int</span> r,
03344                                 u_char type,
03345                                 <span class="keyword">const</span> <span class=
"keyword">struct</span> counter64 *cp, size_t countersize)
03346 {
03347     <span class="comment">/*</span>
03348 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
03349 <span class="comment">     */</span>
03350     <span class="keyword">register</span> u_long low = cp-&gt;low, high = cp-&gt;high;
03351     size_t          intsize, start_offset = *offset;
03352     <span class="keywordtype">int</span>             count, testvalue = (high &amp; 0x80000000) ? -1 : 0;
03353 
03354     <span class="keywordflow">if</span> (countersize != <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>counter64)) {
03355         _asn_size_err(<span class="stringliteral">"build uint64"</span>, countersize,
03356                       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> counter64));
03357         <span class="keywordflow">return</span> 0;
03358     }
03359 
03360     <span class="comment">/*</span>
03361 <span class="comment">     * Encode the low 4 bytes first.  </span>
03362 <span class="comment">     */</span>
03363     <span class=
"keywordflow">if</span> (((*pkt_len - *offset) &lt; 1) &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03364         <span class="keywordflow">return</span> 0;
03365     }
03366     *(*pkt + *pkt_len - (++*offset)) = (u_char) low;
03367     low &gt;&gt;= 8;
03368     count = 1;
03369 
03370     <span class="keywordflow">while</span> ((int) low != testvalue) {
03371         count++;
03372         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
03373             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03374             <span class="keywordflow">return</span> 0;
03375         }
03376         *(*pkt + *pkt_len - (++*offset)) = (u_char) low;
03377         low &gt;&gt;= 8;
03378     }
03379 
03380     <span class="comment">/*</span>
03381 <span class="comment">     * Then the high byte if present.  </span>
03382 <span class="comment">     */</span>
03383     <span class="keywordflow">if</span> (high) {
03384         <span class="comment">/*</span>
03385 <span class="comment">         * Do the rest of the low byte.  </span>
03386 <span class="comment">         */</span>
03387         <span class="keywordflow">for</span> (; count &lt; 4; count++) {
03388             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
03389                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03390                 <span class="keywordflow">return</span> 0;
03391             }
03392             *(*pkt + *pkt_len - (++*offset)) = (testvalue == 0) ? 0 : 0xff;
03393         }
03394 
03395         <span class="comment">/*</span>
03396 <span class="comment">         * Do high byte.  </span>
03397 <span class="comment">         */</span>
03398         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
03399             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03400             <span class="keywordflow">return</span> 0;
03401         }
03402         *(*pkt + *pkt_len - (++*offset)) = (u_char) high;
03403         high &gt;&gt;= 8;
03404 
03405         <span class="keywordflow">while</span> ((int) high != testvalue) {
03406             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
03407                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03408                 <span class="keywordflow">return</span> 0;
03409             }
03410             *(*pkt + *pkt_len - (++*offset)) = (u_char) high;
03411             high &gt;&gt;= 8;
03412         }
03413     }
03414 
03415     <span class="keywordflow">if</span> ((*(*pkt + *pkt_len - *offset) &amp; 0x80) != (0 &amp; 0x80)) {
03416         <span class="comment">/*</span>
03417 <span class="comment">         * Make sure left most bit is representational of the rest of the bits</span>
03418 <span class="comment">         * that aren't encoded.  </span>
03419 <span class="comment">         */</span>
03420         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
03421             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03422             <span class="keywordflow">return</span> 0;
03423         }
03424         *(*pkt + *pkt_len - (++*offset)) = (testvalue == 0) ? 0 : 0xff;
03425     }
03426 
03427     intsize = *offset - start_offset;
03428 
03429     <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; 5) {
03430         <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03431             <span class="keywordflow">return</span> 0;
03432         }
03433     }
03434 
03435     *(*pkt + *pkt_len - (++*offset)) = (u_char) intsize;
03436     *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_I64;
03437     *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_TAG1;
03438 
03439     <span class="comment">/*</span>
03440 <span class="comment">     * Put the tag and length for the Opaque wrapper.  </span>
03441 <span class="comment">     */</span>
03442     <span class="keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r,
03443                                   ASN_OPAQUE, intsize + 3)) {
03444         <span class="keywordflow">if</span> (_asn_realloc_build_header_check
03445             (<span class="stringliteral">"build counter u64"</span>, pkt, pkt_len, intsize + 3)) {
03446             <span class="keywordflow">return</span> 0;
03447         }
03448     } <span class="keywordflow">else</span> {
03449         <span class="keywordflow">return</span> 0;
03450     }
03451 
03452     DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, (*pkt + *pkt_len - *offset), intsize);
03453     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  UInt64:\t%lu %lu\n"</span>, cp-&gt;high, cp-&gt;low));
03454     <span class="keywordflow">return</span> 1;
03455 }
03456 
03475 <span class="keywordtype">int</span>
03476 asn_realloc_rbuild_float(u_char ** pkt, size_t * pkt_len,
03477                          size_t * offset, <span class="keywordtype">int</span> r,
03478                          u_char type, <span class="keyword">const</span> <span class=
"keywordtype">float</span> *floatp, size_t floatsize)
03479 {
03480     size_t          start_offset = *offset;
03481     <span class="keyword">union </span>{
03482         <span class="keywordtype">float</span>           floatVal;
03483         <span class="keywordtype">int</span>             intVal;
03484         u_char          c[<span class="keyword">sizeof</span>(float)];
03485     } fu;
03486 
03487     <span class="comment">/*</span>
03488 <span class="comment">     * Floatsize better not be larger than realistic.  </span>
03489 <span class="comment">     */</span>
03490     <span class="keywordflow">if</span> (floatsize != <span class="keyword">sizeof</span>(float) || floatsize &gt; 122) {
03491         <span class="keywordflow">return</span> 0;
03492     }
03493 
03494     <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; floatsize + 3) {
03495         <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03496             <span class="keywordflow">return</span> 0;
03497         }
03498     }
03499 
03500     <span class="comment">/*</span>
03501 <span class="comment">     * Correct for endian differences and copy value.  </span>
03502 <span class="comment">     */</span>
03503     fu.floatVal = *floatp;
03504     fu.intVal = htonl(fu.intVal);
03505     *offset += floatsize;
03506     memcpy(*pkt + *pkt_len - *offset, &amp;(fu.c[0]), floatsize);
03507 
03508     <span class="comment">/*</span>
03509 <span class="comment">     * Put the special tag and length (3 bytes).  </span>
03510 <span class="comment">     */</span>
03511     *(*pkt + *pkt_len - (++*offset)) = (u_char) floatsize;
03512     *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_FLOAT;
03513     *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_TAG1;
03514 
03515     <span class="comment">/*</span>
03516 <span class="comment">     * Put the tag and length for the Opaque wrapper.  </span>
03517 <span class="comment">     */</span>
03518     <span class="keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r,
03519                                   ASN_OPAQUE, floatsize + 3)) {
03520         <span class="keywordflow">if</span> (_asn_realloc_build_header_check(<span class=
"stringliteral">"build float"</span>, pkt, pkt_len,
03521                                             floatsize + 3)) {
03522             <span class="keywordflow">return</span> 0;
03523         } <span class="keywordflow">else</span> {
03524             DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
03525                            *offset - start_offset);
03526             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"Opaque Float:\t%f\n"</span>, *floatp));
03527             <span class="keywordflow">return</span> 1;
03528         }
03529     }
03530 
03531     <span class="keywordflow">return</span> 0;
03532 }
03533 
03552 <span class="keywordtype">int</span>
03553 asn_realloc_rbuild_double(u_char ** pkt, size_t * pkt_len,
03554                           size_t * offset, <span class="keywordtype">int</span> r,
03555                           u_char type, <span class="keyword">const</span> <span class=
"keywordtype">double</span> *doublep, size_t doublesize)
03556 {
03557     size_t          start_offset = *offset;
03558     <span class="keywordtype">long</span>            tmp;
03559     <span class="keyword">union </span>{
03560         <span class="keywordtype">double</span>          doubleVal;
03561         <span class="keywordtype">int</span>             intVal[2];
03562         u_char          c[<span class="keyword">sizeof</span>(double)];
03563     } fu;
03564 
03565     <span class="comment">/*</span>
03566 <span class="comment">     * Doublesize better not be larger than realistic.  </span>
03567 <span class="comment">     */</span>
03568     <span class="keywordflow">if</span> (doublesize != <span class=
"keyword">sizeof</span>(double) || doublesize &gt; 122) {
03569         <span class="keywordflow">return</span> 0;
03570     }
03571 
03572     <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; doublesize + 3) {
03573         <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
03574             <span class="keywordflow">return</span> 0;
03575         }
03576     }
03577 
03578     <span class="comment">/*</span>
03579 <span class="comment">     * Correct for endian differences and copy value.  </span>
03580 <span class="comment">     */</span>
03581     fu.doubleVal = *doublep;
03582     tmp = htonl(fu.intVal[0]);
03583     fu.intVal[0] = htonl(fu.intVal[1]);
03584     fu.intVal[1] = tmp;
03585     *offset += doublesize;
03586     memcpy(*pkt + *pkt_len - *offset, &amp;(fu.c[0]), doublesize);
03587 
03588     <span class="comment">/*</span>
03589 <span class="comment">     * Put the special tag and length (3 bytes).  </span>
03590 <span class="comment">     */</span>
03591     *(*pkt + *pkt_len - (++*offset)) = (u_char) doublesize;
03592     *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_DOUBLE;
03593     *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_TAG1;
03594 
03595     <span class="comment">/*</span>
03596 <span class="comment">     * Put the tag and length for the Opaque wrapper.  </span>
03597 <span class="comment">     */</span>
03598     <span class="keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r,
03599                                   ASN_OPAQUE, doublesize + 3)) {
03600         <span class="keywordflow">if</span> (_asn_realloc_build_header_check(<span class=
"stringliteral">"build float"</span>, pkt, pkt_len,
03601                                             doublesize + 3)) {
03602             <span class="keywordflow">return</span> 0;
03603         } <span class="keywordflow">else</span> {
03604             DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
03605                            *offset - start_offset);
03606             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  Opaque Double:\t%f\n"</span>, *doublep));
03607             <span class="keywordflow">return</span> 1;
03608         }
03609     }
03610 
03611     <span class="keywordflow">return</span> 0;
03612 }
03613 
03614 <span class="preprocessor">#endif                          </span><span class="comment">/* OPAQUE_SPECIAL_TYPES */</span>
03615 <span class="preprocessor">#endif                          </span><span class=
"comment">/*  USE_REVERSE_ASNENCODING  */</span>
03616 
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small><!--#include virtual="/sfbutton.html" --><br />
    Generated on Thu Oct 28 21:46:56 2004 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

