<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000003.html">agent</a>
  </div>

  <h1>agent_trap.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * agent_trap.c</span>
00003 <span class="comment"> */</span>
00004 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
00005 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00006 <span class="comment"> * that may apply:</span>
00007 <span class="comment"> */</span>
00008 <span class="comment">/*</span>
00009 <span class="comment"> * Portions of this file are copyrighted by:</span>
00010 <span class="comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
00011 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00012 <span class="comment"> * distributed with the Net-SNMP package.</span>
00013 <span class="comment"> */</span>
00020 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00021 
00022 <span class="preprocessor">#if HAVE_UNISTD_H</span>
00023 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00024 <span class="preprocessor">#endif</span>
00025 <span class="preprocessor">#if HAVE_NETDB_H</span>
00026 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00027 <span class="preprocessor">#endif</span>
00028 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00029 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00030 <span class="preprocessor">#endif</span>
00031 <span class="preprocessor">#if HAVE_STRING_H</span>
00032 <span class="preprocessor">#include &lt;string.h&gt;</span>
00033 <span class="preprocessor">#else</span>
00034 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00035 <span class="preprocessor">#endif</span>
00036 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00037 <span class="preprocessor"># ifdef WIN32</span>
00038 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00039 <span class="preprocessor"># else</span>
00040 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00041 <span class="preprocessor"># endif</span>
00042 <span class="preprocessor"># include &lt;time.h&gt;</span>
00043 <span class="preprocessor">#else</span>
00044 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00045 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00046 <span class="preprocessor"># else</span>
00047 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00048 <span class="preprocessor"># endif</span>
00049 <span class="preprocessor">#endif</span>
00050 <span class="preprocessor">#if HAVE_SYS_SOCKET_H</span>
00051 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00052 <span class="preprocessor">#elif HAVE_WINSOCK_H</span>
00053 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00054 <span class="preprocessor">#endif</span>
00055 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00056 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00057 <span class="preprocessor">#endif</span>
00058 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00059 
00060 <span class="preprocessor">#include &lt;net-snmp/net-snmp-includes.h&gt;</span>
00061 <span class="preprocessor">#include &lt;net-snmp/agent/agent_trap.h&gt;</span>
00062 <span class="preprocessor">#include &lt;net-snmp/agent/snmp_agent.h&gt;</span>
00063 <span class="preprocessor">#include &lt;net-snmp/agent/agent_callbacks.h&gt;</span>
00064 
00065 <span class="preprocessor">#include &lt;net-snmp/agent/mib_module_config.h&gt;</span>
00066 
00067 <span class="preprocessor">#ifdef USING_AGENTX_PROTOCOL_MODULE</span>
00068 <span class="preprocessor">#include "agentx/protocol.h"</span>
00069 <span class="preprocessor">#endif</span>
00070 
00071 <span class="keyword">struct </span>trap_sink {
00072     <a class="code" href="structsnmp__session.html">netsnmp_session</a> *sesp;
00073     <span class="keyword">struct </span>trap_sink *next;
00074     <span class="keywordtype">int</span>             pdutype;
00075     <span class="keywordtype">int</span>             version;
00076 };
00077 
00078 <span class="keyword">struct </span>trap_sink *sinks = NULL;
00079 
00080 <span class="keyword">extern</span> <span class="keyword">struct </span>timeval starttime;
00081 
00082 oid             objid_enterprisetrap[] = { NOTIFICATION_MIB };
00083 oid             trap_version_id[] = { SYSTEM_MIB };
00084 <span class="keywordtype">int</span>             enterprisetrap_len;
00085 <span class="keywordtype">int</span>             trap_version_id_len;
00086 
00087 <span class="preprocessor">#define SNMPV2_TRAPS_PREFIX     SNMP_OID_SNMPMODULES,1,1,5</span>
00088 oid             trap_prefix[]    = { SNMPV2_TRAPS_PREFIX };
00089 oid             cold_start_oid[] = { SNMPV2_TRAPS_PREFIX, 1 };  <span class="comment">/* SNMPv2-MIB */</span>
00090 oid             warm_start_oid[] = { SNMPV2_TRAPS_PREFIX, 2 };  <span class="comment">/* SNMPv2-MIB */</span>
00091 oid             link_down_oid[]  = { SNMPV2_TRAPS_PREFIX, 3 };  <span class="comment">/* IF-MIB */</span>
00092 oid             link_up_oid[]    = { SNMPV2_TRAPS_PREFIX, 4 };  <span class="comment">/* IF-MIB */</span>
00093 oid             auth_fail_oid[]  = { SNMPV2_TRAPS_PREFIX, 5 };  <span class="comment">/* SNMPv2-MIB */</span>
00094 oid             egp_xxx_oid[]    = { SNMPV2_TRAPS_PREFIX, 99 }; <span class="comment">/* ??? */</span>
00095 
00096 <span class="preprocessor">#define SNMPV2_TRAP_OBJS_PREFIX SNMP_OID_SNMPMODULES,1,1,4</span>
00097 oid             snmptrap_oid[] = { SNMPV2_TRAP_OBJS_PREFIX, 1, 0 };
00098 oid             snmptrapenterprise_oid[] =
00099     { SNMPV2_TRAP_OBJS_PREFIX, 3, 0 };
00100 oid             sysuptime_oid[] = { SNMP_OID_MIB2, 1, 3, 0 };
00101 size_t          snmptrap_oid_len;
00102 size_t          snmptrapenterprise_oid_len;
00103 size_t          sysuptime_oid_len;
00104 
00105 <span class="preprocessor">#define SNMPV2_COMM_OBJS_PREFIX SNMP_OID_SNMPMODULES,18,1</span>
00106 oid             agentaddr_oid[] = { SNMPV2_COMM_OBJS_PREFIX, 3, 0 };
00107 size_t          agentaddr_oid_len;
00108 oid             community_oid[] = { SNMPV2_COMM_OBJS_PREFIX, 4, 0 };
00109 size_t          community_oid_len;
00110 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
00111 <span class="keywordtype">char</span>           *snmp_trapcommunity = NULL;
00112 <span class="preprocessor">#endif</span>
00113 
00114 
00115 <span class="preprocessor">#define SNMP_AUTHENTICATED_TRAPS_ENABLED        1</span>
00116 <span class="preprocessor">#define SNMP_AUTHENTICATED_TRAPS_DISABLED       2</span>
00117 
00118 <span class="keywordtype">int</span>             snmp_enableauthentraps = SNMP_AUTHENTICATED_TRAPS_DISABLED;
00119 <span class="keywordtype">int</span>             snmp_enableauthentrapsset = 0;
00120 
00121 <span class="comment">/*</span>
00122 <span class="comment"> * Prototypes </span>
00123 <span class="comment"> */</span>
00124  <span class="comment">/*</span>
00125 <span class="comment">  * static int create_v1_trap_session (const char *, u_short, const char *);</span>
00126 <span class="comment">  * static int create_v2_trap_session (const char *, u_short, const char *);</span>
00127 <span class="comment">  * static int create_v2_inform_session (const char *, u_short, const char *);</span>
00128 <span class="comment">  * static void free_trap_session (struct trap_sink *sp);</span>
00129 <span class="comment">  * static void send_v1_trap (netsnmp_session *, int, int);</span>
00130 <span class="comment">  * static void send_v2_trap (netsnmp_session *, int, int, int);</span>
00131 <span class="comment">  */</span>
00132 
00133 
00134         <span class="comment">/*******************</span>
00135 <span class="comment">         *</span>
00136 <span class="comment">         * Trap session handling</span>
00137 <span class="comment">         *</span>
00138 <span class="comment">         *******************/</span>
00139 
00140 <span class="keywordtype">void</span>
00141 init_traps(<span class="keywordtype">void</span>)
00142 {
00143     enterprisetrap_len  = OID_LENGTH(objid_enterprisetrap);
00144     trap_version_id_len = OID_LENGTH(trap_version_id);
00145     snmptrap_oid_len    = OID_LENGTH(snmptrap_oid);
00146     snmptrapenterprise_oid_len = OID_LENGTH(snmptrapenterprise_oid);
00147     sysuptime_oid_len   = OID_LENGTH(sysuptime_oid);
00148     agentaddr_oid_len   = OID_LENGTH(agentaddr_oid);
00149     community_oid_len   = OID_LENGTH(community_oid);
00150 }
00151 
00152 <span class="keyword">static</span> <span class="keywordtype">void</span>
00153 free_trap_session(<span class="keyword">struct</span> trap_sink *sp)
00154 {
00155     snmp_close(sp-&gt;sesp);
00156     free(sp);
00157 }
00158 
00159 <span class="keywordtype">int</span>
00160 add_trap_session(<a class="code" href="structsnmp__session.html">netsnmp_session</a> * ss, <span class=
"keywordtype">int</span> pdutype, <span class="keywordtype">int</span> confirm,
00161                  <span class="keywordtype">int</span> version)
00162 {
00163     <span class="keywordflow">if</span> (snmp_callback_available(SNMP_CALLBACK_APPLICATION,
00164                                 SNMPD_CALLBACK_REGISTER_NOTIFICATIONS) ==
00165         SNMPERR_SUCCESS) {
00166         <span class="comment">/*</span>
00167 <span class="comment">         * something else wants to handle notification registrations </span>
00168 <span class="comment">         */</span>
00169         <span class="keyword">struct </span>agent_add_trap_args args;
00170         DEBUGMSGTL((<span class="stringliteral">"trap"</span>, <span class=
"stringliteral">"adding callback trap sink\n"</span>));
00171         args.ss = ss;
00172         args.confirm = confirm;
00173         <a class="code" href="group__callback.html#ga10">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
00174                             SNMPD_CALLBACK_REGISTER_NOTIFICATIONS,
00175                             (<span class="keywordtype">void</span> *) &amp;args);
00176     } <span class="keywordflow">else</span> {
00177         <span class="comment">/*</span>
00178 <span class="comment">         * no other support exists, handle it ourselves. </span>
00179 <span class="comment">         */</span>
00180         <span class="keyword">struct </span>trap_sink *new_sink;
00181 
00182         DEBUGMSGTL((<span class="stringliteral">"trap"</span>, <span class=
"stringliteral">"adding internal trap sink\n"</span>));
00183         new_sink = (<span class="keyword">struct </span>trap_sink *) malloc(<span class=
"keyword">sizeof</span>(*new_sink));
00184         <span class="keywordflow">if</span> (new_sink == NULL)
00185             <span class="keywordflow">return</span> 0;
00186 
00187         new_sink-&gt;sesp = ss;
00188         new_sink-&gt;pdutype = pdutype;
00189         new_sink-&gt;<a class="code" href="structsnmp__session.html#o0">version</a> = version;
00190         new_sink-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = sinks;
00191         sinks = new_sink;
00192     }
00193     <span class="keywordflow">return</span> 1;
00194 }
00195 
00196 <span class="keywordtype">int</span>
00197 remove_trap_session(<a class="code" href="structsnmp__session.html">netsnmp_session</a> * ss)
00198 {
00199     <span class="keyword">struct </span>trap_sink *sp = sinks, *prev = 0;
00200 
00201     <span class="keywordflow">while</span> (sp) {
00202         <span class="keywordflow">if</span> (sp-&gt;sesp == ss) {
00203             <span class="keywordflow">if</span> (prev) {
00204                 prev-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = sp-&gt;<a class="code" href=
"structsnmp__session.html#o5">next</a>;
00205             } <span class="keywordflow">else</span> {
00206                 sinks = sp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
00207             }
00208             <span class="comment">/*</span>
00209 <span class="comment">             * I don't believe you *really* want to close the session here;</span>
00210 <span class="comment">             * it may still be in use for other purposes.  In particular this</span>
00211 <span class="comment">             * is awkward for AgentX, since we want to call this function</span>
00212 <span class="comment">             * from the session's callback.  Let's just free the trapsink</span>
00213 <span class="comment">             * data structure.  [jbpn]  </span>
00214 <span class="comment">             */</span>
00215             <span class="comment">/*</span>
00216 <span class="comment">             * free_trap_session(sp);  </span>
00217 <span class="comment">             */</span>
00218             free(sp);
00219             <span class="keywordflow">return</span> 1;
00220         }
00221         prev = sp;
00222         sp = sp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
00223     }
00224     <span class="keywordflow">return</span> 0;
00225 }
00226 
00227 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
00228 <span class="keywordtype">int</span>
00229 create_trap_session(<span class="keywordtype">char</span> *sink, u_short sinkport,
00230                     <span class="keywordtype">char</span> *com, <span class="keywordtype">int</span> version, <span class=
"keywordtype">int</span> pdutype)
00231 {
00232     <a class="code" href="structsnmp__session.html">netsnmp_session</a> session, *sesp;
00233     <span class="keywordtype">char</span>           *peername = NULL;
00234     <span class="keywordtype">int</span>             len;
00235 
00236     len = strlen(sink) + 4 + 32;
00237     <span class="keywordflow">if</span> ((peername = malloc(len)) == NULL) {
00238         <span class="keywordflow">return</span> 0;
00239     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NULL != strchr(sink,<span class=
"charliteral">':'</span>)) {
00240         snprintf(peername, len, <span class="stringliteral">"%s"</span>, sink);
00241     } <span class="keywordflow">else</span> {
00242         snprintf(peername, len, <span class="stringliteral">"udp:%s:%hu"</span>, sink, sinkport);
00243     }
00244 
00245     memset(&amp;session, 0, <span class="keyword">sizeof</span>(<a class="code" href=
"structsnmp__session.html">netsnmp_session</a>));
00246     session.<a class="code" href="structsnmp__session.html#o6">peername</a> = peername;
00247     session.<a class="code" href="structsnmp__session.html#o0">version</a> = version;
00248     <span class="keywordflow">if</span> (com) {
00249         session.<a class="code" href="structsnmp__session.html#o16">community</a> = (u_char *) com;
00250         session.<a class="code" href="structsnmp__session.html#o17">community_len</a> = strlen(com);
00251     }
00252 
00253     <span class="comment">/*</span>
00254 <span class="comment">     * for informs, set retries to default</span>
00255 <span class="comment">     */</span>
00256     <span class="keywordflow">if</span> (SNMP_MSG_INFORM == pdutype) {
00257         session.<a class="code" href="structsnmp__session.html#o2">timeout</a> = SNMP_DEFAULT_TIMEOUT;
00258         session.<a class="code" href="structsnmp__session.html#o1">retries</a> = SNMP_DEFAULT_RETRIES;
00259     }
00260 
00261     <span class="comment">/*</span>
00262 <span class="comment">     * if the sink is localhost, bind to localhost, to reduce open ports.</span>
00263 <span class="comment">     */</span>
00264     <span class="keywordflow">if</span> ((NULL == netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
00265                                        NETSNMP_DS_LIB_CLIENT_ADDR)) &amp;&amp; 
00266         ((0 == strcmp(<span class="stringliteral">"localhost"</span>,sink)) || (0 == strcmp(<span class=
"stringliteral">"127.0.0.1"</span>,sink))))
00267         session.<a class="code" href="structsnmp__session.html#o8">localname</a> = <span class=
"stringliteral">"localhost"</span>;
00268     sesp = snmp_open(&amp;session);
00269     free(peername);
00270 
00271     <span class="keywordflow">if</span> (sesp) {
00272         <span class="keywordflow">return</span> add_trap_session(sesp, pdutype,
00273                                 (pdutype == SNMP_MSG_INFORM), version);
00274     }
00275 
00276     <span class="comment">/*</span>
00277 <span class="comment">     * diagnose snmp_open errors with the input netsnmp_session pointer </span>
00278 <span class="comment">     */</span>
00279     snmp_sess_perror(<span class="stringliteral">"snmpd: create_trap_session"</span>, &amp;session);
00280     <span class="keywordflow">return</span> 0;
00281 }
00282 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
00283 
00284 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
00285 <span class="keyword">static</span> <span class="keywordtype">int</span>
00286 create_v1_trap_session(<span class="keywordtype">char</span> *sink, u_short sinkport, <span class=
"keywordtype">char</span> *com)
00287 {
00288     <span class="keywordflow">return</span> create_trap_session(sink, sinkport, com,
00289                                SNMP_VERSION_1, SNMP_MSG_TRAP);
00290 }
00291 <span class="preprocessor">#endif</span>
00292 
00293 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
00294 <span class="keyword">static</span> <span class="keywordtype">int</span>
00295 create_v2_trap_session(<span class="keywordtype">char</span> *sink, u_short sinkport, <span class=
"keywordtype">char</span> *com)
00296 {
00297     <span class="keywordflow">return</span> create_trap_session(sink, sinkport, com,
00298                                SNMP_VERSION_2c, SNMP_MSG_TRAP2);
00299 }
00300 
00301 <span class="keyword">static</span> <span class="keywordtype">int</span>
00302 create_v2_inform_session(<span class="keywordtype">char</span> *sink, u_short sinkport, <span class=
"keywordtype">char</span> *com)
00303 {
00304     <span class="keywordflow">return</span> create_trap_session(sink, sinkport, com,
00305                                SNMP_VERSION_2c, SNMP_MSG_INFORM);
00306 }
00307 <span class="preprocessor">#endif</span>
00308 
00348 <span class="keywordtype">void</span>
<a name="l00349" id="l00349"></a><a class="code" href="group__agent__trap.html#ga35">00349</a> <a class="code" href=
"group__agent__trap.html#ga35">snmpd_free_trapsinks</a>(<span class="keywordtype">void</span>)
00350 {
00351     <span class="keyword">struct </span>trap_sink *sp = sinks;
00352     <span class="keywordflow">while</span> (sp) {
00353         sinks = sinks-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
00354         free_trap_session(sp);
00355         sp = sinks;
00356     }
00357 }
00358 
00359         <span class="comment">/*******************</span>
00360 <span class="comment">         *</span>
00361 <span class="comment">         * Trap handling</span>
00362 <span class="comment">         *</span>
00363 <span class="comment">         *******************/</span>
00364 
00365 
00366 <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>*
00367 convert_v2pdu_to_v1( <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>* template_v2pdu )
00368 {
00369     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>           *template_v1pdu;
00370     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *first_vb, *vblist;
00371     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *var;
00372     size_t                 len;
00373 
00374     <span class="comment">/*</span>
00375 <span class="comment">     * Make a copy of the v2 Trap PDU</span>
00376 <span class="comment">     *   before starting to convert this</span>
00377 <span class="comment">     *   into a v1 Trap PDU.</span>
00378 <span class="comment">     */</span>
00379     template_v1pdu = snmp_clone_pdu( template_v2pdu);
00380     <span class="keywordflow">if</span> (!template_v1pdu) {
00381         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00382                  <span class="stringliteral">"send_trap: failed to copy v1 template PDU\n"</span>);
00383         <span class="keywordflow">return</span> NULL;
00384     }
00385     template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = SNMP_MSG_TRAP;
00386     first_vb = template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>;
00387     vblist   = template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>;
00388 
00389     <span class="comment">/*</span>
00390 <span class="comment">     * The first varbind should be the system uptime.</span>
00391 <span class="comment">     */</span>
00392     <span class="keywordflow">if</span> (!vblist ||
00393         <a class="code" href="group__library.html#ga103">snmp_oid_compare</a>(vblist-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>,  vblist-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>,
00394                          sysuptime_oid, sysuptime_oid_len)) {
00395         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00396                  <span class="stringliteral">"send_trap: no v2 sysUptime varbind to set from\n"</span>);
00397         snmp_free_pdu(template_v1pdu);
00398         <span class="keywordflow">return</span> NULL;
00399     }
00400     template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o8">time</a> = *vblist-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer;
00401     vblist = vblist-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>;
00402             
00403     <span class="comment">/*</span>
00404 <span class="comment">     * The second varbind should be the snmpTrapOID.</span>
00405 <span class="comment">     */</span>
00406     <span class="keywordflow">if</span> (!vblist ||
00407         <a class="code" href="group__library.html#ga103">snmp_oid_compare</a>(vblist-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, vblist-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>,
00408                          snmptrap_oid, snmptrap_oid_len)) {
00409         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00410                  <span class="stringliteral">"send_trap: no v2 trapOID varbind to set from\n"</span>);
00411         snmp_free_pdu(template_v1pdu);
00412         <span class="keywordflow">return</span> NULL;
00413     }
00414 
00415     <span class="comment">/*</span>
00416 <span class="comment">     * Set the generic &amp; specific trap types,</span>
00417 <span class="comment">     *    and the enterprise field from the v2 varbind list.</span>
00418 <span class="comment">     * If there's an agentIPAddress varbind, set the agent_addr too</span>
00419 <span class="comment">     */</span>
00420     <span class="keywordflow">if</span> (!<a class="code" href=
"group__library.html#ga103">snmp_oid_compare</a>(vblist-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid, OID_LENGTH(trap_prefix),
00421                           trap_prefix,       OID_LENGTH(trap_prefix))) {
00422         <span class="comment">/*</span>
00423 <span class="comment">         * For 'standard' traps, extract the generic trap type</span>
00424 <span class="comment">         *   from the snmpTrapOID value, and take the enterprise</span>
00425 <span class="comment">         *   value from the 'snmpEnterprise' varbind.</span>
00426 <span class="comment">         */</span>
00427         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o22">trap_type</a> =
00428             vblist-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid[OID_LENGTH(trap_prefix)] - 1;
00429         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o23">specific_type</a> = 0;
00430 
00431         var = find_varbind_in_list( vblist,
00432                              snmptrapenterprise_oid,
00433                              snmptrapenterprise_oid_len);
00434         <span class="keywordflow">if</span> (var) {
00435             <a class="code" href="group__util.html#ga5">memdup</a>((u_char**)&amp;template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o20">enterprise</a>,
00436                    (<span class="keyword">const</span> u_char*)var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid, var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
00437             template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> = var-&gt;<a class=
"code" href="structvariable__list.html#o5">val_len</a>/<span class="keyword">sizeof</span>(oid);
00438         } <span class="keywordflow">else</span> {
00439             template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>        = NULL;
00440             template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o21">enterprise_length</a> = 0;              <span class="comment">/* XXX ??? */</span>
00441         }
00442     } <span class="keywordflow">else</span> {
00443         <span class="comment">/*</span>
00444 <span class="comment">         * For enterprise-specific traps, split the snmpTrapOID value</span>
00445 <span class="comment">         *   into enterprise and specific trap</span>
00446 <span class="comment">         */</span>
00447         len = vblist-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> / <span class=
"keyword">sizeof</span>(oid);
00448         template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a>     = SNMP_TRAP_ENTERPRISESPECIFIC;
00449         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o23">specific_type</a> = vblist-&gt;<a class="code"
href="structvariable__list.html#o4">val</a>.objid[len - 1];
00450         len--;
00451         <span class="keywordflow">if</span> (vblist-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid[len-1] == 0)
00452             len--;
00453         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o20">enterprise</a>);
00454         <a class="code" href="group__util.html#ga5">memdup</a>((u_char**)&amp;template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o20">enterprise</a>,
00455                (u_char *)vblist-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid, len*<span class=
"keyword">sizeof</span>(oid));
00456         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> = len;
00457     }
00458     var = find_varbind_in_list( vblist, agentaddr_oid,
00459                                         agentaddr_oid_len);
00460     <span class="keywordflow">if</span> (var) {
00461         memcpy(template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>,
00462                var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string, 4);
00463     }
00464 
00465     <span class="comment">/*</span>
00466 <span class="comment">     * The remainder of the v2 varbind list is kept</span>
00467 <span class="comment">     * as the v2 varbind list.  Update the PDU and</span>
00468 <span class="comment">     * free the two redundant varbinds.</span>
00469 <span class="comment">     */</span>
00470     template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = vblist-&gt;<a class="code" href=
"structvariable__list.html#o0">next_variable</a>;
00471     vblist-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a> = NULL;
00472     snmp_free_varbind( first_vb );
00473             
00474     <span class="keywordflow">return</span> template_v1pdu;
00475 }
00476 
00477 <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>*
00478 convert_v1pdu_to_v2( <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>* template_v1pdu )
00479 {
00480     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>           *template_v2pdu;
00481     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *first_vb;
00482     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *var;
00483     oid                    enterprise[MAX_OID_LEN];
00484     size_t                 enterprise_len;
00485 
00486     <span class="comment">/*</span>
00487 <span class="comment">     * Make a copy of the v1 Trap PDU</span>
00488 <span class="comment">     *   before starting to convert this</span>
00489 <span class="comment">     *   into a v2 Trap PDU.</span>
00490 <span class="comment">     */</span>
00491     template_v2pdu = snmp_clone_pdu( template_v1pdu);
00492     <span class="keywordflow">if</span> (!template_v2pdu) {
00493         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00494                  <span class="stringliteral">"send_trap: failed to copy v2 template PDU\n"</span>);
00495         <span class="keywordflow">return</span> NULL;
00496     }
00497     template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = SNMP_MSG_TRAP2;
00498     first_vb = template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>;
00499 
00500     <span class="comment">/*</span>
00501 <span class="comment">     * Insert an snmpTrapOID varbind before the original v1 varbind list</span>
00502 <span class="comment">     *   either using one of the standard defined trap OIDs,</span>
00503 <span class="comment">     *   or constructing this from the PDU enterprise &amp; specific trap fields</span>
00504 <span class="comment">     */</span>
00505     <span class="keywordflow">if</span> (template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a> == SNMP_TRAP_ENTERPRISESPECIFIC) {
00506         memcpy(enterprise, template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>,
00507                            template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o21">enterprise_length</a>*<span class="keyword">sizeof</span>(oid));
00508         enterprise_len               = template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o21">enterprise_length</a>;
00509         enterprise[enterprise_len++] = 0;
00510         enterprise[enterprise_len++] = template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>;
00511     } <span class="keywordflow">else</span> {
00512         memcpy(enterprise, cold_start_oid, <span class="keyword">sizeof</span>(cold_start_oid));
00513         enterprise[9]  = template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o22">trap_type</a>+1;
00514         enterprise_len = <span class="keyword">sizeof</span>(cold_start_oid)/<span class="keyword">sizeof</span>(oid);
00515     }
00516 
00517     var = NULL;
00518     <span class="keywordflow">if</span> (!snmp_varlist_add_variable( &amp;var,
00519              snmptrap_oid, snmptrap_oid_len,
00520              ASN_OBJECT_ID,
00521              (u_char*)enterprise, enterprise_len*<span class="keyword">sizeof</span>(oid))) {
00522         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00523                  <span class="stringliteral">"send_trap: failed to insert copied snmpTrapOID varbind\n"</span>);
00524         snmp_free_pdu(template_v2pdu);
00525         <span class="keywordflow">return</span> NULL;
00526     }
00527     var-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>        = template_v2pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o17">variables</a>;
00528     template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = var;
00529 
00530     <span class="comment">/*</span>
00531 <span class="comment">     * Insert a sysUptime varbind at the head of the v2 varbind list</span>
00532 <span class="comment">     */</span>
00533     var = NULL;
00534     <span class="keywordflow">if</span> (!snmp_varlist_add_variable( &amp;var,
00535              sysuptime_oid, sysuptime_oid_len,
00536              ASN_TIMETICKS,
00537              (u_char*)&amp;(template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o8">time</a>), 
00538              <span class="keyword">sizeof</span>(template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a>))) {
00539         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00540                  <span class="stringliteral">"send_trap: failed to insert copied sysUptime varbind\n"</span>);
00541         snmp_free_pdu(template_v2pdu);
00542         <span class="keywordflow">return</span> NULL;
00543     }
00544     var-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>        = template_v2pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o17">variables</a>;
00545     template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = var;
00546 
00547     <span class="comment">/*</span>
00548 <span class="comment">     * Append the other three conversion varbinds,</span>
00549 <span class="comment">     *  (snmpTrapAgentAddr, snmpTrapCommunity &amp; snmpTrapEnterprise)</span>
00550 <span class="comment">     *  if they're not already present.</span>
00551 <span class="comment">     *  But don't bomb out completely if there are problems.</span>
00552 <span class="comment">     */</span>
00553     var = find_varbind_in_list( template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>,
00554                                 agentaddr_oid, agentaddr_oid_len);
00555     <span class="keywordflow">if</span> (!var &amp;&amp; (template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o24">agent_addr</a>[0]
00556               || template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>[1]
00557               || template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>[2]
00558               || template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>[3])) {
00559         <span class="keywordflow">if</span> (!snmp_varlist_add_variable( &amp;(template_v2pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>),
00560                  agentaddr_oid, agentaddr_oid_len,
00561                  ASN_IPADDRESS,
00562                  (u_char*)&amp;(template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>), 
00563                  <span class="keyword">sizeof</span>(template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o24">agent_addr</a>)))
00564             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00565                  <span class="stringliteral">"send_trap: failed to append snmpTrapAddr varbind\n"</span>);
00566     }
00567     var = find_varbind_in_list( template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>,
00568                                 community_oid, community_oid_len);
00569     <span class="keywordflow">if</span> (!var &amp;&amp; template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a>) {
00570         <span class="keywordflow">if</span> (!snmp_varlist_add_variable( &amp;(template_v2pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>),
00571                  community_oid, community_oid_len,
00572                  ASN_OCTET_STR,
00573                  template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a>, 
00574                  template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a>))
00575             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00576                  <span class="stringliteral">"send_trap: failed to append snmpTrapCommunity varbind\n"</span>);
00577     }
00578     var = find_varbind_in_list( template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>,
00579                                 snmptrapenterprise_oid,
00580                                 snmptrapenterprise_oid_len);
00581     <span class="keywordflow">if</span> (!var &amp;&amp; 
00582         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o22">trap_type</a> != SNMP_TRAP_ENTERPRISESPECIFIC) {
00583         <span class="keywordflow">if</span> (!snmp_varlist_add_variable( &amp;(template_v2pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>),
00584                  snmptrapenterprise_oid, snmptrapenterprise_oid_len,
00585                  ASN_OBJECT_ID,
00586                  (u_char*)template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>, 
00587                  template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a>*<span class=
"keyword">sizeof</span>(oid)))
00588             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00589                  <span class="stringliteral">"send_trap: failed to append snmpEnterprise varbind\n"</span>);
00590     }
00591     <span class="keywordflow">return</span> template_v2pdu;
00592 }
00593 
00594 <span class="keywordtype">int</span>
00595 netsnmp_send_traps(<span class="keywordtype">int</span> trap, <span class="keywordtype">int</span> specific,
00596                           oid * enterprise, <span class="keywordtype">int</span> enterprise_length,
00597                           <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * vars,
00598                           <span class="comment">/* These next two are currently unused */</span>
00599                           <span class="keywordtype">char</span> * context, <span class="keywordtype">int</span> flags)
00600 {
00601     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>           *template_v1pdu;
00602     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>           *template_v2pdu;
00603     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vblist = NULL;
00604     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *trap_vb;
00605     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *var;
00606     in_addr_t             *pdu_in_addr_t;
00607     u_long                 uptime;
00608     <span class="keyword">struct </span>trap_sink *sink;
00609 
00610     DEBUGMSGTL(( <span class="stringliteral">"trap"</span>, <span class=
"stringliteral">"send_trap %d %d "</span>, trap, specific));
00611     DEBUGMSGOID((<span class="stringliteral">"trap"</span>, enterprise, enterprise_length));
00612     DEBUGMSG(( <span class="stringliteral">"trap"</span>, <span class="stringliteral">"\n"</span>));
00613 
00614     <span class="keywordflow">if</span> (vars) {
00615         vblist = snmp_clone_varbind( vars );
00616         <span class="keywordflow">if</span> (!vblist) {
00617             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00618                      <span class="stringliteral">"send_trap: failed to clone varbind list\n"</span>);
00619             <span class="keywordflow">return</span> -1;
00620         }
00621     }
00622 
00623     <span class="keywordflow">if</span> ( trap == -1 ) {
00624         <span class="comment">/*</span>
00625 <span class="comment">         * Construct the SNMPv2-style notification PDU</span>
00626 <span class="comment">         */</span>
00627         <span class="keywordflow">if</span> (!vblist) {
00628             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00629                      <span class="stringliteral">"send_trap: called with NULL v2 information\n"</span>);
00630             <span class="keywordflow">return</span> -1;
00631         }
00632         template_v2pdu = snmp_pdu_create(SNMP_MSG_TRAP2);
00633         <span class="keywordflow">if</span> (!template_v2pdu) {
00634             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00635                      <span class="stringliteral">"send_trap: failed to construct v2 template PDU\n"</span>);
00636             <span class="keywordflow">return</span> -1;
00637         }
00638 
00639         <span class="comment">/*</span>
00640 <span class="comment">         * Check the varbind list we've been given.</span>
00641 <span class="comment">         * If it starts with a 'sysUptime.0' varbind, then use that.</span>
00642 <span class="comment">         * Otherwise, prepend a suitable 'sysUptime.0' varbind.</span>
00643 <span class="comment">         */</span>
00644         <span class="keywordflow">if</span> (!<a class="code" href=
"group__library.html#ga103">snmp_oid_compare</a>( vblist-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>,    vblist-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>,
00645                                sysuptime_oid, sysuptime_oid_len )) {
00646             template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = vblist;
00647             trap_vb  = vblist-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>;
00648         } <span class="keywordflow">else</span> {
00649             uptime   = netsnmp_get_agent_uptime();
00650             var = NULL;
00651             snmp_varlist_add_variable( &amp;var,
00652                            sysuptime_oid, sysuptime_oid_len,
00653                            ASN_TIMETICKS, (u_char*)&amp;uptime, <span class="keyword">sizeof</span>(uptime));
00654             <span class="keywordflow">if</span> (!var) {
00655                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00656                      <span class="stringliteral">"send_trap: failed to insert sysUptime varbind\n"</span>);
00657                 snmp_free_pdu(template_v2pdu);
00658                 <span class="keywordflow">return</span> -1;
00659             }
00660             template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = var;
00661             var-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>        = vblist;
00662             trap_vb  = vblist;
00663         }
00664 
00665         <span class="comment">/*</span>
00666 <span class="comment">         * 'trap_vb' should point to the snmpTrapOID.0 varbind,</span>
00667 <span class="comment">         *   identifying the requested trap.  If not then bomb out.</span>
00668 <span class="comment">         * If it's a 'standard' trap, then we need to append an</span>
00669 <span class="comment">         *   snmpEnterprise varbind (if there isn't already one).</span>
00670 <span class="comment">         */</span>
00671         <span class="keywordflow">if</span> (!trap_vb ||
00672             <a class="code" href="group__library.html#ga103">snmp_oid_compare</a>(trap_vb-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, trap_vb-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>,
00673                              snmptrap_oid,  snmptrap_oid_len)) {
00674             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00675                      <span class="stringliteral">"send_trap: no v2 trapOID varbind provided\n"</span>);
00676             snmp_free_pdu(template_v2pdu);
00677             <span class="keywordflow">return</span> -1;
00678         }
00679         <span class="keywordflow">if</span> (!<a class="code" href=
"group__library.html#ga103">snmp_oid_compare</a>(vblist-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid, OID_LENGTH(trap_prefix),
00680                               trap_prefix,       OID_LENGTH(trap_prefix))) {
00681             var = find_varbind_in_list( template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>,
00682                                         snmptrapenterprise_oid,
00683                                         snmptrapenterprise_oid_len);
00684             <span class="keywordflow">if</span> (!var &amp;&amp;
00685                 !snmp_varlist_add_variable( &amp;(template_v2pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>),
00686                      snmptrapenterprise_oid, snmptrapenterprise_oid_len,
00687                      ASN_OBJECT_ID,
00688                      (<span class="keywordtype">char</span>*)enterprise, enterprise_length*<span class=
"keyword">sizeof</span>(oid))) {
00689                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00690                      <span class="stringliteral">"send_trap: failed to add snmpEnterprise to v2 trap\n"</span>);
00691                 snmp_free_pdu(template_v2pdu);
00692                 <span class="keywordflow">return</span> -1;
00693             }
00694         }
00695             
00696 
00697         <span class="comment">/*</span>
00698 <span class="comment">         * If everything's OK, convert the v2 template into an SNMPv1 trap PDU.</span>
00699 <span class="comment">         */</span>
00700         template_v1pdu = convert_v2pdu_to_v1( template_v2pdu );
00701         <span class="keywordflow">if</span> (!template_v1pdu) {
00702             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00703                      <span class="stringliteral">"send_trap: failed to convert v2-&gt;v1 template PDU\n"</span>);
00704             snmp_free_pdu(template_v2pdu);
00705             <span class="keywordflow">return</span> -1;
00706         }
00707 
00708     } <span class="keywordflow">else</span> {
00709         <span class="comment">/*</span>
00710 <span class="comment">         * Construct the SNMPv1 trap PDU....</span>
00711 <span class="comment">         */</span>
00712         template_v1pdu = snmp_pdu_create(SNMP_MSG_TRAP);
00713         <span class="keywordflow">if</span> (!template_v1pdu) {
00714             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00715                      <span class="stringliteral">"send_trap: failed to construct v1 template PDU\n"</span>);
00716             <span class="keywordflow">return</span> -1;
00717         }
00718         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o22">trap_type</a>     = trap;
00719         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o23">specific_type</a> = specific;
00720         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o8">time</a>          = netsnmp_get_agent_uptime();
00721 
00722         <span class="keywordflow">if</span> (snmp_clone_mem((<span class=
"keywordtype">void</span> **) &amp;template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>,
00723                        enterprise, enterprise_length * <span class="keyword">sizeof</span>(oid))) {
00724             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00725                      <span class="stringliteral">"send_trap: failed to set v1 enterprise OID\n"</span>);
00726             snmp_free_pdu(template_v1pdu);
00727             <span class="keywordflow">return</span> -1;
00728         }
00729         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> = enterprise_length;
00730 
00731         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a>    |= UCD_MSG_FLAG_FORCE_PDU_COPY;
00732         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = vblist;
00733 
00734         <span class="comment">/*</span>
00735 <span class="comment">         * ... and convert it into an SNMPv2-style notification PDU.</span>
00736 <span class="comment">         */</span>
00737 
00738         template_v2pdu = convert_v1pdu_to_v2( template_v1pdu );
00739         <span class="keywordflow">if</span> (!template_v2pdu) {
00740             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00741                      <span class="stringliteral">"send_trap: failed to convert v1-&gt;v2 template PDU\n"</span>);
00742             snmp_free_pdu(template_v1pdu);
00743             <span class="keywordflow">return</span> -1;
00744         }
00745     }
00746 
00747     <span class="comment">/*</span>
00748 <span class="comment">     * Check whether we're ignoring authFail traps</span>
00749 <span class="comment">     */</span>
00750     <span class="keywordflow">if</span> (template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a> == SNMP_TRAP_AUTHFAIL &amp;&amp;
00751         snmp_enableauthentraps == SNMP_AUTHENTICATED_TRAPS_DISABLED) {
00752         snmp_free_pdu(template_v1pdu);
00753         snmp_free_pdu(template_v2pdu);
00754         <span class="keywordflow">return</span> 0;
00755     }
00756 
00757     <span class="comment">/*</span>
00758 <span class="comment">     * Ensure that the v1 trap PDU includes the local IP address</span>
00759 <span class="comment">     */</span>
00760      pdu_in_addr_t = (in_addr_t *) template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>;
00761     *pdu_in_addr_t = get_myaddr();
00762 
00763 
00764     <span class="comment">/*</span>
00765 <span class="comment">     *  Now loop through the list of trap sinks</span>
00766 <span class="comment">     *   and call the trap callback routines,</span>
00767 <span class="comment">     *   providing an appropriately formatted PDU in each case</span>
00768 <span class="comment">     */</span>
00769     <span class="keywordflow">for</span> (sink = sinks; sink; sink = sink-&gt;next) {
00770 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
00771         <span class="keywordflow">if</span> (sink-&gt;version == SNMP_VERSION_1) {
00772             send_trap_to_sess(sink-&gt;sesp, template_v1pdu);
00773         } <span class="keywordflow">else</span> {
00774 <span class="preprocessor">#endif</span>
00775             template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = sink-&gt;pdutype;
00776             send_trap_to_sess(sink-&gt;sesp, template_v2pdu);
00777 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
00778         }
00779 <span class="preprocessor">#endif</span>
00780     }
00781     <a class="code" href="group__callback.html#ga10">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
00782                         SNMPD_CALLBACK_SEND_TRAP1, template_v1pdu);
00783     <a class="code" href="group__callback.html#ga10">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
00784                         SNMPD_CALLBACK_SEND_TRAP2, template_v2pdu);
00785     snmp_free_pdu(template_v1pdu);
00786     snmp_free_pdu(template_v2pdu);
00787     <span class="keywordflow">return</span> 0;
00788 }
00789 
00790 
00791 <span class="keywordtype">void</span>
00792 send_enterprise_trap_vars(<span class="keywordtype">int</span> trap,
00793                           <span class="keywordtype">int</span> specific,
00794                           oid * enterprise, <span class="keywordtype">int</span> enterprise_length,
00795                           <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * vars)
00796 {
00797     netsnmp_send_traps(trap, specific,
00798                        enterprise, enterprise_length,
00799                        vars, NULL, 0);
00800     <span class="keywordflow">return</span>;
00801 }
00802 
00808 <span class="keywordtype">int</span>
<a name="l00809" id="l00809"></a><a class="code" href="group__agent__trap.html#ga40">00809</a> <a class="code" href=
"group__agent__trap.html#ga40">handle_inform_response</a>(<span class="keywordtype">int</span> op, <a class="code" href=
"structsnmp__session.html">netsnmp_session</a> * session,
00810                        <span class="keywordtype">int</span> reqid, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *pdu,
00811                        <span class="keywordtype">void</span> *magic)
00812 {
00813     <span class="comment">/* XXX: possibly stats update */</span>
00814     <span class="keywordflow">switch</span> (op) {
00815 
00816     <span class="keywordflow">case</span> NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE:
00817         snmp_increment_statistic(STAT_SNMPINPKTS);
00818         DEBUGMSGTL((<span class="stringliteral">"trap"</span>, <span class=
"stringliteral">"received the inform response for reqid=%d\n"</span>,
00819                     reqid));
00820         <span class="keywordflow">break</span>;
00821 
00822     <span class="keywordflow">case</span> NETSNMP_CALLBACK_OP_TIMED_OUT:
00823         DEBUGMSGTL((<span class="stringliteral">"trap"</span>,
00824                     <span class="stringliteral">"received a timeout sending an inform for reqid=%d\n"</span>,
00825                     reqid));
00826         <span class="keywordflow">break</span>;
00827 
00828     <span class="keywordflow">case</span> NETSNMP_CALLBACK_OP_SEND_FAILED:
00829         DEBUGMSGTL((<span class="stringliteral">"trap"</span>,
00830                     <span class="stringliteral">"failed to send an inform for reqid=%d\n"</span>,
00831                     reqid));
00832         <span class="keywordflow">break</span>;
00833 
00834     <span class="keywordflow">default</span>:
00835         DEBUGMSGTL((<span class="stringliteral">"trap"</span>, <span class=
"stringliteral">"received op=%d for reqid=%d when trying to send an inform\n"</span>, op, reqid));
00836     }
00837 
00838     <span class="keywordflow">return</span> 1;
00839 }
00840 
00841 
00842 <span class="comment">/*</span>
00843 <span class="comment"> * send_trap_to_sess: sends a trap to a session but assumes that the</span>
00844 <span class="comment"> * pdu is constructed correctly for the session type. </span>
00845 <span class="comment"> */</span>
00846 <span class="keywordtype">void</span>
00847 send_trap_to_sess(<a class="code" href="structsnmp__session.html">netsnmp_session</a> * sess, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *template_pdu)
00848 {
00849     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>    *pdu;
00850     <span class="keywordtype">int</span>            result;
00851 
00852     <span class="keywordflow">if</span> (!sess || !template_pdu)
00853         <span class="keywordflow">return</span>;
00854 
00855     DEBUGMSGTL((<span class="stringliteral">"trap"</span>, <span class=
"stringliteral">"sending trap type=%d, version=%d\n"</span>,
00856                 template_pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>, sess-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a>));
00857 
00858 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
00859     <span class="keywordflow">if</span> (sess-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a> == SNMP_VERSION_1 &amp;&amp;
00860         (template_pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> != SNMP_MSG_TRAP))
00861         <span class="keywordflow">return</span>;                 <span class=
"comment">/* Skip v1 sinks for v2 only traps */</span>
00862 <span class="preprocessor">#endif</span>
00863     template_pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a> = sess-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a>;
00864     pdu = snmp_clone_pdu(template_pdu);
00865     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o5">sessid</a> = sess-&gt;<a class="code" href=
"structsnmp__session.html#o15">sessid</a>; <span class="comment">/* AgentX only ? */</span>
00866 
00867     <span class="keywordflow">if</span> ( template_pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a> == SNMP_MSG_INFORM
00868 <span class="preprocessor">#ifdef USING_AGENTX_PROTOCOL_MODULE</span>
00869          || template_pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> == AGENTX_MSG_NOTIFY
00870 <span class="preprocessor">#endif</span>
00871        ) {
00872         result =
00873             snmp_async_send(sess, pdu, &amp;handle_inform_response, NULL);
00874         
00875     } <span class="keywordflow">else</span> {
00876         result = snmp_send(sess, pdu);
00877     }
00878 
00879     <span class="keywordflow">if</span> (result == 0) {
00880         snmp_sess_perror(<span class="stringliteral">"snmpd: send_trap"</span>, sess);
00881         <span class="comment">/* snmp_free_pdu(pdu); */</span>
00882     } <span class="keywordflow">else</span> {
00883         snmp_increment_statistic(STAT_SNMPOUTTRAPS);
00884         snmp_increment_statistic(STAT_SNMPOUTPKTS);
00885     }
00886 }
00887 
00888 <span class="keywordtype">void</span>
00889 send_trap_vars(<span class="keywordtype">int</span> trap, <span class="keywordtype">int</span> specific, <a class="code"
href="structvariable__list.html">netsnmp_variable_list</a> * vars)
00890 {
00891     <span class="keywordflow">if</span> (trap == SNMP_TRAP_ENTERPRISESPECIFIC)
00892         send_enterprise_trap_vars(trap, specific, objid_enterprisetrap,
00893                                   OID_LENGTH(objid_enterprisetrap), vars);
00894     <span class="keywordflow">else</span>
00895         send_enterprise_trap_vars(trap, specific, trap_version_id,
00896                                   OID_LENGTH(trap_version_id), vars);
00897 }
00898 
00922 <span class="keywordtype">void</span>
<a name="l00923" id="l00923"></a><a class="code" href="group__agent__trap.html#ga43">00923</a> <a class="code" href=
"group__agent__trap.html#ga43">send_easy_trap</a>(<span class="keywordtype">int</span> trap, <span class=
"keywordtype">int</span> specific)
00924 {
00925     send_trap_vars(trap, specific, NULL);
00926 }
00927 
00951 <span class="keywordtype">void</span>
<a name="l00952" id="l00952"></a><a class="code" href="group__agent__trap.html#ga44">00952</a> <a class="code" href=
"group__agent__trap.html#ga44">send_v2trap</a>(<a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * vars)
00953 {
00954     send_trap_vars(-1, -1, vars);
00955 }
00956 
00957 <span class="keywordtype">void</span>
00958 send_trap_pdu(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
00959 {
00960     send_trap_vars(-1, -1, pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>);
00961 }
00962 
00963 
00964 
00965         <span class="comment">/*******************</span>
00966 <span class="comment">         *</span>
00967 <span class="comment">         * Config file handling</span>
00968 <span class="comment">         *</span>
00969 <span class="comment">         *******************/</span>
00970 
00971 <span class="keywordtype">void</span>
00972 snmpd_parse_config_authtrap(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *cptr)
00973 {
00974     <span class="keywordtype">int</span>             i;
00975 
00976     i = atoi(cptr);
00977     <span class="keywordflow">if</span> (i == 0) {
00978         <span class="keywordflow">if</span> (strcmp(cptr, <span class="stringliteral">"enable"</span>) == 0) {
00979             i = SNMP_AUTHENTICATED_TRAPS_ENABLED;
00980         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(cptr, <span class=
"stringliteral">"disable"</span>) == 0) {
00981             i = SNMP_AUTHENTICATED_TRAPS_DISABLED;
00982         }
00983     }
00984     <span class="keywordflow">if</span> (i &lt; 1 || i &gt; 2) {
00985         config_perror(<span class="stringliteral">"authtrapenable must be 1 or 2"</span>);
00986     } <span class="keywordflow">else</span> {
00987         <span class="keywordflow">if</span> (strcmp(token, <span class="stringliteral">"pauthtrapenable"</span>) == 0) {
00988             <span class="keywordflow">if</span> (snmp_enableauthentrapsset &lt; 0) {
00989                 <span class="comment">/*</span>
00990 <span class="comment">                 * This is bogus (and shouldn't happen anyway) -- the value</span>
00991 <span class="comment">                 * of snmpEnableAuthenTraps.0 is already configured</span>
00992 <span class="comment">                 * read-only.  </span>
00993 <span class="comment">                 */</span>
00994                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
00995                          <span class=
"stringliteral">"ignoring attempted override of read-only snmpEnableAuthenTraps.0\n"</span>);
00996                 <span class="keywordflow">return</span>;
00997             } <span class="keywordflow">else</span> {
00998                 snmp_enableauthentrapsset++;
00999             }
01000         } <span class="keywordflow">else</span> {
01001             <span class="keywordflow">if</span> (snmp_enableauthentrapsset &gt; 0) {
01002                 <span class="comment">/*</span>
01003 <span class="comment">                 * This is bogus (and shouldn't happen anyway) -- we already</span>
01004 <span class="comment">                 * read a persistent value of snmpEnableAuthenTraps.0, which</span>
01005 <span class="comment">                 * we should ignore in favour of this one.  </span>
01006 <span class="comment">                 */</span>
01007                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
01008                          <span class=
"stringliteral">"ignoring attempted override of read-only snmpEnableAuthenTraps.0\n"</span>);
01009                 <span class="comment">/*</span>
01010 <span class="comment">                 * Fall through and copy in this value.  </span>
01011 <span class="comment">                 */</span>
01012             }
01013             snmp_enableauthentrapsset = -1;
01014         }
01015         snmp_enableauthentraps = i;
01016     }
01017 }
01018 
01019 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
01020 <span class="keywordtype">void</span>
01021 snmpd_parse_config_trapsink(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *cptr)
01022 {
01023     <span class="keywordtype">char</span>            tmpbuf[1024];
01024     <span class="keywordtype">char</span>           *sp, *cp, *pp = NULL;
01025     <span class="keywordtype">int</span>             sinkport;
01026     <span class="keywordtype">char</span>            *st;
01027 
01028     <span class="keywordflow">if</span> (!snmp_trapcommunity)
01029         snmp_trapcommunity = strdup(<span class="stringliteral">"public"</span>);
01030     sp = strtok_r(cptr, <span class="stringliteral">" \t\n"</span>, &amp;st);
01031     cp = strtok_r(NULL, <span class="stringliteral">" \t\n"</span>, &amp;st);
01032     <span class="keywordflow">if</span> (cp)
01033         pp = strtok_r(NULL, <span class="stringliteral">" \t\n"</span>, &amp;st);
01034     <span class="keywordflow">if</span> (cp &amp;&amp; pp) {
01035         sinkport = atoi(pp);
01036         <span class="keywordflow">if</span> ((sinkport &lt; 1) || (sinkport &gt; 0xffff)) {
01037             config_perror(<span class="stringliteral">"trapsink port out of range"</span>);
01038             sinkport = SNMP_TRAP_PORT;
01039         }
01040     } <span class="keywordflow">else</span> {
01041         sinkport = SNMP_TRAP_PORT;
01042     }
01043     <span class="keywordflow">if</span> (create_v1_trap_session(sp, (u_short)sinkport,
01044                                cp ? cp : snmp_trapcommunity) == 0) {
01045         snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf), <span class=
"stringliteral">"cannot create trapsink: %s"</span>, cptr);
01046         tmpbuf[<span class="keyword">sizeof</span>(tmpbuf)-1] = <span class="charliteral">'\0'</span>;
01047         config_perror(tmpbuf);
01048     }
01049 }
01050 <span class="preprocessor">#endif</span>
01051 
01052 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
01053 <span class="keywordtype">void</span>
01054 snmpd_parse_config_trap2sink(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
01055 {
01056     <span class="keywordtype">char</span>            tmpbuf[1024];
01057     <span class="keywordtype">char</span>           *sp, *cp, *pp = NULL;
01058     <span class="keywordtype">int</span>             sinkport;
01059     <span class="keywordtype">char</span>            *st;
01060 
01061     <span class="keywordflow">if</span> (!snmp_trapcommunity)
01062         snmp_trapcommunity = strdup(<span class="stringliteral">"public"</span>);
01063     sp = strtok_r(cptr, <span class="stringliteral">" \t\n"</span>, &amp;st);
01064     cp = strtok_r(NULL, <span class="stringliteral">" \t\n"</span>, &amp;st);
01065     <span class="keywordflow">if</span> (cp)
01066         pp = strtok_r(NULL, <span class="stringliteral">" \t\n"</span>, &amp;st);
01067     <span class="keywordflow">if</span> (cp &amp;&amp; pp) {
01068         sinkport = atoi(pp);
01069         <span class="keywordflow">if</span> ((sinkport &lt; 1) || (sinkport &gt; 0xffff)) {
01070             config_perror(<span class="stringliteral">"trapsink port out of range"</span>);
01071             sinkport = SNMP_TRAP_PORT;
01072         }
01073     } <span class="keywordflow">else</span> {
01074         sinkport = SNMP_TRAP_PORT;
01075     }
01076     <span class="keywordflow">if</span> (create_v2_trap_session(sp, (u_short)sinkport,
01077                                cp ? cp : snmp_trapcommunity) == 0) {
01078         snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf), <span class=
"stringliteral">"cannot create trap2sink: %s"</span>, cptr);
01079         tmpbuf[<span class="keyword">sizeof</span>(tmpbuf)-1] = <span class="charliteral">'\0'</span>;
01080         config_perror(tmpbuf);
01081     }
01082 }
01083 
01084 <span class="keywordtype">void</span>
01085 snmpd_parse_config_informsink(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
01086 {
01087     <span class="keywordtype">char</span>            tmpbuf[1024];
01088     <span class="keywordtype">char</span>           *sp, *cp, *pp = NULL;
01089     <span class="keywordtype">int</span>             sinkport;
01090     <span class="keywordtype">char</span>            *st;
01091 
01092     <span class="keywordflow">if</span> (!snmp_trapcommunity)
01093         snmp_trapcommunity = strdup(<span class="stringliteral">"public"</span>);
01094     sp = strtok_r(cptr, <span class="stringliteral">" \t\n"</span>, &amp;st);
01095     cp = strtok_r(NULL, <span class="stringliteral">" \t\n"</span>, &amp;st);
01096     <span class="keywordflow">if</span> (cp)
01097         pp = strtok_r(NULL, <span class="stringliteral">" \t\n"</span>, &amp;st);
01098     <span class="keywordflow">if</span> (cp &amp;&amp; pp) {
01099         sinkport = atoi(pp);
01100         <span class="keywordflow">if</span> ((sinkport &lt; 1) || (sinkport &gt; 0xffff)) {
01101             config_perror(<span class="stringliteral">"trapsink port out of range"</span>);
01102             sinkport = SNMP_TRAP_PORT;
01103         }
01104     } <span class="keywordflow">else</span> {
01105         sinkport = SNMP_TRAP_PORT;
01106     }
01107     <span class="keywordflow">if</span> (create_v2_inform_session(sp, (u_short)sinkport,
01108                                  cp ? cp : snmp_trapcommunity) == 0) {
01109         snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf), <span class=
"stringliteral">"cannot create informsink: %s"</span>, cptr);
01110         tmpbuf[<span class="keyword">sizeof</span>(tmpbuf)-1] = <span class="charliteral">'\0'</span>;
01111         config_perror(tmpbuf);
01112     }
01113 }
01114 <span class="preprocessor">#endif</span>
01115 
01116 <span class="comment">/*</span>
01117 <span class="comment"> * this must be standardized somewhere, right? </span>
01118 <span class="comment"> */</span>
01119 <span class="preprocessor">#define MAX_ARGS 128</span>
01120 
01121 <span class="keyword">static</span> <span class="keywordtype">int</span>      traptype;
01122 
01123 <span class="keyword">static</span> <span class="keywordtype">void</span>
01124 trapOptProc(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *<span class=
"keyword">const</span> *argv, <span class="keywordtype">int</span> opt)
01125 {
01126     <span class="keywordflow">switch</span> (opt) {
01127     <span class="keywordflow">case</span> <span class="charliteral">'C'</span>:
01128         <span class="keywordflow">while</span> (*optarg) {
01129             <span class="keywordflow">switch</span> (*optarg++) {
01130             <span class="keywordflow">case</span> <span class="charliteral">'i'</span>:
01131                 traptype = SNMP_MSG_INFORM;
01132                 <span class="keywordflow">break</span>;
01133             <span class="keywordflow">default</span>:
01134                 config_perror(<span class="stringliteral">"unknown argument passed to -C"</span>);
01135                 <span class="keywordflow">break</span>;
01136             }
01137         }
01138         <span class="keywordflow">break</span>;
01139     }
01140 }
01141 
01142 
01143 <span class="keywordtype">void</span>
01144 snmpd_parse_config_trapsess(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
01145 {
01146     <span class="keywordtype">char</span>           *argv[MAX_ARGS], *cp = cptr, tmp[SPRINT_MAX_LEN];
01147     <span class="keywordtype">int</span>             argn, arg;
01148     <a class="code" href="structsnmp__session.html">netsnmp_session</a> session, *ss;
01149 
01150     <span class="comment">/*</span>
01151 <span class="comment">     * inform or trap?  default to trap </span>
01152 <span class="comment">     */</span>
01153     traptype = SNMP_MSG_TRAP2;
01154 
01155     <span class="comment">/*</span>
01156 <span class="comment">     * create the argv[] like array </span>
01157 <span class="comment">     */</span>
01158     argv[0] = strdup(<span class="stringliteral">"snmpd-trapsess"</span>); <span class=
"comment">/* bogus entry for getopt() */</span>
01159     <span class="keywordflow">for</span> (argn = 1; cp &amp;&amp; argn &lt; MAX_ARGS; argn++) {
01160         cp = copy_nword(cp, tmp, SPRINT_MAX_LEN);
01161         argv[argn] = strdup(tmp);
01162     }
01163 
01164     arg = snmp_parse_args(argn, argv, &amp;session, <span class="stringliteral">"C:"</span>, trapOptProc);
01165     ss = snmp_open(&amp;session);
01166 
01167     <span class="keywordflow">for</span> (; argn &gt; 0; argn--) {
01168         free(argv[argn - 1]);
01169     }
01170 
01171     <span class="keywordflow">if</span> (!ss) {
01172         config_perror
01173             (<span class=
"stringliteral">"snmpd: failed to parse this line or the remote trap receiver is down.  Possible cause:"</span>);
01174         snmp_sess_perror(<span class="stringliteral">"snmpd: snmpd_parse_config_trapsess()"</span>, &amp;session);
01175         <span class="keywordflow">return</span>;
01176     }
01177 
01178 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
01179     <span class="keywordflow">if</span> (ss-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a> == SNMP_VERSION_1) {
01180         add_trap_session(ss, SNMP_MSG_TRAP, 0, SNMP_VERSION_1);
01181     } <span class="keywordflow">else</span> {
01182 <span class="preprocessor">#endif</span>
01183         add_trap_session(ss, traptype, (traptype == SNMP_MSG_INFORM),
01184                          ss-&gt;<a class="code" href="structsnmp__session.html#o0">version</a>);
01185 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
01186     }
01187 <span class="preprocessor">#endif</span>
01188 }
01189 
01190 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
01191 <span class="keywordtype">void</span>
01192 snmpd_parse_config_trapcommunity(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *word, <span class="keywordtype">char</span> *cptr)
01193 {
01194     <span class="keywordflow">if</span> (snmp_trapcommunity != NULL) {
01195         free(snmp_trapcommunity);
01196     }
01197     snmp_trapcommunity = (<span class="keywordtype">char</span> *) malloc(strlen(cptr) + 1);
01198     <span class="keywordflow">if</span> (snmp_trapcommunity != NULL) {
01199         copy_nword(cptr, snmp_trapcommunity, strlen(cptr) + 1);
01200     }
01201 }
01202 
01203 <span class="keywordtype">void</span>
01204 snmpd_free_trapcommunity(<span class="keywordtype">void</span>)
01205 {
01206     <span class="keywordflow">if</span> (snmp_trapcommunity) {
01207         free(snmp_trapcommunity);
01208         snmp_trapcommunity = NULL;
01209     }
01210 }
01211 <span class="preprocessor">#endif</span>
01212 
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small>Generated on Fri Dec 30 13:47:44 2005 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

