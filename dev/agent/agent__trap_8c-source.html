<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000003.html">agent</a>
  </div>

  <h1>agent_trap.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * agent_trap.c</span>
00003 <span class="comment"> */</span>
00004 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
00005 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00006 <span class="comment"> * that may apply:</span>
00007 <span class="comment"> */</span>
00008 <span class="comment">/*</span>
00009 <span class="comment"> * Portions of this file are copyrighted by:</span>
00010 <span class="comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
00011 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00012 <span class="comment"> * distributed with the Net-SNMP package.</span>
00013 <span class="comment"> */</span>
00020 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00021 
00022 <span class="preprocessor">#if HAVE_UNISTD_H</span>
00023 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00024 <span class="preprocessor">#endif</span>
00025 <span class="preprocessor">#if HAVE_NETDB_H</span>
00026 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00027 <span class="preprocessor">#endif</span>
00028 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00029 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00030 <span class="preprocessor">#endif</span>
00031 <span class="preprocessor">#if HAVE_STRING_H</span>
00032 <span class="preprocessor">#include &lt;string.h&gt;</span>
00033 <span class="preprocessor">#else</span>
00034 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00035 <span class="preprocessor">#endif</span>
00036 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00037 <span class="preprocessor"># ifdef WIN32</span>
00038 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00039 <span class="preprocessor"># else</span>
00040 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00041 <span class="preprocessor"># endif</span>
00042 <span class="preprocessor"># include &lt;time.h&gt;</span>
00043 <span class="preprocessor">#else</span>
00044 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00045 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00046 <span class="preprocessor"># else</span>
00047 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00048 <span class="preprocessor"># endif</span>
00049 <span class="preprocessor">#endif</span>
00050 <span class="preprocessor">#if HAVE_SYS_SOCKET_H</span>
00051 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00052 <span class="preprocessor">#elif HAVE_WINSOCK_H</span>
00053 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00054 <span class="preprocessor">#endif</span>
00055 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00056 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00057 <span class="preprocessor">#endif</span>
00058 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00059 
00060 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00061 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00062 <span class="preprocessor">#endif</span>
00063 
00064 <span class="preprocessor">#include &lt;net-snmp/net-snmp-includes.h&gt;</span>
00065 <span class="preprocessor">#include &lt;net-snmp/agent/agent_trap.h&gt;</span>
00066 <span class="preprocessor">#include &lt;net-snmp/agent/snmp_agent.h&gt;</span>
00067 <span class="preprocessor">#include &lt;net-snmp/agent/agent_callbacks.h&gt;</span>
00068 
00069 <span class="preprocessor">#include &lt;net-snmp/agent/mib_module_config.h&gt;</span>
00070 
00071 <span class="preprocessor">#ifdef USING_AGENTX_PROTOCOL_MODULE</span>
00072 <span class="preprocessor">#include "agentx/protocol.h"</span>
00073 <span class="preprocessor">#endif</span>
00074 
00075 <span class="keyword">struct </span>trap_sink {
00076     <a class="code" href="structsnmp__session.html">netsnmp_session</a> *sesp;
00077     <span class="keyword">struct </span>trap_sink *next;
00078     <span class="keywordtype">int</span>             pdutype;
00079     <span class="keywordtype">int</span>             version;
00080 };
00081 
00082 <span class="keyword">struct </span>trap_sink *sinks = NULL;
00083 
00084 <span class="keyword">extern</span> <span class="keyword">struct </span>timeval starttime;
00085 
00086 oid             objid_enterprisetrap[] = { NOTIFICATION_MIB };
00087 oid             trap_version_id[] = { SYSTEM_MIB };
00088 <span class="keywordtype">int</span>             enterprisetrap_len;
00089 <span class="keywordtype">int</span>             trap_version_id_len;
00090 
00091 <span class="preprocessor">#define SNMPV2_TRAPS_PREFIX     SNMP_OID_SNMPMODULES,1,1,5</span>
00092 oid             trap_prefix[]    = { SNMPV2_TRAPS_PREFIX };
00093 oid             cold_start_oid[] = { SNMPV2_TRAPS_PREFIX, 1 };  <span class="comment">/* SNMPv2-MIB */</span>
00094 oid             warm_start_oid[] = { SNMPV2_TRAPS_PREFIX, 2 };  <span class="comment">/* SNMPv2-MIB */</span>
00095 oid             link_down_oid[]  = { SNMPV2_TRAPS_PREFIX, 3 };  <span class="comment">/* IF-MIB */</span>
00096 oid             link_up_oid[]    = { SNMPV2_TRAPS_PREFIX, 4 };  <span class="comment">/* IF-MIB */</span>
00097 oid             auth_fail_oid[]  = { SNMPV2_TRAPS_PREFIX, 5 };  <span class="comment">/* SNMPv2-MIB */</span>
00098 oid             egp_xxx_oid[]    = { SNMPV2_TRAPS_PREFIX, 99 }; <span class="comment">/* ??? */</span>
00099 
00100 <span class="preprocessor">#define SNMPV2_TRAP_OBJS_PREFIX SNMP_OID_SNMPMODULES,1,1,4</span>
00101 oid             snmptrap_oid[] = { SNMPV2_TRAP_OBJS_PREFIX, 1, 0 };
00102 oid             snmptrapenterprise_oid[] =
00103     { SNMPV2_TRAP_OBJS_PREFIX, 3, 0 };
00104 oid             sysuptime_oid[] = { SNMP_OID_MIB2, 1, 3, 0 };
00105 size_t          snmptrap_oid_len;
00106 size_t          snmptrapenterprise_oid_len;
00107 size_t          sysuptime_oid_len;
00108 
00109 <span class="preprocessor">#define SNMPV2_COMM_OBJS_PREFIX SNMP_OID_SNMPMODULES,18,1</span>
00110 oid             agentaddr_oid[] = { SNMPV2_COMM_OBJS_PREFIX, 3, 0 };
00111 size_t          agentaddr_oid_len;
00112 oid             community_oid[] = { SNMPV2_COMM_OBJS_PREFIX, 4, 0 };
00113 size_t          community_oid_len;
00114 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
00115 <span class="keywordtype">char</span>           *snmp_trapcommunity = NULL;
00116 <span class="preprocessor">#endif</span>
00117 
00118 
00119 <span class="preprocessor">#define SNMP_AUTHENTICATED_TRAPS_ENABLED        1</span>
00120 <span class="preprocessor">#define SNMP_AUTHENTICATED_TRAPS_DISABLED       2</span>
00121 
00122 <span class="keywordtype">int</span>             snmp_enableauthentraps = SNMP_AUTHENTICATED_TRAPS_DISABLED;
00123 <span class="keywordtype">int</span>             snmp_enableauthentrapsset = 0;
00124 
00125 <span class="comment">/*</span>
00126 <span class="comment"> * Prototypes </span>
00127 <span class="comment"> */</span>
00128  <span class="comment">/*</span>
00129 <span class="comment">  * static int create_v1_trap_session (const char *, u_short, const char *);</span>
00130 <span class="comment">  * static int create_v2_trap_session (const char *, u_short, const char *);</span>
00131 <span class="comment">  * static int create_v2_inform_session (const char *, u_short, const char *);</span>
00132 <span class="comment">  * static void free_trap_session (struct trap_sink *sp);</span>
00133 <span class="comment">  * static void send_v1_trap (netsnmp_session *, int, int);</span>
00134 <span class="comment">  * static void send_v2_trap (netsnmp_session *, int, int, int);</span>
00135 <span class="comment">  */</span>
00136 
00137 
00138         <span class="comment">/*******************</span>
00139 <span class="comment">         *</span>
00140 <span class="comment">         * Trap session handling</span>
00141 <span class="comment">         *</span>
00142 <span class="comment">         *******************/</span>
00143 
00144 <span class="keywordtype">void</span>
00145 init_traps(<span class="keywordtype">void</span>)
00146 {
00147     enterprisetrap_len  = OID_LENGTH(objid_enterprisetrap);
00148     trap_version_id_len = OID_LENGTH(trap_version_id);
00149     snmptrap_oid_len    = OID_LENGTH(snmptrap_oid);
00150     snmptrapenterprise_oid_len = OID_LENGTH(snmptrapenterprise_oid);
00151     sysuptime_oid_len   = OID_LENGTH(sysuptime_oid);
00152     agentaddr_oid_len   = OID_LENGTH(agentaddr_oid);
00153     community_oid_len   = OID_LENGTH(community_oid);
00154 }
00155 
00156 <span class="keyword">static</span> <span class="keywordtype">void</span>
00157 free_trap_session(<span class="keyword">struct</span> trap_sink *sp)
00158 {
00159     snmp_close(sp-&gt;sesp);
00160     free(sp);
00161 }
00162 
00163 <span class="keywordtype">int</span>
00164 add_trap_session(<a class="code" href="structsnmp__session.html">netsnmp_session</a> * ss, <span class=
"keywordtype">int</span> pdutype, <span class="keywordtype">int</span> confirm,
00165                  <span class="keywordtype">int</span> version)
00166 {
00167     <span class="keywordflow">if</span> (snmp_callback_available(SNMP_CALLBACK_APPLICATION,
00168                                 SNMPD_CALLBACK_REGISTER_NOTIFICATIONS) ==
00169         SNMPERR_SUCCESS) {
00170         <span class="comment">/*</span>
00171 <span class="comment">         * something else wants to handle notification registrations </span>
00172 <span class="comment">         */</span>
00173         <span class="keyword">struct </span>agent_add_trap_args args;
00174         DEBUGMSGTL((<span class="stringliteral">"trap"</span>, <span class=
"stringliteral">"adding callback trap sink\n"</span>));
00175         args.ss = ss;
00176         args.confirm = confirm;
00177         <a class="code" href="group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
00178                             SNMPD_CALLBACK_REGISTER_NOTIFICATIONS,
00179                             (<span class="keywordtype">void</span> *) &amp;args);
00180     } <span class="keywordflow">else</span> {
00181         <span class="comment">/*</span>
00182 <span class="comment">         * no other support exists, handle it ourselves. </span>
00183 <span class="comment">         */</span>
00184         <span class="keyword">struct </span>trap_sink *new_sink;
00185 
00186         DEBUGMSGTL((<span class="stringliteral">"trap"</span>, <span class=
"stringliteral">"adding internal trap sink\n"</span>));
00187         new_sink = (<span class="keyword">struct </span>trap_sink *) malloc(<span class=
"keyword">sizeof</span>(*new_sink));
00188         <span class="keywordflow">if</span> (new_sink == NULL)
00189             <span class="keywordflow">return</span> 0;
00190 
00191         new_sink-&gt;sesp = ss;
00192         new_sink-&gt;pdutype = pdutype;
00193         new_sink-&gt;<a class="code" href="structsnmp__session.html#o0">version</a> = version;
00194         new_sink-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = sinks;
00195         sinks = new_sink;
00196     }
00197     <span class="keywordflow">return</span> 1;
00198 }
00199 
00200 <span class="keywordtype">int</span>
00201 remove_trap_session(<a class="code" href="structsnmp__session.html">netsnmp_session</a> * ss)
00202 {
00203     <span class="keyword">struct </span>trap_sink *sp = sinks, *prev = 0;
00204 
00205     <span class="keywordflow">while</span> (sp) {
00206         <span class="keywordflow">if</span> (sp-&gt;sesp == ss) {
00207             <span class="keywordflow">if</span> (prev) {
00208                 prev-&gt;<a class="code" href="structsnmp__session.html#o5">next</a> = sp-&gt;<a class="code" href=
"structsnmp__session.html#o5">next</a>;
00209             } <span class="keywordflow">else</span> {
00210                 sinks = sp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
00211             }
00212             <span class="comment">/*</span>
00213 <span class="comment">             * I don't believe you *really* want to close the session here;</span>
00214 <span class="comment">             * it may still be in use for other purposes.  In particular this</span>
00215 <span class="comment">             * is awkward for AgentX, since we want to call this function</span>
00216 <span class="comment">             * from the session's callback.  Let's just free the trapsink</span>
00217 <span class="comment">             * data structure.  [jbpn]  </span>
00218 <span class="comment">             */</span>
00219             <span class="comment">/*</span>
00220 <span class="comment">             * free_trap_session(sp);  </span>
00221 <span class="comment">             */</span>
00222             free(sp);
00223             <span class="keywordflow">return</span> 1;
00224         }
00225         prev = sp;
00226         sp = sp-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
00227     }
00228     <span class="keywordflow">return</span> 0;
00229 }
00230 
00231 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
00232 <span class="keywordtype">int</span>
00233 create_trap_session(<span class="keywordtype">char</span> *sink, u_short sinkport,
00234                     <span class="keywordtype">char</span> *com, <span class="keywordtype">int</span> version, <span class=
"keywordtype">int</span> pdutype)
00235 {
00236     <a class="code" href="structsnmp__session.html">netsnmp_session</a> session, *sesp;
00237     <span class="keywordtype">char</span>           *peername = NULL;
00238 
00239     <span class="keywordflow">if</span> ((peername = malloc(strlen(sink) + 4 + 32)) == NULL) {
00240         <span class="keywordflow">return</span> 0;
00241     } <span class="keywordflow">else</span> {
00242         snprintf(peername, strlen(sink) + 4 + 32, <span class="stringliteral">"udp:%s:%hu"</span>, sink,
00243                  sinkport);
00244     }
00245 
00246     memset(&amp;session, 0, <span class="keyword">sizeof</span>(<a class="code" href=
"structsnmp__session.html">netsnmp_session</a>));
00247     session.<a class="code" href="structsnmp__session.html#o6">peername</a> = peername;
00248     session.<a class="code" href="structsnmp__session.html#o0">version</a> = version;
00249     <span class="keywordflow">if</span> (com) {
00250         session.<a class="code" href="structsnmp__session.html#o16">community</a> = (u_char *) com;
00251         session.<a class="code" href="structsnmp__session.html#o17">community_len</a> = strlen(com);
00252     }
00253     <span class="comment">/*</span>
00254 <span class="comment">     * for traps (not informs), there is no response. thus we don't</span>
00255 <span class="comment">     * need to listen to any address for a response, and should</span>
00256 <span class="comment">     * set the clientaddress to localhost, to reduce open ports.</span>
00257 <span class="comment">     */</span>
00258     <span class="keywordflow">if</span> (pdutype != SNMP_MSG_INFORM)
00259         session.<a class="code" href="structsnmp__session.html#o8">localname</a> = <span class=
"stringliteral">"localhost"</span>;
00260     sesp = snmp_open(&amp;session);
00261     free(peername);
00262 
00263     <span class="keywordflow">if</span> (sesp) {
00264         <span class="keywordflow">return</span> add_trap_session(sesp, pdutype,
00265                                 (pdutype == SNMP_MSG_INFORM), version);
00266     }
00267 
00268     <span class="comment">/*</span>
00269 <span class="comment">     * diagnose snmp_open errors with the input netsnmp_session pointer </span>
00270 <span class="comment">     */</span>
00271     snmp_sess_perror(<span class="stringliteral">"snmpd: create_trap_session"</span>, &amp;session);
00272     <span class="keywordflow">return</span> 0;
00273 }
00274 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
00275 
00276 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
00277 <span class="keyword">static</span> <span class="keywordtype">int</span>
00278 create_v1_trap_session(<span class="keywordtype">char</span> *sink, u_short sinkport, <span class=
"keywordtype">char</span> *com)
00279 {
00280     <span class="keywordflow">return</span> create_trap_session(sink, sinkport, com,
00281                                SNMP_VERSION_1, SNMP_MSG_TRAP);
00282 }
00283 <span class="preprocessor">#endif</span>
00284 
00285 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
00286 <span class="keyword">static</span> <span class="keywordtype">int</span>
00287 create_v2_trap_session(<span class="keywordtype">char</span> *sink, u_short sinkport, <span class=
"keywordtype">char</span> *com)
00288 {
00289     <span class="keywordflow">return</span> create_trap_session(sink, sinkport, com,
00290                                SNMP_VERSION_2c, SNMP_MSG_TRAP2);
00291 }
00292 
00293 <span class="keyword">static</span> <span class="keywordtype">int</span>
00294 create_v2_inform_session(<span class="keywordtype">char</span> *sink, u_short sinkport, <span class=
"keywordtype">char</span> *com)
00295 {
00296     <span class="keywordflow">return</span> create_trap_session(sink, sinkport, com,
00297                                SNMP_VERSION_2c, SNMP_MSG_INFORM);
00298 }
00299 <span class="preprocessor">#endif</span>
00300 
00341 <span class="keywordtype">void</span>
<a name="l00342" id="l00342"></a><a class="code" href="group__agent__trap.html#ga35">00342</a> <a class="code" href=
"group__agent__trap.html#ga35">snmpd_free_trapsinks</a>(<span class="keywordtype">void</span>)
00343 {
00344     <span class="keyword">struct </span>trap_sink *sp = sinks;
00345     <span class="keywordflow">while</span> (sp) {
00346         sinks = sinks-&gt;<a class="code" href="structsnmp__session.html#o5">next</a>;
00347         free_trap_session(sp);
00348         sp = sinks;
00349     }
00350 }
00351 
00352         <span class="comment">/*******************</span>
00353 <span class="comment">         *</span>
00354 <span class="comment">         * Trap handling</span>
00355 <span class="comment">         *</span>
00356 <span class="comment">         *******************/</span>
00357 
00358 
00359 <a class="code" href="structvariable__list.html">netsnmp_variable_list</a>*
00360 find_varbind_in_list( <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vblist,
00361                       oid *name, size_t len)
00362 {
00363     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *v;
00364 
00365     <span class="keywordflow">for</span> (v=vblist; v; v=v-&gt;<a class="code" href=
"structvariable__list.html#o0">next_variable</a>)
00366         <span class="keywordflow">if</span> (!<a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>(v-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, v-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>,
00367                               name,    len))
00368             <span class="keywordflow">return</span> v;
00369 
00370     <span class="keywordflow">return</span> NULL;
00371 }
00372 
00373 <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>*
00374 convert_v2pdu_to_v1( <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>* template_v2pdu )
00375 {
00376     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>           *template_v1pdu;
00377     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *first_vb, *vblist;
00378     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *var;
00379     size_t                 len;
00380 
00381     <span class="comment">/*</span>
00382 <span class="comment">     * Make a copy of the v2 Trap PDU</span>
00383 <span class="comment">     *   before starting to convert this</span>
00384 <span class="comment">     *   into a v1 Trap PDU.</span>
00385 <span class="comment">     */</span>
00386     template_v1pdu = snmp_clone_pdu( template_v2pdu);
00387     <span class="keywordflow">if</span> (!template_v1pdu) {
00388         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00389                  <span class="stringliteral">"send_trap: failed to copy v1 template PDU\n"</span>);
00390         <span class="keywordflow">return</span> NULL;
00391     }
00392     template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = SNMP_MSG_TRAP;
00393     first_vb = template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>;
00394     vblist   = template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>;
00395 
00396     <span class="comment">/*</span>
00397 <span class="comment">     * The first varbind should be the system uptime.</span>
00398 <span class="comment">     */</span>
00399     <span class="keywordflow">if</span> (!vblist ||
00400         <a class="code" href="group__library.html#ga98">snmp_oid_compare</a>(vblist-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>,  vblist-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>,
00401                          sysuptime_oid, sysuptime_oid_len)) {
00402         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00403                  <span class="stringliteral">"send_trap: no v2 sysUptime varbind to set from\n"</span>);
00404         snmp_free_pdu(template_v1pdu);
00405         <span class="keywordflow">return</span> NULL;
00406     }
00407     template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o8">time</a> = *vblist-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.integer;
00408     vblist = vblist-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>;
00409             
00410     <span class="comment">/*</span>
00411 <span class="comment">     * The second varbind should be the snmpTrapOID.</span>
00412 <span class="comment">     */</span>
00413     <span class="keywordflow">if</span> (!vblist ||
00414         <a class="code" href="group__library.html#ga98">snmp_oid_compare</a>(vblist-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, vblist-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>,
00415                          snmptrap_oid, snmptrap_oid_len)) {
00416         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00417                  <span class="stringliteral">"send_trap: no v2 trapOID varbind to set from\n"</span>);
00418         snmp_free_pdu(template_v1pdu);
00419         <span class="keywordflow">return</span> NULL;
00420     }
00421 
00422     <span class="comment">/*</span>
00423 <span class="comment">     * Set the generic &amp; specific trap types,</span>
00424 <span class="comment">     *    and the enterprise field from the v2 varbind list.</span>
00425 <span class="comment">     * If there's an agentIPAddress varbind, set the agent_addr too</span>
00426 <span class="comment">     */</span>
00427     <span class="keywordflow">if</span> (!<a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>(vblist-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid, OID_LENGTH(trap_prefix),
00428                           trap_prefix,       OID_LENGTH(trap_prefix))) {
00429         <span class="comment">/*</span>
00430 <span class="comment">         * For 'standard' traps, extract the generic trap type</span>
00431 <span class="comment">         *   from the snmpTrapOID value, and take the enterprise</span>
00432 <span class="comment">         *   value from the 'snmpEnterprise' varbind.</span>
00433 <span class="comment">         */</span>
00434         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o22">trap_type</a> =
00435             vblist-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid[OID_LENGTH(trap_prefix)] - 1;
00436         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o23">specific_type</a> = 0;
00437 
00438         var = find_varbind_in_list( vblist,
00439                              snmptrapenterprise_oid,
00440                              snmptrapenterprise_oid_len);
00441         <span class="keywordflow">if</span> (var) {
00442             <a class="code" href="group__util.html#ga5">memdup</a>((u_char**)&amp;template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o20">enterprise</a>,
00443                    (<span class="keyword">const</span> u_char*)var-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid, var-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a>);
00444             template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> = var-&gt;<a class=
"code" href="structvariable__list.html#o5">val_len</a>/<span class="keyword">sizeof</span>(oid);
00445         } <span class="keywordflow">else</span> {
00446             template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>        = NULL;
00447             template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o21">enterprise_length</a> = 0;              <span class="comment">/* XXX ??? */</span>
00448         }
00449     } <span class="keywordflow">else</span> {
00450         <span class="comment">/*</span>
00451 <span class="comment">         * For enterprise-specific traps, split the snmpTrapOID value</span>
00452 <span class="comment">         *   into enterprise and specific trap</span>
00453 <span class="comment">         */</span>
00454         len = vblist-&gt;<a class="code" href="structvariable__list.html#o5">val_len</a> / <span class=
"keyword">sizeof</span>(oid);
00455         template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a>     = SNMP_TRAP_ENTERPRISESPECIFIC;
00456         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o23">specific_type</a> = vblist-&gt;<a class="code"
href="structvariable__list.html#o4">val</a>.objid[len - 1];
00457         len--;
00458         <span class="keywordflow">if</span> (vblist-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid[len-1] == 0)
00459             len--;
00460         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o20">enterprise</a>);
00461         <a class="code" href="group__util.html#ga5">memdup</a>((u_char**)&amp;template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o20">enterprise</a>,
00462                (u_char *)vblist-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.objid, len*<span class=
"keyword">sizeof</span>(oid));
00463         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> = len;
00464     }
00465     var = find_varbind_in_list( vblist, agentaddr_oid,
00466                                         agentaddr_oid_len);
00467     <span class="keywordflow">if</span> (var) {
00468         memcpy(template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>,
00469                var-&gt;<a class="code" href="structvariable__list.html#o4">val</a>.string, 4);
00470     }
00471 
00472     <span class="comment">/*</span>
00473 <span class="comment">     * The remainder of the v2 varbind list is kept</span>
00474 <span class="comment">     * as the v2 varbind list.  Update the PDU and</span>
00475 <span class="comment">     * free the two redundant varbinds.</span>
00476 <span class="comment">     */</span>
00477     template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = vblist-&gt;<a class="code" href=
"structvariable__list.html#o0">next_variable</a>;
00478     vblist-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a> = NULL;
00479     snmp_free_varbind( first_vb );
00480             
00481     <span class="keywordflow">return</span> template_v1pdu;
00482 }
00483 
00484 <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>*
00485 convert_v1pdu_to_v2( <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>* template_v1pdu )
00486 {
00487     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>           *template_v2pdu;
00488     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *first_vb;
00489     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *var;
00490     oid                    enterprise[MAX_OID_LEN];
00491     size_t                 enterprise_len;
00492 
00493     <span class="comment">/*</span>
00494 <span class="comment">     * Make a copy of the v1 Trap PDU</span>
00495 <span class="comment">     *   before starting to convert this</span>
00496 <span class="comment">     *   into a v2 Trap PDU.</span>
00497 <span class="comment">     */</span>
00498     template_v2pdu = snmp_clone_pdu( template_v1pdu);
00499     <span class="keywordflow">if</span> (!template_v2pdu) {
00500         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00501                  <span class="stringliteral">"send_trap: failed to copy v2 template PDU\n"</span>);
00502         <span class="keywordflow">return</span> NULL;
00503     }
00504     template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = SNMP_MSG_TRAP2;
00505     first_vb = template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>;
00506 
00507     <span class="comment">/*</span>
00508 <span class="comment">     * Insert an snmpTrapOID varbind before the original v1 varbind list</span>
00509 <span class="comment">     *   either using one of the standard defined trap OIDs,</span>
00510 <span class="comment">     *   or constructing this from the PDU enterprise &amp; specific trap fields</span>
00511 <span class="comment">     */</span>
00512     <span class="keywordflow">if</span> (template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o22">trap_type</a> == SNMP_TRAP_ENTERPRISESPECIFIC) {
00513         memcpy(enterprise, template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>,
00514                            template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o21">enterprise_length</a>*<span class="keyword">sizeof</span>(oid));
00515         enterprise_len               = template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o21">enterprise_length</a>;
00516         enterprise[enterprise_len++] = 0;
00517         enterprise[enterprise_len++] = template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o23">specific_type</a>;
00518     } <span class="keywordflow">else</span> {
00519         memcpy(enterprise, cold_start_oid, <span class="keyword">sizeof</span>(cold_start_oid));
00520         enterprise[9]  = template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o22">trap_type</a>+1;
00521         enterprise_len = <span class="keyword">sizeof</span>(cold_start_oid)/<span class="keyword">sizeof</span>(oid);
00522     }
00523 
00524     var = NULL;
00525     <span class="keywordflow">if</span> (!snmp_varlist_add_variable( &amp;var,
00526              snmptrap_oid, snmptrap_oid_len,
00527              ASN_OBJECT_ID,
00528              (u_char*)enterprise, enterprise_len*<span class="keyword">sizeof</span>(oid))) {
00529         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00530                  <span class="stringliteral">"send_trap: failed to insert copied snmpTrapOID varbind\n"</span>);
00531         snmp_free_pdu(template_v2pdu);
00532         <span class="keywordflow">return</span> NULL;
00533     }
00534     var-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>        = template_v2pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o17">variables</a>;
00535     template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = var;
00536 
00537     <span class="comment">/*</span>
00538 <span class="comment">     * Insert a sysUptime varbind at the head of the v2 varbind list</span>
00539 <span class="comment">     */</span>
00540     var = NULL;
00541     <span class="keywordflow">if</span> (!snmp_varlist_add_variable( &amp;var,
00542              sysuptime_oid, sysuptime_oid_len,
00543              ASN_TIMETICKS,
00544              (u_char*)&amp;(template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o8">time</a>), 
00545              <span class="keyword">sizeof</span>(template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o8">time</a>))) {
00546         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00547                  <span class="stringliteral">"send_trap: failed to insert copied sysUptime varbind\n"</span>);
00548         snmp_free_pdu(template_v2pdu);
00549         <span class="keywordflow">return</span> NULL;
00550     }
00551     var-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>        = template_v2pdu-&gt;<a class=
"code" href="structsnmp__pdu.html#o17">variables</a>;
00552     template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = var;
00553 
00554     <span class="comment">/*</span>
00555 <span class="comment">     * Append the other three conversion varbinds,</span>
00556 <span class="comment">     *  (snmpTrapAgentAddr, snmpTrapCommunity &amp; snmpTrapEnterprise)</span>
00557 <span class="comment">     *  if they're not already present.</span>
00558 <span class="comment">     *  But don't bomb out completely if there are problems.</span>
00559 <span class="comment">     */</span>
00560     var = find_varbind_in_list( template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>,
00561                                 agentaddr_oid, agentaddr_oid_len);
00562     <span class="keywordflow">if</span> (!var &amp;&amp; (template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o24">agent_addr</a>[0]
00563               || template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>[1]
00564               || template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>[2]
00565               || template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>[3])) {
00566         <span class="keywordflow">if</span> (!snmp_varlist_add_variable( &amp;(template_v2pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>),
00567                  agentaddr_oid, agentaddr_oid_len,
00568                  ASN_IPADDRESS,
00569                  (u_char*)&amp;(template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>), 
00570                  <span class="keyword">sizeof</span>(template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o24">agent_addr</a>)))
00571             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00572                  <span class="stringliteral">"send_trap: failed to append snmpTrapAddr varbind\n"</span>);
00573     }
00574     var = find_varbind_in_list( template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>,
00575                                 community_oid, community_oid_len);
00576     <span class="keywordflow">if</span> (!var &amp;&amp; template_v1pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o18">community</a>) {
00577         <span class="keywordflow">if</span> (!snmp_varlist_add_variable( &amp;(template_v2pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>),
00578                  community_oid, community_oid_len,
00579                  ASN_OCTET_STR,
00580                  template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o18">community</a>, 
00581                  template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o19">community_len</a>))
00582             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00583                  <span class="stringliteral">"send_trap: failed to append snmpTrapCommunity varbind\n"</span>);
00584     }
00585     var = find_varbind_in_list( template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>,
00586                                 snmptrapenterprise_oid,
00587                                 snmptrapenterprise_oid_len);
00588     <span class="keywordflow">if</span> (!var &amp;&amp; 
00589         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o22">trap_type</a> != SNMP_TRAP_ENTERPRISESPECIFIC) {
00590         <span class="keywordflow">if</span> (!snmp_varlist_add_variable( &amp;(template_v2pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>),
00591                  snmptrapenterprise_oid, snmptrapenterprise_oid_len,
00592                  ASN_OBJECT_ID,
00593                  (u_char*)template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>, 
00594                  template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a>*<span class=
"keyword">sizeof</span>(oid)))
00595             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00596                  <span class="stringliteral">"send_trap: failed to append snmpEnterprise varbind\n"</span>);
00597     }
00598     <span class="keywordflow">return</span> template_v2pdu;
00599 }
00600 
00601 <span class="keywordtype">int</span>
00602 netsnmp_send_traps(<span class="keywordtype">int</span> trap, <span class="keywordtype">int</span> specific,
00603                           oid * enterprise, <span class="keywordtype">int</span> enterprise_length,
00604                           <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * vars,
00605                           <span class="comment">/* These next two are currently unused */</span>
00606                           <span class="keywordtype">char</span> * context, <span class="keywordtype">int</span> flags)
00607 {
00608     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>           *template_v1pdu;
00609     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>           *template_v2pdu;
00610     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *vblist = NULL;
00611     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *trap_vb;
00612     <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> *var;
00613     in_addr_t             *pdu_in_addr_t;
00614     u_long                 uptime;
00615     <span class="keyword">struct </span>trap_sink *sink;
00616 
00617     DEBUGMSGTL(( <span class="stringliteral">"trap"</span>, <span class=
"stringliteral">"send_trap %d %d "</span>, trap, specific));
00618     DEBUGMSGOID((<span class="stringliteral">"trap"</span>, enterprise, enterprise_length));
00619     DEBUGMSGTL(( <span class="stringliteral">"trap"</span>, <span class="stringliteral">"\n"</span>));
00620 
00621     <span class="keywordflow">if</span> (vars) {
00622         vblist = snmp_clone_varbind( vars );
00623         <span class="keywordflow">if</span> (!vblist) {
00624             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00625                      <span class="stringliteral">"send_trap: failed to clone varbind list\n"</span>);
00626             <span class="keywordflow">return</span> -1;
00627         }
00628     }
00629 
00630     <span class="keywordflow">if</span> ( trap == -1 ) {
00631         <span class="comment">/*</span>
00632 <span class="comment">         * Construct the SNMPv2-style notification PDU</span>
00633 <span class="comment">         */</span>
00634         <span class="keywordflow">if</span> (!vblist) {
00635             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00636                      <span class="stringliteral">"send_trap: called with NULL v2 information\n"</span>);
00637             <span class="keywordflow">return</span> -1;
00638         }
00639         template_v2pdu = snmp_pdu_create(SNMP_MSG_TRAP2);
00640         <span class="keywordflow">if</span> (!template_v2pdu) {
00641             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00642                      <span class="stringliteral">"send_trap: failed to construct v2 template PDU\n"</span>);
00643             <span class="keywordflow">return</span> -1;
00644         }
00645 
00646         <span class="comment">/*</span>
00647 <span class="comment">         * Check the varbind list we've been given.</span>
00648 <span class="comment">         * If it starts with a 'sysUptime.0' varbind, then use that.</span>
00649 <span class="comment">         * Otherwise, prepend a suitable 'sysUptime.0' varbind.</span>
00650 <span class="comment">         */</span>
00651         <span class="keywordflow">if</span> (!<a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>( vblist-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>,    vblist-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>,
00652                                sysuptime_oid, sysuptime_oid_len )) {
00653             template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = vblist;
00654             trap_vb  = vblist-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>;
00655         } <span class="keywordflow">else</span> {
00656             uptime   = netsnmp_get_agent_uptime();
00657             var = NULL;
00658             snmp_varlist_add_variable( &amp;var,
00659                            sysuptime_oid, sysuptime_oid_len,
00660                            ASN_TIMETICKS, (u_char*)&amp;uptime, <span class="keyword">sizeof</span>(uptime));
00661             <span class="keywordflow">if</span> (!var) {
00662                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00663                      <span class="stringliteral">"send_trap: failed to insert sysUptime varbind\n"</span>);
00664                 snmp_free_pdu(template_v2pdu);
00665                 <span class="keywordflow">return</span> -1;
00666             }
00667             template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = var;
00668             var-&gt;<a class="code" href="structvariable__list.html#o0">next_variable</a>        = vblist;
00669             trap_vb  = vblist;
00670         }
00671 
00672         <span class="comment">/*</span>
00673 <span class="comment">         * 'trap_vb' should point to the snmpTrapOID.0 varbind,</span>
00674 <span class="comment">         *   identifying the requested trap.  If not then bomb out.</span>
00675 <span class="comment">         * If it's a 'standard' trap, then we need to append an</span>
00676 <span class="comment">         *   snmpEnterprise varbind (if there isn't already one).</span>
00677 <span class="comment">         */</span>
00678         <span class="keywordflow">if</span> (!trap_vb ||
00679             <a class="code" href="group__library.html#ga98">snmp_oid_compare</a>(trap_vb-&gt;<a class="code" href=
"structvariable__list.html#o1">name</a>, trap_vb-&gt;<a class="code" href="structvariable__list.html#o2">name_length</a>,
00680                              snmptrap_oid,  snmptrap_oid_len)) {
00681             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00682                      <span class="stringliteral">"send_trap: no v2 trapOID varbind provided\n"</span>);
00683             snmp_free_pdu(template_v2pdu);
00684             <span class="keywordflow">return</span> -1;
00685         }
00686         <span class="keywordflow">if</span> (!<a class="code" href=
"group__library.html#ga98">snmp_oid_compare</a>(vblist-&gt;<a class="code" href=
"structvariable__list.html#o4">val</a>.objid, OID_LENGTH(trap_prefix),
00687                               trap_prefix,       OID_LENGTH(trap_prefix))) {
00688             var = find_varbind_in_list( template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>,
00689                                         snmptrapenterprise_oid,
00690                                         snmptrapenterprise_oid_len);
00691             <span class="keywordflow">if</span> (!var &amp;&amp;
00692                 !snmp_varlist_add_variable( &amp;(template_v2pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o17">variables</a>),
00693                      snmptrapenterprise_oid, snmptrapenterprise_oid_len,
00694                      ASN_OBJECT_ID,
00695                      (<span class="keywordtype">char</span>*)enterprise, enterprise_length*<span class=
"keyword">sizeof</span>(oid))) {
00696                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00697                      <span class="stringliteral">"send_trap: failed to add snmpEnterprise to v2 trap\n"</span>);
00698                 snmp_free_pdu(template_v2pdu);
00699                 <span class="keywordflow">return</span> -1;
00700             }
00701         }
00702             
00703 
00704         <span class="comment">/*</span>
00705 <span class="comment">         * If everything's OK, convert the v2 template into an SNMPv1 trap PDU.</span>
00706 <span class="comment">         */</span>
00707         template_v1pdu = convert_v2pdu_to_v1( template_v2pdu );
00708         <span class="keywordflow">if</span> (!template_v1pdu) {
00709             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00710                      <span class="stringliteral">"send_trap: failed to convert v2-&gt;v1 template PDU\n"</span>);
00711             snmp_free_pdu(template_v2pdu);
00712             <span class="keywordflow">return</span> -1;
00713         }
00714 
00715     } <span class="keywordflow">else</span> {
00716         <span class="comment">/*</span>
00717 <span class="comment">         * Construct the SNMPv1 trap PDU....</span>
00718 <span class="comment">         */</span>
00719         template_v1pdu = snmp_pdu_create(SNMP_MSG_TRAP);
00720         <span class="keywordflow">if</span> (!template_v1pdu) {
00721             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00722                      <span class="stringliteral">"send_trap: failed to construct v1 template PDU\n"</span>);
00723             <span class="keywordflow">return</span> -1;
00724         }
00725         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o22">trap_type</a>     = trap;
00726         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o23">specific_type</a> = specific;
00727         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o8">time</a>          = netsnmp_get_agent_uptime();
00728 
00729         <span class="keywordflow">if</span> (snmp_clone_mem((<span class=
"keywordtype">void</span> **) &amp;template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o20">enterprise</a>,
00730                        enterprise, enterprise_length * <span class="keyword">sizeof</span>(oid))) {
00731             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00732                      <span class="stringliteral">"send_trap: failed to set v1 enterprise OID\n"</span>);
00733             snmp_free_pdu(template_v1pdu);
00734             <span class="keywordflow">return</span> -1;
00735         }
00736         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o21">enterprise_length</a> = enterprise_length;
00737 
00738         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a>    |= UCD_MSG_FLAG_FORCE_PDU_COPY;
00739         template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a> = vblist;
00740 
00741         <span class="comment">/*</span>
00742 <span class="comment">         * ... and convert it into an SNMPv2-style notification PDU.</span>
00743 <span class="comment">         */</span>
00744 
00745         template_v2pdu = convert_v1pdu_to_v2( template_v1pdu );
00746         <span class="keywordflow">if</span> (!template_v2pdu) {
00747             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00748                      <span class="stringliteral">"send_trap: failed to convert v1-&gt;v2 template PDU\n"</span>);
00749             snmp_free_pdu(template_v1pdu);
00750             <span class="keywordflow">return</span> -1;
00751         }
00752     }
00753     <span class="comment">/*</span>
00754 <span class="comment">     * Ensure that the v1 trap PDU includes the local IP address</span>
00755 <span class="comment">     */</span>
00756      pdu_in_addr_t = (in_addr_t *) template_v1pdu-&gt;<a class="code" href="structsnmp__pdu.html#o24">agent_addr</a>;
00757     *pdu_in_addr_t = get_myaddr();
00758 
00759 
00760     <span class="comment">/*</span>
00761 <span class="comment">     *  Now loop through the list of trap sinks</span>
00762 <span class="comment">     *   and call the trap callback routines,</span>
00763 <span class="comment">     *   providing an appropriately formatted PDU in each case</span>
00764 <span class="comment">     */</span>
00765     <span class="keywordflow">for</span> (sink = sinks; sink; sink = sink-&gt;next) {
00766 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
00767         <span class="keywordflow">if</span> (sink-&gt;version == SNMP_VERSION_1) {
00768             send_trap_to_sess(sink-&gt;sesp, template_v1pdu);
00769         } <span class="keywordflow">else</span> {
00770 <span class="preprocessor">#endif</span>
00771             template_v2pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> = sink-&gt;pdutype;
00772             send_trap_to_sess(sink-&gt;sesp, template_v2pdu);
00773 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
00774         }
00775 <span class="preprocessor">#endif</span>
00776     }
00777     <a class="code" href="group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
00778                         SNMPD_CALLBACK_SEND_TRAP1, template_v1pdu);
00779     <a class="code" href="group__callback.html#ga5">snmp_call_callbacks</a>(SNMP_CALLBACK_APPLICATION,
00780                         SNMPD_CALLBACK_SEND_TRAP2, template_v2pdu);
00781     snmp_free_pdu(template_v1pdu);
00782     snmp_free_pdu(template_v2pdu);
00783     <span class="keywordflow">return</span> 0;
00784 }
00785 
00786 
00787 <span class="keywordtype">void</span>
00788 send_enterprise_trap_vars(<span class="keywordtype">int</span> trap,
00789                           <span class="keywordtype">int</span> specific,
00790                           oid * enterprise, <span class="keywordtype">int</span> enterprise_length,
00791                           <a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * vars)
00792 {
00793     netsnmp_send_traps(trap, specific,
00794                        enterprise, enterprise_length,
00795                        vars, NULL, 0);
00796     <span class="keywordflow">return</span>;
00797 }
00798 
00799 <span class="comment">/*</span>
00800 <span class="comment"> * send_trap_to_sess: sends a trap to a session but assumes that the</span>
00801 <span class="comment"> * pdu is constructed correctly for the session type. </span>
00802 <span class="comment"> */</span>
00803 <span class="keywordtype">void</span>
00804 send_trap_to_sess(<a class="code" href="structsnmp__session.html">netsnmp_session</a> * sess, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *template_pdu)
00805 {
00806     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>    *pdu;
00807     <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>    *response;
00808     <span class="keywordtype">int</span>            result;
00809 
00810     <span class="keywordflow">if</span> (!sess || !template_pdu)
00811         <span class="keywordflow">return</span>;
00812 
00813     DEBUGMSGTL((<span class="stringliteral">"trap"</span>, <span class=
"stringliteral">"sending trap type=%d, version=%d\n"</span>,
00814                 template_pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a>, sess-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a>));
00815 
00816 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
00817     <span class="keywordflow">if</span> (sess-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a> == SNMP_VERSION_1 &amp;&amp;
00818         (template_pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> != SNMP_MSG_TRAP))
00819         <span class="keywordflow">return</span>;                 <span class=
"comment">/* Skip v1 sinks for v2 only traps */</span>
00820 <span class="preprocessor">#endif</span>
00821     template_pdu-&gt;<a class="code" href="structsnmp__pdu.html#o0">version</a> = sess-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a>;
00822     pdu = snmp_clone_pdu(template_pdu);
00823     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o5">sessid</a> = sess-&gt;<a class="code" href=
"structsnmp__session.html#o15">sessid</a>; <span class="comment">/* AgentX only ? */</span>
00824 
00825     <span class="keywordflow">if</span> ( template_pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a> == SNMP_MSG_INFORM
00826 <span class="preprocessor">#ifdef USING_AGENTX_PROTOCOL_MODULE</span>
00827          || template_pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> == AGENTX_MSG_NOTIFY
00828 <span class="preprocessor">#endif</span>
00829        ) {
00830         result = snmp_synch_response(sess, pdu, &amp;response);
00831         result = !result;       <span class="comment">/* XXX - different return code :-( */</span>
00832     } <span class="keywordflow">else</span>
00833         result = snmp_send(sess, pdu);
00834     <span class="keywordflow">if</span> (result == 0) {
00835         snmp_sess_perror(<span class="stringliteral">"snmpd: send_trap"</span>, sess);
00836         <span class="comment">/* snmp_free_pdu(pdu); */</span>
00837     } <span class="keywordflow">else</span> {
00838         snmp_increment_statistic(STAT_SNMPOUTTRAPS);
00839         snmp_increment_statistic(STAT_SNMPOUTPKTS);
00840     }
00841 }
00842 
00843 <span class="keywordtype">void</span>
00844 send_trap_vars(<span class="keywordtype">int</span> trap, <span class="keywordtype">int</span> specific, <a class="code"
href="structvariable__list.html">netsnmp_variable_list</a> * vars)
00845 {
00846     <span class="keywordflow">if</span> (trap == SNMP_TRAP_ENTERPRISESPECIFIC)
00847         send_enterprise_trap_vars(trap, specific, objid_enterprisetrap,
00848                                   OID_LENGTH(objid_enterprisetrap), vars);
00849     <span class="keywordflow">else</span>
00850         send_enterprise_trap_vars(trap, specific, trap_version_id,
00851                                   OID_LENGTH(trap_version_id), vars);
00852 }
00853 
00877 <span class="keywordtype">void</span>
<a name="l00878" id="l00878"></a><a class="code" href="group__agent__trap.html#ga43">00878</a> <a class="code" href=
"group__agent__trap.html#ga43">send_easy_trap</a>(<span class="keywordtype">int</span> trap, <span class=
"keywordtype">int</span> specific)
00879 {
00880     send_trap_vars(trap, specific, NULL);
00881 }
00882 
00906 <span class="keywordtype">void</span>
<a name="l00907" id="l00907"></a><a class="code" href="group__agent__trap.html#ga44">00907</a> <a class="code" href=
"group__agent__trap.html#ga44">send_v2trap</a>(<a class="code" href="structvariable__list.html">netsnmp_variable_list</a> * vars)
00908 {
00909     send_trap_vars(-1, -1, vars);
00910 }
00911 
00912 <span class="keywordtype">void</span>
00913 send_trap_pdu(<a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
00914 {
00915     send_trap_vars(-1, -1, pdu-&gt;<a class="code" href="structsnmp__pdu.html#o17">variables</a>);
00916 }
00917 
00918 
00919 
00920         <span class="comment">/*******************</span>
00921 <span class="comment">         *</span>
00922 <span class="comment">         * Config file handling</span>
00923 <span class="comment">         *</span>
00924 <span class="comment">         *******************/</span>
00925 
00926 <span class="keywordtype">void</span>
00927 snmpd_parse_config_authtrap(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *cptr)
00928 {
00929     <span class="keywordtype">int</span>             i;
00930 
00931     i = atoi(cptr);
00932     <span class="keywordflow">if</span> (i == 0) {
00933         <span class="keywordflow">if</span> (strcmp(cptr, <span class="stringliteral">"enable"</span>) == 0) {
00934             i = SNMP_AUTHENTICATED_TRAPS_ENABLED;
00935         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(cptr, <span class=
"stringliteral">"disable"</span>) == 0) {
00936             i = SNMP_AUTHENTICATED_TRAPS_DISABLED;
00937         }
00938     }
00939     <span class="keywordflow">if</span> (i &lt; 1 || i &gt; 2) {
00940         config_perror(<span class="stringliteral">"authtrapenable must be 1 or 2"</span>);
00941     } <span class="keywordflow">else</span> {
00942         <span class="keywordflow">if</span> (strcmp(token, <span class="stringliteral">"pauthtrapenable"</span>) == 0) {
00943             <span class="keywordflow">if</span> (snmp_enableauthentrapsset &lt; 0) {
00944                 <span class="comment">/*</span>
00945 <span class="comment">                 * This is bogus (and shouldn't happen anyway) -- the value</span>
00946 <span class="comment">                 * of snmpEnableAuthenTraps.0 is already configured</span>
00947 <span class="comment">                 * read-only.  </span>
00948 <span class="comment">                 */</span>
00949                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00950                          <span class=
"stringliteral">"ignoring attempted override of read-only snmpEnableAuthenTraps.0\n"</span>);
00951                 <span class="keywordflow">return</span>;
00952             } <span class="keywordflow">else</span> {
00953                 snmp_enableauthentrapsset++;
00954             }
00955         } <span class="keywordflow">else</span> {
00956             <span class="keywordflow">if</span> (snmp_enableauthentrapsset &gt; 0) {
00957                 <span class="comment">/*</span>
00958 <span class="comment">                 * This is bogus (and shouldn't happen anyway) -- we already</span>
00959 <span class="comment">                 * read a persistent value of snmpEnableAuthenTraps.0, which</span>
00960 <span class="comment">                 * we should ignore in favour of this one.  </span>
00961 <span class="comment">                 */</span>
00962                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
00963                          <span class=
"stringliteral">"ignoring attempted override of read-only snmpEnableAuthenTraps.0\n"</span>);
00964                 <span class="comment">/*</span>
00965 <span class="comment">                 * Fall through and copy in this value.  </span>
00966 <span class="comment">                 */</span>
00967             }
00968             snmp_enableauthentrapsset = -1;
00969         }
00970         snmp_enableauthentraps = i;
00971     }
00972 }
00973 
00974 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
00975 <span class="keywordtype">void</span>
00976 snmpd_parse_config_trapsink(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *cptr)
00977 {
00978     <span class="keywordtype">char</span>            tmpbuf[1024];
00979     <span class="keywordtype">char</span>           *sp, *cp, *pp = NULL;
00980     <span class="keywordtype">int</span>             sinkport;
00981     <span class="keywordtype">char</span>            *st;
00982 
00983     <span class="keywordflow">if</span> (!snmp_trapcommunity)
00984         snmp_trapcommunity = strdup(<span class="stringliteral">"public"</span>);
00985     sp = strtok_r(cptr, <span class="stringliteral">" \t\n"</span>, &amp;st);
00986     cp = strtok_r(NULL, <span class="stringliteral">" \t\n"</span>, &amp;st);
00987     <span class="keywordflow">if</span> (cp)
00988         pp = strtok_r(NULL, <span class="stringliteral">" \t\n"</span>, &amp;st);
00989     <span class="keywordflow">if</span> (cp &amp;&amp; pp) {
00990         sinkport = atoi(pp);
00991         <span class="keywordflow">if</span> ((sinkport &lt; 1) || (sinkport &gt; 0xffff)) {
00992             config_perror(<span class="stringliteral">"trapsink port out of range"</span>);
00993             sinkport = SNMP_TRAP_PORT;
00994         }
00995     } <span class="keywordflow">else</span> {
00996         sinkport = SNMP_TRAP_PORT;
00997     }
00998     <span class="keywordflow">if</span> (create_v1_trap_session(sp, (u_short)sinkport,
00999                                cp ? cp : snmp_trapcommunity) == 0) {
01000         snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf), <span class=
"stringliteral">"cannot create trapsink: %s"</span>, cptr);
01001         tmpbuf[<span class="keyword">sizeof</span>(tmpbuf)-1] = <span class="charliteral">'\0'</span>;
01002         config_perror(tmpbuf);
01003     }
01004 }
01005 <span class="preprocessor">#endif</span>
01006 
01007 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
01008 <span class="keywordtype">void</span>
01009 snmpd_parse_config_trap2sink(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
01010 {
01011     <span class="keywordtype">char</span>            tmpbuf[1024];
01012     <span class="keywordtype">char</span>           *sp, *cp, *pp = NULL;
01013     <span class="keywordtype">int</span>             sinkport;
01014     <span class="keywordtype">char</span>            *st;
01015 
01016     <span class="keywordflow">if</span> (!snmp_trapcommunity)
01017         snmp_trapcommunity = strdup(<span class="stringliteral">"public"</span>);
01018     sp = strtok_r(cptr, <span class="stringliteral">" \t\n"</span>, &amp;st);
01019     cp = strtok_r(NULL, <span class="stringliteral">" \t\n"</span>, &amp;st);
01020     <span class="keywordflow">if</span> (cp)
01021         pp = strtok_r(NULL, <span class="stringliteral">" \t\n"</span>, &amp;st);
01022     <span class="keywordflow">if</span> (cp &amp;&amp; pp) {
01023         sinkport = atoi(pp);
01024         <span class="keywordflow">if</span> ((sinkport &lt; 1) || (sinkport &gt; 0xffff)) {
01025             config_perror(<span class="stringliteral">"trapsink port out of range"</span>);
01026             sinkport = SNMP_TRAP_PORT;
01027         }
01028     } <span class="keywordflow">else</span> {
01029         sinkport = SNMP_TRAP_PORT;
01030     }
01031     <span class="keywordflow">if</span> (create_v2_trap_session(sp, (u_short)sinkport,
01032                                cp ? cp : snmp_trapcommunity) == 0) {
01033         snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf), <span class=
"stringliteral">"cannot create trap2sink: %s"</span>, cptr);
01034         tmpbuf[<span class="keyword">sizeof</span>(tmpbuf)-1] = <span class="charliteral">'\0'</span>;
01035         config_perror(tmpbuf);
01036     }
01037 }
01038 
01039 <span class="keywordtype">void</span>
01040 snmpd_parse_config_informsink(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
01041 {
01042     <span class="keywordtype">char</span>            tmpbuf[1024];
01043     <span class="keywordtype">char</span>           *sp, *cp, *pp = NULL;
01044     <span class="keywordtype">int</span>             sinkport;
01045     <span class="keywordtype">char</span>            *st;
01046 
01047     <span class="keywordflow">if</span> (!snmp_trapcommunity)
01048         snmp_trapcommunity = strdup(<span class="stringliteral">"public"</span>);
01049     sp = strtok_r(cptr, <span class="stringliteral">" \t\n"</span>, &amp;st);
01050     cp = strtok_r(NULL, <span class="stringliteral">" \t\n"</span>, &amp;st);
01051     <span class="keywordflow">if</span> (cp)
01052         pp = strtok_r(NULL, <span class="stringliteral">" \t\n"</span>, &amp;st);
01053     <span class="keywordflow">if</span> (cp &amp;&amp; pp) {
01054         sinkport = atoi(pp);
01055         <span class="keywordflow">if</span> ((sinkport &lt; 1) || (sinkport &gt; 0xffff)) {
01056             config_perror(<span class="stringliteral">"trapsink port out of range"</span>);
01057             sinkport = SNMP_TRAP_PORT;
01058         }
01059     } <span class="keywordflow">else</span> {
01060         sinkport = SNMP_TRAP_PORT;
01061     }
01062     <span class="keywordflow">if</span> (create_v2_inform_session(sp, (u_short)sinkport,
01063                                  cp ? cp : snmp_trapcommunity) == 0) {
01064         snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf), <span class=
"stringliteral">"cannot create informsink: %s"</span>, cptr);
01065         tmpbuf[<span class="keyword">sizeof</span>(tmpbuf)-1] = <span class="charliteral">'\0'</span>;
01066         config_perror(tmpbuf);
01067     }
01068 }
01069 <span class="preprocessor">#endif</span>
01070 
01071 <span class="comment">/*</span>
01072 <span class="comment"> * this must be standardized somewhere, right? </span>
01073 <span class="comment"> */</span>
01074 <span class="preprocessor">#define MAX_ARGS 128</span>
01075 
01076 <span class="keyword">static</span> <span class="keywordtype">int</span>      traptype;
01077 
01078 <span class="keyword">static</span> <span class="keywordtype">void</span>
01079 trapOptProc(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *<span class=
"keyword">const</span> *argv, <span class="keywordtype">int</span> opt)
01080 {
01081     <span class="keywordflow">switch</span> (opt) {
01082     <span class="keywordflow">case</span> <span class="charliteral">'C'</span>:
01083         <span class="keywordflow">while</span> (*optarg) {
01084             <span class="keywordflow">switch</span> (*optarg++) {
01085             <span class="keywordflow">case</span> <span class="charliteral">'i'</span>:
01086                 traptype = SNMP_MSG_INFORM;
01087                 <span class="keywordflow">break</span>;
01088             <span class="keywordflow">default</span>:
01089                 config_perror(<span class="stringliteral">"unknown argument passed to -C"</span>);
01090                 <span class="keywordflow">break</span>;
01091             }
01092         }
01093         <span class="keywordflow">break</span>;
01094     }
01095 }
01096 
01097 
01098 <span class="keywordtype">void</span>
01099 snmpd_parse_config_trapsess(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
01100 {
01101     <span class="keywordtype">char</span>           *argv[MAX_ARGS], *cp = cptr, tmp[SPRINT_MAX_LEN];
01102     <span class="keywordtype">int</span>             argn, arg;
01103     <a class="code" href="structsnmp__session.html">netsnmp_session</a> session, *ss;
01104 
01105     <span class="comment">/*</span>
01106 <span class="comment">     * inform or trap?  default to trap </span>
01107 <span class="comment">     */</span>
01108     traptype = SNMP_MSG_TRAP2;
01109 
01110     <span class="comment">/*</span>
01111 <span class="comment">     * create the argv[] like array </span>
01112 <span class="comment">     */</span>
01113     argv[0] = strdup(<span class="stringliteral">"snmpd-trapsess"</span>); <span class=
"comment">/* bogus entry for getopt() */</span>
01114     <span class="keywordflow">for</span> (argn = 1; cp &amp;&amp; argn &lt; MAX_ARGS; argn++) {
01115         cp = copy_nword(cp, tmp, SPRINT_MAX_LEN);
01116         argv[argn] = strdup(tmp);
01117     }
01118 
01119     arg = snmp_parse_args(argn, argv, &amp;session, <span class="stringliteral">"C:"</span>, trapOptProc);
01120     ss = snmp_open(&amp;session);
01121 
01122     <span class="keywordflow">for</span> (; argn &gt; 0; argn--) {
01123         free(argv[argn - 1]);
01124     }
01125 
01126     <span class="keywordflow">if</span> (!ss) {
01127         config_perror
01128             (<span class=
"stringliteral">"snmpd: failed to parse this line or the remote trap receiver is down.  Possible cause:"</span>);
01129         snmp_sess_perror(<span class="stringliteral">"snmpd: snmpd_parse_config_trapsess()"</span>, &amp;session);
01130         <span class="keywordflow">return</span>;
01131     }
01132 
01133 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
01134     <span class="keywordflow">if</span> (ss-&gt;<a class="code" href=
"structsnmp__session.html#o0">version</a> == SNMP_VERSION_1) {
01135         add_trap_session(ss, SNMP_MSG_TRAP, 0, SNMP_VERSION_1);
01136     } <span class="keywordflow">else</span> {
01137 <span class="preprocessor">#endif</span>
01138         add_trap_session(ss, traptype, (traptype == SNMP_MSG_INFORM),
01139                          ss-&gt;<a class="code" href="structsnmp__session.html#o0">version</a>);
01140 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
01141     }
01142 <span class="preprocessor">#endif</span>
01143 }
01144 
01145 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
01146 <span class="keywordtype">void</span>
01147 snmpd_parse_config_trapcommunity(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *word, <span class="keywordtype">char</span> *cptr)
01148 {
01149     <span class="keywordflow">if</span> (snmp_trapcommunity != NULL) {
01150         free(snmp_trapcommunity);
01151     }
01152     snmp_trapcommunity = (<span class="keywordtype">char</span> *) malloc(strlen(cptr) + 1);
01153     <span class="keywordflow">if</span> (snmp_trapcommunity != NULL) {
01154         copy_nword(cptr, snmp_trapcommunity, strlen(cptr) + 1);
01155     }
01156 }
01157 
01158 <span class="keywordtype">void</span>
01159 snmpd_free_trapcommunity(<span class="keywordtype">void</span>)
01160 {
01161     <span class="keywordflow">if</span> (snmp_trapcommunity) {
01162         free(snmp_trapcommunity);
01163         snmp_trapcommunity = NULL;
01164     }
01165 }
01166 <span class="preprocessor">#endif</span>
01167 
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small><!--#include virtual="/sfbutton.html" --><br />
    Generated on Thu Nov 25 17:51:36 2004 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

