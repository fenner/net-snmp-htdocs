<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>parse.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * parse.c</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Update: 1998-09-22 &lt;mslifcak@iss.net&gt;</span>
00005 <span class="comment"> * Clear nbuckets in init_node_hash.</span>
00006 <span class="comment"> * New method xcalloc returns zeroed data structures.</span>
00007 <span class="comment"> * New method alloc_node encapsulates common node creation.</span>
00008 <span class="comment"> * New method to configure terminate comment at end of line.</span>
00009 <span class="comment"> * New method to configure accept underscore in labels.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Update: 1998-10-10 &lt;daves@csc.liv.ac.uk&gt;</span>
00012 <span class="comment"> * fully qualified OID parsing patch</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * Update: 1998-10-20 &lt;daves@csc.liv.ac.uk&gt;</span>
00015 <span class="comment"> * merge_anon_children patch</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * Update: 1998-10-21 &lt;mslifcak@iss.net&gt;</span>
00018 <span class="comment"> * Merge_parse_objectid associates information with last node in chain.</span>
00019 <span class="comment"> */</span>
00020 <span class="comment">/* Portions of this file are subject to the following copyrights.  See</span>
00021 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00022 <span class="comment"> * that may apply:</span>
00023 <span class="comment"> */</span>
00024 <span class="comment">/******************************************************************</span>
00025 <span class="comment">        Copyright 1989, 1991, 1992 by Carnegie Mellon University</span>
00026 
00027 <span class="comment">                      All Rights Reserved</span>
00028 
00029 <span class="comment">Permission to use, copy, modify, and distribute this software and its</span>
00030 <span class="comment">documentation for any purpose and without fee is hereby granted,</span>
00031 <span class="comment">provided that the above copyright notice appear in all copies and that</span>
00032 <span class="comment">both that copyright notice and this permission notice appear in</span>
00033 <span class="comment">supporting documentation, and that the name of CMU not be</span>
00034 <span class="comment">used in advertising or publicity pertaining to distribution of the</span>
00035 <span class="comment">software without specific, written prior permission.</span>
00036 
00037 <span class="comment">CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING</span>
00038 <span class="comment">ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL</span>
00039 <span class="comment">CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR</span>
00040 <span class="comment">ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</span>
00041 <span class="comment">WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,</span>
00042 <span class="comment">ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS</span>
00043 <span class="comment">SOFTWARE.</span>
00044 <span class="comment">******************************************************************/</span>
00045 <span class="comment">/*</span>
00046 <span class="comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
00047 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00048 <span class="comment"> * distributed with the Net-SNMP package.</span>
00049 <span class="comment"> */</span>
00050 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00051 
00052 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
00053 
00054 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00055 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00056 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00057 <span class="preprocessor">#endif</span>
00058 <span class="preprocessor">#if HAVE_STRING_H</span>
00059 <span class="preprocessor">#include &lt;string.h&gt;</span>
00060 <span class="preprocessor">#else</span>
00061 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00062 <span class="preprocessor">#endif</span>
00063 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00064 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00065 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00066 
00067 <span class="comment">/*</span>
00068 <span class="comment"> * Wow.  This is ugly.  -- Wes </span>
00069 <span class="comment"> */</span>
00070 <span class="preprocessor">#if HAVE_DIRENT_H</span>
00071 <span class="preprocessor"># include &lt;dirent.h&gt;</span>
00072 <span class="preprocessor"># define NAMLEN(dirent) strlen((dirent)-&gt;d_name)</span>
00073 <span class="preprocessor">#else</span>
00074 <span class="preprocessor"># define dirent direct</span>
00075 <span class="preprocessor"># define NAMLEN(dirent) (dirent)-&gt;d_namlen</span>
00076 <span class="preprocessor"># if HAVE_SYS_NDIR_H</span>
00077 <span class="preprocessor">#  include &lt;sys/ndir.h&gt;</span>
00078 <span class="preprocessor"># endif</span>
00079 <span class="preprocessor"># if HAVE_SYS_DIR_H</span>
00080 <span class="preprocessor">#  include &lt;sys/dir.h&gt;</span>
00081 <span class="preprocessor"># endif</span>
00082 <span class="preprocessor"># if HAVE_NDIR_H</span>
00083 <span class="preprocessor">#  include &lt;ndir.h&gt;</span>
00084 <span class="preprocessor"># endif</span>
00085 <span class="preprocessor">#endif</span>
00086 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00087 <span class="preprocessor"># ifdef WIN32</span>
00088 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00089 <span class="preprocessor"># else</span>
00090 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00091 <span class="preprocessor"># endif</span>
00092 <span class="preprocessor"># include &lt;time.h&gt;</span>
00093 <span class="preprocessor">#else</span>
00094 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00095 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00096 <span class="preprocessor"># else</span>
00097 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00098 <span class="preprocessor"># endif</span>
00099 <span class="preprocessor">#endif</span>
00100 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00101 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00102 <span class="preprocessor">#endif</span>
00103 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00104 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00105 <span class="preprocessor">#endif</span>
00106 <span class="preprocessor">#if defined(HAVE_REGEX_H) &amp;&amp; defined(HAVE_REGCOMP)</span>
00107 <span class="preprocessor">#include &lt;regex.h&gt;</span>
00108 <span class="preprocessor">#endif</span>
00109 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00110 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00111 <span class="preprocessor">#endif</span>
00112 
00113 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00114 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00115 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00116 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00117 
00118 <span class="preprocessor">#include &lt;net-snmp/library/parse.h&gt;</span>
00119 <span class="preprocessor">#include &lt;net-snmp/library/mib.h&gt;</span>
00120 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00121 
00122 <span class="comment">/*</span>
00123 <span class="comment"> * This is one element of an object identifier with either an integer</span>
00124 <span class="comment"> * subidentifier, or a textual string label, or both.</span>
00125 <span class="comment"> * The subid is -1 if not present, and label is NULL if not present.</span>
00126 <span class="comment"> */</span>
00127 <span class="keyword">struct </span>subid_s {
00128     <span class="keywordtype">int</span>             subid;
00129     <span class="keywordtype">int</span>             modid;
00130     <span class="keywordtype">char</span>           *label;
00131 };
00132 
00133 <span class="preprocessor">#define MAXTC   4096</span>
00134 <span class="keyword">struct </span>tc {                     <span class="comment">/* textual conventions */</span>
00135     <span class="keywordtype">int</span>             type;
00136     <span class="keywordtype">int</span>             modid;
00137     <span class="keywordtype">char</span>           *descriptor;
00138     <span class="keywordtype">char</span>           *hint;
00139     <span class="keyword">struct </span>enum_list *enums;
00140     <span class="keyword">struct </span>range_list *ranges;
00141     <span class="keywordtype">char</span>           *description;
00142 } tclist[MAXTC];
00143 
00144 <span class="keywordtype">int</span>             mibLine = 0;
00145 <span class="keyword">const</span> <span class="keywordtype">char</span>     *File = <span class=
"stringliteral">"(none)"</span>;
00146 <span class="keyword">static</span> <span class="keywordtype">int</span>      anonymous = 0;
00147 
00148 <span class="keyword">struct </span>objgroup {
00149     <span class="keywordtype">char</span>           *name;
00150     <span class="keywordtype">int</span>             line;
00151     <span class="keyword">struct </span>objgroup *next;
00152 }              *objgroups = NULL, *objects = NULL, *notifs = NULL;
00153 
00154 <span class="preprocessor">#define SYNTAX_MASK     0x80</span>
00155 <span class="comment">/*</span>
00156 <span class="comment"> * types of tokens</span>
00157 <span class="comment"> * Tokens wiht the SYNTAX_MASK bit set are syntax tokens </span>
00158 <span class="comment"> */</span>
00159 <span class="preprocessor">#define CONTINUE    -1</span>
00160 <span class="preprocessor">#define ENDOFFILE   0</span>
00161 <span class="preprocessor">#define LABEL       1</span>
00162 <span class="preprocessor">#define SUBTREE     2</span>
00163 <span class="preprocessor">#define SYNTAX      3</span>
00164 <span class="preprocessor">#define OBJID       (4 | SYNTAX_MASK)</span>
00165 <span class="preprocessor">#define OCTETSTR    (5 | SYNTAX_MASK)</span>
00166 <span class="preprocessor">#define INTEGER     (6 | SYNTAX_MASK)</span>
00167 <span class="preprocessor">#define NETADDR     (7 | SYNTAX_MASK)</span>
00168 <span class="preprocessor">#define IPADDR      (8 | SYNTAX_MASK)</span>
00169 <span class="preprocessor">#define COUNTER     (9 | SYNTAX_MASK)</span>
00170 <span class="preprocessor">#define GAUGE       (10 | SYNTAX_MASK)</span>
00171 <span class="preprocessor">#define TIMETICKS   (11 | SYNTAX_MASK)</span>
00172 <span class="preprocessor">#define KW_OPAQUE   (12 | SYNTAX_MASK)</span>
00173 <span class="preprocessor">#define NUL         (13 | SYNTAX_MASK)</span>
00174 <span class="preprocessor">#define SEQUENCE    14</span>
00175 <span class="preprocessor">#define OF          15          </span><span class="comment">/* SEQUENCE OF */</span>
00176 <span class="preprocessor">#define OBJTYPE     16</span>
00177 <span class="preprocessor">#define ACCESS      17</span>
00178 <span class="preprocessor">#define READONLY    18</span>
00179 <span class="preprocessor">#define READWRITE   19</span>
00180 <span class="preprocessor">#define WRITEONLY   20</span>
00181 <span class="preprocessor">#ifdef NOACCESS</span>
00182 <span class="preprocessor">#undef NOACCESS                 </span><span class="comment">/* agent 'NOACCESS' token */</span>
00183 <span class="preprocessor">#endif</span>
00184 <span class="preprocessor">#define NOACCESS    21</span>
00185 <span class="preprocessor">#define STATUS      22</span>
00186 <span class="preprocessor">#define MANDATORY   23</span>
00187 <span class="preprocessor">#define KW_OPTIONAL    24</span>
00188 <span class="preprocessor">#define OBSOLETE    25</span>
00189 <span class="comment">/*</span>
00190 <span class="comment"> * #define RECOMMENDED 26 </span>
00191 <span class="comment"> */</span>
00192 <span class="preprocessor">#define PUNCT       27</span>
00193 <span class="preprocessor">#define EQUALS      28</span>
00194 <span class="preprocessor">#define NUMBER      29</span>
00195 <span class="preprocessor">#define LEFTBRACKET 30</span>
00196 <span class="preprocessor">#define RIGHTBRACKET 31</span>
00197 <span class="preprocessor">#define LEFTPAREN   32</span>
00198 <span class="preprocessor">#define RIGHTPAREN  33</span>
00199 <span class="preprocessor">#define COMMA       34</span>
00200 <span class="preprocessor">#define DESCRIPTION 35</span>
00201 <span class="preprocessor">#define QUOTESTRING 36</span>
00202 <span class="preprocessor">#define INDEX       37</span>
00203 <span class="preprocessor">#define DEFVAL      38</span>
00204 <span class="preprocessor">#define DEPRECATED  39</span>
00205 <span class="preprocessor">#define SIZE        40</span>
00206 <span class="preprocessor">#define BITSTRING   (41 | SYNTAX_MASK)</span>
00207 <span class="preprocessor">#define NSAPADDRESS (42 | SYNTAX_MASK)</span>
00208 <span class="preprocessor">#define COUNTER64   (43 | SYNTAX_MASK)</span>
00209 <span class="preprocessor">#define OBJGROUP    44</span>
00210 <span class="preprocessor">#define NOTIFTYPE   45</span>
00211 <span class="preprocessor">#define AUGMENTS    46</span>
00212 <span class="preprocessor">#define COMPLIANCE  47</span>
00213 <span class="preprocessor">#define READCREATE  48</span>
00214 <span class="preprocessor">#define UNITS       49</span>
00215 <span class="preprocessor">#define REFERENCE   50</span>
00216 <span class="preprocessor">#define NUM_ENTRIES 51</span>
00217 <span class="preprocessor">#define MODULEIDENTITY 52</span>
00218 <span class="preprocessor">#define LASTUPDATED 53</span>
00219 <span class="preprocessor">#define ORGANIZATION 54</span>
00220 <span class="preprocessor">#define CONTACTINFO 55</span>
00221 <span class="preprocessor">#define UINTEGER32 (56 | SYNTAX_MASK)</span>
00222 <span class="preprocessor">#define CURRENT     57</span>
00223 <span class="preprocessor">#define DEFINITIONS 58</span>
00224 <span class="preprocessor">#define END         59</span>
00225 <span class="preprocessor">#define SEMI        60</span>
00226 <span class="preprocessor">#define TRAPTYPE    61</span>
00227 <span class="preprocessor">#define ENTERPRISE  62</span>
00228 <span class="comment">/*</span>
00229 <span class="comment"> * #define DISPLAYSTR (63 | SYNTAX_MASK) </span>
00230 <span class="comment"> */</span>
00231 <span class="preprocessor">#define BEGIN       64</span>
00232 <span class="preprocessor">#define IMPORTS     65</span>
00233 <span class="preprocessor">#define EXPORTS     66</span>
00234 <span class="preprocessor">#define ACCNOTIFY   67</span>
00235 <span class="preprocessor">#define BAR         68</span>
00236 <span class="preprocessor">#define RANGE       69</span>
00237 <span class="preprocessor">#define CONVENTION  70</span>
00238 <span class="preprocessor">#define DISPLAYHINT 71</span>
00239 <span class="preprocessor">#define FROM        72</span>
00240 <span class="preprocessor">#define AGENTCAP    73</span>
00241 <span class="preprocessor">#define MACRO       74</span>
00242 <span class="preprocessor">#define IMPLIED     75</span>
00243 <span class="preprocessor">#define SUPPORTS    76</span>
00244 <span class="preprocessor">#define INCLUDES    77</span>
00245 <span class="preprocessor">#define VARIATION   78</span>
00246 <span class="preprocessor">#define REVISION    79</span>
00247 <span class="preprocessor">#define NOTIMPL     80</span>
00248 <span class="preprocessor">#define OBJECTS     81</span>
00249 <span class="preprocessor">#define NOTIFICATIONS   82</span>
00250 <span class="preprocessor">#define MODULE      83</span>
00251 <span class="preprocessor">#define MINACCESS   84</span>
00252 <span class="preprocessor">#define PRODREL     85</span>
00253 <span class="preprocessor">#define WRSYNTAX    86</span>
00254 <span class="preprocessor">#define CREATEREQ   87</span>
00255 <span class="preprocessor">#define NOTIFGROUP  88</span>
00256 <span class="preprocessor">#define MANDATORYGROUPS 89</span>
00257 <span class="preprocessor">#define GROUP       90</span>
00258 <span class="preprocessor">#define OBJECT      91</span>
00259 <span class="preprocessor">#define IDENTIFIER  92</span>
00260 <span class="preprocessor">#define CHOICE      93</span>
00261 <span class="preprocessor">#define LEFTSQBRACK     95</span>
00262 <span class="preprocessor">#define RIGHTSQBRACK    96</span>
00263 <span class="preprocessor">#define IMPLICIT    97</span>
00264 <span class="preprocessor">#define APPSYNTAX       (98 | SYNTAX_MASK)</span>
00265 <span class="preprocessor">#define OBJSYNTAX       (99 | SYNTAX_MASK)</span>
00266 <span class="preprocessor">#define SIMPLESYNTAX    (100 | SYNTAX_MASK)</span>
00267 <span class="preprocessor">#define OBJNAME         (101 | SYNTAX_MASK)</span>
00268 <span class="preprocessor">#define NOTIFNAME       (102 | SYNTAX_MASK)</span>
00269 <span class="preprocessor">#define VARIABLES       103</span>
00270 <span class="preprocessor">#define UNSIGNED32      (104 | SYNTAX_MASK)</span>
00271 <span class="preprocessor">#define INTEGER32       (105 | SYNTAX_MASK)</span>
00272 <span class="comment">/*</span>
00273 <span class="comment"> * Beware of reaching SYNTAX_MASK (0x80) </span>
00274 <span class="comment"> */</span>
00275 
00276 <span class="keyword">struct </span>tok {
00277     <span class="keyword">const</span> <span class="keywordtype">char</span>     *name;       <span class=
"comment">/* token name */</span>
00278     <span class="keywordtype">int</span>             len;        <span class="comment">/* length not counting nul */</span>
00279     <span class="keywordtype">int</span>             token;      <span class="comment">/* value */</span>
00280     <span class="keywordtype">int</span>             hash;       <span class="comment">/* hash of name */</span>
00281     <span class="keyword">struct </span>tok     *next;       <span class=
"comment">/* pointer to next in hash table */</span>
00282 };
00283 
00284 
00285 <span class="keyword">static</span> <span class="keyword">struct </span>tok tokens[] = {
00286     {<span class="stringliteral">"obsolete"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"obsolete"</span>) - 1, OBSOLETE}
00287     ,
00288     {<span class="stringliteral">"Opaque"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Opaque"</span>) - 1, KW_OPAQUE}
00289     ,
00290     {<span class="stringliteral">"optional"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"optional"</span>) - 1, KW_OPTIONAL}
00291     ,
00292     {<span class="stringliteral">"LAST-UPDATED"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"LAST-UPDATED"</span>) - 1, LASTUPDATED}
00293     ,
00294     {<span class="stringliteral">"ORGANIZATION"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"ORGANIZATION"</span>) - 1, ORGANIZATION}
00295     ,
00296     {<span class="stringliteral">"CONTACT-INFO"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"CONTACT-INFO"</span>) - 1, CONTACTINFO}
00297     ,
00298     {<span class="stringliteral">"MODULE-IDENTITY"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MODULE-IDENTITY"</span>) - 1, MODULEIDENTITY}
00299     ,
00300     {<span class="stringliteral">"MODULE-COMPLIANCE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MODULE-COMPLIANCE"</span>) - 1, COMPLIANCE}
00301     ,
00302     {<span class="stringliteral">"DEFINITIONS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"DEFINITIONS"</span>) - 1, DEFINITIONS}
00303     ,
00304     {<span class="stringliteral">"END"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"END"</span>) - 1, END}
00305     ,
00306     {<span class="stringliteral">"AUGMENTS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"AUGMENTS"</span>) - 1, AUGMENTS}
00307     ,
00308     {<span class="stringliteral">"not-accessible"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"not-accessible"</span>) - 1, NOACCESS}
00309     ,
00310     {<span class="stringliteral">"write-only"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"write-only"</span>) - 1, WRITEONLY}
00311     ,
00312     {<span class="stringliteral">"NsapAddress"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NsapAddress"</span>) - 1, NSAPADDRESS}
00313     ,
00314     {<span class="stringliteral">"UNITS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Units"</span>) - 1, UNITS}
00315     ,
00316     {<span class="stringliteral">"REFERENCE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"REFERENCE"</span>) - 1, REFERENCE}
00317     ,
00318     {<span class="stringliteral">"NUM-ENTRIES"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NUM-ENTRIES"</span>) - 1, NUM_ENTRIES}
00319     ,
00320     {<span class="stringliteral">"BITSTRING"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"BITSTRING"</span>) - 1, BITSTRING}
00321     ,
00322     {<span class="stringliteral">"BIT"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"BIT"</span>) - 1, CONTINUE}
00323     ,
00324     {<span class="stringliteral">"BITS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"BITS"</span>) - 1, BITSTRING}
00325     ,
00326     {<span class="stringliteral">"Counter64"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Counter64"</span>) - 1, COUNTER64}
00327     ,
00328     {<span class="stringliteral">"TimeTicks"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"TimeTicks"</span>) - 1, TIMETICKS}
00329     ,
00330     {<span class="stringliteral">"NOTIFICATION-TYPE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NOTIFICATION-TYPE"</span>) - 1, NOTIFTYPE}
00331     ,
00332     {<span class="stringliteral">"OBJECT-GROUP"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OBJECT-GROUP"</span>) - 1, OBJGROUP}
00333     ,
00334     {<span class="stringliteral">"OBJECT-IDENTITY"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OBJECT-IDENTITY"</span>) - 1, OBJGROUP}
00335     ,
00336     {<span class="stringliteral">"IDENTIFIER"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"IDENTIFIER"</span>) - 1, IDENTIFIER}
00337     ,
00338     {<span class="stringliteral">"OBJECT"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OBJECT"</span>) - 1, OBJECT}
00339     ,
00340     {<span class="stringliteral">"NetworkAddress"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NetworkAddress"</span>) - 1, NETADDR}
00341     ,
00342     {<span class="stringliteral">"Gauge"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Gauge"</span>) - 1, GAUGE}
00343     ,
00344     {<span class="stringliteral">"Gauge32"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Gauge32"</span>) - 1, GAUGE}
00345     ,
00346     {<span class="stringliteral">"Unsigned32"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Unsigned32"</span>) - 1, UNSIGNED32}
00347     ,
00348     {<span class="stringliteral">"read-write"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"read-write"</span>) - 1, READWRITE}
00349     ,
00350     {<span class="stringliteral">"read-create"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"read-create"</span>) - 1, READCREATE}
00351     ,
00352     {<span class="stringliteral">"OCTETSTRING"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OCTETSTRING"</span>) - 1, OCTETSTR}
00353     ,
00354     {<span class="stringliteral">"OCTET"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OCTET"</span>) - 1, CONTINUE}
00355     ,
00356     {<span class="stringliteral">"OF"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OF"</span>) - 1, OF}
00357     ,
00358     {<span class="stringliteral">"SEQUENCE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"SEQUENCE"</span>) - 1, SEQUENCE}
00359     ,
00360     {<span class="stringliteral">"NULL"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NULL"</span>) - 1, NUL}
00361     ,
00362     {<span class="stringliteral">"IpAddress"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"IpAddress"</span>) - 1, IPADDR}
00363     ,
00364     {<span class="stringliteral">"UInteger32"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"UInteger32"</span>) - 1, UINTEGER32}
00365     ,
00366     {<span class="stringliteral">"INTEGER"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"INTEGER"</span>) - 1, INTEGER}
00367     ,
00368     {<span class="stringliteral">"Integer32"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Integer32"</span>) - 1, INTEGER32}
00369     ,
00370     {<span class="stringliteral">"Counter"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Counter"</span>) - 1, COUNTER}
00371     ,
00372     {<span class="stringliteral">"Counter32"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Counter32"</span>) - 1, COUNTER}
00373     ,
00374     {<span class="stringliteral">"read-only"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"read-only"</span>) - 1, READONLY}
00375     ,
00376     {<span class="stringliteral">"DESCRIPTION"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"DESCRIPTION"</span>) - 1, DESCRIPTION}
00377     ,
00378     {<span class="stringliteral">"INDEX"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"INDEX"</span>) - 1, INDEX}
00379     ,
00380     {<span class="stringliteral">"DEFVAL"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"DEFVAL"</span>) - 1, DEFVAL}
00381     ,
00382     {<span class="stringliteral">"deprecated"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"deprecated"</span>) - 1, DEPRECATED}
00383     ,
00384     {<span class="stringliteral">"SIZE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"SIZE"</span>) - 1, SIZE}
00385     ,
00386     {<span class="stringliteral">"MAX-ACCESS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MAX-ACCESS"</span>) - 1, ACCESS}
00387     ,
00388     {<span class="stringliteral">"ACCESS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"ACCESS"</span>) - 1, ACCESS}
00389     ,
00390     {<span class="stringliteral">"mandatory"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"mandatory"</span>) - 1, MANDATORY}
00391     ,
00392     {<span class="stringliteral">"current"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"current"</span>) - 1, CURRENT}
00393     ,
00394     {<span class="stringliteral">"STATUS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"STATUS"</span>) - 1, STATUS}
00395     ,
00396     {<span class="stringliteral">"SYNTAX"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"SYNTAX"</span>) - 1, SYNTAX}
00397     ,
00398     {<span class="stringliteral">"OBJECT-TYPE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OBJECT-TYPE"</span>) - 1, OBJTYPE}
00399     ,
00400     {<span class="stringliteral">"TRAP-TYPE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"TRAP-TYPE"</span>) - 1, TRAPTYPE}
00401     ,
00402     {<span class="stringliteral">"ENTERPRISE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"ENTERPRISE"</span>) - 1, ENTERPRISE}
00403     ,
00404     {<span class="stringliteral">"BEGIN"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"BEGIN"</span>) - 1, BEGIN}
00405     ,
00406     {<span class="stringliteral">"IMPORTS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"IMPORTS"</span>) - 1, IMPORTS}
00407     ,
00408     {<span class="stringliteral">"EXPORTS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"EXPORTS"</span>) - 1, EXPORTS}
00409     ,
00410     {<span class="stringliteral">"accessible-for-notify"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"accessible-for-notify"</span>) - 1,
00411      ACCNOTIFY}
00412     ,
00413     {<span class="stringliteral">"TEXTUAL-CONVENTION"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"TEXTUAL-CONVENTION"</span>) - 1, CONVENTION}
00414     ,
00415     {<span class="stringliteral">"NOTIFICATION-GROUP"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NOTIFICATION-GROUP"</span>) - 1, NOTIFGROUP}
00416     ,
00417     {<span class="stringliteral">"DISPLAY-HINT"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"DISPLAY-HINT"</span>) - 1, DISPLAYHINT}
00418     ,
00419     {<span class="stringliteral">"FROM"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"FROM"</span>) - 1, FROM}
00420     ,
00421     {<span class="stringliteral">"AGENT-CAPABILITIES"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"AGENT-CAPABILITIES"</span>) - 1, AGENTCAP}
00422     ,
00423     {<span class="stringliteral">"MACRO"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MACRO"</span>) - 1, MACRO}
00424     ,
00425     {<span class="stringliteral">"IMPLIED"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"IMPLIED"</span>) - 1, IMPLIED}
00426     ,
00427     {<span class="stringliteral">"SUPPORTS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"SUPPORTS"</span>) - 1, SUPPORTS}
00428     ,
00429     {<span class="stringliteral">"INCLUDES"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"INCLUDES"</span>) - 1, INCLUDES}
00430     ,
00431     {<span class="stringliteral">"VARIATION"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"VARIATION"</span>) - 1, VARIATION}
00432     ,
00433     {<span class="stringliteral">"REVISION"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"REVISION"</span>) - 1, REVISION}
00434     ,
00435     {<span class="stringliteral">"not-implemented"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"not-implemented"</span>) - 1, NOTIMPL}
00436     ,
00437     {<span class="stringliteral">"OBJECTS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OBJECTS"</span>) - 1, OBJECTS}
00438     ,
00439     {<span class="stringliteral">"NOTIFICATIONS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NOTIFICATIONS"</span>) - 1, NOTIFICATIONS}
00440     ,
00441     {<span class="stringliteral">"MODULE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MODULE"</span>) - 1, MODULE}
00442     ,
00443     {<span class="stringliteral">"MIN-ACCESS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MIN-ACCESS"</span>) - 1, MINACCESS}
00444     ,
00445     {<span class="stringliteral">"PRODUCT-RELEASE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"PRODUCT-RELEASE"</span>) - 1, PRODREL}
00446     ,
00447     {<span class="stringliteral">"WRITE-SYNTAX"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"WRITE-SYNTAX"</span>) - 1, WRSYNTAX}
00448     ,
00449     {<span class="stringliteral">"CREATION-REQUIRES"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"CREATION-REQUIRES"</span>) - 1, CREATEREQ}
00450     ,
00451     {<span class="stringliteral">"MANDATORY-GROUPS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MANDATORY-GROUPS"</span>) - 1, MANDATORYGROUPS}
00452     ,
00453     {<span class="stringliteral">"GROUP"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"GROUP"</span>) - 1, GROUP}
00454     ,
00455     {<span class="stringliteral">"CHOICE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"CHOICE"</span>) - 1, CHOICE}
00456     ,
00457     {<span class="stringliteral">"IMPLICIT"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"IMPLICIT"</span>) - 1, IMPLICIT}
00458     ,
00459     {<span class="stringliteral">"ObjectSyntax"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"ObjectSyntax"</span>) - 1, OBJSYNTAX}
00460     ,
00461     {<span class="stringliteral">"SimpleSyntax"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"SimpleSyntax"</span>) - 1, SIMPLESYNTAX}
00462     ,
00463     {<span class="stringliteral">"ApplicationSyntax"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"ApplicationSyntax"</span>) - 1, APPSYNTAX}
00464     ,
00465     {<span class="stringliteral">"ObjectName"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"ObjectName"</span>) - 1, OBJNAME}
00466     ,
00467     {<span class="stringliteral">"NotificationName"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NotificationName"</span>) - 1, NOTIFNAME}
00468     ,
00469     {<span class="stringliteral">"VARIABLES"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"VARIABLES"</span>) - 1, VARIABLES}
00470     ,
00471     {NULL}
00472 };
00473 
00474 <span class="keyword">static</span> <span class="keyword">struct </span>module_compatability *module_map_head;
00475 <span class="keyword">static</span> <span class="keyword">struct </span>module_compatability module_map[] = {
00476     {<span class="stringliteral">"RFC1065-SMI"</span>, <span class="stringliteral">"RFC1155-SMI"</span>, NULL, 0},
00477     {<span class="stringliteral">"RFC1066-MIB"</span>, <span class="stringliteral">"RFC1156-MIB"</span>, NULL, 0},
00478     <span class="comment">/*</span>
00479 <span class="comment">     * 'mib' -&gt; 'mib-2' </span>
00480 <span class="comment">     */</span>
00481     {<span class="stringliteral">"RFC1156-MIB"</span>, <span class="stringliteral">"RFC1158-MIB"</span>, NULL, 0},
00482     <span class="comment">/*</span>
00483 <span class="comment">     * 'snmpEnableAuthTraps' -&gt; 'snmpEnableAuthenTraps' </span>
00484 <span class="comment">     */</span>
00485     {<span class="stringliteral">"RFC1158-MIB"</span>, <span class="stringliteral">"RFC1213-MIB"</span>, NULL, 0},
00486     <span class="comment">/*</span>
00487 <span class="comment">     * 'nullOID' -&gt; 'zeroDotZero' </span>
00488 <span class="comment">     */</span>
00489     {<span class="stringliteral">"RFC1155-SMI"</span>, <span class="stringliteral">"SNMPv2-SMI"</span>, NULL, 0},
00490     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"SNMPv2-SMI"</span>, <span class=
"stringliteral">"mib-2"</span>, 0},
00491     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"SNMPv2-MIB"</span>, <span class=
"stringliteral">"sys"</span>, 3},
00492     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"IF-MIB"</span>, <span class=
"stringliteral">"if"</span>, 2},
00493     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"IP-MIB"</span>, <span class=
"stringliteral">"ip"</span>, 2},
00494     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"IP-MIB"</span>, <span class=
"stringliteral">"icmp"</span>, 4},
00495     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"TCP-MIB"</span>, <span class=
"stringliteral">"tcp"</span>, 3},
00496     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"UDP-MIB"</span>, <span class=
"stringliteral">"udp"</span>, 3},
00497     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"SNMPv2-SMI"</span>, <span class=
"stringliteral">"transmission"</span>, 0},
00498     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"SNMPv2-MIB"</span>, <span class=
"stringliteral">"snmp"</span>, 4},
00499     {<span class="stringliteral">"RFC1231-MIB"</span>, <span class="stringliteral">"TOKENRING-MIB"</span>, NULL, 0},
00500     {<span class="stringliteral">"RFC1271-MIB"</span>, <span class="stringliteral">"RMON-MIB"</span>, NULL, 0},
00501     {<span class="stringliteral">"RFC1286-MIB"</span>, <span class=
"stringliteral">"SOURCE-ROUTING-MIB"</span>, <span class="stringliteral">"dot1dSr"</span>, 7},
00502     {<span class="stringliteral">"RFC1286-MIB"</span>, <span class="stringliteral">"BRIDGE-MIB"</span>, NULL, 0},
00503     {<span class="stringliteral">"RFC1315-MIB"</span>, <span class="stringliteral">"FRAME-RELAY-DTE-MIB"</span>, NULL, 0},
00504     {<span class="stringliteral">"RFC1316-MIB"</span>, <span class="stringliteral">"CHARACTER-MIB"</span>, NULL, 0},
00505     {<span class="stringliteral">"RFC1406-MIB"</span>, <span class="stringliteral">"DS1-MIB"</span>, NULL, 0},
00506     {<span class="stringliteral">"RFC-1213"</span>, <span class="stringliteral">"RFC1213-MIB"</span>, NULL, 0},
00507 };
00508 
00509 <span class="preprocessor">#define MODULE_NOT_FOUND        0</span>
00510 <span class="preprocessor">#define MODULE_LOADED_OK        1</span>
00511 <span class="preprocessor">#define MODULE_ALREADY_LOADED   2</span>
00512 <span class="comment">/*</span>
00513 <span class="comment"> * #define MODULE_LOAD_FAILED   3       </span>
00514 <span class="comment"> */</span>
00515 <span class="preprocessor">#define MODULE_LOAD_FAILED      MODULE_NOT_FOUND</span>
00516 
00517 
00518 <span class="preprocessor">#define HASHSIZE        32</span>
00519 <span class="preprocessor">#define BUCKET(x)       (x &amp; (HASHSIZE-1))</span>
00520 
00521 <span class="preprocessor">#define NHASHSIZE    128</span>
00522 <span class="preprocessor">#define NBUCKET(x)   (x &amp; (NHASHSIZE-1))</span>
00523 
00524 <span class="keyword">static</span> <span class="keyword">struct </span>tok *buckets[HASHSIZE];
00525 
00526 <span class="keyword">static</span> <span class="keyword">struct </span>node *nbuckets[NHASHSIZE];
00527 <span class="keyword">static</span> <span class="keyword">struct </span>tree *tbuckets[NHASHSIZE];
00528 <span class="keyword">static</span> <span class="keyword">struct </span>module *module_head = NULL;
00529 
00530 <span class="keyword">struct </span>node    *orphan_nodes = NULL;
00531 <span class="keyword">struct </span>tree    *tree_head = NULL;
00532 
00533 <span class="preprocessor">#define NUMBER_OF_ROOT_NODES    3</span>
00534 <span class="keyword">static</span> <span class="keyword">struct </span>module_import root_imports[NUMBER_OF_ROOT_NODES];
00535 
00536 <span class="keyword">static</span> <span class="keywordtype">int</span>      current_module = 0;
00537 <span class="keyword">static</span> <span class="keywordtype">int</span>      max_module = 0;
00538 <span class="keyword">static</span> <span class="keywordtype">char</span>    *last_err_module = 0;    <span class=
"comment">/* no repeats on "Cannot find module..." */</span>
00539 
00540 <span class="keyword">static</span> <span class="keywordtype">void</span>     tree_from_node(<span class=
"keyword">struct</span> tree *tp, <span class="keyword">struct</span> node *np);
00541 <span class="keyword">static</span> <span class="keywordtype">void</span>     do_subtree(<span class=
"keyword">struct</span> tree *, <span class="keyword">struct</span> node **);
00542 <span class="keyword">static</span> <span class="keywordtype">void</span>     do_linkup(<span class=
"keyword">struct</span> module *, <span class="keyword">struct</span> node *);
00543 <span class="keyword">static</span> <span class="keywordtype">void</span>     dump_module_list(<span class=
"keywordtype">void</span>);
00544 <span class="keyword">static</span> <span class="keywordtype">int</span>      get_token(FILE *, <span class=
"keywordtype">char</span> *, <span class="keywordtype">int</span>);
00545 <span class="keyword">static</span> <span class="keywordtype">int</span>      parseQuoteString(FILE *, <span class=
"keywordtype">char</span> *, <span class="keywordtype">int</span>);
00546 <span class="keyword">static</span> <span class="keywordtype">int</span>      tossObjectIdentifier(FILE *);
00547 <span class="keyword">static</span> <span class="keywordtype">int</span>      name_hash(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *);
00548 <span class="keyword">static</span> <span class="keywordtype">void</span>     init_node_hash(<span class=
"keyword">struct</span> node *);
00549 <span class="keyword">static</span> <span class="keywordtype">void</span>     print_error(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *, <span class="keywordtype">int</span>);
00550 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_tree(<span class=
"keyword">struct</span> tree *);
00551 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_partial_tree(<span class=
"keyword">struct</span> tree *, <span class="keywordtype">int</span>);
00552 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_node(<span class=
"keyword">struct</span> node *);
00553 <span class="keyword">static</span> <span class="keywordtype">void</span>     build_translation_table(<span class=
"keywordtype">void</span>);
00554 <span class="keyword">static</span> <span class="keywordtype">void</span>     init_tree_roots(<span class=
"keywordtype">void</span>);
00555 <span class="keyword">static</span> <span class="keywordtype">void</span>     merge_anon_children(<span class=
"keyword">struct</span> tree *, <span class="keyword">struct</span> tree *);
00556 <span class="keyword">static</span> <span class="keywordtype">void</span>     unlink_tbucket(<span class=
"keyword">struct</span> tree *);
00557 <span class="keyword">static</span> <span class="keywordtype">void</span>     unlink_tree(<span class=
"keyword">struct</span> tree *);
00558 <span class="keyword">static</span> <span class="keywordtype">int</span>      getoid(FILE *, <span class=
"keyword">struct</span> subid_s *, <span class="keywordtype">int</span>);
00559 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_objectid(FILE *, <span class=
"keywordtype">char</span> *);
00560 <span class="keyword">static</span> <span class="keywordtype">int</span>      get_tc(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>, <span class=
"keywordtype">int</span> *, <span class="keyword">struct</span> enum_list **,
00561                        <span class="keyword">struct</span> range_list **, <span class="keywordtype">char</span> **);
00562 <span class="keyword">static</span> <span class="keywordtype">int</span>      get_tc_index(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>);
00563 <span class="keyword">static</span> <span class="keyword">struct </span>enum_list *parse_enumlist(FILE *, <span class=
"keyword">struct</span> enum_list **);
00564 <span class="keyword">static</span> <span class="keyword">struct </span>range_list *parse_ranges(FILE * fp, <span class=
"keyword">struct</span> range_list **);
00565 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_asntype(FILE *, <span class=
"keywordtype">char</span> *, <span class="keywordtype">int</span> *, <span class="keywordtype">char</span> *);
00566 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_objecttype(FILE *, <span class=
"keywordtype">char</span> *);
00567 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_objectgroup(FILE *, <span class=
"keywordtype">char</span> *, <span class="keywordtype">int</span>,
00568                                       <span class="keyword">struct</span> objgroup **);
00569 <span class="keyword">static</span> <span class=
"keyword">struct </span>node *parse_notificationDefinition(FILE *, <span class="keywordtype">char</span> *);
00570 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_trapDefinition(FILE *, <span class=
"keywordtype">char</span> *);
00571 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_compliance(FILE *, <span class=
"keywordtype">char</span> *);
00572 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_capabilities(FILE *, <span class=
"keywordtype">char</span> *);
00573 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_moduleIdentity(FILE *, <span class=
"keywordtype">char</span> *);
00574 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_macro(FILE *, <span class=
"keywordtype">char</span> *);
00575 <span class="keyword">static</span> <span class="keywordtype">void</span>     parse_imports(FILE *);
00576 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse(FILE *, <span class=
"keyword">struct</span> node *);
00577 
00578 <span class="keyword">static</span> <span class="keywordtype">int</span>     read_module_internal(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *);
00579 <span class="keyword">static</span> <span class="keywordtype">int</span>     read_module_replacements(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *);
00580 <span class="keyword">static</span> <span class="keywordtype">int</span>     read_import_replacements(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *,
00581                                          <span class="keyword">struct</span> module_import *);
00582 
00583 <span class="keyword">static</span> <span class="keywordtype">void</span>     new_module(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *);
00584 
00585 <span class="keyword">static</span> <span class="keyword">struct </span>node *merge_parse_objectid(<span class=
"keyword">struct</span> node *, FILE *, <span class="keywordtype">char</span> *);
00586 <span class="keyword">static</span> <span class="keyword">struct </span>index_list *getIndexes(FILE * fp, <span class=
"keyword">struct</span> index_list **);
00587 <span class="keyword">static</span> <span class="keyword">struct </span>varbind_list *getVarbinds(FILE * fp, <span class=
"keyword">struct</span> varbind_list **);
00588 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_indexes(<span class=
"keyword">struct</span> index_list **);
00589 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_varbinds(<span class=
"keyword">struct</span> varbind_list **);
00590 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_ranges(<span class=
"keyword">struct</span> range_list **);
00591 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_enums(<span class=
"keyword">struct</span> enum_list **);
00592 <span class="keyword">static</span> <span class="keyword">struct </span>range_list *copy_ranges(<span class=
"keyword">struct</span> range_list *);
00593 <span class="keyword">static</span> <span class="keyword">struct </span>enum_list *copy_enums(<span class=
"keyword">struct</span> enum_list *);
00594 
00595 <span class="keyword">static</span> u_int    compute_match(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *search_base, <span class="keyword">const</span> <span class="keywordtype">char</span> *key);
00596 
00597 <span class="keywordtype">void</span>
00598 snmp_mib_toggle_options_usage(<span class="keyword">const</span> <span class="keywordtype">char</span> *lead, FILE * outf)
00599 {
00600     fprintf(outf, <span class="stringliteral">"%su:  %sallow the use of underlines in MIB symbols\n"</span>,
00601             lead, ((netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
00602                                            NETSNMP_DS_LIB_MIB_PARSE_LABEL)) ?
00603                    <span class="stringliteral">"dis"</span> : <span class="stringliteral">""</span>));
00604     fprintf(outf, <span class="stringliteral">"%sc:  %sallow the use of \"--\" to terminate comments\n"</span>,
00605             lead, ((netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
00606                                            NETSNMP_DS_LIB_MIB_COMMENT_TERM)) ?
00607                    <span class="stringliteral">""</span> : <span class="stringliteral">"dis"</span>));
00608 
00609     fprintf(outf, <span class="stringliteral">"%sd:  %ssave the DESCRIPTIONs of the MIB objects\n"</span>,
00610             lead, ((netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
00611                                            NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) ?
00612                    <span class="stringliteral">"do not "</span> : <span class="stringliteral">""</span>));
00613 
00614     fprintf(outf, <span class="stringliteral">"%se:  disable errors when MIB symbols conflict\n"</span>, lead);
00615 
00616     fprintf(outf, <span class="stringliteral">"%sw:  enable warnings when MIB symbols conflict\n"</span>, lead);
00617 
00618     fprintf(outf, <span class="stringliteral">"%sW:  enable detailed warnings when MIB symbols conflict\n"</span>,
00619             lead);
00620 
00621     fprintf(outf, <span class="stringliteral">"%sR:  replace MIB symbols from latest module\n"</span>, lead);
00622 }
00623 
00624 <span class="keywordtype">char</span>           *
00625 snmp_mib_toggle_options(<span class="keywordtype">char</span> *options)
00626 {
00627     <span class="keywordflow">if</span> (options) {
00628         <span class="keywordflow">while</span> (*options) {
00629             <span class="keywordflow">switch</span> (*options) {
00630             <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
00631                 <a class="code" href=
"group__default__store.html#ga8">netsnmp_ds_set_boolean</a>(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_PARSE_LABEL,
00632                                !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
00633                                                NETSNMP_DS_LIB_MIB_PARSE_LABEL));
00634                 <span class="keywordflow">break</span>;
00635 
00636             <span class="keywordflow">case</span> <span class="charliteral">'c'</span>:
00637                 netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID,
00638                                           NETSNMP_DS_LIB_MIB_COMMENT_TERM);
00639                 <span class="keywordflow">break</span>;
00640 
00641             <span class="keywordflow">case</span> <span class="charliteral">'e'</span>:
00642                 netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID,
00643                                           NETSNMP_DS_LIB_MIB_ERRORS);
00644                 <span class="keywordflow">break</span>;
00645 
00646             <span class="keywordflow">case</span> <span class="charliteral">'w'</span>:
00647                 netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,
00648                                    NETSNMP_DS_LIB_MIB_WARNINGS, 1);
00649                 <span class="keywordflow">break</span>;
00650 
00651             <span class="keywordflow">case</span> <span class="charliteral">'W'</span>:
00652                 netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,
00653                                    NETSNMP_DS_LIB_MIB_WARNINGS, 2);
00654                 <span class="keywordflow">break</span>;
00655 
00656             <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
00657                 netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, 
00658                                           NETSNMP_DS_LIB_SAVE_MIB_DESCRS);
00659                 <span class="keywordflow">break</span>;
00660 
00661             <span class="keywordflow">case</span> <span class="charliteral">'R'</span>:
00662                 netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, 
00663                                           NETSNMP_DS_LIB_MIB_REPLACE);
00664                 <span class="keywordflow">break</span>;
00665 
00666             <span class="keywordflow">default</span>:
00667                 <span class="comment">/*</span>
00668 <span class="comment">                 * return at the unknown option </span>
00669 <span class="comment">                 */</span>
00670                 <span class="keywordflow">return</span> options;
00671             }
00672             options++;
00673         }
00674     }
00675     <span class="keywordflow">return</span> NULL;
00676 }
00677 
00678 <span class="keyword">static</span> <span class="keywordtype">int</span>
00679 name_hash(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00680 {
00681     <span class="keywordtype">int</span>             hash = 0;
00682     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp;
00683 
00684     <span class="keywordflow">if</span> (!name)
00685         <span class="keywordflow">return</span> 0;
00686     <span class="keywordflow">for</span> (cp = name; *cp; cp++)
00687         hash += tolower(*cp);
00688     <span class="keywordflow">return</span> (hash);
00689 }
00690 
00691 <span class="keywordtype">void</span>
00692 init_mib_internals(<span class="keywordtype">void</span>)
00693 {
00694     <span class="keyword">register</span> <span class="keyword">struct </span>tok *tp;
00695     <span class="keyword">register</span> <span class="keywordtype">int</span>    b, i;
00696     <span class="keywordtype">int</span>             max_modc;
00697 
00698     <span class="keywordflow">if</span> (tree_head)
00699         <span class="keywordflow">return</span>;
00700 
00701     <span class="comment">/*</span>
00702 <span class="comment">     * Set up hash list of pre-defined tokens</span>
00703 <span class="comment">     */</span>
00704     memset(buckets, 0, <span class="keyword">sizeof</span>(buckets));
00705     <span class="keywordflow">for</span> (tp = tokens; tp-&gt;name; tp++) {
00706         tp-&gt;hash = name_hash(tp-&gt;name);
00707         b = BUCKET(tp-&gt;hash);
00708         <span class="keywordflow">if</span> (buckets[b])
00709             tp-&gt;next = buckets[b];      <span class="comment">/* BUG ??? */</span>
00710         buckets[b] = tp;
00711     }
00712 
00713     <span class="comment">/*</span>
00714 <span class="comment">     * Initialise other internal structures</span>
00715 <span class="comment">     */</span>
00716 
00717     max_modc = <span class="keyword">sizeof</span>(module_map) / <span class="keyword">sizeof</span>(module_map[0]) - 1;
00718     <span class="keywordflow">for</span> (i = 0; i &lt; max_modc; ++i)
00719         module_map[i].next = &amp;(module_map[i + 1]);
00720     module_map[max_modc].next = NULL;
00721     module_map_head = module_map;
00722 
00723     memset(nbuckets, 0, <span class="keyword">sizeof</span>(nbuckets));
00724     memset(tbuckets, 0, <span class="keyword">sizeof</span>(tbuckets));
00725     memset(tclist, 0, MAXTC * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tc));
00726     build_translation_table();
00727     init_tree_roots();          <span class="comment">/* Set up initial roots */</span>
00728     <span class="comment">/*</span>
00729 <span class="comment">     * Relies on 'add_mibdir' having set up the modules </span>
00730 <span class="comment">     */</span>
00731 }
00732 
00733 <span class="keyword">static</span> <span class="keywordtype">void</span>
00734 init_node_hash(<span class="keyword">struct</span> node *nodes)
00735 {
00736     <span class="keyword">struct </span>node    *np, *nextp;
00737     <span class="keywordtype">int</span>             hash;
00738 
00739     memset(nbuckets, 0, <span class="keyword">sizeof</span>(nbuckets));
00740     <span class="keywordflow">for</span> (np = nodes; np;) {
00741         nextp = np-&gt;next;
00742         hash = NBUCKET(name_hash(np-&gt;parent));
00743         np-&gt;next = nbuckets[hash];
00744         nbuckets[hash] = np;
00745         np = nextp;
00746     }
00747 }
00748 
00749 <span class="keyword">static</span> <span class="keywordtype">int</span>      erroneousMibs = 0;
00750 
00751 <span class="keywordtype">int</span>
00752 get_mib_parse_error_count(<span class="keywordtype">void</span>)
00753 {
00754     <span class="keywordflow">return</span> erroneousMibs;
00755 }
00756 
00757 
00758 <span class="keyword">static</span> <span class="keywordtype">void</span>
00759 print_error(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keywordtype">int</span> type)
00760 {
00761     erroneousMibs++;
00762     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class="stringliteral">"\n"</span>));
00763     <span class="keywordflow">if</span> (type == ENDOFFILE)
00764         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"%s (EOF): At line %d in %s\n"</span>, str, mibLine,
00765                  File);
00766     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token &amp;&amp; *token)
00767         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"%s (%s): At line %d in %s\n"</span>, str, token,
00768                  mibLine, File);
00769     <span class="keywordflow">else</span>
00770         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"%s: At line %d in %s\n"</span>, str, mibLine, File);
00771 }
00772 
00773 <span class="keyword">static</span> <span class="keywordtype">void</span>
00774 print_module_not_found(<span class="keyword">const</span> <span class="keywordtype">char</span> *cp)
00775 {
00776     <span class="keywordflow">if</span> (!last_err_module || strcmp(cp, last_err_module))
00777         print_error(<span class="stringliteral">"Cannot find module"</span>, cp, CONTINUE);
00778     <span class="keywordflow">if</span> (last_err_module)
00779         free(last_err_module);
00780     last_err_module = strdup(cp);
00781 }
00782 
00783 <span class="keyword">static</span> <span class="keyword">struct </span>node *
00784 alloc_node(<span class="keywordtype">int</span> modid)
00785 {
00786     <span class="keyword">struct </span>node    *np;
00787     np = (<span class="keyword">struct </span>node *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> node));
00788     <span class="keywordflow">if</span> (np) {
00789         np-&gt;tc_index = -1;
00790         np-&gt;modid = modid;
00791         np-&gt;filename = strdup(File);
00792         np-&gt;lineno = mibLine;
00793     }
00794     <span class="keywordflow">return</span> np;
00795 }
00796 
00797 <span class="keyword">static</span> <span class="keywordtype">void</span>
00798 unlink_tbucket(<span class="keyword">struct</span> tree *tp)
00799 {
00800     <span class="keywordtype">int</span>             hash = NBUCKET(name_hash(tp-&gt;label));
00801     <span class="keyword">struct </span>tree    *otp = NULL, *ntp = tbuckets[hash];
00802 
00803     <span class="keywordflow">while</span> (ntp &amp;&amp; ntp != tp) {
00804         otp = ntp;
00805         ntp = ntp-&gt;next;
00806     }
00807     <span class="keywordflow">if</span> (!ntp)
00808         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_EMERG, <span class=
"stringliteral">"Can't find %s in tbuckets\n"</span>, tp-&gt;label);
00809     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (otp)
00810         otp-&gt;next = ntp-&gt;next;
00811     <span class="keywordflow">else</span>
00812         tbuckets[hash] = tp-&gt;next;
00813 }
00814 
00815 <span class="keyword">static</span> <span class="keywordtype">void</span>
00816 unlink_tree(<span class="keyword">struct</span> tree *tp)
00817 {
00818     <span class="keyword">struct </span>tree    *otp = NULL, *ntp = tp-&gt;parent;
00819 
00820     <span class="keywordflow">if</span> (!ntp) {                 <span class="comment">/* this tree has no parent */</span>
00821         DEBUGMSGTL((<span class="stringliteral">"unlink_tree"</span>, <span class=
"stringliteral">"Tree node %s has no parent\n"</span>,
00822                     tp-&gt;label));
00823     } <span class="keywordflow">else</span> {
00824         ntp = ntp-&gt;child_list;
00825 
00826         <span class="keywordflow">while</span> (ntp &amp;&amp; ntp != tp) {
00827             otp = ntp;
00828             ntp = ntp-&gt;next_peer;
00829         }
00830         <span class="keywordflow">if</span> (!ntp)
00831             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_EMERG, <span class=
"stringliteral">"Can't find %s in %s's children\n"</span>,
00832                      tp-&gt;label, tp-&gt;parent-&gt;label);
00833         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (otp)
00834             otp-&gt;next_peer = ntp-&gt;next_peer;
00835         <span class="keywordflow">else</span>
00836             tp-&gt;parent-&gt;child_list = tp-&gt;next_peer;
00837     }
00838 
00839     <span class="keywordflow">if</span> (tree_head == tp)
00840         tree_head = tp-&gt;next_peer;
00841 }
00842 
00843 <span class="keyword">static</span> <span class="keywordtype">void</span>
00844 free_partial_tree(<span class="keyword">struct</span> tree *tp, <span class="keywordtype">int</span> keep_label)
00845 {
00846     <span class="keywordflow">if</span> (!tp)
00847         <span class="keywordflow">return</span>;
00848 
00849     <span class="comment">/*</span>
00850 <span class="comment">     * remove the data from this tree node </span>
00851 <span class="comment">     */</span>
00852     free_enums(&amp;tp-&gt;enums);
00853     free_ranges(&amp;tp-&gt;ranges);
00854     free_indexes(&amp;tp-&gt;indexes);
00855     free_varbinds(&amp;tp-&gt;varbinds);
00856     <span class="keywordflow">if</span> (!keep_label)
00857         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;label);
00858     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;hint);
00859     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;units);
00860     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;description);
00861     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;reference);
00862     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;augments);
00863     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;defaultValue);
00864 }
00865 
00866 <span class="comment">/*</span>
00867 <span class="comment"> * free a tree node. Note: the node must already have been unlinked</span>
00868 <span class="comment"> * from the tree when calling this routine</span>
00869 <span class="comment"> */</span>
00870 <span class="keyword">static</span> <span class="keywordtype">void</span>
00871 free_tree(<span class="keyword">struct</span> tree *Tree)
00872 {
00873     <span class="keywordflow">if</span> (!Tree)
00874         <span class="keywordflow">return</span>;
00875 
00876     unlink_tbucket(Tree);
00877     free_partial_tree(Tree, FALSE);
00878     <span class="keywordflow">if</span> (Tree-&gt;number_modules &gt; 1)
00879         free((<span class="keywordtype">char</span> *) Tree-&gt;module_list);
00880     free((<span class="keywordtype">char</span> *) Tree);
00881 }
00882 
00883 <span class="keyword">static</span> <span class="keywordtype">void</span>
00884 free_node(<span class="keyword">struct</span> node *np)
00885 {
00886     <span class="keywordflow">if</span> (!np)
00887         <span class="keywordflow">return</span>;
00888 
00889     free_enums(&amp;np-&gt;enums);
00890     free_ranges(&amp;np-&gt;ranges);
00891     free_indexes(&amp;np-&gt;indexes);
00892     free_varbinds(&amp;np-&gt;varbinds);
00893     <span class="keywordflow">if</span> (np-&gt;label)
00894         free(np-&gt;label);
00895     <span class="keywordflow">if</span> (np-&gt;hint)
00896         free(np-&gt;hint);
00897     <span class="keywordflow">if</span> (np-&gt;units)
00898         free(np-&gt;units);
00899     <span class="keywordflow">if</span> (np-&gt;description)
00900         free(np-&gt;description);
00901     <span class="keywordflow">if</span> (np-&gt;reference)
00902         free(np-&gt;reference);
00903     <span class="keywordflow">if</span> (np-&gt;defaultValue)
00904         free(np-&gt;defaultValue);
00905     <span class="keywordflow">if</span> (np-&gt;parent)
00906         free(np-&gt;parent);
00907     <span class="keywordflow">if</span> (np-&gt;augments)
00908         free(np-&gt;augments);
00909     <span class="keywordflow">if</span> (np-&gt;filename)
00910         free(np-&gt;filename);
00911     free((<span class="keywordtype">char</span> *) np);
00912 }
00913 
00914 <span class="preprocessor">#ifdef TEST</span>
00915 <span class="keyword">static</span> <span class="keywordtype">void</span>
00916 print_nodes(FILE * fp, <span class="keyword">struct</span> node *root)
00917 {
00918     <span class="keyword">extern</span> <span class="keywordtype">void</span>     xmalloc_stats(FILE *);
00919     <span class="keyword">struct </span>enum_list *ep;
00920     <span class="keyword">struct </span>index_list *ip;
00921     <span class="keyword">struct </span>range_list *rp;
00922     <span class="keyword">struct </span>varbind_list *vp;
00923     <span class="keyword">struct </span>node    *np;
00924 
00925     <span class="keywordflow">for</span> (np = root; np; np = np-&gt;next) {
00926         fprintf(fp, <span class="stringliteral">"%s ::= { %s %ld } (%d)\n"</span>, np-&gt;label, np-&gt;parent,
00927                 np-&gt;subid, np-&gt;type);
00928         <span class="keywordflow">if</span> (np-&gt;tc_index &gt;= 0)
00929             fprintf(fp, <span class="stringliteral">"  TC = %s\n"</span>, tclist[np-&gt;tc_index].descriptor);
00930         <span class="keywordflow">if</span> (np-&gt;enums) {
00931             fprintf(fp, <span class="stringliteral">"  Enums: \n"</span>);
00932             <span class="keywordflow">for</span> (ep = np-&gt;enums; ep; ep = ep-&gt;next) {
00933                 fprintf(fp, <span class="stringliteral">"    %s(%d)\n"</span>, ep-&gt;label, ep-&gt;value);
00934             }
00935         }
00936         <span class="keywordflow">if</span> (np-&gt;ranges) {
00937             fprintf(fp, <span class="stringliteral">"  Ranges: \n"</span>);
00938             <span class="keywordflow">for</span> (rp = np-&gt;ranges; rp; rp = rp-&gt;next) {
00939                 fprintf(fp, <span class="stringliteral">"    %d..%d\n"</span>, rp-&gt;low, rp-&gt;high);
00940             }
00941         }
00942         <span class="keywordflow">if</span> (np-&gt;indexes) {
00943             fprintf(fp, <span class="stringliteral">"  Indexes: \n"</span>);
00944             <span class="keywordflow">for</span> (ip = np-&gt;indexes; ip; ip = ip-&gt;next) {
00945                 fprintf(fp, <span class="stringliteral">"    %s\n"</span>, ip-&gt;ilabel);
00946             }
00947         }
00948         <span class="keywordflow">if</span> (np-&gt;augments)
00949             fprintf(fp, <span class="stringliteral">"  Augments: %s\n"</span>, np-&gt;augments);
00950         <span class="keywordflow">if</span> (np-&gt;varbinds) {
00951             fprintf(fp, <span class="stringliteral">"  Varbinds: \n"</span>);
00952             <span class="keywordflow">for</span> (vp = np-&gt;varbinds; vp; vp = vp-&gt;next) {
00953                 fprintf(fp, <span class="stringliteral">"    %s\n"</span>, vp-&gt;vblabel);
00954             }
00955         }
00956         <span class="keywordflow">if</span> (np-&gt;hint)
00957             fprintf(fp, <span class="stringliteral">"  Hint: %s\n"</span>, np-&gt;hint);
00958         <span class="keywordflow">if</span> (np-&gt;units)
00959             fprintf(fp, <span class="stringliteral">"  Units: %s\n"</span>, np-&gt;units);
00960         <span class="keywordflow">if</span> (np-&gt;defaultValue)
00961             fprintf(fp, <span class="stringliteral">"  DefaultValue: %s\n"</span>, np-&gt;defaultValue);
00962     }
00963 }
00964 <span class="preprocessor">#endif</span>
00965 
00966 <span class="keywordtype">void</span>
00967 print_subtree(FILE * f, <span class="keyword">struct</span> tree *tree, <span class="keywordtype">int</span> count)
00968 {
00969     <span class="keyword">struct </span>tree    *tp;
00970     <span class="keywordtype">int</span>             i;
00971     <span class="keywordtype">char</span>            modbuf[256];
00972 
00973     <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
00974         fprintf(f, <span class="stringliteral">"  "</span>);
00975     fprintf(f, <span class="stringliteral">"Children of %s(%ld):\n"</span>, tree-&gt;label, tree-&gt;subid);
00976     count++;
00977     <span class="keywordflow">for</span> (tp = tree-&gt;child_list; tp; tp = tp-&gt;next_peer) {
00978         <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
00979             fprintf(f, <span class="stringliteral">"  "</span>);
00980         fprintf(f, <span class="stringliteral">"%s:%s(%ld) type=%d"</span>,
00981                 module_name(tp-&gt;module_list[0], modbuf),
00982                 tp-&gt;label, tp-&gt;subid, tp-&gt;type);
00983         <span class="keywordflow">if</span> (tp-&gt;tc_index != -1)
00984             fprintf(f, <span class="stringliteral">" tc=%d"</span>, tp-&gt;tc_index);
00985         <span class="keywordflow">if</span> (tp-&gt;hint)
00986             fprintf(f, <span class="stringliteral">" hint=%s"</span>, tp-&gt;hint);
00987         <span class="keywordflow">if</span> (tp-&gt;units)
00988             fprintf(f, <span class="stringliteral">" units=%s"</span>, tp-&gt;units);
00989         <span class="keywordflow">if</span> (tp-&gt;number_modules &gt; 1) {
00990             fprintf(f, <span class="stringliteral">" modules:"</span>);
00991             <span class="keywordflow">for</span> (i = 1; i &lt; tp-&gt;number_modules; i++)
00992                 fprintf(f, <span class="stringliteral">" %s"</span>, module_name(tp-&gt;module_list[i], modbuf));
00993         }
00994         fprintf(f, <span class="stringliteral">"\n"</span>);
00995     }
00996     <span class="keywordflow">for</span> (tp = tree-&gt;child_list; tp; tp = tp-&gt;next_peer) {
00997         <span class="keywordflow">if</span> (tp-&gt;child_list)
00998             print_subtree(f, tp, count);
00999     }
01000 }
01001 
01002 <span class="keywordtype">void</span>
01003 print_ascii_dump_tree(FILE * f, <span class="keyword">struct</span> tree *tree, <span class="keywordtype">int</span> count)
01004 {
01005     <span class="keyword">struct </span>tree    *tp;
01006 
01007     count++;
01008     <span class="keywordflow">for</span> (tp = tree-&gt;child_list; tp; tp = tp-&gt;next_peer) {
01009         fprintf(f, <span class="stringliteral">"%s OBJECT IDENTIFIER ::= { %s %ld }\n"</span>, tp-&gt;label,
01010                 tree-&gt;label, tp-&gt;subid);
01011     }
01012     <span class="keywordflow">for</span> (tp = tree-&gt;child_list; tp; tp = tp-&gt;next_peer) {
01013         <span class="keywordflow">if</span> (tp-&gt;child_list)
01014             print_ascii_dump_tree(f, tp, count);
01015     }
01016 }
01017 
01018 <span class="keyword">static</span> <span class="keywordtype">int</span>      translation_table[256];
01019 
01020 <span class="keyword">static</span> <span class="keywordtype">void</span>
01021 build_translation_table()
01022 {
01023     <span class="keywordtype">int</span>             count;
01024 
01025     <span class="keywordflow">for</span> (count = 0; count &lt; 256; count++) {
01026         <span class="keywordflow">switch</span> (count) {
01027         <span class="keywordflow">case</span> OBJID:
01028             translation_table[count] = TYPE_OBJID;
01029             <span class="keywordflow">break</span>;
01030         <span class="keywordflow">case</span> OCTETSTR:
01031             translation_table[count] = TYPE_OCTETSTR;
01032             <span class="keywordflow">break</span>;
01033         <span class="keywordflow">case</span> INTEGER:
01034             translation_table[count] = TYPE_INTEGER;
01035             <span class="keywordflow">break</span>;
01036         <span class="keywordflow">case</span> NETADDR:
01037             translation_table[count] = TYPE_NETADDR;
01038             <span class="keywordflow">break</span>;
01039         <span class="keywordflow">case</span> IPADDR:
01040             translation_table[count] = TYPE_IPADDR;
01041             <span class="keywordflow">break</span>;
01042         <span class="keywordflow">case</span> COUNTER:
01043             translation_table[count] = TYPE_COUNTER;
01044             <span class="keywordflow">break</span>;
01045         <span class="keywordflow">case</span> GAUGE:
01046             translation_table[count] = TYPE_GAUGE;
01047             <span class="keywordflow">break</span>;
01048         <span class="keywordflow">case</span> TIMETICKS:
01049             translation_table[count] = TYPE_TIMETICKS;
01050             <span class="keywordflow">break</span>;
01051         <span class="keywordflow">case</span> KW_OPAQUE:
01052             translation_table[count] = TYPE_OPAQUE;
01053             <span class="keywordflow">break</span>;
01054         <span class="keywordflow">case</span> NUL:
01055             translation_table[count] = TYPE_NULL;
01056             <span class="keywordflow">break</span>;
01057         <span class="keywordflow">case</span> COUNTER64:
01058             translation_table[count] = TYPE_COUNTER64;
01059             <span class="keywordflow">break</span>;
01060         <span class="keywordflow">case</span> BITSTRING:
01061             translation_table[count] = TYPE_BITSTRING;
01062             <span class="keywordflow">break</span>;
01063         <span class="keywordflow">case</span> NSAPADDRESS:
01064             translation_table[count] = TYPE_NSAPADDRESS;
01065             <span class="keywordflow">break</span>;
01066         <span class="keywordflow">case</span> INTEGER32:
01067             translation_table[count] = TYPE_INTEGER32;
01068             <span class="keywordflow">break</span>;
01069         <span class="keywordflow">case</span> UINTEGER32:
01070             translation_table[count] = TYPE_UINTEGER;
01071             <span class="keywordflow">break</span>;
01072         <span class="keywordflow">case</span> UNSIGNED32:
01073             translation_table[count] = TYPE_UNSIGNED32;
01074             <span class="keywordflow">break</span>;
01075         <span class="keywordflow">case</span> TRAPTYPE:
01076             translation_table[count] = TYPE_TRAPTYPE;
01077             <span class="keywordflow">break</span>;
01078         <span class="keywordflow">case</span> NOTIFTYPE:
01079             translation_table[count] = TYPE_NOTIFTYPE;
01080             <span class="keywordflow">break</span>;
01081         <span class="keywordflow">case</span> OBJGROUP:
01082             translation_table[count] = TYPE_OBJGROUP;
01083             <span class="keywordflow">break</span>;
01084         <span class="keywordflow">case</span> MODULEIDENTITY:
01085             translation_table[count] = TYPE_MODID;
01086             <span class="keywordflow">break</span>;
01087         <span class="keywordflow">case</span> AGENTCAP:
01088             translation_table[count] = TYPE_AGENTCAP;
01089             <span class="keywordflow">break</span>;
01090         <span class="keywordflow">case</span> COMPLIANCE:
01091             translation_table[count] = TYPE_MODCOMP;
01092             <span class="keywordflow">break</span>;
01093         <span class="keywordflow">default</span>:
01094             translation_table[count] = TYPE_OTHER;
01095             <span class="keywordflow">break</span>;
01096         }
01097     }
01098 }
01099 
01100 <span class="keyword">static</span> <span class="keywordtype">void</span>
01101 init_tree_roots()
01102 {
01103     <span class="keyword">struct </span>tree    *tp, *lasttp;
01104     <span class="keywordtype">int</span>             base_modid;
01105     <span class="keywordtype">int</span>             hash;
01106 
01107     base_modid = which_module(<span class="stringliteral">"SNMPv2-SMI"</span>);
01108     <span class="keywordflow">if</span> (base_modid == -1)
01109         base_modid = which_module(<span class="stringliteral">"RFC1155-SMI"</span>);
01110     <span class="keywordflow">if</span> (base_modid == -1)
01111         base_modid = which_module(<span class="stringliteral">"RFC1213-MIB"</span>);
01112 
01113     <span class="comment">/*</span>
01114 <span class="comment">     * build root node </span>
01115 <span class="comment">     */</span>
01116     tp = (<span class="keyword">struct </span>tree *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> tree));
01117     <span class="keywordflow">if</span> (tp == NULL)
01118         <span class="keywordflow">return</span>;
01119     tp-&gt;label = strdup(<span class="stringliteral">"joint-iso-ccitt"</span>);
01120     tp-&gt;modid = base_modid;
01121     tp-&gt;number_modules = 1;
01122     tp-&gt;module_list = &amp;(tp-&gt;modid);
01123     tp-&gt;subid = 2;
01124     tp-&gt;tc_index = -1;
01125     <a class="code" href="group__mib__utilities.html#ga61">set_function</a>(tp);           <span class=
"comment">/* from mib.c */</span>
01126     hash = NBUCKET(name_hash(tp-&gt;label));
01127     tp-&gt;next = tbuckets[hash];
01128     tbuckets[hash] = tp;
01129     lasttp = tp;
01130     root_imports[0].label = strdup(tp-&gt;label);
01131     root_imports[0].modid = base_modid;
01132 
01133     <span class="comment">/*</span>
01134 <span class="comment">     * build root node </span>
01135 <span class="comment">     */</span>
01136     tp = (<span class="keyword">struct </span>tree *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> tree));
01137     <span class="keywordflow">if</span> (tp == NULL)
01138         <span class="keywordflow">return</span>;
01139     tp-&gt;next_peer = lasttp;
01140     tp-&gt;label = strdup(<span class="stringliteral">"ccitt"</span>);
01141     tp-&gt;modid = base_modid;
01142     tp-&gt;number_modules = 1;
01143     tp-&gt;module_list = &amp;(tp-&gt;modid);
01144     tp-&gt;subid = 0;
01145     tp-&gt;tc_index = -1;
01146     <a class="code" href="group__mib__utilities.html#ga61">set_function</a>(tp);           <span class=
"comment">/* from mib.c */</span>
01147     hash = NBUCKET(name_hash(tp-&gt;label));
01148     tp-&gt;next = tbuckets[hash];
01149     tbuckets[hash] = tp;
01150     lasttp = tp;
01151     root_imports[1].label = strdup(tp-&gt;label);
01152     root_imports[1].modid = base_modid;
01153 
01154     <span class="comment">/*</span>
01155 <span class="comment">     * build root node </span>
01156 <span class="comment">     */</span>
01157     tp = (<span class="keyword">struct </span>tree *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> tree));
01158     <span class="keywordflow">if</span> (tp == NULL)
01159         <span class="keywordflow">return</span>;
01160     tp-&gt;next_peer = lasttp;
01161     tp-&gt;label = strdup(<span class="stringliteral">"iso"</span>);
01162     tp-&gt;modid = base_modid;
01163     tp-&gt;number_modules = 1;
01164     tp-&gt;module_list = &amp;(tp-&gt;modid);
01165     tp-&gt;subid = 1;
01166     tp-&gt;tc_index = -1;
01167     <a class="code" href="group__mib__utilities.html#ga61">set_function</a>(tp);           <span class=
"comment">/* from mib.c */</span>
01168     hash = NBUCKET(name_hash(tp-&gt;label));
01169     tp-&gt;next = tbuckets[hash];
01170     tbuckets[hash] = tp;
01171     lasttp = tp;
01172     root_imports[2].label = strdup(tp-&gt;label);
01173     root_imports[2].modid = base_modid;
01174 
01175     tree_head = tp;
01176 }
01177 
01178 <span class="preprocessor">#ifdef STRICT_MIB_PARSEING</span>
01179 <span class="preprocessor">#define label_compare   strcasecmp</span>
01180 <span class="preprocessor">#else</span>
01181 <span class="preprocessor">#define label_compare   strcmp</span>
01182 <span class="preprocessor">#endif</span>
01183 
01184 
01185 <span class="keyword">struct </span>tree    *
01186 find_tree_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class=
"keywordtype">int</span> modid)
01187 {
01188     <span class="keyword">struct </span>tree    *tp, *headtp;
01189     <span class="keywordtype">int</span>             count, *int_p;
01190 
01191     <span class="keywordflow">if</span> (!name || !*name)
01192         <span class="keywordflow">return</span> (NULL);
01193 
01194     headtp = tbuckets[NBUCKET(name_hash(name))];
01195     <span class="keywordflow">for</span> (tp = headtp; tp; tp = tp-&gt;next) {
01196         <span class="keywordflow">if</span> (tp-&gt;label &amp;&amp; !label_compare(tp-&gt;label, name)) {
01197 
01198             <span class="keywordflow">if</span> (modid == -1)    <span class="comment">/* Any module */</span>
01199                 <span class="keywordflow">return</span> (tp);
01200 
01201             <span class="keywordflow">for</span> (int_p = tp-&gt;module_list, count = 0;
01202                  count &lt; tp-&gt;number_modules; ++count, ++int_p)
01203                 <span class="keywordflow">if</span> (*int_p == modid)
01204                     <span class="keywordflow">return</span> (tp);
01205         }
01206     }
01207 
01208     <span class="keywordflow">return</span> (NULL);
01209 }
01210 
01211 <span class="comment">/*</span>
01212 <span class="comment"> * computes a value which represents how close name1 is to name2.</span>
01213 <span class="comment"> * * high scores mean a worse match.</span>
01214 <span class="comment"> * * (yes, the algorithm sucks!)</span>
01215 <span class="comment"> */</span>
01216 <span class="preprocessor">#define MAX_BAD 0xffffff</span>
01217 
01218 <span class="keyword">static</span>          u_int
01219 compute_match(<span class="keyword">const</span> <span class="keywordtype">char</span> *search_base, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *key)
01220 {
01221 <span class="preprocessor">#if defined(HAVE_REGEX_H) &amp;&amp; defined(HAVE_REGCOMP)</span>
01222     <span class="keywordtype">int</span>             rc;
01223     regex_t         parsetree;
01224     regmatch_t      pmatch;
01225     rc = regcomp(&amp;parsetree, key, REG_ICASE | REG_EXTENDED);
01226     <span class="keywordflow">if</span> (rc == 0)
01227         rc = regexec(&amp;parsetree, search_base, 1, &amp;pmatch, 0);
01228     regfree(&amp;parsetree);
01229     <span class="keywordflow">if</span> (rc == 0) {
01230         <span class="comment">/*</span>
01231 <span class="comment">         * found </span>
01232 <span class="comment">         */</span>
01233         <span class="keywordflow">return</span> pmatch.rm_so;
01234     }
01235 <span class="preprocessor">#else                           </span><span class=
"comment">/* use our own wildcard matcher */</span>
01236     <span class="comment">/*</span>
01237 <span class="comment">     * first find the longest matching substring (ick) </span>
01238 <span class="comment">     */</span>
01239     <span class="keywordtype">char</span>           *first = NULL, *result = NULL, *entry;
01240     <span class="keyword">const</span> <span class="keywordtype">char</span>     *position;
01241     <span class="keywordtype">char</span>           *newkey = strdup(key);
01242     <span class="keywordtype">char</span>           *st;
01243 
01244 
01245     entry = strtok_r(newkey, <span class="stringliteral">"*"</span>, &amp;st);
01246     position = search_base;
01247     <span class="keywordflow">while</span> (entry) {
01248         result = strcasestr(position, entry);
01249 
01250         <span class="keywordflow">if</span> (result == NULL) {
01251             free(newkey);
01252             <span class="keywordflow">return</span> MAX_BAD;
01253         }
01254 
01255         <span class="keywordflow">if</span> (first == NULL)
01256             first = result;
01257 
01258         position = result + strlen(entry);
01259         entry = strtok_r(NULL, <span class="stringliteral">"*"</span>, &amp;st);
01260     }
01261     free(newkey);
01262     <span class="keywordflow">if</span> (result)
01263         <span class="keywordflow">return</span> (first - search_base);
01264 <span class="preprocessor">#endif</span>
01265 
01266     <span class="comment">/*</span>
01267 <span class="comment">     * not found </span>
01268 <span class="comment">     */</span>
01269     <span class="keywordflow">return</span> MAX_BAD;
01270 }
01271 
01272 <span class="comment">/*</span>
01273 <span class="comment"> * Find the tree node that best matches the pattern string.</span>
01274 <span class="comment"> * Use the "reported" flag such that only one match</span>
01275 <span class="comment"> * is attempted for every node.</span>
01276 <span class="comment"> *</span>
01277 <span class="comment"> * Warning! This function may recurse.</span>
01278 <span class="comment"> *</span>
01279 <span class="comment"> * Caller _must_ invoke clear_tree_flags before first call</span>
01280 <span class="comment"> * to this function.  This function may be called multiple times</span>
01281 <span class="comment"> * to ensure that the entire tree is traversed.</span>
01282 <span class="comment"> */</span>
01283 
01284 <span class="keyword">struct </span>tree    *
01285 find_best_tree_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *pattrn, <span class=
"keyword">struct</span> tree *tree_top,
01286                     u_int * match)
01287 {
01288     <span class="keyword">struct </span>tree    *tp, *best_so_far = NULL, *retptr;
01289     u_int           old_match = MAX_BAD, new_match = MAX_BAD;
01290 
01291     <span class="keywordflow">if</span> (!pattrn || !*pattrn)
01292         <span class="keywordflow">return</span> (NULL);
01293 
01294     <span class="keywordflow">if</span> (!tree_top)
01295         tree_top = <a class="code" href="group__mib__utilities.html#ga46">get_tree_head</a>();
01296 
01297     <span class="keywordflow">for</span> (tp = tree_top; tp; tp = tp-&gt;next_peer) {
01298         <span class="keywordflow">if</span> (!tp-&gt;reported &amp;&amp; tp-&gt;label)
01299             new_match = compute_match(tp-&gt;label, pattrn);
01300         tp-&gt;reported = 1;
01301 
01302         <span class="keywordflow">if</span> (new_match &lt; old_match) {
01303             best_so_far = tp;
01304             old_match = new_match;
01305         }
01306         <span class="keywordflow">if</span> (new_match == 0)
01307             <span class="keywordflow">break</span>;              <span class=
"comment">/* this is the best result we can get */</span>
01308         <span class="keywordflow">if</span> (tp-&gt;child_list) {
01309             retptr =
01310                 find_best_tree_node(pattrn, tp-&gt;child_list, &amp;new_match);
01311             <span class="keywordflow">if</span> (new_match &lt; old_match) {
01312                 best_so_far = retptr;
01313                 old_match = new_match;
01314             }
01315             <span class="keywordflow">if</span> (new_match == 0)
01316                 <span class="keywordflow">break</span>;          <span class=
"comment">/* this is the best result we can get */</span>
01317         }
01318     }
01319     <span class="keywordflow">if</span> (match)
01320         *match = old_match;
01321     <span class="keywordflow">return</span> (best_so_far);
01322 }
01323 
01324 
01325 <span class="keyword">static</span> <span class="keywordtype">void</span>
01326 merge_anon_children(<span class="keyword">struct</span> tree *tp1, <span class="keyword">struct</span> tree *tp2)
01327                 <span class="comment">/*</span>
01328 <span class="comment">                 * NB: tp1 is the 'anonymous' node </span>
01329 <span class="comment">                 */</span>
01330 {
01331     <span class="keyword">struct </span>tree    *child1, *child2, *previous;
01332 
01333     <span class="keywordflow">for</span> (child1 = tp1-&gt;child_list; child1;) {
01334 
01335         <span class="keywordflow">for</span> (child2 = tp2-&gt;child_list, previous = NULL;
01336              child2; previous = child2, child2 = child2-&gt;next_peer) {
01337 
01338             <span class="keywordflow">if</span> (child1-&gt;subid == child2-&gt;subid) {
01339                 <span class="comment">/*</span>
01340 <span class="comment">                 * Found 'matching' children,</span>
01341 <span class="comment">                 *  so merge them</span>
01342 <span class="comment">                 */</span>
01343                 <span class="keywordflow">if</span> (!strncmp(child1-&gt;label, ANON, ANON_LEN)) {
01344                     merge_anon_children(child1, child2);
01345 
01346                     child1-&gt;child_list = NULL;
01347                     previous = child1;  <span class="comment">/* Finished with 'child1' */</span>
01348                     child1 = child1-&gt;next_peer;
01349                     free_tree(previous);
01350                     <span class="keywordflow">goto</span> next;
01351                 }
01352 
01353                 <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (!strncmp(child2-&gt;label, ANON, ANON_LEN)) {
01354                     merge_anon_children(child2, child1);
01355 
01356                     <span class="keywordflow">if</span> (previous)
01357                         previous-&gt;next_peer = child2-&gt;next_peer;
01358                     <span class="keywordflow">else</span>
01359                         tp2-&gt;child_list = child2-&gt;next_peer;
01360                     free_tree(child2);
01361 
01362                     previous = child1;  <span class="comment">/* Move 'child1' to 'tp2' */</span>
01363                     child1 = child1-&gt;next_peer;
01364                     previous-&gt;next_peer = tp2-&gt;child_list;
01365                     tp2-&gt;child_list = previous;
01366                     <span class="keywordflow">for</span> (previous = tp2-&gt;child_list;
01367                          previous; previous = previous-&gt;next_peer)
01368                         previous-&gt;parent = tp2;
01369                     <span class="keywordflow">goto</span> next;
01370                 } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (!label_compare(child1-&gt;label, child2-&gt;label)) {
01371                     <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
01372                                            NETSNMP_DS_LIB_MIB_WARNINGS)) {
01373                         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
01374                                  <span class="stringliteral">"Warning: %s.%ld is both %s and %s (%s)\n"</span>,
01375                                  tp2-&gt;label, child1-&gt;subid, child1-&gt;label,
01376                                  child2-&gt;label, File);
01377                     }
01378                     <span class="keywordflow">continue</span>;
01379                 } <span class="keywordflow">else</span> {
01380                     <span class="comment">/*</span>
01381 <span class="comment">                     * Two copies of the same node.</span>
01382 <span class="comment">                     * 'child2' adopts the children of 'child1'</span>
01383 <span class="comment">                     */</span>
01384 
01385                     <span class="keywordflow">if</span> (child2-&gt;child_list) {
01386                         <span class=
"keywordflow">for</span> (previous = child2-&gt;child_list; previous-&gt;next_peer; previous = previous-&gt;next_peer);       <span class="comment">/* Find the end of the list */</span>
01387                         previous-&gt;next_peer = child1-&gt;child_list;
01388                     } <span class="keywordflow">else</span>
01389                         child2-&gt;child_list = child1-&gt;child_list;
01390                     <span class="keywordflow">for</span> (previous = child1-&gt;child_list;
01391                          previous; previous = previous-&gt;next_peer)
01392                         previous-&gt;parent = child2;
01393                     child1-&gt;child_list = NULL;
01394 
01395                     previous = child1;  <span class="comment">/* Finished with 'child1' */</span>
01396                     child1 = child1-&gt;next_peer;
01397                     free_tree(previous);
01398                     <span class="keywordflow">goto</span> next;
01399                 }
01400             }
01401         }
01402         <span class="comment">/*</span>
01403 <span class="comment">         * If no match, move 'child1' to 'tp2' child_list</span>
01404 <span class="comment">         */</span>
01405         <span class="keywordflow">if</span> (child1) {
01406             previous = child1;
01407             child1 = child1-&gt;next_peer;
01408             previous-&gt;parent = tp2;
01409             previous-&gt;next_peer = tp2-&gt;child_list;
01410             tp2-&gt;child_list = previous;
01411         }
01412       next:;
01413     }
01414 }
01415 
01416 
01417 <span class="comment">/*</span>
01418 <span class="comment"> * Find all the children of root in the list of nodes.  Link them into the</span>
01419 <span class="comment"> * tree and out of the nodes list.</span>
01420 <span class="comment"> */</span>
01421 <span class="keyword">static</span> <span class="keywordtype">void</span>
01422 do_subtree(<span class="keyword">struct</span> tree *root, <span class="keyword">struct</span> node **nodes)
01423 {
01424     <span class="keyword">struct </span>tree    *tp, *anon_tp = NULL;
01425     <span class="keyword">struct </span>tree    *xroot = root;
01426     <span class="keyword">struct </span>node    *np, **headp;
01427     <span class="keyword">struct </span>node    *oldnp = NULL, *child_list = NULL, *childp = NULL;
01428     <span class="keywordtype">int</span>             hash;
01429     <span class="keywordtype">int</span>            *int_p;
01430 
01431     <span class=
"keywordflow">while</span> (xroot-&gt;next_peer &amp;&amp; xroot-&gt;next_peer-&gt;subid == root-&gt;subid) {
01432 <span class="preprocessor">#if 0</span>
01433         printf(<span class="stringliteral">"xroot: %s.%s =&gt; %s\n"</span>, xroot-&gt;parent-&gt;label, xroot-&gt;label,
01434                xroot-&gt;next_peer-&gt;label);
01435 <span class="preprocessor">#endif</span>
01436         xroot = xroot-&gt;next_peer;
01437     }
01438 
01439     tp = root;
01440     headp = &amp;nbuckets[NBUCKET(name_hash(tp-&gt;label))];
01441     <span class="comment">/*</span>
01442 <span class="comment">     * Search each of the nodes for one whose parent is root, and</span>
01443 <span class="comment">     * move each into a separate list.</span>
01444 <span class="comment">     */</span>
01445     <span class="keywordflow">for</span> (np = *headp; np; np = np-&gt;next) {
01446         <span class="keywordflow">if</span> (!label_compare(tp-&gt;label, np-&gt;parent)) {
01447             <span class="comment">/*</span>
01448 <span class="comment">             * take this node out of the node list </span>
01449 <span class="comment">             */</span>
01450             <span class="keywordflow">if</span> (oldnp == NULL) {
01451                 *headp = np-&gt;next;      <span class="comment">/* fix root of node list */</span>
01452             } <span class="keywordflow">else</span> {
01453                 oldnp-&gt;next = np-&gt;next; <span class="comment">/* link around this node */</span>
01454             }
01455             <span class="keywordflow">if</span> (child_list)
01456                 childp-&gt;next = np;
01457             <span class="keywordflow">else</span>
01458                 child_list = np;
01459             childp = np;
01460         } <span class="keywordflow">else</span> {
01461             oldnp = np;
01462         }
01463 
01464     }
01465     <span class="keywordflow">if</span> (childp)
01466         childp-&gt;next = NULL;
01467     <span class="comment">/*</span>
01468 <span class="comment">     * Take each element in the child list and place it into the tree.</span>
01469 <span class="comment">     */</span>
01470     <span class="keywordflow">for</span> (np = child_list; np; np = np-&gt;next) {
01471         <span class="keyword">struct </span>tree    *otp = NULL;
01472         <span class="keyword">struct </span>tree    *xxroot = xroot;
01473         anon_tp = NULL;
01474         tp = xroot-&gt;child_list;
01475 
01476         <span class="keywordflow">if</span> (np-&gt;subid == -1) {
01477             <span class="comment">/*</span>
01478 <span class="comment">             * name ::= { parent } </span>
01479 <span class="comment">             */</span>
01480             np-&gt;subid = xroot-&gt;subid;
01481             tp = xroot;
01482             xxroot = xroot-&gt;parent;
01483         }
01484 
01485         <span class="keywordflow">while</span> (tp) {
01486             <span class="keywordflow">if</span> (tp-&gt;subid == np-&gt;subid)
01487                 <span class="keywordflow">break</span>;
01488             <span class="keywordflow">else</span> {
01489                 otp = tp;
01490                 tp = tp-&gt;next_peer;
01491             }
01492         }
01493         <span class="keywordflow">if</span> (tp) {
01494             <span class="keywordflow">if</span> (!label_compare(tp-&gt;label, np-&gt;label)) {
01495                 <span class="comment">/*</span>
01496 <span class="comment">                 * Update list of modules </span>
01497 <span class="comment">                 */</span>
01498                 int_p =
01499                     (<span class="keywordtype">int</span> *) malloc((tp-&gt;number_modules + 1) * <span class=
"keyword">sizeof</span>(<span class="keywordtype">int</span>));
01500                 <span class="keywordflow">if</span> (int_p == NULL)
01501                     <span class="keywordflow">return</span>;
01502                 memcpy(int_p, tp-&gt;module_list,
01503                        tp-&gt;number_modules * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01504                 int_p[tp-&gt;number_modules] = np-&gt;modid;
01505                 <span class="keywordflow">if</span> (tp-&gt;number_modules &gt; 1)
01506                     free((<span class="keywordtype">char</span> *) tp-&gt;module_list);
01507                 ++tp-&gt;number_modules;
01508                 tp-&gt;module_list = int_p;
01509 
01510                 <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
01511                                            NETSNMP_DS_LIB_MIB_REPLACE)) {
01512                     <span class="comment">/*</span>
01513 <span class="comment">                     * Replace from node </span>
01514 <span class="comment">                     */</span>
01515                     tree_from_node(tp, np);
01516                 }
01517                 <span class="comment">/*</span>
01518 <span class="comment">                 * Handle children </span>
01519 <span class="comment">                 */</span>
01520                 do_subtree(tp, nodes);
01521                 <span class="keywordflow">continue</span>;
01522             }
01523             <span class="keywordflow">if</span> (!strncmp(np-&gt;label, ANON, ANON_LEN) ||
01524                 !strncmp(tp-&gt;label, ANON, ANON_LEN)) {
01525                 anon_tp = tp;   <span class="comment">/* Need to merge these two trees later */</span>
01526             } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
01527                                           NETSNMP_DS_LIB_MIB_WARNINGS)) {
01528                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
01529                          <span class="stringliteral">"Warning: %s.%ld is both %s and %s (%s)\n"</span>,
01530                          root-&gt;label, np-&gt;subid, tp-&gt;label, np-&gt;label,
01531                          File);
01532             }
01533         }
01534 
01535         tp = (<span class="keyword">struct </span>tree *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> tree));
01536         <span class="keywordflow">if</span> (tp == NULL)
01537             <span class="keywordflow">return</span>;
01538         tp-&gt;parent = xxroot;
01539         tp-&gt;modid = np-&gt;modid;
01540         tp-&gt;number_modules = 1;
01541         tp-&gt;module_list = &amp;(tp-&gt;modid);
01542         tree_from_node(tp, np);
01543         tp-&gt;next_peer = otp ? otp-&gt;next_peer : xxroot-&gt;child_list;
01544         <span class="keywordflow">if</span> (otp)
01545             otp-&gt;next_peer = tp;
01546         <span class="keywordflow">else</span>
01547             xxroot-&gt;child_list = tp;
01548         hash = NBUCKET(name_hash(tp-&gt;label));
01549         tp-&gt;next = tbuckets[hash];
01550         tbuckets[hash] = tp;
01551         do_subtree(tp, nodes);
01552 
01553         <span class="keywordflow">if</span> (anon_tp) {
01554             <span class="keywordflow">if</span> (!strncmp(tp-&gt;label, ANON, ANON_LEN)) {
01555                 <span class="comment">/*</span>
01556 <span class="comment">                 * The new node is anonymous,</span>
01557 <span class="comment">                 *  so merge it with the existing one.</span>
01558 <span class="comment">                 */</span>
01559                 merge_anon_children(tp, anon_tp);
01560 
01561                 <span class="comment">/*</span>
01562 <span class="comment">                 * unlink and destroy tp </span>
01563 <span class="comment">                 */</span>
01564                 unlink_tree(tp);
01565                 free_tree(tp);
01566             } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (!strncmp(anon_tp-&gt;label, ANON, ANON_LEN)) {
01567                 <span class="keyword">struct </span>tree    *ntp;
01568                 <span class="comment">/*</span>
01569 <span class="comment">                 * The old node was anonymous,</span>
01570 <span class="comment">                 *  so merge it with the existing one,</span>
01571 <span class="comment">                 *  and fill in the full information.</span>
01572 <span class="comment">                 */</span>
01573                 merge_anon_children(anon_tp, tp);
01574 
01575                 <span class="comment">/*</span>
01576 <span class="comment">                 * unlink anon_tp from the hash </span>
01577 <span class="comment">                 */</span>
01578                 unlink_tbucket(anon_tp);
01579 
01580                 <span class="comment">/*</span>
01581 <span class="comment">                 * get rid of old contents of anon_tp </span>
01582 <span class="comment">                 */</span>
01583                 free_partial_tree(anon_tp, FALSE);
01584 
01585                 <span class="comment">/*</span>
01586 <span class="comment">                 * put in the current information </span>
01587 <span class="comment">                 */</span>
01588                 anon_tp-&gt;label = tp-&gt;label;
01589                 anon_tp-&gt;child_list = tp-&gt;child_list;
01590                 anon_tp-&gt;modid = tp-&gt;modid;
01591                 anon_tp-&gt;tc_index = tp-&gt;tc_index;
01592                 anon_tp-&gt;type = tp-&gt;type;
01593                 anon_tp-&gt;enums = tp-&gt;enums;
01594                 anon_tp-&gt;indexes = tp-&gt;indexes;
01595                 anon_tp-&gt;augments = tp-&gt;augments;
01596                 anon_tp-&gt;varbinds = tp-&gt;varbinds;
01597                 anon_tp-&gt;ranges = tp-&gt;ranges;
01598                 anon_tp-&gt;hint = tp-&gt;hint;
01599                 anon_tp-&gt;units = tp-&gt;units;
01600                 anon_tp-&gt;description = tp-&gt;description;
01601                 anon_tp-&gt;reference = tp-&gt;reference;
01602                 anon_tp-&gt;defaultValue = tp-&gt;defaultValue;
01603                 anon_tp-&gt;parent = tp-&gt;parent;
01604 
01605                 <a class="code" href="group__mib__utilities.html#ga61">set_function</a>(anon_tp);
01606 
01607                 <span class="comment">/*</span>
01608 <span class="comment">                 * update parent pointer in moved children </span>
01609 <span class="comment">                 */</span>
01610                 ntp = anon_tp-&gt;child_list;
01611                 <span class="keywordflow">while</span> (ntp) {
01612                     ntp-&gt;parent = anon_tp;
01613                     ntp = ntp-&gt;next_peer;
01614                 }
01615 
01616                 <span class="comment">/*</span>
01617 <span class="comment">                 * hash in anon_tp in its new place </span>
01618 <span class="comment">                 */</span>
01619                 hash = NBUCKET(name_hash(anon_tp-&gt;label));
01620                 anon_tp-&gt;next = tbuckets[hash];
01621                 tbuckets[hash] = anon_tp;
01622 
01623                 <span class="comment">/*</span>
01624 <span class="comment">                 * unlink and destroy tp </span>
01625 <span class="comment">                 */</span>
01626                 unlink_tbucket(tp);
01627                 unlink_tree(tp);
01628                 free(tp);
01629             } <span class="keywordflow">else</span> {
01630                 <span class="comment">/*</span>
01631 <span class="comment">                 * Uh?  One of these two should have been anonymous! </span>
01632 <span class="comment">                 */</span>
01633                 <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
01634                                        NETSNMP_DS_LIB_MIB_WARNINGS)) {
01635                     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
01636                              <span class=
"stringliteral">"Warning: expected anonymous node (either %s or %s) in %s\n"</span>,
01637                              tp-&gt;label, anon_tp-&gt;label, File);
01638                 }
01639             }
01640             anon_tp = NULL;
01641         }
01642     }
01643     <span class="comment">/*</span>
01644 <span class="comment">     * free all nodes that were copied into tree </span>
01645 <span class="comment">     */</span>
01646     oldnp = NULL;
01647     <span class="keywordflow">for</span> (np = child_list; np; np = np-&gt;next) {
01648         <span class="keywordflow">if</span> (oldnp)
01649             free_node(oldnp);
01650         oldnp = np;
01651     }
01652     <span class="keywordflow">if</span> (oldnp)
01653         free_node(oldnp);
01654 }
01655 
01656 <span class="keyword">static</span> <span class="keywordtype">void</span>
01657 do_linkup(<span class="keyword">struct</span> module *mp, <span class="keyword">struct</span> node *np)
01658 {
01659     <span class="keyword">struct </span>module_import *mip;
01660     <span class="keyword">struct </span>node    *onp, *oldp, *newp;
01661     <span class="keyword">struct </span>tree    *tp;
01662     <span class="keywordtype">int</span>             i, more;
01663     <span class="comment">/*</span>
01664 <span class="comment">     * All modules implicitly import</span>
01665 <span class="comment">     *   the roots of the tree</span>
01666 <span class="comment">     */</span>
01667     <span class="keywordflow">if</span> (snmp_get_do_debugging() &gt; 1)
01668         dump_module_list();
01669     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Processing IMPORTS for module %d %s\n"</span>,
01670                 mp-&gt;modid, mp-&gt;name));
01671     <span class="keywordflow">if</span> (mp-&gt;no_imports == 0) {
01672         mp-&gt;no_imports = NUMBER_OF_ROOT_NODES;
01673         mp-&gt;imports = root_imports;
01674     }
01675 
01676     <span class="comment">/*</span>
01677 <span class="comment">     * Build the tree</span>
01678 <span class="comment">     */</span>
01679     init_node_hash(np);
01680     <span class="keywordflow">for</span> (i = 0, mip = mp-&gt;imports; i &lt; mp-&gt;no_imports; ++i, ++mip) {
01681         <span class="keywordtype">char</span>            modbuf[256];
01682         DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"  Processing import: %s\n"</span>,
01683                     mip-&gt;label));
01684         <span class="keywordflow">if</span> (get_tc_index(mip-&gt;label, mip-&gt;modid) != -1)
01685             <span class="keywordflow">continue</span>;
01686         tp = find_tree_node(mip-&gt;label, mip-&gt;modid);
01687         <span class="keywordflow">if</span> (!tp) {
01688                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
01689                          <span class="stringliteral">"Did not find '%s' in module %s (%s)\n"</span>,
01690                          mip-&gt;label, module_name(mip-&gt;modid, modbuf),
01691                          File);
01692             <span class="keywordflow">continue</span>;
01693         }
01694         do_subtree(tp, &amp;np);
01695     }
01696 
01697     <span class="comment">/*</span>
01698 <span class="comment">     * If any nodes left over,</span>
01699 <span class="comment">     *   check that they're not the result of a "fully qualified"</span>
01700 <span class="comment">     *   name, and then add them to the list of orphans</span>
01701 <span class="comment">     */</span>
01702 
01703     <span class="keywordflow">if</span> (!np)
01704         <span class="keywordflow">return</span>;
01705     <span class="keywordflow">for</span> (tp = tree_head; tp; tp = tp-&gt;next_peer)
01706         do_subtree(tp, &amp;np);
01707     <span class="keywordflow">if</span> (!np)
01708         <span class="keywordflow">return</span>;
01709 
01710     <span class="comment">/*</span>
01711 <span class="comment">     * quietly move all internal references to the orphan list </span>
01712 <span class="comment">     */</span>
01713     oldp = orphan_nodes;
01714     <span class="keywordflow">do</span> {
01715         <span class="keywordflow">for</span> (i = 0; i &lt; NHASHSIZE; i++)
01716             <span class="keywordflow">for</span> (onp = nbuckets[i]; onp; onp = onp-&gt;next) {
01717                 <span class="keyword">struct </span>node    *op = NULL;
01718                 <span class="keywordtype">int</span>             hash = NBUCKET(name_hash(onp-&gt;label));
01719                 np = nbuckets[hash];
01720                 <span class="keywordflow">while</span> (np) {
01721                     <span class="keywordflow">if</span> (label_compare(onp-&gt;label, np-&gt;parent)) {
01722                         op = np;
01723                         np = np-&gt;next;
01724                     } <span class="keywordflow">else</span> {
01725                         <span class="keywordflow">if</span> (op)
01726                             op-&gt;next = np-&gt;next;
01727                         <span class="keywordflow">else</span>
01728                             nbuckets[hash] = np-&gt;next;
01729                         np-&gt;next = orphan_nodes;
01730                         orphan_nodes = np;
01731                         op = NULL;
01732                         np = nbuckets[hash];
01733                     }
01734                 }
01735             }
01736         newp = orphan_nodes;
01737         more = 0;
01738         <span class="keywordflow">for</span> (onp = orphan_nodes; onp != oldp; onp = onp-&gt;next) {
01739             <span class="keyword">struct </span>node    *op = NULL;
01740             <span class="keywordtype">int</span>             hash = NBUCKET(name_hash(onp-&gt;label));
01741             np = nbuckets[hash];
01742             <span class="keywordflow">while</span> (np) {
01743                 <span class="keywordflow">if</span> (label_compare(onp-&gt;label, np-&gt;parent)) {
01744                     op = np;
01745                     np = np-&gt;next;
01746                 } <span class="keywordflow">else</span> {
01747                     <span class="keywordflow">if</span> (op)
01748                         op-&gt;next = np-&gt;next;
01749                     <span class="keywordflow">else</span>
01750                         nbuckets[hash] = np-&gt;next;
01751                     np-&gt;next = orphan_nodes;
01752                     orphan_nodes = np;
01753                     op = NULL;
01754                     np = nbuckets[hash];
01755                     more = 1;
01756                 }
01757             }
01758         }
01759         oldp = newp;
01760     } <span class="keywordflow">while</span> (more);
01761 
01762     <span class="comment">/*</span>
01763 <span class="comment">     * complain about left over nodes </span>
01764 <span class="comment">     */</span>
01765     <span class="keywordflow">for</span> (np = orphan_nodes; np &amp;&amp; np-&gt;next; np = np-&gt;next);     <span class=
"comment">/* find the end of the orphan list */</span>
01766     <span class="keywordflow">for</span> (i = 0; i &lt; NHASHSIZE; i++)
01767         <span class="keywordflow">if</span> (nbuckets[i]) {
01768             <span class="keywordflow">if</span> (orphan_nodes)
01769                 onp = np-&gt;next = nbuckets[i];
01770             <span class="keywordflow">else</span>
01771                 onp = orphan_nodes = nbuckets[i];
01772             nbuckets[i] = NULL;
01773             <span class="keywordflow">while</span> (onp) {
01774                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
01775                          <span class="stringliteral">"Unlinked OID in %s: %s ::= { %s %ld }\n"</span>,
01776                          (mp-&gt;name ? mp-&gt;name : <span class="stringliteral">"&lt;no module&gt;"</span>),
01777                          (onp-&gt;label ? onp-&gt;label : <span class="stringliteral">"&lt;no label&gt;"</span>),
01778                          (onp-&gt;parent ? onp-&gt;parent : <span class="stringliteral">"&lt;no parent&gt;"</span>),
01779                          onp-&gt;subid);
01780                  <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
01781                           <span class="stringliteral">"Undefined identifier: %s near line %d of %s\n"</span>,
01782                           (onp-&gt;parent ? onp-&gt;parent : <span class="stringliteral">"&lt;no parent&gt;"</span>),
01783                           onp-&gt;lineno, onp-&gt;filename);
01784                 np = onp;
01785                 onp = onp-&gt;next;
01786             }
01787         }
01788     <span class="keywordflow">return</span>;
01789 }
01790 
01791 
01792 <span class="comment">/*</span>
01793 <span class="comment"> * Takes a list of the form:</span>
01794 <span class="comment"> * { iso org(3) dod(6) 1 }</span>
01795 <span class="comment"> * and creates several nodes, one for each parent-child pair.</span>
01796 <span class="comment"> * Returns 0 on error.</span>
01797 <span class="comment"> */</span>
01798 <span class="keyword">static</span> <span class="keywordtype">int</span>
01799 getoid(FILE * fp, <span class="keyword">struct</span> subid_s *<span class="keywordtype">id</span>,   <span class=
"comment">/* an array of subids */</span>
01800        <span class="keywordtype">int</span> length)
01801 {                               <span class="comment">/* the length of the array */</span>
01802     <span class="keyword">register</span> <span class="keywordtype">int</span>    count;
01803     <span class="keywordtype">int</span>             type;
01804     <span class="keywordtype">char</span>            token[MAXTOKEN];
01805 
01806     <span class="keywordflow">if</span> ((type = get_token(fp, token, MAXTOKEN)) != LEFTBRACKET) {
01807         print_error(<span class="stringliteral">"Expected \"{\""</span>, token, type);
01808         <span class="keywordflow">return</span> 0;
01809     }
01810     type = get_token(fp, token, MAXTOKEN);
01811     <span class="keywordflow">for</span> (count = 0; count &lt; length; count++, <span class="keywordtype">id</span>++) {
01812         <span class="keywordtype">id</span>-&gt;label = NULL;
01813         <span class="keywordtype">id</span>-&gt;modid = current_module;
01814         <span class="keywordtype">id</span>-&gt;subid = -1;
01815         <span class="keywordflow">if</span> (type == RIGHTBRACKET)
01816             <span class="keywordflow">return</span> count;
01817         <span class="keywordflow">if</span> (type == LABEL) {
01818             <span class="comment">/*</span>
01819 <span class="comment">             * this entry has a label </span>
01820 <span class="comment">             */</span>
01821             <span class="keywordtype">id</span>-&gt;label = strdup(token);
01822             type = get_token(fp, token, MAXTOKEN);
01823             <span class="keywordflow">if</span> (type == LEFTPAREN) {
01824                 type = get_token(fp, token, MAXTOKEN);
01825                 <span class="keywordflow">if</span> (type == NUMBER) {
01826                     <span class="keywordtype">id</span>-&gt;subid = strtoul(token, NULL, 10);
01827                     <span class="keywordflow">if</span> ((type =
01828                          get_token(fp, token, MAXTOKEN)) != RIGHTPAREN) {
01829                         print_error(<span class="stringliteral">"Expected a closing parenthesis"</span>,
01830                                     token, type);
01831                         <span class="keywordflow">return</span> 0;
01832                     }
01833                 } <span class="keywordflow">else</span> {
01834                     print_error(<span class="stringliteral">"Expected a number"</span>, token, type);
01835                     <span class="keywordflow">return</span> 0;
01836                 }
01837             } <span class="keywordflow">else</span> {
01838                 <span class="keywordflow">continue</span>;
01839             }
01840         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == NUMBER) {
01841             <span class="comment">/*</span>
01842 <span class="comment">             * this entry  has just an integer sub-identifier </span>
01843 <span class="comment">             */</span>
01844             <span class="keywordtype">id</span>-&gt;subid = strtoul(token, NULL, 10);
01845         } <span class="keywordflow">else</span> {
01846             print_error(<span class="stringliteral">"Expected label or number"</span>, token, type);
01847             <span class="keywordflow">return</span> 0;
01848         }
01849         type = get_token(fp, token, MAXTOKEN);
01850     }
01851     print_error(<span class="stringliteral">"Too long OID"</span>, token, type);
01852     <span class="keywordflow">return</span> 0;
01853 }
01854 
01855 <span class="comment">/*</span>
01856 <span class="comment"> * Parse a sequence of object subidentifiers for the given name.</span>
01857 <span class="comment"> * The "label OBJECT IDENTIFIER ::=" portion has already been parsed.</span>
01858 <span class="comment"> *</span>
01859 <span class="comment"> * The majority of cases take this form :</span>
01860 <span class="comment"> * label OBJECT IDENTIFIER ::= { parent 2 }</span>
01861 <span class="comment"> * where a parent label and a child subidentifier number are specified.</span>
01862 <span class="comment"> *</span>
01863 <span class="comment"> * Variations on the theme include cases where a number appears with</span>
01864 <span class="comment"> * the parent, or intermediate subidentifiers are specified by label,</span>
01865 <span class="comment"> * by number, or both.</span>
01866 <span class="comment"> *</span>
01867 <span class="comment"> * Here are some representative samples :</span>
01868 <span class="comment"> * internet        OBJECT IDENTIFIER ::= { iso org(3) dod(6) 1 }</span>
01869 <span class="comment"> * mgmt            OBJECT IDENTIFIER ::= { internet 2 }</span>
01870 <span class="comment"> * rptrInfoHealth  OBJECT IDENTIFIER ::= { snmpDot3RptrMgt 0 4 }</span>
01871 <span class="comment"> *</span>
01872 <span class="comment"> * Here is a very rare form :</span>
01873 <span class="comment"> * iso             OBJECT IDENTIFIER ::= { 1 }</span>
01874 <span class="comment"> *</span>
01875 <span class="comment"> * Returns NULL on error.  When this happens, memory may be leaked.</span>
01876 <span class="comment"> */</span>
01877 <span class="keyword">static</span> <span class="keyword">struct </span>node *
01878 parse_objectid(FILE * fp, <span class="keywordtype">char</span> *name)
01879 {
01880     <span class="keyword">register</span> <span class="keywordtype">int</span>    count;
01881     <span class="keyword">register</span> <span class="keyword">struct </span>subid_s *op, *nop;
01882     <span class="keywordtype">int</span>             length;
01883     <span class="keyword">struct </span>subid_s  loid[32];
01884     <span class="keyword">struct </span>node    *np, *root = NULL, *oldnp = NULL;
01885     <span class="keyword">struct </span>tree    *tp;
01886 
01887     <span class="keywordflow">if</span> ((length = getoid(fp, loid, 32)) == 0) {
01888         print_error(<span class="stringliteral">"Bad object identifier"</span>, NULL, CONTINUE);
01889         <span class="keywordflow">return</span> NULL;
01890     }
01891 
01892     <span class="comment">/*</span>
01893 <span class="comment">     * Handle numeric-only object identifiers,</span>
01894 <span class="comment">     *  by labelling the first sub-identifier</span>
01895 <span class="comment">     */</span>
01896     op = loid;
01897     <span class="keywordflow">if</span> (!op-&gt;label) {
01898         <span class="keywordflow">if</span> (length == 1) {
01899             print_error(<span class="stringliteral">"Attempt to define a root oid"</span>, name, OBJECT);
01900             <span class="keywordflow">return</span> NULL;
01901         }
01902         <span class="keywordflow">for</span> (tp = tree_head; tp; tp = tp-&gt;next_peer)
01903             <span class="keywordflow">if</span> ((int) tp-&gt;subid == op-&gt;subid) {
01904                 op-&gt;label = strdup(tp-&gt;label);
01905                 <span class="keywordflow">break</span>;
01906             }
01907     }
01908 
01909     <span class="comment">/*</span>
01910 <span class="comment">     * Handle  "label OBJECT-IDENTIFIER ::= { subid }"</span>
01911 <span class="comment">     */</span>
01912     <span class="keywordflow">if</span> (length == 1) {
01913         op = loid;
01914         np = alloc_node(op-&gt;modid);
01915         <span class="keywordflow">if</span> (np == NULL)
01916             <span class="keywordflow">return</span> (NULL);
01917         np-&gt;subid = op-&gt;subid;
01918         np-&gt;label = strdup(name);
01919         np-&gt;parent = op-&gt;label;
01920         <span class="keywordflow">return</span> np;
01921     }
01922 
01923     <span class="comment">/*</span>
01924 <span class="comment">     * For each parent-child subid pair in the subid array,</span>
01925 <span class="comment">     * create a node and link it into the node list.</span>
01926 <span class="comment">     */</span>
01927     <span class="keywordflow">for</span> (count = 0, op = loid, nop = loid + 1; count &lt; (length - 1);
01928          count++, op++, nop++) {
01929         <span class="comment">/*</span>
01930 <span class="comment">         * every node must have parent's name and child's name or number </span>
01931 <span class="comment">         */</span>
01932         <span class="comment">/*</span>
01933 <span class="comment">         * XX the next statement is always true -- does it matter ?? </span>
01934 <span class="comment">         */</span>
01935         <span class="keywordflow">if</span> (op-&gt;label &amp;&amp; (nop-&gt;label || (nop-&gt;subid != -1))) {
01936             np = alloc_node(nop-&gt;modid);
01937             <span class="keywordflow">if</span> (np == NULL)
01938                 <span class="keywordflow">return</span> (NULL);
01939             <span class="keywordflow">if</span> (root == NULL)
01940                 root = np;
01941 
01942             np-&gt;parent = strdup(op-&gt;label);
01943             <span class="keywordflow">if</span> (count == (length - 2)) {
01944                 <span class="comment">/*</span>
01945 <span class="comment">                 * The name for this node is the label for this entry </span>
01946 <span class="comment">                 */</span>
01947                 np-&gt;label = strdup(name);
01948             } <span class="keywordflow">else</span> {
01949                 <span class="keywordflow">if</span> (!nop-&gt;label) {
01950                     nop-&gt;label = (<span class="keywordtype">char</span> *) malloc(20 + ANON_LEN);
01951                     <span class="keywordflow">if</span> (nop-&gt;label == NULL)
01952                         <span class="keywordflow">return</span> (NULL);
01953                     sprintf(nop-&gt;label, <span class="stringliteral">"%s%d"</span>, ANON, anonymous++);
01954                 }
01955                 np-&gt;label = strdup(nop-&gt;label);
01956             }
01957             <span class="keywordflow">if</span> (nop-&gt;subid != -1)
01958                 np-&gt;subid = nop-&gt;subid;
01959             <span class="keywordflow">else</span>
01960                 print_error(<span class="stringliteral">"Warning: This entry is pretty silly"</span>,
01961                             np-&gt;label, CONTINUE);
01962 
01963             <span class="comment">/*</span>
01964 <span class="comment">             * set up next entry </span>
01965 <span class="comment">             */</span>
01966             <span class="keywordflow">if</span> (oldnp)
01967                 oldnp-&gt;next = np;
01968             oldnp = np;
01969         }                       <span class="comment">/* end if(op-&gt;label... */</span>
01970     }
01971 
01972     <span class="comment">/*</span>
01973 <span class="comment">     * free the loid array </span>
01974 <span class="comment">     */</span>
01975     <span class="keywordflow">for</span> (count = 0, op = loid; count &lt; length; count++, op++) {
01976         <span class="keywordflow">if</span> (op-&gt;label)
01977             free(op-&gt;label);
01978     }
01979 
01980     <span class="keywordflow">return</span> root;
01981 }
01982 
01983 <span class="keyword">static</span> <span class="keywordtype">int</span>
01984 get_tc(<span class="keyword">const</span> <span class="keywordtype">char</span> *descriptor,
01985        <span class="keywordtype">int</span> modid,
01986        <span class="keywordtype">int</span> *tc_index,
01987        <span class="keyword">struct</span> enum_list **ep, <span class=
"keyword">struct</span> range_list **rp, <span class="keywordtype">char</span> **hint)
01988 {
01989     <span class="keywordtype">int</span>             i;
01990     <span class="keyword">struct </span>tc      *tcp;
01991 
01992     i = get_tc_index(descriptor, modid);
01993     <span class="keywordflow">if</span> (tc_index)
01994         *tc_index = i;
01995     <span class="keywordflow">if</span> (i != -1) {
01996         tcp = &amp;tclist[i];
01997         <span class="keywordflow">if</span> (ep) {
01998             free_enums(ep);
01999             *ep = copy_enums(tcp-&gt;enums);
02000         }
02001         <span class="keywordflow">if</span> (rp) {
02002             free_ranges(rp);
02003             *rp = copy_ranges(tcp-&gt;ranges);
02004         }
02005         <span class="keywordflow">if</span> (hint) {
02006             <span class="keywordflow">if</span> (*hint)
02007                 free(*hint);
02008             *hint = (tcp-&gt;hint ? strdup(tcp-&gt;hint) : NULL);
02009         }
02010         <span class="keywordflow">return</span> tcp-&gt;type;
02011     }
02012     <span class="keywordflow">return</span> LABEL;
02013 }
02014 
02015 <span class="comment">/*</span>
02016 <span class="comment"> * return index into tclist of given TC descriptor</span>
02017 <span class="comment"> * return -1 if not found</span>
02018 <span class="comment"> */</span>
02019 <span class="keyword">static</span> <span class="keywordtype">int</span>
02020 get_tc_index(<span class="keyword">const</span> <span class="keywordtype">char</span> *descriptor, <span class=
"keywordtype">int</span> modid)
02021 {
02022     <span class="keywordtype">int</span>             i;
02023     <span class="keyword">struct </span>tc      *tcp;
02024     <span class="keyword">struct </span>module  *mp;
02025     <span class="keyword">struct </span>module_import *mip;
02026 
02027     <span class="comment">/*</span>
02028 <span class="comment">     * Check that the descriptor isn't imported</span>
02029 <span class="comment">     *  by searching the import list</span>
02030 <span class="comment">     */</span>
02031 
02032     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
02033         <span class="keywordflow">if</span> (mp-&gt;modid == modid)
02034             <span class="keywordflow">break</span>;
02035     <span class="keywordflow">if</span> (mp)
02036         <span class="keywordflow">for</span> (i = 0, mip = mp-&gt;imports; i &lt; mp-&gt;no_imports; ++i, ++mip) {
02037             <span class="keywordflow">if</span> (!label_compare(mip-&gt;label, descriptor)) {
02038                 <span class="comment">/*</span>
02039 <span class="comment">                 * Found it - so amend the module ID </span>
02040 <span class="comment">                 */</span>
02041                 modid = mip-&gt;modid;
02042                 <span class="keywordflow">break</span>;
02043             }
02044         }
02045 
02046 
02047     <span class="keywordflow">for</span> (i = 0, tcp = tclist; i &lt; MAXTC; i++, tcp++) {
02048         <span class="keywordflow">if</span> (tcp-&gt;type == 0)
02049             <span class="keywordflow">break</span>;
02050         <span class="keywordflow">if</span> (!label_compare(descriptor, tcp-&gt;descriptor) &amp;&amp;
02051             ((modid == tcp-&gt;modid) || (modid == -1))) {
02052             <span class="keywordflow">return</span> i;
02053         }
02054     }
02055     <span class="keywordflow">return</span> -1;
02056 }
02057 
02058 <span class="comment">/*</span>
02059 <span class="comment"> * translate integer tc_index to string identifier from tclist</span>
02060 <span class="comment"> * *</span>
02061 <span class="comment"> * * Returns pointer to string in table (should not be modified) or NULL</span>
02062 <span class="comment"> */</span>
02063 <span class="keyword">const</span> <span class="keywordtype">char</span>     *
02064 get_tc_descriptor(<span class="keywordtype">int</span> tc_index)
02065 {
02066     <span class="keywordflow">if</span> (tc_index &lt; 0 || tc_index &gt;= MAXTC)
02067         <span class="keywordflow">return</span> NULL;
02068     <span class="keywordflow">return</span> (tclist[tc_index].descriptor);
02069 }
02070 
02071 <span class="keyword">const</span> <span class="keywordtype">char</span>     *
02072 get_tc_description(<span class="keywordtype">int</span> tc_index)
02073 {
02074     <span class="keywordflow">if</span> (tc_index &lt; 0 || tc_index &gt;= MAXTC)
02075         <span class="keywordflow">return</span> NULL;
02076     <span class="keywordflow">return</span> (tclist[tc_index].description);
02077 }
02078 
02079 
02080 <span class="comment">/*</span>
02081 <span class="comment"> * Parses an enumeration list of the form:</span>
02082 <span class="comment"> *        { label(value) label(value) ... }</span>
02083 <span class="comment"> * The initial { has already been parsed.</span>
02084 <span class="comment"> * Returns NULL on error.</span>
02085 <span class="comment"> */</span>
02086 
02087 <span class="keyword">static</span> <span class="keyword">struct </span>enum_list *
02088 parse_enumlist(FILE * fp, <span class="keyword">struct</span> enum_list **retp)
02089 {
02090     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
02091     <span class="keywordtype">char</span>            token[MAXTOKEN];
02092     <span class="keyword">struct </span>enum_list *ep = NULL, **epp = &amp;ep;
02093 
02094     free_enums(retp);
02095 
02096     <span class="keywordflow">while</span> ((type = get_token(fp, token, MAXTOKEN)) != ENDOFFILE) {
02097         <span class="keywordflow">if</span> (type == RIGHTBRACKET)
02098             <span class="keywordflow">break</span>;
02099         <span class="keywordflow">if</span> (type == LABEL) {
02100             <span class="comment">/*</span>
02101 <span class="comment">             * this is an enumerated label </span>
02102 <span class="comment">             */</span>
02103             *epp =
02104                 (<span class="keyword">struct </span>enum_list *) calloc(1, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> enum_list));
02105             <span class="keywordflow">if</span> (*epp == NULL)
02106                 <span class="keywordflow">return</span> (NULL);
02107             <span class="comment">/*</span>
02108 <span class="comment">             * a reasonable approximation for the length </span>
02109 <span class="comment">             */</span>
02110             (*epp)-&gt;label = strdup(token);
02111             type = get_token(fp, token, MAXTOKEN);
02112             <span class="keywordflow">if</span> (type != LEFTPAREN) {
02113                 print_error(<span class="stringliteral">"Expected \"(\""</span>, token, type);
02114                 <span class="keywordflow">return</span> NULL;
02115             }
02116             type = get_token(fp, token, MAXTOKEN);
02117             <span class="keywordflow">if</span> (type != NUMBER) {
02118                 print_error(<span class="stringliteral">"Expected integer"</span>, token, type);
02119                 <span class="keywordflow">return</span> NULL;
02120             }
02121             (*epp)-&gt;value = strtol(token, NULL, 10);
02122             type = get_token(fp, token, MAXTOKEN);
02123             <span class="keywordflow">if</span> (type != RIGHTPAREN) {
02124                 print_error(<span class="stringliteral">"Expected \")\""</span>, token, type);
02125                 <span class="keywordflow">return</span> NULL;
02126             }
02127             epp = &amp;(*epp)-&gt;next;
02128         }
02129     }
02130     <span class="keywordflow">if</span> (type == ENDOFFILE) {
02131         print_error(<span class="stringliteral">"Expected \"}\""</span>, token, type);
02132         <span class="keywordflow">return</span> NULL;
02133     }
02134     *retp = ep;
02135     <span class="keywordflow">return</span> ep;
02136 }
02137 
02138 <span class="keyword">static</span> <span class="keyword">struct </span>range_list *
02139 parse_ranges(FILE * fp, <span class="keyword">struct</span> range_list **retp)
02140 {
02141     <span class="keywordtype">int</span>             low, high;
02142     <span class="keywordtype">char</span>            nexttoken[MAXTOKEN];
02143     <span class="keywordtype">int</span>             nexttype;
02144     <span class="keyword">struct </span>range_list *rp = NULL, **rpp = &amp;rp;
02145     <span class="keywordtype">int</span>             size = 0, taken = 1;
02146 
02147     free_ranges(retp);
02148 
02149     nexttype = get_token(fp, nexttoken, MAXTOKEN);
02150     <span class="keywordflow">if</span> (nexttype == SIZE) {
02151         size = 1;
02152         taken = 0;
02153         nexttype = get_token(fp, nexttoken, MAXTOKEN);
02154         <span class="keywordflow">if</span> (nexttype != LEFTPAREN)
02155             print_error(<span class="stringliteral">"Expected \"(\" after SIZE"</span>, nexttoken, nexttype);
02156     }
02157 
02158     <span class="keywordflow">do</span> {
02159         <span class="keywordflow">if</span> (!taken)
02160             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02161         <span class="keywordflow">else</span>
02162             taken = 0;
02163         high = low = strtol(nexttoken, NULL, 10);
02164         nexttype = get_token(fp, nexttoken, MAXTOKEN);
02165         <span class="keywordflow">if</span> (nexttype == RANGE) {
02166             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02167             high = strtol(nexttoken, NULL, 10);
02168             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02169         }
02170         *rpp = (<span class="keyword">struct </span>range_list *) calloc(1, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> range_list));
02171         <span class="keywordflow">if</span> (*rpp == NULL)
02172             <span class="keywordflow">break</span>;
02173         (*rpp)-&gt;low = low;
02174         (*rpp)-&gt;high = high;
02175         rpp = &amp;(*rpp)-&gt;next;
02176 
02177     } <span class="keywordflow">while</span> (nexttype == BAR);
02178     <span class="keywordflow">if</span> (size) {
02179         <span class="keywordflow">if</span> (nexttype != RIGHTPAREN)
02180             print_error(<span class="stringliteral">"Expected \")\" after SIZE"</span>, nexttoken, nexttype);
02181         nexttype = get_token(fp, nexttoken, nexttype);
02182     }
02183     <span class="keywordflow">if</span> (nexttype != RIGHTPAREN)
02184         print_error(<span class="stringliteral">"Expected \")\""</span>, nexttoken, nexttype);
02185 
02186     *retp = rp;
02187     <span class="keywordflow">return</span> rp;
02188 }
02189 
02190 <span class="comment">/*</span>
02191 <span class="comment"> * Parses an asn type.  Structures are ignored by this parser.</span>
02192 <span class="comment"> * Returns NULL on error.</span>
02193 <span class="comment"> */</span>
02194 <span class="keyword">static</span> <span class="keyword">struct </span>node *
02195 parse_asntype(FILE * fp, <span class="keywordtype">char</span> *name, <span class=
"keywordtype">int</span> *ntype, <span class="keywordtype">char</span> *ntoken)
02196 {
02197     <span class="keywordtype">int</span>             type, i;
02198     <span class="keywordtype">char</span>            token[MAXTOKEN];
02199     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
02200     <span class="keywordtype">char</span>           *hint = NULL;
02201     <span class="keywordtype">char</span>           *descr = NULL;
02202     <span class="keyword">struct </span>tc      *tcp;
02203     <span class="keywordtype">int</span>             level;
02204 
02205     type = get_token(fp, token, MAXTOKEN);
02206     <span class="keywordflow">if</span> (type == SEQUENCE || type == CHOICE) {
02207         level = 0;
02208         <span class="keywordflow">while</span> ((type = get_token(fp, token, MAXTOKEN)) != ENDOFFILE) {
02209             <span class="keywordflow">if</span> (type == LEFTBRACKET) {
02210                 level++;
02211             } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (type == RIGHTBRACKET &amp;&amp; --level == 0) {
02212                 *ntype = get_token(fp, ntoken, MAXTOKEN);
02213                 <span class="keywordflow">return</span> NULL;
02214             }
02215         }
02216         print_error(<span class="stringliteral">"Expected \"}\""</span>, token, type);
02217         <span class="keywordflow">return</span> NULL;
02218     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == LEFTBRACKET) {
02219         <span class="keyword">struct </span>node    *np;
02220         <span class="keywordtype">int</span>             ch_next = <span class="charliteral">'{'</span>;
02221         ungetc(ch_next, fp);
02222         np = parse_objectid(fp, name);
02223         <span class="keywordflow">if</span> (np != NULL) {
02224             *ntype = get_token(fp, ntoken, MAXTOKEN);
02225             <span class="keywordflow">return</span> np;
02226         }
02227         <span class="keywordflow">return</span> NULL;
02228     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == LEFTSQBRACK) {
02229         <span class="keywordtype">int</span>             size = 0;
02230         <span class="keywordflow">do</span> {
02231             type = get_token(fp, token, MAXTOKEN);
02232         } <span class="keywordflow">while</span> (type != ENDOFFILE &amp;&amp; type != RIGHTSQBRACK);
02233         <span class="keywordflow">if</span> (type != RIGHTSQBRACK) {
02234             print_error(<span class="stringliteral">"Expected \"]\""</span>, token, type);
02235             <span class="keywordflow">return</span> NULL;
02236         }
02237         type = get_token(fp, token, MAXTOKEN);
02238         <span class="keywordflow">if</span> (type == IMPLICIT)
02239             type = get_token(fp, token, MAXTOKEN);
02240         *ntype = get_token(fp, ntoken, MAXTOKEN);
02241         <span class="keywordflow">if</span> (*ntype == LEFTPAREN) {
02242             <span class="keywordflow">switch</span> (type) {
02243             <span class="keywordflow">case</span> OCTETSTR:
02244                 *ntype = get_token(fp, ntoken, MAXTOKEN);
02245                 <span class="keywordflow">if</span> (*ntype != SIZE) {
02246                     print_error(<span class="stringliteral">"Expected SIZE"</span>, ntoken, *ntype);
02247                     <span class="keywordflow">return</span> NULL;
02248                 }
02249                 size = 1;
02250                 *ntype = get_token(fp, ntoken, MAXTOKEN);
02251                 <span class="keywordflow">if</span> (*ntype != LEFTPAREN) {
02252                     print_error(<span class="stringliteral">"Expected \"(\" after SIZE"</span>, ntoken,
02253                                 *ntype);
02254                     <span class="keywordflow">return</span> NULL;
02255                 }
02256                 <span class="comment">/*</span>
02257 <span class="comment">                 * fall through </span>
02258 <span class="comment">                 */</span>
02259             <span class="keywordflow">case</span> INTEGER:
02260                 *ntype = get_token(fp, ntoken, MAXTOKEN);
02261                 <span class="keywordflow">do</span> {
02262                     <span class="keywordflow">if</span> (*ntype != NUMBER)
02263                         print_error(<span class="stringliteral">"Expected NUMBER"</span>, ntoken, *ntype);
02264                     *ntype = get_token(fp, ntoken, MAXTOKEN);
02265                     <span class="keywordflow">if</span> (*ntype == RANGE) {
02266                         *ntype = get_token(fp, ntoken, MAXTOKEN);
02267                         <span class="keywordflow">if</span> (*ntype != NUMBER)
02268                             print_error(<span class="stringliteral">"Expected NUMBER"</span>, ntoken, *ntype);
02269                         *ntype = get_token(fp, ntoken, MAXTOKEN);
02270                     }
02271                 } <span class="keywordflow">while</span> (*ntype == BAR);
02272                 <span class="keywordflow">if</span> (*ntype != RIGHTPAREN) {
02273                     print_error(<span class="stringliteral">"Expected \")\""</span>, ntoken, *ntype);
02274                     <span class="keywordflow">return</span> NULL;
02275                 }
02276                 *ntype = get_token(fp, ntoken, MAXTOKEN);
02277                 <span class="keywordflow">if</span> (size) {
02278                     <span class="keywordflow">if</span> (*ntype != RIGHTPAREN) {
02279                         print_error(<span class="stringliteral">"Expected \")\" to terminate SIZE"</span>,
02280                                     ntoken, *ntype);
02281                         <span class="keywordflow">return</span> NULL;
02282                     }
02283                     *ntype = get_token(fp, ntoken, MAXTOKEN);
02284                 }
02285             }
02286         }
02287         <span class="keywordflow">return</span> NULL;
02288     } <span class="keywordflow">else</span> {
02289         <span class="keywordflow">if</span> (type == CONVENTION) {
02290             <span class="keywordflow">while</span> (type != SYNTAX &amp;&amp; type != ENDOFFILE) {
02291                 <span class="keywordflow">if</span> (type == DISPLAYHINT) {
02292                     type = get_token(fp, token, MAXTOKEN);
02293                     <span class="keywordflow">if</span> (type != QUOTESTRING)
02294                         print_error(<span class="stringliteral">"DISPLAY-HINT must be string"</span>, token,
02295                                     type);
02296                     <span class="keywordflow">else</span>
02297                         hint = strdup(token);
02298                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == DESCRIPTION &amp;&amp;
02299                            netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
02300                                                   NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
02301                     type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02302                     <span class="keywordflow">if</span> (type != QUOTESTRING)
02303                         print_error(<span class="stringliteral">"DESCRIPTION must be string"</span>, token,
02304                                     type);
02305                     <span class="keywordflow">else</span>
02306                         descr = strdup(quoted_string_buffer);
02307                 } <span class="keywordflow">else</span>
02308                     type =
02309                         get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02310             }
02311             type = get_token(fp, token, MAXTOKEN);
02312             <span class="keywordflow">if</span> (type == OBJECT) {
02313                 type = get_token(fp, token, MAXTOKEN);
02314                 <span class="keywordflow">if</span> (type != IDENTIFIER) {
02315                     print_error(<span class="stringliteral">"Expected IDENTIFIER"</span>, token, type);
02316                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(hint);
02317                     <span class="keywordflow">return</span> NULL;
02318                 }
02319                 type = OBJID;
02320             }
02321         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == OBJECT) {
02322             type = get_token(fp, token, MAXTOKEN);
02323             <span class="keywordflow">if</span> (type != IDENTIFIER) {
02324                 print_error(<span class="stringliteral">"Expected IDENTIFIER"</span>, token, type);
02325                 <span class="keywordflow">return</span> NULL;
02326             }
02327             type = OBJID;
02328         }
02329 
02330         <span class="keywordflow">if</span> (type == LABEL) {
02331             type = get_tc(token, current_module, NULL, NULL, NULL, NULL);
02332         }
02333 
02334         <span class="comment">/*</span>
02335 <span class="comment">         * textual convention </span>
02336 <span class="comment">         */</span>
02337         <span class="keywordflow">for</span> (i = 0; i &lt; MAXTC; i++) {
02338             <span class="keywordflow">if</span> (tclist[i].type == 0)
02339                 <span class="keywordflow">break</span>;
02340         }
02341 
02342         <span class="keywordflow">if</span> (i == MAXTC) {
02343             print_error(<span class="stringliteral">"Too many textual conventions"</span>, token, type);
02344             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(hint);
02345             <span class="keywordflow">return</span> NULL;
02346         }
02347         <span class="keywordflow">if</span> (!(type &amp; SYNTAX_MASK)) {
02348             print_error(<span class="stringliteral">"Textual convention doesn't map to real type"</span>,
02349                         token, type);
02350             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(hint);
02351             <span class="keywordflow">return</span> NULL;
02352         }
02353         tcp = &amp;tclist[i];
02354         tcp-&gt;modid = current_module;
02355         tcp-&gt;descriptor = strdup(name);
02356         tcp-&gt;hint = hint;
02357         tcp-&gt;description = descr;
02358         tcp-&gt;type = type;
02359         *ntype = get_token(fp, ntoken, MAXTOKEN);
02360         <span class="keywordflow">if</span> (*ntype == LEFTPAREN) {
02361             tcp-&gt;ranges = parse_ranges(fp, &amp;tcp-&gt;ranges);
02362             *ntype = get_token(fp, ntoken, MAXTOKEN);
02363         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*ntype == LEFTBRACKET) {
02364             <span class="comment">/*</span>
02365 <span class="comment">             * if there is an enumeration list, parse it </span>
02366 <span class="comment">             */</span>
02367             tcp-&gt;enums = parse_enumlist(fp, &amp;tcp-&gt;enums);
02368             *ntype = get_token(fp, ntoken, MAXTOKEN);
02369         }
02370         <span class="keywordflow">return</span> NULL;
02371     }
02372 }
02373 
02374 
02375 <span class="comment">/*</span>
02376 <span class="comment"> * Parses an OBJECT TYPE macro.</span>
02377 <span class="comment"> * Returns 0 on error.</span>
02378 <span class="comment"> */</span>
02379 <span class="keyword">static</span> <span class="keyword">struct </span>node *
02380 parse_objecttype(FILE * fp, <span class="keywordtype">char</span> *name)
02381 {
02382     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
02383     <span class="keywordtype">char</span>            token[MAXTOKEN];
02384     <span class="keywordtype">char</span>            nexttoken[MAXTOKEN];
02385     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
02386     <span class="keywordtype">int</span>             nexttype, tctype;
02387     <span class="keyword">register</span> <span class="keyword">struct </span>node *np;
02388 
02389     type = get_token(fp, token, MAXTOKEN);
02390     <span class="keywordflow">if</span> (type != SYNTAX) {
02391         print_error(<span class="stringliteral">"Bad format for OBJECT-TYPE"</span>, token, type);
02392         <span class="keywordflow">return</span> NULL;
02393     }
02394     np = alloc_node(current_module);
02395     <span class="keywordflow">if</span> (np == NULL)
02396         <span class="keywordflow">return</span> (NULL);
02397     type = get_token(fp, token, MAXTOKEN);
02398     <span class="keywordflow">if</span> (type == OBJECT) {
02399         type = get_token(fp, token, MAXTOKEN);
02400         <span class="keywordflow">if</span> (type != IDENTIFIER) {
02401             print_error(<span class="stringliteral">"Expected IDENTIFIER"</span>, token, type);
02402             free_node(np);
02403             <span class="keywordflow">return</span> NULL;
02404         }
02405         type = OBJID;
02406     }
02407     <span class="keywordflow">if</span> (type == LABEL) {
02408         <span class="keywordtype">int</span>             tmp_index;
02409         tctype = get_tc(token, current_module, &amp;tmp_index,
02410                         &amp;np-&gt;enums, &amp;np-&gt;ranges, &amp;np-&gt;hint);
02411         <span class="keywordflow">if</span> (tctype == LABEL &amp;&amp;
02412             netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
02413                                NETSNMP_DS_LIB_MIB_WARNINGS) &gt; 1) {
02414             print_error(<span class="stringliteral">"Warning: No known translation for type"</span>, token,
02415                         type);
02416         }
02417         type = tctype;
02418         np-&gt;tc_index = tmp_index;       <span class="comment">/* store TC for later reference */</span>
02419     }
02420     np-&gt;type = type;
02421     nexttype = get_token(fp, nexttoken, MAXTOKEN);
02422     <span class="keywordflow">switch</span> (type) {
02423     <span class="keywordflow">case</span> SEQUENCE:
02424         <span class="keywordflow">if</span> (nexttype == OF) {
02425             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02426             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02427 
02428         }
02429         <span class="keywordflow">break</span>;
02430     <span class="keywordflow">case</span> INTEGER:
02431     <span class="keywordflow">case</span> INTEGER32:
02432     <span class="keywordflow">case</span> UINTEGER32:
02433     <span class="keywordflow">case</span> UNSIGNED32:
02434     <span class="keywordflow">case</span> COUNTER:
02435     <span class="keywordflow">case</span> GAUGE:
02436     <span class="keywordflow">case</span> BITSTRING:
02437     <span class="keywordflow">case</span> LABEL:
02438         <span class="keywordflow">if</span> (nexttype == LEFTBRACKET) {
02439             <span class="comment">/*</span>
02440 <span class="comment">             * if there is an enumeration list, parse it </span>
02441 <span class="comment">             */</span>
02442             np-&gt;enums = parse_enumlist(fp, &amp;np-&gt;enums);
02443             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02444         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nexttype == LEFTPAREN) {
02445             <span class="comment">/*</span>
02446 <span class="comment">             * if there is a range list, parse it </span>
02447 <span class="comment">             */</span>
02448             np-&gt;ranges = parse_ranges(fp, &amp;np-&gt;ranges);
02449             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02450         }
02451         <span class="keywordflow">break</span>;
02452     <span class="keywordflow">case</span> OCTETSTR:
02453     <span class="keywordflow">case</span> KW_OPAQUE:
02454         <span class="comment">/*</span>
02455 <span class="comment">         * parse any SIZE specification </span>
02456 <span class="comment">         */</span>
02457         <span class="keywordflow">if</span> (nexttype == LEFTPAREN) {
02458             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02459             <span class="keywordflow">if</span> (nexttype == SIZE) {
02460                 nexttype = get_token(fp, nexttoken, MAXTOKEN);
02461                 <span class="keywordflow">if</span> (nexttype == LEFTPAREN) {
02462                     np-&gt;ranges = parse_ranges(fp, &amp;np-&gt;ranges);
02463                     nexttype = get_token(fp, nexttoken, MAXTOKEN);      <span class="comment">/* ) */</span>
02464                     <span class="keywordflow">if</span> (nexttype == RIGHTPAREN) {
02465                         nexttype = get_token(fp, nexttoken, MAXTOKEN);
02466                         <span class="keywordflow">break</span>;
02467                     }
02468                 }
02469             }
02470             print_error(<span class="stringliteral">"Bad SIZE syntax"</span>, token, type);
02471             free_node(np);
02472             <span class="keywordflow">return</span> NULL;
02473         }
02474         <span class="keywordflow">break</span>;
02475     <span class="keywordflow">case</span> OBJID:
02476     <span class="keywordflow">case</span> NETADDR:
02477     <span class="keywordflow">case</span> IPADDR:
02478     <span class="keywordflow">case</span> TIMETICKS:
02479     <span class="keywordflow">case</span> NUL:
02480     <span class="keywordflow">case</span> NSAPADDRESS:
02481     <span class="keywordflow">case</span> COUNTER64:
02482         <span class="keywordflow">break</span>;
02483     <span class="keywordflow">default</span>:
02484         print_error(<span class="stringliteral">"Bad syntax"</span>, token, type);
02485         free_node(np);
02486         <span class="keywordflow">return</span> NULL;
02487     }
02488     <span class="keywordflow">if</span> (nexttype == UNITS) {
02489         type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02490         <span class="keywordflow">if</span> (type != QUOTESTRING) {
02491             print_error(<span class="stringliteral">"Bad UNITS"</span>, quoted_string_buffer, type);
02492             free_node(np);
02493             <span class="keywordflow">return</span> NULL;
02494         }
02495         np-&gt;units = strdup(quoted_string_buffer);
02496         nexttype = get_token(fp, nexttoken, MAXTOKEN);
02497     }
02498     <span class="keywordflow">if</span> (nexttype != ACCESS) {
02499         print_error(<span class="stringliteral">"Should be ACCESS"</span>, nexttoken, nexttype);
02500         free_node(np);
02501         <span class="keywordflow">return</span> NULL;
02502     }
02503     type = get_token(fp, token, MAXTOKEN);
02504     <span class="keywordflow">if</span> (type != READONLY &amp;&amp; type != READWRITE &amp;&amp; type != WRITEONLY
02505         &amp;&amp; type != NOACCESS &amp;&amp; type != READCREATE &amp;&amp; type != ACCNOTIFY) {
02506         print_error(<span class="stringliteral">"Bad ACCESS type"</span>, token, type);
02507         free_node(np);
02508         <span class="keywordflow">return</span> NULL;
02509     }
02510     np-&gt;access = type;
02511     type = get_token(fp, token, MAXTOKEN);
02512     <span class="keywordflow">if</span> (type != STATUS) {
02513         print_error(<span class="stringliteral">"Should be STATUS"</span>, token, type);
02514         free_node(np);
02515         <span class="keywordflow">return</span> NULL;
02516     }
02517     type = get_token(fp, token, MAXTOKEN);
02518     <span class=
"keywordflow">if</span> (type != MANDATORY &amp;&amp; type != CURRENT &amp;&amp; type != KW_OPTIONAL &amp;&amp;
02519         type != OBSOLETE &amp;&amp; type != DEPRECATED) {
02520         print_error(<span class="stringliteral">"Bad STATUS"</span>, token, type);
02521         free_node(np);
02522         <span class="keywordflow">return</span> NULL;
02523     }
02524     np-&gt;status = type;
02525     <span class="comment">/*</span>
02526 <span class="comment">     * Optional parts of the OBJECT-TYPE macro</span>
02527 <span class="comment">     */</span>
02528     type = get_token(fp, token, MAXTOKEN);
02529     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE) {
02530         <span class="keywordflow">switch</span> (type) {
02531         <span class="keywordflow">case</span> DESCRIPTION:
02532             type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02533 
02534             <span class="keywordflow">if</span> (type != QUOTESTRING) {
02535                 print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
02536                 free_node(np);
02537                 <span class="keywordflow">return</span> NULL;
02538             }
02539             <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
02540                                        NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
02541                 np-&gt;description = strdup(quoted_string_buffer);
02542             }
02543             <span class="keywordflow">break</span>;
02544 
02545         <span class="keywordflow">case</span> REFERENCE:
02546             type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02547             <span class="keywordflow">if</span> (type != QUOTESTRING) {
02548                 print_error(<span class="stringliteral">"Bad REFERENCE"</span>, quoted_string_buffer, type);
02549                 free_node(np);
02550                 <span class="keywordflow">return</span> NULL;
02551             }
02552             np-&gt;reference = strdup(quoted_string_buffer);
02553             <span class="keywordflow">break</span>;
02554         <span class="keywordflow">case</span> INDEX:
02555             <span class="keywordflow">if</span> (np-&gt;augments) {
02556                 print_error(<span class="stringliteral">"Cannot have both INDEX and AUGMENTS"</span>, token,
02557                             type);
02558                 free_node(np);
02559                 <span class="keywordflow">return</span> NULL;
02560             }
02561             np-&gt;indexes = getIndexes(fp, &amp;np-&gt;indexes);
02562             <span class="keywordflow">if</span> (np-&gt;indexes == NULL) {
02563                 print_error(<span class="stringliteral">"Bad INDEX list"</span>, token, type);
02564                 free_node(np);
02565                 <span class="keywordflow">return</span> NULL;
02566             }
02567             <span class="keywordflow">break</span>;
02568         <span class="keywordflow">case</span> AUGMENTS:
02569             <span class="keywordflow">if</span> (np-&gt;indexes) {
02570                 print_error(<span class="stringliteral">"Cannot have both INDEX and AUGMENTS"</span>, token,
02571                             type);
02572                 free_node(np);
02573                 <span class="keywordflow">return</span> NULL;
02574             }
02575             np-&gt;indexes = getIndexes(fp, &amp;np-&gt;indexes);
02576             <span class="keywordflow">if</span> (np-&gt;indexes == NULL) {
02577                 print_error(<span class="stringliteral">"Bad AUGMENTS list"</span>, token, type);
02578                 free_node(np);
02579                 <span class="keywordflow">return</span> NULL;
02580             }
02581             np-&gt;augments = strdup(np-&gt;indexes-&gt;ilabel);
02582             free_indexes(&amp;np-&gt;indexes);
02583             <span class="keywordflow">break</span>;
02584         <span class="keywordflow">case</span> DEFVAL:
02585             <span class="comment">/*</span>
02586 <span class="comment">             * Mark's defVal section </span>
02587 <span class="comment">             */</span>
02588             type = get_token(fp, quoted_string_buffer, MAXTOKEN);
02589             <span class="keywordflow">if</span> (type != LEFTBRACKET) {
02590                 print_error(<span class="stringliteral">"Bad DEFAULTVALUE"</span>, quoted_string_buffer,
02591                             type);
02592                 free_node(np);
02593                 <span class="keywordflow">return</span> NULL;
02594             }
02595 
02596             {
02597                 <span class="keywordtype">int</span>             level = 1;
02598                 <span class="keywordtype">char</span>            defbuf[512];
02599 
02600                 defbuf[0] = 0;
02601                 <span class="keywordflow">while</span> (1) {
02602                     type = get_token(fp, quoted_string_buffer, MAXTOKEN);
02603                     <span class="keywordflow">if</span> ((type == RIGHTBRACKET &amp;&amp; --level == 0)
02604                         || type == ENDOFFILE)
02605                         <span class="keywordflow">break</span>;
02606                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == LEFTBRACKET)
02607                         level++;
02608                     <span class="keywordflow">if</span> (type == QUOTESTRING) {
02609                         <span class="keywordflow">if</span> (strlen(defbuf)+2 &lt; <span class=
"keyword">sizeof</span>(defbuf)) {
02610                             defbuf[ strlen(defbuf)+2 ] = 0;
02611                             defbuf[ strlen(defbuf)+1 ] = <span class="charliteral">'"'</span>;
02612                             defbuf[ strlen(defbuf)   ] = <span class="charliteral">'\\'</span>;
02613                         }
02614                         defbuf[ <span class="keyword">sizeof</span>(defbuf)-1 ] = 0;
02615                     }
02616                     strncat(defbuf, quoted_string_buffer,
02617                             <span class="keyword">sizeof</span>(defbuf)-strlen(defbuf));
02618                     defbuf[ <span class="keyword">sizeof</span>(defbuf)-1 ] = 0;
02619                     <span class="keywordflow">if</span> (type == QUOTESTRING) {
02620                         <span class="keywordflow">if</span> (strlen(defbuf)+2 &lt; <span class=
"keyword">sizeof</span>(defbuf)) {
02621                             defbuf[ strlen(defbuf)+2 ] = 0;
02622                             defbuf[ strlen(defbuf)+1 ] = <span class="charliteral">'"'</span>;
02623                             defbuf[ strlen(defbuf)   ] = <span class="charliteral">'\\'</span>;
02624                         }
02625                         defbuf[ <span class="keyword">sizeof</span>(defbuf)-1 ] = 0;
02626                     }
02627                     <span class="keywordflow">if</span> (strlen(defbuf)+1 &lt; <span class=
"keyword">sizeof</span>(defbuf)) {
02628                         defbuf[ strlen(defbuf)+1 ] = 0;
02629                         defbuf[ strlen(defbuf)   ] = <span class="charliteral">' '</span>;
02630                     }
02631                 }
02632 
02633                 <span class="keywordflow">if</span> (type != RIGHTBRACKET) {
02634                     print_error(<span class="stringliteral">"Bad DEFAULTVALUE"</span>, quoted_string_buffer,
02635                                 type);
02636                     free_node(np);
02637                     <span class="keywordflow">return</span> NULL;
02638                 }
02639 
02640                 defbuf[strlen(defbuf) - 1] = 0;
02641                 np-&gt;defaultValue = strdup(defbuf);
02642             }
02643 
02644             <span class="keywordflow">break</span>;
02645 
02646         <span class="keywordflow">case</span> NUM_ENTRIES:
02647             <span class="keywordflow">if</span> (tossObjectIdentifier(fp) != OBJID) {
02648                 print_error(<span class="stringliteral">"Bad Object Identifier"</span>, token, type);
02649                 free_node(np);
02650                 <span class="keywordflow">return</span> NULL;
02651             }
02652             <span class="keywordflow">break</span>;
02653 
02654         <span class="keywordflow">default</span>:
02655             print_error(<span class="stringliteral">"Bad format of optional clauses"</span>, token, type);
02656             free_node(np);
02657             <span class="keywordflow">return</span> NULL;
02658 
02659         }
02660         type = get_token(fp, token, MAXTOKEN);
02661     }
02662     <span class="keywordflow">if</span> (type != EQUALS) {
02663         print_error(<span class="stringliteral">"Bad format"</span>, token, type);
02664         free_node(np);
02665         <span class="keywordflow">return</span> NULL;
02666     }
02667     <span class="keywordflow">return</span> merge_parse_objectid(np, fp, name);
02668 }
02669 
02670 <span class="comment">/*</span>
02671 <span class="comment"> * Parses an OBJECT GROUP macro.</span>
02672 <span class="comment"> * Returns 0 on error.</span>
02673 <span class="comment"> *</span>
02674 <span class="comment"> * Also parses object-identity, since they are similar (ignore STATUS).</span>
02675 <span class="comment"> *   - WJH 10/96</span>
02676 <span class="comment"> */</span>
02677 <span class="keyword">static</span> <span class="keyword">struct </span>node *
02678 parse_objectgroup(FILE * fp, <span class="keywordtype">char</span> *name, <span class=
"keywordtype">int</span> what, <span class="keyword">struct</span> objgroup **ol)
02679 {
02680     <span class="keywordtype">int</span>             type;
02681     <span class="keywordtype">char</span>            token[MAXTOKEN];
02682     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
02683     <span class="keyword">struct </span>node    *np;
02684 
02685     np = alloc_node(current_module);
02686     <span class="keywordflow">if</span> (np == NULL)
02687         <span class="keywordflow">return</span> (NULL);
02688     type = get_token(fp, token, MAXTOKEN);
02689     <span class="keywordflow">if</span> (type == what) {
02690         type = get_token(fp, token, MAXTOKEN);
02691         <span class="keywordflow">if</span> (type != LEFTBRACKET) {
02692             print_error(<span class="stringliteral">"Expected \"{\""</span>, token, type);
02693             <span class="keywordflow">goto</span> skip;
02694         }
02695         <span class="keywordflow">do</span> {
02696             <span class="keyword">struct </span>objgroup *o;
02697             type = get_token(fp, token, MAXTOKEN);
02698             <span class="keywordflow">if</span> (type != LABEL) {
02699                 print_error(<span class="stringliteral">"Bad identifier"</span>, token, type);
02700                 <span class="keywordflow">goto</span> skip;
02701             }
02702             o = (<span class="keyword">struct </span>objgroup *) malloc(<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> objgroup));
02703             <span class="keywordflow">if</span> (!o) {
02704                 print_error(<span class="stringliteral">"Resource failure"</span>, token, type);
02705                 <span class="keywordflow">goto</span> skip;
02706             }
02707             o-&gt;line = mibLine;
02708             o-&gt;name = strdup(token);
02709             o-&gt;next = *ol;
02710             *ol = o;
02711             type = get_token(fp, token, MAXTOKEN);
02712         } <span class="keywordflow">while</span> (type == COMMA);
02713         <span class="keywordflow">if</span> (type != RIGHTBRACKET) {
02714             print_error(<span class="stringliteral">"Expected \"}\" after list"</span>, token, type);
02715             <span class="keywordflow">goto</span> skip;
02716         }
02717         type = get_token(fp, token, type);
02718     }
02719     <span class="keywordflow">if</span> (type != STATUS) {
02720         print_error(<span class="stringliteral">"Expected STATUS"</span>, token, type);
02721         <span class="keywordflow">goto</span> skip;
02722     }
02723     type = get_token(fp, token, MAXTOKEN);
02724     <span class="keywordflow">if</span> (type != CURRENT &amp;&amp; type != DEPRECATED &amp;&amp; type != OBSOLETE) {
02725         print_error(<span class="stringliteral">"Bad STATUS value"</span>, token, type);
02726         <span class="keywordflow">goto</span> skip;
02727     }
02728     type = get_token(fp, token, MAXTOKEN);
02729     <span class="keywordflow">if</span> (type != DESCRIPTION) {
02730         print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
02731         <span class="keywordflow">goto</span> skip;
02732     }
02733     type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02734     <span class="keywordflow">if</span> (type != QUOTESTRING) {
02735         print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
02736         free_node(np);
02737         <span class="keywordflow">return</span> NULL;
02738     }
02739     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
02740                                NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
02741         np-&gt;description = strdup(quoted_string_buffer);
02742     }
02743     type = get_token(fp, token, MAXTOKEN);
02744     <span class="keywordflow">if</span> (type == REFERENCE) {
02745         type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02746         <span class="keywordflow">if</span> (type != QUOTESTRING) {
02747             print_error(<span class="stringliteral">"Bad REFERENCE"</span>, quoted_string_buffer, type);
02748             free_node(np);
02749             <span class="keywordflow">return</span> NULL;
02750         }
02751         np-&gt;reference = strdup(quoted_string_buffer);
02752         type = get_token(fp, token, MAXTOKEN);
02753     }
02754     <span class="keywordflow">if</span> (type != EQUALS)
02755         print_error(<span class="stringliteral">"Expected \"::=\""</span>, token, type);
02756   skip:
02757     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE)
02758         type = get_token(fp, token, MAXTOKEN);
02759 
02760     <span class="keywordflow">return</span> merge_parse_objectid(np, fp, name);
02761 }
02762 
02763 <span class="comment">/*</span>
02764 <span class="comment"> * Parses a NOTIFICATION-TYPE macro.</span>
02765 <span class="comment"> * Returns 0 on error.</span>
02766 <span class="comment"> */</span>
02767 <span class="keyword">static</span> <span class="keyword">struct </span>node *
02768 parse_notificationDefinition(FILE * fp, <span class="keywordtype">char</span> *name)
02769 {
02770     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
02771     <span class="keywordtype">char</span>            token[MAXTOKEN];
02772     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
02773     <span class="keyword">register</span> <span class="keyword">struct </span>node *np;
02774 
02775     np = alloc_node(current_module);
02776     <span class="keywordflow">if</span> (np == NULL)
02777         <span class="keywordflow">return</span> (NULL);
02778     type = get_token(fp, token, MAXTOKEN);
02779     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE) {
02780         <span class="keywordflow">switch</span> (type) {
02781         <span class="keywordflow">case</span> DESCRIPTION:
02782             type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02783             <span class="keywordflow">if</span> (type != QUOTESTRING) {
02784                 print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
02785                 free_node(np);
02786                 <span class="keywordflow">return</span> NULL;
02787             }
02788             <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
02789                                        NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
02790                 np-&gt;description = strdup(quoted_string_buffer);
02791             }
02792             <span class="keywordflow">break</span>;
02793         <span class="keywordflow">case</span> REFERENCE:
02794             type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02795             <span class="keywordflow">if</span> (type != QUOTESTRING) {
02796                 print_error(<span class="stringliteral">"Bad REFERENCE"</span>, quoted_string_buffer, type);
02797                 free_node(np);
02798                 <span class="keywordflow">return</span> NULL;
02799             }
02800             np-&gt;reference = strdup(quoted_string_buffer);
02801             <span class="keywordflow">break</span>;
02802         <span class="keywordflow">case</span> OBJECTS:
02803             np-&gt;varbinds = getVarbinds(fp, &amp;np-&gt;varbinds);
02804             <span class="keywordflow">if</span> (!np-&gt;varbinds) {
02805                 print_error(<span class="stringliteral">"Bad OBJECTS list"</span>, token, type);
02806                 free_node(np);
02807                 <span class="keywordflow">return</span> NULL;
02808             }
02809             <span class="keywordflow">break</span>;
02810         <span class="keywordflow">default</span>:
02811             <span class="comment">/*</span>
02812 <span class="comment">             * NOTHING </span>
02813 <span class="comment">             */</span>
02814             <span class="keywordflow">break</span>;
02815         }
02816         type = get_token(fp, token, MAXTOKEN);
02817     }
02818     <span class="keywordflow">return</span> merge_parse_objectid(np, fp, name);
02819 }
02820 
02821 <span class="comment">/*</span>
02822 <span class="comment"> * Parses a TRAP-TYPE macro.</span>
02823 <span class="comment"> * Returns 0 on error.</span>
02824 <span class="comment"> */</span>
02825 <span class="keyword">static</span> <span class="keyword">struct </span>node *
02826 parse_trapDefinition(FILE * fp, <span class="keywordtype">char</span> *name)
02827 {
02828     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
02829     <span class="keywordtype">char</span>            token[MAXTOKEN];
02830     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
02831     <span class="keyword">register</span> <span class="keyword">struct </span>node *np;
02832 
02833     np = alloc_node(current_module);
02834     <span class="keywordflow">if</span> (np == NULL)
02835         <span class="keywordflow">return</span> (NULL);
02836     type = get_token(fp, token, MAXTOKEN);
02837     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE) {
02838         <span class="keywordflow">switch</span> (type) {
02839         <span class="keywordflow">case</span> DESCRIPTION:
02840             type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02841             <span class="keywordflow">if</span> (type != QUOTESTRING) {
02842                 print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
02843                 free_node(np);
02844                 <span class="keywordflow">return</span> NULL;
02845             }
02846             <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
02847                                        NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
02848                 np-&gt;description = strdup(quoted_string_buffer);
02849             }
02850             <span class="keywordflow">break</span>;
02851         <span class="keywordflow">case</span> REFERENCE:
02852             <span class="comment">/* I'm not sure REFERENCEs are legal in smiv1 traps??? */</span>
02853             type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02854             <span class="keywordflow">if</span> (type != QUOTESTRING) {
02855                 print_error(<span class="stringliteral">"Bad REFERENCE"</span>, quoted_string_buffer, type);
02856                 free_node(np);
02857                 <span class="keywordflow">return</span> NULL;
02858             }
02859             np-&gt;reference = strdup(quoted_string_buffer);
02860             <span class="keywordflow">break</span>;
02861         <span class="keywordflow">case</span> ENTERPRISE:
02862             type = get_token(fp, token, MAXTOKEN);
02863             <span class="keywordflow">if</span> (type == LEFTBRACKET) {
02864                 type = get_token(fp, token, MAXTOKEN);
02865                 <span class="keywordflow">if</span> (type != LABEL) {
02866                     print_error(<span class="stringliteral">"Bad Trap Format"</span>, token, type);
02867                     free_node(np);
02868                     <span class="keywordflow">return</span> NULL;
02869                 }
02870                 np-&gt;parent = strdup(token);
02871                 <span class="comment">/*</span>
02872 <span class="comment">                 * Get right bracket </span>
02873 <span class="comment">                 */</span>
02874                 type = get_token(fp, token, MAXTOKEN);
02875             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == LABEL)
02876                 np-&gt;parent = strdup(token);
02877             <span class="keywordflow">break</span>;
02878         <span class="keywordflow">case</span> VARIABLES:
02879             np-&gt;varbinds = getVarbinds(fp, &amp;np-&gt;varbinds);
02880             <span class="keywordflow">if</span> (!np-&gt;varbinds) {
02881                 print_error(<span class="stringliteral">"Bad VARIABLES list"</span>, token, type);
02882                 free_node(np);
02883                 <span class="keywordflow">return</span> NULL;
02884             }
02885             <span class="keywordflow">break</span>;
02886         <span class="keywordflow">default</span>:
02887             <span class="comment">/*</span>
02888 <span class="comment">             * NOTHING </span>
02889 <span class="comment">             */</span>
02890             <span class="keywordflow">break</span>;
02891         }
02892         type = get_token(fp, token, MAXTOKEN);
02893     }
02894     type = get_token(fp, token, MAXTOKEN);
02895 
02896     np-&gt;label = strdup(name);
02897 
02898     <span class="keywordflow">if</span> (type != NUMBER) {
02899         print_error(<span class="stringliteral">"Expected a Number"</span>, token, type);
02900         free_node(np);
02901         <span class="keywordflow">return</span> NULL;
02902     }
02903     np-&gt;subid = strtoul(token, NULL, 10);
02904     np-&gt;next = alloc_node(current_module);
02905     <span class="keywordflow">if</span> (np-&gt;next == NULL) {
02906         free_node(np);
02907         <span class="keywordflow">return</span> (NULL);
02908     }
02909     np-&gt;next-&gt;parent = np-&gt;parent;
02910     np-&gt;parent = (<span class="keywordtype">char</span> *) malloc(strlen(np-&gt;parent) + 2);
02911     <span class="keywordflow">if</span> (np-&gt;parent == NULL) {
02912         free_node(np-&gt;next);
02913         free_node(np);
02914         <span class="keywordflow">return</span> (NULL);
02915     }
02916     strcpy(np-&gt;parent, np-&gt;next-&gt;parent);
02917     strcat(np-&gt;parent, <span class="stringliteral">"#"</span>);
02918     np-&gt;next-&gt;label = strdup(np-&gt;parent);
02919     <span class="keywordflow">return</span> np;
02920 }
02921 
02922 
02923 <span class="comment">/*</span>
02924 <span class="comment"> * Parses a compliance macro</span>
02925 <span class="comment"> * Returns 0 on error.</span>
02926 <span class="comment"> */</span>
02927 <span class="keyword">static</span> <span class="keywordtype">int</span>
02928 eat_syntax(FILE * fp, <span class="keywordtype">char</span> *token, <span class="keywordtype">int</span> maxtoken)
02929 {
02930     <span class="keywordtype">int</span>             type, nexttype;
02931     <span class="keyword">struct </span>node    *np = alloc_node(current_module);
02932     <span class="keywordtype">char</span>            nexttoken[MAXTOKEN];
02933 
02934     type = get_token(fp, token, maxtoken);
02935     nexttype = get_token(fp, nexttoken, MAXTOKEN);
02936     <span class="keywordflow">switch</span> (type) {
02937     <span class="keywordflow">case</span> INTEGER:
02938     <span class="keywordflow">case</span> INTEGER32:
02939     <span class="keywordflow">case</span> UINTEGER32:
02940     <span class="keywordflow">case</span> UNSIGNED32:
02941     <span class="keywordflow">case</span> COUNTER:
02942     <span class="keywordflow">case</span> GAUGE:
02943     <span class="keywordflow">case</span> BITSTRING:
02944     <span class="keywordflow">case</span> LABEL:
02945         <span class="keywordflow">if</span> (nexttype == LEFTBRACKET) {
02946             <span class="comment">/*</span>
02947 <span class="comment">             * if there is an enumeration list, parse it </span>
02948 <span class="comment">             */</span>
02949             np-&gt;enums = parse_enumlist(fp, &amp;np-&gt;enums);
02950             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02951         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nexttype == LEFTPAREN) {
02952             <span class="comment">/*</span>
02953 <span class="comment">             * if there is a range list, parse it </span>
02954 <span class="comment">             */</span>
02955             np-&gt;ranges = parse_ranges(fp, &amp;np-&gt;ranges);
02956             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02957         }
02958         <span class="keywordflow">break</span>;
02959     <span class="keywordflow">case</span> OCTETSTR:
02960     <span class="keywordflow">case</span> KW_OPAQUE:
02961         <span class="comment">/*</span>
02962 <span class="comment">         * parse any SIZE specification </span>
02963 <span class="comment">         */</span>
02964         <span class="keywordflow">if</span> (nexttype == LEFTPAREN) {
02965             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02966             <span class="keywordflow">if</span> (nexttype == SIZE) {
02967                 nexttype = get_token(fp, nexttoken, MAXTOKEN);
02968                 <span class="keywordflow">if</span> (nexttype == LEFTPAREN) {
02969                     np-&gt;ranges = parse_ranges(fp, &amp;np-&gt;ranges);
02970                     nexttype = get_token(fp, nexttoken, MAXTOKEN);      <span class="comment">/* ) */</span>
02971                     <span class="keywordflow">if</span> (nexttype == RIGHTPAREN) {
02972                         nexttype = get_token(fp, nexttoken, MAXTOKEN);
02973                         <span class="keywordflow">break</span>;
02974                     }
02975                 }
02976             }
02977             print_error(<span class="stringliteral">"Bad SIZE syntax"</span>, token, type);
02978             free_node(np);
02979             <span class="keywordflow">return</span> nexttype;
02980         }
02981         <span class="keywordflow">break</span>;
02982     <span class="keywordflow">case</span> OBJID:
02983     <span class="keywordflow">case</span> NETADDR:
02984     <span class="keywordflow">case</span> IPADDR:
02985     <span class="keywordflow">case</span> TIMETICKS:
02986     <span class="keywordflow">case</span> NUL:
02987     <span class="keywordflow">case</span> NSAPADDRESS:
02988     <span class="keywordflow">case</span> COUNTER64:
02989         <span class="keywordflow">break</span>;
02990     <span class="keywordflow">default</span>:
02991         print_error(<span class="stringliteral">"Bad syntax"</span>, token, type);
02992         free_node(np);
02993         <span class="keywordflow">return</span> nexttype;
02994     }
02995     free_node(np);
02996     <span class="keywordflow">return</span> nexttype;
02997 }
02998 
02999 <span class="keyword">static</span> <span class="keywordtype">int</span>
03000 compliance_lookup(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class=
"keywordtype">int</span> modid)
03001 {
03002     <span class="keywordflow">if</span> (modid == -1) {
03003         <span class="keyword">struct </span>objgroup *op =
03004             (<span class="keyword">struct </span>objgroup *) malloc(<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> objgroup));
03005         <span class="keywordflow">if</span> (!op)
03006             <span class="keywordflow">return</span> 0;
03007         op-&gt;next = objgroups;
03008         op-&gt;name = strdup(name);
03009         op-&gt;line = mibLine;
03010         objgroups = op;
03011         <span class="keywordflow">return</span> 1;
03012     } <span class="keywordflow">else</span>
03013         <span class="keywordflow">return</span> find_tree_node(name, modid) != NULL;
03014 }
03015 
03016 <span class="keyword">static</span> <span class="keyword">struct </span>node *
03017 parse_compliance(FILE * fp, <span class="keywordtype">char</span> *name)
03018 {
03019     <span class="keywordtype">int</span>             type;
03020     <span class="keywordtype">char</span>            token[MAXTOKEN];
03021     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
03022     <span class="keyword">struct </span>node    *np;
03023 
03024     np = alloc_node(current_module);
03025     <span class="keywordflow">if</span> (np == NULL)
03026         <span class="keywordflow">return</span> (NULL);
03027     type = get_token(fp, token, MAXTOKEN);
03028     <span class="keywordflow">if</span> (type != STATUS) {
03029         print_error(<span class="stringliteral">"Expected STATUS"</span>, token, type);
03030         <span class="keywordflow">goto</span> skip;
03031     }
03032     type = get_token(fp, token, MAXTOKEN);
03033     <span class="keywordflow">if</span> (type != CURRENT &amp;&amp; type != DEPRECATED &amp;&amp; type != OBSOLETE) {
03034         print_error(<span class="stringliteral">"Bad STATUS"</span>, token, type);
03035         <span class="keywordflow">goto</span> skip;
03036     }
03037     type = get_token(fp, token, MAXTOKEN);
03038     <span class="keywordflow">if</span> (type != DESCRIPTION) {
03039         print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
03040         <span class="keywordflow">goto</span> skip;
03041     }
03042     type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03043     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03044         print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
03045         <span class="keywordflow">goto</span> skip;
03046     }
03047     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
03048                                NETSNMP_DS_LIB_SAVE_MIB_DESCRS))
03049         np-&gt;description = strdup(quoted_string_buffer);
03050     type = get_token(fp, token, MAXTOKEN);
03051     <span class="keywordflow">if</span> (type == REFERENCE) {
03052         type = get_token(fp, quoted_string_buffer, MAXTOKEN);
03053         <span class="keywordflow">if</span> (type != QUOTESTRING) {
03054             print_error(<span class="stringliteral">"Bad REFERENCE"</span>, quoted_string_buffer, type);
03055             <span class="keywordflow">goto</span> skip;
03056         }
03057         np-&gt;reference = strdup(quoted_string_buffer);
03058         type = get_token(fp, token, MAXTOKEN);
03059     }
03060     <span class="keywordflow">if</span> (type != MODULE) {
03061         print_error(<span class="stringliteral">"Expected MODULE"</span>, token, type);
03062         <span class="keywordflow">goto</span> skip;
03063     }
03064     <span class="keywordflow">while</span> (type == MODULE) {
03065         <span class="keywordtype">int</span>             modid = -1;
03066         <span class="keywordtype">char</span>            modname[MAXTOKEN];
03067         type = get_token(fp, token, MAXTOKEN);
03068         <span class="keywordflow">if</span> (type == LABEL
03069             &amp;&amp; strcmp(token, module_name(current_module, modname))) {
03070             modid = read_module_internal(token);
03071             <span class="keywordflow">if</span> (modid != MODULE_LOADED_OK
03072                 &amp;&amp; modid != MODULE_ALREADY_LOADED) {
03073                 print_error(<span class="stringliteral">"Unknown module"</span>, token, type);
03074                 <span class="keywordflow">goto</span> skip;
03075             }
03076             modid = which_module(token);
03077             type = get_token(fp, token, MAXTOKEN);
03078         }
03079         <span class="keywordflow">if</span> (type == MANDATORYGROUPS) {
03080             type = get_token(fp, token, MAXTOKEN);
03081             <span class="keywordflow">if</span> (type != LEFTBRACKET) {
03082                 print_error(<span class="stringliteral">"Expected \"{\""</span>, token, type);
03083                 <span class="keywordflow">goto</span> skip;
03084             }
03085             <span class="keywordflow">do</span> {
03086                 type = get_token(fp, token, MAXTOKEN);
03087                 <span class="keywordflow">if</span> (type != LABEL) {
03088                     print_error(<span class="stringliteral">"Bad group name"</span>, token, type);
03089                     <span class="keywordflow">goto</span> skip;
03090                 }
03091                 <span class="keywordflow">if</span> (!compliance_lookup(token, modid))
03092                     print_error(<span class="stringliteral">"Unknown group"</span>, token, type);
03093                 type = get_token(fp, token, MAXTOKEN);
03094             } <span class="keywordflow">while</span> (type == COMMA);
03095             <span class="keywordflow">if</span> (type != RIGHTBRACKET) {
03096                 print_error(<span class="stringliteral">"Expected \"}\""</span>, token, type);
03097                 <span class="keywordflow">goto</span> skip;
03098             }
03099             type = get_token(fp, token, MAXTOKEN);
03100         }
03101         <span class="keywordflow">while</span> (type == GROUP || type == OBJECT) {
03102             <span class="keywordflow">if</span> (type == GROUP) {
03103                 type = get_token(fp, token, MAXTOKEN);
03104                 <span class="keywordflow">if</span> (type != LABEL) {
03105                     print_error(<span class="stringliteral">"Bad group name"</span>, token, type);
03106                     <span class="keywordflow">goto</span> skip;
03107                 }
03108                 <span class="keywordflow">if</span> (!compliance_lookup(token, modid))
03109                     print_error(<span class="stringliteral">"Unknown group"</span>, token, type);
03110                 type = get_token(fp, token, MAXTOKEN);
03111             } <span class="keywordflow">else</span> {
03112                 type = get_token(fp, token, MAXTOKEN);
03113                 <span class="keywordflow">if</span> (type != LABEL) {
03114                     print_error(<span class="stringliteral">"Bad object name"</span>, token, type);
03115                     <span class="keywordflow">goto</span> skip;
03116                 }
03117                 <span class="keywordflow">if</span> (!compliance_lookup(token, modid))
03118                     print_error(<span class="stringliteral">"Unknown group"</span>, token, type);
03119                 type = get_token(fp, token, MAXTOKEN);
03120                 <span class="keywordflow">if</span> (type == SYNTAX)
03121                     type = eat_syntax(fp, token, MAXTOKEN);
03122                 <span class="keywordflow">if</span> (type == WRSYNTAX)
03123                     type = eat_syntax(fp, token, MAXTOKEN);
03124                 <span class="keywordflow">if</span> (type == MINACCESS) {
03125                     type = get_token(fp, token, MAXTOKEN);
03126                     <span class="keywordflow">if</span> (type != NOACCESS &amp;&amp; type != ACCNOTIFY
03127                         &amp;&amp; type != READONLY &amp;&amp; type != WRITEONLY
03128                         &amp;&amp; type != READCREATE &amp;&amp; type != READWRITE) {
03129                         print_error(<span class="stringliteral">"Bad MIN-ACCESS spec"</span>, token, type);
03130                         <span class="keywordflow">goto</span> skip;
03131                     }
03132                     type = get_token(fp, token, MAXTOKEN);
03133                 }
03134             }
03135             <span class="keywordflow">if</span> (type != DESCRIPTION) {
03136                 print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
03137                 <span class="keywordflow">goto</span> skip;
03138             }
03139             type = get_token(fp, token, MAXTOKEN);
03140             <span class="keywordflow">if</span> (type != QUOTESTRING) {
03141                 print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, token, type);
03142                 <span class="keywordflow">goto</span> skip;
03143             }
03144             type = get_token(fp, token, MAXTOKEN);
03145         }
03146     }
03147   skip:
03148     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE)
03149         type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03150 
03151     <span class="keywordflow">return</span> merge_parse_objectid(np, fp, name);
03152 }
03153 
03154 
03155 <span class="comment">/*</span>
03156 <span class="comment"> * Parses a capabilities macro</span>
03157 <span class="comment"> * Returns 0 on error.</span>
03158 <span class="comment"> */</span>
03159 <span class="keyword">static</span> <span class="keyword">struct </span>node *
03160 parse_capabilities(FILE * fp, <span class="keywordtype">char</span> *name)
03161 {
03162     <span class="keywordtype">int</span>             type;
03163     <span class="keywordtype">char</span>            token[MAXTOKEN];
03164     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
03165     <span class="keyword">struct </span>node    *np;
03166 
03167     np = alloc_node(current_module);
03168     <span class="keywordflow">if</span> (np == NULL)
03169         <span class="keywordflow">return</span> (NULL);
03170     type = get_token(fp, token, MAXTOKEN);
03171     <span class="keywordflow">if</span> (type != PRODREL) {
03172         print_error(<span class="stringliteral">"Expected PRODUCT-RELEASE"</span>, token, type);
03173         <span class="keywordflow">goto</span> skip;
03174     }
03175     type = get_token(fp, token, MAXTOKEN);
03176     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03177         print_error(<span class="stringliteral">"Expected STRING after PRODUCT-RELEASE"</span>, token, type);
03178         <span class="keywordflow">goto</span> skip;
03179     }
03180     type = get_token(fp, token, MAXTOKEN);
03181     <span class="keywordflow">if</span> (type != STATUS) {
03182         print_error(<span class="stringliteral">"Expected STATUS"</span>, token, type);
03183         <span class="keywordflow">goto</span> skip;
03184     }
03185     type = get_token(fp, token, MAXTOKEN);
03186     <span class="keywordflow">if</span> (type != CURRENT &amp;&amp; type != OBSOLETE) {
03187         print_error(<span class="stringliteral">"STATUS should be current or obsolete"</span>, token, type);
03188         <span class="keywordflow">goto</span> skip;
03189     }
03190     type = get_token(fp, token, MAXTOKEN);
03191     <span class="keywordflow">if</span> (type != DESCRIPTION) {
03192         print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
03193         <span class="keywordflow">goto</span> skip;
03194     }
03195     type = get_token(fp, token, MAXTOKEN);
03196     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03197         print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, token, type);
03198         <span class="keywordflow">goto</span> skip;
03199     }
03200     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
03201                                NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
03202         np-&gt;description = strdup(token);
03203     }
03204     type = get_token(fp, token, MAXTOKEN);
03205     <span class="keywordflow">if</span> (type == REFERENCE) {
03206         type = get_token(fp, token, MAXTOKEN);
03207         <span class="keywordflow">if</span> (type != QUOTESTRING) {
03208             print_error(<span class="stringliteral">"Bad REFERENCE"</span>, token, type);
03209             <span class="keywordflow">goto</span> skip;
03210         }
03211         np-&gt;reference = strdup(token);
03212         type = get_token(fp, token, type);
03213     }
03214     <span class="keywordflow">while</span> (type == SUPPORTS) {
03215         <span class="keywordtype">int</span>             modid;
03216         <span class="keyword">struct </span>tree    *tp;
03217 
03218         type = get_token(fp, token, MAXTOKEN);
03219         <span class="keywordflow">if</span> (type != LABEL) {
03220             print_error(<span class="stringliteral">"Bad module name"</span>, token, type);
03221             <span class="keywordflow">goto</span> skip;
03222         }
03223         modid = read_module_internal(token);
03224         <span class="keywordflow">if</span> (modid != MODULE_LOADED_OK &amp;&amp; modid != MODULE_ALREADY_LOADED) {
03225             print_error(<span class="stringliteral">"Module not found"</span>, token, type);
03226             <span class="keywordflow">goto</span> skip;
03227         }
03228         modid = which_module(token);
03229         type = get_token(fp, token, MAXTOKEN);
03230         <span class="keywordflow">if</span> (type != INCLUDES) {
03231             print_error(<span class="stringliteral">"Expected INCLUDES"</span>, token, type);
03232             <span class="keywordflow">goto</span> skip;
03233         }
03234         type = get_token(fp, token, MAXTOKEN);
03235         <span class="keywordflow">if</span> (type != LEFTBRACKET) {
03236             print_error(<span class="stringliteral">"Expected \"{\""</span>, token, type);
03237             <span class="keywordflow">goto</span> skip;
03238         }
03239         <span class="keywordflow">do</span> {
03240             type = get_token(fp, token, MAXTOKEN);
03241             <span class="keywordflow">if</span> (type != LABEL) {
03242                 print_error(<span class="stringliteral">"Expected group name"</span>, token, type);
03243                 <span class="keywordflow">goto</span> skip;
03244             }
03245             tp = find_tree_node(token, modid);
03246             <span class="keywordflow">if</span> (!tp)
03247                 print_error(<span class="stringliteral">"Group not found in module"</span>, token, type);
03248             type = get_token(fp, token, MAXTOKEN);
03249         } <span class="keywordflow">while</span> (type == COMMA);
03250         <span class="keywordflow">if</span> (type != RIGHTBRACKET) {
03251             print_error(<span class="stringliteral">"Expected \"}\" after group list"</span>, token, type);
03252             <span class="keywordflow">goto</span> skip;
03253         }
03254         type = get_token(fp, token, MAXTOKEN);
03255         <span class="keywordflow">while</span> (type == VARIATION) {
03256             type = get_token(fp, token, MAXTOKEN);
03257             <span class="keywordflow">if</span> (type != LABEL) {
03258                 print_error(<span class="stringliteral">"Bad object name"</span>, token, type);
03259                 <span class="keywordflow">goto</span> skip;
03260             }
03261             tp = find_tree_node(token, modid);
03262             <span class="keywordflow">if</span> (!tp)
03263                 print_error(<span class="stringliteral">"Object not found in module"</span>, token, type);
03264             type = get_token(fp, token, MAXTOKEN);
03265             <span class="keywordflow">if</span> (type == SYNTAX) {
03266                 type = eat_syntax(fp, token, MAXTOKEN);
03267             }
03268             <span class="keywordflow">if</span> (type == WRSYNTAX) {
03269                 type = eat_syntax(fp, token, MAXTOKEN);
03270             }
03271             <span class="keywordflow">if</span> (type == ACCESS) {
03272                 type = get_token(fp, token, MAXTOKEN);
03273                 <span class="keywordflow">if</span> (type != ACCNOTIFY &amp;&amp; type != READONLY
03274                     &amp;&amp; type != READWRITE &amp;&amp; type != READCREATE
03275                     &amp;&amp; type != WRITEONLY &amp;&amp; type != NOTIMPL) {
03276                     print_error(<span class="stringliteral">"Bad ACCESS"</span>, token, type);
03277                     <span class="keywordflow">goto</span> skip;
03278                 }
03279                 type = get_token(fp, token, MAXTOKEN);
03280             }
03281             <span class="keywordflow">if</span> (type == CREATEREQ) {
03282                 type = get_token(fp, token, MAXTOKEN);
03283                 <span class="keywordflow">if</span> (type != LEFTBRACKET) {
03284                     print_error(<span class="stringliteral">"Expected \"{\""</span>, token, type);
03285                     <span class="keywordflow">goto</span> skip;
03286                 }
03287                 <span class="keywordflow">do</span> {
03288                     type = get_token(fp, token, MAXTOKEN);
03289                     <span class="keywordflow">if</span> (type != LABEL) {
03290                         print_error(<span class="stringliteral">"Bad object name in list"</span>, token,
03291                                     type);
03292                         <span class="keywordflow">goto</span> skip;
03293                     }
03294                     type = get_token(fp, token, MAXTOKEN);
03295                 } <span class="keywordflow">while</span> (type == COMMA);
03296                 <span class="keywordflow">if</span> (type != RIGHTBRACKET) {
03297                     print_error(<span class="stringliteral">"Expected \"}\" after list"</span>, token, type);
03298                     <span class="keywordflow">goto</span> skip;
03299                 }
03300                 type = get_token(fp, token, MAXTOKEN);
03301             }
03302             <span class="keywordflow">if</span> (type == DEFVAL) {
03303                 <span class="keywordtype">int</span>             level = 1;
03304                 type = get_token(fp, token, MAXTOKEN);
03305                 <span class="keywordflow">if</span> (type != LEFTBRACKET) {
03306                     print_error(<span class="stringliteral">"Expected \"{\" after DEFVAL"</span>, token,
03307                                 type);
03308                     <span class="keywordflow">goto</span> skip;
03309                 }
03310                 <span class="keywordflow">do</span> {
03311                     type = get_token(fp, token, MAXTOKEN);
03312                     <span class="keywordflow">if</span> (type == LEFTBRACKET)
03313                         level++;
03314                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == RIGHTBRACKET)
03315                         level--;
03316                 } <span class="keywordflow">while</span> (type != RIGHTBRACKET &amp;&amp; type != ENDOFFILE
03317                          &amp;&amp; level != 0);
03318                 <span class="keywordflow">if</span> (type != RIGHTBRACKET) {
03319                     print_error(<span class="stringliteral">"Missing \"}\" after DEFVAL"</span>, token, type);
03320                     <span class="keywordflow">goto</span> skip;
03321                 }
03322                 type = get_token(fp, token, MAXTOKEN);
03323             }
03324             <span class="keywordflow">if</span> (type != DESCRIPTION) {
03325                 print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
03326                 <span class="keywordflow">goto</span> skip;
03327             }
03328             type = get_token(fp, token, MAXTOKEN);
03329             <span class="keywordflow">if</span> (type != QUOTESTRING) {
03330                 print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, token, type);
03331                 <span class="keywordflow">goto</span> skip;
03332             }
03333             type = get_token(fp, token, MAXTOKEN);
03334         }
03335     }
03336     <span class="keywordflow">if</span> (type != EQUALS)
03337         print_error(<span class="stringliteral">"Expected \"::=\""</span>, token, type);
03338   skip:
03339     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE) {
03340         type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03341     }
03342     <span class="keywordflow">return</span> merge_parse_objectid(np, fp, name);
03343 }
03344 
03345 <span class="comment">/*</span>
03346 <span class="comment"> * Parses a module identity macro</span>
03347 <span class="comment"> * Returns 0 on error.</span>
03348 <span class="comment"> */</span>
03349 <span class="keyword">static</span> <span class="keywordtype">void</span>
03350 check_utc(<span class="keyword">const</span> <span class="keywordtype">char</span> *utc)
03351 {
03352     <span class="keywordtype">int</span>             len, year, month, day, hour, minute;
03353 
03354     len = strlen(utc);
03355     <span class="keywordflow">if</span> (utc[len - 1] != <span class=
"charliteral">'Z'</span> &amp;&amp; utc[len - 1] != <span class="charliteral">'z'</span>) {
03356         print_error(<span class="stringliteral">"Timestamp should end with Z"</span>, utc, QUOTESTRING);
03357         <span class="keywordflow">return</span>;
03358     }
03359     <span class="keywordflow">if</span> (len == 11) {
03360         len =
03361             sscanf(utc, <span class="stringliteral">"%2d%2d%2d%2d%2dZ"</span>, &amp;year, &amp;month, &amp;day, &amp;hour,
03362                    &amp;minute);
03363         year += 1900;
03364     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (len == 13)
03365         len =
03366             sscanf(utc, <span class="stringliteral">"%4d%2d%2d%2d%2dZ"</span>, &amp;year, &amp;month, &amp;day, &amp;hour,
03367                    &amp;minute);
03368     <span class="keywordflow">else</span> {
03369         print_error(<span class="stringliteral">"Bad timestamp format (11 or 13 characters)"</span>,
03370                     utc, QUOTESTRING);
03371         <span class="keywordflow">return</span>;
03372     }
03373     <span class="keywordflow">if</span> (len != 5) {
03374         print_error(<span class="stringliteral">"Bad timestamp format"</span>, utc, QUOTESTRING);
03375         <span class="keywordflow">return</span>;
03376     }
03377     <span class="keywordflow">if</span> (month &lt; 1 || month &gt; 12)
03378         print_error(<span class="stringliteral">"Bad month in timestamp"</span>, utc, QUOTESTRING);
03379     <span class="keywordflow">if</span> (day &lt; 1 || day &gt; 31)
03380         print_error(<span class="stringliteral">"Bad day in timestamp"</span>, utc, QUOTESTRING);
03381     <span class="keywordflow">if</span> (hour &lt; 0 || hour &gt; 23)
03382         print_error(<span class="stringliteral">"Bad hour in timestamp"</span>, utc, QUOTESTRING);
03383     <span class="keywordflow">if</span> (minute &lt; 0 || minute &gt; 59)
03384         print_error(<span class="stringliteral">"Bad minute in timestamp"</span>, utc, QUOTESTRING);
03385 }
03386 
03387 <span class="keyword">static</span> <span class="keyword">struct </span>node *
03388 parse_moduleIdentity(FILE * fp, <span class="keywordtype">char</span> *name)
03389 {
03390     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
03391     <span class="keywordtype">char</span>            token[MAXTOKEN];
03392     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
03393     <span class="keyword">register</span> <span class="keyword">struct </span>node *np;
03394 
03395     np = alloc_node(current_module);
03396     <span class="keywordflow">if</span> (np == NULL)
03397         <span class="keywordflow">return</span> (NULL);
03398     type = get_token(fp, token, MAXTOKEN);
03399     <span class="keywordflow">if</span> (type != LASTUPDATED) {
03400         print_error(<span class="stringliteral">"Expected LAST-UPDATED"</span>, token, type);
03401         <span class="keywordflow">goto</span> skip;
03402     }
03403     type = get_token(fp, token, MAXTOKEN);
03404     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03405         print_error(<span class="stringliteral">"Need STRING for LAST-UPDATED"</span>, token, type);
03406         <span class="keywordflow">goto</span> skip;
03407     }
03408     check_utc(token);
03409     type = get_token(fp, token, MAXTOKEN);
03410     <span class="keywordflow">if</span> (type != ORGANIZATION) {
03411         print_error(<span class="stringliteral">"Expected ORGANIZATION"</span>, token, type);
03412         <span class="keywordflow">goto</span> skip;
03413     }
03414     type = get_token(fp, token, MAXTOKEN);
03415     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03416         print_error(<span class="stringliteral">"Bad ORGANIZATION"</span>, token, type);
03417         <span class="keywordflow">goto</span> skip;
03418     }
03419     type = get_token(fp, token, MAXTOKEN);
03420     <span class="keywordflow">if</span> (type != CONTACTINFO) {
03421         print_error(<span class="stringliteral">"Expected CONTACT-INFO"</span>, token, type);
03422         <span class="keywordflow">goto</span> skip;
03423     }
03424     type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03425     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03426         print_error(<span class="stringliteral">"Bad CONTACT-INFO"</span>, quoted_string_buffer, type);
03427         <span class="keywordflow">goto</span> skip;
03428     }
03429     type = get_token(fp, token, MAXTOKEN);
03430     <span class="keywordflow">if</span> (type != DESCRIPTION) {
03431         print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
03432         <span class="keywordflow">goto</span> skip;
03433     }
03434     type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03435     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03436         print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
03437         <span class="keywordflow">goto</span> skip;
03438     }
03439     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
03440                                NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
03441         np-&gt;description = strdup(quoted_string_buffer);
03442     }
03443     type = get_token(fp, token, MAXTOKEN);
03444     <span class="keywordflow">while</span> (type == REVISION) {
03445         type = get_token(fp, token, MAXTOKEN);
03446         <span class="keywordflow">if</span> (type != QUOTESTRING) {
03447             print_error(<span class="stringliteral">"Bad REVISION"</span>, token, type);
03448             <span class="keywordflow">goto</span> skip;
03449         }
03450         check_utc(token);
03451         type = get_token(fp, token, MAXTOKEN);
03452         <span class="keywordflow">if</span> (type != DESCRIPTION) {
03453             print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
03454             <span class="keywordflow">goto</span> skip;
03455         }
03456         type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03457         <span class="keywordflow">if</span> (type != QUOTESTRING) {
03458             print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
03459             <span class="keywordflow">goto</span> skip;
03460         }
03461         type = get_token(fp, token, MAXTOKEN);
03462     }
03463     <span class="keywordflow">if</span> (type != EQUALS)
03464         print_error(<span class="stringliteral">"Expected \"::=\""</span>, token, type);
03465   skip:
03466     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE) {
03467         type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03468     }
03469     <span class="keywordflow">return</span> merge_parse_objectid(np, fp, name);
03470 }
03471 
03472 
03473 <span class="comment">/*</span>
03474 <span class="comment"> * Parses a MACRO definition</span>
03475 <span class="comment"> * Expect BEGIN, discard everything to end.</span>
03476 <span class="comment"> * Returns 0 on error.</span>
03477 <span class="comment"> */</span>
03478 <span class="keyword">static</span> <span class="keyword">struct </span>node *
03479 parse_macro(FILE * fp, <span class="keywordtype">char</span> *name)
03480 {
03481     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
03482     <span class="keywordtype">char</span>            token[MAXTOKEN];
03483     <span class="keyword">struct </span>node    *np;
03484     <span class="keywordtype">int</span>             iLine = mibLine;
03485 
03486     np = alloc_node(current_module);
03487     <span class="keywordflow">if</span> (np == NULL)
03488         <span class="keywordflow">return</span> (NULL);
03489     type = get_token(fp, token, <span class="keyword">sizeof</span>(token));
03490     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE) {
03491         type = get_token(fp, token, <span class="keyword">sizeof</span>(token));
03492     }
03493     <span class="keywordflow">if</span> (type != EQUALS)
03494         <span class="keywordflow">return</span> NULL;
03495     <span class="keywordflow">while</span> (type != BEGIN &amp;&amp; type != ENDOFFILE) {
03496         type = get_token(fp, token, <span class="keyword">sizeof</span>(token));
03497     }
03498     <span class="keywordflow">if</span> (type != BEGIN)
03499         <span class="keywordflow">return</span> NULL;
03500     <span class="keywordflow">while</span> (type != END &amp;&amp; type != ENDOFFILE) {
03501         type = get_token(fp, token, <span class="keyword">sizeof</span>(token));
03502     }
03503     <span class="keywordflow">if</span> (type != END)
03504         <span class="keywordflow">return</span> NULL;
03505 
03506     <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
03507                            NETSNMP_DS_LIB_MIB_WARNINGS)) {
03508         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
03509                  <span class="stringliteral">"%s MACRO (lines %d..%d parsed and ignored).\n"</span>, name,
03510                  iLine, mibLine);
03511     }
03512 
03513     <span class="keywordflow">return</span> np;
03514 }
03515 
03516 <span class="comment">/*</span>
03517 <span class="comment"> * Parses a module import clause</span>
03518 <span class="comment"> *   loading any modules referenced</span>
03519 <span class="comment"> */</span>
03520 <span class="keyword">static</span> <span class="keywordtype">void</span>
03521 parse_imports(FILE * fp)
03522 {
03523     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
03524     <span class="keywordtype">char</span>            token[MAXTOKEN];
03525     <span class="keywordtype">char</span>            modbuf[256];
03526 <span class="preprocessor">#define MAX_IMPORTS     256</span>
03527     <span class="keyword">struct </span>module_import import_list[MAX_IMPORTS];
03528     <span class="keywordtype">int</span>             this_module;
03529     <span class="keyword">struct </span>module  *mp;
03530 
03531     <span class="keywordtype">int</span>             import_count = 0;   <span class=
"comment">/* Total number of imported descriptors */</span>
03532     <span class="keywordtype">int</span>             i = 0, old_i;       <span class=
"comment">/* index of first import from each module */</span>
03533 
03534     type = get_token(fp, token, MAXTOKEN);
03535 
03536     <span class="comment">/*</span>
03537 <span class="comment">     * Parse the IMPORTS clause</span>
03538 <span class="comment">     */</span>
03539     <span class="keywordflow">while</span> (type != SEMI &amp;&amp; type != ENDOFFILE) {
03540         <span class="keywordflow">if</span> (type == LABEL) {
03541             <span class="keywordflow">if</span> (import_count == MAX_IMPORTS) {
03542                 print_error(<span class="stringliteral">"Too many imported symbols"</span>, token, type);
03543                 <span class="keywordflow">do</span> {
03544                     type = get_token(fp, token, MAXTOKEN);
03545                 } <span class="keywordflow">while</span> (type != SEMI &amp;&amp; type != ENDOFFILE);
03546                 <span class="keywordflow">return</span>;
03547             }
03548             import_list[import_count++].label = strdup(token);
03549         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == FROM) {
03550             type = get_token(fp, token, MAXTOKEN);
03551             <span class="keywordflow">if</span> (import_count == i) {    <span class=
"comment">/* All imports are handled internally */</span>
03552                 type = get_token(fp, token, MAXTOKEN);
03553                 <span class="keywordflow">continue</span>;
03554             }
03555             this_module = which_module(token);
03556 
03557             <span class="keywordflow">for</span> (old_i = i; i &lt; import_count; ++i)
03558                 import_list[i].modid = this_module;
03559 
03560             <span class="comment">/*</span>
03561 <span class="comment">             * Recursively read any pre-requisite modules</span>
03562 <span class="comment">             */</span>
03563             <span class="keywordflow">if</span> (read_module_internal(token) == MODULE_NOT_FOUND) {
03564                 <span class="keywordtype">int</span> found = 0;
03565                 <span class="keywordflow">for</span> (; old_i &lt; import_count; ++old_i) {
03566                     found += read_import_replacements(token, &amp;import_list[old_i]);
03567                 }
03568                 <span class="keywordflow">if</span> (!found)
03569                     print_module_not_found(token);
03570             }
03571         }
03572         type = get_token(fp, token, MAXTOKEN);
03573     }
03574 
03575     <span class="comment">/*</span>
03576 <span class="comment">     * Save the import information</span>
03577 <span class="comment">     *   in the global module table</span>
03578 <span class="comment">     */</span>
03579     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
03580         <span class="keywordflow">if</span> (mp-&gt;modid == current_module) {
03581             <span class="keywordflow">if</span> (import_count == 0)
03582                 <span class="keywordflow">return</span>;
03583             <span class="keywordflow">if</span> (mp-&gt;imports &amp;&amp; (mp-&gt;imports != root_imports)) {
03584                 <span class="comment">/*</span>
03585 <span class="comment">                 * this can happen if all modules are in one source file. </span>
03586 <span class="comment">                 */</span>
03587                 <span class="keywordflow">for</span> (i = 0; i &lt; mp-&gt;no_imports; ++i) {
03588                     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>,
03589                                 <span class="stringliteral">"#### freeing Module %d '%s' %d\n"</span>,
03590                                 mp-&gt;modid, mp-&gt;imports[i].label,
03591                                 mp-&gt;imports[i].modid));
03592                     free((<span class="keywordtype">char</span> *) mp-&gt;imports[i].label);
03593                 }
03594                 free((<span class="keywordtype">char</span> *) mp-&gt;imports);
03595             }
03596             mp-&gt;imports = (<span class="keyword">struct </span>module_import *)
03597                 calloc(import_count, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> module_import));
03598             <span class="keywordflow">if</span> (mp-&gt;imports == NULL)
03599                 <span class="keywordflow">return</span>;
03600             <span class="keywordflow">for</span> (i = 0; i &lt; import_count; ++i) {
03601                 mp-&gt;imports[i].label = import_list[i].label;
03602                 mp-&gt;imports[i].modid = import_list[i].modid;
03603                 DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>,
03604                             <span class="stringliteral">"#### adding Module %d '%s' %d\n"</span>, mp-&gt;modid,
03605                             mp-&gt;imports[i].label, mp-&gt;imports[i].modid));
03606             }
03607             mp-&gt;no_imports = import_count;
03608             <span class="keywordflow">return</span>;
03609         }
03610 
03611     <span class="comment">/*</span>
03612 <span class="comment">     * Shouldn't get this far</span>
03613 <span class="comment">     */</span>
03614     print_module_not_found(module_name(current_module, modbuf));
03615     <span class="keywordflow">return</span>;
03616 }
03617 
03618 
03619 
03620 <span class="comment">/*</span>
03621 <span class="comment"> * MIB module handling routines</span>
03622 <span class="comment"> */</span>
03623 
03624 <span class="keyword">static</span> <span class="keywordtype">void</span>
03625 dump_module_list(<span class="keywordtype">void</span>)
03626 {
03627     <span class="keyword">struct </span>module  *mp = module_head;
03628 
03629     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class="stringliteral">"Module list:\n"</span>));
03630     <span class="keywordflow">while</span> (mp) {
03631         DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"  %s %d %s %d\n"</span>, mp-&gt;name, mp-&gt;modid,
03632                     mp-&gt;file, mp-&gt;no_imports));
03633         mp = mp-&gt;next;
03634     }
03635 }
03636 
03637 <span class="keywordtype">int</span>
03638 which_module(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
03639 {
03640     <span class="keyword">struct </span>module  *mp;
03641 
03642     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
03643         <span class="keywordflow">if</span> (!label_compare(mp-&gt;name, name))
03644             <span class="keywordflow">return</span> (mp-&gt;modid);
03645 
03646     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Module %s not found\n"</span>, name));
03647     <span class="keywordflow">return</span> (-1);
03648 }
03649 
03650 <span class="comment">/*</span>
03651 <span class="comment"> * module_name - copy module name to user buffer, return ptr to same.</span>
03652 <span class="comment"> */</span>
03653 <span class="keywordtype">char</span>           *
03654 module_name(<span class="keywordtype">int</span> modid, <span class="keywordtype">char</span> *cp)
03655 {
03656     <span class="keyword">struct </span>module  *mp;
03657 
03658     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
03659         <span class="keywordflow">if</span> (mp-&gt;modid == modid) {
03660             strcpy(cp, mp-&gt;name);
03661             <span class="keywordflow">return</span> (cp);
03662         }
03663 
03664     <span class="keywordflow">if</span> (modid != -1) DEBUGMSGTL((<span class=
"stringliteral">"parse-mibs"</span>, <span class="stringliteral">"Module %d not found\n"</span>, modid));
03665     sprintf(cp, <span class="stringliteral">"#%d"</span>, modid);
03666     <span class="keywordflow">return</span> (cp);
03667 }
03668 
03669 <span class="comment">/*</span>
03670 <span class="comment"> *  Backwards compatability</span>
03671 <span class="comment"> *  Read newer modules that replace the one specified:-</span>
03672 <span class="comment"> *      either all of them (read_module_replacements),</span>
03673 <span class="comment"> *      or those relating to a specified identifier (read_import_replacements)</span>
03674 <span class="comment"> *      plus an interface to add new replacement requirements</span>
03675 <span class="comment"> */</span>
03676 <span class="keywordtype">void</span>
03677 add_module_replacement(<span class="keyword">const</span> <span class="keywordtype">char</span> *old_module,
03678                        <span class="keyword">const</span> <span class="keywordtype">char</span> *new_module_name,
03679                        <span class="keyword">const</span> <span class="keywordtype">char</span> *tag, <span class=
"keywordtype">int</span> len)
03680 {
03681     <span class="keyword">struct </span>module_compatability *mcp;
03682 
03683     mcp = (<span class="keyword">struct </span>module_compatability *)
03684         calloc(1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> module_compatability));
03685     <span class="keywordflow">if</span> (mcp == NULL)
03686         <span class="keywordflow">return</span>;
03687 
03688     mcp-&gt;old_module = strdup(old_module);
03689     mcp-&gt;new_module = strdup(new_module_name);
03690     <span class="keywordflow">if</span> (tag)
03691         mcp-&gt;tag = strdup(tag);
03692     mcp-&gt;tag_len = len;
03693 
03694     mcp-&gt;next = module_map_head;
03695     module_map_head = mcp;
03696 }
03697 
03698 <span class="keyword">static</span> <span class="keywordtype">int</span>
03699 read_module_replacements(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
03700 {
03701     <span class="keyword">struct </span>module_compatability *mcp;
03702 
03703     <span class="keywordflow">for</span> (mcp = module_map_head; mcp; mcp = mcp-&gt;next) {
03704         <span class="keywordflow">if</span> (!label_compare(mcp-&gt;old_module, name)) {
03705             <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
03706                                    NETSNMP_DS_LIB_MIB_WARNINGS)) {
03707                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
03708                          <span class="stringliteral">"Loading replacement module %s for %s (%s)\n"</span>,
03709                          mcp-&gt;new_module, name, File);
03710             }
03711             (void) netsnmp_read_module(mcp-&gt;new_module);
03712             <span class="keywordflow">return</span> 1;
03713         }
03714     }
03715     <span class="keywordflow">return</span> 0;
03716 }
03717 
03718 <span class="keyword">static</span> <span class="keywordtype">int</span>
03719 read_import_replacements(<span class="keyword">const</span> <span class="keywordtype">char</span> *old_module_name,
03720                          <span class="keyword">struct</span> module_import *identifier)
03721 {
03722     <span class="keyword">struct </span>module_compatability *mcp;
03723 
03724     <span class="comment">/*</span>
03725 <span class="comment">     * Look for matches first</span>
03726 <span class="comment">     */</span>
03727     <span class="keywordflow">for</span> (mcp = module_map_head; mcp; mcp = mcp-&gt;next) {
03728         <span class="keywordflow">if</span> (!label_compare(mcp-&gt;old_module, old_module_name)) {
03729 
03730             <span class="keywordflow">if</span> (                <span class="comment">/* exact match */</span>
03731                    (mcp-&gt;tag_len == 0 &amp;&amp;
03732                     (mcp-&gt;tag == NULL ||
03733                      !label_compare(mcp-&gt;tag, identifier-&gt;label))) ||
03734                    <span class="comment">/*</span>
03735 <span class="comment">                    * prefix match </span>
03736 <span class="comment">                    */</span>
03737                    (mcp-&gt;tag_len != 0 &amp;&amp;
03738                     !strncmp(mcp-&gt;tag, identifier-&gt;label, mcp-&gt;tag_len))
03739                 ) {
03740 
03741                 <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
03742                                        NETSNMP_DS_LIB_MIB_WARNINGS)) {
03743                     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
03744                              <span class=
"stringliteral">"Importing %s from replacement module %s instead of %s (%s)\n"</span>,
03745                              identifier-&gt;label, mcp-&gt;new_module,
03746                              old_module_name, File);
03747                 }
03748                 (void) netsnmp_read_module(mcp-&gt;new_module);
03749                 identifier-&gt;modid = which_module(mcp-&gt;new_module);
03750                 <span class="keywordflow">return</span> 1;         <span class="comment">/* finished! */</span>
03751             }
03752         }
03753     }
03754 
03755     <span class="comment">/*</span>
03756 <span class="comment">     * If no exact match, load everything relevant</span>
03757 <span class="comment">     */</span>
03758     <span class="keywordflow">return</span> read_module_replacements(old_module_name);
03759 }
03760 
03761 
03762 <span class="comment">/*</span>
03763 <span class="comment"> *  Read in the named module</span>
03764 <span class="comment"> *      Returns the root of the whole tree</span>
03765 <span class="comment"> *      (by analogy with 'read_mib')</span>
03766 <span class="comment"> */</span>
03767 <span class="keyword">static</span> <span class="keywordtype">int</span>
03768 read_module_internal(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
03769 {
03770     <span class="keyword">struct </span>module  *mp;
03771     FILE           *fp;
03772     <span class="keyword">struct </span>node    *np;
03773 
03774     init_mib_internals();
03775 
03776     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
03777         <span class="keywordflow">if</span> (!label_compare(mp-&gt;name, name)) {
03778             <span class="keyword">const</span> <span class="keywordtype">char</span>     *oldFile = File;
03779             <span class="keywordtype">int</span>             oldLine = mibLine;
03780             <span class="keywordtype">int</span>             oldModule = current_module;
03781 
03782             <span class="keywordflow">if</span> (mp-&gt;no_imports != -1) {
03783                 DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Module %s already loaded\n"</span>,
03784                             name));
03785                 <span class="keywordflow">return</span> MODULE_ALREADY_LOADED;
03786             }
03787             <span class="keywordflow">if</span> ((fp = fopen(mp-&gt;file, <span class=
"stringliteral">"r"</span>)) == NULL) {
03788                 snmp_log_perror(mp-&gt;file);
03789                 <span class="keywordflow">return</span> MODULE_LOAD_FAILED;
03790             }
03791             mp-&gt;no_imports = 0; <span class="comment">/* Note that we've read the file */</span>
03792             File = mp-&gt;file;
03793             mibLine = 1;
03794             current_module = mp-&gt;modid;
03795             <span class="comment">/*</span>
03796 <span class="comment">             * Parse the file</span>
03797 <span class="comment">             */</span>
03798             np = parse(fp, NULL);
03799             fclose(fp);
03800             File = oldFile;
03801             mibLine = oldLine;
03802             current_module = oldModule;
03803             <span class="keywordflow">return</span> MODULE_LOADED_OK;
03804         }
03805 
03806     <span class="keywordflow">return</span> MODULE_NOT_FOUND;
03807 }
03808 
03809 <span class="keywordtype">void</span>
03810 adopt_orphans(<span class="keywordtype">void</span>)
03811 {
03812     <span class="keyword">struct </span>node    *np, *onp;
03813     <span class="keyword">struct </span>tree    *tp;
03814     <span class="keywordtype">int</span>             i, adopted = 1;
03815 
03816     <span class="keywordflow">if</span> (!orphan_nodes)
03817         <span class="keywordflow">return</span>;
03818     init_node_hash(orphan_nodes);
03819     orphan_nodes = NULL;
03820 
03821     <span class="keywordflow">while</span> (adopted) {
03822         adopted = 0;
03823         <span class="keywordflow">for</span> (i = 0; i &lt; NHASHSIZE; i++)
03824             <span class="keywordflow">if</span> (nbuckets[i]) {
03825                 <span class="keywordflow">for</span> (np = nbuckets[i]; np != NULL; np = np-&gt;next) {
03826                     tp = find_tree_node(np-&gt;parent, -1);
03827                     <span class="keywordflow">if</span> (tp) {
03828                         do_subtree(tp, &amp;np);
03829                         adopted = 1;
03830                         <span class="comment">/*</span>
03831 <span class="comment">                         * if do_subtree adopted the entire bucket, stop</span>
03832 <span class="comment">                         */</span>
03833                         <span class="keywordflow">if</span>(NULL == nbuckets[i])
03834                             <span class="keywordflow">break</span>;
03835 
03836                         <span class="comment">/*</span>
03837 <span class="comment">                         * do_subtree may modify nbuckets, and if np</span>
03838 <span class="comment">                         * was adopted, np-&gt;next probably isn't an orphan</span>
03839 <span class="comment">                         * anymore. if np is still in the bucket (do_subtree</span>
03840 <span class="comment">                         * didn't adopt it) keep on plugging. otherwise</span>
03841 <span class="comment">                         * start over, at the top of the bucket.</span>
03842 <span class="comment">                         */</span>
03843                         <span class="keywordflow">for</span>(onp = nbuckets[i]; onp; onp = onp-&gt;next)
03844                             <span class="keywordflow">if</span>(onp == np)
03845                                 <span class="keywordflow">break</span>;
03846                         <span class="keywordflow">if</span>(NULL == onp) { <span class=
"comment">/* not in the list */</span>
03847                             np = nbuckets[i]; <span class="comment">/* start over */</span>
03848                         }
03849                     }
03850                 }
03851             }
03852     }
03853 
03854     <span class="comment">/*</span>
03855 <span class="comment">     * Report on outstanding orphans</span>
03856 <span class="comment">     *    and link them back into the orphan list</span>
03857 <span class="comment">     */</span>
03858     <span class="keywordflow">for</span> (i = 0; i &lt; NHASHSIZE; i++)
03859         <span class="keywordflow">if</span> (nbuckets[i]) {
03860             <span class="keywordflow">if</span> (orphan_nodes)
03861                 onp = np-&gt;next = nbuckets[i];
03862             <span class="keywordflow">else</span>
03863                 onp = orphan_nodes = nbuckets[i];
03864             nbuckets[i] = NULL;
03865             <span class="keywordflow">while</span> (onp) {
03866                 <span class="keywordtype">char</span>            modbuf[256];
03867                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
03868                          <span class="stringliteral">"Cannot adopt OID in %s: %s ::= { %s %ld }\n"</span>,
03869                          module_name(onp-&gt;modid, modbuf),
03870                          (onp-&gt;label ? onp-&gt;label : <span class="stringliteral">"&lt;no label&gt;"</span>),
03871                          (onp-&gt;parent ? onp-&gt;parent : <span class="stringliteral">"&lt;no parent&gt;"</span>),
03872                          onp-&gt;subid);
03873 
03874                 np = onp;
03875                 onp = onp-&gt;next;
03876             }
03877         }
03878 }
03879 
03880 <span class="preprocessor">#ifndef NETSNMP_CLEAN_NAMESPACE</span>
03881 <span class="keyword">struct </span>tree    *
03882 read_module(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
03883 {
03884     <span class="keywordflow">return</span> netsnmp_read_module(name);
03885 }
03886 <span class="preprocessor">#endif</span>
03887 
03888 <span class="keyword">struct </span>tree    *
03889 netsnmp_read_module(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
03890 {
03891     <span class="keywordflow">if</span> (read_module_internal(name) == MODULE_NOT_FOUND)
03892         <span class="keywordflow">if</span> (!read_module_replacements(name))
03893             print_module_not_found(name);
03894     <span class="keywordflow">return</span> tree_head;
03895 }
03896 
03897 <span class="comment">/*</span>
03898 <span class="comment"> * Prototype definition </span>
03899 <span class="comment"> */</span>
03900 <span class="keywordtype">void</span>            unload_module_by_ID(<span class=
"keywordtype">int</span> modID, <span class="keyword">struct</span> tree *tree_top);
03901 
03902 <span class="keywordtype">void</span>
03903 unload_module_by_ID(<span class="keywordtype">int</span> modID, <span class="keyword">struct</span> tree *tree_top)
03904 {
03905     <span class="keyword">struct </span>tree    *tp, *next;
03906     <span class="keywordtype">int</span>             i;
03907 
03908     <span class="keywordflow">for</span> (tp = tree_top; tp; tp = next) {
03909         <span class="comment">/*</span>
03910 <span class="comment">         * Essentially, this is equivalent to the code fragment:</span>
03911 <span class="comment">         *      if (tp-&gt;modID == modID)</span>
03912 <span class="comment">         *        tp-&gt;number_modules--;</span>
03913 <span class="comment">         * but handles one tree node being part of several modules,</span>
03914 <span class="comment">         * and possible multiple copies of the same module ID.</span>
03915 <span class="comment">         */</span>
03916         <span class="keywordtype">int</span>             nmod = tp-&gt;number_modules;
03917         <span class="keywordflow">if</span> (nmod &gt; 0) {         <span class="comment">/* in some module */</span>
03918             <span class="comment">/*</span>
03919 <span class="comment">             * Remove all copies of this module ID</span>
03920 <span class="comment">             */</span>
03921             <span class="keywordtype">int</span>             cnt = 0, *pi1, *pi2 = tp-&gt;module_list;
03922             <span class="keywordflow">for</span> (i = 0, pi1 = pi2; i &lt; nmod; i++, pi2++) {
03923                 <span class="keywordflow">if</span> (*pi2 == modID)
03924                     <span class="keywordflow">continue</span>;
03925                 cnt++;
03926                 *pi1++ = *pi2;
03927             }
03928             <span class="keywordflow">if</span> (nmod != cnt) {  <span class="comment">/* in this module */</span>
03929                 <span class="comment">/*</span>
03930 <span class="comment">                 * if ( (nmod - cnt) &gt; 1)</span>
03931 <span class=
"comment">                 * printf("Dup modid %d,  %d times, '%s'\n", tp-&gt;modid, (nmod-cnt), tp-&gt;label); fflush(stdout); ?* XXDEBUG </span>
03932 <span class="comment">                 */</span>
03933                 tp-&gt;number_modules = cnt;
03934                 <span class="keywordflow">switch</span> (cnt) {
03935                 <span class="keywordflow">case</span> 0:
03936                     tp-&gt;module_list[0] = -1;    <span class="comment">/* Mark unused, and FALL THROUGH */</span>
03937 
03938                 <span class="keywordflow">case</span> 1:        <span class=
"comment">/* save the remaining module */</span>
03939                     <span class="keywordflow">if</span> (&amp;(tp-&gt;modid) != tp-&gt;module_list) {
03940                         tp-&gt;modid = tp-&gt;module_list[0];
03941                         free(tp-&gt;module_list);
03942                         tp-&gt;module_list = &amp;(tp-&gt;modid);
03943                     }
03944                     <span class="keywordflow">break</span>;
03945 
03946                 <span class="keywordflow">default</span>:
03947                     <span class="keywordflow">break</span>;
03948                 }
03949             }                   <span class="comment">/* if tree node is in this module */</span>
03950         }
03951         <span class="comment">/*</span>
03952 <span class="comment">         * if tree node is in some module </span>
03953 <span class="comment">         */</span>
03954         next = tp-&gt;next_peer;
03955 
03956 
03957         <span class="comment">/*</span>
03958 <span class="comment">         *  OK - that's dealt with *this* node.</span>
03959 <span class="comment">         *    Now let's look at the children.</span>
03960 <span class="comment">         *    (Isn't recursion wonderful!)</span>
03961 <span class="comment">         */</span>
03962         <span class="keywordflow">if</span> (tp-&gt;child_list)
03963             unload_module_by_ID(modID, tp-&gt;child_list);
03964 
03965 
03966         <span class="keywordflow">if</span> (tp-&gt;number_modules == 0) {
03967             <span class="comment">/*</span>
03968 <span class="comment">             * This node isn't needed any more (except perhaps</span>
03969 <span class="comment">             * for the sake of the children) </span>
03970 <span class="comment">             */</span>
03971             <span class="keywordflow">if</span> (tp-&gt;child_list == NULL) {
03972                 unlink_tree(tp);
03973                 free_tree(tp);
03974             } <span class="keywordflow">else</span> {
03975                 free_partial_tree(tp, TRUE);
03976             }
03977         }
03978     }
03979 }
03980 
03981 <span class="preprocessor">#ifndef NETSNMP_CLEAN_NAMESPACE</span>
03982 <span class="keywordtype">int</span>
03983 unload_module(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
03984 {
03985     <span class="keywordflow">return</span> netsnmp_unload_module(name);
03986 }
03987 <span class="preprocessor">#endif</span>
03988 
03989 <span class="keywordtype">int</span>
03990 netsnmp_unload_module(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
03991 {
03992     <span class="keyword">struct </span>module  *mp;
03993     <span class="keywordtype">int</span>             modID = -1;
03994 
03995     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
03996         <span class="keywordflow">if</span> (!label_compare(mp-&gt;name, name)) {
03997             modID = mp-&gt;modid;
03998             <span class="keywordflow">break</span>;
03999         }
04000 
04001     <span class="keywordflow">if</span> (modID == -1) {
04002         DEBUGMSGTL((<span class="stringliteral">"unload-mib"</span>, <span class=
"stringliteral">"Module %s not found to unload\n"</span>,
04003                     name));
04004         <span class="keywordflow">return</span> MODULE_NOT_FOUND;
04005     }
04006     unload_module_by_ID(modID, tree_head);
04007     mp-&gt;no_imports = -1;        <span class="comment">/* mark as unloaded */</span>
04008     <span class="keywordflow">return</span> MODULE_LOADED_OK;    <span class=
"comment">/* Well, you know what I mean! */</span>
04009 }
04010 
04011 <span class="comment">/*</span>
04012 <span class="comment"> * Clear module map, tree nodes, textual convention table.</span>
04013 <span class="comment"> */</span>
04014 <span class="keywordtype">void</span>
04015 unload_all_mibs()
04016 {
04017     <span class="keyword">struct </span>module  *mp;
04018     <span class="keyword">struct </span>module_compatability *mcp;
04019     <span class="keyword">struct </span>tc      *ptc;
04020     <span class="keywordtype">int</span>             i;
04021 
04022     <span class="keywordflow">for</span> (mcp = module_map_head; mcp; mcp = module_map_head) {
04023         <span class="keywordflow">if</span> (mcp == module_map)
04024             <span class="keywordflow">break</span>;
04025         module_map_head = mcp-&gt;next;
04026         <span class="keywordflow">if</span> (mcp-&gt;tag) free((<span class="keywordtype">char</span> *) mcp-&gt;tag);
04027         free((<span class="keywordtype">char</span> *) mcp-&gt;old_module);
04028         free((<span class="keywordtype">char</span> *) mcp-&gt;new_module);
04029         free(mcp);
04030     }
04031 
04032     <span class="keywordflow">for</span> (mp = module_head; mp; mp = module_head) {
04033         <span class="keyword">struct </span>module_import *mi = mp-&gt;imports;
04034         <span class="keywordflow">if</span> (mi) {
04035             <span class="keywordflow">for</span> (i = 0; i &lt; mp-&gt;no_imports; ++i) {
04036                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>((mi + i)-&gt;label);
04037             }
04038             mp-&gt;no_imports = 0;
04039             <span class="keywordflow">if</span> (mi == root_imports)
04040                 memset(mi, 0, <span class="keyword">sizeof</span>(*mi));
04041             <span class="keywordflow">else</span>
04042                 free(mi);
04043         }
04044 
04045         unload_module_by_ID(mp-&gt;modid, tree_head);
04046         module_head = mp-&gt;next;
04047         free(mp-&gt;name);
04048         free(mp-&gt;file);
04049         free(mp);
04050     }
04051     unload_module_by_ID(-1, tree_head);
04052     <span class="comment">/*</span>
04053 <span class="comment">     * tree nodes are cleared </span>
04054 <span class="comment">     */</span>
04055 
04056     <span class="keywordflow">for</span> (i = 0, ptc = tclist; i &lt; MAXTC; i++, ptc++) {
04057         <span class="keywordflow">if</span> (ptc-&gt;type == 0)
04058             <span class="keywordflow">continue</span>;
04059         free_enums(&amp;ptc-&gt;enums);
04060         free_ranges(&amp;ptc-&gt;ranges);
04061         free(ptc-&gt;descriptor);
04062         <span class="keywordflow">if</span> (ptc-&gt;hint)
04063             free(ptc-&gt;hint);
04064     }
04065     memset(tclist, 0, MAXTC * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tc));
04066 
04067     memset(buckets, 0, <span class="keyword">sizeof</span>(buckets));
04068     memset(nbuckets, 0, <span class="keyword">sizeof</span>(nbuckets));
04069     memset(tbuckets, 0, <span class="keyword">sizeof</span>(tbuckets));
04070 
04071     <span class="keywordflow">for</span> (i = 0; i &lt; <span class="keyword">sizeof</span>(root_imports) / <span class=
"keyword">sizeof</span>(root_imports[0]); i++) {
04072         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(root_imports[i].label);
04073     }
04074 
04075     max_module = 0;
04076     current_module = 0;
04077     module_map_head = NULL;
04078     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(last_err_module);
04079 }
04080 
04081 <span class="keyword">static</span> <span class="keywordtype">void</span>
04082 new_module(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *file)
04083 {
04084     <span class="keyword">struct </span>module  *mp;
04085 
04086     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
04087         <span class="keywordflow">if</span> (!label_compare(mp-&gt;name, name)) {
04088             DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"  Module %s already noted\n"</span>, name));
04089             <span class="comment">/*</span>
04090 <span class="comment">             * Not the same file </span>
04091 <span class="comment">             */</span>
04092             <span class="keywordflow">if</span> (label_compare(mp-&gt;file, file)) {
04093                 DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"    %s is now in %s\n"</span>,
04094                             name, file));
04095                 <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
04096                                        NETSNMP_DS_LIB_MIB_WARNINGS)) {
04097                     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,
04098                              <span class="stringliteral">"Warning: Module %s was in %s now is %s\n"</span>,
04099                              name, mp-&gt;file, file);
04100                 }
04101 
04102                 <span class="comment">/*</span>
04103 <span class="comment">                 * Use the new one in preference </span>
04104 <span class="comment">                 */</span>
04105                 free(mp-&gt;file);
04106                 mp-&gt;file = strdup(file);
04107             }
04108             <span class="keywordflow">return</span>;
04109         }
04110 
04111     <span class="comment">/*</span>
04112 <span class="comment">     * Add this module to the list </span>
04113 <span class="comment">     */</span>
04114     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"  Module %d %s is in %s\n"</span>, max_module,
04115                 name, file));
04116     mp = (<span class="keyword">struct </span>module *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> module));
04117     <span class="keywordflow">if</span> (mp == NULL)
04118         <span class="keywordflow">return</span>;
04119     mp-&gt;name = strdup(name);
04120     mp-&gt;file = strdup(file);
04121     mp-&gt;imports = NULL;
04122     mp-&gt;no_imports = -1;        <span class="comment">/* Not yet loaded */</span>
04123     mp-&gt;modid = max_module;
04124     ++max_module;
04125 
04126     mp-&gt;next = module_head;     <span class="comment">/* Or add to the *end* of the list? */</span>
04127     module_head = mp;
04128 }
04129 
04130 
04131 <span class="keyword">static</span> <span class="keywordtype">void</span>
04132 scan_objlist(<span class="keyword">struct</span> node *root, <span class=
"keyword">struct</span> objgroup *list, <span class="keyword">const</span> <span class="keywordtype">char</span> *error)
04133 {
04134     <span class="keywordtype">int</span>             oLine = mibLine;
04135 
04136     <span class="keywordflow">while</span> (list) {
04137         <span class="keyword">struct </span>objgroup *gp = list;
04138         <span class="keyword">struct </span>node    *np;
04139         list = list-&gt;next;
04140         np = root;
04141         <span class="keywordflow">while</span> (np)
04142             <span class="keywordflow">if</span> (label_compare(np-&gt;label, gp-&gt;name))
04143                 np = np-&gt;next;
04144             <span class="keywordflow">else</span>
04145                 <span class="keywordflow">break</span>;
04146         <span class="keywordflow">if</span> (!np) {
04147             mibLine = gp-&gt;line;
04148             print_error(error, gp-&gt;name, QUOTESTRING);
04149         }
04150         free(gp-&gt;name);
04151         free(gp);
04152     }
04153     mibLine = oLine;
04154 }
04155 
04156 <span class="comment">/*</span>
04157 <span class="comment"> * Parses a mib file and returns a linked list of nodes found in the file.</span>
04158 <span class="comment"> * Returns NULL on error.</span>
04159 <span class="comment"> */</span>
04160 <span class="keyword">static</span> <span class="keyword">struct </span>node *
04161 parse(FILE * fp, <span class="keyword">struct</span> node *root)
04162 {
04163     <span class="keywordtype">char</span>            token[MAXTOKEN];
04164     <span class="keywordtype">char</span>            name[MAXTOKEN];
04165     <span class="keywordtype">int</span>             type = LABEL;
04166     <span class="keywordtype">int</span>             lasttype = LABEL;
04167 
04168 <span class="preprocessor">#define BETWEEN_MIBS          1</span>
04169 <span class="preprocessor">#define IN_MIB                2</span>
04170     <span class="keywordtype">int</span>             state = BETWEEN_MIBS;
04171     <span class="keyword">struct </span>node    *np, *nnp;
04172     <span class="keyword">struct </span>objgroup *oldgroups = NULL, *oldobjects = NULL, *oldnotifs =
04173         NULL;
04174 
04175     DEBUGMSGTL((<span class="stringliteral">"parse-file"</span>, <span class=
"stringliteral">"Parsing file:  %s...\n"</span>, File));
04176 
04177     <span class="keywordflow">if</span> (last_err_module)
04178         free(last_err_module);
04179     last_err_module = 0;
04180 
04181     np = root;
04182     <span class="keywordflow">if</span> (np != NULL) {
04183         <span class="comment">/*</span>
04184 <span class="comment">         * now find end of chain </span>
04185 <span class="comment">         */</span>
04186         <span class="keywordflow">while</span> (np-&gt;next)
04187             np = np-&gt;next;
04188     }
04189 
04190     <span class="keywordflow">while</span> (type != ENDOFFILE) {
04191         <span class="keywordflow">if</span> (lasttype == CONTINUE)
04192             lasttype = type;
04193         <span class="keywordflow">else</span>
04194             type = lasttype = get_token(fp, token, MAXTOKEN);
04195 
04196         <span class="keywordflow">switch</span> (type) {
04197         <span class="keywordflow">case</span> END:
04198             <span class="keywordflow">if</span> (state != IN_MIB) {
04199                 print_error(<span class="stringliteral">"Error, END before start of MIB"</span>, NULL, type);
04200                 <span class="keywordflow">return</span> NULL;
04201             } <span class="keywordflow">else</span> {
04202                 <span class="keyword">struct </span>module  *mp;
04203 <span class="preprocessor">#ifdef TEST</span>
04204                 printf(<span class="stringliteral">"\nNodes for Module %s:\n"</span>, name);
04205                 print_nodes(stdout, root);
04206 <span class="preprocessor">#endif</span>
04207                 scan_objlist(root, objgroups, <span class="stringliteral">"Undefined OBJECT-GROUP"</span>);
04208                 scan_objlist(root, objects, <span class="stringliteral">"Undefined OBJECT"</span>);
04209                 scan_objlist(root, notifs, <span class="stringliteral">"Undefined NOTIFICATION"</span>);
04210                 objgroups = oldgroups;
04211                 objects = oldobjects;
04212                 notifs = oldnotifs;
04213                 <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
04214                     <span class="keywordflow">if</span> (mp-&gt;modid == current_module)
04215                         <span class="keywordflow">break</span>;
04216                 do_linkup(mp, root);
04217                 np = root = NULL;
04218             }
04219             state = BETWEEN_MIBS;
04220 <span class="preprocessor">#ifdef TEST</span>
04221             <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
04222                                    NETSNMP_DS_LIB_MIB_WARNINGS)) {
04223                 xmalloc_stats(stderr);
04224             }
04225 <span class="preprocessor">#endif</span>
04226             <span class="keywordflow">continue</span>;
04227         <span class="keywordflow">case</span> IMPORTS:
04228             parse_imports(fp);
04229             <span class="keywordflow">continue</span>;
04230         <span class="keywordflow">case</span> EXPORTS:
04231             <span class="keywordflow">while</span> (type != SEMI &amp;&amp; type != ENDOFFILE)
04232                 type = get_token(fp, token, MAXTOKEN);
04233             <span class="keywordflow">continue</span>;
04234         <span class="keywordflow">case</span> LABEL:
04235         <span class="keywordflow">case</span> INTEGER:
04236         <span class="keywordflow">case</span> INTEGER32:
04237         <span class="keywordflow">case</span> UINTEGER32:
04238         <span class="keywordflow">case</span> UNSIGNED32:
04239         <span class="keywordflow">case</span> COUNTER:
04240         <span class="keywordflow">case</span> COUNTER64:
04241         <span class="keywordflow">case</span> GAUGE:
04242         <span class="keywordflow">case</span> IPADDR:
04243         <span class="keywordflow">case</span> NETADDR:
04244         <span class="keywordflow">case</span> NSAPADDRESS:
04245         <span class="keywordflow">case</span> OBJSYNTAX:
04246         <span class="keywordflow">case</span> APPSYNTAX:
04247         <span class="keywordflow">case</span> SIMPLESYNTAX:
04248         <span class="keywordflow">case</span> OBJNAME:
04249         <span class="keywordflow">case</span> NOTIFNAME:
04250         <span class="keywordflow">case</span> KW_OPAQUE:
04251         <span class="keywordflow">case</span> TIMETICKS:
04252             <span class="keywordflow">break</span>;
04253         <span class="keywordflow">case</span> ENDOFFILE:
04254             <span class="keywordflow">continue</span>;
04255         <span class="keywordflow">default</span>:
04256             strcpy(name, token);
04257             type = get_token(fp, token, MAXTOKEN);
04258             nnp = NULL;
04259             <span class="keywordflow">if</span> (type == MACRO) {
04260                 nnp = parse_macro(fp, name);
04261                 <span class="keywordflow">if</span> (nnp == NULL) {
04262                     print_error(<span class="stringliteral">"Bad parse of MACRO"</span>, NULL, type);
04263                     <span class="comment">/*</span>
04264 <span class="comment">                     * return NULL;</span>
04265 <span class="comment">                     */</span>
04266                 }
04267                 free_node(nnp); <span class="comment">/* IGNORE */</span>
04268                 nnp = NULL;
04269             } <span class="keywordflow">else</span>
04270                 print_error(name, <span class="stringliteral">"is a reserved word"</span>, lasttype);
04271             <span class="keywordflow">continue</span>;           <span class=
"comment">/* see if we can parse the rest of the file */</span>
04272         }
04273         strcpy(name, token);
04274         type = get_token(fp, token, MAXTOKEN);
04275         nnp = NULL;
04276 
04277         <span class="comment">/*</span>
04278 <span class="comment">         * Handle obsolete method to assign an object identifier to a</span>
04279 <span class="comment">         * module</span>
04280 <span class="comment">         */</span>
04281         <span class="keywordflow">if</span> (lasttype == LABEL &amp;&amp; type == LEFTBRACKET) {
04282             <span class="keywordflow">while</span> (type != RIGHTBRACKET &amp;&amp; type != ENDOFFILE)
04283                 type = get_token(fp, token, MAXTOKEN);
04284             <span class="keywordflow">if</span> (type == ENDOFFILE) {
04285                 print_error(<span class="stringliteral">"Expected \"}\""</span>, token, type);
04286                 <span class="keywordflow">return</span> NULL;
04287             }
04288             type = get_token(fp, token, MAXTOKEN);
04289         }
04290 
04291         <span class="keywordflow">switch</span> (type) {
04292         <span class="keywordflow">case</span> DEFINITIONS:
04293             <span class="keywordflow">if</span> (state != BETWEEN_MIBS) {
04294                 print_error(<span class="stringliteral">"Error, nested MIBS"</span>, NULL, type);
04295                 <span class="keywordflow">return</span> NULL;
04296             }
04297             state = IN_MIB;
04298             current_module = which_module(name);
04299             oldgroups = objgroups;
04300             objgroups = NULL;
04301             oldobjects = objects;
04302             objects = NULL;
04303             oldnotifs = notifs;
04304             notifs = NULL;
04305             <span class="keywordflow">if</span> (current_module == -1) {
04306                 new_module(name, File);
04307                 current_module = which_module(name);
04308             }
04309             DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Parsing MIB: %d %s\n"</span>,
04310                         current_module, name));
04311             <span class="keywordflow">while</span> ((type = get_token(fp, token, MAXTOKEN)) != ENDOFFILE)
04312                 <span class="keywordflow">if</span> (type == BEGIN)
04313                     <span class="keywordflow">break</span>;
04314             <span class="keywordflow">break</span>;
04315         <span class="keywordflow">case</span> OBJTYPE:
04316             nnp = parse_objecttype(fp, name);
04317             <span class="keywordflow">if</span> (nnp == NULL) {
04318                 print_error(<span class="stringliteral">"Bad parse of OBJECT-TYPE"</span>, NULL, type);
04319                 <span class="keywordflow">return</span> NULL;
04320             }
04321             <span class="keywordflow">break</span>;
04322         <span class="keywordflow">case</span> OBJGROUP:
04323             nnp = parse_objectgroup(fp, name, OBJECTS, &amp;objects);
04324             <span class="keywordflow">if</span> (nnp == NULL) {
04325                 print_error(<span class="stringliteral">"Bad parse of OBJECT-GROUP"</span>, NULL, type);
04326                 <span class="keywordflow">return</span> NULL;
04327             }
04328             <span class="keywordflow">break</span>;
04329         <span class="keywordflow">case</span> NOTIFGROUP:
04330             nnp = parse_objectgroup(fp, name, NOTIFICATIONS, &amp;notifs);
04331             <span class="keywordflow">if</span> (nnp == NULL) {
04332                 print_error(<span class="stringliteral">"Bad parse of NOTIFICATION-GROUP"</span>, NULL, type);
04333                 <span class="keywordflow">return</span> NULL;
04334             }
04335             <span class="keywordflow">break</span>;
04336         <span class="keywordflow">case</span> TRAPTYPE:
04337             nnp = parse_trapDefinition(fp, name);
04338             <span class="keywordflow">if</span> (nnp == NULL) {
04339                 print_error(<span class="stringliteral">"Bad parse of TRAP-TYPE"</span>, NULL, type);
04340                 <span class="keywordflow">return</span> NULL;
04341             }
04342             <span class="keywordflow">break</span>;
04343         <span class="keywordflow">case</span> NOTIFTYPE:
04344             nnp = parse_notificationDefinition(fp, name);
04345             <span class="keywordflow">if</span> (nnp == NULL) {
04346                 print_error(<span class="stringliteral">"Bad parse of NOTIFICATION-TYPE"</span>, NULL, type);
04347                 <span class="keywordflow">return</span> NULL;
04348             }
04349             <span class="keywordflow">break</span>;
04350         <span class="keywordflow">case</span> COMPLIANCE:
04351             nnp = parse_compliance(fp, name);
04352             <span class="keywordflow">if</span> (nnp == NULL) {
04353                 print_error(<span class="stringliteral">"Bad parse of MODULE-COMPLIANCE"</span>, NULL, type);
04354                 <span class="keywordflow">return</span> NULL;
04355             }
04356             <span class="keywordflow">break</span>;
04357         <span class="keywordflow">case</span> AGENTCAP:
04358             nnp = parse_capabilities(fp, name);
04359             <span class="keywordflow">if</span> (nnp == NULL) {
04360                 print_error(<span class="stringliteral">"Bad parse of AGENT-CAPABILITIES"</span>, NULL, type);
04361                 <span class="keywordflow">return</span> NULL;
04362             }
04363             <span class="keywordflow">break</span>;
04364         <span class="keywordflow">case</span> MACRO:
04365             nnp = parse_macro(fp, name);
04366             <span class="keywordflow">if</span> (nnp == NULL) {
04367                 print_error(<span class="stringliteral">"Bad parse of MACRO"</span>, NULL, type);
04368                 <span class="comment">/*</span>
04369 <span class="comment">                 * return NULL;</span>
04370 <span class="comment">                 */</span>
04371             }
04372             free_node(nnp);     <span class="comment">/* IGNORE */</span>
04373             nnp = NULL;
04374             <span class="keywordflow">break</span>;
04375         <span class="keywordflow">case</span> MODULEIDENTITY:
04376             nnp = parse_moduleIdentity(fp, name);
04377             <span class="keywordflow">if</span> (nnp == NULL) {
04378                 print_error(<span class="stringliteral">"Bad parse of MODULE-IDENTITY"</span>, NULL, type);
04379                 <span class="keywordflow">return</span> NULL;
04380             }
04381             <span class="keywordflow">break</span>;
04382         <span class="keywordflow">case</span> OBJECT:
04383             type = get_token(fp, token, MAXTOKEN);
04384             <span class="keywordflow">if</span> (type != IDENTIFIER) {
04385                 print_error(<span class="stringliteral">"Expected IDENTIFIER"</span>, token, type);
04386                 <span class="keywordflow">return</span> NULL;
04387             }
04388             type = get_token(fp, token, MAXTOKEN);
04389             <span class="keywordflow">if</span> (type != EQUALS) {
04390                 print_error(<span class="stringliteral">"Expected \"::=\""</span>, token, type);
04391                 <span class="keywordflow">return</span> NULL;
04392             }
04393             nnp = parse_objectid(fp, name);
04394             <span class="keywordflow">if</span> (nnp == NULL) {
04395                 print_error(<span class="stringliteral">"Bad parse of OBJECT IDENTIFIER"</span>, NULL, type);
04396                 <span class="keywordflow">return</span> NULL;
04397             }
04398             <span class="keywordflow">break</span>;
04399         <span class="keywordflow">case</span> EQUALS:
04400             nnp = parse_asntype(fp, name, &amp;type, token);
04401             lasttype = CONTINUE;
04402             <span class="keywordflow">break</span>;
04403         <span class="keywordflow">case</span> ENDOFFILE:
04404             <span class="keywordflow">break</span>;
04405         <span class="keywordflow">default</span>:
04406             print_error(<span class="stringliteral">"Bad operator"</span>, token, type);
04407             <span class="keywordflow">return</span> NULL;
04408         }
04409         <span class="keywordflow">if</span> (nnp) {
04410             <span class="keywordflow">if</span> (nnp-&gt;type == TYPE_OTHER)
04411                 nnp-&gt;type = type;
04412             <span class="keywordflow">if</span> (np)
04413                 np-&gt;next = nnp;
04414             <span class="keywordflow">else</span>
04415                 np = root = nnp;
04416             <span class="keywordflow">while</span> (np-&gt;next)
04417                 np = np-&gt;next;
04418         }
04419     }
04420     DEBUGMSGTL((<span class="stringliteral">"parse-file"</span>, <span class=
"stringliteral">"End of file (%s)\n"</span>, File));
04421     <span class="keywordflow">return</span> root;
04422 }
04423 
04424 <span class="comment">/*</span>
04425 <span class="comment"> * return zero if character is not a label character. </span>
04426 <span class="comment"> */</span>
04427 <span class="keyword">static</span> <span class="keywordtype">int</span>
04428 is_labelchar(<span class="keywordtype">int</span> ich)
04429 {
04430     <span class="keywordflow">if</span> ((isalnum(ich)) || (ich == <span class="charliteral">'-'</span>))
04431         <span class="keywordflow">return</span> 1;
04432     <span class="keywordflow">if</span> (ich == <span class=
"charliteral">'_'</span> &amp;&amp; netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
04433                                              NETSNMP_DS_LIB_MIB_PARSE_LABEL)) {
04434         <span class="keywordflow">return</span> 1;
04435     }
04436 
04437     <span class="keywordflow">return</span> 0;
04438 }
04439 
04440 <span class="comment">/*</span>
04441 <span class="comment"> * Parses a token from the file.  The type of the token parsed is returned,</span>
04442 <span class="comment"> * and the text is placed in the string pointed to by token.</span>
04443 <span class="comment"> * Warning: this method may recurse.</span>
04444 <span class="comment"> */</span>
04445 <span class="keyword">static</span> <span class="keywordtype">int</span>
04446 get_token(FILE * fp, <span class="keywordtype">char</span> *token, <span class="keywordtype">int</span> maxtlen)
04447 {
04448     <span class="keyword">register</span> <span class="keywordtype">int</span>    ch, ch_next;
04449     <span class="keyword">register</span> <span class="keywordtype">char</span>  *cp = token;
04450     <span class="keyword">register</span> <span class="keywordtype">int</span>    hash = 0;
04451     <span class="keyword">register</span> <span class="keyword">struct </span>tok *tp;
04452     <span class="keywordtype">int</span>             too_long = 0;
04453 
04454     <span class="comment">/*</span>
04455 <span class="comment">     * skip all white space </span>
04456 <span class="comment">     */</span>
04457     <span class="keywordflow">do</span> {
04458         ch = getc(fp);
04459         <span class="keywordflow">if</span> (ch == <span class="charliteral">'\n'</span>)
04460             mibLine++;
04461     }
04462     <span class="keywordflow">while</span> (isspace(ch) &amp;&amp; ch != EOF);
04463     *cp++ = ch;
04464     *cp = <span class="charliteral">'\0'</span>;
04465     <span class="keywordflow">switch</span> (ch) {
04466     <span class="keywordflow">case</span> EOF:
04467         <span class="keywordflow">return</span> ENDOFFILE;
04468     <span class="keywordflow">case</span> <span class="charliteral">'"'</span>:
04469         <span class="keywordflow">return</span> parseQuoteString(fp, token, maxtlen);
04470     <span class="keywordflow">case</span> <span class="charliteral">'\''</span>:                 <span class=
"comment">/* binary or hex constant */</span>
04471         <span class="keywordflow">while</span> ((ch = getc(fp)) != EOF &amp;&amp; ch != <span class=
"charliteral">'\''</span>
04472                &amp;&amp; cp - token &lt; maxtlen - 2)
04473             *cp++ = ch;
04474         <span class="keywordflow">if</span> (ch == <span class="charliteral">'\''</span>) {
04475             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   val = 0;
04476             *cp++ = <span class="charliteral">'\''</span>;
04477             *cp++ = ch = getc(fp);
04478             *cp = 0;
04479             cp = token + 1;
04480             <span class="keywordflow">switch</span> (ch) {
04481             <span class="keywordflow">case</span> EOF:
04482                 <span class="keywordflow">return</span> ENDOFFILE;
04483             <span class="keywordflow">case</span> <span class="charliteral">'b'</span>:
04484             <span class="keywordflow">case</span> <span class="charliteral">'B'</span>:
04485                 <span class="keywordflow">while</span> ((ch = *cp++) != <span class="charliteral">'\''</span>)
04486                     <span class="keywordflow">if</span> (ch != <span class=
"charliteral">'0'</span> &amp;&amp; ch != <span class="charliteral">'1'</span>)
04487                         <span class="keywordflow">return</span> LABEL;
04488                     <span class="keywordflow">else</span>
04489                         val = val * 2 + ch - <span class="charliteral">'0'</span>;
04490                 <span class="keywordflow">break</span>;
04491             <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
04492             <span class="keywordflow">case</span> <span class="charliteral">'H'</span>:
04493                 <span class="keywordflow">while</span> ((ch = *cp++) != <span class="charliteral">'\''</span>)
04494                     <span class="keywordflow">if</span> (<span class=
"charliteral">'0'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'9'</span>)
04495                         val = val * 16 + ch - <span class="charliteral">'0'</span>;
04496                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class=
"charliteral">'a'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'f'</span>)
04497                         val = val * 16 + ch - <span class="charliteral">'a'</span> + 10;
04498                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class=
"charliteral">'A'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'F'</span>)
04499                         val = val * 16 + ch - <span class="charliteral">'A'</span> + 10;
04500                     <span class="keywordflow">else</span>
04501                         <span class="keywordflow">return</span> LABEL;
04502                 <span class="keywordflow">break</span>;
04503             <span class="keywordflow">default</span>:
04504                 <span class="keywordflow">return</span> LABEL;
04505             }
04506             sprintf(token, <span class="stringliteral">"%ld"</span>, val);
04507             <span class="keywordflow">return</span> NUMBER;
04508         } <span class="keywordflow">else</span>
04509             <span class="keywordflow">return</span> LABEL;
04510     <span class="keywordflow">case</span> <span class="charliteral">'('</span>:
04511         <span class="keywordflow">return</span> LEFTPAREN;
04512     <span class="keywordflow">case</span> <span class="charliteral">')'</span>:
04513         <span class="keywordflow">return</span> RIGHTPAREN;
04514     <span class="keywordflow">case</span> <span class="charliteral">'{'</span>:
04515         <span class="keywordflow">return</span> LEFTBRACKET;
04516     <span class="keywordflow">case</span> <span class="charliteral">'}'</span>:
04517         <span class="keywordflow">return</span> RIGHTBRACKET;
04518     <span class="keywordflow">case</span> <span class="charliteral">'['</span>:
04519         <span class="keywordflow">return</span> LEFTSQBRACK;
04520     <span class="keywordflow">case</span> <span class="charliteral">']'</span>:
04521         <span class="keywordflow">return</span> RIGHTSQBRACK;
04522     <span class="keywordflow">case</span> <span class="charliteral">';'</span>:
04523         <span class="keywordflow">return</span> SEMI;
04524     <span class="keywordflow">case</span> <span class="charliteral">','</span>:
04525         <span class="keywordflow">return</span> COMMA;
04526     <span class="keywordflow">case</span> <span class="charliteral">'|'</span>:
04527         <span class="keywordflow">return</span> BAR;
04528     <span class="keywordflow">case</span> <span class="charliteral">'.'</span>:
04529         ch_next = getc(fp);
04530         <span class="keywordflow">if</span> (ch_next == <span class="charliteral">'.'</span>)
04531             <span class="keywordflow">return</span> RANGE;
04532         ungetc(ch_next, fp);
04533         <span class="keywordflow">return</span> LABEL;
04534     <span class="keywordflow">case</span> <span class="charliteral">':'</span>:
04535         ch_next = getc(fp);
04536         <span class="keywordflow">if</span> (ch_next != <span class="charliteral">':'</span>) {
04537             ungetc(ch_next, fp);
04538             <span class="keywordflow">return</span> LABEL;
04539         }
04540         ch_next = getc(fp);
04541         <span class="keywordflow">if</span> (ch_next != <span class="charliteral">'='</span>) {
04542             ungetc(ch_next, fp);
04543             <span class="keywordflow">return</span> LABEL;
04544         }
04545         <span class="keywordflow">return</span> EQUALS;
04546     <span class="keywordflow">case</span> <span class="charliteral">'-'</span>:
04547         ch_next = getc(fp);
04548         <span class="keywordflow">if</span> (ch_next == <span class="charliteral">'-'</span>) {
04549             <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
04550                                        NETSNMP_DS_LIB_MIB_COMMENT_TERM)) {
04551                 <span class="comment">/*</span>
04552 <span class="comment">                 * Treat the rest of this line as a comment. </span>
04553 <span class="comment">                 */</span>
04554                 <span class="keywordflow">while</span> ((ch_next != EOF) &amp;&amp; (ch_next != <span class=
"charliteral">'\n'</span>))
04555                     ch_next = getc(fp);
04556             } <span class="keywordflow">else</span> {
04557                 <span class="comment">/*</span>
04558 <span class="comment">                 * Treat the rest of the line or until another '--' as a comment </span>
04559 <span class="comment">                 */</span>
04560                 <span class="comment">/*</span>
04561 <span class="comment">                 * (this is the "technically" correct way to parse comments) </span>
04562 <span class="comment">                 */</span>
04563                 ch = <span class="charliteral">' '</span>;
04564                 ch_next = getc(fp);
04565                 <span class="keywordflow">while</span> (ch_next != EOF &amp;&amp; ch_next != <span class=
"charliteral">'\n'</span> &amp;&amp;
04566                        (ch != <span class="charliteral">'-'</span> || ch_next != <span class="charliteral">'-'</span>)) {
04567                     ch = ch_next;
04568                     ch_next = getc(fp);
04569                 }
04570             }
04571             <span class="keywordflow">if</span> (ch_next == EOF)
04572                 <span class="keywordflow">return</span> ENDOFFILE;
04573             <span class="keywordflow">if</span> (ch_next == <span class="charliteral">'\n'</span>)
04574                 mibLine++;
04575             <span class="keywordflow">return</span> get_token(fp, token, maxtlen);
04576         }
04577         ungetc(ch_next, fp);
04578     <span class="keywordflow">default</span>:
04579         <span class="comment">/*</span>
04580 <span class="comment">         * Accumulate characters until end of token is found.  Then attempt to</span>
04581 <span class="comment">         * match this token as a reserved word.  If a match is found, return the</span>
04582 <span class="comment">         * type.  Else it is a label.</span>
04583 <span class="comment">         */</span>
04584         <span class="keywordflow">if</span> (!is_labelchar(ch))
04585             <span class="keywordflow">return</span> LABEL;
04586         hash += tolower(ch);
04587       more:
04588         <span class="keywordflow">while</span> (is_labelchar(ch_next = getc(fp))) {
04589             hash += tolower(ch_next);
04590             <span class="keywordflow">if</span> (cp - token &lt; maxtlen - 1)
04591                 *cp++ = ch_next;
04592             <span class="keywordflow">else</span>
04593                 too_long = 1;
04594         }
04595         ungetc(ch_next, fp);
04596         *cp = <span class="charliteral">'\0'</span>;
04597 
04598         <span class="keywordflow">if</span> (too_long)
04599             print_error(<span class="stringliteral">"Warning: token too long"</span>, token, CONTINUE);
04600         <span class="keywordflow">for</span> (tp = buckets[BUCKET(hash)]; tp; tp = tp-&gt;next) {
04601             <span class="keywordflow">if</span> ((tp-&gt;hash == hash) &amp;&amp; (!label_compare(tp-&gt;name, token)))
04602                 <span class="keywordflow">break</span>;
04603         }
04604         <span class="keywordflow">if</span> (tp) {
04605             <span class="keywordflow">if</span> (tp-&gt;token != CONTINUE)
04606                 <span class="keywordflow">return</span> (tp-&gt;token);
04607             <span class="keywordflow">while</span> (isspace((ch_next = getc(fp))))
04608                 <span class="keywordflow">if</span> (ch_next == <span class="charliteral">'\n'</span>)
04609                     mibLine++;
04610             <span class="keywordflow">if</span> (ch_next == EOF)
04611                 <span class="keywordflow">return</span> ENDOFFILE;
04612             <span class="keywordflow">if</span> (isalnum(ch_next)) {
04613                 *cp++ = ch_next;
04614                 hash += tolower(ch_next);
04615                 <span class="keywordflow">goto</span> more;
04616             }
04617         }
04618         <span class="keywordflow">if</span> (token[0] == <span class="charliteral">'-'</span> || isdigit(token[0])) {
04619             <span class="keywordflow">for</span> (cp = token + 1; *cp; cp++)
04620                 <span class="keywordflow">if</span> (!isdigit(*cp))
04621                     <span class="keywordflow">return</span> LABEL;
04622             <span class="keywordflow">return</span> NUMBER;
04623         }
04624         <span class="keywordflow">return</span> LABEL;
04625     }
04626 }
04627 
04628 <span class="keywordtype">int</span>
04629 snmp_get_token(FILE * fp, <span class="keywordtype">char</span> *token, <span class="keywordtype">int</span> maxtlen)
04630 {
04631     <span class="keywordflow">return</span> get_token(fp, token, maxtlen);
04632 }
04633 
04634 <span class="keywordtype">int</span>
04635 add_mibfile(<span class="keyword">const</span> <span class="keywordtype">char</span>* tmpstr, <span class=
"keyword">const</span> <span class="keywordtype">char</span>* d_name, FILE *ip )
04636 {
04637     FILE           *fp;
04638     <span class="keywordtype">char</span>            token[MAXTOKEN], token2[MAXTOKEN];
04639 
04640     <span class="comment">/*</span>
04641 <span class="comment">     * which module is this </span>
04642 <span class="comment">     */</span>
04643     <span class="keywordflow">if</span> ((fp = fopen(tmpstr, <span class="stringliteral">"r"</span>)) == NULL) {
04644         snmp_log_perror(tmpstr);
04645         <span class="keywordflow">return</span> 1;
04646     }
04647     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Checking file: %s...\n"</span>,
04648                 tmpstr));
04649     mibLine = 1;
04650     File = tmpstr;
04651     get_token(fp, token, MAXTOKEN);
04652     <span class="comment">/*</span>
04653 <span class="comment">     * simple test for this being a MIB </span>
04654 <span class="comment">     */</span>
04655     <span class="keywordflow">if</span> (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {
04656         new_module(token, tmpstr);
04657         <span class="keywordflow">if</span> (ip)
04658             fprintf(ip, <span class="stringliteral">"%s %s\n"</span>, token, d_name);
04659         fclose(fp);
04660         <span class="keywordflow">return</span> 0;
04661     } <span class="keywordflow">else</span> {
04662         fclose(fp);
04663         <span class="keywordflow">return</span> 1;
04664     }
04665 }
04666 
04667 <span class="comment">/* For Win32 platforms, the directory does not maintain a last modification</span>
04668 <span class="comment"> * date that we can compare with the modification date of the .index file.</span>
04669 <span class="comment"> * Therefore there is no way to know whether any .index file is valid.</span>
04670 <span class="comment"> * This is the reason for the #if !(defined(WIN32) || defined(cygwin))</span>
04671 <span class="comment"> * in the add_mibdir function</span>
04672 <span class="comment"> */</span>
04673 <span class="keywordtype">int</span>
04674 add_mibdir(<span class="keyword">const</span> <span class="keywordtype">char</span> *dirname)
04675 {
04676     FILE           *ip;
04677     DIR            *dir, *dir2;
04678     <span class="keyword">const</span> <span class="keywordtype">char</span>     *oldFile = File;
04679     <span class="keyword">struct </span>dirent  *file;
04680     <span class="keywordtype">char</span>            tmpstr[300];
04681     <span class="keywordtype">int</span>             count = 0;
04682     <span class="keywordtype">int</span>             fname_len = 0;
04683 <span class="preprocessor">#if !(defined(WIN32) || defined(cygwin))</span>
04684     <span class="keywordtype">char</span>            token[MAXTOKEN];
04685     <span class="keywordtype">char</span> space;
04686     <span class="keywordtype">char</span> newline;
04687     <span class="keyword">struct </span>stat     dir_stat, idx_stat;
04688     <span class="keywordtype">char</span>            tmpstr1[300];
04689 <span class="preprocessor">#endif</span>
04690 
04691     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Scanning directory %s\n"</span>, dirname));
04692 <span class="preprocessor">#if !(defined(WIN32) || defined(cygwin))</span>
04693     snprintf(token, <span class="keyword">sizeof</span>(token), <span class=
"stringliteral">"%s/%s"</span>, dirname, <span class="stringliteral">".index"</span>);
04694     token[ <span class="keyword">sizeof</span>(token)-1 ] = 0;
04695     <span class="keywordflow">if</span> (stat(token, &amp;idx_stat) == 0 &amp;&amp; stat(dirname, &amp;dir_stat) == 0) {
04696         <span class="keywordflow">if</span> (dir_stat.st_mtime &lt; idx_stat.st_mtime) {
04697             DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"The index is good\n"</span>));
04698             <span class="keywordflow">if</span> ((ip = fopen(token, <span class="stringliteral">"r"</span>)) != NULL) {
04699                 <span class="keywordflow">while</span> (fscanf(ip, <span class=
"stringliteral">"%127s%c%299s%c"</span>, token, &amp;space, tmpstr,
04700                     &amp;newline) == 4) {
04701 
04702                     <span class="comment">/*</span>
04703 <span class="comment">                     * If an overflow of the token or tmpstr buffers has been</span>
04704 <span class="comment">                     * found log a message and break out of the while loop,</span>
04705 <span class="comment">                     * thus the rest of the file tokens will be ignored.</span>
04706 <span class="comment">                     */</span>
04707                     <span class="keywordflow">if</span> (space != <span class=
"charliteral">' '</span> || newline != <span class="charliteral">'\n'</span>) {
04708                         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
04709                             <span class="stringliteral">"add_mibdir: strings scanned in from %s/%s "</span> \
04710                             <span class="stringliteral">"are too large.  count = %d\n "</span>, dirname,
04711                             <span class="stringliteral">".index"</span>, count);
04712                             <span class="keywordflow">break</span>;
04713                     }
04714                    
04715                     snprintf(tmpstr1, <span class="keyword">sizeof</span>(tmpstr1), <span class=
"stringliteral">"%s/%s"</span>, dirname, tmpstr);
04716                     tmpstr1[ <span class="keyword">sizeof</span>(tmpstr1)-1 ] = 0;
04717                     new_module(token, tmpstr1);
04718                     count++;
04719                 }
04720                 fclose(ip);
04721                 <span class="keywordflow">return</span> count;
04722             } <span class="keywordflow">else</span>
04723                 DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Can't read index\n"</span>));
04724         } <span class="keywordflow">else</span>
04725             DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Index outdated\n"</span>));
04726     } <span class="keywordflow">else</span>
04727         DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class="stringliteral">"No index\n"</span>));
04728 <span class="preprocessor">#endif</span>
04729 
04730     <span class="keywordflow">if</span> ((dir = opendir(dirname))) {
04731         snprintf(tmpstr, <span class="keyword">sizeof</span>(tmpstr), <span class=
"stringliteral">"%s/.index"</span>, dirname);
04732         tmpstr[ <span class="keyword">sizeof</span>(tmpstr)-1 ] = 0;
04733         ip = fopen(tmpstr, <span class="stringliteral">"w"</span>);
04734         <span class="keywordflow">while</span> ((file = readdir(dir))) {
04735             <span class="comment">/*</span>
04736 <span class="comment">             * Only parse file names that don't begin with a '.' </span>
04737 <span class="comment">             * Also skip files ending in '~', or starting/ending</span>
04738 <span class="comment">             * with '#' which are typically editor backup files.</span>
04739 <span class="comment">             */</span>
04740             <span class="keywordflow">if</span> (file-&gt;d_name != NULL) {
04741               fname_len = strlen( file-&gt;d_name );
04742               <span class="keywordflow">if</span> (fname_len &gt; 0 &amp;&amp; file-&gt;d_name[0] != <span class=
"charliteral">'.'</span> 
04743                                 &amp;&amp; file-&gt;d_name[0] != <span class="charliteral">'#'</span>
04744                                 &amp;&amp; file-&gt;d_name[fname_len-1] != <span class="charliteral">'#'</span>
04745                                 &amp;&amp; file-&gt;d_name[fname_len-1] != <span class="charliteral">'~'</span>) {
04746                 snprintf(tmpstr, <span class="keyword">sizeof</span>(tmpstr), <span class=
"stringliteral">"%s/%s"</span>, dirname, file-&gt;d_name);
04747                 tmpstr[ <span class="keyword">sizeof</span>(tmpstr)-1 ] = 0;
04748                 <span class="keywordflow">if</span> ((dir2 = opendir(tmpstr))) {
04749                     <span class="comment">/*</span>
04750 <span class="comment">                     * file is a directory, don't read it </span>
04751 <span class="comment">                     */</span>
04752                     closedir(dir2);
04753                 } <span class="keywordflow">else</span> {
04754                     <span class="keywordflow">if</span> ( add_mibfile( tmpstr, file-&gt;d_name, ip ))
04755                         count++;
04756                 }
04757               }
04758             }
04759         }
04760         File = oldFile;
04761         closedir(dir);
04762         <span class="keywordflow">if</span> (ip)
04763             fclose(ip);
04764         <span class="keywordflow">return</span> (count);
04765     }
04766     <span class="keywordflow">else</span>
04767         DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>,<span class=
"stringliteral">"cannot open MIB directory %s\n"</span>, dirname));
04768 
04769     <span class="keywordflow">return</span> (-1);
04770 }
04771 
04772 
04773 <span class="comment">/*</span>
04774 <span class="comment"> * Returns the root of the whole tree</span>
04775 <span class="comment"> *   (for backwards compatability)</span>
04776 <span class="comment"> */</span>
04777 <span class="keyword">struct </span>tree    *
04778 read_mib(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename)
04779 {
04780     FILE           *fp;
04781     <span class="keywordtype">char</span>            token[MAXTOKEN];
04782 
04783     fp = fopen(filename, <span class="stringliteral">"r"</span>);
04784     <span class="keywordflow">if</span> (fp == NULL) {
04785         snmp_log_perror(filename);
04786         <span class="keywordflow">return</span> NULL;
04787     }
04788     mibLine = 1;
04789     File = filename;
04790     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Parsing file: %s...\n"</span>, filename));
04791     get_token(fp, token, MAXTOKEN);
04792     fclose(fp);
04793     new_module(token, filename);
04794     (void) netsnmp_read_module(token);
04795 
04796     <span class="keywordflow">return</span> tree_head;
04797 }
04798 
04799 
04800 <span class="keyword">struct </span>tree    *
04801 read_all_mibs()
04802 {
04803     <span class="keyword">struct </span>module  *mp;
04804 
04805     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
04806         <span class="keywordflow">if</span> (mp-&gt;no_imports == -1)
04807             netsnmp_read_module(mp-&gt;name);
04808     adopt_orphans();
04809 
04810     <span class="keywordflow">return</span> tree_head;
04811 }
04812 
04813 
04814 <span class="preprocessor">#ifdef TEST</span>
04815 main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
04816 {
04817     <span class="keywordtype">int</span>             i;
04818     <span class="keyword">struct </span>tree    *tp;
04819     netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_WARNINGS, 2);
04820 
04821     <a class="code" href="group__mib__utilities.html#ga57">init_mib</a>();
04822 
04823     <span class="keywordflow">if</span> (argc == 1)
04824         (void) read_all_mibs();
04825     <span class="keywordflow">else</span>
04826         <span class="keywordflow">for</span> (i = 1; i &lt; argc; i++)
04827             read_mib(argv[i]);
04828 
04829     <span class="keywordflow">for</span> (tp = tree_head; tp; tp = tp-&gt;next_peer)
04830         print_subtree(stdout, tp, 0);
04831     free_tree(tree_head);
04832 
04833     <span class="keywordflow">return</span> 0;
04834 }
04835 <span class="preprocessor">#endif                          </span><span class="comment">/* TEST */</span>
04836 
04837 <span class="keyword">static</span> <span class="keywordtype">int</span>
04838 parseQuoteString(FILE * fp, <span class="keywordtype">char</span> *token, <span class="keywordtype">int</span> maxtlen)
04839 {
04840     <span class="keyword">register</span> <span class="keywordtype">int</span>    ch;
04841     <span class="keywordtype">int</span>             count = 0;
04842     <span class="keywordtype">int</span>             too_long = 0;
04843     <span class="keywordtype">char</span>           *token_start = token;
04844 
04845     <span class="keywordflow">for</span> (ch = getc(fp); ch != EOF; ch = getc(fp)) {
04846         <span class="keywordflow">if</span> (ch == <span class="charliteral">'\r'</span>)
04847             <span class="keywordflow">continue</span>;
04848         <span class="keywordflow">if</span> (ch == <span class="charliteral">'\n'</span>) {
04849             mibLine++;
04850         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class=
"charliteral">'"'</span>) {
04851             *token = <span class="charliteral">'\0'</span>;
04852             <span class="keywordflow">if</span> (too_long &amp;&amp; netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
04853                                            NETSNMP_DS_LIB_MIB_WARNINGS) &gt; 1) {
04854                 <span class="comment">/*</span>
04855 <span class="comment">                 * show short form for brevity sake </span>
04856 <span class="comment">                 */</span>
04857                 <span class="keywordtype">char</span>            ch_save = *(token_start + 50);
04858                 *(token_start + 50) = <span class="charliteral">'\0'</span>;
04859                 print_error(<span class="stringliteral">"Warning: string too long"</span>,
04860                             token_start, QUOTESTRING);
04861                 *(token_start + 50) = ch_save;
04862             }
04863             <span class="keywordflow">return</span> QUOTESTRING;
04864         }
04865         <span class="comment">/*</span>
04866 <span class="comment">         * maximum description length check.  If greater, keep parsing</span>
04867 <span class="comment">         * but truncate the string </span>
04868 <span class="comment">         */</span>
04869         <span class="keywordflow">if</span> (++count &lt; maxtlen)
04870             *token++ = ch;
04871         <span class="keywordflow">else</span>
04872             too_long = 1;
04873     }
04874 
04875     <span class="keywordflow">return</span> 0;
04876 }
04877 
04878 <span class="comment">/*</span>
04879 <span class="comment"> * struct index_list *</span>
04880 <span class="comment"> * getIndexes(FILE *fp):</span>
04881 <span class="comment"> *   This routine parses a string like  { blah blah blah } and returns a</span>
04882 <span class="comment"> *   list of the strings enclosed within it.</span>
04883 <span class="comment"> *</span>
04884 <span class="comment"> */</span>
04885 <span class="keyword">static</span> <span class="keyword">struct </span>index_list *
04886 getIndexes(FILE * fp, <span class="keyword">struct</span> index_list **retp)
04887 {
04888     <span class="keywordtype">int</span>             type;
04889     <span class="keywordtype">char</span>            token[MAXTOKEN];
04890     <span class="keywordtype">char</span>            nextIsImplied = 0;
04891 
04892     <span class="keyword">struct </span>index_list *mylist = NULL;
04893     <span class="keyword">struct </span>index_list **mypp = &amp;mylist;
04894 
04895     free_indexes(retp);
04896 
04897     type = get_token(fp, token, MAXTOKEN);
04898 
04899     <span class="keywordflow">if</span> (type != LEFTBRACKET) {
04900         <span class="keywordflow">return</span> NULL;
04901     }
04902 
04903     type = get_token(fp, token, MAXTOKEN);
04904     <span class="keywordflow">while</span> (type != RIGHTBRACKET &amp;&amp; type != ENDOFFILE) {
04905         <span class="keywordflow">if</span> ((type == LABEL) || (type &amp; SYNTAX_MASK)) {
04906             *mypp =
04907                 (<span class="keyword">struct </span>index_list *) calloc(1, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> index_list));
04908             <span class="keywordflow">if</span> (*mypp) {
04909                 (*mypp)-&gt;ilabel = strdup(token);
04910                 (*mypp)-&gt;isimplied = nextIsImplied;
04911                 mypp = &amp;(*mypp)-&gt;next;
04912                 nextIsImplied = 0;
04913             }
04914         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == IMPLIED) {
04915             nextIsImplied = 1;
04916         }
04917         type = get_token(fp, token, MAXTOKEN);
04918     }
04919 
04920     *retp = mylist;
04921     <span class="keywordflow">return</span> mylist;
04922 }
04923 
04924 <span class="keyword">static</span> <span class="keyword">struct </span>varbind_list *
04925 getVarbinds(FILE * fp, <span class="keyword">struct</span> varbind_list **retp)
04926 {
04927     <span class="keywordtype">int</span>             type;
04928     <span class="keywordtype">char</span>            token[MAXTOKEN];
04929 
04930     <span class="keyword">struct </span>varbind_list *mylist = NULL;
04931     <span class="keyword">struct </span>varbind_list **mypp = &amp;mylist;
04932 
04933     free_varbinds(retp);
04934 
04935     type = get_token(fp, token, MAXTOKEN);
04936 
04937     <span class="keywordflow">if</span> (type != LEFTBRACKET) {
04938         <span class="keywordflow">return</span> NULL;
04939     }
04940 
04941     type = get_token(fp, token, MAXTOKEN);
04942     <span class="keywordflow">while</span> (type != RIGHTBRACKET &amp;&amp; type != ENDOFFILE) {
04943         <span class="keywordflow">if</span> ((type == LABEL) || (type &amp; SYNTAX_MASK)) {
04944             *mypp =
04945                 (<span class="keyword">struct </span>varbind_list *) calloc(1,
04946                                                <span class="keyword">sizeof</span>(<span class="keyword">struct</span>
04947                                                       varbind_list));
04948             <span class="keywordflow">if</span> (*mypp) {
04949                 (*mypp)-&gt;vblabel = strdup(token);
04950                 mypp = &amp;(*mypp)-&gt;next;
04951             }
04952         }
04953         type = get_token(fp, token, MAXTOKEN);
04954     }
04955 
04956     *retp = mylist;
04957     <span class="keywordflow">return</span> mylist;
04958 }
04959 
04960 <span class="keyword">static</span> <span class="keywordtype">void</span>
04961 free_indexes(<span class="keyword">struct</span> index_list **spp)
04962 {
04963     <span class="keywordflow">if</span> (spp &amp;&amp; *spp) {
04964         <span class="keyword">struct </span>index_list *pp, *npp;
04965 
04966         pp = *spp;
04967         *spp = NULL;
04968 
04969         <span class="keywordflow">while</span> (pp) {
04970             npp = pp-&gt;next;
04971             <span class="keywordflow">if</span> (pp-&gt;ilabel)
04972                 free(pp-&gt;ilabel);
04973             free(pp);
04974             pp = npp;
04975         }
04976     }
04977 }
04978 
04979 <span class="keyword">static</span> <span class="keywordtype">void</span>
04980 free_varbinds(<span class="keyword">struct</span> varbind_list **spp)
04981 {
04982     <span class="keywordflow">if</span> (spp &amp;&amp; *spp) {
04983         <span class="keyword">struct </span>varbind_list *pp, *npp;
04984 
04985         pp = *spp;
04986         *spp = NULL;
04987 
04988         <span class="keywordflow">while</span> (pp) {
04989             npp = pp-&gt;next;
04990             <span class="keywordflow">if</span> (pp-&gt;vblabel)
04991                 free(pp-&gt;vblabel);
04992             free(pp);
04993             pp = npp;
04994         }
04995     }
04996 }
04997 
04998 <span class="keyword">static</span> <span class="keywordtype">void</span>
04999 free_ranges(<span class="keyword">struct</span> range_list **spp)
05000 {
05001     <span class="keywordflow">if</span> (spp &amp;&amp; *spp) {
05002         <span class="keyword">struct </span>range_list *pp, *npp;
05003 
05004         pp = *spp;
05005         *spp = NULL;
05006 
05007         <span class="keywordflow">while</span> (pp) {
05008             npp = pp-&gt;next;
05009             free(pp);
05010             pp = npp;
05011         }
05012     }
05013 }
05014 
05015 <span class="keyword">static</span> <span class="keywordtype">void</span>
05016 free_enums(<span class="keyword">struct</span> enum_list **spp)
05017 {
05018     <span class="keywordflow">if</span> (spp &amp;&amp; *spp) {
05019         <span class="keyword">struct </span>enum_list *pp, *npp;
05020 
05021         pp = *spp;
05022         *spp = NULL;
05023 
05024         <span class="keywordflow">while</span> (pp) {
05025             npp = pp-&gt;next;
05026             <span class="keywordflow">if</span> (pp-&gt;label)
05027                 free(pp-&gt;label);
05028             free(pp);
05029             pp = npp;
05030         }
05031     }
05032 }
05033 
05034 <span class="keyword">static</span> <span class="keyword">struct </span>enum_list *
05035 copy_enums(<span class="keyword">struct</span> enum_list *sp)
05036 {
05037     <span class="keyword">struct </span>enum_list *xp = NULL, **spp = &amp;xp;
05038 
05039     <span class="keywordflow">while</span> (sp) {
05040         *spp = (<span class="keyword">struct </span>enum_list *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> enum_list));
05041         <span class="keywordflow">if</span> (!*spp)
05042             <span class="keywordflow">break</span>;
05043         (*spp)-&gt;label = strdup(sp-&gt;label);
05044         (*spp)-&gt;value = sp-&gt;value;
05045         spp = &amp;(*spp)-&gt;next;
05046         sp = sp-&gt;next;
05047     }
05048     <span class="keywordflow">return</span> (xp);
05049 }
05050 
05051 <span class="keyword">static</span> <span class="keyword">struct </span>range_list *
05052 copy_ranges(<span class="keyword">struct</span> range_list *sp)
05053 {
05054     <span class="keyword">struct </span>range_list *xp = NULL, **spp = &amp;xp;
05055 
05056     <span class="keywordflow">while</span> (sp) {
05057         *spp = (<span class="keyword">struct </span>range_list *) calloc(1, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> range_list));
05058         <span class="keywordflow">if</span> (!*spp)
05059             <span class="keywordflow">break</span>;
05060         (*spp)-&gt;low = sp-&gt;low;
05061         (*spp)-&gt;high = sp-&gt;high;
05062         spp = &amp;(*spp)-&gt;next;
05063         sp = sp-&gt;next;
05064     }
05065     <span class="keywordflow">return</span> (xp);
05066 }
05067 
05068 <span class="comment">/*</span>
05069 <span class="comment"> * This routine parses a string like  { blah blah blah } and returns OBJID if</span>
05070 <span class="comment"> * it is well formed, and NULL if not.</span>
05071 <span class="comment"> */</span>
05072 <span class="keyword">static</span> <span class="keywordtype">int</span>
05073 tossObjectIdentifier(FILE * fp)
05074 {
05075     <span class="keywordtype">int</span>             type;
05076     <span class="keywordtype">char</span>            token[MAXTOKEN];
05077     <span class="keywordtype">int</span>             bracketcount = 1;
05078 
05079     type = get_token(fp, token, MAXTOKEN);
05080 
05081     <span class="keywordflow">if</span> (type != LEFTBRACKET)
05082         <span class="keywordflow">return</span> 0;
05083     <span class="keywordflow">while</span> ((type != RIGHTBRACKET || bracketcount &gt; 0) &amp;&amp; type != ENDOFFILE) {
05084         type = get_token(fp, token, MAXTOKEN);
05085         <span class="keywordflow">if</span> (type == LEFTBRACKET)
05086             bracketcount++;
05087         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == RIGHTBRACKET)
05088             bracketcount--;
05089     }
05090 
05091     <span class="keywordflow">if</span> (type == RIGHTBRACKET)
05092         <span class="keywordflow">return</span> OBJID;
05093     <span class="keywordflow">else</span>
05094         <span class="keywordflow">return</span> 0;
05095 }
05096 
05097 <span class="comment">/* Find node in any MIB module</span>
05098 <span class="comment">   Used by Perl modules         */</span>
05099 <span class="keyword">struct </span>tree    *
05100 find_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class=
"keyword">struct</span> tree *subtree)
05101 {                               <span class="comment">/* Unused */</span>
05102     <span class="keywordflow">return</span> (find_tree_node(name, -1));
05103 }
05104 
05105 <span class="comment">/* Find node in specific MIB module</span>
05106 <span class="comment">   Used by Perl modules         */</span>
05107 <span class="keyword">struct </span>tree    *
05108 find_node2(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *module)
05109 {                               
05110   <span class="keywordtype">int</span> modid = -1;
05111   <span class="keywordflow">if</span> (module) {
05112     modid = which_module(module);
05113   }
05114   <span class="keywordflow">if</span> (modid == -1)
05115   {
05116     <span class="keywordflow">return</span> (NULL);
05117   }
05118   <span class="keywordflow">return</span> (find_tree_node(name, modid));
05119 }
05120 
05121 <span class="keyword">struct </span>module  *
05122 find_module(<span class="keywordtype">int</span> mid)
05123 {
05124     <span class="keyword">struct </span>module  *mp;
05125 
05126     <span class="keywordflow">for</span> (mp = module_head; mp != NULL; mp = mp-&gt;next) {
05127         <span class="keywordflow">if</span> (mp-&gt;modid == mid)
05128             <span class="keywordflow">break</span>;
05129     }
05130     <span class="keywordflow">if</span> (mp != 0)
05131         <span class="keywordflow">return</span> mp;
05132     <span class="keywordflow">return</span> NULL;
05133 }
05134 
05135 
05136 <span class="keyword">static</span> <span class="keywordtype">char</span>     leave_indent[256];
05137 <span class="keyword">static</span> <span class="keywordtype">int</span>      leave_was_simple;
05138 
05139 <span class="keyword">static</span> <span class="keywordtype">void</span>
05140 print_mib_leaves(FILE * f, <span class="keyword">struct</span> tree *tp, <span class="keywordtype">int</span> width)
05141 {
05142     <span class="keyword">struct </span>tree    *ntp;
05143     <span class="keywordtype">char</span>           *ip = leave_indent + strlen(leave_indent) - 1;
05144     <span class="keywordtype">char</span>            last_ipch = *ip;
05145 
05146     *ip = <span class="charliteral">'+'</span>;
05147     <span class="keywordflow">if</span> (tp-&gt;type == TYPE_OTHER || tp-&gt;type &gt; TYPE_SIMPLE_LAST) {
05148         fprintf(f, <span class="stringliteral">"%s--%s(%ld)\n"</span>, leave_indent, tp-&gt;label, tp-&gt;subid);
05149         <span class="keywordflow">if</span> (tp-&gt;indexes) {
05150             <span class="keyword">struct </span>index_list *xp = tp-&gt;indexes;
05151             <span class="keywordtype">int</span>             first = 1, cpos = 0, len, cmax =
05152                 width - strlen(leave_indent) - 12;
05153             *ip = last_ipch;
05154             fprintf(f, <span class="stringliteral">"%s  |  Index: "</span>, leave_indent);
05155             <span class="keywordflow">while</span> (xp) {
05156                 <span class="keywordflow">if</span> (first)
05157                     first = 0;
05158                 <span class="keywordflow">else</span>
05159                     fprintf(f, <span class="stringliteral">", "</span>);
05160                 cpos += (len = strlen(xp-&gt;ilabel) + 2);
05161                 <span class="keywordflow">if</span> (cpos &gt; cmax) {
05162                     fprintf(f, <span class="stringliteral">"\n"</span>);
05163                     fprintf(f, <span class="stringliteral">"%s  |         "</span>, leave_indent);
05164                     cpos = len;
05165                 }
05166                 fprintf(f, <span class="stringliteral">"%s"</span>, xp-&gt;ilabel);
05167                 xp = xp-&gt;next;
05168             }
05169             fprintf(f, <span class="stringliteral">"\n"</span>);
05170             *ip = <span class="charliteral">'+'</span>;
05171         }
05172     } <span class="keywordflow">else</span> {
05173         <span class="keyword">const</span> <span class="keywordtype">char</span>     *acc, *typ;
05174         <span class="keywordtype">int</span>             size = 0;
05175         <span class="keywordflow">switch</span> (tp-&gt;access) {
05176         <span class="keywordflow">case</span> MIB_ACCESS_NOACCESS:
05177             acc = <span class="stringliteral">"----"</span>;
05178             <span class="keywordflow">break</span>;
05179         <span class="keywordflow">case</span> MIB_ACCESS_READONLY:
05180             acc = <span class="stringliteral">"-R--"</span>;
05181             <span class="keywordflow">break</span>;
05182         <span class="keywordflow">case</span> MIB_ACCESS_WRITEONLY:
05183             acc = <span class="stringliteral">"--W-"</span>;
05184             <span class="keywordflow">break</span>;
05185         <span class="keywordflow">case</span> MIB_ACCESS_READWRITE:
05186             acc = <span class="stringliteral">"-RW-"</span>;
05187             <span class="keywordflow">break</span>;
05188         <span class="keywordflow">case</span> MIB_ACCESS_NOTIFY:
05189             acc = <span class="stringliteral">"---N"</span>;
05190             <span class="keywordflow">break</span>;
05191         <span class="keywordflow">case</span> MIB_ACCESS_CREATE:
05192             acc = <span class="stringliteral">"CR--"</span>;
05193             <span class="keywordflow">break</span>;
05194         <span class="keywordflow">default</span>:
05195             acc = <span class="stringliteral">"    "</span>;
05196             <span class="keywordflow">break</span>;
05197         }
05198         <span class="keywordflow">switch</span> (tp-&gt;type) {
05199         <span class="keywordflow">case</span> TYPE_OBJID:
05200             typ = <span class="stringliteral">"ObjID    "</span>;
05201             <span class="keywordflow">break</span>;
05202         <span class="keywordflow">case</span> TYPE_OCTETSTR:
05203             typ = <span class="stringliteral">"String   "</span>;
05204             size = 1;
05205             <span class="keywordflow">break</span>;
05206         <span class="keywordflow">case</span> TYPE_INTEGER:
05207             <span class="keywordflow">if</span> (tp-&gt;enums)
05208                 typ = <span class="stringliteral">"EnumVal  "</span>;
05209             <span class="keywordflow">else</span>
05210                 typ = <span class="stringliteral">"INTEGER  "</span>;
05211             <span class="keywordflow">break</span>;
05212         <span class="keywordflow">case</span> TYPE_NETADDR:
05213             typ = <span class="stringliteral">"NetAddr  "</span>;
05214             <span class="keywordflow">break</span>;
05215         <span class="keywordflow">case</span> TYPE_IPADDR:
05216             typ = <span class="stringliteral">"IpAddr   "</span>;
05217             <span class="keywordflow">break</span>;
05218         <span class="keywordflow">case</span> TYPE_COUNTER:
05219             typ = <span class="stringliteral">"Counter  "</span>;
05220             <span class="keywordflow">break</span>;
05221         <span class="keywordflow">case</span> TYPE_GAUGE:
05222             typ = <span class="stringliteral">"Gauge    "</span>;
05223             <span class="keywordflow">break</span>;
05224         <span class="keywordflow">case</span> TYPE_TIMETICKS:
05225             typ = <span class="stringliteral">"TimeTicks"</span>;
05226             <span class="keywordflow">break</span>;
05227         <span class="keywordflow">case</span> TYPE_OPAQUE:
05228             typ = <span class="stringliteral">"Opaque   "</span>;
05229             size = 1;
05230             <span class="keywordflow">break</span>;
05231         <span class="keywordflow">case</span> TYPE_NULL:
05232             typ = <span class="stringliteral">"Null     "</span>;
05233             <span class="keywordflow">break</span>;
05234         <span class="keywordflow">case</span> TYPE_COUNTER64:
05235             typ = <span class="stringliteral">"Counter64"</span>;
05236             <span class="keywordflow">break</span>;
05237         <span class="keywordflow">case</span> TYPE_BITSTRING:
05238             typ = <span class="stringliteral">"BitString"</span>;
05239             <span class="keywordflow">break</span>;
05240         <span class="keywordflow">case</span> TYPE_NSAPADDRESS:
05241             typ = <span class="stringliteral">"NsapAddr "</span>;
05242             <span class="keywordflow">break</span>;
05243         <span class="keywordflow">case</span> TYPE_UNSIGNED32:
05244             typ = <span class="stringliteral">"Unsigned "</span>;
05245             <span class="keywordflow">break</span>;
05246         <span class="keywordflow">case</span> TYPE_UINTEGER:
05247             typ = <span class="stringliteral">"UInteger "</span>;
05248             <span class="keywordflow">break</span>;
05249         <span class="keywordflow">case</span> TYPE_INTEGER32:
05250             typ = <span class="stringliteral">"Integer32"</span>;
05251             <span class="keywordflow">break</span>;
05252         <span class="keywordflow">default</span>:
05253             typ = <span class="stringliteral">"         "</span>;
05254             <span class="keywordflow">break</span>;
05255         }
05256         fprintf(f, <span class="stringliteral">"%s-- %s %s %s(%ld)\n"</span>, leave_indent, acc, typ,
05257                 tp-&gt;label, tp-&gt;subid);
05258         *ip = last_ipch;
05259         <span class="keywordflow">if</span> (tp-&gt;tc_index &gt;= 0)
05260             fprintf(f, <span class="stringliteral">"%s        Textual Convention: %s\n"</span>, leave_indent,
05261                     tclist[tp-&gt;tc_index].descriptor);
05262         <span class="keywordflow">if</span> (tp-&gt;enums) {
05263             <span class="keyword">struct </span>enum_list *ep = tp-&gt;enums;
05264             <span class="keywordtype">int</span>             cpos = 0, cmax =
05265                 width - strlen(leave_indent) - 16;
05266             fprintf(f, <span class="stringliteral">"%s        Values: "</span>, leave_indent);
05267             <span class="keywordflow">while</span> (ep) {
05268                 <span class="keywordtype">char</span>            buf[80];
05269                 <span class="keywordtype">int</span>             bufw;
05270                 <span class="keywordflow">if</span> (ep != tp-&gt;enums)
05271                     fprintf(f, <span class="stringliteral">", "</span>);
05272                 snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class=
"stringliteral">"%s(%d)"</span>, ep-&gt;label, ep-&gt;value);
05273                 buf[ <span class="keyword">sizeof</span>(buf)-1 ] = 0;
05274                 cpos += (bufw = strlen(buf) + 2);
05275                 <span class="keywordflow">if</span> (cpos &gt;= cmax) {
05276                     fprintf(f, <span class="stringliteral">"\n%s                "</span>, leave_indent);
05277                     cpos = bufw;
05278                 }
05279                 fprintf(f, <span class="stringliteral">"%s"</span>, buf);
05280                 ep = ep-&gt;next;
05281             }
05282             fprintf(f, <span class="stringliteral">"\n"</span>);
05283         }
05284         <span class="keywordflow">if</span> (tp-&gt;ranges) {
05285             <span class="keyword">struct </span>range_list *rp = tp-&gt;ranges;
05286             <span class="keywordflow">if</span> (size)
05287                 fprintf(f, <span class="stringliteral">"%s        Size: "</span>, leave_indent);
05288             <span class="keywordflow">else</span>
05289                 fprintf(f, <span class="stringliteral">"%s        Range: "</span>, leave_indent);
05290             <span class="keywordflow">while</span> (rp) {
05291                 <span class="keywordflow">if</span> (rp != tp-&gt;ranges)
05292                     fprintf(f, <span class="stringliteral">" | "</span>);
05293                 <span class="keywordflow">if</span> (rp-&gt;low == rp-&gt;high)
05294                     fprintf(f, <span class="stringliteral">"%d"</span>, rp-&gt;low);
05295                 <span class="keywordflow">else</span>
05296                     fprintf(f, <span class="stringliteral">"%d..%d"</span>, rp-&gt;low, rp-&gt;high);
05297                 rp = rp-&gt;next;
05298             }
05299             fprintf(f, <span class="stringliteral">"\n"</span>);
05300         }
05301     }
05302     *ip = last_ipch;
05303     strcat(leave_indent, <span class="stringliteral">"  |"</span>);
05304     leave_was_simple = tp-&gt;type != TYPE_OTHER;
05305 
05306     {
05307         <span class="keywordtype">int</span>             i, j, count = 0;
05308         <span class="keyword">struct </span>leave {
05309             oid             id;
05310             <span class="keyword">struct </span>tree    *tp;
05311         }              *leaves, *lp;
05312 
05313         <span class="keywordflow">for</span> (ntp = tp-&gt;child_list; ntp; ntp = ntp-&gt;next_peer)
05314             count++;
05315         <span class="keywordflow">if</span> (count) {
05316             leaves = (<span class="keyword">struct </span>leave *) calloc(count, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> leave));
05317             <span class="keywordflow">if</span> (!leaves)
05318                 <span class="keywordflow">return</span>;
05319             <span class="keywordflow">for</span> (ntp = tp-&gt;child_list, count = 0; ntp;
05320                  ntp = ntp-&gt;next_peer) {
05321                 <span class="keywordflow">for</span> (i = 0, lp = leaves; i &lt; count; i++, lp++)
05322                     <span class="keywordflow">if</span> (lp-&gt;id &gt;= ntp-&gt;subid)
05323                         <span class="keywordflow">break</span>;
05324                 <span class="keywordflow">for</span> (j = count; j &gt; i; j--)
05325                     leaves[j] = leaves[j - 1];
05326                 lp-&gt;id = ntp-&gt;subid;
05327                 lp-&gt;tp = ntp;
05328                 count++;
05329             }
05330             <span class="keywordflow">for</span> (i = 1, lp = leaves; i &lt;= count; i++, lp++) {
05331                 <span class="keywordflow">if</span> (!leave_was_simple || lp-&gt;tp-&gt;type == 0)
05332                     fprintf(f, <span class="stringliteral">"%s\n"</span>, leave_indent);
05333                 <span class="keywordflow">if</span> (i == count)
05334                     ip[3] = <span class="charliteral">' '</span>;
05335                 print_mib_leaves(f, lp-&gt;tp, width);
05336             }
05337             free(leaves);
05338             leave_was_simple = 0;
05339         }
05340     }
05341     ip[1] = 0;
05342 }
05343 
05344 <span class="keywordtype">void</span>
05345 print_mib_tree(FILE * f, <span class="keyword">struct</span> tree *tp, <span class="keywordtype">int</span> width)
05346 {
05347     leave_indent[0] = <span class="charliteral">' '</span>;
05348     leave_indent[1] = 0;
05349     leave_was_simple = 1;
05350     print_mib_leaves(f, tp, width);
05351 }
05352 
05353 
05354 <span class="comment">/*</span>
05355 <span class="comment"> * Merge the parsed object identifier with the existing node.</span>
05356 <span class="comment"> * If there is a problem with the identifier, release the existing node.</span>
05357 <span class="comment"> */</span>
05358 <span class="keyword">static</span> <span class="keyword">struct </span>node *
05359 merge_parse_objectid(<span class="keyword">struct</span> node *np, FILE * fp, <span class="keywordtype">char</span> *name)
05360 {
05361     <span class="keyword">struct </span>node    *nnp;
05362     <span class="comment">/*</span>
05363 <span class="comment">     * printf("merge defval --&gt; %s\n",np-&gt;defaultValue); </span>
05364 <span class="comment">     */</span>
05365     nnp = parse_objectid(fp, name);
05366     <span class="keywordflow">if</span> (nnp) {
05367 
05368         <span class="comment">/*</span>
05369 <span class="comment">         * apply last OID sub-identifier data to the information </span>
05370 <span class="comment">         */</span>
05371         <span class="comment">/*</span>
05372 <span class="comment">         * already collected for this node. </span>
05373 <span class="comment">         */</span>
05374         <span class="keyword">struct </span>node    *headp, *nextp;
05375         <span class="keywordtype">int</span>             ncount = 0;
05376         nextp = headp = nnp;
05377         <span class="keywordflow">while</span> (nnp-&gt;next) {
05378             nextp = nnp;
05379             ncount++;
05380             nnp = nnp-&gt;next;
05381         }
05382 
05383         np-&gt;label = nnp-&gt;label;
05384         np-&gt;subid = nnp-&gt;subid;
05385         np-&gt;modid = nnp-&gt;modid;
05386         np-&gt;parent = nnp-&gt;parent;
05387         <span class="keywordflow">if</span> (nnp-&gt;filename != NULL) {
05388           free(nnp-&gt;filename);
05389         }
05390         free(nnp);
05391 
05392         <span class="keywordflow">if</span> (ncount) {
05393             nextp-&gt;next = np;
05394             np = headp;
05395         }
05396     } <span class="keywordflow">else</span> {
05397         free_node(np);
05398         np = NULL;
05399     }
05400 
05401     <span class="keywordflow">return</span> np;
05402 }
05403 
05404 <span class="comment">/*</span>
05405 <span class="comment"> * transfer data to tree from node</span>
05406 <span class="comment"> *</span>
05407 <span class="comment"> * move pointers for alloc'd data from np to tp.</span>
05408 <span class="comment"> * this prevents them from being freed when np is released.</span>
05409 <span class="comment"> * parent member is not moved.</span>
05410 <span class="comment"> *</span>
05411 <span class="comment"> * CAUTION: nodes may be repeats of existing tree nodes.</span>
05412 <span class="comment"> * This can happen especially when resolving IMPORT clauses.</span>
05413 <span class="comment"> *</span>
05414 <span class="comment"> */</span>
05415 <span class="keyword">static</span> <span class="keywordtype">void</span>
05416 tree_from_node(<span class="keyword">struct</span> tree *tp, <span class="keyword">struct</span> node *np)
05417 {
05418     free_partial_tree(tp, FALSE);
05419 
05420     tp-&gt;label = np-&gt;label;
05421     np-&gt;label = NULL;
05422     tp-&gt;enums = np-&gt;enums;
05423     np-&gt;enums = NULL;
05424     tp-&gt;ranges = np-&gt;ranges;
05425     np-&gt;ranges = NULL;
05426     tp-&gt;indexes = np-&gt;indexes;
05427     np-&gt;indexes = NULL;
05428     tp-&gt;augments = np-&gt;augments;
05429     np-&gt;augments = NULL;
05430     tp-&gt;varbinds = np-&gt;varbinds;
05431     np-&gt;varbinds = NULL;
05432     tp-&gt;hint = np-&gt;hint;
05433     np-&gt;hint = NULL;
05434     tp-&gt;units = np-&gt;units;
05435     np-&gt;units = NULL;
05436     tp-&gt;description = np-&gt;description;
05437     np-&gt;description = NULL;
05438     tp-&gt;reference = np-&gt;reference;
05439     np-&gt;reference = NULL;
05440     tp-&gt;defaultValue = np-&gt;defaultValue;
05441     np-&gt;defaultValue = NULL;
05442     tp-&gt;subid = np-&gt;subid;
05443     tp-&gt;tc_index = np-&gt;tc_index;
05444     tp-&gt;type = translation_table[np-&gt;type];
05445     tp-&gt;access = np-&gt;access;
05446     tp-&gt;status = np-&gt;status;
05447 
05448     <a class="code" href="group__mib__utilities.html#ga61">set_function</a>(tp);
05449 }
05450 
05451 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small>Generated on Fri Dec 30 13:47:46 2005 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

