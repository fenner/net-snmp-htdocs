<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>parse.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * parse.c</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Update: 1998-09-22 &lt;mslifcak@iss.net&gt;</span>
00005 <span class="comment"> * Clear nbuckets in init_node_hash.</span>
00006 <span class="comment"> * New method xcalloc returns zeroed data structures.</span>
00007 <span class="comment"> * New method alloc_node encapsulates common node creation.</span>
00008 <span class="comment"> * New method to configure terminate comment at end of line.</span>
00009 <span class="comment"> * New method to configure accept underscore in labels.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * Update: 1998-10-10 &lt;daves@csc.liv.ac.uk&gt;</span>
00012 <span class="comment"> * fully qualified OID parsing patch</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * Update: 1998-10-20 &lt;daves@csc.liv.ac.uk&gt;</span>
00015 <span class="comment"> * merge_anon_children patch</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * Update: 1998-10-21 &lt;mslifcak@iss.net&gt;</span>
00018 <span class="comment"> * Merge_parse_objectid associates information with last node in chain.</span>
00019 <span class="comment"> */</span>
00020 <span class="comment">/* Portions of this file are subject to the following copyrights.  See</span>
00021 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00022 <span class="comment"> * that may apply:</span>
00023 <span class="comment"> */</span>
00024 <span class="comment">/******************************************************************</span>
00025 <span class="comment">        Copyright 1989, 1991, 1992 by Carnegie Mellon University</span>
00026 
00027 <span class="comment">                      All Rights Reserved</span>
00028 
00029 <span class="comment">Permission to use, copy, modify, and distribute this software and its</span>
00030 <span class="comment">documentation for any purpose and without fee is hereby granted,</span>
00031 <span class="comment">provided that the above copyright notice appear in all copies and that</span>
00032 <span class="comment">both that copyright notice and this permission notice appear in</span>
00033 <span class="comment">supporting documentation, and that the name of CMU not be</span>
00034 <span class="comment">used in advertising or publicity pertaining to distribution of the</span>
00035 <span class="comment">software without specific, written prior permission.</span>
00036 
00037 <span class="comment">CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING</span>
00038 <span class="comment">ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL</span>
00039 <span class="comment">CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR</span>
00040 <span class="comment">ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</span>
00041 <span class="comment">WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,</span>
00042 <span class="comment">ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS</span>
00043 <span class="comment">SOFTWARE.</span>
00044 <span class="comment">******************************************************************/</span>
00045 <span class="comment">/*</span>
00046 <span class="comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
00047 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00048 <span class="comment"> * distributed with the Net-SNMP package.</span>
00049 <span class="comment"> */</span>
00050 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00051 
00052 <span class="preprocessor">#ifndef DISABLE_MIB_LOADING</span>
00053 
00054 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00055 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00056 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00057 <span class="preprocessor">#endif</span>
00058 <span class="preprocessor">#if HAVE_STRING_H</span>
00059 <span class="preprocessor">#include &lt;string.h&gt;</span>
00060 <span class="preprocessor">#else</span>
00061 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00062 <span class="preprocessor">#endif</span>
00063 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00064 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00065 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00066 
00067 <span class="comment">/*</span>
00068 <span class="comment"> * Wow.  This is ugly.  -- Wes </span>
00069 <span class="comment"> */</span>
00070 <span class="preprocessor">#if HAVE_DIRENT_H</span>
00071 <span class="preprocessor"># include &lt;dirent.h&gt;</span>
00072 <span class="preprocessor"># define NAMLEN(dirent) strlen((dirent)-&gt;d_name)</span>
00073 <span class="preprocessor">#else</span>
00074 <span class="preprocessor"># define dirent direct</span>
00075 <span class="preprocessor"># define NAMLEN(dirent) (dirent)-&gt;d_namlen</span>
00076 <span class="preprocessor"># if HAVE_SYS_NDIR_H</span>
00077 <span class="preprocessor">#  include &lt;sys/ndir.h&gt;</span>
00078 <span class="preprocessor"># endif</span>
00079 <span class="preprocessor"># if HAVE_SYS_DIR_H</span>
00080 <span class="preprocessor">#  include &lt;sys/dir.h&gt;</span>
00081 <span class="preprocessor"># endif</span>
00082 <span class="preprocessor"># if HAVE_NDIR_H</span>
00083 <span class="preprocessor">#  include &lt;ndir.h&gt;</span>
00084 <span class="preprocessor"># endif</span>
00085 <span class="preprocessor">#endif</span>
00086 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00087 <span class="preprocessor"># ifdef WIN32</span>
00088 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00089 <span class="preprocessor"># else</span>
00090 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00091 <span class="preprocessor"># endif</span>
00092 <span class="preprocessor"># include &lt;time.h&gt;</span>
00093 <span class="preprocessor">#else</span>
00094 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00095 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00096 <span class="preprocessor"># else</span>
00097 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00098 <span class="preprocessor"># endif</span>
00099 <span class="preprocessor">#endif</span>
00100 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00101 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00102 <span class="preprocessor">#endif</span>
00103 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00104 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00105 <span class="preprocessor">#endif</span>
00106 <span class="preprocessor">#if defined(HAVE_REGEX_H) &amp;&amp; defined(HAVE_REGCOMP)</span>
00107 <span class="preprocessor">#include &lt;regex.h&gt;</span>
00108 <span class="preprocessor">#endif</span>
00109 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00110 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00111 <span class="preprocessor">#endif</span>
00112 
00113 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00114 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00115 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00116 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00117 
00118 <span class="preprocessor">#include &lt;net-snmp/library/parse.h&gt;</span>
00119 <span class="preprocessor">#include &lt;net-snmp/library/mib.h&gt;</span>
00120 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00121 
00122 <span class="comment">/*</span>
00123 <span class="comment"> * This is one element of an object identifier with either an integer</span>
00124 <span class="comment"> * subidentifier, or a textual string label, or both.</span>
00125 <span class="comment"> * The subid is -1 if not present, and label is NULL if not present.</span>
00126 <span class="comment"> */</span>
00127 <span class="keyword">struct </span>subid_s {
00128     <span class="keywordtype">int</span>             subid;
00129     <span class="keywordtype">int</span>             modid;
00130     <span class="keywordtype">char</span>           *label;
00131 };
00132 
00133 <span class="preprocessor">#define MAXTC   4096</span>
00134 <span class="keyword">struct </span>tc {                     <span class="comment">/* textual conventions */</span>
00135     <span class="keywordtype">int</span>             type;
00136     <span class="keywordtype">int</span>             modid;
00137     <span class="keywordtype">char</span>           *descriptor;
00138     <span class="keywordtype">char</span>           *hint;
00139     <span class="keyword">struct </span>enum_list *enums;
00140     <span class="keyword">struct </span>range_list *ranges;
00141     <span class="keywordtype">char</span>           *description;
00142 } tclist[MAXTC];
00143 
00144 <span class="keywordtype">int</span>             mibLine = 0;
00145 <span class="keyword">const</span> <span class="keywordtype">char</span>     *File = <span class=
"stringliteral">"(none)"</span>;
00146 <span class="keyword">static</span> <span class="keywordtype">int</span>      anonymous = 0;
00147 
00148 <span class="keyword">struct </span>objgroup {
00149     <span class="keywordtype">char</span>           *name;
00150     <span class="keywordtype">int</span>             line;
00151     <span class="keyword">struct </span>objgroup *next;
00152 }              *objgroups = NULL, *objects = NULL, *notifs = NULL;
00153 
00154 <span class="preprocessor">#define SYNTAX_MASK     0x80</span>
00155 <span class="comment">/*</span>
00156 <span class="comment"> * types of tokens</span>
00157 <span class="comment"> * Tokens wiht the SYNTAX_MASK bit set are syntax tokens </span>
00158 <span class="comment"> */</span>
00159 <span class="preprocessor">#define CONTINUE    -1</span>
00160 <span class="preprocessor">#define ENDOFFILE   0</span>
00161 <span class="preprocessor">#define LABEL       1</span>
00162 <span class="preprocessor">#define SUBTREE     2</span>
00163 <span class="preprocessor">#define SYNTAX      3</span>
00164 <span class="preprocessor">#define OBJID       (4 | SYNTAX_MASK)</span>
00165 <span class="preprocessor">#define OCTETSTR    (5 | SYNTAX_MASK)</span>
00166 <span class="preprocessor">#define INTEGER     (6 | SYNTAX_MASK)</span>
00167 <span class="preprocessor">#define NETADDR     (7 | SYNTAX_MASK)</span>
00168 <span class="preprocessor">#define IPADDR      (8 | SYNTAX_MASK)</span>
00169 <span class="preprocessor">#define COUNTER     (9 | SYNTAX_MASK)</span>
00170 <span class="preprocessor">#define GAUGE       (10 | SYNTAX_MASK)</span>
00171 <span class="preprocessor">#define TIMETICKS   (11 | SYNTAX_MASK)</span>
00172 <span class="preprocessor">#define KW_OPAQUE   (12 | SYNTAX_MASK)</span>
00173 <span class="preprocessor">#define NUL         (13 | SYNTAX_MASK)</span>
00174 <span class="preprocessor">#define SEQUENCE    14</span>
00175 <span class="preprocessor">#define OF          15          </span><span class="comment">/* SEQUENCE OF */</span>
00176 <span class="preprocessor">#define OBJTYPE     16</span>
00177 <span class="preprocessor">#define ACCESS      17</span>
00178 <span class="preprocessor">#define READONLY    18</span>
00179 <span class="preprocessor">#define READWRITE   19</span>
00180 <span class="preprocessor">#define WRITEONLY   20</span>
00181 <span class="preprocessor">#ifdef NOACCESS</span>
00182 <span class="preprocessor">#undef NOACCESS                 </span><span class="comment">/* agent 'NOACCESS' token */</span>
00183 <span class="preprocessor">#endif</span>
00184 <span class="preprocessor">#define NOACCESS    21</span>
00185 <span class="preprocessor">#define STATUS      22</span>
00186 <span class="preprocessor">#define MANDATORY   23</span>
00187 <span class="preprocessor">#define KW_OPTIONAL    24</span>
00188 <span class="preprocessor">#define OBSOLETE    25</span>
00189 <span class="comment">/*</span>
00190 <span class="comment"> * #define RECOMMENDED 26 </span>
00191 <span class="comment"> */</span>
00192 <span class="preprocessor">#define PUNCT       27</span>
00193 <span class="preprocessor">#define EQUALS      28</span>
00194 <span class="preprocessor">#define NUMBER      29</span>
00195 <span class="preprocessor">#define LEFTBRACKET 30</span>
00196 <span class="preprocessor">#define RIGHTBRACKET 31</span>
00197 <span class="preprocessor">#define LEFTPAREN   32</span>
00198 <span class="preprocessor">#define RIGHTPAREN  33</span>
00199 <span class="preprocessor">#define COMMA       34</span>
00200 <span class="preprocessor">#define DESCRIPTION 35</span>
00201 <span class="preprocessor">#define QUOTESTRING 36</span>
00202 <span class="preprocessor">#define INDEX       37</span>
00203 <span class="preprocessor">#define DEFVAL      38</span>
00204 <span class="preprocessor">#define DEPRECATED  39</span>
00205 <span class="preprocessor">#define SIZE        40</span>
00206 <span class="preprocessor">#define BITSTRING   (41 | SYNTAX_MASK)</span>
00207 <span class="preprocessor">#define NSAPADDRESS (42 | SYNTAX_MASK)</span>
00208 <span class="preprocessor">#define COUNTER64   (43 | SYNTAX_MASK)</span>
00209 <span class="preprocessor">#define OBJGROUP    44</span>
00210 <span class="preprocessor">#define NOTIFTYPE   45</span>
00211 <span class="preprocessor">#define AUGMENTS    46</span>
00212 <span class="preprocessor">#define COMPLIANCE  47</span>
00213 <span class="preprocessor">#define READCREATE  48</span>
00214 <span class="preprocessor">#define UNITS       49</span>
00215 <span class="preprocessor">#define REFERENCE   50</span>
00216 <span class="preprocessor">#define NUM_ENTRIES 51</span>
00217 <span class="preprocessor">#define MODULEIDENTITY 52</span>
00218 <span class="preprocessor">#define LASTUPDATED 53</span>
00219 <span class="preprocessor">#define ORGANIZATION 54</span>
00220 <span class="preprocessor">#define CONTACTINFO 55</span>
00221 <span class="preprocessor">#define UINTEGER32 (56 | SYNTAX_MASK)</span>
00222 <span class="preprocessor">#define CURRENT     57</span>
00223 <span class="preprocessor">#define DEFINITIONS 58</span>
00224 <span class="preprocessor">#define END         59</span>
00225 <span class="preprocessor">#define SEMI        60</span>
00226 <span class="preprocessor">#define TRAPTYPE    61</span>
00227 <span class="preprocessor">#define ENTERPRISE  62</span>
00228 <span class="comment">/*</span>
00229 <span class="comment"> * #define DISPLAYSTR (63 | SYNTAX_MASK) </span>
00230 <span class="comment"> */</span>
00231 <span class="preprocessor">#define BEGIN       64</span>
00232 <span class="preprocessor">#define IMPORTS     65</span>
00233 <span class="preprocessor">#define EXPORTS     66</span>
00234 <span class="preprocessor">#define ACCNOTIFY   67</span>
00235 <span class="preprocessor">#define BAR         68</span>
00236 <span class="preprocessor">#define RANGE       69</span>
00237 <span class="preprocessor">#define CONVENTION  70</span>
00238 <span class="preprocessor">#define DISPLAYHINT 71</span>
00239 <span class="preprocessor">#define FROM        72</span>
00240 <span class="preprocessor">#define AGENTCAP    73</span>
00241 <span class="preprocessor">#define MACRO       74</span>
00242 <span class="preprocessor">#define IMPLIED     75</span>
00243 <span class="preprocessor">#define SUPPORTS    76</span>
00244 <span class="preprocessor">#define INCLUDES    77</span>
00245 <span class="preprocessor">#define VARIATION   78</span>
00246 <span class="preprocessor">#define REVISION    79</span>
00247 <span class="preprocessor">#define NOTIMPL     80</span>
00248 <span class="preprocessor">#define OBJECTS     81</span>
00249 <span class="preprocessor">#define NOTIFICATIONS   82</span>
00250 <span class="preprocessor">#define MODULE      83</span>
00251 <span class="preprocessor">#define MINACCESS   84</span>
00252 <span class="preprocessor">#define PRODREL     85</span>
00253 <span class="preprocessor">#define WRSYNTAX    86</span>
00254 <span class="preprocessor">#define CREATEREQ   87</span>
00255 <span class="preprocessor">#define NOTIFGROUP  88</span>
00256 <span class="preprocessor">#define MANDATORYGROUPS 89</span>
00257 <span class="preprocessor">#define GROUP       90</span>
00258 <span class="preprocessor">#define OBJECT      91</span>
00259 <span class="preprocessor">#define IDENTIFIER  92</span>
00260 <span class="preprocessor">#define CHOICE      93</span>
00261 <span class="preprocessor">#define LEFTSQBRACK     95</span>
00262 <span class="preprocessor">#define RIGHTSQBRACK    96</span>
00263 <span class="preprocessor">#define IMPLICIT    97</span>
00264 <span class="preprocessor">#define APPSYNTAX       (98 | SYNTAX_MASK)</span>
00265 <span class="preprocessor">#define OBJSYNTAX       (99 | SYNTAX_MASK)</span>
00266 <span class="preprocessor">#define SIMPLESYNTAX    (100 | SYNTAX_MASK)</span>
00267 <span class="preprocessor">#define OBJNAME         (101 | SYNTAX_MASK)</span>
00268 <span class="preprocessor">#define NOTIFNAME       (102 | SYNTAX_MASK)</span>
00269 <span class="preprocessor">#define VARIABLES       103</span>
00270 <span class="preprocessor">#define UNSIGNED32      (104 | SYNTAX_MASK)</span>
00271 <span class="preprocessor">#define INTEGER32       (105 | SYNTAX_MASK)</span>
00272 <span class="comment">/*</span>
00273 <span class="comment"> * Beware of reaching SYNTAX_MASK (0x80) </span>
00274 <span class="comment"> */</span>
00275 
00276 <span class="keyword">struct </span>tok {
00277     <span class="keyword">const</span> <span class="keywordtype">char</span>     *name;       <span class=
"comment">/* token name */</span>
00278     <span class="keywordtype">int</span>             len;        <span class="comment">/* length not counting nul */</span>
00279     <span class="keywordtype">int</span>             token;      <span class="comment">/* value */</span>
00280     <span class="keywordtype">int</span>             hash;       <span class="comment">/* hash of name */</span>
00281     <span class="keyword">struct </span>tok     *next;       <span class=
"comment">/* pointer to next in hash table */</span>
00282 };
00283 
00284 
00285 <span class="keyword">static</span> <span class="keyword">struct </span>tok tokens[] = {
00286     {<span class="stringliteral">"obsolete"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"obsolete"</span>) - 1, OBSOLETE}
00287     ,
00288     {<span class="stringliteral">"Opaque"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Opaque"</span>) - 1, KW_OPAQUE}
00289     ,
00290     {<span class="stringliteral">"optional"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"optional"</span>) - 1, KW_OPTIONAL}
00291     ,
00292     {<span class="stringliteral">"LAST-UPDATED"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"LAST-UPDATED"</span>) - 1, LASTUPDATED}
00293     ,
00294     {<span class="stringliteral">"ORGANIZATION"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"ORGANIZATION"</span>) - 1, ORGANIZATION}
00295     ,
00296     {<span class="stringliteral">"CONTACT-INFO"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"CONTACT-INFO"</span>) - 1, CONTACTINFO}
00297     ,
00298     {<span class="stringliteral">"MODULE-IDENTITY"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MODULE-IDENTITY"</span>) - 1, MODULEIDENTITY}
00299     ,
00300     {<span class="stringliteral">"MODULE-COMPLIANCE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MODULE-COMPLIANCE"</span>) - 1, COMPLIANCE}
00301     ,
00302     {<span class="stringliteral">"DEFINITIONS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"DEFINITIONS"</span>) - 1, DEFINITIONS}
00303     ,
00304     {<span class="stringliteral">"END"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"END"</span>) - 1, END}
00305     ,
00306     {<span class="stringliteral">"AUGMENTS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"AUGMENTS"</span>) - 1, AUGMENTS}
00307     ,
00308     {<span class="stringliteral">"not-accessible"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"not-accessible"</span>) - 1, NOACCESS}
00309     ,
00310     {<span class="stringliteral">"write-only"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"write-only"</span>) - 1, WRITEONLY}
00311     ,
00312     {<span class="stringliteral">"NsapAddress"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NsapAddress"</span>) - 1, NSAPADDRESS}
00313     ,
00314     {<span class="stringliteral">"UNITS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Units"</span>) - 1, UNITS}
00315     ,
00316     {<span class="stringliteral">"REFERENCE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"REFERENCE"</span>) - 1, REFERENCE}
00317     ,
00318     {<span class="stringliteral">"NUM-ENTRIES"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NUM-ENTRIES"</span>) - 1, NUM_ENTRIES}
00319     ,
00320     {<span class="stringliteral">"BITSTRING"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"BITSTRING"</span>) - 1, BITSTRING}
00321     ,
00322     {<span class="stringliteral">"BIT"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"BIT"</span>) - 1, CONTINUE}
00323     ,
00324     {<span class="stringliteral">"BITS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"BITS"</span>) - 1, BITSTRING}
00325     ,
00326     {<span class="stringliteral">"Counter64"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Counter64"</span>) - 1, COUNTER64}
00327     ,
00328     {<span class="stringliteral">"TimeTicks"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"TimeTicks"</span>) - 1, TIMETICKS}
00329     ,
00330     {<span class="stringliteral">"NOTIFICATION-TYPE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NOTIFICATION-TYPE"</span>) - 1, NOTIFTYPE}
00331     ,
00332     {<span class="stringliteral">"OBJECT-GROUP"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OBJECT-GROUP"</span>) - 1, OBJGROUP}
00333     ,
00334     {<span class="stringliteral">"OBJECT-IDENTITY"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OBJECT-IDENTITY"</span>) - 1, OBJGROUP}
00335     ,
00336     {<span class="stringliteral">"IDENTIFIER"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"IDENTIFIER"</span>) - 1, IDENTIFIER}
00337     ,
00338     {<span class="stringliteral">"OBJECT"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OBJECT"</span>) - 1, OBJECT}
00339     ,
00340     {<span class="stringliteral">"NetworkAddress"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NetworkAddress"</span>) - 1, NETADDR}
00341     ,
00342     {<span class="stringliteral">"Gauge"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Gauge"</span>) - 1, GAUGE}
00343     ,
00344     {<span class="stringliteral">"Gauge32"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Gauge32"</span>) - 1, GAUGE}
00345     ,
00346     {<span class="stringliteral">"Unsigned32"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Unsigned32"</span>) - 1, UNSIGNED32}
00347     ,
00348     {<span class="stringliteral">"read-write"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"read-write"</span>) - 1, READWRITE}
00349     ,
00350     {<span class="stringliteral">"read-create"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"read-create"</span>) - 1, READCREATE}
00351     ,
00352     {<span class="stringliteral">"OCTETSTRING"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OCTETSTRING"</span>) - 1, OCTETSTR}
00353     ,
00354     {<span class="stringliteral">"OCTET"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OCTET"</span>) - 1, CONTINUE}
00355     ,
00356     {<span class="stringliteral">"OF"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OF"</span>) - 1, OF}
00357     ,
00358     {<span class="stringliteral">"SEQUENCE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"SEQUENCE"</span>) - 1, SEQUENCE}
00359     ,
00360     {<span class="stringliteral">"NULL"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NULL"</span>) - 1, NUL}
00361     ,
00362     {<span class="stringliteral">"IpAddress"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"IpAddress"</span>) - 1, IPADDR}
00363     ,
00364     {<span class="stringliteral">"UInteger32"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"UInteger32"</span>) - 1, UINTEGER32}
00365     ,
00366     {<span class="stringliteral">"INTEGER"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"INTEGER"</span>) - 1, INTEGER}
00367     ,
00368     {<span class="stringliteral">"Integer32"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Integer32"</span>) - 1, INTEGER32}
00369     ,
00370     {<span class="stringliteral">"Counter"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Counter"</span>) - 1, COUNTER}
00371     ,
00372     {<span class="stringliteral">"Counter32"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"Counter32"</span>) - 1, COUNTER}
00373     ,
00374     {<span class="stringliteral">"read-only"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"read-only"</span>) - 1, READONLY}
00375     ,
00376     {<span class="stringliteral">"DESCRIPTION"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"DESCRIPTION"</span>) - 1, DESCRIPTION}
00377     ,
00378     {<span class="stringliteral">"INDEX"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"INDEX"</span>) - 1, INDEX}
00379     ,
00380     {<span class="stringliteral">"DEFVAL"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"DEFVAL"</span>) - 1, DEFVAL}
00381     ,
00382     {<span class="stringliteral">"deprecated"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"deprecated"</span>) - 1, DEPRECATED}
00383     ,
00384     {<span class="stringliteral">"SIZE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"SIZE"</span>) - 1, SIZE}
00385     ,
00386     {<span class="stringliteral">"MAX-ACCESS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MAX-ACCESS"</span>) - 1, ACCESS}
00387     ,
00388     {<span class="stringliteral">"ACCESS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"ACCESS"</span>) - 1, ACCESS}
00389     ,
00390     {<span class="stringliteral">"mandatory"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"mandatory"</span>) - 1, MANDATORY}
00391     ,
00392     {<span class="stringliteral">"current"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"current"</span>) - 1, CURRENT}
00393     ,
00394     {<span class="stringliteral">"STATUS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"STATUS"</span>) - 1, STATUS}
00395     ,
00396     {<span class="stringliteral">"SYNTAX"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"SYNTAX"</span>) - 1, SYNTAX}
00397     ,
00398     {<span class="stringliteral">"OBJECT-TYPE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OBJECT-TYPE"</span>) - 1, OBJTYPE}
00399     ,
00400     {<span class="stringliteral">"TRAP-TYPE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"TRAP-TYPE"</span>) - 1, TRAPTYPE}
00401     ,
00402     {<span class="stringliteral">"ENTERPRISE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"ENTERPRISE"</span>) - 1, ENTERPRISE}
00403     ,
00404     {<span class="stringliteral">"BEGIN"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"BEGIN"</span>) - 1, BEGIN}
00405     ,
00406     {<span class="stringliteral">"IMPORTS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"IMPORTS"</span>) - 1, IMPORTS}
00407     ,
00408     {<span class="stringliteral">"EXPORTS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"EXPORTS"</span>) - 1, EXPORTS}
00409     ,
00410     {<span class="stringliteral">"accessible-for-notify"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"accessible-for-notify"</span>) - 1,
00411      ACCNOTIFY}
00412     ,
00413     {<span class="stringliteral">"TEXTUAL-CONVENTION"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"TEXTUAL-CONVENTION"</span>) - 1, CONVENTION}
00414     ,
00415     {<span class="stringliteral">"NOTIFICATION-GROUP"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NOTIFICATION-GROUP"</span>) - 1, NOTIFGROUP}
00416     ,
00417     {<span class="stringliteral">"DISPLAY-HINT"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"DISPLAY-HINT"</span>) - 1, DISPLAYHINT}
00418     ,
00419     {<span class="stringliteral">"FROM"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"FROM"</span>) - 1, FROM}
00420     ,
00421     {<span class="stringliteral">"AGENT-CAPABILITIES"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"AGENT-CAPABILITIES"</span>) - 1, AGENTCAP}
00422     ,
00423     {<span class="stringliteral">"MACRO"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MACRO"</span>) - 1, MACRO}
00424     ,
00425     {<span class="stringliteral">"IMPLIED"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"IMPLIED"</span>) - 1, IMPLIED}
00426     ,
00427     {<span class="stringliteral">"SUPPORTS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"SUPPORTS"</span>) - 1, SUPPORTS}
00428     ,
00429     {<span class="stringliteral">"INCLUDES"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"INCLUDES"</span>) - 1, INCLUDES}
00430     ,
00431     {<span class="stringliteral">"VARIATION"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"VARIATION"</span>) - 1, VARIATION}
00432     ,
00433     {<span class="stringliteral">"REVISION"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"REVISION"</span>) - 1, REVISION}
00434     ,
00435     {<span class="stringliteral">"not-implemented"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"not-implemented"</span>) - 1, NOTIMPL}
00436     ,
00437     {<span class="stringliteral">"OBJECTS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"OBJECTS"</span>) - 1, OBJECTS}
00438     ,
00439     {<span class="stringliteral">"NOTIFICATIONS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NOTIFICATIONS"</span>) - 1, NOTIFICATIONS}
00440     ,
00441     {<span class="stringliteral">"MODULE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MODULE"</span>) - 1, MODULE}
00442     ,
00443     {<span class="stringliteral">"MIN-ACCESS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MIN-ACCESS"</span>) - 1, MINACCESS}
00444     ,
00445     {<span class="stringliteral">"PRODUCT-RELEASE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"PRODUCT-RELEASE"</span>) - 1, PRODREL}
00446     ,
00447     {<span class="stringliteral">"WRITE-SYNTAX"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"WRITE-SYNTAX"</span>) - 1, WRSYNTAX}
00448     ,
00449     {<span class="stringliteral">"CREATION-REQUIRES"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"CREATION-REQUIRES"</span>) - 1, CREATEREQ}
00450     ,
00451     {<span class="stringliteral">"MANDATORY-GROUPS"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"MANDATORY-GROUPS"</span>) - 1, MANDATORYGROUPS}
00452     ,
00453     {<span class="stringliteral">"GROUP"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"GROUP"</span>) - 1, GROUP}
00454     ,
00455     {<span class="stringliteral">"CHOICE"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"CHOICE"</span>) - 1, CHOICE}
00456     ,
00457     {<span class="stringliteral">"IMPLICIT"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"IMPLICIT"</span>) - 1, IMPLICIT}
00458     ,
00459     {<span class="stringliteral">"ObjectSyntax"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"ObjectSyntax"</span>) - 1, OBJSYNTAX}
00460     ,
00461     {<span class="stringliteral">"SimpleSyntax"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"SimpleSyntax"</span>) - 1, SIMPLESYNTAX}
00462     ,
00463     {<span class="stringliteral">"ApplicationSyntax"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"ApplicationSyntax"</span>) - 1, APPSYNTAX}
00464     ,
00465     {<span class="stringliteral">"ObjectName"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"ObjectName"</span>) - 1, OBJNAME}
00466     ,
00467     {<span class="stringliteral">"NotificationName"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"NotificationName"</span>) - 1, NOTIFNAME}
00468     ,
00469     {<span class="stringliteral">"VARIABLES"</span>, <span class="keyword">sizeof</span>(<span class=
"stringliteral">"VARIABLES"</span>) - 1, VARIABLES}
00470     ,
00471     {NULL}
00472 };
00473 
00474 <span class="keyword">static</span> <span class="keyword">struct </span>module_compatability *module_map_head;
00475 <span class="keyword">static</span> <span class="keyword">struct </span>module_compatability module_map[] = {
00476     {<span class="stringliteral">"RFC1065-SMI"</span>, <span class="stringliteral">"RFC1155-SMI"</span>, NULL, 0},
00477     {<span class="stringliteral">"RFC1066-MIB"</span>, <span class="stringliteral">"RFC1156-MIB"</span>, NULL, 0},
00478     <span class="comment">/*</span>
00479 <span class="comment">     * 'mib' -&gt; 'mib-2' </span>
00480 <span class="comment">     */</span>
00481     {<span class="stringliteral">"RFC1156-MIB"</span>, <span class="stringliteral">"RFC1158-MIB"</span>, NULL, 0},
00482     <span class="comment">/*</span>
00483 <span class="comment">     * 'snmpEnableAuthTraps' -&gt; 'snmpEnableAuthenTraps' </span>
00484 <span class="comment">     */</span>
00485     {<span class="stringliteral">"RFC1158-MIB"</span>, <span class="stringliteral">"RFC1213-MIB"</span>, NULL, 0},
00486     <span class="comment">/*</span>
00487 <span class="comment">     * 'nullOID' -&gt; 'zeroDotZero' </span>
00488 <span class="comment">     */</span>
00489     {<span class="stringliteral">"RFC1155-SMI"</span>, <span class="stringliteral">"SNMPv2-SMI"</span>, NULL, 0},
00490     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"SNMPv2-SMI"</span>, <span class=
"stringliteral">"mib-2"</span>, 0},
00491     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"SNMPv2-MIB"</span>, <span class=
"stringliteral">"sys"</span>, 3},
00492     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"IF-MIB"</span>, <span class=
"stringliteral">"if"</span>, 2},
00493     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"IP-MIB"</span>, <span class=
"stringliteral">"ip"</span>, 2},
00494     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"IP-MIB"</span>, <span class=
"stringliteral">"icmp"</span>, 4},
00495     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"TCP-MIB"</span>, <span class=
"stringliteral">"tcp"</span>, 3},
00496     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"UDP-MIB"</span>, <span class=
"stringliteral">"udp"</span>, 3},
00497     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"SNMPv2-SMI"</span>, <span class=
"stringliteral">"transmission"</span>, 0},
00498     {<span class="stringliteral">"RFC1213-MIB"</span>, <span class="stringliteral">"SNMPv2-MIB"</span>, <span class=
"stringliteral">"snmp"</span>, 4},
00499     {<span class="stringliteral">"RFC1231-MIB"</span>, <span class="stringliteral">"TOKENRING-MIB"</span>, NULL, 0},
00500     {<span class="stringliteral">"RFC1271-MIB"</span>, <span class="stringliteral">"RMON-MIB"</span>, NULL, 0},
00501     {<span class="stringliteral">"RFC1286-MIB"</span>, <span class=
"stringliteral">"SOURCE-ROUTING-MIB"</span>, <span class="stringliteral">"dot1dSr"</span>, 7},
00502     {<span class="stringliteral">"RFC1286-MIB"</span>, <span class="stringliteral">"BRIDGE-MIB"</span>, NULL, 0},
00503     {<span class="stringliteral">"RFC1315-MIB"</span>, <span class="stringliteral">"FRAME-RELAY-DTE-MIB"</span>, NULL, 0},
00504     {<span class="stringliteral">"RFC1316-MIB"</span>, <span class="stringliteral">"CHARACTER-MIB"</span>, NULL, 0},
00505     {<span class="stringliteral">"RFC1406-MIB"</span>, <span class="stringliteral">"DS1-MIB"</span>, NULL, 0},
00506     {<span class="stringliteral">"RFC-1213"</span>, <span class="stringliteral">"RFC1213-MIB"</span>, NULL, 0},
00507 };
00508 
00509 <span class="preprocessor">#define MODULE_NOT_FOUND        0</span>
00510 <span class="preprocessor">#define MODULE_LOADED_OK        1</span>
00511 <span class="preprocessor">#define MODULE_ALREADY_LOADED   2</span>
00512 <span class="comment">/*</span>
00513 <span class="comment"> * #define MODULE_LOAD_FAILED   3       </span>
00514 <span class="comment"> */</span>
00515 <span class="preprocessor">#define MODULE_LOAD_FAILED      MODULE_NOT_FOUND</span>
00516 
00517 
00518 <span class="preprocessor">#define HASHSIZE        32</span>
00519 <span class="preprocessor">#define BUCKET(x)       (x &amp; (HASHSIZE-1))</span>
00520 
00521 <span class="preprocessor">#define NHASHSIZE    128</span>
00522 <span class="preprocessor">#define NBUCKET(x)   (x &amp; (NHASHSIZE-1))</span>
00523 
00524 <span class="keyword">static</span> <span class="keyword">struct </span>tok *buckets[HASHSIZE];
00525 
00526 <span class="keyword">static</span> <span class="keyword">struct </span>node *nbuckets[NHASHSIZE];
00527 <span class="keyword">static</span> <span class="keyword">struct </span>tree *tbuckets[NHASHSIZE];
00528 <span class="keyword">static</span> <span class="keyword">struct </span>module *module_head = NULL;
00529 
00530 <span class="keyword">struct </span>node    *orphan_nodes = NULL;
00531 <span class="keyword">struct </span>tree    *tree_head = NULL;
00532 
00533 <span class="preprocessor">#define NUMBER_OF_ROOT_NODES    3</span>
00534 <span class="keyword">static</span> <span class="keyword">struct </span>module_import root_imports[NUMBER_OF_ROOT_NODES];
00535 
00536 <span class="keyword">static</span> <span class="keywordtype">int</span>      current_module = 0;
00537 <span class="keyword">static</span> <span class="keywordtype">int</span>      max_module = 0;
00538 <span class="keyword">static</span> <span class="keywordtype">char</span>    *last_err_module = 0;    <span class=
"comment">/* no repeats on "Cannot find module..." */</span>
00539 
00540 <span class="keyword">static</span> <span class="keywordtype">void</span>     tree_from_node(<span class=
"keyword">struct</span> tree *tp, <span class="keyword">struct</span> node *np);
00541 <span class="keyword">static</span> <span class="keywordtype">void</span>     do_subtree(<span class=
"keyword">struct</span> tree *, <span class="keyword">struct</span> node **);
00542 <span class="keyword">static</span> <span class="keywordtype">void</span>     do_linkup(<span class=
"keyword">struct</span> module *, <span class="keyword">struct</span> node *);
00543 <span class="keyword">static</span> <span class="keywordtype">void</span>     dump_module_list(<span class=
"keywordtype">void</span>);
00544 <span class="keyword">static</span> <span class="keywordtype">int</span>      get_token(FILE *, <span class=
"keywordtype">char</span> *, <span class="keywordtype">int</span>);
00545 <span class="keyword">static</span> <span class="keywordtype">int</span>      parseQuoteString(FILE *, <span class=
"keywordtype">char</span> *, <span class="keywordtype">int</span>);
00546 <span class="keyword">static</span> <span class="keywordtype">int</span>      tossObjectIdentifier(FILE *);
00547 <span class="keyword">static</span> <span class="keywordtype">int</span>      name_hash(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *);
00548 <span class="keyword">static</span> <span class="keywordtype">void</span>     init_node_hash(<span class=
"keyword">struct</span> node *);
00549 <span class="keyword">static</span> <span class="keywordtype">void</span>     print_error(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *, <span class="keywordtype">int</span>);
00550 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_tree(<span class=
"keyword">struct</span> tree *);
00551 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_partial_tree(<span class=
"keyword">struct</span> tree *, <span class="keywordtype">int</span>);
00552 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_node(<span class=
"keyword">struct</span> node *);
00553 <span class="keyword">static</span> <span class="keywordtype">void</span>     build_translation_table(<span class=
"keywordtype">void</span>);
00554 <span class="keyword">static</span> <span class="keywordtype">void</span>     init_tree_roots(<span class=
"keywordtype">void</span>);
00555 <span class="keyword">static</span> <span class="keywordtype">void</span>     merge_anon_children(<span class=
"keyword">struct</span> tree *, <span class="keyword">struct</span> tree *);
00556 <span class="keyword">static</span> <span class="keywordtype">void</span>     unlink_tbucket(<span class=
"keyword">struct</span> tree *);
00557 <span class="keyword">static</span> <span class="keywordtype">void</span>     unlink_tree(<span class=
"keyword">struct</span> tree *);
00558 <span class="keyword">static</span> <span class="keywordtype">int</span>      getoid(FILE *, <span class=
"keyword">struct</span> subid_s *, <span class="keywordtype">int</span>);
00559 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_objectid(FILE *, <span class=
"keywordtype">char</span> *);
00560 <span class="keyword">static</span> <span class="keywordtype">int</span>      get_tc(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>, <span class=
"keywordtype">int</span> *, <span class="keyword">struct</span> enum_list **,
00561                        <span class="keyword">struct</span> range_list **, <span class="keywordtype">char</span> **);
00562 <span class="keyword">static</span> <span class="keywordtype">int</span>      get_tc_index(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>);
00563 <span class="keyword">static</span> <span class="keyword">struct </span>enum_list *parse_enumlist(FILE *, <span class=
"keyword">struct</span> enum_list **);
00564 <span class="keyword">static</span> <span class="keyword">struct </span>range_list *parse_ranges(FILE * fp, <span class=
"keyword">struct</span> range_list **);
00565 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_asntype(FILE *, <span class=
"keywordtype">char</span> *, <span class="keywordtype">int</span> *, <span class="keywordtype">char</span> *);
00566 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_objecttype(FILE *, <span class=
"keywordtype">char</span> *);
00567 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_objectgroup(FILE *, <span class=
"keywordtype">char</span> *, <span class="keywordtype">int</span>,
00568                                       <span class="keyword">struct</span> objgroup **);
00569 <span class="keyword">static</span> <span class=
"keyword">struct </span>node *parse_notificationDefinition(FILE *, <span class="keywordtype">char</span> *);
00570 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_trapDefinition(FILE *, <span class=
"keywordtype">char</span> *);
00571 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_compliance(FILE *, <span class=
"keywordtype">char</span> *);
00572 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_capabilities(FILE *, <span class=
"keywordtype">char</span> *);
00573 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_moduleIdentity(FILE *, <span class=
"keywordtype">char</span> *);
00574 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse_macro(FILE *, <span class=
"keywordtype">char</span> *);
00575 <span class="keyword">static</span> <span class="keywordtype">void</span>     parse_imports(FILE *);
00576 <span class="keyword">static</span> <span class="keyword">struct </span>node *parse(FILE *, <span class=
"keyword">struct</span> node *);
00577 
00578 <span class="keyword">static</span> <span class="keywordtype">int</span>     read_module_internal(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *);
00579 <span class="keyword">static</span> <span class="keywordtype">int</span>     read_module_replacements(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *);
00580 <span class="keyword">static</span> <span class="keywordtype">int</span>     read_import_replacements(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *,
00581                                          <span class="keyword">struct</span> module_import *);
00582 
00583 <span class="keyword">static</span> <span class="keywordtype">void</span>     new_module(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *);
00584 
00585 <span class="keyword">static</span> <span class="keyword">struct </span>node *merge_parse_objectid(<span class=
"keyword">struct</span> node *, FILE *, <span class="keywordtype">char</span> *);
00586 <span class="keyword">static</span> <span class="keyword">struct </span>index_list *getIndexes(FILE * fp, <span class=
"keyword">struct</span> index_list **);
00587 <span class="keyword">static</span> <span class="keyword">struct </span>varbind_list *getVarbinds(FILE * fp, <span class=
"keyword">struct</span> varbind_list **);
00588 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_indexes(<span class=
"keyword">struct</span> index_list **);
00589 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_varbinds(<span class=
"keyword">struct</span> varbind_list **);
00590 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_ranges(<span class=
"keyword">struct</span> range_list **);
00591 <span class="keyword">static</span> <span class="keywordtype">void</span>     free_enums(<span class=
"keyword">struct</span> enum_list **);
00592 <span class="keyword">static</span> <span class="keyword">struct </span>range_list *copy_ranges(<span class=
"keyword">struct</span> range_list *);
00593 <span class="keyword">static</span> <span class="keyword">struct </span>enum_list *copy_enums(<span class=
"keyword">struct</span> enum_list *);
00594 
00595 <span class="keyword">static</span> u_int    compute_match(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *search_base, <span class="keyword">const</span> <span class="keywordtype">char</span> *key);
00596 
00597 <span class="keywordtype">void</span>
00598 snmp_mib_toggle_options_usage(<span class="keyword">const</span> <span class="keywordtype">char</span> *lead, FILE * outf)
00599 {
00600     fprintf(outf, <span class="stringliteral">"%su:  %sallow the use of underlines in MIB symbols\n"</span>,
00601             lead, ((netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
00602                                            NETSNMP_DS_LIB_MIB_PARSE_LABEL)) ?
00603                    <span class="stringliteral">"dis"</span> : <span class="stringliteral">""</span>));
00604     fprintf(outf, <span class="stringliteral">"%sc:  %sallow the use of \"--\" to terminate comments\n"</span>,
00605             lead, ((netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
00606                                            NETSNMP_DS_LIB_MIB_COMMENT_TERM)) ?
00607                    <span class="stringliteral">""</span> : <span class="stringliteral">"dis"</span>));
00608 
00609     fprintf(outf, <span class="stringliteral">"%sd:  %ssave the DESCRIPTIONs of the MIB objects\n"</span>,
00610             lead, ((netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
00611                                            NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) ?
00612                    <span class="stringliteral">"do not "</span> : <span class="stringliteral">""</span>));
00613 
00614     fprintf(outf, <span class="stringliteral">"%se:  disable errors when MIB symbols conflict\n"</span>, lead);
00615 
00616     fprintf(outf, <span class="stringliteral">"%sw:  enable warnings when MIB symbols conflict\n"</span>, lead);
00617 
00618     fprintf(outf, <span class="stringliteral">"%sW:  enable detailed warnings when MIB symbols conflict\n"</span>,
00619             lead);
00620 
00621     fprintf(outf, <span class="stringliteral">"%sR:  replace MIB symbols from latest module\n"</span>, lead);
00622 }
00623 
00624 <span class="keywordtype">char</span>           *
00625 snmp_mib_toggle_options(<span class="keywordtype">char</span> *options)
00626 {
00627     <span class="keywordflow">if</span> (options) {
00628         <span class="keywordflow">while</span> (*options) {
00629             <span class="keywordflow">switch</span> (*options) {
00630             <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
00631                 <a class="code" href=
"group__default__store.html#ga8">netsnmp_ds_set_boolean</a>(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_PARSE_LABEL,
00632                                !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
00633                                                NETSNMP_DS_LIB_MIB_PARSE_LABEL));
00634                 <span class="keywordflow">break</span>;
00635 
00636             <span class="keywordflow">case</span> <span class="charliteral">'c'</span>:
00637                 netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID,
00638                                           NETSNMP_DS_LIB_MIB_COMMENT_TERM);
00639                 <span class="keywordflow">break</span>;
00640 
00641             <span class="keywordflow">case</span> <span class="charliteral">'e'</span>:
00642                 netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID,
00643                                           NETSNMP_DS_LIB_MIB_ERRORS);
00644                 <span class="keywordflow">break</span>;
00645 
00646             <span class="keywordflow">case</span> <span class="charliteral">'w'</span>:
00647                 netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,
00648                                    NETSNMP_DS_LIB_MIB_WARNINGS, 1);
00649                 <span class="keywordflow">break</span>;
00650 
00651             <span class="keywordflow">case</span> <span class="charliteral">'W'</span>:
00652                 netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,
00653                                    NETSNMP_DS_LIB_MIB_WARNINGS, 2);
00654                 <span class="keywordflow">break</span>;
00655 
00656             <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
00657                 netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, 
00658                                           NETSNMP_DS_LIB_SAVE_MIB_DESCRS);
00659                 <span class="keywordflow">break</span>;
00660 
00661             <span class="keywordflow">case</span> <span class="charliteral">'R'</span>:
00662                 netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, 
00663                                           NETSNMP_DS_LIB_MIB_REPLACE);
00664                 <span class="keywordflow">break</span>;
00665 
00666             <span class="keywordflow">default</span>:
00667                 <span class="comment">/*</span>
00668 <span class="comment">                 * return at the unknown option </span>
00669 <span class="comment">                 */</span>
00670                 <span class="keywordflow">return</span> options;
00671             }
00672             options++;
00673         }
00674     }
00675     <span class="keywordflow">return</span> NULL;
00676 }
00677 
00678 <span class="keyword">static</span> <span class="keywordtype">int</span>
00679 name_hash(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00680 {
00681     <span class="keywordtype">int</span>             hash = 0;
00682     <span class="keyword">const</span> <span class="keywordtype">char</span>     *cp;
00683 
00684     <span class="keywordflow">if</span> (!name)
00685         <span class="keywordflow">return</span> 0;
00686     <span class="keywordflow">for</span> (cp = name; *cp; cp++)
00687         hash += tolower(*cp);
00688     <span class="keywordflow">return</span> (hash);
00689 }
00690 
00691 <span class="keywordtype">void</span>
00692 init_mib_internals(<span class="keywordtype">void</span>)
00693 {
00694     <span class="keyword">register</span> <span class="keyword">struct </span>tok *tp;
00695     <span class="keyword">register</span> <span class="keywordtype">int</span>    b, i;
00696     <span class="keywordtype">int</span>             max_modc;
00697 
00698     <span class="keywordflow">if</span> (tree_head)
00699         <span class="keywordflow">return</span>;
00700 
00701     <span class="comment">/*</span>
00702 <span class="comment">     * Set up hash list of pre-defined tokens</span>
00703 <span class="comment">     */</span>
00704     memset(buckets, 0, <span class="keyword">sizeof</span>(buckets));
00705     <span class="keywordflow">for</span> (tp = tokens; tp-&gt;name; tp++) {
00706         tp-&gt;hash = name_hash(tp-&gt;name);
00707         b = BUCKET(tp-&gt;hash);
00708         <span class="keywordflow">if</span> (buckets[b])
00709             tp-&gt;next = buckets[b];      <span class="comment">/* BUG ??? */</span>
00710         buckets[b] = tp;
00711     }
00712 
00713     <span class="comment">/*</span>
00714 <span class="comment">     * Initialise other internal structures</span>
00715 <span class="comment">     */</span>
00716 
00717     max_modc = <span class="keyword">sizeof</span>(module_map) / <span class="keyword">sizeof</span>(module_map[0]) - 1;
00718     <span class="keywordflow">for</span> (i = 0; i &lt; max_modc; ++i)
00719         module_map[i].next = &amp;(module_map[i + 1]);
00720     module_map[max_modc].next = NULL;
00721     module_map_head = module_map;
00722 
00723     memset(nbuckets, 0, <span class="keyword">sizeof</span>(nbuckets));
00724     memset(tbuckets, 0, <span class="keyword">sizeof</span>(tbuckets));
00725     memset(tclist, 0, MAXTC * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tc));
00726     build_translation_table();
00727     init_tree_roots();          <span class="comment">/* Set up initial roots */</span>
00728     <span class="comment">/*</span>
00729 <span class="comment">     * Relies on 'add_mibdir' having set up the modules </span>
00730 <span class="comment">     */</span>
00731 }
00732 
00733 <span class="keyword">static</span> <span class="keywordtype">void</span>
00734 init_node_hash(<span class="keyword">struct</span> node *nodes)
00735 {
00736     <span class="keyword">struct </span>node    *np, *nextp;
00737     <span class="keywordtype">int</span>             hash;
00738 
00739     memset(nbuckets, 0, <span class="keyword">sizeof</span>(nbuckets));
00740     <span class="keywordflow">for</span> (np = nodes; np;) {
00741         nextp = np-&gt;next;
00742         hash = NBUCKET(name_hash(np-&gt;parent));
00743         np-&gt;next = nbuckets[hash];
00744         nbuckets[hash] = np;
00745         np = nextp;
00746     }
00747 }
00748 
00749 <span class="keyword">static</span> <span class="keywordtype">int</span>      erroneousMibs = 0;
00750 
00751 <span class="keywordtype">int</span>
00752 get_mib_parse_error_count(<span class="keywordtype">void</span>)
00753 {
00754     <span class="keywordflow">return</span> erroneousMibs;
00755 }
00756 
00757 
00758 <span class="keyword">static</span> <span class="keywordtype">void</span>
00759 print_error(<span class="keyword">const</span> <span class="keywordtype">char</span> *string, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *token, <span class="keywordtype">int</span> type)
00760 {
00761     erroneousMibs++;
00762     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class="stringliteral">"\n"</span>));
00763     <span class="keywordflow">if</span> (type == ENDOFFILE)
00764         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"%s (EOF): At line %d in %s\n"</span>, string, mibLine,
00765                  File);
00766     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token &amp;&amp; *token)
00767         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"%s (%s): At line %d in %s\n"</span>, string, token,
00768                  mibLine, File);
00769     <span class="keywordflow">else</span>
00770         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"%s: At line %d in %s\n"</span>, string, mibLine, File);
00771 }
00772 
00773 <span class="keyword">static</span> <span class="keywordtype">void</span>
00774 print_module_not_found(<span class="keyword">const</span> <span class="keywordtype">char</span> *cp)
00775 {
00776     <span class="keywordflow">if</span> (!last_err_module || strcmp(cp, last_err_module))
00777         print_error(<span class="stringliteral">"Cannot find module"</span>, cp, CONTINUE);
00778     <span class="keywordflow">if</span> (last_err_module)
00779         free(last_err_module);
00780     last_err_module = strdup(cp);
00781 }
00782 
00783 <span class="keyword">static</span> <span class="keyword">struct </span>node *
00784 alloc_node(<span class="keywordtype">int</span> modid)
00785 {
00786     <span class="keyword">struct </span>node    *np;
00787     np = (<span class="keyword">struct </span>node *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> node));
00788     <span class="keywordflow">if</span> (np) {
00789         np-&gt;tc_index = -1;
00790         np-&gt;modid = modid;
00791         np-&gt;filename = strdup(File);
00792         np-&gt;lineno = mibLine;
00793     }
00794     <span class="keywordflow">return</span> np;
00795 }
00796 
00797 <span class="keyword">static</span> <span class="keywordtype">void</span>
00798 unlink_tbucket(<span class="keyword">struct</span> tree *tp)
00799 {
00800     <span class="keywordtype">int</span>             hash = NBUCKET(name_hash(tp-&gt;label));
00801     <span class="keyword">struct </span>tree    *otp = NULL, *ntp = tbuckets[hash];
00802 
00803     <span class="keywordflow">while</span> (ntp &amp;&amp; ntp != tp) {
00804         otp = ntp;
00805         ntp = ntp-&gt;next;
00806     }
00807     <span class="keywordflow">if</span> (!ntp)
00808         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_EMERG, <span class=
"stringliteral">"Can't find %s in tbuckets\n"</span>, tp-&gt;label);
00809     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (otp)
00810         otp-&gt;next = ntp-&gt;next;
00811     <span class="keywordflow">else</span>
00812         tbuckets[hash] = tp-&gt;next;
00813 }
00814 
00815 <span class="keyword">static</span> <span class="keywordtype">void</span>
00816 unlink_tree(<span class="keyword">struct</span> tree *tp)
00817 {
00818     <span class="keyword">struct </span>tree    *otp = NULL, *ntp = tp-&gt;parent;
00819 
00820     <span class="keywordflow">if</span> (!ntp) {                 <span class="comment">/* this tree has no parent */</span>
00821         DEBUGMSGTL((<span class="stringliteral">"unlink_tree"</span>, <span class=
"stringliteral">"Tree node %s has no parent\n"</span>,
00822                     tp-&gt;label));
00823     } <span class="keywordflow">else</span> {
00824         ntp = ntp-&gt;child_list;
00825 
00826         <span class="keywordflow">while</span> (ntp &amp;&amp; ntp != tp) {
00827             otp = ntp;
00828             ntp = ntp-&gt;next_peer;
00829         }
00830         <span class="keywordflow">if</span> (!ntp)
00831             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_EMERG, <span class=
"stringliteral">"Can't find %s in %s's children\n"</span>,
00832                      tp-&gt;label, tp-&gt;parent-&gt;label);
00833         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (otp)
00834             otp-&gt;next_peer = ntp-&gt;next_peer;
00835         <span class="keywordflow">else</span>
00836             tp-&gt;parent-&gt;child_list = tp-&gt;next_peer;
00837     }
00838 
00839     <span class="keywordflow">if</span> (tree_head == tp)
00840         tree_head = tp-&gt;next_peer;
00841 }
00842 
00843 <span class="keyword">static</span> <span class="keywordtype">void</span>
00844 free_partial_tree(<span class="keyword">struct</span> tree *tp, <span class="keywordtype">int</span> keep_label)
00845 {
00846     <span class="keywordflow">if</span> (!tp)
00847         <span class="keywordflow">return</span>;
00848 
00849     <span class="comment">/*</span>
00850 <span class="comment">     * remove the data from this tree node </span>
00851 <span class="comment">     */</span>
00852     free_enums(&amp;tp-&gt;enums);
00853     free_ranges(&amp;tp-&gt;ranges);
00854     free_indexes(&amp;tp-&gt;indexes);
00855     free_varbinds(&amp;tp-&gt;varbinds);
00856     <span class="keywordflow">if</span> (!keep_label)
00857         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;label);
00858     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;hint);
00859     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;units);
00860     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;description);
00861     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;reference);
00862     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;augments);
00863     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(tp-&gt;defaultValue);
00864 }
00865 
00866 <span class="comment">/*</span>
00867 <span class="comment"> * free a tree node. Note: the node must already have been unlinked</span>
00868 <span class="comment"> * from the tree when calling this routine</span>
00869 <span class="comment"> */</span>
00870 <span class="keyword">static</span> <span class="keywordtype">void</span>
00871 free_tree(<span class="keyword">struct</span> tree *Tree)
00872 {
00873     <span class="keywordflow">if</span> (!Tree)
00874         <span class="keywordflow">return</span>;
00875 
00876     unlink_tbucket(Tree);
00877     free_partial_tree(Tree, FALSE);
00878     <span class="keywordflow">if</span> (Tree-&gt;number_modules &gt; 1)
00879         free((<span class="keywordtype">char</span> *) Tree-&gt;module_list);
00880     free((<span class="keywordtype">char</span> *) Tree);
00881 }
00882 
00883 <span class="keyword">static</span> <span class="keywordtype">void</span>
00884 free_node(<span class="keyword">struct</span> node *np)
00885 {
00886     <span class="keywordflow">if</span> (!np)
00887         <span class="keywordflow">return</span>;
00888 
00889     free_enums(&amp;np-&gt;enums);
00890     free_ranges(&amp;np-&gt;ranges);
00891     free_indexes(&amp;np-&gt;indexes);
00892     free_varbinds(&amp;np-&gt;varbinds);
00893     <span class="keywordflow">if</span> (np-&gt;label)
00894         free(np-&gt;label);
00895     <span class="keywordflow">if</span> (np-&gt;hint)
00896         free(np-&gt;hint);
00897     <span class="keywordflow">if</span> (np-&gt;units)
00898         free(np-&gt;units);
00899     <span class="keywordflow">if</span> (np-&gt;description)
00900         free(np-&gt;description);
00901     <span class="keywordflow">if</span> (np-&gt;reference)
00902         free(np-&gt;reference);
00903     <span class="keywordflow">if</span> (np-&gt;defaultValue)
00904         free(np-&gt;defaultValue);
00905     <span class="keywordflow">if</span> (np-&gt;parent)
00906         free(np-&gt;parent);
00907     <span class="keywordflow">if</span> (np-&gt;augments)
00908         free(np-&gt;augments);
00909     <span class="keywordflow">if</span> (np-&gt;filename)
00910         free(np-&gt;filename);
00911     free((<span class="keywordtype">char</span> *) np);
00912 }
00913 
00914 <span class="preprocessor">#ifdef TEST</span>
00915 <span class="keyword">static</span> <span class="keywordtype">void</span>
00916 print_nodes(FILE * fp, <span class="keyword">struct</span> node *root)
00917 {
00918     <span class="keyword">extern</span> <span class="keywordtype">void</span>     xmalloc_stats(FILE *);
00919     <span class="keyword">struct </span>enum_list *ep;
00920     <span class="keyword">struct </span>index_list *ip;
00921     <span class="keyword">struct </span>range_list *rp;
00922     <span class="keyword">struct </span>varbind_list *vp;
00923     <span class="keyword">struct </span>node    *np;
00924 
00925     <span class="keywordflow">for</span> (np = root; np; np = np-&gt;next) {
00926         fprintf(fp, <span class="stringliteral">"%s ::= { %s %ld } (%d)\n"</span>, np-&gt;label, np-&gt;parent,
00927                 np-&gt;subid, np-&gt;type);
00928         <span class="keywordflow">if</span> (np-&gt;tc_index &gt;= 0)
00929             fprintf(fp, <span class="stringliteral">"  TC = %s\n"</span>, tclist[np-&gt;tc_index].descriptor);
00930         <span class="keywordflow">if</span> (np-&gt;enums) {
00931             fprintf(fp, <span class="stringliteral">"  Enums: \n"</span>);
00932             <span class="keywordflow">for</span> (ep = np-&gt;enums; ep; ep = ep-&gt;next) {
00933                 fprintf(fp, <span class="stringliteral">"    %s(%d)\n"</span>, ep-&gt;label, ep-&gt;value);
00934             }
00935         }
00936         <span class="keywordflow">if</span> (np-&gt;ranges) {
00937             fprintf(fp, <span class="stringliteral">"  Ranges: \n"</span>);
00938             <span class="keywordflow">for</span> (rp = np-&gt;ranges; rp; rp = rp-&gt;next) {
00939                 fprintf(fp, <span class="stringliteral">"    %d..%d\n"</span>, rp-&gt;low, rp-&gt;high);
00940             }
00941         }
00942         <span class="keywordflow">if</span> (np-&gt;indexes) {
00943             fprintf(fp, <span class="stringliteral">"  Indexes: \n"</span>);
00944             <span class="keywordflow">for</span> (ip = np-&gt;indexes; ip; ip = ip-&gt;next) {
00945                 fprintf(fp, <span class="stringliteral">"    %s\n"</span>, ip-&gt;ilabel);
00946             }
00947         }
00948         <span class="keywordflow">if</span> (np-&gt;augments)
00949             fprintf(fp, <span class="stringliteral">"  Augments: %s\n"</span>, np-&gt;augments);
00950         <span class="keywordflow">if</span> (np-&gt;varbinds) {
00951             fprintf(fp, <span class="stringliteral">"  Varbinds: \n"</span>);
00952             <span class="keywordflow">for</span> (vp = np-&gt;varbinds; vp; vp = vp-&gt;next) {
00953                 fprintf(fp, <span class="stringliteral">"    %s\n"</span>, vp-&gt;vblabel);
00954             }
00955         }
00956         <span class="keywordflow">if</span> (np-&gt;hint)
00957             fprintf(fp, <span class="stringliteral">"  Hint: %s\n"</span>, np-&gt;hint);
00958         <span class="keywordflow">if</span> (np-&gt;units)
00959             fprintf(fp, <span class="stringliteral">"  Units: %s\n"</span>, np-&gt;units);
00960         <span class="keywordflow">if</span> (np-&gt;defaultValue)
00961             fprintf(fp, <span class="stringliteral">"  DefaultValue: %s\n"</span>, np-&gt;defaultValue);
00962     }
00963 }
00964 <span class="preprocessor">#endif</span>
00965 
00966 <span class="keywordtype">void</span>
00967 print_subtree(FILE * f, <span class="keyword">struct</span> tree *tree, <span class="keywordtype">int</span> count)
00968 {
00969     <span class="keyword">struct </span>tree    *tp;
00970     <span class="keywordtype">int</span>             i;
00971     <span class="keywordtype">char</span>            modbuf[256];
00972 
00973     <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
00974         fprintf(f, <span class="stringliteral">"  "</span>);
00975     fprintf(f, <span class="stringliteral">"Children of %s(%ld):\n"</span>, tree-&gt;label, tree-&gt;subid);
00976     count++;
00977     <span class="keywordflow">for</span> (tp = tree-&gt;child_list; tp; tp = tp-&gt;next_peer) {
00978         <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
00979             fprintf(f, <span class="stringliteral">"  "</span>);
00980         fprintf(f, <span class="stringliteral">"%s:%s(%ld) type=%d"</span>,
00981                 module_name(tp-&gt;module_list[0], modbuf),
00982                 tp-&gt;label, tp-&gt;subid, tp-&gt;type);
00983         <span class="keywordflow">if</span> (tp-&gt;tc_index != -1)
00984             fprintf(f, <span class="stringliteral">" tc=%d"</span>, tp-&gt;tc_index);
00985         <span class="keywordflow">if</span> (tp-&gt;hint)
00986             fprintf(f, <span class="stringliteral">" hint=%s"</span>, tp-&gt;hint);
00987         <span class="keywordflow">if</span> (tp-&gt;units)
00988             fprintf(f, <span class="stringliteral">" units=%s"</span>, tp-&gt;units);
00989         <span class="keywordflow">if</span> (tp-&gt;number_modules &gt; 1) {
00990             fprintf(f, <span class="stringliteral">" modules:"</span>);
00991             <span class="keywordflow">for</span> (i = 1; i &lt; tp-&gt;number_modules; i++)
00992                 fprintf(f, <span class="stringliteral">" %s"</span>, module_name(tp-&gt;module_list[i], modbuf));
00993         }
00994         fprintf(f, <span class="stringliteral">"\n"</span>);
00995     }
00996     <span class="keywordflow">for</span> (tp = tree-&gt;child_list; tp; tp = tp-&gt;next_peer) {
00997         <span class="keywordflow">if</span> (tp-&gt;child_list)
00998             print_subtree(f, tp, count);
00999     }
01000 }
01001 
01002 <span class="keywordtype">void</span>
01003 print_ascii_dump_tree(FILE * f, <span class="keyword">struct</span> tree *tree, <span class="keywordtype">int</span> count)
01004 {
01005     <span class="keyword">struct </span>tree    *tp;
01006 
01007     count++;
01008     <span class="keywordflow">for</span> (tp = tree-&gt;child_list; tp; tp = tp-&gt;next_peer) {
01009         fprintf(f, <span class="stringliteral">"%s OBJECT IDENTIFIER ::= { %s %ld }\n"</span>, tp-&gt;label,
01010                 tree-&gt;label, tp-&gt;subid);
01011     }
01012     <span class="keywordflow">for</span> (tp = tree-&gt;child_list; tp; tp = tp-&gt;next_peer) {
01013         <span class="keywordflow">if</span> (tp-&gt;child_list)
01014             print_ascii_dump_tree(f, tp, count);
01015     }
01016 }
01017 
01018 <span class="keyword">static</span> <span class="keywordtype">int</span>      translation_table[256];
01019 
01020 <span class="keyword">static</span> <span class="keywordtype">void</span>
01021 build_translation_table()
01022 {
01023     <span class="keywordtype">int</span>             count;
01024 
01025     <span class="keywordflow">for</span> (count = 0; count &lt; 256; count++) {
01026         <span class="keywordflow">switch</span> (count) {
01027         <span class="keywordflow">case</span> OBJID:
01028             translation_table[count] = TYPE_OBJID;
01029             <span class="keywordflow">break</span>;
01030         <span class="keywordflow">case</span> OCTETSTR:
01031             translation_table[count] = TYPE_OCTETSTR;
01032             <span class="keywordflow">break</span>;
01033         <span class="keywordflow">case</span> INTEGER:
01034             translation_table[count] = TYPE_INTEGER;
01035             <span class="keywordflow">break</span>;
01036         <span class="keywordflow">case</span> NETADDR:
01037             translation_table[count] = TYPE_NETADDR;
01038             <span class="keywordflow">break</span>;
01039         <span class="keywordflow">case</span> IPADDR:
01040             translation_table[count] = TYPE_IPADDR;
01041             <span class="keywordflow">break</span>;
01042         <span class="keywordflow">case</span> COUNTER:
01043             translation_table[count] = TYPE_COUNTER;
01044             <span class="keywordflow">break</span>;
01045         <span class="keywordflow">case</span> GAUGE:
01046             translation_table[count] = TYPE_GAUGE;
01047             <span class="keywordflow">break</span>;
01048         <span class="keywordflow">case</span> TIMETICKS:
01049             translation_table[count] = TYPE_TIMETICKS;
01050             <span class="keywordflow">break</span>;
01051         <span class="keywordflow">case</span> KW_OPAQUE:
01052             translation_table[count] = TYPE_OPAQUE;
01053             <span class="keywordflow">break</span>;
01054         <span class="keywordflow">case</span> NUL:
01055             translation_table[count] = TYPE_NULL;
01056             <span class="keywordflow">break</span>;
01057         <span class="keywordflow">case</span> COUNTER64:
01058             translation_table[count] = TYPE_COUNTER64;
01059             <span class="keywordflow">break</span>;
01060         <span class="keywordflow">case</span> BITSTRING:
01061             translation_table[count] = TYPE_BITSTRING;
01062             <span class="keywordflow">break</span>;
01063         <span class="keywordflow">case</span> NSAPADDRESS:
01064             translation_table[count] = TYPE_NSAPADDRESS;
01065             <span class="keywordflow">break</span>;
01066         <span class="keywordflow">case</span> INTEGER32:
01067             translation_table[count] = TYPE_INTEGER32;
01068             <span class="keywordflow">break</span>;
01069         <span class="keywordflow">case</span> UINTEGER32:
01070             translation_table[count] = TYPE_UINTEGER;
01071             <span class="keywordflow">break</span>;
01072         <span class="keywordflow">case</span> UNSIGNED32:
01073             translation_table[count] = TYPE_UNSIGNED32;
01074             <span class="keywordflow">break</span>;
01075         <span class="keywordflow">case</span> TRAPTYPE:
01076             translation_table[count] = TYPE_TRAPTYPE;
01077             <span class="keywordflow">break</span>;
01078         <span class="keywordflow">case</span> NOTIFTYPE:
01079             translation_table[count] = TYPE_NOTIFTYPE;
01080             <span class="keywordflow">break</span>;
01081         <span class="keywordflow">case</span> OBJGROUP:
01082             translation_table[count] = TYPE_OBJGROUP;
01083             <span class="keywordflow">break</span>;
01084         <span class="keywordflow">case</span> MODULEIDENTITY:
01085             translation_table[count] = TYPE_MODID;
01086             <span class="keywordflow">break</span>;
01087         <span class="keywordflow">case</span> AGENTCAP:
01088             translation_table[count] = TYPE_AGENTCAP;
01089             <span class="keywordflow">break</span>;
01090         <span class="keywordflow">case</span> COMPLIANCE:
01091             translation_table[count] = TYPE_MODCOMP;
01092             <span class="keywordflow">break</span>;
01093         <span class="keywordflow">default</span>:
01094             translation_table[count] = TYPE_OTHER;
01095             <span class="keywordflow">break</span>;
01096         }
01097     }
01098 }
01099 
01100 <span class="keyword">static</span> <span class="keywordtype">void</span>
01101 init_tree_roots()
01102 {
01103     <span class="keyword">struct </span>tree    *tp, *lasttp;
01104     <span class="keywordtype">int</span>             base_modid;
01105     <span class="keywordtype">int</span>             hash;
01106 
01107     base_modid = which_module(<span class="stringliteral">"SNMPv2-SMI"</span>);
01108     <span class="keywordflow">if</span> (base_modid == -1)
01109         base_modid = which_module(<span class="stringliteral">"RFC1155-SMI"</span>);
01110     <span class="keywordflow">if</span> (base_modid == -1)
01111         base_modid = which_module(<span class="stringliteral">"RFC1213-MIB"</span>);
01112 
01113     <span class="comment">/*</span>
01114 <span class="comment">     * build root node </span>
01115 <span class="comment">     */</span>
01116     tp = (<span class="keyword">struct </span>tree *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> tree));
01117     <span class="keywordflow">if</span> (tp == NULL)
01118         <span class="keywordflow">return</span>;
01119     tp-&gt;label = strdup(<span class="stringliteral">"joint-iso-ccitt"</span>);
01120     tp-&gt;modid = base_modid;
01121     tp-&gt;number_modules = 1;
01122     tp-&gt;module_list = &amp;(tp-&gt;modid);
01123     tp-&gt;subid = 2;
01124     tp-&gt;tc_index = -1;
01125     <a class="code" href="group__mib__utilities.html#ga60">set_function</a>(tp);           <span class=
"comment">/* from mib.c */</span>
01126     hash = NBUCKET(name_hash(tp-&gt;label));
01127     tp-&gt;next = tbuckets[hash];
01128     tbuckets[hash] = tp;
01129     lasttp = tp;
01130     root_imports[0].label = strdup(tp-&gt;label);
01131     root_imports[0].modid = base_modid;
01132 
01133     <span class="comment">/*</span>
01134 <span class="comment">     * build root node </span>
01135 <span class="comment">     */</span>
01136     tp = (<span class="keyword">struct </span>tree *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> tree));
01137     <span class="keywordflow">if</span> (tp == NULL)
01138         <span class="keywordflow">return</span>;
01139     tp-&gt;next_peer = lasttp;
01140     tp-&gt;label = strdup(<span class="stringliteral">"ccitt"</span>);
01141     tp-&gt;modid = base_modid;
01142     tp-&gt;number_modules = 1;
01143     tp-&gt;module_list = &amp;(tp-&gt;modid);
01144     tp-&gt;subid = 0;
01145     tp-&gt;tc_index = -1;
01146     <a class="code" href="group__mib__utilities.html#ga60">set_function</a>(tp);           <span class=
"comment">/* from mib.c */</span>
01147     hash = NBUCKET(name_hash(tp-&gt;label));
01148     tp-&gt;next = tbuckets[hash];
01149     tbuckets[hash] = tp;
01150     lasttp = tp;
01151     root_imports[1].label = strdup(tp-&gt;label);
01152     root_imports[1].modid = base_modid;
01153 
01154     <span class="comment">/*</span>
01155 <span class="comment">     * build root node </span>
01156 <span class="comment">     */</span>
01157     tp = (<span class="keyword">struct </span>tree *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> tree));
01158     <span class="keywordflow">if</span> (tp == NULL)
01159         <span class="keywordflow">return</span>;
01160     tp-&gt;next_peer = lasttp;
01161     tp-&gt;label = strdup(<span class="stringliteral">"iso"</span>);
01162     tp-&gt;modid = base_modid;
01163     tp-&gt;number_modules = 1;
01164     tp-&gt;module_list = &amp;(tp-&gt;modid);
01165     tp-&gt;subid = 1;
01166     tp-&gt;tc_index = -1;
01167     <a class="code" href="group__mib__utilities.html#ga60">set_function</a>(tp);           <span class=
"comment">/* from mib.c */</span>
01168     hash = NBUCKET(name_hash(tp-&gt;label));
01169     tp-&gt;next = tbuckets[hash];
01170     tbuckets[hash] = tp;
01171     lasttp = tp;
01172     root_imports[2].label = strdup(tp-&gt;label);
01173     root_imports[2].modid = base_modid;
01174 
01175     tree_head = tp;
01176 }
01177 
01178 <span class="preprocessor">#ifdef STRICT_MIB_PARSEING</span>
01179 <span class="preprocessor">#define label_compare   strcasecmp</span>
01180 <span class="preprocessor">#else</span>
01181 <span class="preprocessor">#define label_compare   strcmp</span>
01182 <span class="preprocessor">#endif</span>
01183 
01184 
01185 <span class="keyword">struct </span>tree    *
01186 find_tree_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class=
"keywordtype">int</span> modid)
01187 {
01188     <span class="keyword">struct </span>tree    *tp, *headtp;
01189     <span class="keywordtype">int</span>             count, *int_p;
01190 
01191     <span class="keywordflow">if</span> (!name || !*name)
01192         <span class="keywordflow">return</span> (NULL);
01193 
01194     headtp = tbuckets[NBUCKET(name_hash(name))];
01195     <span class="keywordflow">for</span> (tp = headtp; tp; tp = tp-&gt;next) {
01196         <span class="keywordflow">if</span> (tp-&gt;label &amp;&amp; !label_compare(tp-&gt;label, name)) {
01197 
01198             <span class="keywordflow">if</span> (modid == -1)    <span class="comment">/* Any module */</span>
01199                 <span class="keywordflow">return</span> (tp);
01200 
01201             <span class="keywordflow">for</span> (int_p = tp-&gt;module_list, count = 0;
01202                  count &lt; tp-&gt;number_modules; ++count, ++int_p)
01203                 <span class="keywordflow">if</span> (*int_p == modid)
01204                     <span class="keywordflow">return</span> (tp);
01205         }
01206     }
01207 
01208     <span class="keywordflow">return</span> (NULL);
01209 }
01210 
01211 <span class="comment">/*</span>
01212 <span class="comment"> * computes a value which represents how close name1 is to name2.</span>
01213 <span class="comment"> * * high scores mean a worse match.</span>
01214 <span class="comment"> * * (yes, the algorithm sucks!)</span>
01215 <span class="comment"> */</span>
01216 <span class="preprocessor">#define MAX_BAD 0xffffff</span>
01217 
01218 <span class="keyword">static</span>          u_int
01219 compute_match(<span class="keyword">const</span> <span class="keywordtype">char</span> *search_base, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *key)
01220 {
01221 <span class="preprocessor">#if defined(HAVE_REGEX_H) &amp;&amp; defined(HAVE_REGCOMP)</span>
01222     <span class="keywordtype">int</span>             rc;
01223     regex_t         parsetree;
01224     regmatch_t      pmatch;
01225     rc = regcomp(&amp;parsetree, key, REG_ICASE | REG_EXTENDED);
01226     <span class="keywordflow">if</span> (rc == 0)
01227         rc = regexec(&amp;parsetree, search_base, 1, &amp;pmatch, 0);
01228     regfree(&amp;parsetree);
01229     <span class="keywordflow">if</span> (rc == 0) {
01230         <span class="comment">/*</span>
01231 <span class="comment">         * found </span>
01232 <span class="comment">         */</span>
01233         <span class="keywordflow">return</span> pmatch.rm_so;
01234     }
01235 <span class="preprocessor">#else                           </span><span class=
"comment">/* use our own wildcard matcher */</span>
01236     <span class="comment">/*</span>
01237 <span class="comment">     * first find the longest matching substring (ick) </span>
01238 <span class="comment">     */</span>
01239     <span class="keywordtype">char</span>           *first = NULL, *result = NULL, *entry;
01240     <span class="keyword">const</span> <span class="keywordtype">char</span>     *position;
01241     <span class="keywordtype">char</span>           *newkey = strdup(key);
01242     <span class="keywordtype">char</span>           *st;
01243 
01244 
01245     entry = strtok_r(newkey, <span class="stringliteral">"*"</span>, &amp;st);
01246     position = search_base;
01247     <span class="keywordflow">while</span> (entry) {
01248         result = strcasestr(position, entry);
01249 
01250         <span class="keywordflow">if</span> (result == NULL) {
01251             free(newkey);
01252             <span class="keywordflow">return</span> MAX_BAD;
01253         }
01254 
01255         <span class="keywordflow">if</span> (first == NULL)
01256             first = result;
01257 
01258         position = result + strlen(entry);
01259         entry = strtok_r(NULL, <span class="stringliteral">"*"</span>, &amp;st);
01260     }
01261     free(newkey);
01262     <span class="keywordflow">if</span> (result)
01263         <span class="keywordflow">return</span> (first - search_base);
01264 <span class="preprocessor">#endif</span>
01265 
01266     <span class="comment">/*</span>
01267 <span class="comment">     * not found </span>
01268 <span class="comment">     */</span>
01269     <span class="keywordflow">return</span> MAX_BAD;
01270 }
01271 
01272 <span class="comment">/*</span>
01273 <span class="comment"> * Find the tree node that best matches the pattern string.</span>
01274 <span class="comment"> * Use the "reported" flag such that only one match</span>
01275 <span class="comment"> * is attempted for every node.</span>
01276 <span class="comment"> *</span>
01277 <span class="comment"> * Warning! This function may recurse.</span>
01278 <span class="comment"> *</span>
01279 <span class="comment"> * Caller _must_ invoke clear_tree_flags before first call</span>
01280 <span class="comment"> * to this function.  This function may be called multiple times</span>
01281 <span class="comment"> * to ensure that the entire tree is traversed.</span>
01282 <span class="comment"> */</span>
01283 
01284 <span class="keyword">struct </span>tree    *
01285 find_best_tree_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *pattrn, <span class=
"keyword">struct</span> tree *tree_top,
01286                     u_int * match)
01287 {
01288     <span class="keyword">struct </span>tree    *tp, *best_so_far = NULL, *retptr;
01289     u_int           old_match = MAX_BAD, new_match = MAX_BAD;
01290 
01291     <span class="keywordflow">if</span> (!pattrn || !*pattrn)
01292         <span class="keywordflow">return</span> (NULL);
01293 
01294     <span class="keywordflow">if</span> (!tree_top)
01295         tree_top = <a class="code" href="group__mib__utilities.html#ga45">get_tree_head</a>();
01296 
01297     <span class="keywordflow">for</span> (tp = tree_top; tp; tp = tp-&gt;next_peer) {
01298         <span class="keywordflow">if</span> (!tp-&gt;reported &amp;&amp; tp-&gt;label)
01299             new_match = compute_match(tp-&gt;label, pattrn);
01300         tp-&gt;reported = 1;
01301 
01302         <span class="keywordflow">if</span> (new_match &lt; old_match) {
01303             best_so_far = tp;
01304             old_match = new_match;
01305         }
01306         <span class="keywordflow">if</span> (new_match == 0)
01307             <span class="keywordflow">break</span>;              <span class=
"comment">/* this is the best result we can get */</span>
01308         <span class="keywordflow">if</span> (tp-&gt;child_list) {
01309             retptr =
01310                 find_best_tree_node(pattrn, tp-&gt;child_list, &amp;new_match);
01311             <span class="keywordflow">if</span> (new_match &lt; old_match) {
01312                 best_so_far = retptr;
01313                 old_match = new_match;
01314             }
01315             <span class="keywordflow">if</span> (new_match == 0)
01316                 <span class="keywordflow">break</span>;          <span class=
"comment">/* this is the best result we can get */</span>
01317         }
01318     }
01319     <span class="keywordflow">if</span> (match)
01320         *match = old_match;
01321     <span class="keywordflow">return</span> (best_so_far);
01322 }
01323 
01324 
01325 <span class="keyword">static</span> <span class="keywordtype">void</span>
01326 merge_anon_children(<span class="keyword">struct</span> tree *tp1, <span class="keyword">struct</span> tree *tp2)
01327                 <span class="comment">/*</span>
01328 <span class="comment">                 * NB: tp1 is the 'anonymous' node </span>
01329 <span class="comment">                 */</span>
01330 {
01331     <span class="keyword">struct </span>tree    *child1, *child2, *previous;
01332 
01333     <span class="keywordflow">for</span> (child1 = tp1-&gt;child_list; child1;) {
01334 
01335         <span class="keywordflow">for</span> (child2 = tp2-&gt;child_list, previous = NULL;
01336              child2; previous = child2, child2 = child2-&gt;next_peer) {
01337 
01338             <span class="keywordflow">if</span> (child1-&gt;subid == child2-&gt;subid) {
01339                 <span class="comment">/*</span>
01340 <span class="comment">                 * Found 'matching' children,</span>
01341 <span class="comment">                 *  so merge them</span>
01342 <span class="comment">                 */</span>
01343                 <span class="keywordflow">if</span> (!strncmp(child1-&gt;label, ANON, ANON_LEN)) {
01344                     merge_anon_children(child1, child2);
01345 
01346                     child1-&gt;child_list = NULL;
01347                     previous = child1;  <span class="comment">/* Finished with 'child1' */</span>
01348                     child1 = child1-&gt;next_peer;
01349                     free_tree(previous);
01350                     <span class="keywordflow">goto</span> next;
01351                 }
01352 
01353                 <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (!strncmp(child2-&gt;label, ANON, ANON_LEN)) {
01354                     merge_anon_children(child2, child1);
01355 
01356                     <span class="keywordflow">if</span> (previous)
01357                         previous-&gt;next_peer = child2-&gt;next_peer;
01358                     <span class="keywordflow">else</span>
01359                         tp2-&gt;child_list = child2-&gt;next_peer;
01360                     free_tree(child2);
01361 
01362                     previous = child1;  <span class="comment">/* Move 'child1' to 'tp2' */</span>
01363                     child1 = child1-&gt;next_peer;
01364                     previous-&gt;next_peer = tp2-&gt;child_list;
01365                     tp2-&gt;child_list = previous;
01366                     <span class="keywordflow">for</span> (previous = tp2-&gt;child_list;
01367                          previous; previous = previous-&gt;next_peer)
01368                         previous-&gt;parent = tp2;
01369                     <span class="keywordflow">goto</span> next;
01370                 } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (!label_compare(child1-&gt;label, child2-&gt;label)) {
01371                     <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
01372                                            NETSNMP_DS_LIB_MIB_WARNINGS)) {
01373                         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
01374                                  <span class="stringliteral">"Warning: %s.%ld is both %s and %s (%s)\n"</span>,
01375                                  tp2-&gt;label, child1-&gt;subid, child1-&gt;label,
01376                                  child2-&gt;label, File);
01377                     }
01378                     <span class="keywordflow">continue</span>;
01379                 } <span class="keywordflow">else</span> {
01380                     <span class="comment">/*</span>
01381 <span class="comment">                     * Two copies of the same node.</span>
01382 <span class="comment">                     * 'child2' adopts the children of 'child1'</span>
01383 <span class="comment">                     */</span>
01384 
01385                     <span class="keywordflow">if</span> (child2-&gt;child_list) {
01386                         <span class=
"keywordflow">for</span> (previous = child2-&gt;child_list; previous-&gt;next_peer; previous = previous-&gt;next_peer);       <span class="comment">/* Find the end of the list */</span>
01387                         previous-&gt;next_peer = child1-&gt;child_list;
01388                     } <span class="keywordflow">else</span>
01389                         child2-&gt;child_list = child1-&gt;child_list;
01390                     <span class="keywordflow">for</span> (previous = child1-&gt;child_list;
01391                          previous; previous = previous-&gt;next_peer)
01392                         previous-&gt;parent = child2;
01393                     child1-&gt;child_list = NULL;
01394 
01395                     previous = child1;  <span class="comment">/* Finished with 'child1' */</span>
01396                     child1 = child1-&gt;next_peer;
01397                     free_tree(previous);
01398                     <span class="keywordflow">goto</span> next;
01399                 }
01400             }
01401         }
01402         <span class="comment">/*</span>
01403 <span class="comment">         * If no match, move 'child1' to 'tp2' child_list</span>
01404 <span class="comment">         */</span>
01405         <span class="keywordflow">if</span> (child1) {
01406             previous = child1;
01407             child1 = child1-&gt;next_peer;
01408             previous-&gt;parent = tp2;
01409             previous-&gt;next_peer = tp2-&gt;child_list;
01410             tp2-&gt;child_list = previous;
01411         }
01412       next:;
01413     }
01414 }
01415 
01416 
01417 <span class="comment">/*</span>
01418 <span class="comment"> * Find all the children of root in the list of nodes.  Link them into the</span>
01419 <span class="comment"> * tree and out of the nodes list.</span>
01420 <span class="comment"> */</span>
01421 <span class="keyword">static</span> <span class="keywordtype">void</span>
01422 do_subtree(<span class="keyword">struct</span> tree *root, <span class="keyword">struct</span> node **nodes)
01423 {
01424     <span class="keyword">struct </span>tree    *tp, *anon_tp = NULL;
01425     <span class="keyword">struct </span>tree    *xroot = root;
01426     <span class="keyword">struct </span>node    *np, **headp;
01427     <span class="keyword">struct </span>node    *oldnp = NULL, *child_list = NULL, *childp = NULL;
01428     <span class="keywordtype">int</span>             hash;
01429     <span class="keywordtype">int</span>            *int_p;
01430 
01431     <span class=
"keywordflow">while</span> (xroot-&gt;next_peer &amp;&amp; xroot-&gt;next_peer-&gt;subid == root-&gt;subid) {
01432 <span class="preprocessor">#if 0</span>
01433         printf(<span class="stringliteral">"xroot: %s.%s =&gt; %s\n"</span>, xroot-&gt;parent-&gt;label, xroot-&gt;label,
01434                xroot-&gt;next_peer-&gt;label);
01435 <span class="preprocessor">#endif</span>
01436         xroot = xroot-&gt;next_peer;
01437     }
01438 
01439     tp = root;
01440     headp = &amp;nbuckets[NBUCKET(name_hash(tp-&gt;label))];
01441     <span class="comment">/*</span>
01442 <span class="comment">     * Search each of the nodes for one whose parent is root, and</span>
01443 <span class="comment">     * move each into a separate list.</span>
01444 <span class="comment">     */</span>
01445     <span class="keywordflow">for</span> (np = *headp; np; np = np-&gt;next) {
01446         <span class="keywordflow">if</span> (!label_compare(tp-&gt;label, np-&gt;parent)) {
01447             <span class="comment">/*</span>
01448 <span class="comment">             * take this node out of the node list </span>
01449 <span class="comment">             */</span>
01450             <span class="keywordflow">if</span> (oldnp == NULL) {
01451                 *headp = np-&gt;next;      <span class="comment">/* fix root of node list */</span>
01452             } <span class="keywordflow">else</span> {
01453                 oldnp-&gt;next = np-&gt;next; <span class="comment">/* link around this node */</span>
01454             }
01455             <span class="keywordflow">if</span> (child_list)
01456                 childp-&gt;next = np;
01457             <span class="keywordflow">else</span>
01458                 child_list = np;
01459             childp = np;
01460         } <span class="keywordflow">else</span> {
01461             oldnp = np;
01462         }
01463 
01464     }
01465     <span class="keywordflow">if</span> (childp)
01466         childp-&gt;next = NULL;
01467     <span class="comment">/*</span>
01468 <span class="comment">     * Take each element in the child list and place it into the tree.</span>
01469 <span class="comment">     */</span>
01470     <span class="keywordflow">for</span> (np = child_list; np; np = np-&gt;next) {
01471         <span class="keyword">struct </span>tree    *otp = NULL;
01472         <span class="keyword">struct </span>tree    *xxroot = xroot;
01473         anon_tp = NULL;
01474         tp = xroot-&gt;child_list;
01475 
01476         <span class="keywordflow">if</span> (np-&gt;subid == -1) {
01477             <span class="comment">/*</span>
01478 <span class="comment">             * name ::= { parent } </span>
01479 <span class="comment">             */</span>
01480             np-&gt;subid = xroot-&gt;subid;
01481             tp = xroot;
01482             xxroot = xroot-&gt;parent;
01483         }
01484 
01485         <span class="keywordflow">while</span> (tp) {
01486             <span class="keywordflow">if</span> (tp-&gt;subid == np-&gt;subid)
01487                 <span class="keywordflow">break</span>;
01488             <span class="keywordflow">else</span> {
01489                 otp = tp;
01490                 tp = tp-&gt;next_peer;
01491             }
01492         }
01493         <span class="keywordflow">if</span> (tp) {
01494             <span class="keywordflow">if</span> (!label_compare(tp-&gt;label, np-&gt;label)) {
01495                 <span class="comment">/*</span>
01496 <span class="comment">                 * Update list of modules </span>
01497 <span class="comment">                 */</span>
01498                 int_p =
01499                     (<span class="keywordtype">int</span> *) malloc((tp-&gt;number_modules + 1) * <span class=
"keyword">sizeof</span>(<span class="keywordtype">int</span>));
01500                 <span class="keywordflow">if</span> (int_p == NULL)
01501                     <span class="keywordflow">return</span>;
01502                 memcpy(int_p, tp-&gt;module_list,
01503                        tp-&gt;number_modules * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01504                 int_p[tp-&gt;number_modules] = np-&gt;modid;
01505                 <span class="keywordflow">if</span> (tp-&gt;number_modules &gt; 1)
01506                     free((<span class="keywordtype">char</span> *) tp-&gt;module_list);
01507                 ++tp-&gt;number_modules;
01508                 tp-&gt;module_list = int_p;
01509 
01510                 <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
01511                                            NETSNMP_DS_LIB_MIB_REPLACE)) {
01512                     <span class="comment">/*</span>
01513 <span class="comment">                     * Replace from node </span>
01514 <span class="comment">                     */</span>
01515                     tree_from_node(tp, np);
01516                 }
01517                 <span class="comment">/*</span>
01518 <span class="comment">                 * Handle children </span>
01519 <span class="comment">                 */</span>
01520                 do_subtree(tp, nodes);
01521                 <span class="keywordflow">continue</span>;
01522             }
01523             <span class="keywordflow">if</span> (!strncmp(np-&gt;label, ANON, ANON_LEN) ||
01524                 !strncmp(tp-&gt;label, ANON, ANON_LEN)) {
01525                 anon_tp = tp;   <span class="comment">/* Need to merge these two trees later */</span>
01526             } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
01527                                           NETSNMP_DS_LIB_MIB_WARNINGS)) {
01528                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
01529                          <span class="stringliteral">"Warning: %s.%ld is both %s and %s (%s)\n"</span>,
01530                          root-&gt;label, np-&gt;subid, tp-&gt;label, np-&gt;label,
01531                          File);
01532             }
01533         }
01534 
01535         tp = (<span class="keyword">struct </span>tree *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> tree));
01536         <span class="keywordflow">if</span> (tp == NULL)
01537             <span class="keywordflow">return</span>;
01538         tp-&gt;parent = xxroot;
01539         tp-&gt;modid = np-&gt;modid;
01540         tp-&gt;number_modules = 1;
01541         tp-&gt;module_list = &amp;(tp-&gt;modid);
01542         tree_from_node(tp, np);
01543         tp-&gt;next_peer = otp ? otp-&gt;next_peer : xxroot-&gt;child_list;
01544         <span class="keywordflow">if</span> (otp)
01545             otp-&gt;next_peer = tp;
01546         <span class="keywordflow">else</span>
01547             xxroot-&gt;child_list = tp;
01548         hash = NBUCKET(name_hash(tp-&gt;label));
01549         tp-&gt;next = tbuckets[hash];
01550         tbuckets[hash] = tp;
01551         do_subtree(tp, nodes);
01552 
01553         <span class="keywordflow">if</span> (anon_tp) {
01554             <span class="keywordflow">if</span> (!strncmp(tp-&gt;label, ANON, ANON_LEN)) {
01555                 <span class="comment">/*</span>
01556 <span class="comment">                 * The new node is anonymous,</span>
01557 <span class="comment">                 *  so merge it with the existing one.</span>
01558 <span class="comment">                 */</span>
01559                 merge_anon_children(tp, anon_tp);
01560 
01561                 <span class="comment">/*</span>
01562 <span class="comment">                 * unlink and destroy tp </span>
01563 <span class="comment">                 */</span>
01564                 unlink_tree(tp);
01565                 free_tree(tp);
01566             } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (!strncmp(anon_tp-&gt;label, ANON, ANON_LEN)) {
01567                 <span class="keyword">struct </span>tree    *ntp;
01568                 <span class="comment">/*</span>
01569 <span class="comment">                 * The old node was anonymous,</span>
01570 <span class="comment">                 *  so merge it with the existing one,</span>
01571 <span class="comment">                 *  and fill in the full information.</span>
01572 <span class="comment">                 */</span>
01573                 merge_anon_children(anon_tp, tp);
01574 
01575                 <span class="comment">/*</span>
01576 <span class="comment">                 * unlink anon_tp from the hash </span>
01577 <span class="comment">                 */</span>
01578                 unlink_tbucket(anon_tp);
01579 
01580                 <span class="comment">/*</span>
01581 <span class="comment">                 * get rid of old contents of anon_tp </span>
01582 <span class="comment">                 */</span>
01583                 free_partial_tree(anon_tp, FALSE);
01584 
01585                 <span class="comment">/*</span>
01586 <span class="comment">                 * put in the current information </span>
01587 <span class="comment">                 */</span>
01588                 anon_tp-&gt;label = tp-&gt;label;
01589                 anon_tp-&gt;child_list = tp-&gt;child_list;
01590                 anon_tp-&gt;modid = tp-&gt;modid;
01591                 anon_tp-&gt;tc_index = tp-&gt;tc_index;
01592                 anon_tp-&gt;type = tp-&gt;type;
01593                 anon_tp-&gt;enums = tp-&gt;enums;
01594                 anon_tp-&gt;indexes = tp-&gt;indexes;
01595                 anon_tp-&gt;augments = tp-&gt;augments;
01596                 anon_tp-&gt;varbinds = tp-&gt;varbinds;
01597                 anon_tp-&gt;ranges = tp-&gt;ranges;
01598                 anon_tp-&gt;hint = tp-&gt;hint;
01599                 anon_tp-&gt;units = tp-&gt;units;
01600                 anon_tp-&gt;description = tp-&gt;description;
01601                 anon_tp-&gt;reference = tp-&gt;reference;
01602                 anon_tp-&gt;defaultValue = tp-&gt;defaultValue;
01603                 anon_tp-&gt;parent = tp-&gt;parent;
01604 
01605                 <a class="code" href="group__mib__utilities.html#ga60">set_function</a>(anon_tp);
01606 
01607                 <span class="comment">/*</span>
01608 <span class="comment">                 * update parent pointer in moved children </span>
01609 <span class="comment">                 */</span>
01610                 ntp = anon_tp-&gt;child_list;
01611                 <span class="keywordflow">while</span> (ntp) {
01612                     ntp-&gt;parent = anon_tp;
01613                     ntp = ntp-&gt;next_peer;
01614                 }
01615 
01616                 <span class="comment">/*</span>
01617 <span class="comment">                 * hash in anon_tp in its new place </span>
01618 <span class="comment">                 */</span>
01619                 hash = NBUCKET(name_hash(anon_tp-&gt;label));
01620                 anon_tp-&gt;next = tbuckets[hash];
01621                 tbuckets[hash] = anon_tp;
01622 
01623                 <span class="comment">/*</span>
01624 <span class="comment">                 * unlink and destroy tp </span>
01625 <span class="comment">                 */</span>
01626                 unlink_tbucket(tp);
01627                 unlink_tree(tp);
01628                 free(tp);
01629             } <span class="keywordflow">else</span> {
01630                 <span class="comment">/*</span>
01631 <span class="comment">                 * Uh?  One of these two should have been anonymous! </span>
01632 <span class="comment">                 */</span>
01633                 <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
01634                                        NETSNMP_DS_LIB_MIB_WARNINGS)) {
01635                     <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
01636                              <span class=
"stringliteral">"Warning: expected anonymous node (either %s or %s) in %s\n"</span>,
01637                              tp-&gt;label, anon_tp-&gt;label, File);
01638                 }
01639             }
01640             anon_tp = NULL;
01641         }
01642     }
01643     <span class="comment">/*</span>
01644 <span class="comment">     * free all nodes that were copied into tree </span>
01645 <span class="comment">     */</span>
01646     oldnp = NULL;
01647     <span class="keywordflow">for</span> (np = child_list; np; np = np-&gt;next) {
01648         <span class="keywordflow">if</span> (oldnp)
01649             free_node(oldnp);
01650         oldnp = np;
01651     }
01652     <span class="keywordflow">if</span> (oldnp)
01653         free_node(oldnp);
01654 }
01655 
01656 <span class="keyword">static</span> <span class="keywordtype">void</span>
01657 do_linkup(<span class="keyword">struct</span> module *mp, <span class="keyword">struct</span> node *np)
01658 {
01659     <span class="keyword">struct </span>module_import *mip;
01660     <span class="keyword">struct </span>node    *onp, *oldp, *newp;
01661     <span class="keyword">struct </span>tree    *tp;
01662     <span class="keywordtype">int</span>             i, more;
01663     <span class="comment">/*</span>
01664 <span class="comment">     * All modules implicitly import</span>
01665 <span class="comment">     *   the roots of the tree</span>
01666 <span class="comment">     */</span>
01667     <span class="keywordflow">if</span> (snmp_get_do_debugging() &gt; 1)
01668         dump_module_list();
01669     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Processing IMPORTS for module %d %s\n"</span>,
01670                 mp-&gt;modid, mp-&gt;name));
01671     <span class="keywordflow">if</span> (mp-&gt;no_imports == 0) {
01672         mp-&gt;no_imports = NUMBER_OF_ROOT_NODES;
01673         mp-&gt;imports = root_imports;
01674     }
01675 
01676     <span class="comment">/*</span>
01677 <span class="comment">     * Build the tree</span>
01678 <span class="comment">     */</span>
01679     init_node_hash(np);
01680     <span class="keywordflow">for</span> (i = 0, mip = mp-&gt;imports; i &lt; mp-&gt;no_imports; ++i, ++mip) {
01681         <span class="keywordtype">char</span>            modbuf[256];
01682         DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"  Processing import: %s\n"</span>,
01683                     mip-&gt;label));
01684         <span class="keywordflow">if</span> (get_tc_index(mip-&gt;label, mip-&gt;modid) != -1)
01685             <span class="keywordflow">continue</span>;
01686         tp = find_tree_node(mip-&gt;label, mip-&gt;modid);
01687         <span class="keywordflow">if</span> (!tp) {
01688                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
01689                          <span class="stringliteral">"Did not find '%s' in module %s (%s)\n"</span>,
01690                          mip-&gt;label, module_name(mip-&gt;modid, modbuf),
01691                          File);
01692             <span class="keywordflow">continue</span>;
01693         }
01694         do_subtree(tp, &amp;np);
01695     }
01696 
01697     <span class="comment">/*</span>
01698 <span class="comment">     * If any nodes left over,</span>
01699 <span class="comment">     *   check that they're not the result of a "fully qualified"</span>
01700 <span class="comment">     *   name, and then add them to the list of orphans</span>
01701 <span class="comment">     */</span>
01702 
01703     <span class="keywordflow">if</span> (!np)
01704         <span class="keywordflow">return</span>;
01705     <span class="keywordflow">for</span> (tp = tree_head; tp; tp = tp-&gt;next_peer)
01706         do_subtree(tp, &amp;np);
01707     <span class="keywordflow">if</span> (!np)
01708         <span class="keywordflow">return</span>;
01709 
01710     <span class="comment">/*</span>
01711 <span class="comment">     * quietly move all internal references to the orphan list </span>
01712 <span class="comment">     */</span>
01713     oldp = orphan_nodes;
01714     <span class="keywordflow">do</span> {
01715         <span class="keywordflow">for</span> (i = 0; i &lt; NHASHSIZE; i++)
01716             <span class="keywordflow">for</span> (onp = nbuckets[i]; onp; onp = onp-&gt;next) {
01717                 <span class="keyword">struct </span>node    *op = NULL;
01718                 <span class="keywordtype">int</span>             hash = NBUCKET(name_hash(onp-&gt;label));
01719                 np = nbuckets[hash];
01720                 <span class="keywordflow">while</span> (np) {
01721                     <span class="keywordflow">if</span> (label_compare(onp-&gt;label, np-&gt;parent)) {
01722                         op = np;
01723                         np = np-&gt;next;
01724                     } <span class="keywordflow">else</span> {
01725                         <span class="keywordflow">if</span> (op)
01726                             op-&gt;next = np-&gt;next;
01727                         <span class="keywordflow">else</span>
01728                             nbuckets[hash] = np-&gt;next;
01729                         np-&gt;next = orphan_nodes;
01730                         orphan_nodes = np;
01731                         op = NULL;
01732                         np = nbuckets[hash];
01733                     }
01734                 }
01735             }
01736         newp = orphan_nodes;
01737         more = 0;
01738         <span class="keywordflow">for</span> (onp = orphan_nodes; onp != oldp; onp = onp-&gt;next) {
01739             <span class="keyword">struct </span>node    *op = NULL;
01740             <span class="keywordtype">int</span>             hash = NBUCKET(name_hash(onp-&gt;label));
01741             np = nbuckets[hash];
01742             <span class="keywordflow">while</span> (np) {
01743                 <span class="keywordflow">if</span> (label_compare(onp-&gt;label, np-&gt;parent)) {
01744                     op = np;
01745                     np = np-&gt;next;
01746                 } <span class="keywordflow">else</span> {
01747                     <span class="keywordflow">if</span> (op)
01748                         op-&gt;next = np-&gt;next;
01749                     <span class="keywordflow">else</span>
01750                         nbuckets[hash] = np-&gt;next;
01751                     np-&gt;next = orphan_nodes;
01752                     orphan_nodes = np;
01753                     op = NULL;
01754                     np = nbuckets[hash];
01755                     more = 1;
01756                 }
01757             }
01758         }
01759         oldp = newp;
01760     } <span class="keywordflow">while</span> (more);
01761 
01762     <span class="comment">/*</span>
01763 <span class="comment">     * complain about left over nodes </span>
01764 <span class="comment">     */</span>
01765     <span class="keywordflow">for</span> (np = orphan_nodes; np &amp;&amp; np-&gt;next; np = np-&gt;next);     <span class=
"comment">/* find the end of the orphan list */</span>
01766     <span class="keywordflow">for</span> (i = 0; i &lt; NHASHSIZE; i++)
01767         <span class="keywordflow">if</span> (nbuckets[i]) {
01768             <span class="keywordflow">if</span> (orphan_nodes)
01769                 onp = np-&gt;next = nbuckets[i];
01770             <span class="keywordflow">else</span>
01771                 onp = orphan_nodes = nbuckets[i];
01772             nbuckets[i] = NULL;
01773             <span class="keywordflow">while</span> (onp) {
01774                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
01775                          <span class="stringliteral">"Unlinked OID in %s: %s ::= { %s %ld }\n"</span>,
01776                          (mp-&gt;name ? mp-&gt;name : <span class="stringliteral">"&lt;no module&gt;"</span>),
01777                          (onp-&gt;label ? onp-&gt;label : <span class="stringliteral">"&lt;no label&gt;"</span>),
01778                          (onp-&gt;parent ? onp-&gt;parent : <span class="stringliteral">"&lt;no parent&gt;"</span>),
01779                          onp-&gt;subid);
01780                  <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
01781                           <span class="stringliteral">"Undefined identifier: %s near line %d of %s\n"</span>,
01782                           (onp-&gt;parent ? onp-&gt;parent : <span class="stringliteral">"&lt;no parent&gt;"</span>),
01783                           onp-&gt;lineno, onp-&gt;filename);
01784                 np = onp;
01785                 onp = onp-&gt;next;
01786             }
01787         }
01788     <span class="keywordflow">return</span>;
01789 }
01790 
01791 
01792 <span class="comment">/*</span>
01793 <span class="comment"> * Takes a list of the form:</span>
01794 <span class="comment"> * { iso org(3) dod(6) 1 }</span>
01795 <span class="comment"> * and creates several nodes, one for each parent-child pair.</span>
01796 <span class="comment"> * Returns 0 on error.</span>
01797 <span class="comment"> */</span>
01798 <span class="keyword">static</span> <span class="keywordtype">int</span>
01799 getoid(FILE * fp, <span class="keyword">struct</span> subid_s *<span class="keywordtype">id</span>,   <span class=
"comment">/* an array of subids */</span>
01800        <span class="keywordtype">int</span> length)
01801 {                               <span class="comment">/* the length of the array */</span>
01802     <span class="keyword">register</span> <span class="keywordtype">int</span>    count;
01803     <span class="keywordtype">int</span>             type;
01804     <span class="keywordtype">char</span>            token[MAXTOKEN];
01805 
01806     <span class="keywordflow">if</span> ((type = get_token(fp, token, MAXTOKEN)) != LEFTBRACKET) {
01807         print_error(<span class="stringliteral">"Expected \"{\""</span>, token, type);
01808         <span class="keywordflow">return</span> 0;
01809     }
01810     type = get_token(fp, token, MAXTOKEN);
01811     <span class="keywordflow">for</span> (count = 0; count &lt; length; count++, <span class="keywordtype">id</span>++) {
01812         <span class="keywordtype">id</span>-&gt;label = NULL;
01813         <span class="keywordtype">id</span>-&gt;modid = current_module;
01814         <span class="keywordtype">id</span>-&gt;subid = -1;
01815         <span class="keywordflow">if</span> (type == RIGHTBRACKET)
01816             <span class="keywordflow">return</span> count;
01817         <span class="keywordflow">if</span> (type == LABEL) {
01818             <span class="comment">/*</span>
01819 <span class="comment">             * this entry has a label </span>
01820 <span class="comment">             */</span>
01821             <span class="keywordtype">id</span>-&gt;label = strdup(token);
01822             type = get_token(fp, token, MAXTOKEN);
01823             <span class="keywordflow">if</span> (type == LEFTPAREN) {
01824                 type = get_token(fp, token, MAXTOKEN);
01825                 <span class="keywordflow">if</span> (type == NUMBER) {
01826                     <span class="keywordtype">id</span>-&gt;subid = strtoul(token, NULL, 10);
01827                     <span class="keywordflow">if</span> ((type =
01828                          get_token(fp, token, MAXTOKEN)) != RIGHTPAREN) {
01829                         print_error(<span class="stringliteral">"Expected a closing parenthesis"</span>,
01830                                     token, type);
01831                         <span class="keywordflow">return</span> 0;
01832                     }
01833                 } <span class="keywordflow">else</span> {
01834                     print_error(<span class="stringliteral">"Expected a number"</span>, token, type);
01835                     <span class="keywordflow">return</span> 0;
01836                 }
01837             } <span class="keywordflow">else</span> {
01838                 <span class="keywordflow">continue</span>;
01839             }
01840         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == NUMBER) {
01841             <span class="comment">/*</span>
01842 <span class="comment">             * this entry  has just an integer sub-identifier </span>
01843 <span class="comment">             */</span>
01844             <span class="keywordtype">id</span>-&gt;subid = strtoul(token, NULL, 10);
01845         } <span class="keywordflow">else</span> {
01846             print_error(<span class="stringliteral">"Expected label or number"</span>, token, type);
01847             <span class="keywordflow">return</span> 0;
01848         }
01849         type = get_token(fp, token, MAXTOKEN);
01850     }
01851     print_error(<span class="stringliteral">"Too long OID"</span>, token, type);
01852     <span class="keywordflow">return</span> 0;
01853 }
01854 
01855 <span class="comment">/*</span>
01856 <span class="comment"> * Parse a sequence of object subidentifiers for the given name.</span>
01857 <span class="comment"> * The "label OBJECT IDENTIFIER ::=" portion has already been parsed.</span>
01858 <span class="comment"> *</span>
01859 <span class="comment"> * The majority of cases take this form :</span>
01860 <span class="comment"> * label OBJECT IDENTIFIER ::= { parent 2 }</span>
01861 <span class="comment"> * where a parent label and a child subidentifier number are specified.</span>
01862 <span class="comment"> *</span>
01863 <span class="comment"> * Variations on the theme include cases where a number appears with</span>
01864 <span class="comment"> * the parent, or intermediate subidentifiers are specified by label,</span>
01865 <span class="comment"> * by number, or both.</span>
01866 <span class="comment"> *</span>
01867 <span class="comment"> * Here are some representative samples :</span>
01868 <span class="comment"> * internet        OBJECT IDENTIFIER ::= { iso org(3) dod(6) 1 }</span>
01869 <span class="comment"> * mgmt            OBJECT IDENTIFIER ::= { internet 2 }</span>
01870 <span class="comment"> * rptrInfoHealth  OBJECT IDENTIFIER ::= { snmpDot3RptrMgt 0 4 }</span>
01871 <span class="comment"> *</span>
01872 <span class="comment"> * Here is a very rare form :</span>
01873 <span class="comment"> * iso             OBJECT IDENTIFIER ::= { 1 }</span>
01874 <span class="comment"> *</span>
01875 <span class="comment"> * Returns NULL on error.  When this happens, memory may be leaked.</span>
01876 <span class="comment"> */</span>
01877 <span class="keyword">static</span> <span class="keyword">struct </span>node *
01878 parse_objectid(FILE * fp, <span class="keywordtype">char</span> *name)
01879 {
01880     <span class="keyword">register</span> <span class="keywordtype">int</span>    count;
01881     <span class="keyword">register</span> <span class="keyword">struct </span>subid_s *op, *nop;
01882     <span class="keywordtype">int</span>             length;
01883     <span class="keyword">struct </span>subid_s  loid[32];
01884     <span class="keyword">struct </span>node    *np, *root = NULL, *oldnp = NULL;
01885     <span class="keyword">struct </span>tree    *tp;
01886 
01887     <span class="keywordflow">if</span> ((length = getoid(fp, loid, 32)) == 0) {
01888         print_error(<span class="stringliteral">"Bad object identifier"</span>, NULL, CONTINUE);
01889         <span class="keywordflow">return</span> NULL;
01890     }
01891 
01892     <span class="comment">/*</span>
01893 <span class="comment">     * Handle numeric-only object identifiers,</span>
01894 <span class="comment">     *  by labelling the first sub-identifier</span>
01895 <span class="comment">     */</span>
01896     op = loid;
01897     <span class="keywordflow">if</span> (!op-&gt;label) {
01898         <span class="keywordflow">if</span> (length == 1) {
01899             print_error(<span class="stringliteral">"Attempt to define a root oid"</span>, name, OBJECT);
01900             <span class="keywordflow">return</span> NULL;
01901         }
01902         <span class="keywordflow">for</span> (tp = tree_head; tp; tp = tp-&gt;next_peer)
01903             <span class="keywordflow">if</span> ((int) tp-&gt;subid == op-&gt;subid) {
01904                 op-&gt;label = strdup(tp-&gt;label);
01905                 <span class="keywordflow">break</span>;
01906             }
01907     }
01908 
01909     <span class="comment">/*</span>
01910 <span class="comment">     * Handle  "label OBJECT-IDENTIFIER ::= { subid }"</span>
01911 <span class="comment">     */</span>
01912     <span class="keywordflow">if</span> (length == 1) {
01913         op = loid;
01914         np = alloc_node(op-&gt;modid);
01915         <span class="keywordflow">if</span> (np == NULL)
01916             <span class="keywordflow">return</span> (NULL);
01917         np-&gt;subid = op-&gt;subid;
01918         np-&gt;label = strdup(name);
01919         np-&gt;parent = op-&gt;label;
01920         <span class="keywordflow">return</span> np;
01921     }
01922 
01923     <span class="comment">/*</span>
01924 <span class="comment">     * For each parent-child subid pair in the subid array,</span>
01925 <span class="comment">     * create a node and link it into the node list.</span>
01926 <span class="comment">     */</span>
01927     <span class="keywordflow">for</span> (count = 0, op = loid, nop = loid + 1; count &lt; (length - 1);
01928          count++, op++, nop++) {
01929         <span class="comment">/*</span>
01930 <span class="comment">         * every node must have parent's name and child's name or number </span>
01931 <span class="comment">         */</span>
01932         <span class="comment">/*</span>
01933 <span class="comment">         * XX the next statement is always true -- does it matter ?? </span>
01934 <span class="comment">         */</span>
01935         <span class="keywordflow">if</span> (op-&gt;label &amp;&amp; (nop-&gt;label || (nop-&gt;subid != -1))) {
01936             np = alloc_node(nop-&gt;modid);
01937             <span class="keywordflow">if</span> (np == NULL)
01938                 <span class="keywordflow">return</span> (NULL);
01939             <span class="keywordflow">if</span> (root == NULL)
01940                 root = np;
01941 
01942             np-&gt;parent = strdup(op-&gt;label);
01943             <span class="keywordflow">if</span> (count == (length - 2)) {
01944                 <span class="comment">/*</span>
01945 <span class="comment">                 * The name for this node is the label for this entry </span>
01946 <span class="comment">                 */</span>
01947                 np-&gt;label = strdup(name);
01948             } <span class="keywordflow">else</span> {
01949                 <span class="keywordflow">if</span> (!nop-&gt;label) {
01950                     nop-&gt;label = (<span class="keywordtype">char</span> *) malloc(20 + ANON_LEN);
01951                     <span class="keywordflow">if</span> (nop-&gt;label == NULL)
01952                         <span class="keywordflow">return</span> (NULL);
01953                     sprintf(nop-&gt;label, <span class="stringliteral">"%s%d"</span>, ANON, anonymous++);
01954                 }
01955                 np-&gt;label = strdup(nop-&gt;label);
01956             }
01957             <span class="keywordflow">if</span> (nop-&gt;subid != -1)
01958                 np-&gt;subid = nop-&gt;subid;
01959             <span class="keywordflow">else</span>
01960                 print_error(<span class="stringliteral">"Warning: This entry is pretty silly"</span>,
01961                             np-&gt;label, CONTINUE);
01962 
01963             <span class="comment">/*</span>
01964 <span class="comment">             * set up next entry </span>
01965 <span class="comment">             */</span>
01966             <span class="keywordflow">if</span> (oldnp)
01967                 oldnp-&gt;next = np;
01968             oldnp = np;
01969         }                       <span class="comment">/* end if(op-&gt;label... */</span>
01970     }
01971 
01972     <span class="comment">/*</span>
01973 <span class="comment">     * free the loid array </span>
01974 <span class="comment">     */</span>
01975     <span class="keywordflow">for</span> (count = 0, op = loid; count &lt; length; count++, op++) {
01976         <span class="keywordflow">if</span> (op-&gt;label)
01977             free(op-&gt;label);
01978     }
01979 
01980     <span class="keywordflow">return</span> root;
01981 }
01982 
01983 <span class="keyword">static</span> <span class="keywordtype">int</span>
01984 get_tc(<span class="keyword">const</span> <span class="keywordtype">char</span> *descriptor,
01985        <span class="keywordtype">int</span> modid,
01986        <span class="keywordtype">int</span> *tc_index,
01987        <span class="keyword">struct</span> enum_list **ep, <span class=
"keyword">struct</span> range_list **rp, <span class="keywordtype">char</span> **hint)
01988 {
01989     <span class="keywordtype">int</span>             i;
01990     <span class="keyword">struct </span>tc      *tcp;
01991 
01992     i = get_tc_index(descriptor, modid);
01993     <span class="keywordflow">if</span> (tc_index)
01994         *tc_index = i;
01995     <span class="keywordflow">if</span> (i != -1) {
01996         tcp = &amp;tclist[i];
01997         <span class="keywordflow">if</span> (ep) {
01998             free_enums(ep);
01999             *ep = copy_enums(tcp-&gt;enums);
02000         }
02001         <span class="keywordflow">if</span> (rp) {
02002             free_ranges(rp);
02003             *rp = copy_ranges(tcp-&gt;ranges);
02004         }
02005         <span class="keywordflow">if</span> (hint) {
02006             <span class="keywordflow">if</span> (*hint)
02007                 free(*hint);
02008             *hint = (tcp-&gt;hint ? strdup(tcp-&gt;hint) : NULL);
02009         }
02010         <span class="keywordflow">return</span> tcp-&gt;type;
02011     }
02012     <span class="keywordflow">return</span> LABEL;
02013 }
02014 
02015 <span class="comment">/*</span>
02016 <span class="comment"> * return index into tclist of given TC descriptor</span>
02017 <span class="comment"> * return -1 if not found</span>
02018 <span class="comment"> */</span>
02019 <span class="keyword">static</span> <span class="keywordtype">int</span>
02020 get_tc_index(<span class="keyword">const</span> <span class="keywordtype">char</span> *descriptor, <span class=
"keywordtype">int</span> modid)
02021 {
02022     <span class="keywordtype">int</span>             i;
02023     <span class="keyword">struct </span>tc      *tcp;
02024     <span class="keyword">struct </span>module  *mp;
02025     <span class="keyword">struct </span>module_import *mip;
02026 
02027     <span class="comment">/*</span>
02028 <span class="comment">     * Check that the descriptor isn't imported</span>
02029 <span class="comment">     *  by searching the import list</span>
02030 <span class="comment">     */</span>
02031 
02032     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
02033         <span class="keywordflow">if</span> (mp-&gt;modid == modid)
02034             <span class="keywordflow">break</span>;
02035     <span class="keywordflow">if</span> (mp)
02036         <span class="keywordflow">for</span> (i = 0, mip = mp-&gt;imports; i &lt; mp-&gt;no_imports; ++i, ++mip) {
02037             <span class="keywordflow">if</span> (!label_compare(mip-&gt;label, descriptor)) {
02038                 <span class="comment">/*</span>
02039 <span class="comment">                 * Found it - so amend the module ID </span>
02040 <span class="comment">                 */</span>
02041                 modid = mip-&gt;modid;
02042                 <span class="keywordflow">break</span>;
02043             }
02044         }
02045 
02046 
02047     <span class="keywordflow">for</span> (i = 0, tcp = tclist; i &lt; MAXTC; i++, tcp++) {
02048         <span class="keywordflow">if</span> (tcp-&gt;type == 0)
02049             <span class="keywordflow">break</span>;
02050         <span class="keywordflow">if</span> (!label_compare(descriptor, tcp-&gt;descriptor) &amp;&amp;
02051             ((modid == tcp-&gt;modid) || (modid == -1))) {
02052             <span class="keywordflow">return</span> i;
02053         }
02054     }
02055     <span class="keywordflow">return</span> -1;
02056 }
02057 
02058 <span class="comment">/*</span>
02059 <span class="comment"> * translate integer tc_index to string identifier from tclist</span>
02060 <span class="comment"> * *</span>
02061 <span class="comment"> * * Returns pointer to string in table (should not be modified) or NULL</span>
02062 <span class="comment"> */</span>
02063 <span class="keyword">const</span> <span class="keywordtype">char</span>     *
02064 get_tc_descriptor(<span class="keywordtype">int</span> tc_index)
02065 {
02066     <span class="keywordflow">if</span> (tc_index &lt; 0 || tc_index &gt;= MAXTC)
02067         <span class="keywordflow">return</span> NULL;
02068     <span class="keywordflow">return</span> (tclist[tc_index].descriptor);
02069 }
02070 
02071 <span class="keyword">const</span> <span class="keywordtype">char</span>     *
02072 get_tc_description(<span class="keywordtype">int</span> tc_index)
02073 {
02074     <span class="keywordflow">if</span> (tc_index &lt; 0 || tc_index &gt;= MAXTC)
02075         <span class="keywordflow">return</span> NULL;
02076     <span class="keywordflow">return</span> (tclist[tc_index].description);
02077 }
02078 
02079 
02080 <span class="comment">/*</span>
02081 <span class="comment"> * Parses an enumeration list of the form:</span>
02082 <span class="comment"> *        { label(value) label(value) ... }</span>
02083 <span class="comment"> * The initial { has already been parsed.</span>
02084 <span class="comment"> * Returns NULL on error.</span>
02085 <span class="comment"> */</span>
02086 
02087 <span class="keyword">static</span> <span class="keyword">struct </span>enum_list *
02088 parse_enumlist(FILE * fp, <span class="keyword">struct</span> enum_list **retp)
02089 {
02090     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
02091     <span class="keywordtype">char</span>            token[MAXTOKEN];
02092     <span class="keyword">struct </span>enum_list *ep = NULL, **epp = &amp;ep;
02093 
02094     free_enums(retp);
02095 
02096     <span class="keywordflow">while</span> ((type = get_token(fp, token, MAXTOKEN)) != ENDOFFILE) {
02097         <span class="keywordflow">if</span> (type == RIGHTBRACKET)
02098             <span class="keywordflow">break</span>;
02099         <span class="keywordflow">if</span> (type == LABEL) {
02100             <span class="comment">/*</span>
02101 <span class="comment">             * this is an enumerated label </span>
02102 <span class="comment">             */</span>
02103             *epp =
02104                 (<span class="keyword">struct </span>enum_list *) calloc(1, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> enum_list));
02105             <span class="keywordflow">if</span> (*epp == NULL)
02106                 <span class="keywordflow">return</span> (NULL);
02107             <span class="comment">/*</span>
02108 <span class="comment">             * a reasonable approximation for the length </span>
02109 <span class="comment">             */</span>
02110             (*epp)-&gt;label = strdup(token);
02111             type = get_token(fp, token, MAXTOKEN);
02112             <span class="keywordflow">if</span> (type != LEFTPAREN) {
02113                 print_error(<span class="stringliteral">"Expected \"(\""</span>, token, type);
02114                 <span class="keywordflow">return</span> NULL;
02115             }
02116             type = get_token(fp, token, MAXTOKEN);
02117             <span class="keywordflow">if</span> (type != NUMBER) {
02118                 print_error(<span class="stringliteral">"Expected integer"</span>, token, type);
02119                 <span class="keywordflow">return</span> NULL;
02120             }
02121             (*epp)-&gt;value = strtol(token, NULL, 10);
02122             type = get_token(fp, token, MAXTOKEN);
02123             <span class="keywordflow">if</span> (type != RIGHTPAREN) {
02124                 print_error(<span class="stringliteral">"Expected \")\""</span>, token, type);
02125                 <span class="keywordflow">return</span> NULL;
02126             }
02127             epp = &amp;(*epp)-&gt;next;
02128         }
02129     }
02130     <span class="keywordflow">if</span> (type == ENDOFFILE) {
02131         print_error(<span class="stringliteral">"Expected \"}\""</span>, token, type);
02132         <span class="keywordflow">return</span> NULL;
02133     }
02134     *retp = ep;
02135     <span class="keywordflow">return</span> ep;
02136 }
02137 
02138 <span class="keyword">static</span> <span class="keyword">struct </span>range_list *
02139 parse_ranges(FILE * fp, <span class="keyword">struct</span> range_list **retp)
02140 {
02141     <span class="keywordtype">int</span>             low, high;
02142     <span class="keywordtype">char</span>            nexttoken[MAXTOKEN];
02143     <span class="keywordtype">int</span>             nexttype;
02144     <span class="keyword">struct </span>range_list *rp = NULL, **rpp = &amp;rp;
02145     <span class="keywordtype">int</span>             size = 0, taken = 1;
02146 
02147     free_ranges(retp);
02148 
02149     nexttype = get_token(fp, nexttoken, MAXTOKEN);
02150     <span class="keywordflow">if</span> (nexttype == SIZE) {
02151         size = 1;
02152         taken = 0;
02153         nexttype = get_token(fp, nexttoken, MAXTOKEN);
02154         <span class="keywordflow">if</span> (nexttype != LEFTPAREN)
02155             print_error(<span class="stringliteral">"Expected \"(\" after SIZE"</span>, nexttoken, nexttype);
02156     }
02157 
02158     <span class="keywordflow">do</span> {
02159         <span class="keywordflow">if</span> (!taken)
02160             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02161         <span class="keywordflow">else</span>
02162             taken = 0;
02163         high = low = strtol(nexttoken, NULL, 10);
02164         nexttype = get_token(fp, nexttoken, MAXTOKEN);
02165         <span class="keywordflow">if</span> (nexttype == RANGE) {
02166             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02167             high = strtol(nexttoken, NULL, 10);
02168             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02169         }
02170         *rpp = (<span class="keyword">struct </span>range_list *) calloc(1, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> range_list));
02171         <span class="keywordflow">if</span> (*rpp == NULL)
02172             <span class="keywordflow">break</span>;
02173         (*rpp)-&gt;low = low;
02174         (*rpp)-&gt;high = high;
02175         rpp = &amp;(*rpp)-&gt;next;
02176 
02177     } <span class="keywordflow">while</span> (nexttype == BAR);
02178     <span class="keywordflow">if</span> (size) {
02179         <span class="keywordflow">if</span> (nexttype != RIGHTPAREN)
02180             print_error(<span class="stringliteral">"Expected \")\" after SIZE"</span>, nexttoken, nexttype);
02181         nexttype = get_token(fp, nexttoken, nexttype);
02182     }
02183     <span class="keywordflow">if</span> (nexttype != RIGHTPAREN)
02184         print_error(<span class="stringliteral">"Expected \")\""</span>, nexttoken, nexttype);
02185 
02186     *retp = rp;
02187     <span class="keywordflow">return</span> rp;
02188 }
02189 
02190 <span class="comment">/*</span>
02191 <span class="comment"> * Parses an asn type.  Structures are ignored by this parser.</span>
02192 <span class="comment"> * Returns NULL on error.</span>
02193 <span class="comment"> */</span>
02194 <span class="keyword">static</span> <span class="keyword">struct </span>node *
02195 parse_asntype(FILE * fp, <span class="keywordtype">char</span> *name, <span class=
"keywordtype">int</span> *ntype, <span class="keywordtype">char</span> *ntoken)
02196 {
02197     <span class="keywordtype">int</span>             type, i;
02198     <span class="keywordtype">char</span>            token[MAXTOKEN];
02199     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
02200     <span class="keywordtype">char</span>           *hint = NULL;
02201     <span class="keywordtype">char</span>           *descr = NULL;
02202     <span class="keyword">struct </span>tc      *tcp;
02203     <span class="keywordtype">int</span>             level;
02204 
02205     type = get_token(fp, token, MAXTOKEN);
02206     <span class="keywordflow">if</span> (type == SEQUENCE || type == CHOICE) {
02207         level = 0;
02208         <span class="keywordflow">while</span> ((type = get_token(fp, token, MAXTOKEN)) != ENDOFFILE) {
02209             <span class="keywordflow">if</span> (type == LEFTBRACKET) {
02210                 level++;
02211             } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (type == RIGHTBRACKET &amp;&amp; --level == 0) {
02212                 *ntype = get_token(fp, ntoken, MAXTOKEN);
02213                 <span class="keywordflow">return</span> NULL;
02214             }
02215         }
02216         print_error(<span class="stringliteral">"Expected \"}\""</span>, token, type);
02217         <span class="keywordflow">return</span> NULL;
02218     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == LEFTBRACKET) {
02219         <span class="keyword">struct </span>node    *np;
02220         <span class="keywordtype">int</span>             ch_next = <span class="charliteral">'{'</span>;
02221         ungetc(ch_next, fp);
02222         np = parse_objectid(fp, name);
02223         <span class="keywordflow">if</span> (np != NULL) {
02224             *ntype = get_token(fp, ntoken, MAXTOKEN);
02225             <span class="keywordflow">return</span> np;
02226         }
02227         <span class="keywordflow">return</span> NULL;
02228     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == LEFTSQBRACK) {
02229         <span class="keywordtype">int</span>             size = 0;
02230         <span class="keywordflow">do</span> {
02231             type = get_token(fp, token, MAXTOKEN);
02232         } <span class="keywordflow">while</span> (type != ENDOFFILE &amp;&amp; type != RIGHTSQBRACK);
02233         <span class="keywordflow">if</span> (type != RIGHTSQBRACK) {
02234             print_error(<span class="stringliteral">"Expected \"]\""</span>, token, type);
02235             <span class="keywordflow">return</span> NULL;
02236         }
02237         type = get_token(fp, token, MAXTOKEN);
02238         <span class="keywordflow">if</span> (type == IMPLICIT)
02239             type = get_token(fp, token, MAXTOKEN);
02240         *ntype = get_token(fp, ntoken, MAXTOKEN);
02241         <span class="keywordflow">if</span> (*ntype == LEFTPAREN) {
02242             <span class="keywordflow">switch</span> (type) {
02243             <span class="keywordflow">case</span> OCTETSTR:
02244                 *ntype = get_token(fp, ntoken, MAXTOKEN);
02245                 <span class="keywordflow">if</span> (*ntype != SIZE) {
02246                     print_error(<span class="stringliteral">"Expected SIZE"</span>, ntoken, *ntype);
02247                     <span class="keywordflow">return</span> NULL;
02248                 }
02249                 size = 1;
02250                 *ntype = get_token(fp, ntoken, MAXTOKEN);
02251                 <span class="keywordflow">if</span> (*ntype != LEFTPAREN) {
02252                     print_error(<span class="stringliteral">"Expected \"(\" after SIZE"</span>, ntoken,
02253                                 *ntype);
02254                     <span class="keywordflow">return</span> NULL;
02255                 }
02256                 <span class="comment">/*</span>
02257 <span class="comment">                 * fall through </span>
02258 <span class="comment">                 */</span>
02259             <span class="keywordflow">case</span> INTEGER:
02260                 *ntype = get_token(fp, ntoken, MAXTOKEN);
02261                 <span class="keywordflow">do</span> {
02262                     <span class="keywordflow">if</span> (*ntype != NUMBER)
02263                         print_error(<span class="stringliteral">"Expected NUMBER"</span>, ntoken, *ntype);
02264                     *ntype = get_token(fp, ntoken, MAXTOKEN);
02265                     <span class="keywordflow">if</span> (*ntype == RANGE) {
02266                         *ntype = get_token(fp, ntoken, MAXTOKEN);
02267                         <span class="keywordflow">if</span> (*ntype != NUMBER)
02268                             print_error(<span class="stringliteral">"Expected NUMBER"</span>, ntoken, *ntype);
02269                         *ntype = get_token(fp, ntoken, MAXTOKEN);
02270                     }
02271                 } <span class="keywordflow">while</span> (*ntype == BAR);
02272                 <span class="keywordflow">if</span> (*ntype != RIGHTPAREN) {
02273                     print_error(<span class="stringliteral">"Expected \")\""</span>, ntoken, *ntype);
02274                     <span class="keywordflow">return</span> NULL;
02275                 }
02276                 *ntype = get_token(fp, ntoken, MAXTOKEN);
02277                 <span class="keywordflow">if</span> (size) {
02278                     <span class="keywordflow">if</span> (*ntype != RIGHTPAREN) {
02279                         print_error(<span class="stringliteral">"Expected \")\" to terminate SIZE"</span>,
02280                                     ntoken, *ntype);
02281                         <span class="keywordflow">return</span> NULL;
02282                     }
02283                     *ntype = get_token(fp, ntoken, MAXTOKEN);
02284                 }
02285             }
02286         }
02287         <span class="keywordflow">return</span> NULL;
02288     } <span class="keywordflow">else</span> {
02289         <span class="keywordflow">if</span> (type == CONVENTION) {
02290             <span class="keywordflow">while</span> (type != SYNTAX &amp;&amp; type != ENDOFFILE) {
02291                 <span class="keywordflow">if</span> (type == DISPLAYHINT) {
02292                     type = get_token(fp, token, MAXTOKEN);
02293                     <span class="keywordflow">if</span> (type != QUOTESTRING)
02294                         print_error(<span class="stringliteral">"DISPLAY-HINT must be string"</span>, token,
02295                                     type);
02296                     <span class="keywordflow">else</span>
02297                         hint = strdup(token);
02298                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == DESCRIPTION &amp;&amp;
02299                            netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
02300                                                   NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
02301                     type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02302                     <span class="keywordflow">if</span> (type != QUOTESTRING)
02303                         print_error(<span class="stringliteral">"DESCRIPTION must be string"</span>, token,
02304                                     type);
02305                     <span class="keywordflow">else</span>
02306                         descr = strdup(quoted_string_buffer);
02307                 } <span class="keywordflow">else</span>
02308                     type =
02309                         get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02310             }
02311             type = get_token(fp, token, MAXTOKEN);
02312             <span class="keywordflow">if</span> (type == OBJECT) {
02313                 type = get_token(fp, token, MAXTOKEN);
02314                 <span class="keywordflow">if</span> (type != IDENTIFIER) {
02315                     print_error(<span class="stringliteral">"Expected IDENTIFIER"</span>, token, type);
02316                     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(hint);
02317                     <span class="keywordflow">return</span> NULL;
02318                 }
02319                 type = OBJID;
02320             }
02321         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == OBJECT) {
02322             type = get_token(fp, token, MAXTOKEN);
02323             <span class="keywordflow">if</span> (type != IDENTIFIER) {
02324                 print_error(<span class="stringliteral">"Expected IDENTIFIER"</span>, token, type);
02325                 <span class="keywordflow">return</span> NULL;
02326             }
02327             type = OBJID;
02328         }
02329 
02330         <span class="keywordflow">if</span> (type == LABEL) {
02331             type = get_tc(token, current_module, NULL, NULL, NULL, NULL);
02332         }
02333 
02334         <span class="comment">/*</span>
02335 <span class="comment">         * textual convention </span>
02336 <span class="comment">         */</span>
02337         <span class="keywordflow">for</span> (i = 0; i &lt; MAXTC; i++) {
02338             <span class="keywordflow">if</span> (tclist[i].type == 0)
02339                 <span class="keywordflow">break</span>;
02340         }
02341 
02342         <span class="keywordflow">if</span> (i == MAXTC) {
02343             print_error(<span class="stringliteral">"Too many textual conventions"</span>, token, type);
02344             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(hint);
02345             <span class="keywordflow">return</span> NULL;
02346         }
02347         <span class="keywordflow">if</span> (!(type &amp; SYNTAX_MASK)) {
02348             print_error(<span class="stringliteral">"Textual convention doesn't map to real type"</span>,
02349                         token, type);
02350             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(hint);
02351             <span class="keywordflow">return</span> NULL;
02352         }
02353         tcp = &amp;tclist[i];
02354         tcp-&gt;modid = current_module;
02355         tcp-&gt;descriptor = strdup(name);
02356         tcp-&gt;hint = hint;
02357         tcp-&gt;description = descr;
02358         tcp-&gt;type = type;
02359         *ntype = get_token(fp, ntoken, MAXTOKEN);
02360         <span class="keywordflow">if</span> (*ntype == LEFTPAREN) {
02361             tcp-&gt;ranges = parse_ranges(fp, &amp;tcp-&gt;ranges);
02362             *ntype = get_token(fp, ntoken, MAXTOKEN);
02363         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*ntype == LEFTBRACKET) {
02364             <span class="comment">/*</span>
02365 <span class="comment">             * if there is an enumeration list, parse it </span>
02366 <span class="comment">             */</span>
02367             tcp-&gt;enums = parse_enumlist(fp, &amp;tcp-&gt;enums);
02368             *ntype = get_token(fp, ntoken, MAXTOKEN);
02369         }
02370         <span class="keywordflow">return</span> NULL;
02371     }
02372 }
02373 
02374 
02375 <span class="comment">/*</span>
02376 <span class="comment"> * Parses an OBJECT TYPE macro.</span>
02377 <span class="comment"> * Returns 0 on error.</span>
02378 <span class="comment"> */</span>
02379 <span class="keyword">static</span> <span class="keyword">struct </span>node *
02380 parse_objecttype(FILE * fp, <span class="keywordtype">char</span> *name)
02381 {
02382     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
02383     <span class="keywordtype">char</span>            token[MAXTOKEN];
02384     <span class="keywordtype">char</span>            nexttoken[MAXTOKEN];
02385     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
02386     <span class="keywordtype">int</span>             nexttype, tctype;
02387     <span class="keyword">register</span> <span class="keyword">struct </span>node *np;
02388 
02389     type = get_token(fp, token, MAXTOKEN);
02390     <span class="keywordflow">if</span> (type != SYNTAX) {
02391         print_error(<span class="stringliteral">"Bad format for OBJECT-TYPE"</span>, token, type);
02392         <span class="keywordflow">return</span> NULL;
02393     }
02394     np = alloc_node(current_module);
02395     <span class="keywordflow">if</span> (np == NULL)
02396         <span class="keywordflow">return</span> (NULL);
02397     type = get_token(fp, token, MAXTOKEN);
02398     <span class="keywordflow">if</span> (type == OBJECT) {
02399         type = get_token(fp, token, MAXTOKEN);
02400         <span class="keywordflow">if</span> (type != IDENTIFIER) {
02401             print_error(<span class="stringliteral">"Expected IDENTIFIER"</span>, token, type);
02402             free_node(np);
02403             <span class="keywordflow">return</span> NULL;
02404         }
02405         type = OBJID;
02406     }
02407     <span class="keywordflow">if</span> (type == LABEL) {
02408         <span class="keywordtype">int</span>             tmp_index;
02409         tctype = get_tc(token, current_module, &amp;tmp_index,
02410                         &amp;np-&gt;enums, &amp;np-&gt;ranges, &amp;np-&gt;hint);
02411         <span class="keywordflow">if</span> (tctype == LABEL &amp;&amp;
02412             netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
02413                                NETSNMP_DS_LIB_MIB_WARNINGS) &gt; 1) {
02414             print_error(<span class="stringliteral">"Warning: No known translation for type"</span>, token,
02415                         type);
02416         }
02417         type = tctype;
02418         np-&gt;tc_index = tmp_index;       <span class="comment">/* store TC for later reference */</span>
02419     }
02420     np-&gt;type = type;
02421     nexttype = get_token(fp, nexttoken, MAXTOKEN);
02422     <span class="keywordflow">switch</span> (type) {
02423     <span class="keywordflow">case</span> SEQUENCE:
02424         <span class="keywordflow">if</span> (nexttype == OF) {
02425             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02426             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02427 
02428         }
02429         <span class="keywordflow">break</span>;
02430     <span class="keywordflow">case</span> INTEGER:
02431     <span class="keywordflow">case</span> INTEGER32:
02432     <span class="keywordflow">case</span> UINTEGER32:
02433     <span class="keywordflow">case</span> UNSIGNED32:
02434     <span class="keywordflow">case</span> COUNTER:
02435     <span class="keywordflow">case</span> GAUGE:
02436     <span class="keywordflow">case</span> BITSTRING:
02437     <span class="keywordflow">case</span> LABEL:
02438         <span class="keywordflow">if</span> (nexttype == LEFTBRACKET) {
02439             <span class="comment">/*</span>
02440 <span class="comment">             * if there is an enumeration list, parse it </span>
02441 <span class="comment">             */</span>
02442             np-&gt;enums = parse_enumlist(fp, &amp;np-&gt;enums);
02443             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02444         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nexttype == LEFTPAREN) {
02445             <span class="comment">/*</span>
02446 <span class="comment">             * if there is a range list, parse it </span>
02447 <span class="comment">             */</span>
02448             np-&gt;ranges = parse_ranges(fp, &amp;np-&gt;ranges);
02449             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02450         }
02451         <span class="keywordflow">break</span>;
02452     <span class="keywordflow">case</span> OCTETSTR:
02453     <span class="keywordflow">case</span> KW_OPAQUE:
02454         <span class="comment">/*</span>
02455 <span class="comment">         * parse any SIZE specification </span>
02456 <span class="comment">         */</span>
02457         <span class="keywordflow">if</span> (nexttype == LEFTPAREN) {
02458             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02459             <span class="keywordflow">if</span> (nexttype == SIZE) {
02460                 nexttype = get_token(fp, nexttoken, MAXTOKEN);
02461                 <span class="keywordflow">if</span> (nexttype == LEFTPAREN) {
02462                     np-&gt;ranges = parse_ranges(fp, &amp;np-&gt;ranges);
02463                     nexttype = get_token(fp, nexttoken, MAXTOKEN);      <span class="comment">/* ) */</span>
02464                     <span class="keywordflow">if</span> (nexttype == RIGHTPAREN) {
02465                         nexttype = get_token(fp, nexttoken, MAXTOKEN);
02466                         <span class="keywordflow">break</span>;
02467                     }
02468                 }
02469             }
02470             print_error(<span class="stringliteral">"Bad SIZE syntax"</span>, token, type);
02471             free_node(np);
02472             <span class="keywordflow">return</span> NULL;
02473         }
02474         <span class="keywordflow">break</span>;
02475     <span class="keywordflow">case</span> OBJID:
02476     <span class="keywordflow">case</span> NETADDR:
02477     <span class="keywordflow">case</span> IPADDR:
02478     <span class="keywordflow">case</span> TIMETICKS:
02479     <span class="keywordflow">case</span> NUL:
02480     <span class="keywordflow">case</span> NSAPADDRESS:
02481     <span class="keywordflow">case</span> COUNTER64:
02482         <span class="keywordflow">break</span>;
02483     <span class="keywordflow">default</span>:
02484         print_error(<span class="stringliteral">"Bad syntax"</span>, token, type);
02485         free_node(np);
02486         <span class="keywordflow">return</span> NULL;
02487     }
02488     <span class="keywordflow">if</span> (nexttype == UNITS) {
02489         type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02490         <span class="keywordflow">if</span> (type != QUOTESTRING) {
02491             print_error(<span class="stringliteral">"Bad UNITS"</span>, quoted_string_buffer, type);
02492             free_node(np);
02493             <span class="keywordflow">return</span> NULL;
02494         }
02495         np-&gt;units = strdup(quoted_string_buffer);
02496         nexttype = get_token(fp, nexttoken, MAXTOKEN);
02497     }
02498     <span class="keywordflow">if</span> (nexttype != ACCESS) {
02499         print_error(<span class="stringliteral">"Should be ACCESS"</span>, nexttoken, nexttype);
02500         free_node(np);
02501         <span class="keywordflow">return</span> NULL;
02502     }
02503     type = get_token(fp, token, MAXTOKEN);
02504     <span class="keywordflow">if</span> (type != READONLY &amp;&amp; type != READWRITE &amp;&amp; type != WRITEONLY
02505         &amp;&amp; type != NOACCESS &amp;&amp; type != READCREATE &amp;&amp; type != ACCNOTIFY) {
02506         print_error(<span class="stringliteral">"Bad ACCESS type"</span>, token, type);
02507         free_node(np);
02508         <span class="keywordflow">return</span> NULL;
02509     }
02510     np-&gt;access = type;
02511     type = get_token(fp, token, MAXTOKEN);
02512     <span class="keywordflow">if</span> (type != STATUS) {
02513         print_error(<span class="stringliteral">"Should be STATUS"</span>, token, type);
02514         free_node(np);
02515         <span class="keywordflow">return</span> NULL;
02516     }
02517     type = get_token(fp, token, MAXTOKEN);
02518     <span class=
"keywordflow">if</span> (type != MANDATORY &amp;&amp; type != CURRENT &amp;&amp; type != KW_OPTIONAL &amp;&amp;
02519         type != OBSOLETE &amp;&amp; type != DEPRECATED) {
02520         print_error(<span class="stringliteral">"Bad STATUS"</span>, token, type);
02521         free_node(np);
02522         <span class="keywordflow">return</span> NULL;
02523     }
02524     np-&gt;status = type;
02525     <span class="comment">/*</span>
02526 <span class="comment">     * Optional parts of the OBJECT-TYPE macro</span>
02527 <span class="comment">     */</span>
02528     type = get_token(fp, token, MAXTOKEN);
02529     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE) {
02530         <span class="keywordflow">switch</span> (type) {
02531         <span class="keywordflow">case</span> DESCRIPTION:
02532             type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02533 
02534             <span class="keywordflow">if</span> (type != QUOTESTRING) {
02535                 print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
02536                 free_node(np);
02537                 <span class="keywordflow">return</span> NULL;
02538             }
02539             <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
02540                                        NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
02541                 np-&gt;description = strdup(quoted_string_buffer);
02542             }
02543             <span class="keywordflow">break</span>;
02544 
02545         <span class="keywordflow">case</span> REFERENCE:
02546             type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02547             <span class="keywordflow">if</span> (type != QUOTESTRING) {
02548                 print_error(<span class="stringliteral">"Bad REFERENCE"</span>, quoted_string_buffer, type);
02549                 free_node(np);
02550                 <span class="keywordflow">return</span> NULL;
02551             }
02552             np-&gt;reference = strdup(quoted_string_buffer);
02553             <span class="keywordflow">break</span>;
02554         <span class="keywordflow">case</span> INDEX:
02555             <span class="keywordflow">if</span> (np-&gt;augments) {
02556                 print_error(<span class="stringliteral">"Cannot have both INDEX and AUGMENTS"</span>, token,
02557                             type);
02558                 free_node(np);
02559                 <span class="keywordflow">return</span> NULL;
02560             }
02561             np-&gt;indexes = getIndexes(fp, &amp;np-&gt;indexes);
02562             <span class="keywordflow">if</span> (np-&gt;indexes == NULL) {
02563                 print_error(<span class="stringliteral">"Bad INDEX list"</span>, token, type);
02564                 free_node(np);
02565                 <span class="keywordflow">return</span> NULL;
02566             }
02567             <span class="keywordflow">break</span>;
02568         <span class="keywordflow">case</span> AUGMENTS:
02569             <span class="keywordflow">if</span> (np-&gt;indexes) {
02570                 print_error(<span class="stringliteral">"Cannot have both INDEX and AUGMENTS"</span>, token,
02571                             type);
02572                 free_node(np);
02573                 <span class="keywordflow">return</span> NULL;
02574             }
02575             np-&gt;indexes = getIndexes(fp, &amp;np-&gt;indexes);
02576             <span class="keywordflow">if</span> (np-&gt;indexes == NULL) {
02577                 print_error(<span class="stringliteral">"Bad AUGMENTS list"</span>, token, type);
02578                 free_node(np);
02579                 <span class="keywordflow">return</span> NULL;
02580             }
02581             np-&gt;augments = strdup(np-&gt;indexes-&gt;ilabel);
02582             free_indexes(&amp;np-&gt;indexes);
02583             <span class="keywordflow">break</span>;
02584         <span class="keywordflow">case</span> DEFVAL:
02585             <span class="comment">/*</span>
02586 <span class="comment">             * Mark's defVal section </span>
02587 <span class="comment">             */</span>
02588             type = get_token(fp, quoted_string_buffer, MAXTOKEN);
02589             <span class="keywordflow">if</span> (type != LEFTBRACKET) {
02590                 print_error(<span class="stringliteral">"Bad DEFAULTVALUE"</span>, quoted_string_buffer,
02591                             type);
02592                 free_node(np);
02593                 <span class="keywordflow">return</span> NULL;
02594             }
02595 
02596             {
02597                 <span class="keywordtype">int</span>             level = 1;
02598                 <span class="keywordtype">char</span>            defbuf[512];
02599 
02600                 defbuf[0] = 0;
02601                 <span class="keywordflow">while</span> (1) {
02602                     type = get_token(fp, quoted_string_buffer, MAXTOKEN);
02603                     <span class="keywordflow">if</span> ((type == RIGHTBRACKET &amp;&amp; --level == 0)
02604                         || type == ENDOFFILE)
02605                         <span class="keywordflow">break</span>;
02606                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == LEFTBRACKET)
02607                         level++;
02608                     <span class="keywordflow">if</span> (type == QUOTESTRING) {
02609                         <span class="keywordflow">if</span> (strlen(defbuf)+2 &lt; <span class=
"keyword">sizeof</span>(defbuf)) {
02610                             defbuf[ strlen(defbuf)+2 ] = 0;
02611                             defbuf[ strlen(defbuf)+1 ] = <span class="charliteral">'"'</span>;
02612                             defbuf[ strlen(defbuf)   ] = <span class="charliteral">'\\'</span>;
02613                         }
02614                         defbuf[ <span class="keyword">sizeof</span>(defbuf)-1 ] = 0;
02615                     }
02616                     strncat(defbuf, quoted_string_buffer,
02617                             <span class="keyword">sizeof</span>(defbuf)-strlen(defbuf));
02618                     defbuf[ <span class="keyword">sizeof</span>(defbuf)-1 ] = 0;
02619                     <span class="keywordflow">if</span> (type == QUOTESTRING) {
02620                         <span class="keywordflow">if</span> (strlen(defbuf)+2 &lt; <span class=
"keyword">sizeof</span>(defbuf)) {
02621                             defbuf[ strlen(defbuf)+2 ] = 0;
02622                             defbuf[ strlen(defbuf)+1 ] = <span class="charliteral">'"'</span>;
02623                             defbuf[ strlen(defbuf)   ] = <span class="charliteral">'\\'</span>;
02624                         }
02625                         defbuf[ <span class="keyword">sizeof</span>(defbuf)-1 ] = 0;
02626                     }
02627                     <span class="keywordflow">if</span> (strlen(defbuf)+1 &lt; <span class=
"keyword">sizeof</span>(defbuf)) {
02628                         defbuf[ strlen(defbuf)+1 ] = 0;
02629                         defbuf[ strlen(defbuf)   ] = <span class="charliteral">' '</span>;
02630                     }
02631                 }
02632 
02633                 <span class="keywordflow">if</span> (type != RIGHTBRACKET) {
02634                     print_error(<span class="stringliteral">"Bad DEFAULTVALUE"</span>, quoted_string_buffer,
02635                                 type);
02636                     free_node(np);
02637                     <span class="keywordflow">return</span> NULL;
02638                 }
02639 
02640                 defbuf[strlen(defbuf) - 1] = 0;
02641                 np-&gt;defaultValue = strdup(defbuf);
02642             }
02643 
02644             <span class="keywordflow">break</span>;
02645 
02646         <span class="keywordflow">case</span> NUM_ENTRIES:
02647             <span class="keywordflow">if</span> (tossObjectIdentifier(fp) != OBJID) {
02648                 print_error(<span class="stringliteral">"Bad Object Identifier"</span>, token, type);
02649                 free_node(np);
02650                 <span class="keywordflow">return</span> NULL;
02651             }
02652             <span class="keywordflow">break</span>;
02653 
02654         <span class="keywordflow">default</span>:
02655             print_error(<span class="stringliteral">"Bad format of optional clauses"</span>, token, type);
02656             free_node(np);
02657             <span class="keywordflow">return</span> NULL;
02658 
02659         }
02660         type = get_token(fp, token, MAXTOKEN);
02661     }
02662     <span class="keywordflow">if</span> (type != EQUALS) {
02663         print_error(<span class="stringliteral">"Bad format"</span>, token, type);
02664         free_node(np);
02665         <span class="keywordflow">return</span> NULL;
02666     }
02667     <span class="keywordflow">return</span> merge_parse_objectid(np, fp, name);
02668 }
02669 
02670 <span class="comment">/*</span>
02671 <span class="comment"> * Parses an OBJECT GROUP macro.</span>
02672 <span class="comment"> * Returns 0 on error.</span>
02673 <span class="comment"> *</span>
02674 <span class="comment"> * Also parses object-identity, since they are similar (ignore STATUS).</span>
02675 <span class="comment"> *   - WJH 10/96</span>
02676 <span class="comment"> */</span>
02677 <span class="keyword">static</span> <span class="keyword">struct </span>node *
02678 parse_objectgroup(FILE * fp, <span class="keywordtype">char</span> *name, <span class=
"keywordtype">int</span> what, <span class="keyword">struct</span> objgroup **ol)
02679 {
02680     <span class="keywordtype">int</span>             type;
02681     <span class="keywordtype">char</span>            token[MAXTOKEN];
02682     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
02683     <span class="keyword">struct </span>node    *np;
02684 
02685     np = alloc_node(current_module);
02686     <span class="keywordflow">if</span> (np == NULL)
02687         <span class="keywordflow">return</span> (NULL);
02688     type = get_token(fp, token, MAXTOKEN);
02689     <span class="keywordflow">if</span> (type == what) {
02690         type = get_token(fp, token, MAXTOKEN);
02691         <span class="keywordflow">if</span> (type != LEFTBRACKET) {
02692             print_error(<span class="stringliteral">"Expected \"{\""</span>, token, type);
02693             <span class="keywordflow">goto</span> skip;
02694         }
02695         <span class="keywordflow">do</span> {
02696             <span class="keyword">struct </span>objgroup *o;
02697             type = get_token(fp, token, MAXTOKEN);
02698             <span class="keywordflow">if</span> (type != LABEL) {
02699                 print_error(<span class="stringliteral">"Bad identifier"</span>, token, type);
02700                 <span class="keywordflow">goto</span> skip;
02701             }
02702             o = (<span class="keyword">struct </span>objgroup *) malloc(<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> objgroup));
02703             o-&gt;line = mibLine;
02704             o-&gt;name = strdup(token);
02705             o-&gt;next = *ol;
02706             *ol = o;
02707             type = get_token(fp, token, MAXTOKEN);
02708         } <span class="keywordflow">while</span> (type == COMMA);
02709         <span class="keywordflow">if</span> (type != RIGHTBRACKET) {
02710             print_error(<span class="stringliteral">"Expected \"}\" after list"</span>, token, type);
02711             <span class="keywordflow">goto</span> skip;
02712         }
02713         type = get_token(fp, token, type);
02714     }
02715     <span class="keywordflow">if</span> (type != STATUS) {
02716         print_error(<span class="stringliteral">"Expected STATUS"</span>, token, type);
02717         <span class="keywordflow">goto</span> skip;
02718     }
02719     type = get_token(fp, token, MAXTOKEN);
02720     <span class="keywordflow">if</span> (type != CURRENT &amp;&amp; type != DEPRECATED &amp;&amp; type != OBSOLETE) {
02721         print_error(<span class="stringliteral">"Bad STATUS value"</span>, token, type);
02722         <span class="keywordflow">goto</span> skip;
02723     }
02724     type = get_token(fp, token, MAXTOKEN);
02725     <span class="keywordflow">if</span> (type != DESCRIPTION) {
02726         print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
02727         <span class="keywordflow">goto</span> skip;
02728     }
02729     type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02730     <span class="keywordflow">if</span> (type != QUOTESTRING) {
02731         print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
02732         free_node(np);
02733         <span class="keywordflow">return</span> NULL;
02734     }
02735     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
02736                                NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
02737         np-&gt;description = strdup(quoted_string_buffer);
02738     }
02739     type = get_token(fp, token, MAXTOKEN);
02740     <span class="keywordflow">if</span> (type == REFERENCE) {
02741         type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02742         <span class="keywordflow">if</span> (type != QUOTESTRING) {
02743             print_error(<span class="stringliteral">"Bad REFERENCE"</span>, quoted_string_buffer, type);
02744             free_node(np);
02745             <span class="keywordflow">return</span> NULL;
02746         }
02747         np-&gt;reference = strdup(quoted_string_buffer);
02748         type = get_token(fp, token, MAXTOKEN);
02749     }
02750     <span class="keywordflow">if</span> (type != EQUALS)
02751         print_error(<span class="stringliteral">"Expected \"::=\""</span>, token, type);
02752   skip:
02753     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE)
02754         type = get_token(fp, token, MAXTOKEN);
02755 
02756     <span class="keywordflow">return</span> merge_parse_objectid(np, fp, name);
02757 }
02758 
02759 <span class="comment">/*</span>
02760 <span class="comment"> * Parses a NOTIFICATION-TYPE macro.</span>
02761 <span class="comment"> * Returns 0 on error.</span>
02762 <span class="comment"> */</span>
02763 <span class="keyword">static</span> <span class="keyword">struct </span>node *
02764 parse_notificationDefinition(FILE * fp, <span class="keywordtype">char</span> *name)
02765 {
02766     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
02767     <span class="keywordtype">char</span>            token[MAXTOKEN];
02768     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
02769     <span class="keyword">register</span> <span class="keyword">struct </span>node *np;
02770 
02771     np = alloc_node(current_module);
02772     <span class="keywordflow">if</span> (np == NULL)
02773         <span class="keywordflow">return</span> (NULL);
02774     type = get_token(fp, token, MAXTOKEN);
02775     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE) {
02776         <span class="keywordflow">switch</span> (type) {
02777         <span class="keywordflow">case</span> DESCRIPTION:
02778             type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02779             <span class="keywordflow">if</span> (type != QUOTESTRING) {
02780                 print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
02781                 free_node(np);
02782                 <span class="keywordflow">return</span> NULL;
02783             }
02784             <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
02785                                        NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
02786                 np-&gt;description = strdup(quoted_string_buffer);
02787             }
02788             <span class="keywordflow">break</span>;
02789         <span class="keywordflow">case</span> REFERENCE:
02790             type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02791             <span class="keywordflow">if</span> (type != QUOTESTRING) {
02792                 print_error(<span class="stringliteral">"Bad REFERENCE"</span>, quoted_string_buffer, type);
02793                 free_node(np);
02794                 <span class="keywordflow">return</span> NULL;
02795             }
02796             np-&gt;reference = strdup(quoted_string_buffer);
02797             <span class="keywordflow">break</span>;
02798         <span class="keywordflow">case</span> OBJECTS:
02799             np-&gt;varbinds = getVarbinds(fp, &amp;np-&gt;varbinds);
02800             <span class="keywordflow">if</span> (!np-&gt;varbinds) {
02801                 print_error(<span class="stringliteral">"Bad OBJECTS list"</span>, token, type);
02802                 free_node(np);
02803                 <span class="keywordflow">return</span> NULL;
02804             }
02805             <span class="keywordflow">break</span>;
02806         <span class="keywordflow">default</span>:
02807             <span class="comment">/*</span>
02808 <span class="comment">             * NOTHING </span>
02809 <span class="comment">             */</span>
02810             <span class="keywordflow">break</span>;
02811         }
02812         type = get_token(fp, token, MAXTOKEN);
02813     }
02814     <span class="keywordflow">return</span> merge_parse_objectid(np, fp, name);
02815 }
02816 
02817 <span class="comment">/*</span>
02818 <span class="comment"> * Parses a TRAP-TYPE macro.</span>
02819 <span class="comment"> * Returns 0 on error.</span>
02820 <span class="comment"> */</span>
02821 <span class="keyword">static</span> <span class="keyword">struct </span>node *
02822 parse_trapDefinition(FILE * fp, <span class="keywordtype">char</span> *name)
02823 {
02824     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
02825     <span class="keywordtype">char</span>            token[MAXTOKEN];
02826     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
02827     <span class="keyword">register</span> <span class="keyword">struct </span>node *np;
02828 
02829     np = alloc_node(current_module);
02830     <span class="keywordflow">if</span> (np == NULL)
02831         <span class="keywordflow">return</span> (NULL);
02832     type = get_token(fp, token, MAXTOKEN);
02833     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE) {
02834         <span class="keywordflow">switch</span> (type) {
02835         <span class="keywordflow">case</span> DESCRIPTION:
02836             type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02837             <span class="keywordflow">if</span> (type != QUOTESTRING) {
02838                 print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
02839                 free_node(np);
02840                 <span class="keywordflow">return</span> NULL;
02841             }
02842             <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
02843                                        NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
02844                 np-&gt;description = strdup(quoted_string_buffer);
02845             }
02846             <span class="keywordflow">break</span>;
02847         <span class="keywordflow">case</span> REFERENCE:
02848             <span class="comment">/* I'm not sure REFERENCEs are legal in smiv1 traps??? */</span>
02849             type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
02850             <span class="keywordflow">if</span> (type != QUOTESTRING) {
02851                 print_error(<span class="stringliteral">"Bad REFERENCE"</span>, quoted_string_buffer, type);
02852                 free_node(np);
02853                 <span class="keywordflow">return</span> NULL;
02854             }
02855             np-&gt;reference = strdup(quoted_string_buffer);
02856             <span class="keywordflow">break</span>;
02857         <span class="keywordflow">case</span> ENTERPRISE:
02858             type = get_token(fp, token, MAXTOKEN);
02859             <span class="keywordflow">if</span> (type == LEFTBRACKET) {
02860                 type = get_token(fp, token, MAXTOKEN);
02861                 <span class="keywordflow">if</span> (type != LABEL) {
02862                     print_error(<span class="stringliteral">"Bad Trap Format"</span>, token, type);
02863                     free_node(np);
02864                     <span class="keywordflow">return</span> NULL;
02865                 }
02866                 np-&gt;parent = strdup(token);
02867                 <span class="comment">/*</span>
02868 <span class="comment">                 * Get right bracket </span>
02869 <span class="comment">                 */</span>
02870                 type = get_token(fp, token, MAXTOKEN);
02871             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == LABEL)
02872                 np-&gt;parent = strdup(token);
02873             <span class="keywordflow">break</span>;
02874         <span class="keywordflow">case</span> VARIABLES:
02875             np-&gt;varbinds = getVarbinds(fp, &amp;np-&gt;varbinds);
02876             <span class="keywordflow">if</span> (!np-&gt;varbinds) {
02877                 print_error(<span class="stringliteral">"Bad VARIABLES list"</span>, token, type);
02878                 free_node(np);
02879                 <span class="keywordflow">return</span> NULL;
02880             }
02881             <span class="keywordflow">break</span>;
02882         <span class="keywordflow">default</span>:
02883             <span class="comment">/*</span>
02884 <span class="comment">             * NOTHING </span>
02885 <span class="comment">             */</span>
02886             <span class="keywordflow">break</span>;
02887         }
02888         type = get_token(fp, token, MAXTOKEN);
02889     }
02890     type = get_token(fp, token, MAXTOKEN);
02891 
02892     np-&gt;label = strdup(name);
02893 
02894     <span class="keywordflow">if</span> (type != NUMBER) {
02895         print_error(<span class="stringliteral">"Expected a Number"</span>, token, type);
02896         free_node(np);
02897         <span class="keywordflow">return</span> NULL;
02898     }
02899     np-&gt;subid = strtoul(token, NULL, 10);
02900     np-&gt;next = alloc_node(current_module);
02901     <span class="keywordflow">if</span> (np-&gt;next == NULL) {
02902         free_node(np);
02903         <span class="keywordflow">return</span> (NULL);
02904     }
02905     np-&gt;next-&gt;parent = np-&gt;parent;
02906     np-&gt;parent = (<span class="keywordtype">char</span> *) malloc(strlen(np-&gt;parent) + 2);
02907     <span class="keywordflow">if</span> (np-&gt;parent == NULL) {
02908         free_node(np-&gt;next);
02909         free_node(np);
02910         <span class="keywordflow">return</span> (NULL);
02911     }
02912     strcpy(np-&gt;parent, np-&gt;next-&gt;parent);
02913     strcat(np-&gt;parent, <span class="stringliteral">"#"</span>);
02914     np-&gt;next-&gt;label = strdup(np-&gt;parent);
02915     <span class="keywordflow">return</span> np;
02916 }
02917 
02918 
02919 <span class="comment">/*</span>
02920 <span class="comment"> * Parses a compliance macro</span>
02921 <span class="comment"> * Returns 0 on error.</span>
02922 <span class="comment"> */</span>
02923 <span class="keyword">static</span> <span class="keywordtype">int</span>
02924 eat_syntax(FILE * fp, <span class="keywordtype">char</span> *token, <span class="keywordtype">int</span> maxtoken)
02925 {
02926     <span class="keywordtype">int</span>             type, nexttype;
02927     <span class="keyword">struct </span>node    *np = alloc_node(current_module);
02928     <span class="keywordtype">char</span>            nexttoken[MAXTOKEN];
02929 
02930     type = get_token(fp, token, maxtoken);
02931     nexttype = get_token(fp, nexttoken, MAXTOKEN);
02932     <span class="keywordflow">switch</span> (type) {
02933     <span class="keywordflow">case</span> INTEGER:
02934     <span class="keywordflow">case</span> INTEGER32:
02935     <span class="keywordflow">case</span> UINTEGER32:
02936     <span class="keywordflow">case</span> UNSIGNED32:
02937     <span class="keywordflow">case</span> COUNTER:
02938     <span class="keywordflow">case</span> GAUGE:
02939     <span class="keywordflow">case</span> BITSTRING:
02940     <span class="keywordflow">case</span> LABEL:
02941         <span class="keywordflow">if</span> (nexttype == LEFTBRACKET) {
02942             <span class="comment">/*</span>
02943 <span class="comment">             * if there is an enumeration list, parse it </span>
02944 <span class="comment">             */</span>
02945             np-&gt;enums = parse_enumlist(fp, &amp;np-&gt;enums);
02946             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02947         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nexttype == LEFTPAREN) {
02948             <span class="comment">/*</span>
02949 <span class="comment">             * if there is a range list, parse it </span>
02950 <span class="comment">             */</span>
02951             np-&gt;ranges = parse_ranges(fp, &amp;np-&gt;ranges);
02952             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02953         }
02954         <span class="keywordflow">break</span>;
02955     <span class="keywordflow">case</span> OCTETSTR:
02956     <span class="keywordflow">case</span> KW_OPAQUE:
02957         <span class="comment">/*</span>
02958 <span class="comment">         * parse any SIZE specification </span>
02959 <span class="comment">         */</span>
02960         <span class="keywordflow">if</span> (nexttype == LEFTPAREN) {
02961             nexttype = get_token(fp, nexttoken, MAXTOKEN);
02962             <span class="keywordflow">if</span> (nexttype == SIZE) {
02963                 nexttype = get_token(fp, nexttoken, MAXTOKEN);
02964                 <span class="keywordflow">if</span> (nexttype == LEFTPAREN) {
02965                     np-&gt;ranges = parse_ranges(fp, &amp;np-&gt;ranges);
02966                     nexttype = get_token(fp, nexttoken, MAXTOKEN);      <span class="comment">/* ) */</span>
02967                     <span class="keywordflow">if</span> (nexttype == RIGHTPAREN) {
02968                         nexttype = get_token(fp, nexttoken, MAXTOKEN);
02969                         <span class="keywordflow">break</span>;
02970                     }
02971                 }
02972             }
02973             print_error(<span class="stringliteral">"Bad SIZE syntax"</span>, token, type);
02974             free_node(np);
02975             <span class="keywordflow">return</span> nexttype;
02976         }
02977         <span class="keywordflow">break</span>;
02978     <span class="keywordflow">case</span> OBJID:
02979     <span class="keywordflow">case</span> NETADDR:
02980     <span class="keywordflow">case</span> IPADDR:
02981     <span class="keywordflow">case</span> TIMETICKS:
02982     <span class="keywordflow">case</span> NUL:
02983     <span class="keywordflow">case</span> NSAPADDRESS:
02984     <span class="keywordflow">case</span> COUNTER64:
02985         <span class="keywordflow">break</span>;
02986     <span class="keywordflow">default</span>:
02987         print_error(<span class="stringliteral">"Bad syntax"</span>, token, type);
02988         free_node(np);
02989         <span class="keywordflow">return</span> nexttype;
02990     }
02991     free_node(np);
02992     <span class="keywordflow">return</span> nexttype;
02993 }
02994 
02995 <span class="keyword">static</span> <span class="keywordtype">int</span>
02996 compliance_lookup(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class=
"keywordtype">int</span> modid)
02997 {
02998     <span class="keywordflow">if</span> (modid == -1) {
02999         <span class="keyword">struct </span>objgroup *op =
03000             (<span class="keyword">struct </span>objgroup *) malloc(<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> objgroup));
03001         op-&gt;next = objgroups;
03002         op-&gt;name = strdup(name);
03003         op-&gt;line = mibLine;
03004         objgroups = op;
03005         <span class="keywordflow">return</span> 1;
03006     } <span class="keywordflow">else</span>
03007         <span class="keywordflow">return</span> find_tree_node(name, modid) != NULL;
03008 }
03009 
03010 <span class="keyword">static</span> <span class="keyword">struct </span>node *
03011 parse_compliance(FILE * fp, <span class="keywordtype">char</span> *name)
03012 {
03013     <span class="keywordtype">int</span>             type;
03014     <span class="keywordtype">char</span>            token[MAXTOKEN];
03015     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
03016     <span class="keyword">struct </span>node    *np;
03017 
03018     np = alloc_node(current_module);
03019     <span class="keywordflow">if</span> (np == NULL)
03020         <span class="keywordflow">return</span> (NULL);
03021     type = get_token(fp, token, MAXTOKEN);
03022     <span class="keywordflow">if</span> (type != STATUS) {
03023         print_error(<span class="stringliteral">"Expected STATUS"</span>, token, type);
03024         <span class="keywordflow">goto</span> skip;
03025     }
03026     type = get_token(fp, token, MAXTOKEN);
03027     <span class="keywordflow">if</span> (type != CURRENT &amp;&amp; type != DEPRECATED &amp;&amp; type != OBSOLETE) {
03028         print_error(<span class="stringliteral">"Bad STATUS"</span>, token, type);
03029         <span class="keywordflow">goto</span> skip;
03030     }
03031     type = get_token(fp, token, MAXTOKEN);
03032     <span class="keywordflow">if</span> (type != DESCRIPTION) {
03033         print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
03034         <span class="keywordflow">goto</span> skip;
03035     }
03036     type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03037     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03038         print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
03039         <span class="keywordflow">goto</span> skip;
03040     }
03041     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
03042                                NETSNMP_DS_LIB_SAVE_MIB_DESCRS))
03043         np-&gt;description = strdup(quoted_string_buffer);
03044     type = get_token(fp, token, MAXTOKEN);
03045     <span class="keywordflow">if</span> (type == REFERENCE) {
03046         type = get_token(fp, quoted_string_buffer, MAXTOKEN);
03047         <span class="keywordflow">if</span> (type != QUOTESTRING) {
03048             print_error(<span class="stringliteral">"Bad REFERENCE"</span>, quoted_string_buffer, type);
03049             <span class="keywordflow">goto</span> skip;
03050         }
03051         np-&gt;reference = strdup(quoted_string_buffer);
03052         type = get_token(fp, token, MAXTOKEN);
03053     }
03054     <span class="keywordflow">if</span> (type != MODULE) {
03055         print_error(<span class="stringliteral">"Expected MODULE"</span>, token, type);
03056         <span class="keywordflow">goto</span> skip;
03057     }
03058     <span class="keywordflow">while</span> (type == MODULE) {
03059         <span class="keywordtype">int</span>             modid = -1;
03060         <span class="keywordtype">char</span>            modname[MAXTOKEN];
03061         type = get_token(fp, token, MAXTOKEN);
03062         <span class="keywordflow">if</span> (type == LABEL
03063             &amp;&amp; strcmp(token, module_name(current_module, modname))) {
03064             modid = read_module_internal(token);
03065             <span class="keywordflow">if</span> (modid != MODULE_LOADED_OK
03066                 &amp;&amp; modid != MODULE_ALREADY_LOADED) {
03067                 print_error(<span class="stringliteral">"Unknown module"</span>, token, type);
03068                 <span class="keywordflow">goto</span> skip;
03069             }
03070             modid = which_module(token);
03071             type = get_token(fp, token, MAXTOKEN);
03072         }
03073         <span class="keywordflow">if</span> (type == MANDATORYGROUPS) {
03074             type = get_token(fp, token, MAXTOKEN);
03075             <span class="keywordflow">if</span> (type != LEFTBRACKET) {
03076                 print_error(<span class="stringliteral">"Expected \"{\""</span>, token, type);
03077                 <span class="keywordflow">goto</span> skip;
03078             }
03079             <span class="keywordflow">do</span> {
03080                 type = get_token(fp, token, MAXTOKEN);
03081                 <span class="keywordflow">if</span> (type != LABEL) {
03082                     print_error(<span class="stringliteral">"Bad group name"</span>, token, type);
03083                     <span class="keywordflow">goto</span> skip;
03084                 }
03085                 <span class="keywordflow">if</span> (!compliance_lookup(token, modid))
03086                     print_error(<span class="stringliteral">"Unknown group"</span>, token, type);
03087                 type = get_token(fp, token, MAXTOKEN);
03088             } <span class="keywordflow">while</span> (type == COMMA);
03089             <span class="keywordflow">if</span> (type != RIGHTBRACKET) {
03090                 print_error(<span class="stringliteral">"Expected \"}\""</span>, token, type);
03091                 <span class="keywordflow">goto</span> skip;
03092             }
03093             type = get_token(fp, token, MAXTOKEN);
03094         }
03095         <span class="keywordflow">while</span> (type == GROUP || type == OBJECT) {
03096             <span class="keywordflow">if</span> (type == GROUP) {
03097                 type = get_token(fp, token, MAXTOKEN);
03098                 <span class="keywordflow">if</span> (type != LABEL) {
03099                     print_error(<span class="stringliteral">"Bad group name"</span>, token, type);
03100                     <span class="keywordflow">goto</span> skip;
03101                 }
03102                 <span class="keywordflow">if</span> (!compliance_lookup(token, modid))
03103                     print_error(<span class="stringliteral">"Unknown group"</span>, token, type);
03104                 type = get_token(fp, token, MAXTOKEN);
03105             } <span class="keywordflow">else</span> {
03106                 type = get_token(fp, token, MAXTOKEN);
03107                 <span class="keywordflow">if</span> (type != LABEL) {
03108                     print_error(<span class="stringliteral">"Bad object name"</span>, token, type);
03109                     <span class="keywordflow">goto</span> skip;
03110                 }
03111                 <span class="keywordflow">if</span> (!compliance_lookup(token, modid))
03112                     print_error(<span class="stringliteral">"Unknown group"</span>, token, type);
03113                 type = get_token(fp, token, MAXTOKEN);
03114                 <span class="keywordflow">if</span> (type == SYNTAX)
03115                     type = eat_syntax(fp, token, MAXTOKEN);
03116                 <span class="keywordflow">if</span> (type == WRSYNTAX)
03117                     type = eat_syntax(fp, token, MAXTOKEN);
03118                 <span class="keywordflow">if</span> (type == MINACCESS) {
03119                     type = get_token(fp, token, MAXTOKEN);
03120                     <span class="keywordflow">if</span> (type != NOACCESS &amp;&amp; type != ACCNOTIFY
03121                         &amp;&amp; type != READONLY &amp;&amp; type != WRITEONLY
03122                         &amp;&amp; type != READCREATE &amp;&amp; type != READWRITE) {
03123                         print_error(<span class="stringliteral">"Bad MIN-ACCESS spec"</span>, token, type);
03124                         <span class="keywordflow">goto</span> skip;
03125                     }
03126                     type = get_token(fp, token, MAXTOKEN);
03127                 }
03128             }
03129             <span class="keywordflow">if</span> (type != DESCRIPTION) {
03130                 print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
03131                 <span class="keywordflow">goto</span> skip;
03132             }
03133             type = get_token(fp, token, MAXTOKEN);
03134             <span class="keywordflow">if</span> (type != QUOTESTRING) {
03135                 print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, token, type);
03136                 <span class="keywordflow">goto</span> skip;
03137             }
03138             type = get_token(fp, token, MAXTOKEN);
03139         }
03140     }
03141   skip:
03142     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE)
03143         type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03144 
03145     <span class="keywordflow">return</span> merge_parse_objectid(np, fp, name);
03146 }
03147 
03148 
03149 <span class="comment">/*</span>
03150 <span class="comment"> * Parses a capabilities macro</span>
03151 <span class="comment"> * Returns 0 on error.</span>
03152 <span class="comment"> */</span>
03153 <span class="keyword">static</span> <span class="keyword">struct </span>node *
03154 parse_capabilities(FILE * fp, <span class="keywordtype">char</span> *name)
03155 {
03156     <span class="keywordtype">int</span>             type;
03157     <span class="keywordtype">char</span>            token[MAXTOKEN];
03158     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
03159     <span class="keyword">struct </span>node    *np;
03160 
03161     np = alloc_node(current_module);
03162     <span class="keywordflow">if</span> (np == NULL)
03163         <span class="keywordflow">return</span> (NULL);
03164     type = get_token(fp, token, MAXTOKEN);
03165     <span class="keywordflow">if</span> (type != PRODREL) {
03166         print_error(<span class="stringliteral">"Expected PRODUCT-RELEASE"</span>, token, type);
03167         <span class="keywordflow">goto</span> skip;
03168     }
03169     type = get_token(fp, token, MAXTOKEN);
03170     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03171         print_error(<span class="stringliteral">"Expected STRING after PRODUCT-RELEASE"</span>, token, type);
03172         <span class="keywordflow">goto</span> skip;
03173     }
03174     type = get_token(fp, token, MAXTOKEN);
03175     <span class="keywordflow">if</span> (type != STATUS) {
03176         print_error(<span class="stringliteral">"Expected STATUS"</span>, token, type);
03177         <span class="keywordflow">goto</span> skip;
03178     }
03179     type = get_token(fp, token, MAXTOKEN);
03180     <span class="keywordflow">if</span> (type != CURRENT &amp;&amp; type != OBSOLETE) {
03181         print_error(<span class="stringliteral">"STATUS should be current or obsolete"</span>, token, type);
03182         <span class="keywordflow">goto</span> skip;
03183     }
03184     type = get_token(fp, token, MAXTOKEN);
03185     <span class="keywordflow">if</span> (type != DESCRIPTION) {
03186         print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
03187         <span class="keywordflow">goto</span> skip;
03188     }
03189     type = get_token(fp, token, MAXTOKEN);
03190     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03191         print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, token, type);
03192         <span class="keywordflow">goto</span> skip;
03193     }
03194     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
03195                                NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
03196         np-&gt;description = strdup(token);
03197     }
03198     type = get_token(fp, token, MAXTOKEN);
03199     <span class="keywordflow">if</span> (type == REFERENCE) {
03200         type = get_token(fp, token, MAXTOKEN);
03201         <span class="keywordflow">if</span> (type != QUOTESTRING) {
03202             print_error(<span class="stringliteral">"Bad REFERENCE"</span>, token, type);
03203             <span class="keywordflow">goto</span> skip;
03204         }
03205         np-&gt;reference = strdup(token);
03206         type = get_token(fp, token, type);
03207     }
03208     <span class="keywordflow">while</span> (type == SUPPORTS) {
03209         <span class="keywordtype">int</span>             modid;
03210         <span class="keyword">struct </span>tree    *tp;
03211 
03212         type = get_token(fp, token, MAXTOKEN);
03213         <span class="keywordflow">if</span> (type != LABEL) {
03214             print_error(<span class="stringliteral">"Bad module name"</span>, token, type);
03215             <span class="keywordflow">goto</span> skip;
03216         }
03217         modid = read_module_internal(token);
03218         <span class="keywordflow">if</span> (modid != MODULE_LOADED_OK &amp;&amp; modid != MODULE_ALREADY_LOADED) {
03219             print_error(<span class="stringliteral">"Module not found"</span>, token, type);
03220             <span class="keywordflow">goto</span> skip;
03221         }
03222         modid = which_module(token);
03223         type = get_token(fp, token, MAXTOKEN);
03224         <span class="keywordflow">if</span> (type != INCLUDES) {
03225             print_error(<span class="stringliteral">"Expected INCLUDES"</span>, token, type);
03226             <span class="keywordflow">goto</span> skip;
03227         }
03228         type = get_token(fp, token, MAXTOKEN);
03229         <span class="keywordflow">if</span> (type != LEFTBRACKET) {
03230             print_error(<span class="stringliteral">"Expected \"{\""</span>, token, type);
03231             <span class="keywordflow">goto</span> skip;
03232         }
03233         <span class="keywordflow">do</span> {
03234             type = get_token(fp, token, MAXTOKEN);
03235             <span class="keywordflow">if</span> (type != LABEL) {
03236                 print_error(<span class="stringliteral">"Expected group name"</span>, token, type);
03237                 <span class="keywordflow">goto</span> skip;
03238             }
03239             tp = find_tree_node(token, modid);
03240             <span class="keywordflow">if</span> (!tp)
03241                 print_error(<span class="stringliteral">"Group not found in module"</span>, token, type);
03242             type = get_token(fp, token, MAXTOKEN);
03243         } <span class="keywordflow">while</span> (type == COMMA);
03244         <span class="keywordflow">if</span> (type != RIGHTBRACKET) {
03245             print_error(<span class="stringliteral">"Expected \"}\" after group list"</span>, token, type);
03246             <span class="keywordflow">goto</span> skip;
03247         }
03248         type = get_token(fp, token, MAXTOKEN);
03249         <span class="keywordflow">while</span> (type == VARIATION) {
03250             type = get_token(fp, token, MAXTOKEN);
03251             <span class="keywordflow">if</span> (type != LABEL) {
03252                 print_error(<span class="stringliteral">"Bad object name"</span>, token, type);
03253                 <span class="keywordflow">goto</span> skip;
03254             }
03255             tp = find_tree_node(token, modid);
03256             <span class="keywordflow">if</span> (!tp)
03257                 print_error(<span class="stringliteral">"Object not found in module"</span>, token, type);
03258             type = get_token(fp, token, MAXTOKEN);
03259             <span class="keywordflow">if</span> (type == SYNTAX) {
03260                 type = eat_syntax(fp, token, MAXTOKEN);
03261             }
03262             <span class="keywordflow">if</span> (type == WRSYNTAX) {
03263                 type = eat_syntax(fp, token, MAXTOKEN);
03264             }
03265             <span class="keywordflow">if</span> (type == ACCESS) {
03266                 type = get_token(fp, token, MAXTOKEN);
03267                 <span class="keywordflow">if</span> (type != ACCNOTIFY &amp;&amp; type != READONLY
03268                     &amp;&amp; type != READWRITE &amp;&amp; type != READCREATE
03269                     &amp;&amp; type != WRITEONLY &amp;&amp; type != NOTIMPL) {
03270                     print_error(<span class="stringliteral">"Bad ACCESS"</span>, token, type);
03271                     <span class="keywordflow">goto</span> skip;
03272                 }
03273                 type = get_token(fp, token, MAXTOKEN);
03274             }
03275             <span class="keywordflow">if</span> (type == CREATEREQ) {
03276                 type = get_token(fp, token, MAXTOKEN);
03277                 <span class="keywordflow">if</span> (type != LEFTBRACKET) {
03278                     print_error(<span class="stringliteral">"Expected \"{\""</span>, token, type);
03279                     <span class="keywordflow">goto</span> skip;
03280                 }
03281                 <span class="keywordflow">do</span> {
03282                     type = get_token(fp, token, MAXTOKEN);
03283                     <span class="keywordflow">if</span> (type != LABEL) {
03284                         print_error(<span class="stringliteral">"Bad object name in list"</span>, token,
03285                                     type);
03286                         <span class="keywordflow">goto</span> skip;
03287                     }
03288                     type = get_token(fp, token, MAXTOKEN);
03289                 } <span class="keywordflow">while</span> (type == COMMA);
03290                 <span class="keywordflow">if</span> (type != RIGHTBRACKET) {
03291                     print_error(<span class="stringliteral">"Expected \"}\" after list"</span>, token, type);
03292                     <span class="keywordflow">goto</span> skip;
03293                 }
03294                 type = get_token(fp, token, MAXTOKEN);
03295             }
03296             <span class="keywordflow">if</span> (type == DEFVAL) {
03297                 <span class="keywordtype">int</span>             level = 1;
03298                 type = get_token(fp, token, MAXTOKEN);
03299                 <span class="keywordflow">if</span> (type != LEFTBRACKET) {
03300                     print_error(<span class="stringliteral">"Expected \"{\" after DEFVAL"</span>, token,
03301                                 type);
03302                     <span class="keywordflow">goto</span> skip;
03303                 }
03304                 <span class="keywordflow">do</span> {
03305                     type = get_token(fp, token, MAXTOKEN);
03306                     <span class="keywordflow">if</span> (type == LEFTBRACKET)
03307                         level++;
03308                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == RIGHTBRACKET)
03309                         level--;
03310                 } <span class="keywordflow">while</span> (type != RIGHTBRACKET &amp;&amp; type != ENDOFFILE
03311                          &amp;&amp; level != 0);
03312                 <span class="keywordflow">if</span> (type != RIGHTBRACKET) {
03313                     print_error(<span class="stringliteral">"Missing \"}\" after DEFVAL"</span>, token, type);
03314                     <span class="keywordflow">goto</span> skip;
03315                 }
03316                 type = get_token(fp, token, MAXTOKEN);
03317             }
03318             <span class="keywordflow">if</span> (type != DESCRIPTION) {
03319                 print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
03320                 <span class="keywordflow">goto</span> skip;
03321             }
03322             type = get_token(fp, token, MAXTOKEN);
03323             <span class="keywordflow">if</span> (type != QUOTESTRING) {
03324                 print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, token, type);
03325                 <span class="keywordflow">goto</span> skip;
03326             }
03327             type = get_token(fp, token, MAXTOKEN);
03328         }
03329     }
03330     <span class="keywordflow">if</span> (type != EQUALS)
03331         print_error(<span class="stringliteral">"Expected \"::=\""</span>, token, type);
03332   skip:
03333     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE) {
03334         type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03335     }
03336     <span class="keywordflow">return</span> merge_parse_objectid(np, fp, name);
03337 }
03338 
03339 <span class="comment">/*</span>
03340 <span class="comment"> * Parses a module identity macro</span>
03341 <span class="comment"> * Returns 0 on error.</span>
03342 <span class="comment"> */</span>
03343 <span class="keyword">static</span> <span class="keywordtype">void</span>
03344 check_utc(<span class="keyword">const</span> <span class="keywordtype">char</span> *utc)
03345 {
03346     <span class="keywordtype">int</span>             len, year, month, day, hour, minute;
03347 
03348     len = strlen(utc);
03349     <span class="keywordflow">if</span> (utc[len - 1] != <span class=
"charliteral">'Z'</span> &amp;&amp; utc[len - 1] != <span class="charliteral">'z'</span>) {
03350         print_error(<span class="stringliteral">"Timestamp should end with Z"</span>, utc, QUOTESTRING);
03351         <span class="keywordflow">return</span>;
03352     }
03353     <span class="keywordflow">if</span> (len == 11) {
03354         len =
03355             sscanf(utc, <span class="stringliteral">"%2d%2d%2d%2d%2dZ"</span>, &amp;year, &amp;month, &amp;day, &amp;hour,
03356                    &amp;minute);
03357         year += 1900;
03358     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (len == 13)
03359         len =
03360             sscanf(utc, <span class="stringliteral">"%4d%2d%2d%2d%2dZ"</span>, &amp;year, &amp;month, &amp;day, &amp;hour,
03361                    &amp;minute);
03362     <span class="keywordflow">else</span> {
03363         print_error(<span class="stringliteral">"Bad timestamp format (11 or 13 characters)"</span>,
03364                     utc, QUOTESTRING);
03365         <span class="keywordflow">return</span>;
03366     }
03367     <span class="keywordflow">if</span> (len != 5) {
03368         print_error(<span class="stringliteral">"Bad timestamp format"</span>, utc, QUOTESTRING);
03369         <span class="keywordflow">return</span>;
03370     }
03371     <span class="keywordflow">if</span> (month &lt; 1 || month &gt; 12)
03372         print_error(<span class="stringliteral">"Bad month in timestamp"</span>, utc, QUOTESTRING);
03373     <span class="keywordflow">if</span> (day &lt; 1 || day &gt; 31)
03374         print_error(<span class="stringliteral">"Bad day in timestamp"</span>, utc, QUOTESTRING);
03375     <span class="keywordflow">if</span> (hour &lt; 0 || hour &gt; 23)
03376         print_error(<span class="stringliteral">"Bad hour in timestamp"</span>, utc, QUOTESTRING);
03377     <span class="keywordflow">if</span> (minute &lt; 0 || minute &gt; 59)
03378         print_error(<span class="stringliteral">"Bad minute in timestamp"</span>, utc, QUOTESTRING);
03379 }
03380 
03381 <span class="keyword">static</span> <span class="keyword">struct </span>node *
03382 parse_moduleIdentity(FILE * fp, <span class="keywordtype">char</span> *name)
03383 {
03384     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
03385     <span class="keywordtype">char</span>            token[MAXTOKEN];
03386     <span class="keywordtype">char</span>            quoted_string_buffer[MAXQUOTESTR];
03387     <span class="keyword">register</span> <span class="keyword">struct </span>node *np;
03388 
03389     np = alloc_node(current_module);
03390     <span class="keywordflow">if</span> (np == NULL)
03391         <span class="keywordflow">return</span> (NULL);
03392     type = get_token(fp, token, MAXTOKEN);
03393     <span class="keywordflow">if</span> (type != LASTUPDATED) {
03394         print_error(<span class="stringliteral">"Expected LAST-UPDATED"</span>, token, type);
03395         <span class="keywordflow">goto</span> skip;
03396     }
03397     type = get_token(fp, token, MAXTOKEN);
03398     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03399         print_error(<span class="stringliteral">"Need STRING for LAST-UPDATED"</span>, token, type);
03400         <span class="keywordflow">goto</span> skip;
03401     }
03402     check_utc(token);
03403     type = get_token(fp, token, MAXTOKEN);
03404     <span class="keywordflow">if</span> (type != ORGANIZATION) {
03405         print_error(<span class="stringliteral">"Expected ORGANIZATION"</span>, token, type);
03406         <span class="keywordflow">goto</span> skip;
03407     }
03408     type = get_token(fp, token, MAXTOKEN);
03409     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03410         print_error(<span class="stringliteral">"Bad ORGANIZATION"</span>, token, type);
03411         <span class="keywordflow">goto</span> skip;
03412     }
03413     type = get_token(fp, token, MAXTOKEN);
03414     <span class="keywordflow">if</span> (type != CONTACTINFO) {
03415         print_error(<span class="stringliteral">"Expected CONTACT-INFO"</span>, token, type);
03416         <span class="keywordflow">goto</span> skip;
03417     }
03418     type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03419     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03420         print_error(<span class="stringliteral">"Bad CONTACT-INFO"</span>, quoted_string_buffer, type);
03421         <span class="keywordflow">goto</span> skip;
03422     }
03423     type = get_token(fp, token, MAXTOKEN);
03424     <span class="keywordflow">if</span> (type != DESCRIPTION) {
03425         print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
03426         <span class="keywordflow">goto</span> skip;
03427     }
03428     type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03429     <span class="keywordflow">if</span> (type != QUOTESTRING) {
03430         print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
03431         <span class="keywordflow">goto</span> skip;
03432     }
03433     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
03434                                NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {
03435         np-&gt;description = strdup(quoted_string_buffer);
03436     }
03437     type = get_token(fp, token, MAXTOKEN);
03438     <span class="keywordflow">while</span> (type == REVISION) {
03439         type = get_token(fp, token, MAXTOKEN);
03440         <span class="keywordflow">if</span> (type != QUOTESTRING) {
03441             print_error(<span class="stringliteral">"Bad REVISION"</span>, token, type);
03442             <span class="keywordflow">goto</span> skip;
03443         }
03444         check_utc(token);
03445         type = get_token(fp, token, MAXTOKEN);
03446         <span class="keywordflow">if</span> (type != DESCRIPTION) {
03447             print_error(<span class="stringliteral">"Expected DESCRIPTION"</span>, token, type);
03448             <span class="keywordflow">goto</span> skip;
03449         }
03450         type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03451         <span class="keywordflow">if</span> (type != QUOTESTRING) {
03452             print_error(<span class="stringliteral">"Bad DESCRIPTION"</span>, quoted_string_buffer, type);
03453             <span class="keywordflow">goto</span> skip;
03454         }
03455         type = get_token(fp, token, MAXTOKEN);
03456     }
03457     <span class="keywordflow">if</span> (type != EQUALS)
03458         print_error(<span class="stringliteral">"Expected \"::=\""</span>, token, type);
03459   skip:
03460     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE) {
03461         type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);
03462     }
03463     <span class="keywordflow">return</span> merge_parse_objectid(np, fp, name);
03464 }
03465 
03466 
03467 <span class="comment">/*</span>
03468 <span class="comment"> * Parses a MACRO definition</span>
03469 <span class="comment"> * Expect BEGIN, discard everything to end.</span>
03470 <span class="comment"> * Returns 0 on error.</span>
03471 <span class="comment"> */</span>
03472 <span class="keyword">static</span> <span class="keyword">struct </span>node *
03473 parse_macro(FILE * fp, <span class="keywordtype">char</span> *name)
03474 {
03475     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
03476     <span class="keywordtype">char</span>            token[MAXTOKEN];
03477     <span class="keyword">struct </span>node    *np;
03478     <span class="keywordtype">int</span>             iLine = mibLine;
03479 
03480     np = alloc_node(current_module);
03481     <span class="keywordflow">if</span> (np == NULL)
03482         <span class="keywordflow">return</span> (NULL);
03483     type = get_token(fp, token, <span class="keyword">sizeof</span>(token));
03484     <span class="keywordflow">while</span> (type != EQUALS &amp;&amp; type != ENDOFFILE) {
03485         type = get_token(fp, token, <span class="keyword">sizeof</span>(token));
03486     }
03487     <span class="keywordflow">if</span> (type != EQUALS)
03488         <span class="keywordflow">return</span> NULL;
03489     <span class="keywordflow">while</span> (type != BEGIN &amp;&amp; type != ENDOFFILE) {
03490         type = get_token(fp, token, <span class="keyword">sizeof</span>(token));
03491     }
03492     <span class="keywordflow">if</span> (type != BEGIN)
03493         <span class="keywordflow">return</span> NULL;
03494     <span class="keywordflow">while</span> (type != END &amp;&amp; type != ENDOFFILE) {
03495         type = get_token(fp, token, <span class="keyword">sizeof</span>(token));
03496     }
03497     <span class="keywordflow">if</span> (type != END)
03498         <span class="keywordflow">return</span> NULL;
03499 
03500     <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
03501                            NETSNMP_DS_LIB_MIB_WARNINGS)) {
03502         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
03503                  <span class="stringliteral">"%s MACRO (lines %d..%d parsed and ignored).\n"</span>, name,
03504                  iLine, mibLine);
03505     }
03506 
03507     <span class="keywordflow">return</span> np;
03508 }
03509 
03510 <span class="comment">/*</span>
03511 <span class="comment"> * Parses a module import clause</span>
03512 <span class="comment"> *   loading any modules referenced</span>
03513 <span class="comment"> */</span>
03514 <span class="keyword">static</span> <span class="keywordtype">void</span>
03515 parse_imports(FILE * fp)
03516 {
03517     <span class="keyword">register</span> <span class="keywordtype">int</span>    type;
03518     <span class="keywordtype">char</span>            token[MAXTOKEN];
03519     <span class="keywordtype">char</span>            modbuf[256];
03520 <span class="preprocessor">#define MAX_IMPORTS     256</span>
03521     <span class="keyword">struct </span>module_import import_list[MAX_IMPORTS];
03522     <span class="keywordtype">int</span>             this_module;
03523     <span class="keyword">struct </span>module  *mp;
03524 
03525     <span class="keywordtype">int</span>             import_count = 0;   <span class=
"comment">/* Total number of imported descriptors */</span>
03526     <span class="keywordtype">int</span>             i = 0, old_i;       <span class=
"comment">/* index of first import from each module */</span>
03527 
03528     type = get_token(fp, token, MAXTOKEN);
03529 
03530     <span class="comment">/*</span>
03531 <span class="comment">     * Parse the IMPORTS clause</span>
03532 <span class="comment">     */</span>
03533     <span class="keywordflow">while</span> (type != SEMI &amp;&amp; type != ENDOFFILE) {
03534         <span class="keywordflow">if</span> (type == LABEL) {
03535             <span class="keywordflow">if</span> (import_count == MAX_IMPORTS) {
03536                 print_error(<span class="stringliteral">"Too many imported symbols"</span>, token, type);
03537                 <span class="keywordflow">do</span> {
03538                     type = get_token(fp, token, MAXTOKEN);
03539                 } <span class="keywordflow">while</span> (type != SEMI &amp;&amp; type != ENDOFFILE);
03540                 <span class="keywordflow">return</span>;
03541             }
03542             import_list[import_count++].label = strdup(token);
03543         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == FROM) {
03544             type = get_token(fp, token, MAXTOKEN);
03545             <span class="keywordflow">if</span> (import_count == i) {    <span class=
"comment">/* All imports are handled internally */</span>
03546                 type = get_token(fp, token, MAXTOKEN);
03547                 <span class="keywordflow">continue</span>;
03548             }
03549             this_module = which_module(token);
03550 
03551             <span class="keywordflow">for</span> (old_i = i; i &lt; import_count; ++i)
03552                 import_list[i].modid = this_module;
03553 
03554             <span class="comment">/*</span>
03555 <span class="comment">             * Recursively read any pre-requisite modules</span>
03556 <span class="comment">             */</span>
03557             <span class="keywordflow">if</span> (read_module_internal(token) == MODULE_NOT_FOUND) {
03558                 <span class="keywordtype">int</span> found = 0;
03559                 <span class="keywordflow">for</span> (; old_i &lt; import_count; ++old_i) {
03560                     found += read_import_replacements(token, &amp;import_list[old_i]);
03561                 }
03562                 <span class="keywordflow">if</span> (!found)
03563                     print_module_not_found(token);
03564             }
03565         }
03566         type = get_token(fp, token, MAXTOKEN);
03567     }
03568 
03569     <span class="comment">/*</span>
03570 <span class="comment">     * Save the import information</span>
03571 <span class="comment">     *   in the global module table</span>
03572 <span class="comment">     */</span>
03573     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
03574         <span class="keywordflow">if</span> (mp-&gt;modid == current_module) {
03575             <span class="keywordflow">if</span> (import_count == 0)
03576                 <span class="keywordflow">return</span>;
03577             <span class="keywordflow">if</span> (mp-&gt;imports &amp;&amp; (mp-&gt;imports != root_imports)) {
03578                 <span class="comment">/*</span>
03579 <span class="comment">                 * this can happen if all modules are in one source file. </span>
03580 <span class="comment">                 */</span>
03581                 <span class="keywordflow">for</span> (i = 0; i &lt; mp-&gt;no_imports; ++i) {
03582                     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>,
03583                                 <span class="stringliteral">"#### freeing Module %d '%s' %d\n"</span>,
03584                                 mp-&gt;modid, mp-&gt;imports[i].label,
03585                                 mp-&gt;imports[i].modid));
03586                     free((<span class="keywordtype">char</span> *) mp-&gt;imports[i].label);
03587                 }
03588                 free((<span class="keywordtype">char</span> *) mp-&gt;imports);
03589             }
03590             mp-&gt;imports = (<span class="keyword">struct </span>module_import *)
03591                 calloc(import_count, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> module_import));
03592             <span class="keywordflow">if</span> (mp-&gt;imports == NULL)
03593                 <span class="keywordflow">return</span>;
03594             <span class="keywordflow">for</span> (i = 0; i &lt; import_count; ++i) {
03595                 mp-&gt;imports[i].label = import_list[i].label;
03596                 mp-&gt;imports[i].modid = import_list[i].modid;
03597                 DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>,
03598                             <span class="stringliteral">"#### adding Module %d '%s' %d\n"</span>, mp-&gt;modid,
03599                             mp-&gt;imports[i].label, mp-&gt;imports[i].modid));
03600             }
03601             mp-&gt;no_imports = import_count;
03602             <span class="keywordflow">return</span>;
03603         }
03604 
03605     <span class="comment">/*</span>
03606 <span class="comment">     * Shouldn't get this far</span>
03607 <span class="comment">     */</span>
03608     print_module_not_found(module_name(current_module, modbuf));
03609     <span class="keywordflow">return</span>;
03610 }
03611 
03612 
03613 
03614 <span class="comment">/*</span>
03615 <span class="comment"> * MIB module handling routines</span>
03616 <span class="comment"> */</span>
03617 
03618 <span class="keyword">static</span> <span class="keywordtype">void</span>
03619 dump_module_list(<span class="keywordtype">void</span>)
03620 {
03621     <span class="keyword">struct </span>module  *mp = module_head;
03622 
03623     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class="stringliteral">"Module list:\n"</span>));
03624     <span class="keywordflow">while</span> (mp) {
03625         DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"  %s %d %s %d\n"</span>, mp-&gt;name, mp-&gt;modid,
03626                     mp-&gt;file, mp-&gt;no_imports));
03627         mp = mp-&gt;next;
03628     }
03629 }
03630 
03631 <span class="keywordtype">int</span>
03632 which_module(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
03633 {
03634     <span class="keyword">struct </span>module  *mp;
03635 
03636     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
03637         <span class="keywordflow">if</span> (!label_compare(mp-&gt;name, name))
03638             <span class="keywordflow">return</span> (mp-&gt;modid);
03639 
03640     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Module %s not found\n"</span>, name));
03641     <span class="keywordflow">return</span> (-1);
03642 }
03643 
03644 <span class="comment">/*</span>
03645 <span class="comment"> * module_name - copy module name to user buffer, return ptr to same.</span>
03646 <span class="comment"> */</span>
03647 <span class="keywordtype">char</span>           *
03648 module_name(<span class="keywordtype">int</span> modid, <span class="keywordtype">char</span> *cp)
03649 {
03650     <span class="keyword">struct </span>module  *mp;
03651 
03652     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
03653         <span class="keywordflow">if</span> (mp-&gt;modid == modid) {
03654             strcpy(cp, mp-&gt;name);
03655             <span class="keywordflow">return</span> (cp);
03656         }
03657 
03658     <span class="keywordflow">if</span> (modid != -1) DEBUGMSGTL((<span class=
"stringliteral">"parse-mibs"</span>, <span class="stringliteral">"Module %d not found\n"</span>, modid));
03659     sprintf(cp, <span class="stringliteral">"#%d"</span>, modid);
03660     <span class="keywordflow">return</span> (cp);
03661 }
03662 
03663 <span class="comment">/*</span>
03664 <span class="comment"> *  Backwards compatability</span>
03665 <span class="comment"> *  Read newer modules that replace the one specified:-</span>
03666 <span class="comment"> *      either all of them (read_module_replacements),</span>
03667 <span class="comment"> *      or those relating to a specified identifier (read_import_replacements)</span>
03668 <span class="comment"> *      plus an interface to add new replacement requirements</span>
03669 <span class="comment"> */</span>
03670 <span class="keywordtype">void</span>
03671 add_module_replacement(<span class="keyword">const</span> <span class="keywordtype">char</span> *old_module,
03672                        <span class="keyword">const</span> <span class="keywordtype">char</span> *new_module_name,
03673                        <span class="keyword">const</span> <span class="keywordtype">char</span> *tag, <span class=
"keywordtype">int</span> len)
03674 {
03675     <span class="keyword">struct </span>module_compatability *mcp;
03676 
03677     mcp = (<span class="keyword">struct </span>module_compatability *)
03678         calloc(1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> module_compatability));
03679     <span class="keywordflow">if</span> (mcp == NULL)
03680         <span class="keywordflow">return</span>;
03681 
03682     mcp-&gt;old_module = strdup(old_module);
03683     mcp-&gt;new_module = strdup(new_module_name);
03684     <span class="keywordflow">if</span> (tag)
03685         mcp-&gt;tag = strdup(tag);
03686     mcp-&gt;tag_len = len;
03687 
03688     mcp-&gt;next = module_map_head;
03689     module_map_head = mcp;
03690 }
03691 
03692 <span class="keyword">static</span> <span class="keywordtype">int</span>
03693 read_module_replacements(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
03694 {
03695     <span class="keyword">struct </span>module_compatability *mcp;
03696 
03697     <span class="keywordflow">for</span> (mcp = module_map_head; mcp; mcp = mcp-&gt;next) {
03698         <span class="keywordflow">if</span> (!label_compare(mcp-&gt;old_module, name)) {
03699             <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
03700                                    NETSNMP_DS_LIB_MIB_WARNINGS)) {
03701                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
03702                          <span class="stringliteral">"Loading replacement module %s for %s (%s)\n"</span>,
03703                          mcp-&gt;new_module, name, File);
03704             }
03705             (void) read_module(mcp-&gt;new_module);
03706             <span class="keywordflow">return</span> 1;
03707         }
03708     }
03709     <span class="keywordflow">return</span> 0;
03710 }
03711 
03712 <span class="keyword">static</span> <span class="keywordtype">int</span>
03713 read_import_replacements(<span class="keyword">const</span> <span class="keywordtype">char</span> *old_module_name,
03714                          <span class="keyword">struct</span> module_import *identifier)
03715 {
03716     <span class="keyword">struct </span>module_compatability *mcp;
03717 
03718     <span class="comment">/*</span>
03719 <span class="comment">     * Look for matches first</span>
03720 <span class="comment">     */</span>
03721     <span class="keywordflow">for</span> (mcp = module_map_head; mcp; mcp = mcp-&gt;next) {
03722         <span class="keywordflow">if</span> (!label_compare(mcp-&gt;old_module, old_module_name)) {
03723 
03724             <span class="keywordflow">if</span> (                <span class="comment">/* exact match */</span>
03725                    (mcp-&gt;tag_len == 0 &amp;&amp;
03726                     (mcp-&gt;tag == NULL ||
03727                      !label_compare(mcp-&gt;tag, identifier-&gt;label))) ||
03728                    <span class="comment">/*</span>
03729 <span class="comment">                    * prefix match </span>
03730 <span class="comment">                    */</span>
03731                    (mcp-&gt;tag_len != 0 &amp;&amp;
03732                     !strncmp(mcp-&gt;tag, identifier-&gt;label, mcp-&gt;tag_len))
03733                 ) {
03734 
03735                 <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
03736                                        NETSNMP_DS_LIB_MIB_WARNINGS)) {
03737                     <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
03738                              <span class=
"stringliteral">"Importing %s from replacement module %s instead of %s (%s)\n"</span>,
03739                              identifier-&gt;label, mcp-&gt;new_module,
03740                              old_module_name, File);
03741                 }
03742                 (void) read_module(mcp-&gt;new_module);
03743                 identifier-&gt;modid = which_module(mcp-&gt;new_module);
03744                 <span class="keywordflow">return</span> 1;         <span class="comment">/* finished! */</span>
03745             }
03746         }
03747     }
03748 
03749     <span class="comment">/*</span>
03750 <span class="comment">     * If no exact match, load everything relevant</span>
03751 <span class="comment">     */</span>
03752     <span class="keywordflow">return</span> read_module_replacements(old_module_name);
03753 }
03754 
03755 
03756 <span class="comment">/*</span>
03757 <span class="comment"> *  Read in the named module</span>
03758 <span class="comment"> *      Returns the root of the whole tree</span>
03759 <span class="comment"> *      (by analogy with 'read_mib')</span>
03760 <span class="comment"> */</span>
03761 <span class="keyword">static</span> <span class="keywordtype">int</span>
03762 read_module_internal(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
03763 {
03764     <span class="keyword">struct </span>module  *mp;
03765     FILE           *fp;
03766     <span class="keyword">struct </span>node    *np;
03767 
03768     init_mib_internals();
03769 
03770     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
03771         <span class="keywordflow">if</span> (!label_compare(mp-&gt;name, name)) {
03772             <span class="keyword">const</span> <span class="keywordtype">char</span>     *oldFile = File;
03773             <span class="keywordtype">int</span>             oldLine = mibLine;
03774             <span class="keywordtype">int</span>             oldModule = current_module;
03775 
03776             <span class="keywordflow">if</span> (mp-&gt;no_imports != -1) {
03777                 DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Module %s already loaded\n"</span>,
03778                             name));
03779                 <span class="keywordflow">return</span> MODULE_ALREADY_LOADED;
03780             }
03781             <span class="keywordflow">if</span> ((fp = fopen(mp-&gt;file, <span class=
"stringliteral">"r"</span>)) == NULL) {
03782                 snmp_log_perror(mp-&gt;file);
03783                 <span class="keywordflow">return</span> MODULE_LOAD_FAILED;
03784             }
03785             mp-&gt;no_imports = 0; <span class="comment">/* Note that we've read the file */</span>
03786             File = mp-&gt;file;
03787             mibLine = 1;
03788             current_module = mp-&gt;modid;
03789             <span class="comment">/*</span>
03790 <span class="comment">             * Parse the file</span>
03791 <span class="comment">             */</span>
03792             np = parse(fp, NULL);
03793             fclose(fp);
03794             File = oldFile;
03795             mibLine = oldLine;
03796             current_module = oldModule;
03797             <span class="keywordflow">return</span> MODULE_LOADED_OK;
03798         }
03799 
03800     <span class="keywordflow">return</span> MODULE_NOT_FOUND;
03801 }
03802 
03803 <span class="keywordtype">void</span>
03804 adopt_orphans(<span class="keywordtype">void</span>)
03805 {
03806     <span class="keyword">struct </span>node    *np, *onp;
03807     <span class="keyword">struct </span>tree    *tp;
03808     <span class="keywordtype">int</span>             i, adopted = 1;
03809 
03810     <span class="keywordflow">if</span> (!orphan_nodes)
03811         <span class="keywordflow">return</span>;
03812     init_node_hash(orphan_nodes);
03813     orphan_nodes = NULL;
03814 
03815     <span class="keywordflow">while</span> (adopted) {
03816         adopted = 0;
03817         <span class="keywordflow">for</span> (i = 0; i &lt; NHASHSIZE; i++)
03818             <span class="keywordflow">if</span> (nbuckets[i]) {
03819                 <span class="keywordflow">for</span> (np = nbuckets[i]; np != NULL; np = np-&gt;next) {
03820                     tp = find_tree_node(np-&gt;parent, -1);
03821                     <span class="keywordflow">if</span> (tp) {
03822                         do_subtree(tp, &amp;np);
03823                         adopted = 1;
03824                         <span class="comment">/*</span>
03825 <span class="comment">                         * if do_subtree adopted the entire bucket, stop</span>
03826 <span class="comment">                         */</span>
03827                         <span class="keywordflow">if</span>(NULL == nbuckets[i])
03828                             <span class="keywordflow">break</span>;
03829 
03830                         <span class="comment">/*</span>
03831 <span class="comment">                         * do_subtree may modify nbuckets, and if np</span>
03832 <span class="comment">                         * was adopted, np-&gt;next probably isn't an orphan</span>
03833 <span class="comment">                         * anymore. if np is still in the bucket (do_subtree</span>
03834 <span class="comment">                         * didn't adopt it) keep on plugging. otherwise</span>
03835 <span class="comment">                         * start over, at the top of the bucket.</span>
03836 <span class="comment">                         */</span>
03837                         <span class="keywordflow">for</span>(onp = nbuckets[i]; onp; onp = onp-&gt;next)
03838                             <span class="keywordflow">if</span>(onp == np)
03839                                 <span class="keywordflow">break</span>;
03840                         <span class="keywordflow">if</span>(NULL == onp) { <span class=
"comment">/* not in the list */</span>
03841                             np = nbuckets[i]; <span class="comment">/* start over */</span>
03842                         }
03843                     }
03844                 }
03845             }
03846     }
03847 
03848     <span class="comment">/*</span>
03849 <span class="comment">     * Report on outstanding orphans</span>
03850 <span class="comment">     *    and link them back into the orphan list</span>
03851 <span class="comment">     */</span>
03852     <span class="keywordflow">for</span> (i = 0; i &lt; NHASHSIZE; i++)
03853         <span class="keywordflow">if</span> (nbuckets[i]) {
03854             <span class="keywordflow">if</span> (orphan_nodes)
03855                 onp = np-&gt;next = nbuckets[i];
03856             <span class="keywordflow">else</span>
03857                 onp = orphan_nodes = nbuckets[i];
03858             nbuckets[i] = NULL;
03859             <span class="keywordflow">while</span> (onp) {
03860                 <span class="keywordtype">char</span>            modbuf[256];
03861                 <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
03862                          <span class="stringliteral">"Cannot adopt OID in %s: %s ::= { %s %ld }\n"</span>,
03863                          module_name(onp-&gt;modid, modbuf),
03864                          (onp-&gt;label ? onp-&gt;label : <span class="stringliteral">"&lt;no label&gt;"</span>),
03865                          (onp-&gt;parent ? onp-&gt;parent : <span class="stringliteral">"&lt;no parent&gt;"</span>),
03866                          onp-&gt;subid);
03867 
03868                 np = onp;
03869                 onp = onp-&gt;next;
03870             }
03871         }
03872 }
03873 
03874 <span class="keyword">struct </span>tree    *
03875 read_module(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
03876 {
03877     <span class="keywordflow">if</span> (read_module_internal(name) == MODULE_NOT_FOUND)
03878         <span class="keywordflow">if</span> (!read_module_replacements(name))
03879             print_module_not_found(name);
03880     <span class="keywordflow">return</span> tree_head;
03881 }
03882 
03883 <span class="comment">/*</span>
03884 <span class="comment"> * Prototype definition </span>
03885 <span class="comment"> */</span>
03886 <span class="keywordtype">void</span>            unload_module_by_ID(<span class=
"keywordtype">int</span> modID, <span class="keyword">struct</span> tree *tree_top);
03887 
03888 <span class="keywordtype">void</span>
03889 unload_module_by_ID(<span class="keywordtype">int</span> modID, <span class="keyword">struct</span> tree *tree_top)
03890 {
03891     <span class="keyword">struct </span>tree    *tp, *next;
03892     <span class="keywordtype">int</span>             i;
03893 
03894     <span class="keywordflow">for</span> (tp = tree_top; tp; tp = next) {
03895         <span class="comment">/*</span>
03896 <span class="comment">         * Essentially, this is equivalent to the code fragment:</span>
03897 <span class="comment">         *      if (tp-&gt;modID == modID)</span>
03898 <span class="comment">         *        tp-&gt;number_modules--;</span>
03899 <span class="comment">         * but handles one tree node being part of several modules,</span>
03900 <span class="comment">         * and possible multiple copies of the same module ID.</span>
03901 <span class="comment">         */</span>
03902         <span class="keywordtype">int</span>             nmod = tp-&gt;number_modules;
03903         <span class="keywordflow">if</span> (nmod &gt; 0) {         <span class="comment">/* in some module */</span>
03904             <span class="comment">/*</span>
03905 <span class="comment">             * Remove all copies of this module ID</span>
03906 <span class="comment">             */</span>
03907             <span class="keywordtype">int</span>             cnt = 0, *pi1, *pi2 = tp-&gt;module_list;
03908             <span class="keywordflow">for</span> (i = 0, pi1 = pi2; i &lt; nmod; i++, pi2++) {
03909                 <span class="keywordflow">if</span> (*pi2 == modID)
03910                     <span class="keywordflow">continue</span>;
03911                 cnt++;
03912                 *pi1++ = *pi2;
03913             }
03914             <span class="keywordflow">if</span> (nmod != cnt) {  <span class="comment">/* in this module */</span>
03915                 <span class="comment">/*</span>
03916 <span class="comment">                 * if ( (nmod - cnt) &gt; 1)</span>
03917 <span class=
"comment">                 * printf("Dup modid %d,  %d times, '%s'\n", tp-&gt;modid, (nmod-cnt), tp-&gt;label); fflush(stdout); ?* XXDEBUG </span>
03918 <span class="comment">                 */</span>
03919                 tp-&gt;number_modules = cnt;
03920                 <span class="keywordflow">switch</span> (cnt) {
03921                 <span class="keywordflow">case</span> 0:
03922                     tp-&gt;module_list[0] = -1;    <span class="comment">/* Mark unused, and FALL THROUGH */</span>
03923 
03924                 <span class="keywordflow">case</span> 1:        <span class=
"comment">/* save the remaining module */</span>
03925                     <span class="keywordflow">if</span> (&amp;(tp-&gt;modid) != tp-&gt;module_list) {
03926                         tp-&gt;modid = tp-&gt;module_list[0];
03927                         free(tp-&gt;module_list);
03928                         tp-&gt;module_list = &amp;(tp-&gt;modid);
03929                     }
03930                     <span class="keywordflow">break</span>;
03931 
03932                 <span class="keywordflow">default</span>:
03933                     <span class="keywordflow">break</span>;
03934                 }
03935             }                   <span class="comment">/* if tree node is in this module */</span>
03936         }
03937         <span class="comment">/*</span>
03938 <span class="comment">         * if tree node is in some module </span>
03939 <span class="comment">         */</span>
03940         next = tp-&gt;next_peer;
03941 
03942 
03943         <span class="comment">/*</span>
03944 <span class="comment">         *  OK - that's dealt with *this* node.</span>
03945 <span class="comment">         *    Now let's look at the children.</span>
03946 <span class="comment">         *    (Isn't recursion wonderful!)</span>
03947 <span class="comment">         */</span>
03948         <span class="keywordflow">if</span> (tp-&gt;child_list)
03949             unload_module_by_ID(modID, tp-&gt;child_list);
03950 
03951 
03952         <span class="keywordflow">if</span> (tp-&gt;number_modules == 0) {
03953             <span class="comment">/*</span>
03954 <span class="comment">             * This node isn't needed any more (except perhaps</span>
03955 <span class="comment">             * for the sake of the children) </span>
03956 <span class="comment">             */</span>
03957             <span class="keywordflow">if</span> (tp-&gt;child_list == NULL) {
03958                 unlink_tree(tp);
03959                 free_tree(tp);
03960             } <span class="keywordflow">else</span> {
03961                 free_partial_tree(tp, TRUE);
03962             }
03963         }
03964     }
03965 }
03966 
03967 <span class="keywordtype">int</span>
03968 unload_module(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
03969 {
03970     <span class="keyword">struct </span>module  *mp;
03971     <span class="keywordtype">int</span>             modID = -1;
03972 
03973     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
03974         <span class="keywordflow">if</span> (!label_compare(mp-&gt;name, name)) {
03975             modID = mp-&gt;modid;
03976             <span class="keywordflow">break</span>;
03977         }
03978 
03979     <span class="keywordflow">if</span> (modID == -1) {
03980         DEBUGMSGTL((<span class="stringliteral">"unload-mib"</span>, <span class=
"stringliteral">"Module %s not found to unload\n"</span>,
03981                     name));
03982         <span class="keywordflow">return</span> MODULE_NOT_FOUND;
03983     }
03984     unload_module_by_ID(modID, tree_head);
03985     mp-&gt;no_imports = -1;        <span class="comment">/* mark as unloaded */</span>
03986     <span class="keywordflow">return</span> MODULE_LOADED_OK;    <span class=
"comment">/* Well, you know what I mean! */</span>
03987 }
03988 
03989 <span class="comment">/*</span>
03990 <span class="comment"> * Clear module map, tree nodes, textual convention table.</span>
03991 <span class="comment"> */</span>
03992 <span class="keywordtype">void</span>
03993 unload_all_mibs()
03994 {
03995     <span class="keyword">struct </span>module  *mp;
03996     <span class="keyword">struct </span>module_compatability *mcp;
03997     <span class="keyword">struct </span>tc      *ptc;
03998     <span class="keywordtype">int</span>             i;
03999 
04000     <span class="keywordflow">for</span> (mcp = module_map_head; mcp; mcp = module_map_head) {
04001         <span class="keywordflow">if</span> (mcp == module_map)
04002             <span class="keywordflow">break</span>;
04003         module_map_head = mcp-&gt;next;
04004         <span class="keywordflow">if</span> (mcp-&gt;tag) free((<span class="keywordtype">char</span> *) mcp-&gt;tag);
04005         free((<span class="keywordtype">char</span> *) mcp-&gt;old_module);
04006         free((<span class="keywordtype">char</span> *) mcp-&gt;new_module);
04007         free(mcp);
04008     }
04009 
04010     <span class="keywordflow">for</span> (mp = module_head; mp; mp = module_head) {
04011         <span class="keyword">struct </span>module_import *mi = mp-&gt;imports;
04012         <span class="keywordflow">if</span> (mi) {
04013             <span class="keywordflow">for</span> (i = 0; i &lt; mp-&gt;no_imports; ++i) {
04014                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>((mi + i)-&gt;label);
04015             }
04016             mp-&gt;no_imports = 0;
04017             <span class="keywordflow">if</span> (mi == root_imports)
04018                 memset(mi, 0, <span class="keyword">sizeof</span>(*mi));
04019             <span class="keywordflow">else</span>
04020                 free(mi);
04021         }
04022 
04023         unload_module_by_ID(mp-&gt;modid, tree_head);
04024         module_head = mp-&gt;next;
04025         free(mp-&gt;name);
04026         free(mp-&gt;file);
04027         free(mp);
04028     }
04029     unload_module_by_ID(-1, tree_head);
04030     <span class="comment">/*</span>
04031 <span class="comment">     * tree nodes are cleared </span>
04032 <span class="comment">     */</span>
04033 
04034     <span class="keywordflow">for</span> (i = 0, ptc = tclist; i &lt; MAXTC; i++, ptc++) {
04035         <span class="keywordflow">if</span> (ptc-&gt;type == 0)
04036             <span class="keywordflow">continue</span>;
04037         free_enums(&amp;ptc-&gt;enums);
04038         free_ranges(&amp;ptc-&gt;ranges);
04039         free(ptc-&gt;descriptor);
04040         <span class="keywordflow">if</span> (ptc-&gt;hint)
04041             free(ptc-&gt;hint);
04042     }
04043     memset(tclist, 0, MAXTC * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tc));
04044 
04045     memset(buckets, 0, <span class="keyword">sizeof</span>(buckets));
04046     memset(nbuckets, 0, <span class="keyword">sizeof</span>(nbuckets));
04047     memset(tbuckets, 0, <span class="keyword">sizeof</span>(tbuckets));
04048 
04049     <span class="keywordflow">for</span> (i = 0; i &lt; <span class="keyword">sizeof</span>(root_imports) / <span class=
"keyword">sizeof</span>(root_imports[0]); i++) {
04050         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(root_imports[i].label);
04051     }
04052 
04053     max_module = 0;
04054     current_module = 0;
04055     module_map_head = NULL;
04056     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(last_err_module);
04057 }
04058 
04059 <span class="keyword">static</span> <span class="keywordtype">void</span>
04060 new_module(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *file)
04061 {
04062     <span class="keyword">struct </span>module  *mp;
04063 
04064     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
04065         <span class="keywordflow">if</span> (!label_compare(mp-&gt;name, name)) {
04066             DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"  Module %s already noted\n"</span>, name));
04067             <span class="comment">/*</span>
04068 <span class="comment">             * Not the same file </span>
04069 <span class="comment">             */</span>
04070             <span class="keywordflow">if</span> (label_compare(mp-&gt;file, file)) {
04071                 DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"    %s is now in %s\n"</span>,
04072                             name, file));
04073                 <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
04074                                        NETSNMP_DS_LIB_MIB_WARNINGS)) {
04075                     <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING,
04076                              <span class="stringliteral">"Warning: Module %s was in %s now is %s\n"</span>,
04077                              name, mp-&gt;file, file);
04078                 }
04079 
04080                 <span class="comment">/*</span>
04081 <span class="comment">                 * Use the new one in preference </span>
04082 <span class="comment">                 */</span>
04083                 free(mp-&gt;file);
04084                 mp-&gt;file = strdup(file);
04085             }
04086             <span class="keywordflow">return</span>;
04087         }
04088 
04089     <span class="comment">/*</span>
04090 <span class="comment">     * Add this module to the list </span>
04091 <span class="comment">     */</span>
04092     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"  Module %d %s is in %s\n"</span>, max_module,
04093                 name, file));
04094     mp = (<span class="keyword">struct </span>module *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> module));
04095     <span class="keywordflow">if</span> (mp == NULL)
04096         <span class="keywordflow">return</span>;
04097     mp-&gt;name = strdup(name);
04098     mp-&gt;file = strdup(file);
04099     mp-&gt;imports = NULL;
04100     mp-&gt;no_imports = -1;        <span class="comment">/* Not yet loaded */</span>
04101     mp-&gt;modid = max_module;
04102     ++max_module;
04103 
04104     mp-&gt;next = module_head;     <span class="comment">/* Or add to the *end* of the list? */</span>
04105     module_head = mp;
04106 }
04107 
04108 
04109 <span class="keyword">static</span> <span class="keywordtype">void</span>
04110 scan_objlist(<span class="keyword">struct</span> node *root, <span class=
"keyword">struct</span> objgroup *list, <span class="keyword">const</span> <span class="keywordtype">char</span> *error)
04111 {
04112     <span class="keywordtype">int</span>             oLine = mibLine;
04113 
04114     <span class="keywordflow">while</span> (list) {
04115         <span class="keyword">struct </span>objgroup *gp = list;
04116         <span class="keyword">struct </span>node    *np;
04117         list = list-&gt;next;
04118         np = root;
04119         <span class="keywordflow">while</span> (np)
04120             <span class="keywordflow">if</span> (label_compare(np-&gt;label, gp-&gt;name))
04121                 np = np-&gt;next;
04122             <span class="keywordflow">else</span>
04123                 <span class="keywordflow">break</span>;
04124         <span class="keywordflow">if</span> (!np) {
04125             mibLine = gp-&gt;line;
04126             print_error(error, gp-&gt;name, QUOTESTRING);
04127         }
04128         free(gp-&gt;name);
04129         free(gp);
04130     }
04131     mibLine = oLine;
04132 }
04133 
04134 <span class="comment">/*</span>
04135 <span class="comment"> * Parses a mib file and returns a linked list of nodes found in the file.</span>
04136 <span class="comment"> * Returns NULL on error.</span>
04137 <span class="comment"> */</span>
04138 <span class="keyword">static</span> <span class="keyword">struct </span>node *
04139 parse(FILE * fp, <span class="keyword">struct</span> node *root)
04140 {
04141     <span class="keywordtype">char</span>            token[MAXTOKEN];
04142     <span class="keywordtype">char</span>            name[MAXTOKEN];
04143     <span class="keywordtype">int</span>             type = LABEL;
04144     <span class="keywordtype">int</span>             lasttype = LABEL;
04145 
04146 <span class="preprocessor">#define BETWEEN_MIBS          1</span>
04147 <span class="preprocessor">#define IN_MIB                2</span>
04148     <span class="keywordtype">int</span>             state = BETWEEN_MIBS;
04149     <span class="keyword">struct </span>node    *np, *nnp;
04150     <span class="keyword">struct </span>objgroup *oldgroups = NULL, *oldobjects = NULL, *oldnotifs =
04151         NULL;
04152 
04153     DEBUGMSGTL((<span class="stringliteral">"parse-file"</span>, <span class=
"stringliteral">"Parsing file:  %s...\n"</span>, File));
04154 
04155     <span class="keywordflow">if</span> (last_err_module)
04156         free(last_err_module);
04157     last_err_module = 0;
04158 
04159     np = root;
04160     <span class="keywordflow">if</span> (np != NULL) {
04161         <span class="comment">/*</span>
04162 <span class="comment">         * now find end of chain </span>
04163 <span class="comment">         */</span>
04164         <span class="keywordflow">while</span> (np-&gt;next)
04165             np = np-&gt;next;
04166     }
04167 
04168     <span class="keywordflow">while</span> (type != ENDOFFILE) {
04169         <span class="keywordflow">if</span> (lasttype == CONTINUE)
04170             lasttype = type;
04171         <span class="keywordflow">else</span>
04172             type = lasttype = get_token(fp, token, MAXTOKEN);
04173 
04174         <span class="keywordflow">switch</span> (type) {
04175         <span class="keywordflow">case</span> END:
04176             <span class="keywordflow">if</span> (state != IN_MIB) {
04177                 print_error(<span class="stringliteral">"Error, END before start of MIB"</span>, NULL, type);
04178                 <span class="keywordflow">return</span> NULL;
04179             } <span class="keywordflow">else</span> {
04180                 <span class="keyword">struct </span>module  *mp;
04181 <span class="preprocessor">#ifdef TEST</span>
04182                 printf(<span class="stringliteral">"\nNodes for Module %s:\n"</span>, name);
04183                 print_nodes(stdout, root);
04184 <span class="preprocessor">#endif</span>
04185                 scan_objlist(root, objgroups, <span class="stringliteral">"Undefined OBJECT-GROUP"</span>);
04186                 scan_objlist(root, objects, <span class="stringliteral">"Undefined OBJECT"</span>);
04187                 scan_objlist(root, notifs, <span class="stringliteral">"Undefined NOTIFICATION"</span>);
04188                 objgroups = oldgroups;
04189                 objects = oldobjects;
04190                 notifs = oldnotifs;
04191                 <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
04192                     <span class="keywordflow">if</span> (mp-&gt;modid == current_module)
04193                         <span class="keywordflow">break</span>;
04194                 do_linkup(mp, root);
04195                 np = root = NULL;
04196             }
04197             state = BETWEEN_MIBS;
04198 <span class="preprocessor">#ifdef TEST</span>
04199             <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
04200                                    NETSNMP_DS_LIB_MIB_WARNINGS)) {
04201                 xmalloc_stats(stderr);
04202             }
04203 <span class="preprocessor">#endif</span>
04204             <span class="keywordflow">continue</span>;
04205         <span class="keywordflow">case</span> IMPORTS:
04206             parse_imports(fp);
04207             <span class="keywordflow">continue</span>;
04208         <span class="keywordflow">case</span> EXPORTS:
04209             <span class="keywordflow">while</span> (type != SEMI &amp;&amp; type != ENDOFFILE)
04210                 type = get_token(fp, token, MAXTOKEN);
04211             <span class="keywordflow">continue</span>;
04212         <span class="keywordflow">case</span> LABEL:
04213         <span class="keywordflow">case</span> INTEGER:
04214         <span class="keywordflow">case</span> INTEGER32:
04215         <span class="keywordflow">case</span> UINTEGER32:
04216         <span class="keywordflow">case</span> UNSIGNED32:
04217         <span class="keywordflow">case</span> COUNTER:
04218         <span class="keywordflow">case</span> COUNTER64:
04219         <span class="keywordflow">case</span> GAUGE:
04220         <span class="keywordflow">case</span> IPADDR:
04221         <span class="keywordflow">case</span> NETADDR:
04222         <span class="keywordflow">case</span> NSAPADDRESS:
04223         <span class="keywordflow">case</span> OBJSYNTAX:
04224         <span class="keywordflow">case</span> APPSYNTAX:
04225         <span class="keywordflow">case</span> SIMPLESYNTAX:
04226         <span class="keywordflow">case</span> OBJNAME:
04227         <span class="keywordflow">case</span> NOTIFNAME:
04228         <span class="keywordflow">case</span> KW_OPAQUE:
04229         <span class="keywordflow">case</span> TIMETICKS:
04230             <span class="keywordflow">break</span>;
04231         <span class="keywordflow">case</span> ENDOFFILE:
04232             <span class="keywordflow">continue</span>;
04233         <span class="keywordflow">default</span>:
04234             strcpy(name, token);
04235             type = get_token(fp, token, MAXTOKEN);
04236             nnp = NULL;
04237             <span class="keywordflow">if</span> (type == MACRO) {
04238                 nnp = parse_macro(fp, name);
04239                 <span class="keywordflow">if</span> (nnp == NULL) {
04240                     print_error(<span class="stringliteral">"Bad parse of MACRO"</span>, NULL, type);
04241                     <span class="comment">/*</span>
04242 <span class="comment">                     * return NULL;</span>
04243 <span class="comment">                     */</span>
04244                 }
04245                 free_node(nnp); <span class="comment">/* IGNORE */</span>
04246                 nnp = NULL;
04247             } <span class="keywordflow">else</span>
04248                 print_error(name, <span class="stringliteral">"is a reserved word"</span>, lasttype);
04249             <span class="keywordflow">continue</span>;           <span class=
"comment">/* see if we can parse the rest of the file */</span>
04250         }
04251         strcpy(name, token);
04252         type = get_token(fp, token, MAXTOKEN);
04253         nnp = NULL;
04254 
04255         <span class="comment">/*</span>
04256 <span class="comment">         * Handle obsolete method to assign an object identifier to a</span>
04257 <span class="comment">         * module</span>
04258 <span class="comment">         */</span>
04259         <span class="keywordflow">if</span> (lasttype == LABEL &amp;&amp; type == LEFTBRACKET) {
04260             <span class="keywordflow">while</span> (type != RIGHTBRACKET &amp;&amp; type != ENDOFFILE)
04261                 type = get_token(fp, token, MAXTOKEN);
04262             <span class="keywordflow">if</span> (type == ENDOFFILE) {
04263                 print_error(<span class="stringliteral">"Expected \"}\""</span>, token, type);
04264                 <span class="keywordflow">return</span> NULL;
04265             }
04266             type = get_token(fp, token, MAXTOKEN);
04267         }
04268 
04269         <span class="keywordflow">switch</span> (type) {
04270         <span class="keywordflow">case</span> DEFINITIONS:
04271             <span class="keywordflow">if</span> (state != BETWEEN_MIBS) {
04272                 print_error(<span class="stringliteral">"Error, nested MIBS"</span>, NULL, type);
04273                 <span class="keywordflow">return</span> NULL;
04274             }
04275             state = IN_MIB;
04276             current_module = which_module(name);
04277             oldgroups = objgroups;
04278             objgroups = NULL;
04279             oldobjects = objects;
04280             objects = NULL;
04281             oldnotifs = notifs;
04282             notifs = NULL;
04283             <span class="keywordflow">if</span> (current_module == -1) {
04284                 new_module(name, File);
04285                 current_module = which_module(name);
04286             }
04287             DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Parsing MIB: %d %s\n"</span>,
04288                         current_module, name));
04289             <span class="keywordflow">while</span> ((type = get_token(fp, token, MAXTOKEN)) != ENDOFFILE)
04290                 <span class="keywordflow">if</span> (type == BEGIN)
04291                     <span class="keywordflow">break</span>;
04292             <span class="keywordflow">break</span>;
04293         <span class="keywordflow">case</span> OBJTYPE:
04294             nnp = parse_objecttype(fp, name);
04295             <span class="keywordflow">if</span> (nnp == NULL) {
04296                 print_error(<span class="stringliteral">"Bad parse of OBJECT-TYPE"</span>, NULL, type);
04297                 <span class="keywordflow">return</span> NULL;
04298             }
04299             <span class="keywordflow">break</span>;
04300         <span class="keywordflow">case</span> OBJGROUP:
04301             nnp = parse_objectgroup(fp, name, OBJECTS, &amp;objects);
04302             <span class="keywordflow">if</span> (nnp == NULL) {
04303                 print_error(<span class="stringliteral">"Bad parse of OBJECT-GROUP"</span>, NULL, type);
04304                 <span class="keywordflow">return</span> NULL;
04305             }
04306             <span class="keywordflow">break</span>;
04307         <span class="keywordflow">case</span> NOTIFGROUP:
04308             nnp = parse_objectgroup(fp, name, NOTIFICATIONS, &amp;notifs);
04309             <span class="keywordflow">if</span> (nnp == NULL) {
04310                 print_error(<span class="stringliteral">"Bad parse of NOTIFICATION-GROUP"</span>, NULL, type);
04311                 <span class="keywordflow">return</span> NULL;
04312             }
04313             <span class="keywordflow">break</span>;
04314         <span class="keywordflow">case</span> TRAPTYPE:
04315             nnp = parse_trapDefinition(fp, name);
04316             <span class="keywordflow">if</span> (nnp == NULL) {
04317                 print_error(<span class="stringliteral">"Bad parse of TRAP-TYPE"</span>, NULL, type);
04318                 <span class="keywordflow">return</span> NULL;
04319             }
04320             <span class="keywordflow">break</span>;
04321         <span class="keywordflow">case</span> NOTIFTYPE:
04322             nnp = parse_notificationDefinition(fp, name);
04323             <span class="keywordflow">if</span> (nnp == NULL) {
04324                 print_error(<span class="stringliteral">"Bad parse of NOTIFICATION-TYPE"</span>, NULL, type);
04325                 <span class="keywordflow">return</span> NULL;
04326             }
04327             <span class="keywordflow">break</span>;
04328         <span class="keywordflow">case</span> COMPLIANCE:
04329             nnp = parse_compliance(fp, name);
04330             <span class="keywordflow">if</span> (nnp == NULL) {
04331                 print_error(<span class="stringliteral">"Bad parse of MODULE-COMPLIANCE"</span>, NULL, type);
04332                 <span class="keywordflow">return</span> NULL;
04333             }
04334             <span class="keywordflow">break</span>;
04335         <span class="keywordflow">case</span> AGENTCAP:
04336             nnp = parse_capabilities(fp, name);
04337             <span class="keywordflow">if</span> (nnp == NULL) {
04338                 print_error(<span class="stringliteral">"Bad parse of AGENT-CAPABILITIES"</span>, NULL, type);
04339                 <span class="keywordflow">return</span> NULL;
04340             }
04341             <span class="keywordflow">break</span>;
04342         <span class="keywordflow">case</span> MACRO:
04343             nnp = parse_macro(fp, name);
04344             <span class="keywordflow">if</span> (nnp == NULL) {
04345                 print_error(<span class="stringliteral">"Bad parse of MACRO"</span>, NULL, type);
04346                 <span class="comment">/*</span>
04347 <span class="comment">                 * return NULL;</span>
04348 <span class="comment">                 */</span>
04349             }
04350             free_node(nnp);     <span class="comment">/* IGNORE */</span>
04351             nnp = NULL;
04352             <span class="keywordflow">break</span>;
04353         <span class="keywordflow">case</span> MODULEIDENTITY:
04354             nnp = parse_moduleIdentity(fp, name);
04355             <span class="keywordflow">if</span> (nnp == NULL) {
04356                 print_error(<span class="stringliteral">"Bad parse of MODULE-IDENTITY"</span>, NULL, type);
04357                 <span class="keywordflow">return</span> NULL;
04358             }
04359             <span class="keywordflow">break</span>;
04360         <span class="keywordflow">case</span> OBJECT:
04361             type = get_token(fp, token, MAXTOKEN);
04362             <span class="keywordflow">if</span> (type != IDENTIFIER) {
04363                 print_error(<span class="stringliteral">"Expected IDENTIFIER"</span>, token, type);
04364                 <span class="keywordflow">return</span> NULL;
04365             }
04366             type = get_token(fp, token, MAXTOKEN);
04367             <span class="keywordflow">if</span> (type != EQUALS) {
04368                 print_error(<span class="stringliteral">"Expected \"::=\""</span>, token, type);
04369                 <span class="keywordflow">return</span> NULL;
04370             }
04371             nnp = parse_objectid(fp, name);
04372             <span class="keywordflow">if</span> (nnp == NULL) {
04373                 print_error(<span class="stringliteral">"Bad parse of OBJECT IDENTIFIER"</span>, NULL, type);
04374                 <span class="keywordflow">return</span> NULL;
04375             }
04376             <span class="keywordflow">break</span>;
04377         <span class="keywordflow">case</span> EQUALS:
04378             nnp = parse_asntype(fp, name, &amp;type, token);
04379             lasttype = CONTINUE;
04380             <span class="keywordflow">break</span>;
04381         <span class="keywordflow">case</span> ENDOFFILE:
04382             <span class="keywordflow">break</span>;
04383         <span class="keywordflow">default</span>:
04384             print_error(<span class="stringliteral">"Bad operator"</span>, token, type);
04385             <span class="keywordflow">return</span> NULL;
04386         }
04387         <span class="keywordflow">if</span> (nnp) {
04388             <span class="keywordflow">if</span> (nnp-&gt;type == TYPE_OTHER)
04389                 nnp-&gt;type = type;
04390             <span class="keywordflow">if</span> (np)
04391                 np-&gt;next = nnp;
04392             <span class="keywordflow">else</span>
04393                 np = root = nnp;
04394             <span class="keywordflow">while</span> (np-&gt;next)
04395                 np = np-&gt;next;
04396         }
04397     }
04398     DEBUGMSGTL((<span class="stringliteral">"parse-file"</span>, <span class=
"stringliteral">"End of file (%s)\n"</span>, File));
04399     <span class="keywordflow">return</span> root;
04400 }
04401 
04402 <span class="comment">/*</span>
04403 <span class="comment"> * return zero if character is not a label character. </span>
04404 <span class="comment"> */</span>
04405 <span class="keyword">static</span> <span class="keywordtype">int</span>
04406 is_labelchar(<span class="keywordtype">int</span> ich)
04407 {
04408     <span class="keywordflow">if</span> ((isalnum(ich)) || (ich == <span class="charliteral">'-'</span>))
04409         <span class="keywordflow">return</span> 1;
04410     <span class="keywordflow">if</span> (ich == <span class=
"charliteral">'_'</span> &amp;&amp; netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
04411                                              NETSNMP_DS_LIB_MIB_PARSE_LABEL)) {
04412         <span class="keywordflow">return</span> 1;
04413     }
04414 
04415     <span class="keywordflow">return</span> 0;
04416 }
04417 
04418 <span class="comment">/*</span>
04419 <span class="comment"> * Parses a token from the file.  The type of the token parsed is returned,</span>
04420 <span class="comment"> * and the text is placed in the string pointed to by token.</span>
04421 <span class="comment"> * Warning: this method may recurse.</span>
04422 <span class="comment"> */</span>
04423 <span class="keyword">static</span> <span class="keywordtype">int</span>
04424 get_token(FILE * fp, <span class="keywordtype">char</span> *token, <span class="keywordtype">int</span> maxtlen)
04425 {
04426     <span class="keyword">register</span> <span class="keywordtype">int</span>    ch, ch_next;
04427     <span class="keyword">register</span> <span class="keywordtype">char</span>  *cp = token;
04428     <span class="keyword">register</span> <span class="keywordtype">int</span>    hash = 0;
04429     <span class="keyword">register</span> <span class="keyword">struct </span>tok *tp;
04430     <span class="keywordtype">int</span>             too_long = 0;
04431 
04432     <span class="comment">/*</span>
04433 <span class="comment">     * skip all white space </span>
04434 <span class="comment">     */</span>
04435     <span class="keywordflow">do</span> {
04436         ch = getc(fp);
04437         <span class="keywordflow">if</span> (ch == <span class="charliteral">'\n'</span>)
04438             mibLine++;
04439     }
04440     <span class="keywordflow">while</span> (isspace(ch) &amp;&amp; ch != EOF);
04441     *cp++ = ch;
04442     *cp = <span class="charliteral">'\0'</span>;
04443     <span class="keywordflow">switch</span> (ch) {
04444     <span class="keywordflow">case</span> EOF:
04445         <span class="keywordflow">return</span> ENDOFFILE;
04446     <span class="keywordflow">case</span> <span class="charliteral">'"'</span>:
04447         <span class="keywordflow">return</span> parseQuoteString(fp, token, maxtlen);
04448     <span class="keywordflow">case</span> <span class="charliteral">'\''</span>:                 <span class=
"comment">/* binary or hex constant */</span>
04449         <span class="keywordflow">while</span> ((ch = getc(fp)) != EOF &amp;&amp; ch != <span class=
"charliteral">'\''</span>
04450                &amp;&amp; cp - token &lt; maxtlen - 2)
04451             *cp++ = ch;
04452         <span class="keywordflow">if</span> (ch == <span class="charliteral">'\''</span>) {
04453             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   val = 0;
04454             *cp++ = <span class="charliteral">'\''</span>;
04455             *cp++ = ch = getc(fp);
04456             *cp = 0;
04457             cp = token + 1;
04458             <span class="keywordflow">switch</span> (ch) {
04459             <span class="keywordflow">case</span> EOF:
04460                 <span class="keywordflow">return</span> ENDOFFILE;
04461             <span class="keywordflow">case</span> <span class="charliteral">'b'</span>:
04462             <span class="keywordflow">case</span> <span class="charliteral">'B'</span>:
04463                 <span class="keywordflow">while</span> ((ch = *cp++) != <span class="charliteral">'\''</span>)
04464                     <span class="keywordflow">if</span> (ch != <span class=
"charliteral">'0'</span> &amp;&amp; ch != <span class="charliteral">'1'</span>)
04465                         <span class="keywordflow">return</span> LABEL;
04466                     <span class="keywordflow">else</span>
04467                         val = val * 2 + ch - <span class="charliteral">'0'</span>;
04468                 <span class="keywordflow">break</span>;
04469             <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
04470             <span class="keywordflow">case</span> <span class="charliteral">'H'</span>:
04471                 <span class="keywordflow">while</span> ((ch = *cp++) != <span class="charliteral">'\''</span>)
04472                     <span class="keywordflow">if</span> (<span class=
"charliteral">'0'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'9'</span>)
04473                         val = val * 16 + ch - <span class="charliteral">'0'</span>;
04474                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class=
"charliteral">'a'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'f'</span>)
04475                         val = val * 16 + ch - <span class="charliteral">'a'</span> + 10;
04476                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class=
"charliteral">'A'</span> &lt;= ch &amp;&amp; ch &lt;= <span class="charliteral">'F'</span>)
04477                         val = val * 16 + ch - <span class="charliteral">'A'</span> + 10;
04478                     <span class="keywordflow">else</span>
04479                         <span class="keywordflow">return</span> LABEL;
04480                 <span class="keywordflow">break</span>;
04481             <span class="keywordflow">default</span>:
04482                 <span class="keywordflow">return</span> LABEL;
04483             }
04484             sprintf(token, <span class="stringliteral">"%ld"</span>, val);
04485             <span class="keywordflow">return</span> NUMBER;
04486         } <span class="keywordflow">else</span>
04487             <span class="keywordflow">return</span> LABEL;
04488     <span class="keywordflow">case</span> <span class="charliteral">'('</span>:
04489         <span class="keywordflow">return</span> LEFTPAREN;
04490     <span class="keywordflow">case</span> <span class="charliteral">')'</span>:
04491         <span class="keywordflow">return</span> RIGHTPAREN;
04492     <span class="keywordflow">case</span> <span class="charliteral">'{'</span>:
04493         <span class="keywordflow">return</span> LEFTBRACKET;
04494     <span class="keywordflow">case</span> <span class="charliteral">'}'</span>:
04495         <span class="keywordflow">return</span> RIGHTBRACKET;
04496     <span class="keywordflow">case</span> <span class="charliteral">'['</span>:
04497         <span class="keywordflow">return</span> LEFTSQBRACK;
04498     <span class="keywordflow">case</span> <span class="charliteral">']'</span>:
04499         <span class="keywordflow">return</span> RIGHTSQBRACK;
04500     <span class="keywordflow">case</span> <span class="charliteral">';'</span>:
04501         <span class="keywordflow">return</span> SEMI;
04502     <span class="keywordflow">case</span> <span class="charliteral">','</span>:
04503         <span class="keywordflow">return</span> COMMA;
04504     <span class="keywordflow">case</span> <span class="charliteral">'|'</span>:
04505         <span class="keywordflow">return</span> BAR;
04506     <span class="keywordflow">case</span> <span class="charliteral">'.'</span>:
04507         ch_next = getc(fp);
04508         <span class="keywordflow">if</span> (ch_next == <span class="charliteral">'.'</span>)
04509             <span class="keywordflow">return</span> RANGE;
04510         ungetc(ch_next, fp);
04511         <span class="keywordflow">return</span> LABEL;
04512     <span class="keywordflow">case</span> <span class="charliteral">':'</span>:
04513         ch_next = getc(fp);
04514         <span class="keywordflow">if</span> (ch_next != <span class="charliteral">':'</span>) {
04515             ungetc(ch_next, fp);
04516             <span class="keywordflow">return</span> LABEL;
04517         }
04518         ch_next = getc(fp);
04519         <span class="keywordflow">if</span> (ch_next != <span class="charliteral">'='</span>) {
04520             ungetc(ch_next, fp);
04521             <span class="keywordflow">return</span> LABEL;
04522         }
04523         <span class="keywordflow">return</span> EQUALS;
04524     <span class="keywordflow">case</span> <span class="charliteral">'-'</span>:
04525         ch_next = getc(fp);
04526         <span class="keywordflow">if</span> (ch_next == <span class="charliteral">'-'</span>) {
04527             <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
04528                                        NETSNMP_DS_LIB_MIB_COMMENT_TERM)) {
04529                 <span class="comment">/*</span>
04530 <span class="comment">                 * Treat the rest of this line as a comment. </span>
04531 <span class="comment">                 */</span>
04532                 <span class="keywordflow">while</span> ((ch_next != EOF) &amp;&amp; (ch_next != <span class=
"charliteral">'\n'</span>))
04533                     ch_next = getc(fp);
04534             } <span class="keywordflow">else</span> {
04535                 <span class="comment">/*</span>
04536 <span class="comment">                 * Treat the rest of the line or until another '--' as a comment </span>
04537 <span class="comment">                 */</span>
04538                 <span class="comment">/*</span>
04539 <span class="comment">                 * (this is the "technically" correct way to parse comments) </span>
04540 <span class="comment">                 */</span>
04541                 ch = <span class="charliteral">' '</span>;
04542                 ch_next = getc(fp);
04543                 <span class="keywordflow">while</span> (ch_next != EOF &amp;&amp; ch_next != <span class=
"charliteral">'\n'</span> &amp;&amp;
04544                        (ch != <span class="charliteral">'-'</span> || ch_next != <span class="charliteral">'-'</span>)) {
04545                     ch = ch_next;
04546                     ch_next = getc(fp);
04547                 }
04548             }
04549             <span class="keywordflow">if</span> (ch_next == EOF)
04550                 <span class="keywordflow">return</span> ENDOFFILE;
04551             <span class="keywordflow">if</span> (ch_next == <span class="charliteral">'\n'</span>)
04552                 mibLine++;
04553             <span class="keywordflow">return</span> get_token(fp, token, maxtlen);
04554         }
04555         ungetc(ch_next, fp);
04556     <span class="keywordflow">default</span>:
04557         <span class="comment">/*</span>
04558 <span class="comment">         * Accumulate characters until end of token is found.  Then attempt to</span>
04559 <span class="comment">         * match this token as a reserved word.  If a match is found, return the</span>
04560 <span class="comment">         * type.  Else it is a label.</span>
04561 <span class="comment">         */</span>
04562         <span class="keywordflow">if</span> (!is_labelchar(ch))
04563             <span class="keywordflow">return</span> LABEL;
04564         hash += tolower(ch);
04565       more:
04566         <span class="keywordflow">while</span> (is_labelchar(ch_next = getc(fp))) {
04567             hash += tolower(ch_next);
04568             <span class="keywordflow">if</span> (cp - token &lt; maxtlen - 1)
04569                 *cp++ = ch_next;
04570             <span class="keywordflow">else</span>
04571                 too_long = 1;
04572         }
04573         ungetc(ch_next, fp);
04574         *cp = <span class="charliteral">'\0'</span>;
04575 
04576         <span class="keywordflow">if</span> (too_long)
04577             print_error(<span class="stringliteral">"Warning: token too long"</span>, token, CONTINUE);
04578         <span class="keywordflow">for</span> (tp = buckets[BUCKET(hash)]; tp; tp = tp-&gt;next) {
04579             <span class="keywordflow">if</span> ((tp-&gt;hash == hash) &amp;&amp; (!label_compare(tp-&gt;name, token)))
04580                 <span class="keywordflow">break</span>;
04581         }
04582         <span class="keywordflow">if</span> (tp) {
04583             <span class="keywordflow">if</span> (tp-&gt;token != CONTINUE)
04584                 <span class="keywordflow">return</span> (tp-&gt;token);
04585             <span class="keywordflow">while</span> (isspace((ch_next = getc(fp))))
04586                 <span class="keywordflow">if</span> (ch_next == <span class="charliteral">'\n'</span>)
04587                     mibLine++;
04588             <span class="keywordflow">if</span> (ch_next == EOF)
04589                 <span class="keywordflow">return</span> ENDOFFILE;
04590             <span class="keywordflow">if</span> (isalnum(ch_next)) {
04591                 *cp++ = ch_next;
04592                 hash += tolower(ch_next);
04593                 <span class="keywordflow">goto</span> more;
04594             }
04595         }
04596         <span class="keywordflow">if</span> (token[0] == <span class="charliteral">'-'</span> || isdigit(token[0])) {
04597             <span class="keywordflow">for</span> (cp = token + 1; *cp; cp++)
04598                 <span class="keywordflow">if</span> (!isdigit(*cp))
04599                     <span class="keywordflow">return</span> LABEL;
04600             <span class="keywordflow">return</span> NUMBER;
04601         }
04602         <span class="keywordflow">return</span> LABEL;
04603     }
04604 }
04605 
04606 <span class="keywordtype">int</span>
04607 snmp_get_token(FILE * fp, <span class="keywordtype">char</span> *token, <span class="keywordtype">int</span> maxtlen)
04608 {
04609     <span class="keywordflow">return</span> get_token(fp, token, maxtlen);
04610 }
04611 
04612 <span class="keywordtype">int</span>
04613 add_mibfile(<span class="keyword">const</span> <span class="keywordtype">char</span>* tmpstr, <span class=
"keyword">const</span> <span class="keywordtype">char</span>* d_name, FILE *ip )
04614 {
04615     FILE           *fp;
04616     <span class="keywordtype">char</span>            token[MAXTOKEN], token2[MAXTOKEN];
04617 
04618     <span class="comment">/*</span>
04619 <span class="comment">     * which module is this </span>
04620 <span class="comment">     */</span>
04621     <span class="keywordflow">if</span> ((fp = fopen(tmpstr, <span class="stringliteral">"r"</span>)) == NULL) {
04622         snmp_log_perror(tmpstr);
04623         <span class="keywordflow">return</span> 1;
04624     }
04625     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Checking file: %s...\n"</span>,
04626                 tmpstr));
04627     mibLine = 1;
04628     File = tmpstr;
04629     get_token(fp, token, MAXTOKEN);
04630     <span class="comment">/*</span>
04631 <span class="comment">     * simple test for this being a MIB </span>
04632 <span class="comment">     */</span>
04633     <span class="keywordflow">if</span> (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {
04634         new_module(token, tmpstr);
04635         <span class="keywordflow">if</span> (ip)
04636             fprintf(ip, <span class="stringliteral">"%s %s\n"</span>, token, d_name);
04637         fclose(fp);
04638         <span class="keywordflow">return</span> 0;
04639     } <span class="keywordflow">else</span> {
04640         fclose(fp);
04641         <span class="keywordflow">return</span> 1;
04642     }
04643 }
04644 
04645 <span class="comment">/* For Win32 platforms, the directory does not maintain a last modification</span>
04646 <span class="comment"> * date that we can compare with the modification date of the .index file.</span>
04647 <span class="comment"> * Therefore there is no way to know whether any .index file is valid.</span>
04648 <span class="comment"> * This is the reason for the #if !(defined(WIN32) || defined(cygwin))</span>
04649 <span class="comment"> * in the add_mibdir function</span>
04650 <span class="comment"> */</span>
04651 <span class="keywordtype">int</span>
04652 add_mibdir(<span class="keyword">const</span> <span class="keywordtype">char</span> *dirname)
04653 {
04654     FILE           *ip;
04655     DIR            *dir, *dir2;
04656     <span class="keyword">const</span> <span class="keywordtype">char</span>     *oldFile = File;
04657     <span class="keyword">struct </span>dirent  *file;
04658     <span class="keywordtype">char</span>            tmpstr[300];
04659     <span class="keywordtype">int</span>             count = 0;
04660 <span class="preprocessor">#if !(defined(WIN32) || defined(cygwin))</span>
04661     <span class="keywordtype">char</span>            token[MAXTOKEN];
04662     <span class="keywordtype">char</span> space;
04663     <span class="keywordtype">char</span> newline;
04664     <span class="keyword">struct </span>stat     dir_stat, idx_stat;
04665     <span class="keywordtype">char</span>            tmpstr1[300];
04666 <span class="preprocessor">#endif</span>
04667 
04668     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Scanning directory %s\n"</span>, dirname));
04669 <span class="preprocessor">#if !(defined(WIN32) || defined(cygwin))</span>
04670     snprintf(token, <span class="keyword">sizeof</span>(token), <span class=
"stringliteral">"%s/%s"</span>, dirname, <span class="stringliteral">".index"</span>);
04671     token[ <span class="keyword">sizeof</span>(token)-1 ] = 0;
04672     <span class="keywordflow">if</span> (stat(token, &amp;idx_stat) == 0 &amp;&amp; stat(dirname, &amp;dir_stat) == 0) {
04673         <span class="keywordflow">if</span> (dir_stat.st_mtime &lt; idx_stat.st_mtime) {
04674             DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"The index is good\n"</span>));
04675             <span class="keywordflow">if</span> ((ip = fopen(token, <span class="stringliteral">"r"</span>)) != NULL) {
04676                 <span class="keywordflow">while</span> (fscanf(ip, <span class=
"stringliteral">"%127s%c%299s%c"</span>, token, &amp;space, tmpstr,
04677                     &amp;newline) == 4) {
04678 
04679                     <span class="comment">/*</span>
04680 <span class="comment">                     * If an overflow of the token or tmpstr buffers has been</span>
04681 <span class="comment">                     * found log a message and break out of the while loop,</span>
04682 <span class="comment">                     * thus the rest of the file tokens will be ignored.</span>
04683 <span class="comment">                     */</span>
04684                     <span class="keywordflow">if</span> (space != <span class=
"charliteral">' '</span> || newline != <span class="charliteral">'\n'</span>) {
04685                         <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_ERR,
04686                             <span class="stringliteral">"add_mibdir: strings scanned in from %s/%s "</span> \
04687                             <span class="stringliteral">"are too large.  count = %d\n "</span>, dirname,
04688                             <span class="stringliteral">".index"</span>, count);
04689                             <span class="keywordflow">break</span>;
04690                     }
04691                    
04692                     snprintf(tmpstr1, <span class="keyword">sizeof</span>(tmpstr1), <span class=
"stringliteral">"%s/%s"</span>, dirname, tmpstr);
04693                     tmpstr1[ <span class="keyword">sizeof</span>(tmpstr1)-1 ] = 0;
04694                     new_module(token, tmpstr1);
04695                     count++;
04696                 }
04697                 fclose(ip);
04698                 <span class="keywordflow">return</span> count;
04699             } <span class="keywordflow">else</span>
04700                 DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Can't read index\n"</span>));
04701         } <span class="keywordflow">else</span>
04702             DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Index outdated\n"</span>));
04703     } <span class="keywordflow">else</span>
04704         DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class="stringliteral">"No index\n"</span>));
04705 <span class="preprocessor">#endif</span>
04706 
04707     <span class="keywordflow">if</span> ((dir = opendir(dirname))) {
04708         snprintf(tmpstr, <span class="keyword">sizeof</span>(tmpstr), <span class=
"stringliteral">"%s/.index"</span>, dirname);
04709         tmpstr[ <span class="keyword">sizeof</span>(tmpstr)-1 ] = 0;
04710         ip = fopen(tmpstr, <span class="stringliteral">"w"</span>);
04711         <span class="keywordflow">while</span> ((file = readdir(dir))) {
04712             <span class="comment">/*</span>
04713 <span class="comment">             * Only parse file names not beginning with a '.' </span>
04714 <span class="comment">             */</span>
04715             <span class="keywordflow">if</span> (file-&gt;d_name != NULL &amp;&amp; file-&gt;d_name[0] != <span class=
"charliteral">'.'</span>) {
04716                 snprintf(tmpstr, <span class="keyword">sizeof</span>(tmpstr), <span class=
"stringliteral">"%s/%s"</span>, dirname, file-&gt;d_name);
04717                 tmpstr[ <span class="keyword">sizeof</span>(tmpstr)-1 ] = 0;
04718                 <span class="keywordflow">if</span> ((dir2 = opendir(tmpstr))) {
04719                     <span class="comment">/*</span>
04720 <span class="comment">                     * file is a directory, don't read it </span>
04721 <span class="comment">                     */</span>
04722                     closedir(dir2);
04723                 } <span class="keywordflow">else</span> {
04724                     <span class="keywordflow">if</span> ( add_mibfile( tmpstr, file-&gt;d_name, ip ))
04725                         count++;
04726                 }
04727             }
04728         }
04729         File = oldFile;
04730         closedir(dir);
04731         <span class="keywordflow">if</span> (ip)
04732             fclose(ip);
04733         <span class="keywordflow">return</span> (count);
04734     }
04735     <span class="keywordflow">else</span>
04736         DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>,<span class=
"stringliteral">"cannot open MIB directory %s\n"</span>, dirname));
04737 
04738     <span class="keywordflow">return</span> (-1);
04739 }
04740 
04741 
04742 <span class="comment">/*</span>
04743 <span class="comment"> * Returns the root of the whole tree</span>
04744 <span class="comment"> *   (for backwards compatability)</span>
04745 <span class="comment"> */</span>
04746 <span class="keyword">struct </span>tree    *
04747 read_mib(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename)
04748 {
04749     FILE           *fp;
04750     <span class="keywordtype">char</span>            token[MAXTOKEN];
04751 
04752     fp = fopen(filename, <span class="stringliteral">"r"</span>);
04753     <span class="keywordflow">if</span> (fp == NULL) {
04754         snmp_log_perror(filename);
04755         <span class="keywordflow">return</span> NULL;
04756     }
04757     mibLine = 1;
04758     File = filename;
04759     DEBUGMSGTL((<span class="stringliteral">"parse-mibs"</span>, <span class=
"stringliteral">"Parsing file: %s...\n"</span>, filename));
04760     get_token(fp, token, MAXTOKEN);
04761     fclose(fp);
04762     new_module(token, filename);
04763     (void) read_module(token);
04764 
04765     <span class="keywordflow">return</span> tree_head;
04766 }
04767 
04768 
04769 <span class="keyword">struct </span>tree    *
04770 read_all_mibs()
04771 {
04772     <span class="keyword">struct </span>module  *mp;
04773 
04774     <span class="keywordflow">for</span> (mp = module_head; mp; mp = mp-&gt;next)
04775         <span class="keywordflow">if</span> (mp-&gt;no_imports == -1)
04776             read_module(mp-&gt;name);
04777     adopt_orphans();
04778 
04779     <span class="keywordflow">return</span> tree_head;
04780 }
04781 
04782 
04783 <span class="preprocessor">#ifdef TEST</span>
04784 main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
04785 {
04786     <span class="keywordtype">int</span>             i;
04787     <span class="keyword">struct </span>tree    *tp;
04788     netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_WARNINGS, 2);
04789 
04790     <a class="code" href="group__mib__utilities.html#ga56">init_mib</a>();
04791 
04792     <span class="keywordflow">if</span> (argc == 1)
04793         (void) read_all_mibs();
04794     <span class="keywordflow">else</span>
04795         <span class="keywordflow">for</span> (i = 1; i &lt; argc; i++)
04796             read_mib(argv[i]);
04797 
04798     <span class="keywordflow">for</span> (tp = tree_head; tp; tp = tp-&gt;next_peer)
04799         print_subtree(stdout, tp, 0);
04800     free_tree(tree_head);
04801 
04802     <span class="keywordflow">return</span> 0;
04803 }
04804 <span class="preprocessor">#endif                          </span><span class="comment">/* TEST */</span>
04805 
04806 <span class="keyword">static</span> <span class="keywordtype">int</span>
04807 parseQuoteString(FILE * fp, <span class="keywordtype">char</span> *token, <span class="keywordtype">int</span> maxtlen)
04808 {
04809     <span class="keyword">register</span> <span class="keywordtype">int</span>    ch;
04810     <span class="keywordtype">int</span>             count = 0;
04811     <span class="keywordtype">int</span>             too_long = 0;
04812     <span class="keywordtype">char</span>           *token_start = token;
04813 
04814     <span class="keywordflow">for</span> (ch = getc(fp); ch != EOF; ch = getc(fp)) {
04815         <span class="keywordflow">if</span> (ch == <span class="charliteral">'\r'</span>)
04816             <span class="keywordflow">continue</span>;
04817         <span class="keywordflow">if</span> (ch == <span class="charliteral">'\n'</span>) {
04818             mibLine++;
04819         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class=
"charliteral">'"'</span>) {
04820             *token = <span class="charliteral">'\0'</span>;
04821             <span class="keywordflow">if</span> (too_long &amp;&amp; netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
04822                                            NETSNMP_DS_LIB_MIB_WARNINGS) &gt; 1) {
04823                 <span class="comment">/*</span>
04824 <span class="comment">                 * show short form for brevity sake </span>
04825 <span class="comment">                 */</span>
04826                 <span class="keywordtype">char</span>            ch_save = *(token_start + 50);
04827                 *(token_start + 50) = <span class="charliteral">'\0'</span>;
04828                 print_error(<span class="stringliteral">"Warning: string too long"</span>,
04829                             token_start, QUOTESTRING);
04830                 *(token_start + 50) = ch_save;
04831             }
04832             <span class="keywordflow">return</span> QUOTESTRING;
04833         }
04834         <span class="comment">/*</span>
04835 <span class="comment">         * maximum description length check.  If greater, keep parsing</span>
04836 <span class="comment">         * but truncate the string </span>
04837 <span class="comment">         */</span>
04838         <span class="keywordflow">if</span> (++count &lt; maxtlen)
04839             *token++ = ch;
04840         <span class="keywordflow">else</span>
04841             too_long = 1;
04842     }
04843 
04844     <span class="keywordflow">return</span> 0;
04845 }
04846 
04847 <span class="comment">/*</span>
04848 <span class="comment"> * struct index_list *</span>
04849 <span class="comment"> * getIndexes(FILE *fp):</span>
04850 <span class="comment"> *   This routine parses a string like  { blah blah blah } and returns a</span>
04851 <span class="comment"> *   list of the strings enclosed within it.</span>
04852 <span class="comment"> *</span>
04853 <span class="comment"> */</span>
04854 <span class="keyword">static</span> <span class="keyword">struct </span>index_list *
04855 getIndexes(FILE * fp, <span class="keyword">struct</span> index_list **retp)
04856 {
04857     <span class="keywordtype">int</span>             type;
04858     <span class="keywordtype">char</span>            token[MAXTOKEN];
04859     <span class="keywordtype">char</span>            nextIsImplied = 0;
04860 
04861     <span class="keyword">struct </span>index_list *mylist = NULL;
04862     <span class="keyword">struct </span>index_list **mypp = &amp;mylist;
04863 
04864     free_indexes(retp);
04865 
04866     type = get_token(fp, token, MAXTOKEN);
04867 
04868     <span class="keywordflow">if</span> (type != LEFTBRACKET) {
04869         <span class="keywordflow">return</span> NULL;
04870     }
04871 
04872     type = get_token(fp, token, MAXTOKEN);
04873     <span class="keywordflow">while</span> (type != RIGHTBRACKET &amp;&amp; type != ENDOFFILE) {
04874         <span class="keywordflow">if</span> ((type == LABEL) || (type &amp; SYNTAX_MASK)) {
04875             *mypp =
04876                 (<span class="keyword">struct </span>index_list *) calloc(1, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> index_list));
04877             <span class="keywordflow">if</span> (*mypp) {
04878                 (*mypp)-&gt;ilabel = strdup(token);
04879                 (*mypp)-&gt;isimplied = nextIsImplied;
04880                 mypp = &amp;(*mypp)-&gt;next;
04881                 nextIsImplied = 0;
04882             }
04883         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == IMPLIED) {
04884             nextIsImplied = 1;
04885         }
04886         type = get_token(fp, token, MAXTOKEN);
04887     }
04888 
04889     *retp = mylist;
04890     <span class="keywordflow">return</span> mylist;
04891 }
04892 
04893 <span class="keyword">static</span> <span class="keyword">struct </span>varbind_list *
04894 getVarbinds(FILE * fp, <span class="keyword">struct</span> varbind_list **retp)
04895 {
04896     <span class="keywordtype">int</span>             type;
04897     <span class="keywordtype">char</span>            token[MAXTOKEN];
04898 
04899     <span class="keyword">struct </span>varbind_list *mylist = NULL;
04900     <span class="keyword">struct </span>varbind_list **mypp = &amp;mylist;
04901 
04902     free_varbinds(retp);
04903 
04904     type = get_token(fp, token, MAXTOKEN);
04905 
04906     <span class="keywordflow">if</span> (type != LEFTBRACKET) {
04907         <span class="keywordflow">return</span> NULL;
04908     }
04909 
04910     type = get_token(fp, token, MAXTOKEN);
04911     <span class="keywordflow">while</span> (type != RIGHTBRACKET &amp;&amp; type != ENDOFFILE) {
04912         <span class="keywordflow">if</span> ((type == LABEL) || (type &amp; SYNTAX_MASK)) {
04913             *mypp =
04914                 (<span class="keyword">struct </span>varbind_list *) calloc(1,
04915                                                <span class="keyword">sizeof</span>(<span class="keyword">struct</span>
04916                                                       varbind_list));
04917             <span class="keywordflow">if</span> (*mypp) {
04918                 (*mypp)-&gt;vblabel = strdup(token);
04919                 mypp = &amp;(*mypp)-&gt;next;
04920             }
04921         }
04922         type = get_token(fp, token, MAXTOKEN);
04923     }
04924 
04925     *retp = mylist;
04926     <span class="keywordflow">return</span> mylist;
04927 }
04928 
04929 <span class="keyword">static</span> <span class="keywordtype">void</span>
04930 free_indexes(<span class="keyword">struct</span> index_list **spp)
04931 {
04932     <span class="keywordflow">if</span> (spp &amp;&amp; *spp) {
04933         <span class="keyword">struct </span>index_list *pp, *npp;
04934 
04935         pp = *spp;
04936         *spp = NULL;
04937 
04938         <span class="keywordflow">while</span> (pp) {
04939             npp = pp-&gt;next;
04940             <span class="keywordflow">if</span> (pp-&gt;ilabel)
04941                 free(pp-&gt;ilabel);
04942             free(pp);
04943             pp = npp;
04944         }
04945     }
04946 }
04947 
04948 <span class="keyword">static</span> <span class="keywordtype">void</span>
04949 free_varbinds(<span class="keyword">struct</span> varbind_list **spp)
04950 {
04951     <span class="keywordflow">if</span> (spp &amp;&amp; *spp) {
04952         <span class="keyword">struct </span>varbind_list *pp, *npp;
04953 
04954         pp = *spp;
04955         *spp = NULL;
04956 
04957         <span class="keywordflow">while</span> (pp) {
04958             npp = pp-&gt;next;
04959             <span class="keywordflow">if</span> (pp-&gt;vblabel)
04960                 free(pp-&gt;vblabel);
04961             free(pp);
04962             pp = npp;
04963         }
04964     }
04965 }
04966 
04967 <span class="keyword">static</span> <span class="keywordtype">void</span>
04968 free_ranges(<span class="keyword">struct</span> range_list **spp)
04969 {
04970     <span class="keywordflow">if</span> (spp &amp;&amp; *spp) {
04971         <span class="keyword">struct </span>range_list *pp, *npp;
04972 
04973         pp = *spp;
04974         *spp = NULL;
04975 
04976         <span class="keywordflow">while</span> (pp) {
04977             npp = pp-&gt;next;
04978             free(pp);
04979             pp = npp;
04980         }
04981     }
04982 }
04983 
04984 <span class="keyword">static</span> <span class="keywordtype">void</span>
04985 free_enums(<span class="keyword">struct</span> enum_list **spp)
04986 {
04987     <span class="keywordflow">if</span> (spp &amp;&amp; *spp) {
04988         <span class="keyword">struct </span>enum_list *pp, *npp;
04989 
04990         pp = *spp;
04991         *spp = NULL;
04992 
04993         <span class="keywordflow">while</span> (pp) {
04994             npp = pp-&gt;next;
04995             <span class="keywordflow">if</span> (pp-&gt;label)
04996                 free(pp-&gt;label);
04997             free(pp);
04998             pp = npp;
04999         }
05000     }
05001 }
05002 
05003 <span class="keyword">static</span> <span class="keyword">struct </span>enum_list *
05004 copy_enums(<span class="keyword">struct</span> enum_list *sp)
05005 {
05006     <span class="keyword">struct </span>enum_list *xp = NULL, **spp = &amp;xp;
05007 
05008     <span class="keywordflow">while</span> (sp) {
05009         *spp = (<span class="keyword">struct </span>enum_list *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> enum_list));
05010         <span class="keywordflow">if</span> (!*spp)
05011             <span class="keywordflow">break</span>;
05012         (*spp)-&gt;label = strdup(sp-&gt;label);
05013         (*spp)-&gt;value = sp-&gt;value;
05014         spp = &amp;(*spp)-&gt;next;
05015         sp = sp-&gt;next;
05016     }
05017     <span class="keywordflow">return</span> (xp);
05018 }
05019 
05020 <span class="keyword">static</span> <span class="keyword">struct </span>range_list *
05021 copy_ranges(<span class="keyword">struct</span> range_list *sp)
05022 {
05023     <span class="keyword">struct </span>range_list *xp = NULL, **spp = &amp;xp;
05024 
05025     <span class="keywordflow">while</span> (sp) {
05026         *spp = (<span class="keyword">struct </span>range_list *) calloc(1, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> range_list));
05027         <span class="keywordflow">if</span> (!*spp)
05028             <span class="keywordflow">break</span>;
05029         (*spp)-&gt;low = sp-&gt;low;
05030         (*spp)-&gt;high = sp-&gt;high;
05031         spp = &amp;(*spp)-&gt;next;
05032         sp = sp-&gt;next;
05033     }
05034     <span class="keywordflow">return</span> (xp);
05035 }
05036 
05037 <span class="comment">/*</span>
05038 <span class="comment"> * This routine parses a string like  { blah blah blah } and returns OBJID if</span>
05039 <span class="comment"> * it is well formed, and NULL if not.</span>
05040 <span class="comment"> */</span>
05041 <span class="keyword">static</span> <span class="keywordtype">int</span>
05042 tossObjectIdentifier(FILE * fp)
05043 {
05044     <span class="keywordtype">int</span>             type;
05045     <span class="keywordtype">char</span>            token[MAXTOKEN];
05046     <span class="keywordtype">int</span>             bracketcount = 1;
05047 
05048     type = get_token(fp, token, MAXTOKEN);
05049 
05050     <span class="keywordflow">if</span> (type != LEFTBRACKET)
05051         <span class="keywordflow">return</span> 0;
05052     <span class="keywordflow">while</span> ((type != RIGHTBRACKET || bracketcount &gt; 0) &amp;&amp; type != ENDOFFILE) {
05053         type = get_token(fp, token, MAXTOKEN);
05054         <span class="keywordflow">if</span> (type == LEFTBRACKET)
05055             bracketcount++;
05056         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == RIGHTBRACKET)
05057             bracketcount--;
05058     }
05059 
05060     <span class="keywordflow">if</span> (type == RIGHTBRACKET)
05061         <span class="keywordflow">return</span> OBJID;
05062     <span class="keywordflow">else</span>
05063         <span class="keywordflow">return</span> 0;
05064 }
05065 
05066 <span class="comment">/* Find node in any MIB module</span>
05067 <span class="comment">   Used by Perl modules         */</span>
05068 <span class="keyword">struct </span>tree    *
05069 find_node(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class=
"keyword">struct</span> tree *subtree)
05070 {                               <span class="comment">/* Unused */</span>
05071     <span class="keywordflow">return</span> (find_tree_node(name, -1));
05072 }
05073 
05074 <span class="comment">/* Find node in specific MIB module</span>
05075 <span class="comment">   Used by Perl modules         */</span>
05076 <span class="keyword">struct </span>tree    *
05077 find_node2(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *module)
05078 {                               
05079   <span class="keywordtype">int</span> modid = -1;
05080   <span class="keywordflow">if</span> (module) {
05081     modid = which_module(module);
05082   }
05083   <span class="keywordflow">if</span> (modid == -1)
05084   {
05085     <span class="keywordflow">return</span> (NULL);
05086   }
05087   <span class="keywordflow">return</span> (find_tree_node(name, modid));
05088 }
05089 
05090 <span class="keyword">struct </span>module  *
05091 find_module(<span class="keywordtype">int</span> mid)
05092 {
05093     <span class="keyword">struct </span>module  *mp;
05094 
05095     <span class="keywordflow">for</span> (mp = module_head; mp != NULL; mp = mp-&gt;next) {
05096         <span class="keywordflow">if</span> (mp-&gt;modid == mid)
05097             <span class="keywordflow">break</span>;
05098     }
05099     <span class="keywordflow">if</span> (mp != 0)
05100         <span class="keywordflow">return</span> mp;
05101     <span class="keywordflow">return</span> NULL;
05102 }
05103 
05104 
05105 <span class="keyword">static</span> <span class="keywordtype">char</span>     leave_indent[256];
05106 <span class="keyword">static</span> <span class="keywordtype">int</span>      leave_was_simple;
05107 
05108 <span class="keyword">static</span> <span class="keywordtype">void</span>
05109 print_mib_leaves(FILE * f, <span class="keyword">struct</span> tree *tp, <span class="keywordtype">int</span> width)
05110 {
05111     <span class="keyword">struct </span>tree    *ntp;
05112     <span class="keywordtype">char</span>           *ip = leave_indent + strlen(leave_indent) - 1;
05113     <span class="keywordtype">char</span>            last_ipch = *ip;
05114 
05115     *ip = <span class="charliteral">'+'</span>;
05116     <span class="keywordflow">if</span> (tp-&gt;type == TYPE_OTHER || tp-&gt;type &gt; TYPE_SIMPLE_LAST) {
05117         fprintf(f, <span class="stringliteral">"%s--%s(%ld)\n"</span>, leave_indent, tp-&gt;label, tp-&gt;subid);
05118         <span class="keywordflow">if</span> (tp-&gt;indexes) {
05119             <span class="keyword">struct </span>index_list *xp = tp-&gt;indexes;
05120             <span class="keywordtype">int</span>             first = 1, cpos = 0, len, cmax =
05121                 width - strlen(leave_indent) - 12;
05122             *ip = last_ipch;
05123             fprintf(f, <span class="stringliteral">"%s  |  Index: "</span>, leave_indent);
05124             <span class="keywordflow">while</span> (xp) {
05125                 <span class="keywordflow">if</span> (first)
05126                     first = 0;
05127                 <span class="keywordflow">else</span>
05128                     fprintf(f, <span class="stringliteral">", "</span>);
05129                 cpos += (len = strlen(xp-&gt;ilabel) + 2);
05130                 <span class="keywordflow">if</span> (cpos &gt; cmax) {
05131                     fprintf(f, <span class="stringliteral">"\n"</span>);
05132                     fprintf(f, <span class="stringliteral">"%s  |         "</span>, leave_indent);
05133                     cpos = len;
05134                 }
05135                 fprintf(f, <span class="stringliteral">"%s"</span>, xp-&gt;ilabel);
05136                 xp = xp-&gt;next;
05137             }
05138             fprintf(f, <span class="stringliteral">"\n"</span>);
05139             *ip = <span class="charliteral">'+'</span>;
05140         }
05141     } <span class="keywordflow">else</span> {
05142         <span class="keyword">const</span> <span class="keywordtype">char</span>     *acc, *typ;
05143         <span class="keywordtype">int</span>             size = 0;
05144         <span class="keywordflow">switch</span> (tp-&gt;access) {
05145         <span class="keywordflow">case</span> MIB_ACCESS_NOACCESS:
05146             acc = <span class="stringliteral">"----"</span>;
05147             <span class="keywordflow">break</span>;
05148         <span class="keywordflow">case</span> MIB_ACCESS_READONLY:
05149             acc = <span class="stringliteral">"-R--"</span>;
05150             <span class="keywordflow">break</span>;
05151         <span class="keywordflow">case</span> MIB_ACCESS_WRITEONLY:
05152             acc = <span class="stringliteral">"--W-"</span>;
05153             <span class="keywordflow">break</span>;
05154         <span class="keywordflow">case</span> MIB_ACCESS_READWRITE:
05155             acc = <span class="stringliteral">"-RW-"</span>;
05156             <span class="keywordflow">break</span>;
05157         <span class="keywordflow">case</span> MIB_ACCESS_NOTIFY:
05158             acc = <span class="stringliteral">"---N"</span>;
05159             <span class="keywordflow">break</span>;
05160         <span class="keywordflow">case</span> MIB_ACCESS_CREATE:
05161             acc = <span class="stringliteral">"CR--"</span>;
05162             <span class="keywordflow">break</span>;
05163         <span class="keywordflow">default</span>:
05164             acc = <span class="stringliteral">"    "</span>;
05165             <span class="keywordflow">break</span>;
05166         }
05167         <span class="keywordflow">switch</span> (tp-&gt;type) {
05168         <span class="keywordflow">case</span> TYPE_OBJID:
05169             typ = <span class="stringliteral">"ObjID    "</span>;
05170             <span class="keywordflow">break</span>;
05171         <span class="keywordflow">case</span> TYPE_OCTETSTR:
05172             typ = <span class="stringliteral">"String   "</span>;
05173             size = 1;
05174             <span class="keywordflow">break</span>;
05175         <span class="keywordflow">case</span> TYPE_INTEGER:
05176             <span class="keywordflow">if</span> (tp-&gt;enums)
05177                 typ = <span class="stringliteral">"EnumVal  "</span>;
05178             <span class="keywordflow">else</span>
05179                 typ = <span class="stringliteral">"INTEGER  "</span>;
05180             <span class="keywordflow">break</span>;
05181         <span class="keywordflow">case</span> TYPE_NETADDR:
05182             typ = <span class="stringliteral">"NetAddr  "</span>;
05183             <span class="keywordflow">break</span>;
05184         <span class="keywordflow">case</span> TYPE_IPADDR:
05185             typ = <span class="stringliteral">"IpAddr   "</span>;
05186             <span class="keywordflow">break</span>;
05187         <span class="keywordflow">case</span> TYPE_COUNTER:
05188             typ = <span class="stringliteral">"Counter  "</span>;
05189             <span class="keywordflow">break</span>;
05190         <span class="keywordflow">case</span> TYPE_GAUGE:
05191             typ = <span class="stringliteral">"Gauge    "</span>;
05192             <span class="keywordflow">break</span>;
05193         <span class="keywordflow">case</span> TYPE_TIMETICKS:
05194             typ = <span class="stringliteral">"TimeTicks"</span>;
05195             <span class="keywordflow">break</span>;
05196         <span class="keywordflow">case</span> TYPE_OPAQUE:
05197             typ = <span class="stringliteral">"Opaque   "</span>;
05198             size = 1;
05199             <span class="keywordflow">break</span>;
05200         <span class="keywordflow">case</span> TYPE_NULL:
05201             typ = <span class="stringliteral">"Null     "</span>;
05202             <span class="keywordflow">break</span>;
05203         <span class="keywordflow">case</span> TYPE_COUNTER64:
05204             typ = <span class="stringliteral">"Counter64"</span>;
05205             <span class="keywordflow">break</span>;
05206         <span class="keywordflow">case</span> TYPE_BITSTRING:
05207             typ = <span class="stringliteral">"BitString"</span>;
05208             <span class="keywordflow">break</span>;
05209         <span class="keywordflow">case</span> TYPE_NSAPADDRESS:
05210             typ = <span class="stringliteral">"NsapAddr "</span>;
05211             <span class="keywordflow">break</span>;
05212         <span class="keywordflow">case</span> TYPE_UNSIGNED32:
05213             typ = <span class="stringliteral">"Unsigned "</span>;
05214             <span class="keywordflow">break</span>;
05215         <span class="keywordflow">case</span> TYPE_UINTEGER:
05216             typ = <span class="stringliteral">"UInteger "</span>;
05217             <span class="keywordflow">break</span>;
05218         <span class="keywordflow">case</span> TYPE_INTEGER32:
05219             typ = <span class="stringliteral">"Integer32"</span>;
05220             <span class="keywordflow">break</span>;
05221         <span class="keywordflow">default</span>:
05222             typ = <span class="stringliteral">"         "</span>;
05223             <span class="keywordflow">break</span>;
05224         }
05225         fprintf(f, <span class="stringliteral">"%s-- %s %s %s(%ld)\n"</span>, leave_indent, acc, typ,
05226                 tp-&gt;label, tp-&gt;subid);
05227         *ip = last_ipch;
05228         <span class="keywordflow">if</span> (tp-&gt;tc_index &gt;= 0)
05229             fprintf(f, <span class="stringliteral">"%s        Textual Convention: %s\n"</span>, leave_indent,
05230                     tclist[tp-&gt;tc_index].descriptor);
05231         <span class="keywordflow">if</span> (tp-&gt;enums) {
05232             <span class="keyword">struct </span>enum_list *ep = tp-&gt;enums;
05233             <span class="keywordtype">int</span>             cpos = 0, cmax =
05234                 width - strlen(leave_indent) - 16;
05235             fprintf(f, <span class="stringliteral">"%s        Values: "</span>, leave_indent);
05236             <span class="keywordflow">while</span> (ep) {
05237                 <span class="keywordtype">char</span>            buf[80];
05238                 <span class="keywordtype">int</span>             bufw;
05239                 <span class="keywordflow">if</span> (ep != tp-&gt;enums)
05240                     fprintf(f, <span class="stringliteral">", "</span>);
05241                 snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class=
"stringliteral">"%s(%d)"</span>, ep-&gt;label, ep-&gt;value);
05242                 buf[ <span class="keyword">sizeof</span>(buf)-1 ] = 0;
05243                 cpos += (bufw = strlen(buf) + 2);
05244                 <span class="keywordflow">if</span> (cpos &gt;= cmax) {
05245                     fprintf(f, <span class="stringliteral">"\n%s                "</span>, leave_indent);
05246                     cpos = bufw;
05247                 }
05248                 fprintf(f, <span class="stringliteral">"%s"</span>, buf);
05249                 ep = ep-&gt;next;
05250             }
05251             fprintf(f, <span class="stringliteral">"\n"</span>);
05252         }
05253         <span class="keywordflow">if</span> (tp-&gt;ranges) {
05254             <span class="keyword">struct </span>range_list *rp = tp-&gt;ranges;
05255             <span class="keywordflow">if</span> (size)
05256                 fprintf(f, <span class="stringliteral">"%s        Size: "</span>, leave_indent);
05257             <span class="keywordflow">else</span>
05258                 fprintf(f, <span class="stringliteral">"%s        Range: "</span>, leave_indent);
05259             <span class="keywordflow">while</span> (rp) {
05260                 <span class="keywordflow">if</span> (rp != tp-&gt;ranges)
05261                     fprintf(f, <span class="stringliteral">" | "</span>);
05262                 <span class="keywordflow">if</span> (rp-&gt;low == rp-&gt;high)
05263                     fprintf(f, <span class="stringliteral">"%d"</span>, rp-&gt;low);
05264                 <span class="keywordflow">else</span>
05265                     fprintf(f, <span class="stringliteral">"%d..%d"</span>, rp-&gt;low, rp-&gt;high);
05266                 rp = rp-&gt;next;
05267             }
05268             fprintf(f, <span class="stringliteral">"\n"</span>);
05269         }
05270     }
05271     *ip = last_ipch;
05272     strcat(leave_indent, <span class="stringliteral">"  |"</span>);
05273     leave_was_simple = tp-&gt;type != TYPE_OTHER;
05274 
05275     {
05276         <span class="keywordtype">int</span>             i, j, count = 0;
05277         <span class="keyword">struct </span>leave {
05278             oid             id;
05279             <span class="keyword">struct </span>tree    *tp;
05280         }              *leaves, *lp;
05281 
05282         <span class="keywordflow">for</span> (ntp = tp-&gt;child_list; ntp; ntp = ntp-&gt;next_peer)
05283             count++;
05284         <span class="keywordflow">if</span> (count) {
05285             leaves = (<span class="keyword">struct </span>leave *) calloc(count, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> leave));
05286             <span class="keywordflow">if</span> (!leaves)
05287                 <span class="keywordflow">return</span>;
05288             <span class="keywordflow">for</span> (ntp = tp-&gt;child_list, count = 0; ntp;
05289                  ntp = ntp-&gt;next_peer) {
05290                 <span class="keywordflow">for</span> (i = 0, lp = leaves; i &lt; count; i++, lp++)
05291                     <span class="keywordflow">if</span> (lp-&gt;id &gt;= ntp-&gt;subid)
05292                         <span class="keywordflow">break</span>;
05293                 <span class="keywordflow">for</span> (j = count; j &gt; i; j--)
05294                     leaves[j] = leaves[j - 1];
05295                 lp-&gt;id = ntp-&gt;subid;
05296                 lp-&gt;tp = ntp;
05297                 count++;
05298             }
05299             <span class="keywordflow">for</span> (i = 1, lp = leaves; i &lt;= count; i++, lp++) {
05300                 <span class="keywordflow">if</span> (!leave_was_simple || lp-&gt;tp-&gt;type == 0)
05301                     fprintf(f, <span class="stringliteral">"%s\n"</span>, leave_indent);
05302                 <span class="keywordflow">if</span> (i == count)
05303                     ip[3] = <span class="charliteral">' '</span>;
05304                 print_mib_leaves(f, lp-&gt;tp, width);
05305             }
05306             free(leaves);
05307             leave_was_simple = 0;
05308         }
05309     }
05310     ip[1] = 0;
05311 }
05312 
05313 <span class="keywordtype">void</span>
05314 print_mib_tree(FILE * f, <span class="keyword">struct</span> tree *tp, <span class="keywordtype">int</span> width)
05315 {
05316     leave_indent[0] = <span class="charliteral">' '</span>;
05317     leave_indent[1] = 0;
05318     leave_was_simple = 1;
05319     print_mib_leaves(f, tp, width);
05320 }
05321 
05322 
05323 <span class="comment">/*</span>
05324 <span class="comment"> * Merge the parsed object identifier with the existing node.</span>
05325 <span class="comment"> * If there is a problem with the identifier, release the existing node.</span>
05326 <span class="comment"> */</span>
05327 <span class="keyword">static</span> <span class="keyword">struct </span>node *
05328 merge_parse_objectid(<span class="keyword">struct</span> node *np, FILE * fp, <span class="keywordtype">char</span> *name)
05329 {
05330     <span class="keyword">struct </span>node    *nnp;
05331     <span class="comment">/*</span>
05332 <span class="comment">     * printf("merge defval --&gt; %s\n",np-&gt;defaultValue); </span>
05333 <span class="comment">     */</span>
05334     nnp = parse_objectid(fp, name);
05335     <span class="keywordflow">if</span> (nnp) {
05336 
05337         <span class="comment">/*</span>
05338 <span class="comment">         * apply last OID sub-identifier data to the information </span>
05339 <span class="comment">         */</span>
05340         <span class="comment">/*</span>
05341 <span class="comment">         * already collected for this node. </span>
05342 <span class="comment">         */</span>
05343         <span class="keyword">struct </span>node    *headp, *nextp;
05344         <span class="keywordtype">int</span>             ncount = 0;
05345         nextp = headp = nnp;
05346         <span class="keywordflow">while</span> (nnp-&gt;next) {
05347             nextp = nnp;
05348             ncount++;
05349             nnp = nnp-&gt;next;
05350         }
05351 
05352         np-&gt;label = nnp-&gt;label;
05353         np-&gt;subid = nnp-&gt;subid;
05354         np-&gt;modid = nnp-&gt;modid;
05355         np-&gt;parent = nnp-&gt;parent;
05356         <span class="keywordflow">if</span> (nnp-&gt;filename != NULL) {
05357           free(nnp-&gt;filename);
05358         }
05359         free(nnp);
05360 
05361         <span class="keywordflow">if</span> (ncount) {
05362             nextp-&gt;next = np;
05363             np = headp;
05364         }
05365     } <span class="keywordflow">else</span> {
05366         free_node(np);
05367         np = NULL;
05368     }
05369 
05370     <span class="keywordflow">return</span> np;
05371 }
05372 
05373 <span class="comment">/*</span>
05374 <span class="comment"> * transfer data to tree from node</span>
05375 <span class="comment"> *</span>
05376 <span class="comment"> * move pointers for alloc'd data from np to tp.</span>
05377 <span class="comment"> * this prevents them from being freed when np is released.</span>
05378 <span class="comment"> * parent member is not moved.</span>
05379 <span class="comment"> *</span>
05380 <span class="comment"> * CAUTION: nodes may be repeats of existing tree nodes.</span>
05381 <span class="comment"> * This can happen especially when resolving IMPORT clauses.</span>
05382 <span class="comment"> *</span>
05383 <span class="comment"> */</span>
05384 <span class="keyword">static</span> <span class="keywordtype">void</span>
05385 tree_from_node(<span class="keyword">struct</span> tree *tp, <span class="keyword">struct</span> node *np)
05386 {
05387     free_partial_tree(tp, FALSE);
05388 
05389     tp-&gt;label = np-&gt;label;
05390     np-&gt;label = NULL;
05391     tp-&gt;enums = np-&gt;enums;
05392     np-&gt;enums = NULL;
05393     tp-&gt;ranges = np-&gt;ranges;
05394     np-&gt;ranges = NULL;
05395     tp-&gt;indexes = np-&gt;indexes;
05396     np-&gt;indexes = NULL;
05397     tp-&gt;augments = np-&gt;augments;
05398     np-&gt;augments = NULL;
05399     tp-&gt;varbinds = np-&gt;varbinds;
05400     np-&gt;varbinds = NULL;
05401     tp-&gt;hint = np-&gt;hint;
05402     np-&gt;hint = NULL;
05403     tp-&gt;units = np-&gt;units;
05404     np-&gt;units = NULL;
05405     tp-&gt;description = np-&gt;description;
05406     np-&gt;description = NULL;
05407     tp-&gt;reference = np-&gt;reference;
05408     np-&gt;reference = NULL;
05409     tp-&gt;defaultValue = np-&gt;defaultValue;
05410     np-&gt;defaultValue = NULL;
05411     tp-&gt;subid = np-&gt;subid;
05412     tp-&gt;tc_index = np-&gt;tc_index;
05413     tp-&gt;type = translation_table[np-&gt;type];
05414     tp-&gt;access = np-&gt;access;
05415     tp-&gt;status = np-&gt;status;
05416 
05417     <a class="code" href="group__mib__utilities.html#ga60">set_function</a>(tp);
05418 }
05419 
05420 <span class="preprocessor">#endif </span><span class="comment">/* DISABLE_MIB_LOADING */</span>
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small><!--#include virtual="/sfbutton.html" --><br />
    Generated on Thu Oct 28 21:46:58 2004 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

