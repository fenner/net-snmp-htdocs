<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>snmpUDPDomain.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
00002 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00003 <span class="comment"> * that may apply:</span>
00004 <span class="comment"> */</span>
00005 <span class="comment">/*</span>
00006 <span class="comment"> * Portions of this file are copyrighted by:</span>
00007 <span class="comment"> * Copyright Copyright 2003 Sun Microsystems, Inc. All rights reserved.</span>
00008 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00009 <span class="comment"> * distributed with the Net-SNMP package.</span>
00010 <span class="comment"> */</span>
00011 
00012 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00013 
00014 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00015 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00016 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00017 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00018 
00019 <span class="preprocessor">#if HAVE_STRING_H</span>
00020 <span class="preprocessor">#include &lt;string.h&gt;</span>
00021 <span class="preprocessor">#else</span>
00022 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00023 <span class="preprocessor">#endif</span>
00024 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00025 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor">#if HAVE_UNISTD_H</span>
00028 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00029 <span class="preprocessor">#endif</span>
00030 <span class="preprocessor">#if HAVE_SYS_SOCKET_H</span>
00031 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00032 <span class="preprocessor">#endif</span>
00033 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00034 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00035 <span class="preprocessor">#endif</span>
00036 <span class="preprocessor">#if HAVE_ARPA_INET_H</span>
00037 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
00038 <span class="preprocessor">#endif</span>
00039 <span class="preprocessor">#if HAVE_NETDB_H</span>
00040 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00041 <span class="preprocessor">#endif</span>
00042 
00043 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00044 <span class="preprocessor">#include &lt;winsock2.h&gt;</span>
00045 <span class="preprocessor">#include &lt;ws2tcpip.h&gt;</span>
00046 <span class="preprocessor">#endif</span>
00047 
00048 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00049 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00050 <span class="preprocessor">#endif</span>
00051 
00052 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00053 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00054 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00055 
00056 <span class="preprocessor">#include &lt;net-snmp/library/snmp_transport.h&gt;</span>
00057 <span class="preprocessor">#include &lt;net-snmp/library/snmpUDPDomain.h&gt;</span>
00058 
00059 <span class="preprocessor">#ifndef INADDR_NONE</span>
00060 <span class="preprocessor">#define INADDR_NONE     -1</span>
00061 <span class="preprocessor">#endif</span>
00062 
00063 <span class="keyword">static</span> netsnmp_tdomain udpDomain;
00064 
00065 <span class="comment">/*</span>
00066 <span class="comment"> * not static, since snmpUDPIPv6Domain needs it, but not public, either.</span>
00067 <span class="comment"> * (ie don't put it in a public header.)</span>
00068 <span class="comment"> */</span>
00069 <span class="keywordtype">void</span> _netsnmp_udp_sockopt_set(<span class="keywordtype">int</span> fd, <span class=
"keywordtype">int</span> server);
00070 
00071 <span class="comment">/*</span>
00072 <span class="comment"> * Return a string representing the address in data, or else the "far end"</span>
00073 <span class="comment"> * address if data is NULL.  </span>
00074 <span class="comment"> */</span>
00075 
00076 <span class="keyword">static</span> <span class="keywordtype">char</span> *
00077 netsnmp_udp_fmtaddr(netsnmp_transport *t, <span class="keywordtype">void</span> *data, <span class=
"keywordtype">int</span> len)
00078 {
00079     <span class="keyword">struct </span>sockaddr_in *to = NULL;
00080 
00081     <span class="keywordflow">if</span> (data != NULL &amp;&amp; len == <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_in)) {
00082         to = (<span class="keyword">struct </span>sockaddr_in *) data;
00083     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL) {
00084         to = (<span class="keyword">struct </span>sockaddr_in *) t-&gt;data;
00085     }
00086     <span class="keywordflow">if</span> (to == NULL) {
00087         <span class="keywordflow">return</span> strdup(<span class="stringliteral">"UDP: unknown"</span>);
00088     } <span class="keywordflow">else</span> {
00089         <span class="keywordtype">char</span> tmp[64];
00090 
00091         sprintf(tmp, <span class="stringliteral">"UDP: [%s]:%hd"</span>,
00092                 inet_ntoa(to-&gt;sin_addr), ntohs(to-&gt;sin_port));
00093         <span class="keywordflow">return</span> strdup(tmp);
00094     }
00095 }
00096 
00097 
00098 
00099 <span class="comment">/*</span>
00100 <span class="comment"> * You can write something into opaque that will subsequently get passed back </span>
00101 <span class="comment"> * to your send function if you like.  For instance, you might want to</span>
00102 <span class="comment"> * remember where a PDU came from, so that you can send a reply there...  </span>
00103 <span class="comment"> */</span>
00104 
00105 <span class="keyword">static</span> <span class="keywordtype">int</span>
00106 netsnmp_udp_recv(netsnmp_transport *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
00107                  <span class="keywordtype">void</span> **opaque, <span class="keywordtype">int</span> *olength)
00108 {
00109     <span class="keywordtype">int</span>             rc = -1;
00110     socklen_t       fromlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr);
00111     <span class="keyword">struct </span>sockaddr *from;
00112 
00113     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00114         from = (<span class="keyword">struct </span>sockaddr *) malloc(<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_in));
00115         <span class="keywordflow">if</span> (from == NULL) {
00116             *opaque = NULL;
00117             *olength = 0;
00118             <span class="keywordflow">return</span> -1;
00119         } <span class="keywordflow">else</span> {
00120             memset(from, 0, fromlen);
00121         }
00122 
00123         <span class="keywordflow">while</span> (rc &lt; 0) {
00124             rc = recvfrom(t-&gt;sock, buf, size, 0, from, &amp;fromlen);
00125             <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
00126                 <span class="keywordflow">break</span>;
00127             }
00128         }
00129 
00130         <span class="keywordflow">if</span> (rc &gt;= 0) {
00131             <span class="keywordtype">char</span> *string = netsnmp_udp_fmtaddr(NULL, from, fromlen);
00132             DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp"</span>,
00133                         <span class="stringliteral">"recvfrom fd %d got %d bytes (from %s)\n"</span>,
00134                         t-&gt;sock, rc, string));
00135             free(string);
00136         } <span class="keywordflow">else</span> {
00137             DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp"</span>, <span class=
"stringliteral">"recvfrom fd %d err %d (\"%s\")\n"</span>,
00138                         t-&gt;sock, errno, strerror(errno)));
00139         }
00140         *opaque = (<span class="keywordtype">void</span> *)from;
00141         *olength = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in);
00142     }
00143     <span class="keywordflow">return</span> rc;
00144 }
00145 
00146 
00147 
00148 <span class="keyword">static</span> <span class="keywordtype">int</span>
00149 netsnmp_udp_send(netsnmp_transport *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
00150                  <span class="keywordtype">void</span> **opaque, <span class="keywordtype">int</span> *olength)
00151 {
00152     <span class="keywordtype">int</span> rc = -1;
00153     <span class="keyword">struct </span>sockaddr *to = NULL;
00154 
00155     <span class="keywordflow">if</span> (opaque != NULL &amp;&amp; *opaque != NULL &amp;&amp;
00156         *olength == <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in)) {
00157         to = (<span class="keyword">struct </span>sockaddr *) (*opaque);
00158     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL &amp;&amp;
00159                t-&gt;data_length == <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in)) {
00160         to = (<span class="keyword">struct </span>sockaddr *) (t-&gt;data);
00161     }
00162 
00163     <span class="keywordflow">if</span> (to != NULL &amp;&amp; t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00164         <span class="keywordtype">char</span> *string = netsnmp_udp_fmtaddr(NULL, (<span class=
"keywordtype">void</span> *) to,
00165                                         <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_in));
00166         DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp"</span>, <span class=
"stringliteral">"send %d bytes from %p to %s on fd %d\n"</span>,
00167                     size, buf, string, t-&gt;sock));
00168         free(string);
00169         <span class="keywordflow">while</span> (rc &lt; 0) {
00170             rc = sendto(t-&gt;sock, buf, size, 0, to, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr));
00171             <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
00172                 <span class="keywordflow">break</span>;
00173             }
00174         }
00175     }
00176     <span class="keywordflow">return</span> rc;
00177 }
00178 
00179 
00180 
00181 <span class="keyword">static</span> <span class="keywordtype">int</span>
00182 netsnmp_udp_close(netsnmp_transport *t)
00183 {
00184     <span class="keywordtype">int</span> rc = -1;
00185     <span class="keywordflow">if</span> (t-&gt;sock &gt;= 0) {
00186 <span class="preprocessor">#ifndef HAVE_CLOSESOCKET</span>
00187         rc = close(t-&gt;sock);
00188 <span class="preprocessor">#else</span>
00189         rc = closesocket(t-&gt;sock);
00190 <span class="preprocessor">#endif</span>
00191         t-&gt;sock = -1;
00192     }
00193     <span class="keywordflow">return</span> rc;
00194 }
00195 
00196 <span class="comment">/*</span>
00197 <span class="comment"> * find largest possible buffer between current size and specified size.</span>
00198 <span class="comment"> *</span>
00199 <span class="comment"> * Try to maximize the current buffer of type "optname"</span>
00200 <span class="comment"> * to the maximum allowable size by the OS (as close to</span>
00201 <span class="comment"> * size as possible)</span>
00202 <span class="comment"> */</span>
00203 <span class="keyword">static</span> <span class="keywordtype">int</span>
00204 _sock_buffer_maximize(<span class="keywordtype">int</span> s, <span class="keywordtype">int</span> optname, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *buftype, <span class="keywordtype">int</span> size)
00205 {
00206     <span class="keywordtype">int</span>            curbuf = 0, curbuflen = <span class="keyword">sizeof</span>(int);
00207     <span class="keywordtype">int</span>            lo, mid, hi;
00208 
00209     <span class="comment">/*</span>
00210 <span class="comment">     * First we need to determine our current buffer</span>
00211 <span class="comment">     */</span>
00212     <span class="keywordflow">if</span> ((getsockopt(s, SOL_SOCKET, optname, (<span class=
"keywordtype">void</span> *) &amp;curbuf,
00213                     &amp;curbuflen) == 0) 
00214             &amp;&amp; (curbuflen == <span class="keyword">sizeof</span>(int))) {
00215 
00216         DEBUGMSGTL((<span class="stringliteral">"verbose:socket:buffer:max"</span>, <span class=
"stringliteral">"Current %s is %d\n"</span>,
00217                     buftype, curbuf));
00218 
00219         <span class="comment">/*</span>
00220 <span class="comment">         * Let's not be stupid ... if we were asked for less than what we</span>
00221 <span class="comment">         * already have, then forget about it</span>
00222 <span class="comment">         */</span>
00223         <span class="keywordflow">if</span> (size &lt;= curbuf) {
00224             DEBUGMSGTL((<span class="stringliteral">"verbose:socket:buffer:max"</span>,
00225                         <span class="stringliteral">"Requested %s &lt;= current buffer\n"</span>, buftype));
00226             <span class="keywordflow">return</span> curbuf;
00227         }
00228 
00229         <span class="comment">/*</span>
00230 <span class="comment">         * Do a binary search the optimal buffer within 1k of the point of</span>
00231 <span class="comment">         * failure. This is rather bruteforce, but simple</span>
00232 <span class="comment">         */</span>
00233         hi = size;
00234         lo = curbuf;
00235 
00236         <span class="keywordflow">while</span> (hi - lo &gt; 1024) {
00237             mid = (lo + hi) / 2;
00238             <span class="keywordflow">if</span> (setsockopt(s, SOL_SOCKET, optname, (<span class=
"keywordtype">void</span> *) &amp;mid,
00239                         <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) == 0) {
00240                 lo = mid; <span class="comment">/* Success: search between mid and hi */</span>
00241             } <span class="keywordflow">else</span> {
00242                 hi = mid; <span class="comment">/* Failed: search between lo and mid */</span>
00243             }
00244         }
00245 
00246         <span class="comment">/*</span>
00247 <span class="comment">         * Now print if this optimization helped or not</span>
00248 <span class="comment">         */</span>
00249         <span class="keywordflow">if</span> (getsockopt(s,SOL_SOCKET, optname, (<span class=
"keywordtype">void</span> *) &amp;curbuf,
00250                     &amp;curbuflen) == 0) {
00251             DEBUGMSGTL((<span class="stringliteral">"socket:buffer:max"</span>, 
00252                         <span class="stringliteral">"Maximized %s: %d\n"</span>,buftype, curbuf));
00253         } 
00254     } <span class="keywordflow">else</span> {
00255         <span class="comment">/*</span>
00256 <span class="comment">         * There is really not a lot we can do anymore.</span>
00257 <span class="comment">         * If the OS doesn't give us the current buffer, then what's the </span>
00258 <span class="comment">         * point in trying to make it better</span>
00259 <span class="comment">         */</span>
00260         DEBUGMSGTL((<span class="stringliteral">"socket:buffer:max"</span>, <span class=
"stringliteral">"Get %s failed ... giving up!\n"</span>,
00261                     buftype));
00262         curbuf = -1;
00263     }
00264 
00265     <span class="keywordflow">return</span> curbuf;
00266 }
00267 
00268 
00269 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
00270 _sock_buf_type_get(<span class="keywordtype">int</span> optname, <span class="keywordtype">int</span> local)
00271 {
00272     <span class="keywordflow">if</span> (optname == SO_SNDBUF) {
00273         <span class="keywordflow">if</span> (local)
00274             <span class="keywordflow">return</span> <span class="stringliteral">"server send buffer"</span>;
00275         <span class="keywordflow">else</span>
00276             <span class="keywordflow">return</span> <span class="stringliteral">"client send buffer"</span>;
00277     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (optname == SO_RCVBUF) {
00278         <span class="keywordflow">if</span> (local)
00279             <span class="keywordflow">return</span> <span class="stringliteral">"server receive buffer"</span>;
00280         <span class="keywordflow">else</span>
00281             <span class="keywordflow">return</span> <span class="stringliteral">"client receive buffer"</span>;
00282     }
00283 
00284     <span class="keywordflow">return</span> <span class="stringliteral">"unknown buffer"</span>;
00285 }
00286 
00287 <span class="comment">/*</span>
00288 <span class="comment"> *</span>
00289 <span class="comment"> * Get the requested buffersize, based on</span>
00290 <span class="comment"> * - sockettype : client (local = 0) or server (local = 1) </span>
00291 <span class="comment"> * - buffertype : send (optname = SO_SNDBUF) or recv (SO_RCVBUF)</span>
00292 <span class="comment"> *</span>
00293 <span class="comment"> * In case a compile time buffer was specified, then use that one</span>
00294 <span class="comment"> * if there was no runtime configuration override</span>
00295 <span class="comment"> */</span>
00296 <span class="keyword">static</span> <span class="keywordtype">int</span>
00297 _sock_buffer_size_get(<span class="keywordtype">int</span> optname, <span class=
"keywordtype">int</span> local, <span class="keyword">const</span> <span class="keywordtype">char</span> **buftype)
00298 {
00299     <span class="keywordtype">int</span> size;
00300 
00301     <span class="keywordflow">if</span> (NULL != buftype)
00302         *buftype = _sock_buf_type_get(optname, local);
00303 
00304     <span class="keywordflow">if</span> (optname == SO_SNDBUF) {
00305         <span class="keywordflow">if</span> (local) {
00306             size = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
00307                     NETSNMP_DS_LIB_SERVERSENDBUF);
00308 <span class="preprocessor">#ifdef DEFAULT_SERVER_SEND_BUF</span>
00309             <span class="keywordflow">if</span> (size &lt;= 0)
00310                size = DEFAULT_SERVER_SEND_BUF;
00311 <span class="preprocessor">#endif</span>
00312         } <span class="keywordflow">else</span> {
00313             size = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
00314                     NETSNMP_DS_LIB_CLIENTSENDBUF);
00315 <span class="preprocessor">#ifdef DEFAULT_CLIENT_SEND_BUF</span>
00316             <span class="keywordflow">if</span> (size &lt;= 0)
00317                size = DEFAULT_CLIENT_SEND_BUF;
00318 <span class="preprocessor">#endif</span>
00319         }
00320     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (optname == SO_RCVBUF) {
00321         <span class="keywordflow">if</span> (local) {
00322             size = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
00323                     NETSNMP_DS_LIB_SERVERRECVBUF);
00324 <span class="preprocessor">#ifdef DEFAULT_SERVER_RECV_BUF</span>
00325             <span class="keywordflow">if</span> (size &lt;= 0)
00326                size = DEFAULT_SERVER_RECV_BUF;
00327 <span class="preprocessor">#endif</span>
00328         } <span class="keywordflow">else</span> {
00329             size = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
00330                     NETSNMP_DS_LIB_CLIENTRECVBUF);
00331 <span class="preprocessor">#ifdef DEFAULT_CLIENT_RECV_BUF</span>
00332             <span class="keywordflow">if</span> (size &lt;= 0)
00333                size = DEFAULT_CLIENT_RECV_BUF;
00334 <span class="preprocessor">#endif</span>
00335         }
00336     } <span class="keywordflow">else</span> {
00337         size = 0;
00338     }
00339 
00340     DEBUGMSGTL((<span class="stringliteral">"socket:buffer"</span>, <span class=
"stringliteral">"Requested %s is %d\n"</span>,
00341                 (buftype) ? *buftype : <span class="stringliteral">"unknown buffer"</span>, size));
00342 
00343     <span class="keywordflow">return</span>(size);
00344 }
00345 
00346 <span class="comment">/*</span>
00347 <span class="comment"> * set socket buffer size</span>
00348 <span class="comment"> *</span>
00349 <span class="comment"> * @param ss     : socket</span>
00350 <span class="comment"> * @param optname: SO_SNDBUF or SO_RCVBUF</span>
00351 <span class="comment"> * @param local  : 1 for server, 0 for client</span>
00352 <span class="comment"> * @param reqbuf : requested size, or 0 for default</span>
00353 <span class="comment"> *</span>
00354 <span class="comment"> * @retval    -1 : error</span>
00355 <span class="comment"> * @retval    &gt;0 : new buffer size</span>
00356 <span class="comment"> */</span>
00357 <span class="keywordtype">int</span>
00358 netsnmp_sock_buffer_set(<span class="keywordtype">int</span> s, <span class="keywordtype">int</span> optname, <span class=
"keywordtype">int</span> local, <span class="keywordtype">int</span> size)
00359 {
00360 <span class="preprocessor">#if ! defined(SO_SNDBUF) &amp;&amp; ! defined(SO_RCVBUF)</span>
00361     DEBUGMSGTL((<span class="stringliteral">"socket:buffer"</span>, <span class=
"stringliteral">"Changing socket buffer is not supported\n"</span>));
00362     <span class="keywordflow">return</span> -1;
00363 <span class="preprocessor">#else</span>
00364     <span class="keyword">const</span> <span class="keywordtype">char</span>     *buftype;
00365     <span class="keywordtype">int</span>            curbuf = 0, curbuflen = <span class="keyword">sizeof</span>(int);
00366 
00367 <span class="preprocessor">#   ifndef  SO_SNDBUF</span>
00368     <span class="keywordflow">if</span> (SO_SNDBUF == optname) {
00369         DEBUGMSGTL((<span class="stringliteral">"socket:buffer"</span>,
00370                     <span class="stringliteral">"Changing socket send buffer is not supported\n"</span>));
00371         <span class="keywordflow">return</span> -1;
00372     }
00373 <span class="preprocessor">#   endif                          </span><span class="comment">/*SO_SNDBUF */</span>
00374 <span class="preprocessor">#   ifndef  SO_RCVBUF</span>
00375     <span class="keywordflow">if</span> (SO_RCVBUF == optname) {
00376         DEBUGMSGTL((<span class="stringliteral">"socket:buffer"</span>,
00377                     <span class="stringliteral">"Changing socket receive buffer is not supported\n"</span>));
00378         <span class="keywordflow">return</span> -1;
00379     }
00380 <span class="preprocessor">#   endif                          </span><span class="comment">/*SO_RCVBUF */</span>
00381 
00382     <span class="comment">/*</span>
00383 <span class="comment">     * What is the requested buffer size ?</span>
00384 <span class="comment">     */</span>
00385     <span class="keywordflow">if</span> (0 == size)
00386         size = _sock_buffer_size_get(optname, local, &amp;buftype);
00387     <span class="keywordflow">else</span> {
00388         buftype = _sock_buf_type_get(optname, local);
00389         DEBUGMSGT((<span class="stringliteral">"verbose:socket:buffer"</span>, <span class=
"stringliteral">"Requested %s is %d\n"</span>,
00390                    buftype, size));
00391     }
00392 
00393     <span class="keywordflow">if</span> ((getsockopt(s, SOL_SOCKET, optname, (<span class=
"keywordtype">void</span> *) &amp;curbuf,
00394                     &amp;curbuflen) == 0) 
00395         &amp;&amp; (curbuflen == <span class="keyword">sizeof</span>(int))) {
00396         
00397         DEBUGMSGT((<span class="stringliteral">"verbose:socket:buffer"</span>, <span class=
"stringliteral">"Original %s is %d\n"</span>,
00398                    buftype, curbuf));
00399         <span class="keywordflow">if</span> (curbuf &gt;= size) {
00400             DEBUGMSGT((<span class="stringliteral">"verbose:socket:buffer"</span>,
00401                       <span class="stringliteral">"New %s size is smaller than original!\n"</span>, buftype));
00402         }
00403     }
00404 
00405     <span class="comment">/*</span>
00406 <span class="comment">     * If the buffersize was not specified or it was a negative value</span>
00407 <span class="comment">     * then don't change the OS buffers at all</span>
00408 <span class="comment">     */</span>
00409     <span class="keywordflow">if</span> (size &lt;= 0) {
00410        DEBUGMSGT((<span class="stringliteral">"socket:buffer"</span>,
00411                     <span class="stringliteral">"%s not valid or not specified; using OS default(%d)\n"</span>,
00412                     buftype,curbuf));
00413        <span class="keywordflow">return</span> curbuf;
00414     }
00415 
00416     <span class="comment">/*</span>
00417 <span class="comment">     * Try to set the requested send buffer</span>
00418 <span class="comment">     */</span>
00419     <span class="keywordflow">if</span> (setsockopt(s, SOL_SOCKET, optname, (<span class=
"keywordtype">void</span> *) &amp;size, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) == 0) {
00420         <span class="comment">/*</span>
00421 <span class="comment">         * Because some platforms lie about the actual buffer that has been </span>
00422 <span class="comment">         * set (Linux will always say it worked ...), we print some </span>
00423 <span class="comment">         * diagnostic output for debugging</span>
00424 <span class="comment">         */</span>
00425         DEBUGIF(<span class="stringliteral">"socket:buffer"</span>) {
00426             DEBUGMSGT((<span class="stringliteral">"socket:buffer"</span>, <span class=
"stringliteral">"Set %s to %d\n"</span>,
00427                        buftype, size));
00428             <span class="keywordflow">if</span> ((getsockopt(s, SOL_SOCKET, optname, (<span class=
"keywordtype">void</span> *) &amp;curbuf,
00429                             &amp;curbuflen) == 0) 
00430                     &amp;&amp; (curbuflen == <span class="keyword">sizeof</span>(int))) {
00431 
00432                 DEBUGMSGT((<span class="stringliteral">"verbose:socket:buffer"</span>,
00433                            <span class="stringliteral">"Now %s is %d\n"</span>, buftype, curbuf));
00434             }
00435         }
00436         <span class="comment">/*</span>
00437 <span class="comment">         * If the new buffer is smaller than the size we requested, we will</span>
00438 <span class="comment">         * try to increment the new buffer with 1k increments </span>
00439 <span class="comment">         * (this will sometime allow us to reach a more optimal buffer.)</span>
00440 <span class="comment">         *   For example : On Solaris, if the max OS buffer is 100k and you</span>
00441 <span class="comment">         *   request 110k, you end up with the default 8k :-(</span>
00442 <span class="comment">         */</span>
00443         <span class="keywordflow">if</span> (curbuf &lt; size) {
00444             curbuf = _sock_buffer_maximize(s, optname, buftype, size);
00445             <span class="keywordflow">if</span>(-1 != curbuf)
00446                 size = curbuf;
00447         }
00448 
00449     } <span class="keywordflow">else</span> {
00450         <span class="comment">/*</span>
00451 <span class="comment">         * Obviously changing the buffer failed, most like like because we </span>
00452 <span class="comment">         * requested a buffer greater than the OS limit.</span>
00453 <span class="comment">         * Therefore we need to search for an optimal buffer that is close</span>
00454 <span class="comment">         * enough to the point of failure.</span>
00455 <span class="comment">         * This will allow us to reach a more optimal buffer.</span>
00456 <span class="comment">         *   For example : On Solaris, if the max OS buffer is 100k and you </span>
00457 <span class="comment">         *   request 110k, you end up with the default 8k :-(</span>
00458 <span class="comment">         *   After this quick seach we would get 1k close to 100k (the max)</span>
00459 <span class="comment">         */</span>
00460         DEBUGMSGTL((<span class="stringliteral">"socket:buffer"</span>, <span class=
"stringliteral">"couldn't set %s to %d\n"</span>,
00461                     buftype, size));
00462 
00463         curbuf = _sock_buffer_maximize(s, optname, buftype, size);
00464         <span class="keywordflow">if</span>(-1 != curbuf)
00465             size = curbuf;
00466     }
00467 
00468     <span class="keywordflow">return</span> size;
00469 <span class="preprocessor">#endif</span>
00470 }
00471 
00472 <span class="comment">/*</span>
00473 <span class="comment"> * Open a UDP-based transport for SNMP.  Local is TRUE if addr is the local</span>
00474 <span class="comment"> * address to bind to (i.e. this is a server-type session); otherwise addr is </span>
00475 <span class="comment"> * the remote address to send things to.  </span>
00476 <span class="comment"> */</span>
00477 
00478 netsnmp_transport *
00479 netsnmp_udp_transport(<span class="keyword">struct</span> sockaddr_in *addr, <span class="keywordtype">int</span> local)
00480 {
00481     netsnmp_transport *t = NULL;
00482     <span class="keywordtype">int</span>             rc = 0;
00483     <span class="keywordtype">char</span>           *string = NULL;
00484     <span class="keywordtype">char</span>           *client_socket = NULL;
00485 
00486     <span class="keywordflow">if</span> (addr == NULL || addr-&gt;sin_family != AF_INET) {
00487         <span class="keywordflow">return</span> NULL;
00488     }
00489 
00490     t = (netsnmp_transport *) malloc(<span class="keyword">sizeof</span>(netsnmp_transport));
00491     <span class="keywordflow">if</span> (t == NULL) {
00492         <span class="keywordflow">return</span> NULL;
00493     }
00494 
00495     string = netsnmp_udp_fmtaddr(NULL, (<span class="keywordtype">void</span> *)addr, 
00496                                  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));
00497     DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp"</span>, <span class=
"stringliteral">"open %s %s:%d\n"</span>, local ? <span class="stringliteral">"local"</span> : <span class=
"stringliteral">"remote"</span>,
00498                 string,addr-&gt;sin_port));
00499     free(string);
00500 
00501     memset(t, 0, <span class="keyword">sizeof</span>(netsnmp_transport));
00502 
00503     t-&gt;domain = netsnmpUDPDomain;
00504     t-&gt;domain_length = netsnmpUDPDomain_len;
00505 
00506     t-&gt;sock = socket(PF_INET, SOCK_DGRAM, 0);
00507     <span class="keywordflow">if</span> (t-&gt;sock &lt; 0) {
00508         netsnmp_transport_free(t);
00509         <span class="keywordflow">return</span> NULL;
00510     }
00511 
00512     _netsnmp_udp_sockopt_set(t-&gt;sock, local);
00513 
00514     <span class="keywordflow">if</span> (local) {
00515         <span class="comment">/*</span>
00516 <span class="comment">         * This session is inteneded as a server, so we must bind on to the</span>
00517 <span class="comment">         * given IP address, which may include an interface address, or could</span>
00518 <span class="comment">         * be INADDR_ANY, but certainly includes a port number.</span>
00519 <span class="comment">         */</span>
00520 
00521         t-&gt;local = malloc(6);
00522         <span class="keywordflow">if</span> (t-&gt;local == NULL) {
00523             netsnmp_transport_free(t);
00524             <span class="keywordflow">return</span> NULL;
00525         }
00526         memcpy(t-&gt;local, (u_char *) &amp; (addr-&gt;sin_addr.s_addr), 4);
00527         t-&gt;local[4] = (htons(addr-&gt;sin_port) &amp; 0xff00) &gt;&gt; 8;
00528         t-&gt;local[5] = (htons(addr-&gt;sin_port) &amp; 0x00ff) &gt;&gt; 0;
00529         t-&gt;local_length = 6;
00530 
00531         rc = bind(t-&gt;sock, (<span class="keyword">struct</span> sockaddr *) addr,
00532                   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));
00533         <span class="keywordflow">if</span> (rc != 0) {
00534             netsnmp_udp_close(t);
00535             netsnmp_transport_free(t);
00536             <span class="keywordflow">return</span> NULL;
00537         }
00538         t-&gt;data = NULL;
00539         t-&gt;data_length = 0;
00540     } <span class="keywordflow">else</span> {
00541         <span class="comment">/*</span>
00542 <span class="comment">         * This is a client session.  If we've been given a</span>
00543 <span class="comment">         * client address to send from, then bind to that.</span>
00544 <span class="comment">         * Otherwise the send will use "something sensible".</span>
00545 <span class="comment">         */</span>
00546         client_socket = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,
00547                                               NETSNMP_DS_LIB_CLIENT_ADDR);
00548         <span class="keywordflow">if</span> (client_socket) {
00549             <span class="keyword">struct </span>sockaddr_in client_addr;
00550             netsnmp_sockaddr_in( &amp;client_addr, client_socket, 0);
00551             client_addr.sin_port = 0;
00552             bind(t-&gt;sock, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr,
00553                   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));
00554         }
00555         <span class="comment">/*</span>
00556 <span class="comment">         * Save the (remote) address in the</span>
00557 <span class="comment">         * transport-specific data pointer for later use by netsnmp_udp_send.</span>
00558 <span class="comment">         */</span>
00559 
00560         t-&gt;data = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));
00561         t-&gt;remote = malloc(6);
00562         <span class="keywordflow">if</span> (t-&gt;data == NULL || t-&gt;remote == NULL) {
00563             netsnmp_transport_free(t);
00564             <span class="keywordflow">return</span> NULL;
00565         }
00566         memcpy(t-&gt;remote, (u_char *) &amp; (addr-&gt;sin_addr.s_addr), 4);
00567         t-&gt;remote[4] = (htons(addr-&gt;sin_port) &amp; 0xff00) &gt;&gt; 8;
00568         t-&gt;remote[5] = (htons(addr-&gt;sin_port) &amp; 0x00ff) &gt;&gt; 0;
00569         t-&gt;remote_length = 6;
00570         memcpy(t-&gt;data, addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));
00571         t-&gt;data_length = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in);
00572     }
00573 
00574     <span class="comment">/*</span>
00575 <span class="comment">     * 16-bit length field, 8 byte UDP header, 20 byte IPv4 header  </span>
00576 <span class="comment">     */</span>
00577 
00578     t-&gt;msgMaxSize = 0xffff - 8 - 20;
00579     t-&gt;f_recv     = netsnmp_udp_recv;
00580     t-&gt;f_send     = netsnmp_udp_send;
00581     t-&gt;f_close    = netsnmp_udp_close;
00582     t-&gt;f_accept   = NULL;
00583     t-&gt;f_fmtaddr  = netsnmp_udp_fmtaddr;
00584 
00585     <span class="keywordflow">return</span> t;
00586 }
00587 
00588 
00589 <span class="keywordtype">void</span>
00590 _netsnmp_udp_sockopt_set(<span class="keywordtype">int</span> fd, <span class="keywordtype">int</span> local)
00591 {
00592 <span class="preprocessor">#ifdef  SO_BSDCOMPAT</span>
00593     <span class="comment">/*</span>
00594 <span class="comment">     * Patch for Linux.  Without this, UDP packets that fail get an ICMP</span>
00595 <span class="comment">     * response.  Linux turns the failed ICMP response into an error message</span>
00596 <span class="comment">     * and return value, unlike all other OS's.  </span>
00597 <span class="comment">     */</span>
00598     <span class="keywordflow">if</span> (0 == netsnmp_os_prematch(<span class="stringliteral">"Linux"</span>,<span class=
"stringliteral">"2.4"</span>))
00599     {
00600         <span class="keywordtype">int</span>             one = 1;
00601         DEBUGMSGTL((<span class="stringliteral">"socket:option"</span>, <span class=
"stringliteral">"setting socket option SO_BSDCOMPAT\n"</span>));
00602         setsockopt(fd, SOL_SOCKET, SO_BSDCOMPAT, (<span class="keywordtype">void</span> *) &amp;one,
00603                    <span class="keyword">sizeof</span>(one));
00604     }
00605 <span class="preprocessor">#endif                          </span><span class="comment">/*SO_BSDCOMPAT */</span>
00606     <span class="comment">/*</span>
00607 <span class="comment">     * SO_REUSEADDR will allow multiple apps to open the same port at</span>
00608 <span class="comment">     * the same time. Only the last one to open the socket will get</span>
00609 <span class="comment">     * data. Obviously, for an agent, this is a bad thing. There should</span>
00610 <span class="comment">     * only be one listener.</span>
00611 <span class="comment">     */</span>
00612 <span class="preprocessor">#ifdef ALLOW_PORT_HIJACKING</span>
00613 <span class="preprocessor">#ifdef  SO_REUSEADDR</span>
00614     <span class="comment">/*</span>
00615 <span class="comment">     * Allow the same port to be specified multiple times without failing.</span>
00616 <span class="comment">     *    (useful for a listener)</span>
00617 <span class="comment">     */</span>
00618     {
00619         <span class="keywordtype">int</span>             one = 1;
00620         DEBUGMSGTL((<span class="stringliteral">"socket:option"</span>, <span class=
"stringliteral">"setting socket option SO_REUSEADDR\n"</span>));
00621         setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (<span class="keywordtype">void</span> *) &amp;one,
00622                    <span class="keyword">sizeof</span>(one));
00623     }
00624 <span class="preprocessor">#endif                          </span><span class="comment">/*SO_REUSEADDR */</span>
00625 <span class="preprocessor">#endif</span>
00626 
00627     <span class="comment">/*</span>
00628 <span class="comment">     * Try to set the send and receive buffers to a reasonably large value, so</span>
00629 <span class="comment">     * that we can send and receive big PDUs (defaults to 8192 bytes (!) on</span>
00630 <span class="comment">     * Solaris, for instance).  Don't worry too much about errors -- just</span>
00631 <span class="comment">     * plough on regardless.  </span>
00632 <span class="comment">     */</span>
00633     netsnmp_sock_buffer_set(fd, SO_SNDBUF, local, 0);
00634     netsnmp_sock_buffer_set(fd, SO_RCVBUF, local, 0);
00635 }
00636 
00637 <span class="keywordtype">int</span>
00638 netsnmp_sockaddr_in(<span class="keyword">struct</span> sockaddr_in *addr,
00639                     <span class="keyword">const</span> <span class="keywordtype">char</span> *inpeername, <span class=
"keywordtype">int</span> remote_port)
00640 {
00641     <span class="keywordtype">char</span>           *cp = NULL, *peername = NULL;
00642 
00643     <span class="keywordflow">if</span> (addr == NULL) {
00644         <span class="keywordflow">return</span> 0;
00645     }
00646     memset(addr, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));
00647 
00648     DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in"</span>, <span class=
"stringliteral">"addr %p, peername \"%s\"\n"</span>,
00649                 addr, inpeername ? inpeername : <span class="stringliteral">"[NIL]"</span>));
00650 
00651     addr-&gt;sin_addr.s_addr = htonl(INADDR_ANY);
00652     addr-&gt;sin_family = AF_INET;
00653     <span class="keywordflow">if</span> (remote_port &gt; 0) {
00654         addr-&gt;sin_port = htons((u_short)remote_port);
00655     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
00656                                   NETSNMP_DS_LIB_DEFAULT_PORT) &gt; 0) {
00657         addr-&gt;sin_port = htons((u_short)netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
00658                                                  NETSNMP_DS_LIB_DEFAULT_PORT));
00659     } <span class="keywordflow">else</span> {
00660         addr-&gt;sin_port = htons(SNMP_PORT);
00661     }
00662 
00663     <span class="keywordflow">if</span> (inpeername != NULL) {
00664         <span class="comment">/*</span>
00665 <span class="comment">         * Duplicate the peername because we might want to mank around with</span>
00666 <span class="comment">         * it.  </span>
00667 <span class="comment">         */</span>
00668 
00669         peername = strdup(inpeername);
00670         <span class="keywordflow">if</span> (peername == NULL) {
00671             <span class="keywordflow">return</span> 0;
00672         }
00673 
00674         <span class="comment">/*</span>
00675 <span class="comment">         * Try and extract an appended port number.  </span>
00676 <span class="comment">         */</span>
00677         cp = strchr(peername, <span class="charliteral">':'</span>);
00678         <span class="keywordflow">if</span> (cp != NULL) {
00679             *cp = <span class="charliteral">'\0'</span>;
00680             cp++;
00681             <span class="keywordflow">if</span> (atoi(cp) != 0) {
00682                 DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in"</span>,
00683                             <span class="stringliteral">"port number suffix :%d\n"</span>, atoi(cp)));
00684                 addr-&gt;sin_port = htons((u_short)atoi(cp));
00685             }
00686         }
00687 
00688         <span class="keywordflow">for</span> (cp = peername; *cp &amp;&amp; isdigit((<span class=
"keywordtype">int</span>) *cp); cp++);
00689         <span class="keywordflow">if</span> (!*cp &amp;&amp; atoi(peername) != 0) {
00690             <span class="comment">/*</span>
00691 <span class="comment">             * Okay, it looks like just a port number.  </span>
00692 <span class="comment">             */</span>
00693             DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in"</span>, <span class=
"stringliteral">"totally numeric: %d\n"</span>,
00694                         atoi(peername)));
00695             addr-&gt;sin_port = htons((u_short)atoi(peername));
00696         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (inet_addr(peername) != INADDR_NONE) {
00697             <span class="comment">/*</span>
00698 <span class="comment">             * It looks like an IP address.  </span>
00699 <span class="comment">             */</span>
00700             DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in"</span>, <span class=
"stringliteral">"IP address\n"</span>));
00701             addr-&gt;sin_addr.s_addr = inet_addr(peername);
00702         } <span class="keywordflow">else</span> {
00703             <span class="comment">/*</span>
00704 <span class="comment">             * Well, it must be a hostname then.  </span>
00705 <span class="comment">             */</span>
00706 <span class="preprocessor">#ifdef  HAVE_GETHOSTBYNAME</span>
00707             <span class="keyword">struct </span>hostent *hp = gethostbyname(peername);
00708             <span class="keywordflow">if</span> (hp == NULL) {
00709                 DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in"</span>,
00710                             <span class="stringliteral">"hostname (couldn't resolve)\n"</span>));
00711                 free(peername);
00712                 <span class="keywordflow">return</span> 0;
00713             } <span class="keywordflow">else</span> {
00714                 <span class="keywordflow">if</span> (hp-&gt;h_addrtype != AF_INET) {
00715                     DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in"</span>,
00716                                 <span class="stringliteral">"hostname (not AF_INET!)\n"</span>));
00717                     free(peername);
00718                     <span class="keywordflow">return</span> 0;
00719                 } <span class="keywordflow">else</span> {
00720                     DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in"</span>,
00721                                 <span class="stringliteral">"hostname (resolved okay)\n"</span>));
00722                     memcpy(&amp;(addr-&gt;sin_addr), hp-&gt;h_addr, hp-&gt;h_length);
00723                 }
00724             }
00725 <span class="preprocessor">#else                           </span><span class="comment">/*HAVE_GETHOSTBYNAME */</span>
00726             DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in"</span>,
00727                         <span class="stringliteral">"hostname (no gethostbyname)\n"</span>));
00728             free(peername);
00729             <span class="keywordflow">return</span> 0;
00730 <span class="preprocessor">#endif                          </span><span class="comment">/*HAVE_GETHOSTBYNAME */</span>
00731         }
00732     } <span class="keywordflow">else</span> {
00733         DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in"</span>, <span class=
"stringliteral">"NULL peername"</span>));
00734         <span class="keywordflow">return</span> 0;
00735     }
00736     DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in"</span>, <span class=
"stringliteral">"return { AF_INET, %s:%hu }\n"</span>,
00737                 inet_ntoa(addr-&gt;sin_addr), ntohs(addr-&gt;sin_port)));
00738     free(peername);
00739     <span class="keywordflow">return</span> 1;
00740 }
00741 
00742 
00743 
00744 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
00745 <span class="comment">/*</span>
00746 <span class="comment"> * The following functions provide the "com2sec" configuration token</span>
00747 <span class="comment"> * functionality for compatibility.  </span>
00748 <span class="comment"> */</span>
00749 
00750 <span class="preprocessor">#define EXAMPLE_NETWORK         "NETWORK"</span>
00751 <span class="preprocessor">#define EXAMPLE_COMMUNITY       "COMMUNITY"</span>
00752 
00753 <span class="keyword">typedef</span> <span class="keyword">struct </span>_com2SecEntry {
00754     <span class="keywordtype">char</span>            community[VACMSTRINGLEN];
00755     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   network;
00756     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   mask;
00757     <span class="keywordtype">char</span>            secName[VACMSTRINGLEN];
00758     <span class="keywordtype">char</span>            contextName[VACMSTRINGLEN];
00759     <span class="keyword">struct </span>_com2SecEntry *next;
00760 } com2SecEntry;
00761 
00762 com2SecEntry   *com2SecList = NULL, *com2SecListLast = NULL;
00763 
00764 <span class="keywordtype">void</span>
00765 netsnmp_udp_parse_security(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *param)
00766 {
00767     <span class="keywordtype">char</span>            secName[VACMSTRINGLEN];
00768     <span class="keywordtype">char</span>            contextName[VACMSTRINGLEN];
00769     <span class="keywordtype">char</span>            community[VACMSTRINGLEN];
00770     <span class="keywordtype">char</span>            source[VACMSTRINGLEN];
00771     <span class="keywordtype">char</span>           *cp = NULL;
00772     <span class="keyword">const</span> <span class="keywordtype">char</span>     *strmask = NULL;
00773     com2SecEntry   *e = NULL;
00774     in_addr_t   network = 0, mask = 0;
00775 
00776     <span class="comment">/*</span>
00777 <span class="comment">     * Get security, source address/netmask and community strings.  </span>
00778 <span class="comment">     */</span>
00779 
00780     cp = copy_nword( param, secName, <span class="keyword">sizeof</span>(secName));
00781     <span class="keywordflow">if</span> (strcmp(secName, <span class="stringliteral">"-Cn"</span>) == 0) {
00782         <span class="keywordflow">if</span> (!cp) {
00783             config_perror(<span class="stringliteral">"missing CONTEXT_NAME parameter"</span>);
00784             <span class="keywordflow">return</span>;
00785         }
00786         cp = copy_nword( cp, contextName, <span class="keyword">sizeof</span>(contextName));
00787         cp = copy_nword( cp, secName, <span class="keyword">sizeof</span>(secName));
00788     } <span class="keywordflow">else</span> {
00789         contextName[0] = <span class="charliteral">'\0'</span>;
00790     }
00791     <span class="keywordflow">if</span> (secName[0] == <span class="charliteral">'\0'</span>) {
00792         config_perror(<span class="stringliteral">"missing NAME parameter"</span>);
00793         <span class="keywordflow">return</span>;
00794     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strlen(secName) &gt; (VACMSTRINGLEN - 1)) {
00795         config_perror(<span class="stringliteral">"security name too long"</span>);
00796         <span class="keywordflow">return</span>;
00797     }
00798     cp = copy_nword( cp, source, <span class="keyword">sizeof</span>(source));
00799     <span class="keywordflow">if</span> (source[0] == <span class="charliteral">'\0'</span>) {
00800         config_perror(<span class="stringliteral">"missing SOURCE parameter"</span>);
00801         <span class="keywordflow">return</span>;
00802     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strncmp(source, EXAMPLE_NETWORK, strlen(EXAMPLE_NETWORK)) ==
00803                0) {
00804         config_perror(<span class="stringliteral">"example config NETWORK not properly configured"</span>);
00805         <span class="keywordflow">return</span>;
00806     }
00807     cp = copy_nword( cp, community, <span class="keyword">sizeof</span>(community));
00808     <span class="keywordflow">if</span> (community[0] == <span class="charliteral">'\0'</span>) {
00809         config_perror(<span class="stringliteral">"missing COMMUNITY parameter\n"</span>);
00810         <span class="keywordflow">return</span>;
00811     } <span class="keywordflow">else</span>
00812         <span class="keywordflow">if</span> (strncmp
00813             (community, EXAMPLE_COMMUNITY, strlen(EXAMPLE_COMMUNITY))
00814             == 0) {
00815         config_perror(<span class="stringliteral">"example config COMMUNITY not properly configured"</span>);
00816         <span class="keywordflow">return</span>;
00817     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strlen(community) &gt; (VACMSTRINGLEN - 1)) {
00818         config_perror(<span class="stringliteral">"community name too long"</span>);
00819         <span class="keywordflow">return</span>;
00820     }
00821 
00822     <span class="comment">/*</span>
00823 <span class="comment">     * Process the source address/netmask string.  </span>
00824 <span class="comment">     */</span>
00825 
00826     cp = strchr(source, <span class="charliteral">'/'</span>);
00827     <span class="keywordflow">if</span> (cp != NULL) {
00828         <span class="comment">/*</span>
00829 <span class="comment">         * Mask given.  </span>
00830 <span class="comment">         */</span>
00831         *cp = <span class="charliteral">'\0'</span>;
00832         strmask = cp + 1;
00833     }
00834 
00835     <span class="comment">/*</span>
00836 <span class="comment">     * Deal with the network part first.  </span>
00837 <span class="comment">     */</span>
00838 
00839     <span class="keywordflow">if</span> ((strcmp(source, <span class="stringliteral">"default"</span>) == 0)
00840         || (strcmp(source, <span class="stringliteral">"0.0.0.0"</span>) == 0)) {
00841         network = 0;
00842         strmask = <span class="stringliteral">"0.0.0.0"</span>;
00843     } <span class="keywordflow">else</span> {
00844         <span class="comment">/*</span>
00845 <span class="comment">         * Try interpreting as a dotted quad.  </span>
00846 <span class="comment">         */</span>
00847         network = inet_addr(source);
00848 
00849         <span class="keywordflow">if</span> (network == (in_addr_t) -1) {
00850             <span class="comment">/*</span>
00851 <span class="comment">             * Nope, wasn't a dotted quad.  Must be a hostname.  </span>
00852 <span class="comment">             */</span>
00853 <span class="preprocessor">#ifdef  HAVE_GETHOSTBYNAME</span>
00854             <span class="keyword">struct </span>hostent *hp = gethostbyname(source);
00855             <span class="keywordflow">if</span> (hp == NULL) {
00856                 config_perror(<span class="stringliteral">"bad source address"</span>);
00857                 <span class="keywordflow">return</span>;
00858             } <span class="keywordflow">else</span> {
00859                 <span class="keywordflow">if</span> (hp-&gt;h_addrtype != AF_INET) {
00860                     config_perror(<span class="stringliteral">"no IP address for source hostname"</span>);
00861                     <span class="keywordflow">return</span>;
00862                 }
00863                 network = *((in_addr_t *) hp-&gt;h_addr);
00864             }
00865 <span class="preprocessor">#else                           </span><span class="comment">/*HAVE_GETHOSTBYNAME */</span>
00866             <span class="comment">/*</span>
00867 <span class="comment">             * Oh dear.  </span>
00868 <span class="comment">             */</span>
00869             config_perror(<span class="stringliteral">"cannot resolve source hostname"</span>);
00870             <span class="keywordflow">return</span>;
00871 <span class="preprocessor">#endif                          </span><span class="comment">/*HAVE_GETHOSTBYNAME */</span>
00872         }
00873     }
00874 
00875     <span class="comment">/*</span>
00876 <span class="comment">     * Now work out the mask.  </span>
00877 <span class="comment">     */</span>
00878 
00879     <span class="keywordflow">if</span> (strmask == NULL || *strmask == <span class="charliteral">'\0'</span>) {
00880         <span class="comment">/*</span>
00881 <span class="comment">         * No mask was given.  Use 255.255.255.255.  </span>
00882 <span class="comment">         */</span>
00883         mask = 0xffffffffL;
00884     } <span class="keywordflow">else</span> {
00885         <span class="keywordflow">if</span> (strchr(strmask, <span class="charliteral">'.'</span>)) {
00886             <span class="comment">/*</span>
00887 <span class="comment">             * Try to interpret mask as a dotted quad.  </span>
00888 <span class="comment">             */</span>
00889             mask = inet_addr(strmask);
00890             <span class="keywordflow">if</span> (mask == (in_addr_t) -1 &amp;&amp;
00891                 strncmp(strmask, <span class="stringliteral">"255.255.255.255"</span>, 15) != 0) {
00892                 config_perror(<span class="stringliteral">"bad mask"</span>);
00893                 <span class="keywordflow">return</span>;
00894             }
00895         } <span class="keywordflow">else</span> {
00896             <span class="comment">/*</span>
00897 <span class="comment">             * Try to interpret mask as a "number of 1 bits".  </span>
00898 <span class="comment">             */</span>
00899             <span class="keywordtype">int</span>             maskLen = atoi(strmask), maskBit = 0x80000000L;
00900             <span class="keywordflow">if</span> (maskLen &lt;= 0 || maskLen &gt; 32) {
00901                 config_perror(<span class="stringliteral">"bad mask length"</span>);
00902                 <span class="keywordflow">return</span>;
00903             }
00904             <span class="keywordflow">while</span> (maskLen--) {
00905                 mask |= maskBit;
00906                 maskBit &gt;&gt;= 1;
00907             }
00908             mask = htonl(mask);
00909         }
00910     }
00911 
00912     <span class="comment">/*</span>
00913 <span class="comment">     * Check that the network and mask are consistent.  </span>
00914 <span class="comment">     */</span>
00915 
00916     <span class="keywordflow">if</span> (network &amp; ~mask) {
00917         config_perror(<span class="stringliteral">"source/mask mismatch"</span>);
00918         <span class="keywordflow">return</span>;
00919     }
00920 
00921     e = (com2SecEntry *) malloc(<span class="keyword">sizeof</span>(com2SecEntry));
00922     <span class="keywordflow">if</span> (e == NULL) {
00923         config_perror(<span class="stringliteral">"memory error"</span>);
00924         <span class="keywordflow">return</span>;
00925     }
00926 
00927     <span class="comment">/*</span>
00928 <span class="comment">     * Everything is okay.  Copy the parameters to the structure allocated</span>
00929 <span class="comment">     * above and add it to END of the list.  </span>
00930 <span class="comment">     */</span>
00931 
00932     DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp_parse_security"</span>,
00933                 <span class="stringliteral">"&lt;\"%s\", 0x%08x/0x%08x&gt; =&gt; \"%s\"\n"</span>, community, network,
00934                 mask, secName));
00935 
00936     strcpy(e-&gt;contextName, contextName);
00937     strcpy(e-&gt;secName, secName);
00938     strcpy(e-&gt;community, community);
00939     e-&gt;network = network;
00940     e-&gt;mask = mask;
00941     e-&gt;next = NULL;
00942 
00943     <span class="keywordflow">if</span> (com2SecListLast != NULL) {
00944         com2SecListLast-&gt;next = e;
00945         com2SecListLast = e;
00946     } <span class="keywordflow">else</span> {
00947         com2SecListLast = com2SecList = e;
00948     }
00949 }
00950 
00951 
00952 <span class="keywordtype">void</span>
00953 netsnmp_udp_com2SecList_free(<span class="keywordtype">void</span>)
00954 {
00955     com2SecEntry   *e = com2SecList;
00956     <span class="keywordflow">while</span> (e != NULL) {
00957         com2SecEntry   *tmp = e;
00958         e = e-&gt;next;
00959         free(tmp);
00960     }
00961     com2SecList = com2SecListLast = NULL;
00962 }
00963 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
00964 
00965 <span class="keywordtype">void</span>
00966 netsnmp_udp_agent_config_tokens_register(<span class="keywordtype">void</span>)
00967 {
00968 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
00969     register_app_config_handler(<span class="stringliteral">"com2sec"</span>, netsnmp_udp_parse_security,
00970                                 netsnmp_udp_com2SecList_free,
00971                                 <span class=
"stringliteral">"[-Cn CONTEXT] secName IPv4-network-address[/netmask] community"</span>);
00972 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
00973 }
00974 
00975 
00976 
00977 <span class="comment">/*</span>
00978 <span class="comment"> * Return 0 if there are no com2sec entries, or return 1 if there ARE com2sec </span>
00979 <span class="comment"> * entries.  On return, if a com2sec entry matched the passed parameters,</span>
00980 <span class="comment"> * then *secName points at the appropriate security name, or is NULL if the</span>
00981 <span class="comment"> * parameters did not match any com2sec entry.  </span>
00982 <span class="comment"> */</span>
00983 
00984 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
00985 <span class="keywordtype">int</span>
00986 netsnmp_udp_getSecName(<span class="keywordtype">void</span> *opaque, <span class="keywordtype">int</span> olength,
00987                        <span class="keyword">const</span> <span class="keywordtype">char</span> *community,
00988                        size_t community_len, <span class="keywordtype">char</span> **secName,
00989                        <span class="keywordtype">char</span> **contextName)
00990 {
00991     com2SecEntry   *c;
00992     <span class="keyword">struct </span>sockaddr_in *from = (<span class="keyword">struct </span>sockaddr_in *) opaque;
00993     <span class="keywordtype">char</span>           *ztcommunity = NULL;
00994 
00995     <span class="keywordflow">if</span> (secName != NULL) {
00996         *secName = NULL;  <span class="comment">/* Haven't found anything yet */</span>
00997     }
00998 
00999     <span class="comment">/*</span>
01000 <span class="comment">     * Special case if there are NO entries (as opposed to no MATCHING</span>
01001 <span class="comment">     * entries).  </span>
01002 <span class="comment">     */</span>
01003 
01004     <span class="keywordflow">if</span> (com2SecList == NULL) {
01005         DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp_getSecName"</span>, <span class=
"stringliteral">"no com2sec entries\n"</span>));
01006         <span class="keywordflow">return</span> 0;
01007     }
01008 
01009     <span class="comment">/*</span>
01010 <span class="comment">     * If there is no IPv4 source address, then there can be no valid security</span>
01011 <span class="comment">     * name.  </span>
01012 <span class="comment">     */</span>
01013 
01014     <span class="keywordflow">if</span> (opaque == NULL || olength != <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_in) ||
01015         from-&gt;sin_family != AF_INET) {
01016         DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp_getSecName"</span>,
01017                     <span class="stringliteral">"no IPv4 source address in PDU?\n"</span>));
01018         <span class="keywordflow">return</span> 1;
01019     }
01020 
01021     DEBUGIF(<span class="stringliteral">"netsnmp_udp_getSecName"</span>) {
01022         ztcommunity = (<span class="keywordtype">char</span> *)malloc(community_len + 1);
01023         <span class="keywordflow">if</span> (ztcommunity != NULL) {
01024             memcpy(ztcommunity, community, community_len);
01025             ztcommunity[community_len] = <span class="charliteral">'\0'</span>;
01026         }
01027 
01028         DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp_getSecName"</span>, <span class=
"stringliteral">"resolve &lt;\"%s\", 0x%08x&gt;\n"</span>,
01029                     ztcommunity ? ztcommunity : <span class="stringliteral">"&lt;malloc error&gt;"</span>,
01030                     from-&gt;sin_addr.s_addr));
01031     }
01032 
01033     <span class="keywordflow">for</span> (c = com2SecList; c != NULL; c = c-&gt;next) {
01034         DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp_getSecName"</span>,<span class=
"stringliteral">"compare &lt;\"%s\", 0x%08x/0x%08x&gt;"</span>,
01035                     c-&gt;community, c-&gt;network, c-&gt;mask));
01036         <span class="keywordflow">if</span> ((community_len == strlen(c-&gt;community)) &amp;&amp;
01037             (memcmp(community, c-&gt;community, community_len) == 0) &amp;&amp;
01038             ((from-&gt;sin_addr.s_addr &amp; c-&gt;mask) == c-&gt;network)) {
01039             DEBUGMSG((<span class="stringliteral">"netsnmp_udp_getSecName"</span>, <span class=
"stringliteral">"... SUCCESS\n"</span>));
01040             <span class="keywordflow">if</span> (secName != NULL) {
01041                 *secName = c-&gt;secName;
01042                 *contextName = c-&gt;contextName;
01043             }
01044             <span class="keywordflow">break</span>;
01045         }
01046         DEBUGMSG((<span class="stringliteral">"netsnmp_udp_getSecName"</span>, <span class=
"stringliteral">"... nope\n"</span>));
01047     }
01048     <span class="keywordflow">if</span> (ztcommunity != NULL) {
01049         free(ztcommunity);
01050     }
01051     <span class="keywordflow">return</span> 1;
01052 }
01053 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
01054 
01055 
01056 netsnmp_transport *
01057 netsnmp_udp_create_tstring(<span class="keyword">const</span> <span class="keywordtype">char</span> *string, <span class=
"keywordtype">int</span> local)
01058 {
01059     <span class="keyword">struct </span>sockaddr_in addr;
01060 
01061     <span class="keywordflow">if</span> (netsnmp_sockaddr_in(&amp;addr, string, 0)) {
01062         <span class="keywordflow">return</span> netsnmp_udp_transport(&amp;addr, local);
01063     } <span class="keywordflow">else</span> {
01064         <span class="keywordflow">return</span> NULL;
01065     }
01066 }
01067 
01068 
01069 netsnmp_transport *
01070 netsnmp_udp_create_ostring(<span class="keyword">const</span> u_char * o, size_t o_len, <span class=
"keywordtype">int</span> local)
01071 {
01072     <span class="keyword">struct </span>sockaddr_in addr;
01073 
01074     <span class="keywordflow">if</span> (o_len == 6) {
01075         <span class="keywordtype">unsigned</span> <span class=
"keywordtype">short</span> porttmp = (o[4] &lt;&lt; 8) + o[5];
01076         addr.sin_family = AF_INET;
01077         memcpy((u_char *) &amp; (addr.sin_addr.s_addr), o, 4);
01078         addr.sin_port = htons(porttmp);
01079         <span class="keywordflow">return</span> netsnmp_udp_transport(&amp;addr, local);
01080     }
01081     <span class="keywordflow">return</span> NULL;
01082 }
01083 
01084 
01085 <span class="keywordtype">void</span>
01086 netsnmp_udp_ctor(<span class="keywordtype">void</span>)
01087 {
01088     udpDomain.name = netsnmpUDPDomain;
01089     udpDomain.name_length = netsnmpUDPDomain_len;
01090     udpDomain.prefix = calloc(2, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
01091     udpDomain.prefix[0] = <span class="stringliteral">"udp"</span>;
01092 
01093     udpDomain.f_create_from_tstring = netsnmp_udp_create_tstring;
01094     udpDomain.f_create_from_ostring = netsnmp_udp_create_ostring;
01095 
01096     netsnmp_tdomain_register(&amp;udpDomain);
01097 }
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small><!--#include virtual="/sfbutton.html" --><br />
    Generated on Thu Oct 28 21:47:01 2004 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

