<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>scapi.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
00002 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00003 <span class="comment"> * that may apply:</span>
00004 <span class="comment"> */</span>
00005 <span class="comment">/*</span>
00006 <span class="comment"> * Portions of this file are copyrighted by:</span>
00007 <span class="comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
00008 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00009 <span class="comment"> * distributed with the Net-SNMP package.</span>
00010 <span class="comment"> */</span>
00011 
00012 <span class="comment">/*</span>
00013 <span class="comment"> * scapi.c</span>
00014 <span class="comment"> *</span>
00015 <span class="comment"> */</span>
00016 
00017 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00018 
00019 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00020 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00021 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00022 <span class="preprocessor">#endif</span>
00023 <span class="preprocessor">#ifdef HAVE_STDLIB_H</span>
00024 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00025 <span class="preprocessor">#endif</span>
00026 <span class="preprocessor">#if HAVE_STRING_H</span>
00027 <span class="preprocessor">#include &lt;string.h&gt;</span>
00028 <span class="preprocessor">#else</span>
00029 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00030 <span class="preprocessor">#endif</span>
00031 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00032 <span class="preprocessor"># ifdef WIN32</span>
00033 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00034 <span class="preprocessor"># else</span>
00035 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00036 <span class="preprocessor"># endif</span>
00037 <span class="preprocessor"># include &lt;time.h&gt;</span>
00038 <span class="preprocessor">#else</span>
00039 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00040 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00041 <span class="preprocessor"># else</span>
00042 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00043 <span class="preprocessor"># endif</span>
00044 <span class="preprocessor">#endif</span>
00045 <span class="preprocessor">#ifdef HAVE_NETINET_IN_H</span>
00046 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00047 <span class="preprocessor">#endif</span>
00048 
00049 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00050 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00051 <span class="preprocessor">#endif</span>
00052 
00053 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00054 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00055 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00056 
00057 <span class="preprocessor">#ifdef USE_INTERNAL_MD5</span>
00058 <span class="preprocessor">#include &lt;net-snmp/library/md5.h&gt;</span>
00059 <span class="preprocessor">#endif</span>
00060 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00061 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
00062 <span class="preprocessor">#include &lt;net-snmp/library/snmp_secmod.h&gt;</span>
00063 <span class="preprocessor">#include &lt;net-snmp/library/snmpusm.h&gt;</span>
00064 <span class="preprocessor">#include &lt;net-snmp/library/keytools.h&gt;</span>
00065 <span class="preprocessor">#include &lt;net-snmp/library/scapi.h&gt;</span>
00066 <span class="preprocessor">#include &lt;net-snmp/library/mib.h&gt;</span>
00067 <span class="preprocessor">#include &lt;net-snmp/library/transform_oids.h&gt;</span>
00068 
00069 <span class="preprocessor">#ifdef USE_OPENSSL</span>
00070 <span class="preprocessor">#include &lt;openssl/hmac.h&gt;</span>
00071 <span class="preprocessor">#include &lt;openssl/evp.h&gt;</span>
00072 <span class="preprocessor">#include &lt;openssl/rand.h&gt;</span>
00073 <span class="preprocessor">#include &lt;openssl/des.h&gt;</span>
00074 <span class="preprocessor">#ifdef HAVE_AES</span>
00075 <span class="preprocessor">#include &lt;openssl/aes.h&gt;</span>
00076 <span class="preprocessor">#endif</span>
00077 
00078 <span class="preprocessor">#ifndef DISABLE_DES</span>
00079 <span class="preprocessor">#ifdef STRUCT_DES_KS_STRUCT_HAS_WEAK_KEY</span>
00080 <span class="comment">/* these are older names for newer structures that exist in openssl .9.7 */</span>
00081 <span class="preprocessor">#define DES_key_schedule    des_key_schedule </span>
00082 <span class="preprocessor">#define DES_cblock          des_cblock </span>
00083 <span class="preprocessor">#define DES_key_sched       des_key_sched </span>
00084 <span class="preprocessor">#define DES_ncbc_encrypt    des_ncbc_encrypt</span>
00085 <span class="preprocessor">#define DES_cbc_encrypt    des_cbc_encrypt</span>
00086 <span class="preprocessor">#define OLD_DES</span>
00087 <span class="preprocessor">#endif</span>
00088 <span class="preprocessor">#endif</span>
00089 
00090 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_OPENSSL */</span>
00091 
00092 <span class="preprocessor">#ifdef USE_PKCS</span>
00093 <span class="preprocessor">#include &lt;security/cryptoki.h&gt;</span>
00094 <span class="preprocessor">#endif</span>
00095 
00096 <span class="preprocessor">#ifdef QUITFUN</span>
00097 <span class="preprocessor">#undef QUITFUN</span>
00098 <span class="preprocessor">#define QUITFUN(e, l)                                   \</span>
00099 <span class="preprocessor">        if (e != SNMPERR_SUCCESS) {                     \</span>
00100 <span class="preprocessor">                rval = SNMPERR_SC_GENERAL_FAILURE;      \</span>
00101 <span class="preprocessor">                goto l ;                                \</span>
00102 <span class="preprocessor">        }</span>
00103 <span class="preprocessor">#endif</span>
00104 
00105 
00106 <span class="comment">/*</span>
00107 <span class="comment"> * sc_get_properlength(oid *hashtype, u_int hashtype_len):</span>
00108 <span class="comment"> * </span>
00109 <span class="comment"> * Given a hashing type ("hashtype" and its length hashtype_len), return</span>
00110 <span class="comment"> * the length of the hash result.</span>
00111 <span class="comment"> * </span>
00112 <span class="comment"> * Returns either the length or SNMPERR_GENERR for an unknown hashing type.</span>
00113 <span class="comment"> */</span>
00114 <span class="keywordtype">int</span>
00115 sc_get_properlength(<span class="keyword">const</span> oid * hashtype, u_int hashtype_len)
00116 {
00117     DEBUGTRACE;
00118     <span class="comment">/*</span>
00119 <span class="comment">     * Determine transform type hash length.</span>
00120 <span class="comment">     */</span>
00121 <span class="preprocessor">#ifndef DISABLE_MD5</span>
00122     <span class="keywordflow">if</span> (ISTRANSFORM(hashtype, HMACMD5Auth)) {
00123         <span class="keywordflow">return</span> BYTESIZE(SNMP_TRANS_AUTHLEN_HMACMD5);
00124     } <span class="keywordflow">else</span>
00125 <span class="preprocessor">#endif</span>
00126         <span class="keywordflow">if</span> (ISTRANSFORM(hashtype, HMACSHA1Auth)) {
00127         <span class="keywordflow">return</span> BYTESIZE(SNMP_TRANS_AUTHLEN_HMACSHA1);
00128     }
00129     <span class="keywordflow">return</span> SNMPERR_GENERR;
00130 }
00131 
00132 <span class="keywordtype">int</span>
00133 sc_get_proper_priv_length(<span class="keyword">const</span> oid * privtype, u_int privtype_len)
00134 {
00135     <span class="keywordtype">int</span> properlength = 0;
00136 <span class="preprocessor">#ifndef DISABLE_DES</span>
00137     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, DESPriv)) {
00138         properlength = BYTESIZE(SNMP_TRANS_PRIVLEN_1DES);
00139     }
00140 <span class="preprocessor">#endif</span>
00141 <span class="preprocessor">#ifdef HAVE_AES</span>
00142     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, AESPriv)) {
00143         properlength = BYTESIZE(SNMP_TRANS_PRIVLEN_AES);
00144     }
00145 <span class="preprocessor">#endif</span>
00146     <span class="keywordflow">return</span> properlength;
00147 }
00148 
00149 
00150 <span class="comment">/*******************************************************************-o-******</span>
00151 <span class="comment"> * sc_init</span>
00152 <span class="comment"> *</span>
00153 <span class="comment"> * Returns:</span>
00154 <span class="comment"> *      SNMPERR_SUCCESS                 Success.</span>
00155 <span class="comment"> */</span>
00156 <span class="keywordtype">int</span>
00157 sc_init(<span class="keywordtype">void</span>)
00158 {
00159     <span class="keywordtype">int</span>             rval = SNMPERR_SUCCESS;
00160 
00161 <span class="preprocessor">#ifndef USE_OPENSSL</span>
00162 <span class="preprocessor">#ifdef USE_INTERNAL_MD5</span>
00163     <span class="keyword">struct </span>timeval  tv;
00164 
00165     DEBUGTRACE;
00166 
00167     gettimeofday(&amp;tv, (<span class="keyword">struct</span> timezone *) 0);
00168 
00169     srandom(tv.tv_sec ^ tv.tv_usec);
00170 <span class="preprocessor">#elif USE_PKCS</span>
00171     DEBUGTRACE;
00172     rval = pkcs_init();
00173 <span class="preprocessor">#else</span>
00174     rval = SNMPERR_SC_NOT_CONFIGURED;
00175 <span class="preprocessor">#endif                           </span><span class="comment">/* USE_INTERNAL_MD5 */</span>
00176     <span class="comment">/*</span>
00177 <span class="comment">     * XXX ogud: The only reason to do anything here with openssl is to </span>
00178 <span class="comment">     * * XXX ogud: seed random number generator </span>
00179 <span class="comment">     */</span>
00180 <span class="preprocessor">#endif                          </span><span class="comment">/* ifndef USE_OPENSSL */</span>
00181     <span class="keywordflow">return</span> rval;
00182 }                               <span class="comment">/* end sc_init() */</span>
00183 
00184 <span class="comment">/*******************************************************************-o-******</span>
00185 <span class="comment"> * sc_random</span>
00186 <span class="comment"> *</span>
00187 <span class="comment"> * Parameters:</span>
00188 <span class="comment"> *      *buf            Pre-allocated buffer.</span>
00189 <span class="comment"> *      *buflen         Size of buffer.</span>
00190 <span class="comment"> *      </span>
00191 <span class="comment"> * Returns:</span>
00192 <span class="comment"> *      SNMPERR_SUCCESS                 Success.</span>
00193 <span class="comment"> */</span>
00194 <span class="keywordtype">int</span>
00195 sc_random(u_char * buf, size_t * buflen)
00196 #<span class="keywordflow">if</span> defined(USE_INTERNAL_MD5) || defined(USE_OPENSSL) || defined(USE_PKCS)
00197 {
00198     <span class="keywordtype">int</span>             rval = SNMPERR_SUCCESS;
00199 <span class="preprocessor">#ifdef USE_INTERNAL_MD5</span>
00200     <span class="keywordtype">int</span>             i;
00201     <span class="keywordtype">int</span>             rndval;
00202     u_char         *ucp = buf;
00203 <span class="preprocessor">#endif</span>
00204 
00205     DEBUGTRACE;
00206 
00207 <span class="preprocessor">#ifdef USE_OPENSSL</span>
00208     RAND_bytes(buf, *buflen);   <span class="comment">/* will never fail */</span>
00209 <span class="preprocessor">#elif USE_PKCS                  </span><span class="comment">/* USE_PKCS */</span>
00210     pkcs_random(buf, *buflen);
00211 <span class="preprocessor">#else                           </span><span class="comment">/* USE_INTERNAL_MD5 */</span>
00212     <span class="comment">/*</span>
00213 <span class="comment">     * fill the buffer with random integers.  Note that random()</span>
00214 <span class="comment">     * is defined in config.h and may not be truly the random()</span>
00215 <span class="comment">     * system call if something better existed </span>
00216 <span class="comment">     */</span>
00217     rval = *buflen - *buflen % <span class="keyword">sizeof</span>(rndval);
00218     <span class="keywordflow">for</span> (i = 0; i &lt; rval; i += <span class="keyword">sizeof</span>(rndval)) {
00219         rndval = random();
00220         memcpy(ucp, &amp;rndval, <span class="keyword">sizeof</span>(rndval));
00221         ucp += <span class="keyword">sizeof</span>(rndval);
00222     }
00223 
00224     rndval = random();
00225     memcpy(ucp, &amp;rndval, *buflen % <span class="keyword">sizeof</span>(rndval));
00226 
00227     rval = SNMPERR_SUCCESS;
00228 <span class="preprocessor">#endif                          </span><span class="comment">/* USE_OPENSSL */</span>
00229     <span class="keywordflow">return</span> rval;
00230 
00231 }                               <span class="comment">/* end sc_random() */</span>
00232 
00233 <span class="preprocessor">#else</span>
00234 _SCAPI_NOT_CONFIGURED
00235 <span class="preprocessor">#endif                          </span><span class="comment">/*  */</span>
00236 <span class="comment">/*******************************************************************-o-******</span>
00237 <span class="comment"> * sc_generate_keyed_hash</span>
00238 <span class="comment"> *</span>
00239 <span class="comment"> * Parameters:</span>
00240 <span class="comment"> *       authtype       Type of authentication transform.</span>
00241 <span class="comment"> *       authtypelen</span>
00242 <span class="comment"> *      *key            Pointer to key (Kul) to use in keyed hash.</span>
00243 <span class="comment"> *       keylen         Length of key in bytes.</span>
00244 <span class="comment"> *      *message        Pointer to the message to hash.</span>
00245 <span class="comment"> *       msglen         Length of the message.</span>
00246 <span class="comment"> *      *MAC            Will be returned with allocated bytes containg hash.</span>
00247 <span class="comment"> *      *maclen         Length of the hash buffer in bytes; also indicates</span>
00248 <span class="comment"> *                              whether the MAC should be truncated.</span>
00249 <span class="comment"> *      </span>
00250 <span class="comment"> * Returns:</span>
00251 <span class="comment"> *      SNMPERR_SUCCESS                 Success.</span>
00252 <span class="comment"> *      SNMPERR_GENERR                  All errs</span>
00253 <span class="comment"> *</span>
00254 <span class="comment"> *</span>
00255 <span class="comment"> * A hash of the first msglen bytes of message using a keyed hash defined</span>
00256 <span class="comment"> * by authtype is created and stored in MAC.  MAC is ASSUMED to be a buffer</span>
00257 <span class="comment"> * of at least maclen bytes.  If the length of the hash is greater than</span>
00258 <span class="comment"> * maclen, it is truncated to fit the buffer.  If the length of the hash is</span>
00259 <span class="comment"> * less than maclen, maclen set to the number of hash bytes generated.</span>
00260 <span class="comment"> *</span>
00261 <span class="comment"> * ASSUMED that the number of hash bits is a multiple of 8.</span>
00262 <span class="comment"> */</span>
00263 <span class="keywordtype">int</span>
00264 sc_generate_keyed_hash(<span class="keyword">const</span> oid * authtype, size_t authtypelen,
00265                        u_char * key, u_int keylen,
00266                        u_char * message, u_int msglen,
00267                        u_char * MAC, size_t * maclen)
00268 #<span class="keywordflow">if</span>  defined(USE_INTERNAL_MD5) || defined(USE_OPENSSL) || defined(USE_PKCS)
00269 {
00270     <span class="keywordtype">int</span>             rval = SNMPERR_SUCCESS;
00271     <span class="keywordtype">int</span>             properlength;
00272 
00273     u_char          buf[SNMP_MAXBUF_SMALL];
00274 <span class="preprocessor">#if  defined(USE_OPENSSL) || defined(USE_PKCS)</span>
00275     size_t             buf_len = <span class="keyword">sizeof</span>(buf);
00276 <span class="preprocessor">#endif</span>
00277 
00278     DEBUGTRACE;
00279 
00280 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
00281     {
00282         <span class="keywordtype">int</span>             i;
00283         DEBUGMSG((<span class="stringliteral">"sc_generate_keyed_hash"</span>,
00284                   <span class="stringliteral">"sc_generate_keyed_hash(): key=0x"</span>));
00285         <span class="keywordflow">for</span> (i = 0; i &lt; keylen; i++)
00286             DEBUGMSG((<span class="stringliteral">"sc_generate_keyed_hash"</span>, <span class=
"stringliteral">"%02x"</span>, key[i] &amp; 0xff));
00287         DEBUGMSG((<span class="stringliteral">"sc_generate_keyed_hash"</span>, <span class=
"stringliteral">" (%d)\n"</span>, keylen));
00288     }
00289 <span class="preprocessor">#endif                          </span><span class="comment">/* SNMP_TESTING_CODE */</span>
00290 
00291     <span class="comment">/*</span>
00292 <span class="comment">     * Sanity check.</span>
00293 <span class="comment">     */</span>
00294     <span class="keywordflow">if</span> (!authtype || !key || !message || !MAC || !maclen
00295         || (keylen &lt;= 0) || (msglen &lt;= 0) || (*maclen &lt;= 0)
00296         || (authtypelen != USM_LENGTH_OID_TRANSFORM)) {
00297         QUITFUN(SNMPERR_GENERR, sc_generate_keyed_hash_quit);
00298     }
00299 
00300     properlength = sc_get_properlength(authtype, authtypelen);
00301     <span class="keywordflow">if</span> (properlength == SNMPERR_GENERR)
00302         <span class="keywordflow">return</span> properlength;
00303 
00304     <span class="keywordflow">if</span> (((int) keylen &lt; properlength)) {
00305         QUITFUN(SNMPERR_GENERR, sc_generate_keyed_hash_quit);
00306     }
00307 <span class="preprocessor">#ifdef USE_OPENSSL</span>
00308     <span class="comment">/*</span>
00309 <span class="comment">     * Determine transform type.</span>
00310 <span class="comment">     */</span>
00311 <span class="preprocessor">#ifndef DISABLE_MD5</span>
00312     <span class="keywordflow">if</span> (ISTRANSFORM(authtype, HMACMD5Auth))
00313         HMAC(EVP_md5(), key, keylen, message, msglen, buf, &amp;buf_len);
00314     <span class="keywordflow">else</span>
00315 <span class="preprocessor">#endif</span>
00316         <span class="keywordflow">if</span> (ISTRANSFORM(authtype, HMACSHA1Auth))
00317         HMAC(EVP_sha1(), key, keylen, message, msglen, buf, &amp;buf_len);
00318     <span class="keywordflow">else</span> {
00319         QUITFUN(SNMPERR_GENERR, sc_generate_keyed_hash_quit);
00320     }
00321     <span class="keywordflow">if</span> ((int)buf_len != properlength) {
00322         QUITFUN(rval, sc_generate_keyed_hash_quit);
00323     }
00324     <span class="keywordflow">if</span> ((int)*maclen &gt; buf_len)
00325         *maclen = buf_len;
00326     memcpy(MAC, buf, *maclen);
00327 
00328 <span class="preprocessor">#elif USE_PKCS                    </span><span class="comment">/* USE_PKCS */</span>
00329 
00330 <span class="preprocessor">#ifndef DISABLE_MD5</span>
00331     <span class="keywordflow">if</span> (ISTRANSFORM(authtype, HMACMD5Auth)) {
00332         <span class="keywordflow">if</span> (pkcs_sign(CKM_MD5_HMAC,key, keylen, message,
00333                         msglen, buf, &amp;buf_len) != SNMPERR_SUCCESS) {
00334             QUITFUN(SNMPERR_GENERR, sc_generate_keyed_hash_quit);
00335         }
00336     } <span class="keywordflow">else</span>
00337 <span class="preprocessor">#endif</span>
00338         <span class="keywordflow">if</span> (ISTRANSFORM(authtype, HMACSHA1Auth)) {
00339         <span class="keywordflow">if</span> (pkcs_sign(CKM_SHA_1_HMAC,key, keylen, message,
00340                         msglen, buf, &amp;buf_len) != SNMPERR_SUCCESS) {
00341             QUITFUN(SNMPERR_GENERR, sc_generate_keyed_hash_quit);
00342         }
00343     } <span class="keywordflow">else</span> {
00344         QUITFUN(SNMPERR_GENERR, sc_generate_keyed_hash_quit);
00345     }
00346 
00347     <span class="keywordflow">if</span> (buf_len != properlength) {
00348         QUITFUN(rval, sc_generate_keyed_hash_quit);
00349     }
00350     <span class="keywordflow">if</span> (*maclen &gt; buf_len)
00351         *maclen = buf_len;
00352     memcpy(MAC, buf, *maclen);
00353 
00354 <span class="preprocessor">#else                            </span><span class="comment">/* USE_INTERNAL_MD5 */</span>
00355     <span class="keywordflow">if</span> ((int) *maclen &gt; properlength)
00356         *maclen = properlength;
00357     <span class="keywordflow">if</span> (MDsign(message, msglen, MAC, *maclen, key, keylen)) {
00358         rval = SNMPERR_GENERR;
00359         <span class="keywordflow">goto</span> sc_generate_keyed_hash_quit;
00360     }
00361 <span class="preprocessor">#endif                          </span><span class="comment">/* USE_OPENSSL */</span>
00362 
00363 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
00364     {
00365         <span class="keywordtype">char</span>           *s;
00366         <span class="keywordtype">int</span>             len = <a class="code" href=
"group__util.html#ga6">binary_to_hex</a>(MAC, *maclen, &amp;s);
00367 
00368         DEBUGMSGTL((<span class="stringliteral">"scapi"</span>, <span class=
"stringliteral">"Full v3 message hash: %s\n"</span>, s));
00369         <a class="code" href="group__util.html#ga40">SNMP_ZERO</a>(s, len);
00370         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(s);
00371     }
00372 <span class="preprocessor">#endif                          </span><span class="comment">/* SNMP_TESTING_CODE */</span>
00373 
00374   sc_generate_keyed_hash_quit:
00375     <a class="code" href="group__util.html#ga40">SNMP_ZERO</a>(buf, SNMP_MAXBUF_SMALL);
00376     <span class="keywordflow">return</span> rval;
00377 }                               <span class="comment">/* end sc_generate_keyed_hash() */</span>
00378 
00379 <span class="preprocessor">#else</span>
00380                 _SCAPI_NOT_CONFIGURED
00381 <span class="preprocessor">#endif                          </span><span class="comment">/* */</span>
00382 <span class="comment">/*</span>
00383 <span class="comment"> * sc_hash(): a generic wrapper around whatever hashing package we are using.</span>
00384 <span class="comment"> * </span>
00385 <span class="comment"> * IN:</span>
00386 <span class="comment"> * hashtype    - oid pointer to a hash type</span>
00387 <span class="comment"> * hashtypelen - length of oid pointer</span>
00388 <span class="comment"> * buf         - u_char buffer to be hashed</span>
00389 <span class="comment"> * buf_len     - integer length of buf data</span>
00390 <span class="comment"> * MAC_len     - length of the passed MAC buffer size.</span>
00391 <span class="comment"> * </span>
00392 <span class="comment"> * OUT:    </span>
00393 <span class="comment"> * MAC         - pre-malloced space to store hash output.</span>
00394 <span class="comment"> * MAC_len     - length of MAC output to the MAC buffer.</span>
00395 <span class="comment"> * </span>
00396 <span class="comment"> * Returns:</span>
00397 <span class="comment"> * SNMPERR_SUCCESS              Success.</span>
00398 <span class="comment"> * SNMP_SC_GENERAL_FAILURE      Any error.</span>
00399 <span class="comment"> */</span>
00400 <span class="keywordtype">int</span>
00401 sc_hash(<span class="keyword">const</span> oid * hashtype, size_t hashtypelen, u_char * buf,
00402         size_t buf_len, u_char * MAC, size_t * MAC_len)
00403 #<span class="keywordflow">if</span> defined(USE_INTERNAL_MD5) || defined(USE_OPENSSL) || defined(USE_PKCS)
00404 {
00405 <span class="preprocessor">#if defined(USE_OPENSSL) || defined(USE_PKCS)</span>
00406     <span class="keywordtype">int</span>             rval = SNMPERR_SUCCESS;
00407 <span class="preprocessor">#endif</span>
00408 
00409 <span class="preprocessor">#ifdef USE_OPENSSL</span>
00410     <span class="keyword">const</span> EVP_MD         *hashfn;
00411     EVP_MD_CTX     ctx, *cptr;
00412     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   tmp_len;
00413 <span class="preprocessor">#endif</span>
00414 
00415     DEBUGTRACE;
00416 
00417     <span class="keywordflow">if</span> (hashtype == NULL || hashtypelen &lt; 0 || buf == NULL ||
00418         buf_len &lt; 0 || MAC == NULL || MAC_len == NULL ||
00419         (int) (*MAC_len) &lt; sc_get_properlength(hashtype, hashtypelen))
00420         <span class="keywordflow">return</span> (SNMPERR_GENERR);
00421 
00422 <span class="preprocessor">#ifdef USE_OPENSSL</span>
00423     <span class="comment">/*</span>
00424 <span class="comment">     * Determine transform type.</span>
00425 <span class="comment">     */</span>
00426 <span class="preprocessor">#ifndef DISABLE_MD5</span>
00427     <span class="keywordflow">if</span> (ISTRANSFORM(hashtype, HMACMD5Auth)) {
00428         hashfn = (<span class="keyword">const</span> EVP_MD *) EVP_md5();
00429     } <span class="keywordflow">else</span>
00430 <span class="preprocessor">#endif</span>
00431         <span class="keywordflow">if</span> (ISTRANSFORM(hashtype, HMACSHA1Auth)) {
00432         hashfn = (<span class="keyword">const</span> EVP_MD *) EVP_sha1();
00433     } <span class="keywordflow">else</span> {
00434         <span class="keywordflow">return</span> (SNMPERR_GENERR);
00435     }
00436 
00438     memset(&amp;ctx, 0, <span class="keyword">sizeof</span>(ctx));
00439     cptr = &amp;ctx;
00440 <span class="preprocessor">#if defined(OLD_DES)</span>
00441     EVP_DigestInit(cptr, hashfn);
00442 <span class="preprocessor">#else </span><span class="comment">/* !OLD_DES */</span>
00443     <span class="comment">/* this is needed if the runtime library is different than the compiled</span>
00444 <span class="comment">       library since the openssl versions are very different. */</span>
00445     <span class="keywordflow">if</span> (SSLeay() &lt; 0x907000) {
00446         <span class="comment">/* the old version of the struct was bigger and thus more</span>
00447 <span class="comment">           memory is needed. should be 152, but we use 256 for safety. */</span>
00448         cptr = malloc(256);
00449         EVP_DigestInit(cptr, hashfn);
00450     } <span class="keywordflow">else</span> {
00451         EVP_MD_CTX_init(cptr);
00452         EVP_DigestInit(cptr, hashfn);
00453     }
00454 <span class="preprocessor">#endif</span>
00455 
00457     EVP_DigestUpdate(cptr, buf, buf_len);
00458 
00460 <span class="preprocessor">#if defined(OLD_DES)</span>
00461     EVP_DigestFinal(cptr, MAC, &amp;tmp_len);
00462     *MAC_len = tmp_len;
00463 <span class="preprocessor">#else </span><span class="comment">/* !OLD_DES */</span>
00464     <span class="keywordflow">if</span> (SSLeay() &lt; 0x907000) {
00465         EVP_DigestFinal(cptr, MAC, &amp;tmp_len);
00466         *MAC_len = tmp_len;
00467         free(cptr);
00468     } <span class="keywordflow">else</span> {
00469         EVP_DigestFinal_ex(cptr, MAC, &amp;tmp_len);
00470         *MAC_len = tmp_len;
00471         EVP_MD_CTX_cleanup(cptr);
00472     }
00473 <span class="preprocessor">#endif                          </span><span class="comment">/* OLD_DES */</span>
00474     <span class="keywordflow">return</span> (rval);
00475 <span class="preprocessor">#elif USE_PKCS                  </span><span class="comment">/* USE_PKCS */</span>
00476 
00477 <span class="preprocessor">#ifndef DISABLE_MD5</span>
00478     <span class="keywordflow">if</span> (ISTRANSFORM(hashtype, HMACMD5Auth)) {
00479         rval = pkcs_digest(CKM_MD5, buf, buf_len, MAC, MAC_len);
00480     } <span class="keywordflow">else</span>
00481 <span class="preprocessor">#endif</span>
00482         <span class="keywordflow">if</span> (ISTRANSFORM(hashtype, HMACSHA1Auth)) {
00483         rval = pkcs_digest(CKM_SHA_1, buf, buf_len, MAC, MAC_len);
00484     } <span class="keywordflow">else</span> {
00485         <span class="keywordflow">return</span> (SNMPERR_GENERR);
00486     }
00487 
00488      <span class="keywordflow">return</span> (rval);
00489 
00490 <span class="preprocessor">#else                           </span><span class="comment">/* USE_INTERNAL_MD5 */</span>
00491 
00492     <span class="keywordflow">if</span> (MDchecksum(buf, buf_len, MAC, *MAC_len)) {
00493         <span class="keywordflow">return</span> SNMPERR_GENERR;
00494     }
00495     <span class="keywordflow">if</span> (*MAC_len &gt; 16)
00496         *MAC_len = 16;
00497     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
00498 
00499 <span class="preprocessor">#endif                          </span><span class="comment">/* USE_OPENSSL */</span>
00500 }
00501 <span class="preprocessor">#else                           </span><span class=
"comment">/* !defined(USE_OPENSSL) &amp;&amp; !defined(USE_INTERNAL_MD5) */</span>
00502 _SCAPI_NOT_CONFIGURED
00503 <span class="preprocessor">#endif                          </span><span class=
"comment">/* !defined(USE_OPENSSL) &amp;&amp; !defined(USE_INTERNAL_MD5) */</span>
00504 <span class="comment">/*******************************************************************-o-******</span>
00505 <span class="comment"> * sc_check_keyed_hash</span>
00506 <span class="comment"> *</span>
00507 <span class="comment"> * Parameters:</span>
00508 <span class="comment"> *       authtype       Transform type of authentication hash.</span>
00509 <span class="comment"> *      *key            Key bits in a string of bytes.</span>
00510 <span class="comment"> *       keylen         Length of key in bytes.</span>
00511 <span class="comment"> *      *message        Message for which to check the hash.</span>
00512 <span class="comment"> *       msglen         Length of message.</span>
00513 <span class="comment"> *      *MAC            Given hash.</span>
00514 <span class="comment"> *       maclen         Length of given hash; indicates truncation if it is</span>
00515 <span class="comment"> *                              shorter than the normal size of output for</span>
00516 <span class="comment"> *                              given hash transform.</span>
00517 <span class="comment"> * Returns:</span>
00518 <span class="comment"> *      SNMPERR_SUCCESS         Success.</span>
00519 <span class="comment"> *      SNMP_SC_GENERAL_FAILURE Any error</span>
00520 <span class="comment"> *</span>
00521 <span class="comment"> *</span>
00522 <span class="comment"> * Check the hash given in MAC against the hash of message.  If the length</span>
00523 <span class="comment"> * of MAC is less than the length of the transform hash output, only maclen</span>
00524 <span class="comment"> * bytes are compared.  The length of MAC cannot be greater than the</span>
00525 <span class="comment"> * length of the hash transform output.</span>
00526 <span class="comment"> */</span>
00527 <span class="keywordtype">int</span>
00528 sc_check_keyed_hash(<span class="keyword">const</span> oid * authtype, size_t authtypelen,
00529                     u_char * key, u_int keylen,
00530                     u_char * message, u_int msglen,
00531                     u_char * MAC, u_int maclen)
00532 #<span class="keywordflow">if</span> defined(USE_INTERNAL_MD5) || defined(USE_OPENSSL) || defined(USE_PKCS)
00533 {
00534     <span class="keywordtype">int</span>             rval = SNMPERR_SUCCESS;
00535     size_t          buf_len = SNMP_MAXBUF_SMALL;
00536 
00537     u_char          buf[SNMP_MAXBUF_SMALL];
00538 
00539     DEBUGTRACE;
00540 
00541 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
00542     {
00543         <span class="keywordtype">int</span>             i;
00544         DEBUGMSG((<span class="stringliteral">"scapi"</span>, <span class=
"stringliteral">"sc_check_keyed_hash():    key=0x"</span>));
00545         <span class="keywordflow">for</span> (i = 0; i &lt; keylen; i++)
00546             DEBUGMSG((<span class="stringliteral">"scapi"</span>, <span class=
"stringliteral">"%02x"</span>, key[i] &amp; 0xff));
00547         DEBUGMSG((<span class="stringliteral">"scapi"</span>, <span class="stringliteral">" (%d)\n"</span>, keylen));
00548     }
00549 <span class="preprocessor">#endif                          </span><span class="comment">/* SNMP_TESTING_CODE */</span>
00550 
00551     <span class="comment">/*</span>
00552 <span class="comment">     * Sanity check.</span>
00553 <span class="comment">     */</span>
00554     <span class="keywordflow">if</span> (!authtype || !key || !message || !MAC
00555         || (keylen &lt;= 0) || (msglen &lt;= 0) || (maclen &lt;= 0)
00556         || (authtypelen != USM_LENGTH_OID_TRANSFORM)) {
00557         QUITFUN(SNMPERR_GENERR, sc_check_keyed_hash_quit);
00558     }
00559 
00560 
00561     <span class="comment">/*</span>
00562 <span class="comment">     * Generate a full hash of the message, then compare</span>
00563 <span class="comment">     * the result with the given MAC which may shorter than</span>
00564 <span class="comment">     * the full hash length.</span>
00565 <span class="comment">     */</span>
00566     rval = sc_generate_keyed_hash(authtype, authtypelen,
00567                                   key, keylen,
00568                                   message, msglen, buf, &amp;buf_len);
00569     QUITFUN(rval, sc_check_keyed_hash_quit);
00570 
00571     <span class="keywordflow">if</span> (maclen &gt; msglen) {
00572         QUITFUN(SNMPERR_GENERR, sc_check_keyed_hash_quit);
00573 
00574     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (memcmp(buf, MAC, maclen) != 0) {
00575         QUITFUN(SNMPERR_GENERR, sc_check_keyed_hash_quit);
00576     }
00577 
00578 
00579   sc_check_keyed_hash_quit:
00580     <a class="code" href="group__util.html#ga40">SNMP_ZERO</a>(buf, SNMP_MAXBUF_SMALL);
00581 
00582     <span class="keywordflow">return</span> rval;
00583 
00584 }                               <span class="comment">/* end sc_check_keyed_hash() */</span>
00585 
00586 <span class="preprocessor">#else</span>
00587 _SCAPI_NOT_CONFIGURED
00588 <span class="preprocessor">#endif                          </span><span class="comment">/* USE_INTERNAL_MD5 */</span>
00589 <span class="comment">/*******************************************************************-o-******</span>
00590 <span class="comment"> * sc_encrypt</span>
00591 <span class="comment"> *</span>
00592 <span class="comment"> * Parameters:</span>
00593 <span class="comment"> *       privtype       Type of privacy cryptographic transform.</span>
00594 <span class="comment"> *      *key            Key bits for crypting.</span>
00595 <span class="comment"> *       keylen         Length of key (buffer) in bytes.</span>
00596 <span class="comment"> *      *iv             IV bits for crypting.</span>
00597 <span class="comment"> *       ivlen          Length of iv (buffer) in bytes.</span>
00598 <span class="comment"> *      *plaintext      Plaintext to crypt.</span>
00599 <span class="comment"> *       ptlen          Length of plaintext.</span>
00600 <span class="comment"> *      *ciphertext     Ciphertext to crypt.</span>
00601 <span class="comment"> *      *ctlen          Length of ciphertext.</span>
00602 <span class="comment"> *      </span>
00603 <span class="comment"> * Returns:</span>
00604 <span class="comment"> *      SNMPERR_SUCCESS                 Success.</span>
00605 <span class="comment"> *      SNMPERR_SC_NOT_CONFIGURED       Encryption is not supported.</span>
00606 <span class="comment"> *      SNMPERR_SC_GENERAL_FAILURE      Any other error</span>
00607 <span class="comment"> *</span>
00608 <span class="comment"> *</span>
00609 <span class="comment"> * Encrypt plaintext into ciphertext using key and iv.</span>
00610 <span class="comment"> *</span>
00611 <span class="comment"> * ctlen contains actual number of crypted bytes in ciphertext upon</span>
00612 <span class="comment"> * successful return.</span>
00613 <span class="comment"> */</span>
00614 <span class="keywordtype">int</span>
00615 sc_encrypt(<span class="keyword">const</span> oid * privtype, size_t privtypelen,
00616            u_char * key, u_int keylen,
00617            u_char * iv, u_int ivlen,
00618            u_char * plaintext, u_int ptlen,
00619            u_char * ciphertext, size_t * ctlen)
00620 #<span class="keywordflow">if</span> defined(USE_OPENSSL)
00621 {
00622     <span class="keywordtype">int</span>             rval = SNMPERR_SUCCESS;
00623     u_int           properlength = 0, properlength_iv = 0;
00624     u_char          pad_block[128];      <span class="comment">/* bigger than anything I need */</span>
00625     u_char          my_iv[128];  <span class="comment">/* ditto */</span>
00626     <span class="keywordtype">int</span>             pad, plast, pad_size = 0;
00627     <span class="keywordtype">int</span>             have_trans;
00628 <span class="preprocessor">#ifndef DISABLE_DES</span>
00629 <span class="preprocessor">#ifdef OLD_DES</span>
00630     DES_key_schedule key_sch;
00631 <span class="preprocessor">#else</span>
00632     DES_key_schedule key_sched_store;
00633     DES_key_schedule *key_sch = &amp;key_sched_store;
00634 <span class="preprocessor">#endif</span>
00635     DES_cblock       key_struct;
00636 <span class="preprocessor">#endif</span>
00637 <span class="preprocessor">#ifdef HAVE_AES</span>
00638     AES_KEY aes_key;
00639     <span class="keywordtype">int</span> new_ivlen = 0;
00640 <span class="preprocessor">#endif</span>
00641 
00642     DEBUGTRACE;
00643 
00644     <span class="comment">/*</span>
00645 <span class="comment">     * Sanity check.</span>
00646 <span class="comment">     */</span>
00647 <span class="preprocessor">#if     !defined(SCAPI_AUTHPRIV)</span>
00648     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Encryption support not enabled.\n"</span>);
00649     <span class="keywordflow">return</span> SNMPERR_SC_NOT_CONFIGURED;
00650 <span class="preprocessor">#endif</span>
00651 
00652     <span class="keywordflow">if</span> (!privtype || !key || !iv || !plaintext || !ciphertext || !ctlen
00653         || (keylen &lt;= 0) || (ivlen &lt;= 0) || (ptlen &lt;= 0) || (*ctlen &lt;= 0)
00654         || (privtypelen != USM_LENGTH_OID_TRANSFORM)) {
00655         QUITFUN(SNMPERR_GENERR, sc_encrypt_quit);
00656     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ptlen &gt; *ctlen) {
00657         QUITFUN(SNMPERR_GENERR, sc_encrypt_quit);
00658     }
00659 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
00660     {
00661         size_t          buf_len = 128, out_len = 0;
00662         u_char         *buf = (u_char *) malloc(buf_len);
00663 
00664         <span class="keywordflow">if</span> (buf != NULL) {
00665             <span class="keywordflow">if</span> (sprint_realloc_hexstring(&amp;buf, &amp;buf_len, &amp;out_len, 1,
00666                                          iv, ivlen)) {
00667                 DEBUGMSGTL((<span class="stringliteral">"scapi"</span>, <span class=
"stringliteral">"encrypt: IV: %s/"</span>, buf));
00668             } <span class="keywordflow">else</span> {
00669                 DEBUGMSGTL((<span class="stringliteral">"scapi"</span>, <span class=
"stringliteral">"encrypt: IV: %s [TRUNCATED]/"</span>, buf));
00670             }
00671             out_len = 0;
00672             <span class="keywordflow">if</span> (sprint_realloc_hexstring(&amp;buf, &amp;buf_len, &amp;out_len, 1,
00673                                          key, keylen)) {
00674                 DEBUGMSG((<span class="stringliteral">"scapi"</span>, <span class="stringliteral">"%s\n"</span>, buf));
00675             } <span class="keywordflow">else</span> {
00676                 DEBUGMSG((<span class="stringliteral">"scapi"</span>, <span class=
"stringliteral">"%s [TRUNCATED]\n"</span>, buf));
00677             }
00678             out_len = 0;
00679             <span class="keywordflow">if</span> (sprint_realloc_hexstring(&amp;buf, &amp;buf_len, &amp;out_len, 1,
00680                                          plaintext, 16)) {
00681                 DEBUGMSGTL((<span class="stringliteral">"scapi"</span>, <span class=
"stringliteral">"encrypt: string: %s\n"</span>, buf));
00682             } <span class="keywordflow">else</span> {
00683                 DEBUGMSGTL((<span class="stringliteral">"scapi"</span>, <span class=
"stringliteral">"encrypt: string: %s [TRUNCATED]\n"</span>,
00684                             buf));
00685             }
00686             free(buf);
00687         } <span class="keywordflow">else</span> {
00688             DEBUGMSGTL((<span class="stringliteral">"scapi"</span>,
00689                         <span class="stringliteral">"encrypt: malloc fail for debug output\n"</span>));
00690         }
00691     }
00692 <span class="preprocessor">#endif                          </span><span class="comment">/* SNMP_TESTING_CODE */</span>
00693 
00694 
00695     <span class="comment">/*</span>
00696 <span class="comment">     * Determine privacy transform.</span>
00697 <span class="comment">     */</span>
00698     have_trans = 0;
00699 <span class="preprocessor">#ifndef DISABLE_DES</span>
00700     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, DESPriv)) {
00701         properlength = BYTESIZE(SNMP_TRANS_PRIVLEN_1DES);
00702         properlength_iv = BYTESIZE(SNMP_TRANS_PRIVLEN_1DES_IV);
00703         pad_size = properlength;
00704         have_trans = 1;
00705     }
00706 <span class="preprocessor">#endif</span>
00707 <span class="preprocessor">#ifdef HAVE_AES</span>
00708     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, AESPriv)) {
00709         properlength = BYTESIZE(SNMP_TRANS_PRIVLEN_AES);
00710         properlength_iv = BYTESIZE(SNMP_TRANS_PRIVLEN_AES_IV);
00711         have_trans = 1;
00712     }
00713 <span class="preprocessor">#endif</span>
00714     <span class="keywordflow">if</span> (!have_trans) {
00715         QUITFUN(SNMPERR_GENERR, sc_encrypt_quit);
00716     }
00717 
00718     <span class="keywordflow">if</span> ((keylen &lt; properlength) || (ivlen &lt; properlength_iv)) {
00719         QUITFUN(SNMPERR_GENERR, sc_encrypt_quit);
00720     }
00721 
00722     memset(my_iv, 0, <span class="keyword">sizeof</span>(my_iv));
00723 
00724 <span class="preprocessor">#ifndef DISABLE_DES</span>
00725     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, DESPriv)) {
00726 
00727         <span class="comment">/*</span>
00728 <span class="comment">         * now calculate the padding needed </span>
00729 <span class="comment">         */</span>
00730         pad = pad_size - (ptlen % pad_size);
00731         plast = (int) ptlen - (pad_size - pad);
00732         <span class="keywordflow">if</span> (pad == pad_size)
00733             pad = 0;
00734         <span class="keywordflow">if</span> (ptlen + pad &gt; *ctlen) {
00735             QUITFUN(SNMPERR_GENERR, sc_encrypt_quit);    <span class="comment">/* not enough space */</span>
00736         }
00737         <span class="keywordflow">if</span> (pad &gt; 0) {              <span class=
"comment">/* copy data into pad block if needed */</span>
00738             memcpy(pad_block, plaintext + plast, pad_size - pad);
00739             memset(&amp;pad_block[pad_size - pad], pad, pad);   <span class="comment">/* filling in padblock */</span>
00740         }
00741 
00742         memcpy(key_struct, key, <span class="keyword">sizeof</span>(key_struct));
00743         (void) DES_key_sched(&amp;key_struct, key_sch);
00744 
00745         memcpy(my_iv, iv, ivlen);
00746         <span class="comment">/*</span>
00747 <span class="comment">         * encrypt the data </span>
00748 <span class="comment">         */</span>
00749         DES_ncbc_encrypt(plaintext, ciphertext, plast, key_sch,
00750                          (DES_cblock *) my_iv, DES_ENCRYPT);
00751         <span class="keywordflow">if</span> (pad &gt; 0) {
00752             <span class="comment">/*</span>
00753 <span class="comment">             * then encrypt the pad block </span>
00754 <span class="comment">             */</span>
00755             DES_ncbc_encrypt(pad_block, ciphertext + plast, pad_size,
00756                              key_sch, (DES_cblock *) my_iv, DES_ENCRYPT);
00757             *ctlen = plast + pad_size;
00758         } <span class="keywordflow">else</span> {
00759             *ctlen = plast;
00760         }
00761     }
00762 <span class="preprocessor">#endif</span>
00763 <span class="preprocessor">#ifdef HAVE_AES</span>
00764     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, AESPriv)) {
00765         (void) AES_set_encrypt_key(key, properlength*8, &amp;aes_key);
00766 
00767         memcpy(my_iv, iv, ivlen);
00768         <span class="comment">/*</span>
00769 <span class="comment">         * encrypt the data </span>
00770 <span class="comment">         */</span>
00771         AES_cfb128_encrypt(plaintext, ciphertext, ptlen,
00772                            &amp;aes_key, my_iv, &amp;new_ivlen, AES_ENCRYPT);
00773         *ctlen = ptlen;
00774     }
00775 <span class="preprocessor">#endif</span>
00776   sc_encrypt_quit:
00777     <span class="comment">/*</span>
00778 <span class="comment">     * clear memory just in case </span>
00779 <span class="comment">     */</span>
00780     memset(my_iv, 0, <span class="keyword">sizeof</span>(my_iv));
00781     memset(pad_block, 0, <span class="keyword">sizeof</span>(pad_block));
00782 <span class="preprocessor">#ifndef DISABLE_DES</span>
00783     memset(key_struct, 0, <span class="keyword">sizeof</span>(key_struct));
00784 <span class="preprocessor">#ifdef OLD_DES</span>
00785     memset(&amp;key_sch, 0, <span class="keyword">sizeof</span>(key_sch));
00786 <span class="preprocessor">#else</span>
00787     memset(&amp;key_sched_store, 0, <span class="keyword">sizeof</span>(key_sched_store));
00788 <span class="preprocessor">#endif</span>
00789 <span class="preprocessor">#endif</span>
00790 <span class="preprocessor">#ifdef HAVE_AES</span>
00791     memset(&amp;aes_key,0,<span class="keyword">sizeof</span>(aes_key));
00792 <span class="preprocessor">#endif</span>
00793     <span class="keywordflow">return</span> rval;
00794 
00795 }                               <span class="comment">/* end sc_encrypt() */</span>
00796 <span class="preprocessor">#elif defined(USE_PKCS)</span>
00797 {
00798     <span class="keywordtype">int</span>             rval = SNMPERR_SUCCESS;
00799     u_int           properlength, properlength_iv;
00800     u_char          pkcs_des_key[8];
00801 
00802     DEBUGTRACE;
00803 
00804     <span class="comment">/*</span>
00805 <span class="comment">     * Sanity check.</span>
00806 <span class="comment">     */</span>
00807 <span class="preprocessor">#if     !defined(SCAPI_AUTHPRIV)</span>
00808     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Encryption support not enabled.\n"</span>);
00809     <span class="keywordflow">return</span> SNMPERR_SC_NOT_CONFIGURED;
00810 <span class="preprocessor">#endif</span>
00811 
00812     <span class="keywordflow">if</span> (!privtype || !key || !iv || !plaintext || !ciphertext || !ctlen
00813         || (keylen &lt;= 0) || (ivlen &lt;= 0) || (ptlen &lt;= 0) || (*ctlen &lt;= 0)
00814         || (privtypelen != USM_LENGTH_OID_TRANSFORM)) {
00815         QUITFUN(SNMPERR_GENERR, sc_encrypt_quit);
00816     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ptlen &gt; *ctlen) {
00817         QUITFUN(SNMPERR_GENERR, sc_encrypt_quit);
00818     }
00819 
00820     <span class="comment">/*</span>
00821 <span class="comment">     * Determine privacy transform.</span>
00822 <span class="comment">     */</span>
00823     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, DESPriv)) {
00824         properlength = BYTESIZE(SNMP_TRANS_PRIVLEN_1DES);
00825         properlength_iv = BYTESIZE(SNMP_TRANS_PRIVLEN_1DES_IV);
00826     } <span class="keywordflow">else</span> {
00827         QUITFUN(SNMPERR_GENERR, sc_encrypt_quit);
00828     }
00829 
00830     <span class="keywordflow">if</span> ((keylen &lt; properlength) || (ivlen &lt; properlength_iv)) {
00831         QUITFUN(SNMPERR_GENERR, sc_encrypt_quit);
00832     }
00833 
00834     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, DESPriv)) {
00835         memset(pkcs_des_key, 0, <span class="keyword">sizeof</span>(pkcs_des_key));
00836         memcpy(pkcs_des_key, key, <span class="keyword">sizeof</span>(pkcs_des_key));
00837         rval = pkcs_encrpyt(CKM_DES_CBC, pkcs_des_key,
00838                 <span class="keyword">sizeof</span>(pkcs_des_key), iv, ivlen, plaintext, ptlen,
00839                 ciphertext, ctlen);
00840     }
00841 
00842   sc_encrypt_quit:
00843     <span class="keywordflow">return</span> rval;
00844 }
00845 <span class="preprocessor">#else</span>
00846 {
00847 <span class="preprocessor">#       if USE_INTERNAL_MD5</span>
00848     {
00849         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Encryption support not enabled.\n"</span>);
00850         DEBUGMSGTL((<span class="stringliteral">"scapi"</span>, <span class=
"stringliteral">"Encrypt function not defined.\n"</span>));
00851         <span class="keywordflow">return</span> SNMPERR_SC_GENERAL_FAILURE;
00852     }
00853 
00854 <span class="preprocessor">#       else</span>
00855     _SCAPI_NOT_CONFIGURED
00856 <span class="preprocessor">#       endif                   </span><span class="comment">/* USE_INTERNAL_MD5 */</span>
00857 }
00858 <span class="preprocessor">#endif                          </span><span class="comment">/* */</span>
00859 
00860 
00861 
00862 <span class="comment">/*******************************************************************-o-******</span>
00863 <span class="comment"> * sc_decrypt</span>
00864 <span class="comment"> *</span>
00865 <span class="comment"> * Parameters:</span>
00866 <span class="comment"> *       privtype</span>
00867 <span class="comment"> *      *key</span>
00868 <span class="comment"> *       keylen</span>
00869 <span class="comment"> *      *iv</span>
00870 <span class="comment"> *       ivlen</span>
00871 <span class="comment"> *      *ciphertext</span>
00872 <span class="comment"> *       ctlen</span>
00873 <span class="comment"> *      *plaintext</span>
00874 <span class="comment"> *      *ptlen</span>
00875 <span class="comment"> *      </span>
00876 <span class="comment"> * Returns:</span>
00877 <span class="comment"> *      SNMPERR_SUCCESS                 Success.</span>
00878 <span class="comment"> *      SNMPERR_SC_NOT_CONFIGURED       Encryption is not supported.</span>
00879 <span class="comment"> *      SNMPERR_SC_GENERAL_FAILURE      Any other error</span>
00880 <span class="comment"> *</span>
00881 <span class="comment"> *</span>
00882 <span class="comment"> * Decrypt ciphertext into plaintext using key and iv.</span>
00883 <span class="comment"> *</span>
00884 <span class="comment"> * ptlen contains actual number of plaintext bytes in plaintext upon</span>
00885 <span class="comment"> * successful return.</span>
00886 <span class="comment"> */</span>
00887 <span class="keywordtype">int</span>
00888 sc_decrypt(<span class="keyword">const</span> oid * privtype, size_t privtypelen,
00889            u_char * key, u_int keylen,
00890            u_char * iv, u_int ivlen,
00891            u_char * ciphertext, u_int ctlen,
00892            u_char * plaintext, size_t * ptlen)
00893 #ifdef USE_OPENSSL
00894 {
00895 
00896     <span class="keywordtype">int</span>             rval = SNMPERR_SUCCESS;
00897     u_char          my_iv[128];
00898 <span class="preprocessor">#ifndef DISABLE_DES</span>
00899 <span class="preprocessor">#ifdef OLD_DES</span>
00900     DES_key_schedule key_sch;
00901 <span class="preprocessor">#else</span>
00902     DES_key_schedule key_sched_store;
00903     DES_key_schedule *key_sch = &amp;key_sched_store;
00904 <span class="preprocessor">#endif</span>
00905     DES_cblock      key_struct;
00906 <span class="preprocessor">#endif</span>
00907     u_int           properlength = 0, properlength_iv = 0;
00908     <span class="keywordtype">int</span>             have_transform;
00909 <span class="preprocessor">#ifdef HAVE_AES</span>
00910     <span class="keywordtype">int</span> new_ivlen = 0;
00911     AES_KEY aes_key;
00912 <span class="preprocessor">#endif</span>
00913 
00914     DEBUGTRACE;
00915 
00916     <span class="keywordflow">if</span> (!privtype || !key || !iv || !plaintext || !ciphertext || !ptlen
00917         || (ctlen &lt;= 0) || (*ptlen &lt;= 0) || (*ptlen &lt; ctlen)
00918         || (privtypelen != USM_LENGTH_OID_TRANSFORM)) {
00919         QUITFUN(SNMPERR_GENERR, sc_decrypt_quit);
00920     }
00921 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
00922     {
00923         size_t          buf_len = 128, out_len = 0;
00924         u_char         *buf = (u_char *) malloc(buf_len);
00925 
00926         <span class="keywordflow">if</span> (buf != NULL) {
00927             <span class="keywordflow">if</span> (sprint_realloc_hexstring(&amp;buf, &amp;buf_len, &amp;out_len, 1,
00928                                          iv, ivlen)) {
00929                 DEBUGMSGTL((<span class="stringliteral">"scapi"</span>, <span class=
"stringliteral">"decrypt: IV: %s/"</span>, buf));
00930             } <span class="keywordflow">else</span> {
00931                 DEBUGMSGTL((<span class="stringliteral">"scapi"</span>, <span class=
"stringliteral">"decrypt: IV: %s [TRUNCATED]/"</span>, buf));
00932             }
00933             out_len = 0;
00934             <span class="keywordflow">if</span> (sprint_realloc_hexstring(&amp;buf, &amp;buf_len, &amp;out_len, 1,
00935                                          key, keylen)) {
00936                 DEBUGMSG((<span class="stringliteral">"scapi"</span>, <span class="stringliteral">"%s\n"</span>, buf));
00937             } <span class="keywordflow">else</span> {
00938                 DEBUGMSG((<span class="stringliteral">"scapi"</span>, <span class="stringliteral">"%s\n"</span>, buf));
00939             }
00940             free(buf);
00941         } <span class="keywordflow">else</span> {
00942             DEBUGMSGTL((<span class="stringliteral">"scapi"</span>,
00943                         <span class="stringliteral">"decrypt: malloc fail for debug output\n"</span>));
00944         }
00945     }
00946 <span class="preprocessor">#endif                          </span><span class="comment">/* SNMP_TESTING_CODE */</span>
00947 
00948     <span class="comment">/*</span>
00949 <span class="comment">     * Determine privacy transform.</span>
00950 <span class="comment">     */</span>
00951     have_transform = 0;
00952 <span class="preprocessor">#ifndef DISABLE_DES</span>
00953     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, DESPriv)) {
00954         properlength = BYTESIZE(SNMP_TRANS_PRIVLEN_1DES);
00955         properlength_iv = BYTESIZE(SNMP_TRANS_PRIVLEN_1DES_IV);
00956         have_transform = 1;
00957     }
00958 <span class="preprocessor">#endif</span>
00959 <span class="preprocessor">#ifdef HAVE_AES</span>
00960     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, AESPriv)) {
00961         properlength = BYTESIZE(SNMP_TRANS_PRIVLEN_AES);
00962         properlength_iv = BYTESIZE(SNMP_TRANS_PRIVLEN_AES_IV);
00963         have_transform = 1;
00964     }
00965 <span class="preprocessor">#endif</span>
00966     <span class="keywordflow">if</span> (!have_transform) {
00967         QUITFUN(SNMPERR_GENERR, sc_decrypt_quit);
00968     }
00969 
00970     <span class="keywordflow">if</span> ((keylen &lt; properlength) || (ivlen &lt; properlength_iv)) {
00971         QUITFUN(SNMPERR_GENERR, sc_decrypt_quit);
00972     }
00973 
00974     memset(my_iv, 0, <span class="keyword">sizeof</span>(my_iv));
00975 <span class="preprocessor">#ifndef DISABLE_DES</span>
00976     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, DESPriv)) {
00977         memcpy(key_struct, key, <span class="keyword">sizeof</span>(key_struct));
00978         (void) DES_key_sched(&amp;key_struct, key_sch);
00979 
00980         memcpy(my_iv, iv, ivlen);
00981         DES_cbc_encrypt(ciphertext, plaintext, ctlen, key_sch,
00982                         (DES_cblock *) my_iv, DES_DECRYPT);
00983         *ptlen = ctlen;
00984     }
00985 <span class="preprocessor">#endif</span>
00986 <span class="preprocessor">#ifdef HAVE_AES</span>
00987     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, AESPriv)) {
00988         (void) AES_set_encrypt_key(key, properlength*8, &amp;aes_key);
00989 
00990         memcpy(my_iv, iv, ivlen);
00991         <span class="comment">/*</span>
00992 <span class="comment">         * encrypt the data </span>
00993 <span class="comment">         */</span>
00994         AES_cfb128_encrypt(ciphertext, plaintext, ctlen,
00995                            &amp;aes_key, my_iv, &amp;new_ivlen, AES_DECRYPT);
00996         *ptlen = ctlen;
00997     }
00998 <span class="preprocessor">#endif</span>
00999 
01000     <span class="comment">/*</span>
01001 <span class="comment">     * exit cond </span>
01002 <span class="comment">     */</span>
01003   sc_decrypt_quit:
01004 <span class="preprocessor">#ifndef DISABLE_DES</span>
01005 <span class="preprocessor">#ifdef OLD_DES</span>
01006     memset(&amp;key_sch, 0, <span class="keyword">sizeof</span>(key_sch));
01007 <span class="preprocessor">#else</span>
01008     memset(&amp;key_sched_store, 0, <span class="keyword">sizeof</span>(key_sched_store));
01009 <span class="preprocessor">#endif</span>
01010     memset(key_struct, 0, <span class="keyword">sizeof</span>(key_struct));
01011 <span class="preprocessor">#endif</span>
01012     memset(my_iv, 0, <span class="keyword">sizeof</span>(my_iv));
01013     <span class="keywordflow">return</span> rval;
01014 }                               <span class="comment">/* USE OPEN_SSL */</span>
01015 <span class="preprocessor">#elif USE_PKCS                  </span><span class="comment">/* USE PKCS */</span>
01016 {
01017     <span class="keywordtype">int</span>             rval = SNMPERR_SUCCESS;
01018     u_int           properlength, properlength_iv;
01019     u_char          pkcs_des_key[8];
01020 
01021     DEBUGTRACE;
01022 
01023     <span class="keywordflow">if</span> (!privtype || !key || !iv || !plaintext || !ciphertext || !ptlen
01024         || (ctlen &lt;= 0) || (*ptlen &lt;= 0) || (*ptlen &lt; ctlen)
01025         || (privtypelen != USM_LENGTH_OID_TRANSFORM)) {
01026         QUITFUN(SNMPERR_GENERR, sc_decrypt_quit);
01027     }
01028 
01029     <span class="comment">/*</span>
01030 <span class="comment">     * Determine privacy transform.</span>
01031 <span class="comment">     */</span>
01032     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, DESPriv)) {
01033         properlength = BYTESIZE(SNMP_TRANS_PRIVLEN_1DES);
01034         properlength_iv = BYTESIZE(SNMP_TRANS_PRIVLEN_1DES_IV);
01035     } <span class="keywordflow">else</span> {
01036         QUITFUN(SNMPERR_GENERR, sc_decrypt_quit);
01037     }
01038 
01039     <span class="keywordflow">if</span> ((keylen &lt; properlength) || (ivlen &lt; properlength_iv)) {
01040         QUITFUN(SNMPERR_GENERR, sc_decrypt_quit);
01041     }
01042 
01043     <span class="keywordflow">if</span> (ISTRANSFORM(privtype, DESPriv)) {
01044         memset(pkcs_des_key, 0, <span class="keyword">sizeof</span>(pkcs_des_key));
01045         memcpy(pkcs_des_key, key, <span class="keyword">sizeof</span>(pkcs_des_key));
01046         rval = pkcs_decrpyt(CKM_DES_CBC, pkcs_des_key, 
01047                 <span class="keyword">sizeof</span>(pkcs_des_key), iv, ivlen, ciphertext,
01048                 ctlen, plaintext, ptlen);
01049         *ptlen = ctlen;
01050     }
01051 
01052   sc_decrypt_quit:
01053     <span class="keywordflow">return</span> rval;
01054 }                               <span class="comment">/* USE PKCS */</span>
01055 <span class="preprocessor">#else</span>
01056 {
01057 <span class="preprocessor">#if     !defined(SCAPI_AUTHPRIV)</span>
01058     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Encryption support not enabled.\n"</span>);
01059     <span class="keywordflow">return</span> SNMPERR_SC_NOT_CONFIGURED;
01060 <span class="preprocessor">#else</span>
01061 <span class="preprocessor">#       if USE_INTERNAL_MD5</span>
01062     {
01063         DEBUGMSGTL((<span class="stringliteral">"scapi"</span>, <span class=
"stringliteral">"Decryption function not defined.\n"</span>));
01064         <span class="keywordflow">return</span> SNMPERR_SC_GENERAL_FAILURE;
01065     }
01066 
01067 <span class="preprocessor">#       else</span>
01068     _SCAPI_NOT_CONFIGURED
01069 <span class="preprocessor">#       endif                   </span><span class="comment">/* USE_INTERNAL_MD5 */</span>
01070 <span class="preprocessor">#endif                          </span><span class="comment">/*  */</span>
01071 }
01072 <span class="preprocessor">#endif                          </span><span class="comment">/* USE_OPENSSL */</span>
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small>Generated on Fri Dec 30 13:47:47 2005 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

