<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>snmpIPXDomain.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00002 
00003 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00004 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00005 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00006 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00007 
00008 <span class="preprocessor">#if HAVE_STRING_H</span>
00009 <span class="preprocessor">#include &lt;string.h&gt;</span>
00010 <span class="preprocessor">#else</span>
00011 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00012 <span class="preprocessor">#endif</span>
00013 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00014 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00015 <span class="preprocessor">#endif</span>
00016 <span class="preprocessor">#if HAVE_UNISTD_H</span>
00017 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00018 <span class="preprocessor">#endif</span>
00019 <span class="preprocessor">#if HAVE_SYS_SOCKET_H</span>
00020 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00021 <span class="preprocessor">#endif</span>
00022 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00023 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00024 <span class="preprocessor">#endif</span>
00025 
00026 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00027 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00028 <span class="preprocessor">#endif</span>
00029 
00030 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00031 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00032 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00033 
00034 <span class="preprocessor">#include &lt;net-snmp/library/snmp_transport.h&gt;</span>
00035 <span class="preprocessor">#include &lt;net-snmp/library/snmpIPXDomain.h&gt;</span>
00036 
00037 <span class="preprocessor">#define SNMP_IPX_DEFAULT_PORT   36879   </span><span class=
"comment">/*  Specified in RFC 1420.  */</span>
00038 <span class="keyword">static</span> netsnmp_tdomain ipxDomain;
00039 
00040 <span class="comment">/*</span>
00041 <span class="comment"> * Return a string representing the address in data, or else the "far end"</span>
00042 <span class="comment"> * address if data is NULL.  </span>
00043 <span class="comment"> */</span>
00044 
00045 <span class="keyword">static</span> <span class="keywordtype">char</span> *
00046 netsnmp_ipx_fmtaddr(netsnmp_transport *t, <span class="keywordtype">void</span> *data, <span class=
"keywordtype">int</span> len)
00047 {
00048     <span class="keyword">struct </span>sockaddr_ipx *to = NULL;
00049 
00050     <span class="keywordflow">if</span> (data != NULL &amp;&amp; len == <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_ipx)) {
00051         to = (<span class="keyword">struct </span>sockaddr_ipx *) data;
00052     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL) {
00053         to = (<span class="keyword">struct </span>sockaddr_ipx *) t-&gt;data;
00054     }
00055     <span class="keywordflow">if</span> (to == NULL) {
00056         <span class="keywordflow">return</span> strdup(<span class="stringliteral">"IPX: unknown"</span>);
00057     } <span class="keywordflow">else</span> {
00058         <span class="keywordtype">char</span> tmp[64];
00059         sprintf(tmp, <span class="stringliteral">"IPX: %08X:%02X%02X%02X%02X%02X%02X/%hu"</span>,
00060                 ntohl(to-&gt;sipx_network), to-&gt;sipx_node[0],
00061                 to-&gt;sipx_node[1], to-&gt;sipx_node[2], to-&gt;sipx_node[3],
00062                 to-&gt;sipx_node[4], to-&gt;sipx_node[5], ntohs(to-&gt;sipx_port));
00063         <span class="keywordflow">return</span> strdup(tmp);
00064     }
00065 }
00066 
00067 
00068 
00069 <span class="comment">/*</span>
00070 <span class="comment"> * You can write something into opaque that will subsequently get passed back </span>
00071 <span class="comment"> * to your send function if you like.  For instance, you might want to</span>
00072 <span class="comment"> * remember where a PDU came from, so that you can send a reply there...  </span>
00073 <span class="comment"> */</span>
00074 
00075 <span class="keyword">static</span> <span class="keywordtype">int</span>
00076 netsnmp_ipx_recv(netsnmp_transport *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
00077                  <span class="keywordtype">void</span> **opaque, <span class="keywordtype">int</span> *olength)
00078 {
00079     <span class="keywordtype">int</span> rc = -1, fromlen = <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr);
00080     <span class="keyword">struct </span>sockaddr *from;
00081 
00082     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00083         from = (<span class="keyword">struct </span>sockaddr *)malloc(<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_ipx));
00084         <span class="keywordflow">if</span> (from == NULL) {
00085             *opaque = NULL;
00086             *olength = 0;
00087             <span class="keywordflow">return</span> -1;
00088         } <span class="keywordflow">else</span> {
00089             memset(from, 0, fromlen);
00090         }
00091 
00092         <span class="keywordflow">while</span> (rc &lt; 0) {
00093           rc = recvfrom(t-&gt;sock, buf, size, 0, from, &amp;fromlen);
00094           <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
00095             <span class="keywordflow">break</span>;
00096           }
00097         }
00098 
00099         <span class="keywordflow">if</span> (rc &gt;= 0) {
00100             <span class="keywordtype">char</span> *string = netsnmp_ipx_fmtaddr(NULL, from, fromlen);
00101             DEBUGMSGTL((<span class="stringliteral">"netsnmp_ipx"</span>,<span class=
"stringliteral">"recvfrom fd %d got %d bytes(from %s)\n"</span>,
00102                         t-&gt;sock, rc, string));
00103             free(string);
00104         } <span class="keywordflow">else</span> {
00105             DEBUGMSGTL((<span class="stringliteral">"netsnmp_ipx"</span>, <span class=
"stringliteral">"recvfrom fd %d err %d (\"%s\")\n"</span>,
00106                         t-&gt;sock, errno, strerror(errno)));
00107         }
00108         *opaque = (<span class="keywordtype">void</span> *) from;
00109         *olength = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_ipx);
00110     }
00111     <span class="keywordflow">return</span> rc;
00112 }
00113 
00114 
00115 
00116 <span class="keyword">static</span> <span class="keywordtype">int</span>
00117 netsnmp_ipx_send(netsnmp_transport *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
00118                  <span class="keywordtype">void</span> **opaque, <span class="keywordtype">int</span> *olength)
00119 {
00120     <span class="keywordtype">int</span> rc = -1;
00121     <span class="keyword">struct </span>sockaddr *to = NULL;
00122 
00123     <span class="keywordflow">if</span> (opaque != NULL &amp;&amp; *opaque != NULL &amp;&amp;
00124         *olength == <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_ipx)) {
00125         to = (<span class="keyword">struct </span>sockaddr *) (*opaque);
00126     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL &amp;&amp;
00127                t-&gt;data_length == <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_ipx)) {
00128         to = (<span class="keyword">struct </span>sockaddr *) (t-&gt;data);
00129     }
00130 
00131     <span class="keywordflow">if</span> (to != NULL &amp;&amp; t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00132         <span class="keywordtype">char</span> *string = netsnmp_ipx_fmtaddr(NULL, (<span class=
"keywordtype">void</span> *)to,
00133                                         <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_ipx));
00134         DEBUGMSGTL((<span class="stringliteral">"netsnmp_ipx"</span>, <span class=
"stringliteral">"send %d bytes from %p to %s on fd %d\n"</span>,
00135                     size, buf, string, t-&gt;sock));
00136         free(string);
00137         <span class="keywordflow">while</span> (rc &lt; 0) {
00138             rc = sendto(t-&gt;sock, buf, size, 0, to, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr));
00139             <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
00140                 <span class="keywordflow">break</span>;
00141             }
00142         }
00143     }
00144     <span class="keywordflow">return</span> rc;
00145 }
00146 
00147 
00148 
00149 <span class="keyword">static</span> <span class="keywordtype">int</span>
00150 netsnmp_ipx_close(netsnmp_transport *t)
00151 {
00152     <span class="keywordtype">int</span> rc = -1;
00153     <span class="keywordflow">if</span> (t-&gt;sock &gt;= 0) {
00154 <span class="preprocessor">#ifndef HAVE_CLOSESOCKET</span>
00155         rc = close(t-&gt;sock);
00156 <span class="preprocessor">#else</span>
00157         rc = closesocket(t-&gt;sock);
00158 <span class="preprocessor">#endif</span>
00159         t-&gt;sock = -1;
00160     }
00161     <span class="keywordflow">return</span> rc;
00162 }
00163 
00164 
00165 
00166 <span class="comment">/*</span>
00167 <span class="comment"> * Open a IPX-based transport for SNMP.  Local is TRUE if addr is the local</span>
00168 <span class="comment"> * address to bind to (i.e. this is a server-type session); otherwise addr is </span>
00169 <span class="comment"> * the remote address to send things to.  </span>
00170 <span class="comment"> */</span>
00171 
00172 netsnmp_transport *
00173 netsnmp_ipx_transport(<span class="keyword">struct</span> sockaddr_ipx *addr, <span class="keywordtype">int</span> local)
00174 {
00175     netsnmp_transport *t = NULL;
00176     <span class="keywordtype">int</span>             rc = 0;
00177     <span class="keywordtype">char</span>           *string = NULL;
00178 
00179     <span class="keywordflow">if</span> (addr == NULL || addr-&gt;sipx_family != AF_IPX) {
00180         <span class="keywordflow">return</span> NULL;
00181     }
00182 
00183     t = (netsnmp_transport *) malloc(<span class="keyword">sizeof</span>(netsnmp_transport));
00184     <span class="keywordflow">if</span> (t == NULL) {
00185         <span class="keywordflow">return</span> NULL;
00186     }
00187 
00188     string = netsnmp_ipx_fmtaddr(NULL, (<span class="keywordtype">void</span> *)addr, 
00189                                  <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_ipx));
00190     DEBUGMSGTL((<span class="stringliteral">"netsnmp_ipx"</span>, <span class=
"stringliteral">"open %s %s\n"</span>, local ? <span class="stringliteral">"local"</span> : <span class=
"stringliteral">"remote"</span>,
00191                 string));
00192     free(string);
00193 
00194     memset(t, 0, <span class="keyword">sizeof</span>(netsnmp_transport));
00195 
00196     t-&gt;domain = netsnmpIPXDomain;
00197     t-&gt;domain_length = netsnmpIPXDomain_len;
00198 
00199     t-&gt;sock = socket(AF_IPX, SOCK_DGRAM, AF_IPX);
00200     <span class="keywordflow">if</span> (t-&gt;sock &lt; 0) {
00201         netsnmp_transport_free(t);
00202         <span class="keywordflow">return</span> NULL;
00203     }
00204 
00205     <span class="keywordflow">if</span> (local) {
00206         t-&gt;local = malloc(12);
00207         <span class="keywordflow">if</span> (t-&gt;local == NULL) {
00208             netsnmp_transport_free(t);
00209             <span class="keywordflow">return</span> NULL;
00210         }
00211         memcpy(&amp;(t-&gt;local[00]), (u_char *) &amp; (addr-&gt;sipx_network), 4);
00212         memcpy(&amp;(t-&gt;local[04]), (u_char *) &amp; (addr-&gt;sipx_node), 6);
00213         memcpy(&amp;(t-&gt;local[10]), (u_char *) &amp; (addr-&gt;sipx_port), 2);
00214         t-&gt;local_length = 12;
00215 
00216         <span class="comment">/*</span>
00217 <span class="comment">         * This session is inteneded as a server, so we must bind on to the</span>
00218 <span class="comment">         * given address (which may include a particular network and/or node</span>
00219 <span class="comment">         * address, but definitely includes a port number).</span>
00220 <span class="comment">         */</span>
00221 
00222         rc = bind(t-&gt;sock, (<span class="keyword">struct</span> sockaddr *) addr,
00223                   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));
00224         <span class="keywordflow">if</span> (rc != 0) {
00225             netsnmp_ipx_close(t);
00226             netsnmp_transport_free(t);
00227             <span class="keywordflow">return</span> NULL;
00228         }
00229         t-&gt;data = NULL;
00230         t-&gt;data_length = 0;
00231     } <span class="keywordflow">else</span> {
00232         t-&gt;remote = malloc(12);
00233         <span class="keywordflow">if</span> (t-&gt;remote == NULL) {
00234             netsnmp_transport_free(t);
00235             <span class="keywordflow">return</span> NULL;
00236         }
00237         memcpy(&amp;(t-&gt;remote[00]), (u_char *) &amp; (addr-&gt;sipx_network), 4);
00238         memcpy(&amp;(t-&gt;remote[04]), (u_char *) &amp; (addr-&gt;sipx_node), 6);
00239         memcpy(&amp;(t-&gt;remote[10]), (u_char *) &amp; (addr-&gt;sipx_port), 2);
00240         t-&gt;remote_length = 12;
00241 
00242         <span class="comment">/*</span>
00243 <span class="comment">         * This is a client session.  Save the address in the</span>
00244 <span class="comment">         * transport-specific data pointer for later use by snmp_ipx_send.</span>
00245 <span class="comment">         */</span>
00246 
00247         t-&gt;data = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_ipx));
00248         <span class="keywordflow">if</span> (t-&gt;data == NULL) {
00249             netsnmp_transport_free(t);
00250             <span class="keywordflow">return</span> NULL;
00251         }
00252         memcpy(t-&gt;data, addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_ipx));
00253         t-&gt;data_length = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_ipx);
00254     }
00255 
00256     <span class="comment">/*</span>
00257 <span class="comment">     * Maximum size of an IPX PDU is 576 bytes including a 30-byte header.</span>
00258 <span class="comment">     * Ridiculous!  </span>
00259 <span class="comment">     */</span>
00260 
00261     t-&gt;msgMaxSize = 576 - 30;
00262     t-&gt;f_recv     = netsnmp_ipx_recv;
00263     t-&gt;f_send     = netsnmp_ipx_send;
00264     t-&gt;f_close    = netsnmp_ipx_close;
00265     t-&gt;f_accept   = NULL;
00266     t-&gt;f_fmtaddr  = netsnmp_ipx_fmtaddr;
00267 
00268     <span class="keywordflow">return</span> t;
00269 }
00270 
00271 
00272 
00273 <span class="comment">/*</span>
00274 <span class="comment"> * Attempt to parse a string of the form [%08x]:%12x[/%d] where the parts</span>
00275 <span class="comment"> * are the network number, the node address and the port in that order.  </span>
00276 <span class="comment"> */</span>
00277 
00278 <span class="keywordtype">int</span>
00279 netsnmp_sockaddr_ipx(<span class="keyword">struct</span> sockaddr_ipx *addr, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *peername)
00280 {
00281     <span class="keywordtype">char</span>           *cp = NULL;
00282     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    network = 0, i = 0;
00283 
00284     <span class="keywordflow">if</span> (addr == NULL) {
00285         <span class="keywordflow">return</span> 0;
00286     }
00287     memset(addr, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_ipx));
00288 
00289     DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_ipx"</span>, <span class=
"stringliteral">"addr %p, peername \"%s\"\n"</span>,
00290                 addr, peername ? peername : <span class="stringliteral">"[NIL]"</span>));
00291 
00292     addr-&gt;sipx_family = AF_IPX;
00293     addr-&gt;sipx_type = 4;        <span class="comment">/*  Specified in RFC 1420.  */</span>
00294 
00295     <span class="keywordflow">if</span> (peername == NULL) {
00296         <span class="keywordflow">return</span> 0;
00297     }
00298 
00299     <span class="comment">/*</span>
00300 <span class="comment">     * Skip leading white space.  </span>
00301 <span class="comment">     */</span>
00302 
00303     <span class="keywordflow">while</span> (*peername &amp;&amp; isspace((<span class=
"keywordtype">int</span>) *peername)) {
00304         peername++;
00305     }
00306 
00307     <span class="keywordflow">if</span> (!*peername) {
00308         <span class="comment">/*</span>
00309 <span class="comment">         * Completely blank address.  Let this mean "any network, any address,</span>
00310 <span class="comment">         * default SNMP port".  </span>
00311 <span class="comment">         */</span>
00312         addr-&gt;sipx_network = htonl(0);
00313         <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
00314             addr-&gt;sipx_node[i] = 0;
00315         }
00316         addr-&gt;sipx_port = htons(SNMP_IPX_DEFAULT_PORT);
00317         <span class="keywordflow">return</span> 1;
00318     }
00319 
00320     <span class="comment">/*</span>
00321 <span class="comment">     * Try to get a leading network address.  </span>
00322 <span class="comment">     */</span>
00323 
00324     network = strtoul(peername, &amp;cp, 16);
00325     <span class="keywordflow">if</span> (cp != peername) {
00326         DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_ipx"</span>, <span class=
"stringliteral">"network parsed okay\n"</span>));
00327         addr-&gt;sipx_network = htonl(network);
00328         peername = cp;
00329     } <span class="keywordflow">else</span> {
00330         DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_ipx"</span>,
00331                     <span class="stringliteral">"no network part of address\n"</span>));
00332         addr-&gt;sipx_network = htonl(0);
00333     }
00334 
00335     <span class="keywordflow">if</span> (*peername == <span class="charliteral">':'</span>) {
00336         <span class="comment">/*</span>
00337 <span class="comment">         * Okay we are looking for a node number plus optionally a port here.  </span>
00338 <span class="comment">         */</span>
00339         <span class="keywordtype">int</span>             node[6] = { 0, 0, 0, 0, 0, 0 }, rc = 0;
00340         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>  port = 0;
00341         rc = sscanf(peername, <span class="stringliteral">":%02X%02X%02X%02X%02X%02X/%hu"</span>,
00342                     &amp;node[0], &amp;node[1], &amp;node[2], &amp;node[3], &amp;node[4],
00343                     &amp;node[5], &amp;port);
00344         <span class="keywordflow">if</span> (rc &lt; 6) {
00345             DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_ipx"</span>,
00346                         <span class="stringliteral">"no node -- fail (rc %d)\n"</span>, rc));
00347             <span class="keywordflow">return</span> 0;
00348         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == 6) {
00349             DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_ipx"</span>, <span class=
"stringliteral">"node, no port\n"</span>));
00350             <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
00351                 addr-&gt;sipx_node[i] = node[i];
00352             }
00353             addr-&gt;sipx_port = htons(SNMP_IPX_DEFAULT_PORT);
00354         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc == 7) {
00355             DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_ipx"</span>, <span class=
"stringliteral">"node and port\n"</span>));
00356             <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
00357                 addr-&gt;sipx_node[i] = node[i];
00358             }
00359             addr-&gt;sipx_port = htons(port);
00360         }
00361     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*peername == <span class=
"charliteral">'/'</span>) {
00362         <span class="comment">/*</span>
00363 <span class="comment">         * Okay we are just looking for a port number here.  </span>
00364 <span class="comment">         */</span>
00365         <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>  port = 0;
00366         <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
00367             addr-&gt;sipx_node[i] = 0;
00368         }
00369         <span class="keywordflow">if</span> (sscanf(peername, <span class="stringliteral">"/%hu"</span>, &amp;port) != 1) {
00370             DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_ipx"</span>, <span class=
"stringliteral">"no port\n"</span>));
00371             addr-&gt;sipx_port = htons(SNMP_IPX_DEFAULT_PORT);
00372         } <span class="keywordflow">else</span> {
00373             addr-&gt;sipx_port = htons(port);
00374         }
00375     } <span class="keywordflow">else</span> {
00376         <span class="keywordflow">return</span> 0;
00377     }
00378 
00379     <span class="keywordflow">return</span> 1;
00380 }
00381 
00382 
00383 
00384 netsnmp_transport *
00385 netsnmp_ipx_create_tstring(<span class="keyword">const</span> <span class="keywordtype">char</span> *string, <span class=
"keywordtype">int</span> local)
00386 {
00387     <span class="keyword">struct </span>sockaddr_ipx addr;
00388 
00389     <span class="keywordflow">if</span> (netsnmp_sockaddr_ipx(&amp;addr, string)) {
00390         <span class="keywordflow">return</span> netsnmp_ipx_transport(&amp;addr, local);
00391     } <span class="keywordflow">else</span> {
00392         <span class="keywordflow">return</span> NULL;
00393     }
00394 }
00395 
00396 
00397 
00398 netsnmp_transport *
00399 netsnmp_ipx_create_ostring(<span class="keyword">const</span> u_char * o, size_t o_len, <span class=
"keywordtype">int</span> local)
00400 {
00401     <span class="keyword">struct </span>sockaddr_ipx addr;
00402 
00403     <span class="keywordflow">if</span> (o_len == 12) {
00404         addr.sipx_family = AF_IPX;
00405         memcpy((u_char *) &amp; (addr.sipx_network), &amp;(o[00]), 4);
00406         memcpy((u_char *) &amp; (addr.sipx_node), &amp;(o[04]), 6);
00407         memcpy((u_char *) &amp; (addr.sipx_port), &amp;(o[10]), 2);
00408         <span class="keywordflow">return</span> netsnmp_ipx_transport(&amp;addr, local);
00409     }
00410     <span class="keywordflow">return</span> NULL;
00411 }
00412 
00413 
00414 
00415 <span class="keywordtype">void</span>
00416 netsnmp_ipx_ctor(<span class="keywordtype">void</span>)
00417 {
00418     ipxDomain.name = netsnmpIPXDomain;
00419     ipxDomain.name_length = netsnmpIPXDomain_len;
00420     ipxDomain.prefix = calloc(2, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
00421     ipxDomain.prefix[0] = <span class="stringliteral">"ipx"</span>;
00422 
00423     ipxDomain.f_create_from_tstring = netsnmp_ipx_create_tstring;
00424     ipxDomain.f_create_from_ostring = netsnmp_ipx_create_ostring;
00425 
00426     netsnmp_tdomain_register(&amp;ipxDomain);
00427 }
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small><!--#include virtual="/sfbutton.html" --><br />
    Generated on Thu Nov 25 17:51:41 2004 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

