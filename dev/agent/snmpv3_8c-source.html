<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>snmpv3.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * snmpv3.c</span>
00003 <span class="comment"> */</span>
00004 
00005 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00006 <span class="preprocessor">#ifdef HAVE_LIMITS_H</span>
00007 <span class="preprocessor">#include &lt;limits.h&gt;</span>
00008 <span class="preprocessor">#endif</span>
00009 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00010 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00011 
00012 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00013 <span class="preprocessor"># ifdef WIN32</span>
00014 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00015 <span class="preprocessor"># else</span>
00016 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00017 <span class="preprocessor"># endif</span>
00018 <span class="preprocessor"># include &lt;time.h&gt;</span>
00019 <span class="preprocessor">#else</span>
00020 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00021 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00022 <span class="preprocessor"># else</span>
00023 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00024 <span class="preprocessor"># endif</span>
00025 <span class="preprocessor">#endif</span>
00026 <span class="preprocessor">#if HAVE_SYS_TIMES_H</span>
00027 <span class="preprocessor">#include &lt;sys/times.h&gt;</span>
00028 <span class="preprocessor">#endif</span>
00029 <span class="preprocessor">#if HAVE_STRING_H</span>
00030 <span class="preprocessor">#include &lt;string.h&gt;</span>
00031 <span class="preprocessor">#else</span>
00032 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00033 <span class="preprocessor">#endif</span>
00034 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00035 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00036 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00037 <span class="preprocessor">#endif</span>
00038 <span class="preprocessor">#if HAVE_UNISTD_H</span>
00039 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00040 <span class="preprocessor">#endif</span>
00041 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00042 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00043 <span class="preprocessor">#endif</span>
00044 <span class="preprocessor">#if HAVE_SYS_SOCKET_H</span>
00045 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00046 <span class="preprocessor">#endif</span>
00047 <span class="preprocessor">#if HAVE_NETDB_H</span>
00048 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00049 <span class="preprocessor">#endif</span>
00050 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00051 <span class="preprocessor">#       include &lt;stdlib.h&gt;</span>
00052 <span class="preprocessor">#endif</span>
00053 
00054 <span class="comment">/*</span>
00055 <span class="comment"> * Stuff needed for getHwAddress(...) </span>
00056 <span class="comment"> */</span>
00057 <span class="preprocessor">#ifdef HAVE_SYS_IOCTL_H</span>
00058 <span class="preprocessor">#       include &lt;sys/ioctl.h&gt;</span>
00059 <span class="preprocessor">#endif</span>
00060 <span class="preprocessor">#ifdef HAVE_NET_IF_H</span>
00061 <span class="preprocessor">#       include &lt;net/if.h&gt;</span>
00062 <span class="preprocessor">#endif</span>
00063 
00064 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00065 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00066 <span class="preprocessor">#endif</span>
00067 
00068 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00069 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00070 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00071 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00072 
00073 <span class="preprocessor">#include &lt;net-snmp/library/snmpv3.h&gt;</span>
00074 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
00075 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00076 <span class="preprocessor">#include &lt;net-snmp/library/lcd_time.h&gt;</span>
00077 <span class="preprocessor">#include &lt;net-snmp/library/scapi.h&gt;</span>
00078 <span class="preprocessor">#include &lt;net-snmp/library/keytools.h&gt;</span>
00079 <span class="preprocessor">#include &lt;net-snmp/library/lcd_time.h&gt;</span>
00080 <span class="preprocessor">#include &lt;net-snmp/library/snmp_secmod.h&gt;</span>
00081 <span class="preprocessor">#include &lt;net-snmp/library/snmpusm.h&gt;</span>
00082 <span class="preprocessor">#include &lt;net-snmp/library/transform_oids.h&gt;</span>
00083 
00084 <span class="keyword">static</span> u_long   engineBoots = 1;
00085 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class=
"keywordtype">int</span> engineIDType = ENGINEID_TYPE_NETSNMP_RND;
00086 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class=
"keywordtype">char</span> *engineID = NULL;
00087 <span class="keyword">static</span> size_t   engineIDLength = 0;
00088 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class=
"keywordtype">char</span> *engineIDNic = NULL;
00089 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class=
"keywordtype">int</span> engineIDIsSet = 0;  <span class="comment">/* flag if ID set by config */</span>
00090 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class=
"keywordtype">char</span> *oldEngineID = NULL;
00091 <span class="keyword">static</span> size_t   oldEngineIDLength = 0;
00092 <span class="keyword">static</span> <span class="keyword">struct </span>timeval snmpv3starttime;
00093 
00094 <span class="comment">/*</span>
00095 <span class="comment"> * Set up default snmpv3 parameter value storage.</span>
00096 <span class="comment"> */</span>
00097 <span class="keyword">static</span> <span class="keyword">const</span> oid *defaultAuthType = NULL;
00098 <span class="keyword">static</span> size_t   defaultAuthTypeLen = 0;
00099 <span class="keyword">static</span> <span class="keyword">const</span> oid *defaultPrivType = NULL;
00100 <span class="keyword">static</span> size_t   defaultPrivTypeLen = 0;
00101 
00102 <span class="comment">/* this is probably an over-kill ifdef, but why not */</span>
00103 <span class=
"preprocessor">#if defined(HAVE_SYS_TIMES_H) &amp;&amp; defined(HAVE_UNISTD_H) &amp;&amp; defined(HAVE_TIMES) &amp;&amp; defined(_SC_CLK_TCK) &amp;&amp; defined(HAVE_SYSCONF) &amp;&amp; defined(UINT_MAX)</span>
00104 
00105 <span class="preprocessor">#define SNMP_USE_TIMES 1</span>
00106 
00107 <span class="keyword">static</span> clock_t snmpv3startClock;
00108 <span class="keyword">static</span> <span class="keywordtype">long</span> clockticks = 0;
00109 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class=
"keywordtype">int</span> lastcalltime = 0;
00110 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class=
"keywordtype">int</span> wrapcounter = 0;
00111 
00112 <span class="preprocessor">#endif </span><span class="comment">/* times() tests */</span>
00113 
00114 <span class="preprocessor">#if defined(IFHWADDRLEN) &amp;&amp; defined(SIOCGIFHWADDR)</span>
00115 <span class="keyword">static</span> <span class="keywordtype">int</span>      getHwAddress(<span class=
"keyword">const</span> <span class="keywordtype">char</span> *networkDevice, <span class="keywordtype">char</span> *addressOut);
00116 <span class="preprocessor">#endif</span>
00117 
00118 <span class="keywordtype">void</span>
00119 snmpv3_authtype_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
00120 {
00121 <span class="preprocessor">#ifndef DISABLE_MD5</span>
00122     <span class="keywordflow">if</span> (strcasecmp(cptr, <span class="stringliteral">"MD5"</span>) == 0)
00123         defaultAuthType = usmHMACMD5AuthProtocol;
00124     <span class="keywordflow">else</span>
00125 <span class="preprocessor">#endif</span>
00126         <span class="keywordflow">if</span> (strcasecmp(cptr, <span class="stringliteral">"SHA"</span>) == 0)
00127         defaultAuthType = usmHMACSHA1AuthProtocol;
00128     <span class="keywordflow">else</span>
00129         config_perror(<span class="stringliteral">"Unknown authentication type"</span>);
00130     defaultAuthTypeLen = USM_LENGTH_OID_TRANSFORM;
00131     DEBUGMSGTL((<span class="stringliteral">"snmpv3"</span>, <span class=
"stringliteral">"set default authentication type: %s\n"</span>, cptr));
00132 }
00133 
00134 <span class="keyword">const</span> oid      *
00135 get_default_authtype(size_t * len)
00136 {
00137     <span class="keywordflow">if</span> (defaultAuthType == NULL) {
00138         defaultAuthType = SNMP_DEFAULT_AUTH_PROTO;
00139         defaultAuthTypeLen = SNMP_DEFAULT_AUTH_PROTOLEN;
00140     }
00141     <span class="keywordflow">if</span> (len)
00142         *len = defaultAuthTypeLen;
00143     <span class="keywordflow">return</span> defaultAuthType;
00144 }
00145 
00146 <span class="keywordtype">void</span>
00147 snmpv3_privtype_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
00148 {
00149     <span class="keywordtype">int</span> testcase = 0;
00150 
00151 <span class="preprocessor">#ifndef DISABLE_DES</span>
00152     <span class="keywordflow">if</span> (strcasecmp(cptr, <span class="stringliteral">"DES"</span>) == 0) {
00153         testcase = 1;
00154         defaultPrivType = usmDESPrivProtocol;
00155     }
00156 <span class="preprocessor">#endif</span>
00157 
00158 <span class="preprocessor">#if HAVE_AES</span>
00159     <span class="comment">/* XXX AES: assumes oid length == des oid length */</span>
00160     <span class="keywordflow">if</span> (strcasecmp(cptr, <span class="stringliteral">"AES128"</span>) == 0 ||
00161         strcasecmp(cptr, <span class="stringliteral">"AES"</span>) == 0) {
00162         testcase = 1;
00163         defaultPrivType = usmAES128PrivProtocol;
00164     }
00165 <span class="preprocessor">#endif</span>
00166     <span class="keywordflow">if</span> (testcase == 0)
00167         config_perror(<span class="stringliteral">"Unknown privacy type"</span>);
00168     defaultPrivTypeLen = SNMP_DEFAULT_PRIV_PROTOLEN;
00169     DEBUGMSGTL((<span class="stringliteral">"snmpv3"</span>, <span class=
"stringliteral">"set default privacy type: %s\n"</span>, cptr));
00170 }
00171 
00172 <span class="keyword">const</span> oid      *
00173 get_default_privtype(size_t * len)
00174 {
00175     <span class="keywordflow">if</span> (defaultPrivType == NULL) {
00176 <span class="preprocessor">#ifndef DISABLE_DES</span>
00177         defaultPrivType = usmDESPrivProtocol;
00178 <span class="preprocessor">#else</span>
00179         defaultPrivType = usmAESPrivProtocol;
00180 <span class="preprocessor">#endif</span>
00181         defaultPrivTypeLen = USM_LENGTH_OID_TRANSFORM;
00182     }
00183     <span class="keywordflow">if</span> (len)
00184         *len = defaultPrivTypeLen;
00185     <span class="keywordflow">return</span> defaultPrivType;
00186 }
00187 
00188 <span class="comment">/*******************************************************************-o-******</span>
00189 <span class="comment"> * snmpv3_secLevel_conf</span>
00190 <span class="comment"> *</span>
00191 <span class="comment"> * Parameters:</span>
00192 <span class="comment"> *      *word</span>
00193 <span class="comment"> *      *cptr</span>
00194 <span class="comment"> *</span>
00195 <span class="comment"> * Line syntax:</span>
00196 <span class="comment"> *      defSecurityLevel "noAuthNoPriv" | "authNoPriv" | "authPriv"</span>
00197 <span class="comment"> */</span>
00198 
00199 <span class="keywordtype">int</span>
00200 parse_secLevel_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr) {
00201     <span class="keywordflow">if</span> (strcasecmp(cptr, <span class=
"stringliteral">"noAuthNoPriv"</span>) == 0 || strcmp(cptr, <span class="stringliteral">"1"</span>) == 0 ||
00202         strcasecmp(cptr, <span class="stringliteral">"nanp"</span>) == 0) {
00203         <span class="keywordflow">return</span> SNMP_SEC_LEVEL_NOAUTH;
00204     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(cptr, <span class=
"stringliteral">"authNoPriv"</span>) == 0 || strcmp(cptr, <span class="stringliteral">"2"</span>) == 0 ||
00205                strcasecmp(cptr, <span class="stringliteral">"anp"</span>) == 0) {
00206         <span class="keywordflow">return</span> SNMP_SEC_LEVEL_AUTHNOPRIV;
00207     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(cptr, <span class=
"stringliteral">"authPriv"</span>) == 0 || strcmp(cptr, <span class="stringliteral">"3"</span>) == 0 ||
00208                strcasecmp(cptr, <span class="stringliteral">"ap"</span>) == 0) {
00209         <span class="keywordflow">return</span> SNMP_SEC_LEVEL_AUTHPRIV;
00210     } <span class="keywordflow">else</span> {
00211         <span class="keywordflow">return</span> -1;
00212     }
00213 }
00214 
00215 <span class="keywordtype">void</span>
00216 snmpv3_secLevel_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
00217 {
00218     <span class="keywordtype">char</span>            buf[1024];
00219     <span class="keywordtype">int</span>             secLevel;
00220 
00221     <span class="keywordflow">if</span> ((secLevel = parse_secLevel_conf( word, cptr )) &gt;= 0 ) {
00222         netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, 
00223                            NETSNMP_DS_LIB_SECLEVEL, secLevel);
00224     } <span class="keywordflow">else</span> {
00225         snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class=
"stringliteral">"Unknown security level: %s"</span>, cptr);
00226         buf[ <span class="keyword">sizeof</span>(buf)-1 ] = 0;
00227         config_perror(buf);
00228     }
00229     DEBUGMSGTL((<span class="stringliteral">"snmpv3"</span>, <span class=
"stringliteral">"default secLevel set to: %s = %d\n"</span>, cptr,
00230                 netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
00231                                    NETSNMP_DS_LIB_SECLEVEL)));
00232 }
00233 
00234 
00235 <span class="keywordtype">int</span>
00236 snmpv3_options(<span class="keywordtype">char</span> *optarg, <a class="code" href=
"structsnmp__session.html">netsnmp_session</a> * session, <span class="keywordtype">char</span> **Apsz,
00237                <span class="keywordtype">char</span> **Xpsz, <span class="keywordtype">int</span> argc, <span class=
"keywordtype">char</span> *<span class="keyword">const</span> *argv)
00238 {
00239     <span class="keywordtype">char</span>           *cp = optarg;
00240     <span class="keywordtype">int</span> testcase;
00241     optarg++;
00242     <span class="comment">/*</span>
00243 <span class="comment">     * Support '... -3x=value ....' syntax</span>
00244 <span class="comment">     */</span>
00245     <span class="keywordflow">if</span> (*optarg == <span class="charliteral">'='</span>) {
00246         optarg++;
00247     }
00248     <span class="comment">/*</span>
00249 <span class="comment">     * and '.... "-3x value" ....'  (*with* the quotes)</span>
00250 <span class="comment">     */</span>
00251     <span class="keywordflow">while</span> (*optarg &amp;&amp; isspace(*optarg)) {
00252         optarg++;
00253     }
00254     <span class="comment">/*</span>
00255 <span class="comment">     * Finally, handle ".... -3x value ...." syntax</span>
00256 <span class="comment">     *   (*without* surrounding quotes)</span>
00257 <span class="comment">     */</span>
00258     <span class="keywordflow">if</span> (!*optarg) {
00259         <span class="comment">/*</span>
00260 <span class="comment">         * We've run off the end of the argument</span>
00261 <span class="comment">         *  so move on the the next.</span>
00262 <span class="comment">         */</span>
00263         optarg = argv[optind++];
00264         <span class="keywordflow">if</span> (optind &gt; argc) {
00265             fprintf(stderr,
00266                     <span class="stringliteral">"Missing argument after SNMPv3 '-3%c' option.\n"</span>, *cp);
00267             <span class="keywordflow">return</span> (-1);
00268         }
00269     }
00270 
00271     <span class="keywordflow">switch</span> (*cp) {
00272 
00273     <span class="keywordflow">case</span> <span class="charliteral">'Z'</span>:
00274         session-&gt;<a class="code" href="structsnmp__session.html#o23">engineBoots</a> = strtoul(optarg, NULL, 10);
00275         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o23">engineBoots</a> == 0 || !isdigit(optarg[0])) {
00276             fprintf(stderr, <span class="stringliteral">"Need engine boots value after -3Z flag.\n"</span>);
00277             <span class="keywordflow">return</span> (-1);
00278         }
00279         cp = strchr(optarg, <span class="charliteral">','</span>);
00280         <span class="keywordflow">if</span> (cp &amp;&amp; *(++cp) &amp;&amp; isdigit(*cp))
00281             session-&gt;<a class="code" href="structsnmp__session.html#o24">engineTime</a> = strtoul(cp, NULL, 10);
00282         <span class="keywordflow">else</span> {
00283             fprintf(stderr, <span class="stringliteral">"Need engine time value after -3Z flag.\n"</span>);
00284             <span class="keywordflow">return</span> (-1);
00285         }
00286         <span class="keywordflow">break</span>;
00287 
00288     <span class="keywordflow">case</span> <span class="charliteral">'e'</span>:{
00289             size_t          ebuf_len = 32, eout_len = 0;
00290             u_char         *ebuf = (u_char *) malloc(ebuf_len);
00291 
00292             <span class="keywordflow">if</span> (ebuf == NULL) {
00293                 fprintf(stderr, <span class="stringliteral">"malloc failure processing -3e flag.\n"</span>);
00294                 <span class="keywordflow">return</span> (-1);
00295             }
00296             <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#ga8">snmp_hex_to_binary</a>
00297                 (&amp;ebuf, &amp;ebuf_len, &amp;eout_len, 1, optarg)) {
00298                 fprintf(stderr, <span class="stringliteral">"Bad engine ID value after -3e flag.\n"</span>);
00299                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ebuf);
00300                 <span class="keywordflow">return</span> (-1);
00301             }
00302             session-&gt;<a class="code" href="structsnmp__session.html#o27">securityEngineID</a> = ebuf;
00303             session-&gt;<a class="code" href="structsnmp__session.html#o28">securityEngineIDLen</a> = eout_len;
00304             <span class="keywordflow">break</span>;
00305         }
00306 
00307     <span class="keywordflow">case</span> <span class="charliteral">'E'</span>:{
00308             size_t          ebuf_len = 32, eout_len = 0;
00309             u_char         *ebuf = (u_char *) malloc(ebuf_len);
00310 
00311             <span class="keywordflow">if</span> (ebuf == NULL) {
00312                 fprintf(stderr, <span class="stringliteral">"malloc failure processing -3E flag.\n"</span>);
00313                 <span class="keywordflow">return</span> (-1);
00314             }
00315             <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#ga8">snmp_hex_to_binary</a>
00316                 (&amp;ebuf, &amp;ebuf_len, &amp;eout_len, 1, optarg)) {
00317                 fprintf(stderr, <span class="stringliteral">"Bad engine ID value after -3E flag.\n"</span>);
00318                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ebuf);
00319                 <span class="keywordflow">return</span> (-1);
00320             }
00321             session-&gt;<a class="code" href="structsnmp__session.html#o21">contextEngineID</a> = ebuf;
00322             session-&gt;<a class="code" href="structsnmp__session.html#o22">contextEngineIDLen</a> = eout_len;
00323             <span class="keywordflow">break</span>;
00324         }
00325 
00326     <span class="keywordflow">case</span> <span class="charliteral">'n'</span>:
00327         session-&gt;<a class="code" href="structsnmp__session.html#o25">contextName</a> = optarg;
00328         session-&gt;<a class="code" href="structsnmp__session.html#o26">contextNameLen</a> = strlen(optarg);
00329         <span class="keywordflow">break</span>;
00330 
00331     <span class="keywordflow">case</span> <span class="charliteral">'u'</span>:
00332         session-&gt;<a class="code" href="structsnmp__session.html#o29">securityName</a> = optarg;
00333         session-&gt;<a class="code" href="structsnmp__session.html#o30">securityNameLen</a> = strlen(optarg);
00334         <span class="keywordflow">break</span>;
00335 
00336     <span class="keywordflow">case</span> <span class="charliteral">'l'</span>:
00337         <span class="keywordflow">if</span> (!strcasecmp(optarg, <span class=
"stringliteral">"noAuthNoPriv"</span>) || !strcmp(optarg, <span class="stringliteral">"1"</span>) ||
00338             !strcasecmp(optarg, <span class="stringliteral">"nanp"</span>)) {
00339             session-&gt;<a class="code" href="structsnmp__session.html#o44">securityLevel</a> = SNMP_SEC_LEVEL_NOAUTH;
00340         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcasecmp(optarg, <span class=
"stringliteral">"authNoPriv"</span>)
00341                    || !strcmp(optarg, <span class="stringliteral">"2"</span>) || !strcasecmp(optarg, <span class=
"stringliteral">"anp"</span>)) {
00342             session-&gt;<a class="code" href="structsnmp__session.html#o44">securityLevel</a> = SNMP_SEC_LEVEL_AUTHNOPRIV;
00343         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcasecmp(optarg, <span class=
"stringliteral">"authPriv"</span>) || !strcmp(optarg, <span class="stringliteral">"3"</span>)
00344                    || !strcasecmp(optarg, <span class="stringliteral">"ap"</span>)) {
00345             session-&gt;<a class="code" href="structsnmp__session.html#o44">securityLevel</a> = SNMP_SEC_LEVEL_AUTHPRIV;
00346         } <span class="keywordflow">else</span> {
00347             fprintf(stderr,
00348                     <span class="stringliteral">"Invalid security level specified after -3l flag: %s\n"</span>,
00349                     optarg);
00350             <span class="keywordflow">return</span> (-1);
00351         }
00352 
00353         <span class="keywordflow">break</span>;
00354 
00355     <span class="keywordflow">case</span> <span class="charliteral">'a'</span>:
00356 <span class="preprocessor">#ifndef DISABLE_MD5</span>
00357         <span class="keywordflow">if</span> (!strcasecmp(optarg, <span class="stringliteral">"MD5"</span>)) {
00358             session-&gt;<a class="code" href="structsnmp__session.html#o31">securityAuthProto</a> = usmHMACMD5AuthProtocol;
00359             session-&gt;<a class="code" href=
"structsnmp__session.html#o32">securityAuthProtoLen</a> = USM_AUTH_PROTO_MD5_LEN;
00360         } <span class="keywordflow">else</span>
00361 <span class="preprocessor">#endif</span>
00362             <span class="keywordflow">if</span> (!strcasecmp(optarg, <span class="stringliteral">"SHA"</span>)) {
00363             session-&gt;<a class="code" href=
"structsnmp__session.html#o31">securityAuthProto</a> = usmHMACSHA1AuthProtocol;
00364             session-&gt;<a class="code" href=
"structsnmp__session.html#o32">securityAuthProtoLen</a> = USM_AUTH_PROTO_SHA_LEN;
00365         } <span class="keywordflow">else</span> {
00366             fprintf(stderr,
00367                     <span class="stringliteral">"Invalid authentication protocol specified after -3a flag: %s\n"</span>,
00368                     optarg);
00369             <span class="keywordflow">return</span> (-1);
00370         }
00371         <span class="keywordflow">break</span>;
00372 
00373     <span class="keywordflow">case</span> <span class="charliteral">'x'</span>:
00374         testcase = 0;
00375 <span class="preprocessor">#ifndef DISABLE_DES</span>
00376         <span class="keywordflow">if</span> (!strcasecmp(optarg, <span class="stringliteral">"DES"</span>)) {
00377             session-&gt;<a class="code" href="structsnmp__session.html#o37">securityPrivProto</a> = usmDESPrivProtocol;
00378             session-&gt;<a class="code" href=
"structsnmp__session.html#o38">securityPrivProtoLen</a> = USM_PRIV_PROTO_DES_LEN;
00379             testcase = 1;
00380         }
00381 <span class="preprocessor">#endif</span>
00382 <span class="preprocessor">#ifdef HAVE_AES</span>
00383         <span class="keywordflow">if</span> (!strcasecmp(optarg, <span class="stringliteral">"AES128"</span>) ||
00384             strcasecmp(optarg, <span class="stringliteral">"AES"</span>)) {
00385             session-&gt;<a class="code" href="structsnmp__session.html#o37">securityPrivProto</a> = usmAES128PrivProtocol;
00386             session-&gt;<a class="code" href=
"structsnmp__session.html#o38">securityPrivProtoLen</a> = USM_PRIV_PROTO_AES128_LEN;
00387             testcase = 1;
00388         }
00389 <span class="preprocessor">#endif</span>
00390         <span class="keywordflow">if</span> (testcase == 0) {
00391             fprintf(stderr,
00392                     <span class="stringliteral">"Invalid privacy protocol specified after -3x flag: %s\n"</span>,
00393                     optarg);
00394             <span class="keywordflow">return</span> (-1);
00395         }
00396         <span class="keywordflow">break</span>;
00397 
00398     <span class="keywordflow">case</span> <span class="charliteral">'A'</span>:
00399         *Apsz = optarg;
00400         <span class="keywordflow">break</span>;
00401 
00402     <span class="keywordflow">case</span> <span class="charliteral">'X'</span>:
00403         *Xpsz = optarg;
00404         <span class="keywordflow">break</span>;
00405 
00406     <span class="keywordflow">case</span> <span class="charliteral">'m'</span>: {
00407         size_t bufSize = <span class="keyword">sizeof</span>(session-&gt;<a class="code" href=
"structsnmp__session.html#o33">securityAuthKey</a>);
00408         u_char *tmpp = session-&gt;<a class="code" href="structsnmp__session.html#o33">securityAuthKey</a>;
00409         <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;tmpp, &amp;bufSize,
00410                                 &amp;session-&gt;<a class="code" href=
"structsnmp__session.html#o34">securityAuthKeyLen</a>, 0, optarg)) {
00411             fprintf(stderr, <span class="stringliteral">"Bad key value after -3m flag.\n"</span>);
00412             <span class="keywordflow">return</span> (-1);
00413         }
00414         <span class="keywordflow">break</span>;
00415     }
00416 
00417     <span class="keywordflow">case</span> <span class="charliteral">'M'</span>: {
00418         size_t bufSize = <span class="keyword">sizeof</span>(session-&gt;<a class="code" href=
"structsnmp__session.html#o39">securityPrivKey</a>);
00419         u_char *tmpp = session-&gt;<a class="code" href="structsnmp__session.html#o39">securityPrivKey</a>;
00420         <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;tmpp, &amp;bufSize,
00421              &amp;session-&gt;<a class="code" href="structsnmp__session.html#o40">securityPrivKeyLen</a>, 0, optarg)) {
00422             fprintf(stderr, <span class="stringliteral">"Bad key value after -3M flag.\n"</span>);
00423             <span class="keywordflow">return</span> (-1);
00424         }
00425         <span class="keywordflow">break</span>;
00426     }
00427 
00428     <span class="keywordflow">case</span> <span class="charliteral">'k'</span>: {
00429         size_t          kbuf_len = 32, kout_len = 0;
00430         u_char         *kbuf = (u_char *) malloc(kbuf_len);
00431 
00432         <span class="keywordflow">if</span> (kbuf == NULL) {
00433             fprintf(stderr, <span class="stringliteral">"malloc failure processing -3k flag.\n"</span>);
00434             <span class="keywordflow">return</span> (-1);
00435         }
00436         <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#ga8">snmp_hex_to_binary</a>
00437             (&amp;kbuf, &amp;kbuf_len, &amp;kout_len, 1, optarg)) {
00438             fprintf(stderr, <span class="stringliteral">"Bad key value after -3k flag.\n"</span>);
00439             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(kbuf);
00440             <span class="keywordflow">return</span> (-1);
00441         }
00442         session-&gt;<a class="code" href="structsnmp__session.html#o35">securityAuthLocalKey</a> = kbuf;
00443         session-&gt;<a class="code" href="structsnmp__session.html#o36">securityAuthLocalKeyLen</a> = kout_len;
00444         <span class="keywordflow">break</span>;
00445     }
00446 
00447     <span class="keywordflow">case</span> <span class="charliteral">'K'</span>: {
00448         size_t          kbuf_len = 32, kout_len = 0;
00449         u_char         *kbuf = (u_char *) malloc(kbuf_len);
00450 
00451         <span class="keywordflow">if</span> (kbuf == NULL) {
00452             fprintf(stderr, <span class="stringliteral">"malloc failure processing -3K flag.\n"</span>);
00453             <span class="keywordflow">return</span> (-1);
00454         }
00455         <span class="keywordflow">if</span> (!<a class="code" href="group__util.html#ga8">snmp_hex_to_binary</a>
00456             (&amp;kbuf, &amp;kbuf_len, &amp;kout_len, 1, optarg)) {
00457             fprintf(stderr, <span class="stringliteral">"Bad key value after -3K flag.\n"</span>);
00458             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(kbuf);
00459             <span class="keywordflow">return</span> (-1);
00460         }
00461         session-&gt;<a class="code" href="structsnmp__session.html#o41">securityPrivLocalKey</a> = kbuf;
00462         session-&gt;<a class="code" href="structsnmp__session.html#o42">securityPrivLocalKeyLen</a> = kout_len;
00463         <span class="keywordflow">break</span>;
00464     }
00465         
00466     <span class="keywordflow">default</span>:
00467         fprintf(stderr, <span class="stringliteral">"Unknown SNMPv3 option passed to -3: %c.\n"</span>, *cp);
00468         <span class="keywordflow">return</span> -1;
00469     }
00470     <span class="keywordflow">return</span> 0;
00471 }
00472 
00473 <span class="comment">/*******************************************************************-o-******</span>
00474 <span class="comment"> * setup_engineID</span>
00475 <span class="comment"> *</span>
00476 <span class="comment"> * Parameters:</span>
00477 <span class="comment"> *      **eidp</span>
00478 <span class="comment"> *       *text  Printable (?) text to be plugged into the snmpEngineID.</span>
00479 <span class="comment"> *</span>
00480 <span class="comment"> * Return:</span>
00481 <span class="comment"> *      Length of allocated engineID string in bytes,  -OR-</span>
00482 <span class="comment"> *      -1 on error.</span>
00483 <span class="comment"> *</span>
00484 <span class="comment"> *</span>
00485 <span class="comment"> * Create an snmpEngineID using text and the local IP address.  If eidp</span>
00486 <span class="comment"> * is defined, use it to return a pointer to the newly allocated data.</span>
00487 <span class="comment"> * Otherwise, use the result to define engineID defined in this module.</span>
00488 <span class="comment"> *</span>
00489 <span class="comment"> * Line syntax:</span>
00490 <span class="comment"> *      engineID &lt;text&gt; | NULL</span>
00491 <span class="comment"> *</span>
00492 <span class="comment"> * XXX  What if a node has multiple interfaces?</span>
00493 <span class="comment"> * XXX  What if multiple engines all choose the same address?</span>
00494 <span class="comment"> *      (answer:  You're screwed, because you might need a kul database</span>
00495 <span class="comment"> *       which is dependant on the current engineID.  Enumeration and other</span>
00496 <span class="comment"> *       tricks won't work). </span>
00497 <span class="comment"> */</span>
00498 <span class="keywordtype">int</span>
00499 setup_engineID(u_char ** eidp, <span class="keyword">const</span> <span class="keywordtype">char</span> *text)
00500 {
00501     <span class="keywordtype">int</span>             enterpriseid = htonl(ENTERPRISE_OID),
00502         netsnmpoid = htonl(NETSNMP_OID),
00503         localsetup = (eidp) ? 0 : 1;
00504 
00505     <span class="comment">/*</span>
00506 <span class="comment">     * Use local engineID if *eidp == NULL.  </span>
00507 <span class="comment">     */</span>
00508 <span class="preprocessor">#ifdef HAVE_GETHOSTNAME</span>
00509     u_char          buf[SNMP_MAXBUF_SMALL];
00510     <span class="keyword">struct </span>hostent *hent = NULL;
00511 <span class="preprocessor">#endif</span>
00512     u_char         *bufp = NULL;
00513     size_t          len;
00514     <span class="keywordtype">int</span>             localEngineIDType = engineIDType;
00515     <span class="keywordtype">int</span>             tmpint;
00516     time_t          tmptime;
00517 
00518     engineIDIsSet = 1;
00519 
00520 <span class="preprocessor">#ifdef HAVE_GETHOSTNAME</span>
00521 <span class="preprocessor">#ifdef AF_INET6</span>
00522     <span class="comment">/*</span>
00523 <span class="comment">     * see if they selected IPV4 or IPV6 support </span>
00524 <span class="comment">     */</span>
00525     <span class="keywordflow">if</span> ((ENGINEID_TYPE_IPV6 == localEngineIDType) ||
00526         (ENGINEID_TYPE_IPV4 == localEngineIDType)) {
00527         <span class="comment">/*</span>
00528 <span class="comment">         * get the host name and save the information </span>
00529 <span class="comment">         */</span>
00530         gethostname((<span class="keywordtype">char</span> *) buf, <span class="keyword">sizeof</span>(buf));
00531         hent = gethostbyname((<span class="keywordtype">char</span> *) buf);
00532         <span class="keywordflow">if</span> (hent &amp;&amp; hent-&gt;h_addrtype == AF_INET6) {
00533             localEngineIDType = ENGINEID_TYPE_IPV6;
00534         } <span class="keywordflow">else</span> {
00535             <span class="comment">/*</span>
00536 <span class="comment">             * Not IPV6 so we go with default </span>
00537 <span class="comment">             */</span>
00538             localEngineIDType = ENGINEID_TYPE_IPV4;
00539         }
00540     }
00541 <span class="preprocessor">#else</span>
00542     <span class="comment">/*</span>
00543 <span class="comment">     * No IPV6 support.  Check if they selected IPV6 engineID type.</span>
00544 <span class="comment">     *  If so make it IPV4 instead </span>
00545 <span class="comment">     */</span>
00546     <span class="keywordflow">if</span> (ENGINEID_TYPE_IPV6 == localEngineIDType) {
00547         localEngineIDType = ENGINEID_TYPE_IPV4;
00548     }
00549     <span class="keywordflow">if</span> (ENGINEID_TYPE_IPV4 == localEngineIDType) {
00550         <span class="comment">/*</span>
00551 <span class="comment">         * get the host name and save the information </span>
00552 <span class="comment">         */</span>
00553         gethostname((<span class="keywordtype">char</span> *) buf, <span class="keyword">sizeof</span>(buf));
00554         hent = gethostbyname((<span class="keywordtype">char</span> *) buf);
00555     }
00556 <span class="preprocessor">#endif</span>
00557 <span class="preprocessor">#endif                          </span><span class="comment">/* HAVE_GETHOSTNAME */</span>
00558 
00559     <span class="comment">/*</span>
00560 <span class="comment">     * Determine if we have text and if so setup our localEngineIDType</span>
00561 <span class="comment">     * * appropriately.  </span>
00562 <span class="comment">     */</span>
00563     <span class="keywordflow">if</span> (NULL != text) {
00564         engineIDType = localEngineIDType = ENGINEID_TYPE_TEXT;
00565     }
00566     <span class="comment">/*</span>
00567 <span class="comment">     * Determine length of the engineID string. </span>
00568 <span class="comment">     */</span>
00569     len = 5;                    <span class="comment">/* always have 5 leading bytes */</span>
00570     <span class="keywordflow">switch</span> (localEngineIDType) {
00571     <span class="keywordflow">case</span> ENGINEID_TYPE_TEXT:
00572         len += strlen(text);    <span class="comment">/* 5 leading bytes+text. No NULL char */</span>
00573         <span class="keywordflow">break</span>;
00574 <span class="preprocessor">#if defined(IFHWADDRLEN) &amp;&amp; defined(SIOCGIFHWADDR)</span>
00575     <span class="keywordflow">case</span> ENGINEID_TYPE_MACADDR:        <span class="comment">/* MAC address */</span>
00576         len += 6;               <span class="comment">/* + 6 bytes for MAC address */</span>
00577         <span class="keywordflow">break</span>;
00578 <span class="preprocessor">#endif</span>
00579     <span class="keywordflow">case</span> ENGINEID_TYPE_IPV4:   <span class="comment">/* IPv4 */</span>
00580         len += 4;               <span class="comment">/* + 4 byte IPV4 address */</span>
00581         <span class="keywordflow">break</span>;
00582     <span class="keywordflow">case</span> ENGINEID_TYPE_IPV6:   <span class="comment">/* IPv6 */</span>
00583         len += 16;              <span class="comment">/* + 16 byte IPV6 address */</span>
00584         <span class="keywordflow">break</span>;
00585     <span class="keywordflow">case</span> ENGINEID_TYPE_NETSNMP_RND:        <span class=
"comment">/* Net-SNMP specific encoding */</span>
00586         <span class="keywordflow">if</span> (engineID)           <span class=
"comment">/* already setup, keep current value */</span>
00587             <span class="keywordflow">return</span> engineIDLength;
00588         <span class="keywordflow">if</span> (oldEngineID) {
00589             len = oldEngineIDLength;
00590         } <span class="keywordflow">else</span> {
00591             len += <span class="keyword">sizeof</span>(int) + <span class="keyword">sizeof</span>(time_t);
00592         }
00593         <span class="keywordflow">break</span>;
00594     <span class="keywordflow">default</span>:
00595         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
00596                  <span class="stringliteral">"Unknown EngineID type requested for setup (%d).  Using IPv4.\n"</span>,
00597                  localEngineIDType);
00598         localEngineIDType = ENGINEID_TYPE_IPV4; <span class="comment">/* make into IPV4 */</span>
00599         len += 4;               <span class="comment">/* + 4 byte IPv4 address */</span>
00600         <span class="keywordflow">break</span>;
00601     }                           <span class="comment">/* switch */</span>
00602 
00603 
00604     <span class="comment">/*</span>
00605 <span class="comment">     * Allocate memory and store enterprise ID.</span>
00606 <span class="comment">     */</span>
00607     <span class="keywordflow">if</span> ((bufp = (u_char *) malloc(len)) == NULL) {
00608         snmp_log_perror(<span class="stringliteral">"setup_engineID malloc"</span>);
00609         <span class="keywordflow">return</span> -1;
00610     }
00611     <span class="keywordflow">if</span> (localEngineIDType == ENGINEID_TYPE_NETSNMP_RND)
00612         <span class="comment">/*</span>
00613 <span class="comment">         * we must use the net-snmp enterprise id here, regardless </span>
00614 <span class="comment">         */</span>
00615         memcpy(bufp, &amp;netsnmpoid, <span class="keyword">sizeof</span>(netsnmpoid));    <span class=
"comment">/* XXX Must be 4 bytes! */</span>
00616     <span class="keywordflow">else</span>
00617         memcpy(bufp, &amp;enterpriseid, <span class="keyword">sizeof</span>(enterpriseid));      <span class=
"comment">/* XXX Must be 4 bytes! */</span>
00618 
00619     bufp[0] |= 0x80;
00620 
00621 
00622     <span class="comment">/*</span>
00623 <span class="comment">     * Store the given text  -OR-   the first found IP address</span>
00624 <span class="comment">     *  -OR-  the MAC address  -OR-  random elements</span>
00625 <span class="comment">     * (the latter being the recommended default)</span>
00626 <span class="comment">     */</span>
00627     <span class="keywordflow">switch</span> (localEngineIDType) {
00628     <span class="keywordflow">case</span> ENGINEID_TYPE_NETSNMP_RND:
00629         <span class="keywordflow">if</span> (oldEngineID) {
00630             <span class="comment">/*</span>
00631 <span class="comment">             * keep our previous notion of the engineID </span>
00632 <span class="comment">             */</span>
00633             memcpy(bufp, oldEngineID, oldEngineIDLength);
00634         } <span class="keywordflow">else</span> {
00635             <span class="comment">/*</span>
00636 <span class="comment">             * Here we've desigend our own ENGINEID that is not based on</span>
00637 <span class="comment">             * an address which may change and may even become conflicting</span>
00638 <span class="comment">             * in the future like most of the default v3 engineID types</span>
00639 <span class="comment">             * suffer from.</span>
00640 <span class="comment">             * </span>
00641 <span class="comment">             * Ours is built from 2 fairly random elements: a random number and</span>
00642 <span class="comment">             * the current time in seconds.  This method suffers from boxes</span>
00643 <span class="comment">             * that may not have a correct clock setting and random number</span>
00644 <span class="comment">             * seed at startup, but few OSes should have that problem.</span>
00645 <span class="comment">             */</span>
00646             bufp[4] = ENGINEID_TYPE_NETSNMP_RND;
00647             tmpint = random();
00648             memcpy(bufp + 5, &amp;tmpint, <span class="keyword">sizeof</span>(tmpint));
00649             tmptime = time(NULL);
00650             memcpy(bufp + 5 + <span class="keyword">sizeof</span>(tmpint), &amp;tmptime, <span class=
"keyword">sizeof</span>(tmptime));
00651         }
00652         <span class="keywordflow">break</span>;
00653     <span class="keywordflow">case</span> ENGINEID_TYPE_TEXT:
00654         bufp[4] = ENGINEID_TYPE_TEXT;
00655         memcpy((<span class="keywordtype">char</span> *) bufp + 5, text, strlen(text));
00656         <span class="keywordflow">break</span>;
00657 <span class="preprocessor">#ifdef HAVE_GETHOSTNAME</span>
00658 <span class="preprocessor">#ifdef AF_INET6</span>
00659     <span class="keywordflow">case</span> ENGINEID_TYPE_IPV6:
00660         bufp[4] = ENGINEID_TYPE_IPV6;
00661         memcpy(bufp + 5, hent-&gt;h_addr_list[0], hent-&gt;h_length);
00662         <span class="keywordflow">break</span>;
00663 <span class="preprocessor">#endif</span>
00664 <span class="preprocessor">#endif</span>
00665 <span class="preprocessor">#if defined(IFHWADDRLEN) &amp;&amp; defined(SIOCGIFHWADDR)</span>
00666     <span class="keywordflow">case</span> ENGINEID_TYPE_MACADDR:
00667         {
00668             <span class="keywordtype">int</span>             x;
00669             bufp[4] = ENGINEID_TYPE_MACADDR;
00670             <span class="comment">/*</span>
00671 <span class="comment">             * use default NIC if none provided </span>
00672 <span class="comment">             */</span>
00673             <span class="keywordflow">if</span> (NULL == engineIDNic) {
00674                 x = getHwAddress(DEFAULT_NIC, &amp;bufp[5]);
00675             } <span class="keywordflow">else</span> {
00676                 x = getHwAddress(engineIDNic, &amp;bufp[5]);
00677             }
00678             <span class="keywordflow">if</span> (0 != x)
00679                 <span class="comment">/*</span>
00680 <span class="comment">                 * function failed fill MAC address with zeros </span>
00681 <span class="comment">                 */</span>
00682             {
00683                 memset(&amp;bufp[5], 0, 6);
00684             }
00685         }
00686         <span class="keywordflow">break</span>;
00687 <span class="preprocessor">#endif</span>
00688     <span class="keywordflow">case</span> ENGINEID_TYPE_IPV4:
00689     <span class="keywordflow">default</span>:
00690         bufp[4] = ENGINEID_TYPE_IPV4;
00691 <span class="preprocessor">#ifdef HAVE_GETHOSTNAME</span>
00692         <span class="keywordflow">if</span> (hent &amp;&amp; hent-&gt;h_addrtype == AF_INET) {
00693             memcpy(bufp + 5, hent-&gt;h_addr_list[0], hent-&gt;h_length);
00694         } <span class="keywordflow">else</span> {                <span class=
"comment">/* Unknown address type.  Default to 127.0.0.1. */</span>
00695 
00696             bufp[5] = 127;
00697             bufp[6] = 0;
00698             bufp[7] = 0;
00699             bufp[8] = 1;
00700         }
00701 <span class="preprocessor">#else                           </span><span class="comment">/* HAVE_GETHOSTNAME */</span>
00702         <span class="comment">/*</span>
00703 <span class="comment">         * Unknown address type.  Default to 127.0.0.1. </span>
00704 <span class="comment">         */</span>
00705         bufp[5] = 127;
00706         bufp[6] = 0;
00707         bufp[7] = 0;
00708         bufp[8] = 1;
00709 <span class="preprocessor">#endif                          </span><span class="comment">/* HAVE_GETHOSTNAME */</span>
00710         <span class="keywordflow">break</span>;
00711     }
00712 
00713     <span class="comment">/*</span>
00714 <span class="comment">     * Pass the string back to the calling environment, or use it for</span>
00715 <span class="comment">     * our local engineID.</span>
00716 <span class="comment">     */</span>
00717     <span class="keywordflow">if</span> (localsetup) {
00718         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(engineID);
00719         engineID = bufp;
00720         engineIDLength = len;
00721 
00722     } <span class="keywordflow">else</span> {
00723         *eidp = bufp;
00724     }
00725 
00726 
00727     <span class="keywordflow">return</span> len;
00728 
00729 }                               <span class="comment">/* end setup_engineID() */</span>
00730 
00731 <span class="keywordtype">int</span>
00732 free_engineID(<span class="keywordtype">int</span> majorid, <span class="keywordtype">int</span> minorid, <span class=
"keywordtype">void</span> *serverarg,
00733               <span class="keywordtype">void</span> *clientarg)
00734 {
00735     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(engineID);
00736     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(engineIDNic);
00737     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(oldEngineID);
00738     <span class="keywordflow">return</span> 0;
00739 }
00740 
00741 <span class="keywordtype">int</span>
00742 free_enginetime_on_shutdown(<span class="keywordtype">int</span> majorid, <span class=
"keywordtype">int</span> minorid, <span class="keywordtype">void</span> *serverarg,
00743                             <span class="keywordtype">void</span> *clientarg)
00744 {
00745     DEBUGMSGTL((<span class="stringliteral">"snmpv3"</span>, <span class=
"stringliteral">"free enginetime callback called\n"</span>));
00746     <span class="keywordflow">if</span> (engineID != NULL)
00747         free_enginetime(engineID, engineIDLength);
00748     <span class="keywordflow">return</span> 0;
00749 }
00750 
00751 <span class="keywordtype">void</span>
00752 usm_parse_create_usmUser(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
00753 {
00754     <span class="keywordtype">char</span>           *cp;
00755     <span class="keywordtype">char</span>            buf[SNMP_MAXBUF_MEDIUM];
00756     <span class="keyword">struct </span>usmUser *newuser;
00757     u_char          userKey[SNMP_MAXBUF_SMALL], *tmpp;
00758     size_t          userKeyLen = SNMP_MAXBUF_SMALL;
00759     size_t          privKeyLen = 0;
00760     size_t          ret;
00761     <span class="keywordtype">int</span>             testcase;
00762 
00763     newuser = usm_create_user();
00764 
00765     <span class="comment">/*</span>
00766 <span class="comment">     * READ: Security Name </span>
00767 <span class="comment">     */</span>
00768     cp = copy_nword(line, buf, <span class="keyword">sizeof</span>(buf));
00769 
00770     <span class="comment">/*</span>
00771 <span class="comment">     * might be a -e ENGINEID argument </span>
00772 <span class="comment">     */</span>
00773     <span class="keywordflow">if</span> (strcmp(buf, <span class="stringliteral">"-e"</span>) == 0) {
00774         size_t          ebuf_len = 32, eout_len = 0;
00775         u_char         *ebuf = (u_char *) malloc(ebuf_len);
00776 
00777         <span class="keywordflow">if</span> (ebuf == NULL) {
00778             config_perror(<span class="stringliteral">"malloc failure processing -e flag"</span>);
00779             usm_free_user(newuser);
00780             <span class="keywordflow">return</span>;
00781         }
00782 
00783         <span class="comment">/*</span>
00784 <span class="comment">         * Get the specified engineid from the line.  </span>
00785 <span class="comment">         */</span>
00786         cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
00787         <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;ebuf, &amp;ebuf_len, &amp;eout_len, 1, buf)) {
00788             config_perror(<span class="stringliteral">"invalid EngineID argument to -e"</span>);
00789             usm_free_user(newuser);
00790             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ebuf);
00791             <span class="keywordflow">return</span>;
00792         }
00793 
00794         newuser-&gt;engineID = ebuf;
00795         newuser-&gt;engineIDLen = eout_len;
00796         cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
00797     } <span class="keywordflow">else</span> {
00798         newuser-&gt;engineID = snmpv3_generate_engineID(&amp;ret);
00799         <span class="keywordflow">if</span> (ret == 0) {
00800             usm_free_user(newuser);
00801             <span class="keywordflow">return</span>;
00802         }
00803         newuser-&gt;engineIDLen = ret;
00804     }
00805 
00806     newuser-&gt;secName = strdup(buf);
00807     newuser-&gt;name = strdup(buf);
00808 
00809     <span class="keywordflow">if</span> (!cp)
00810         <span class="keywordflow">goto</span> add;               <span class=
"comment">/* no authentication or privacy type */</span>
00811 
00812     <span class="comment">/*</span>
00813 <span class="comment">     * READ: Authentication Type </span>
00814 <span class="comment">     */</span>
00815 <span class="preprocessor">#ifndef DISABLE_MD5</span>
00816     <span class="keywordflow">if</span> (strncmp(cp, <span class="stringliteral">"MD5"</span>, 3) == 0) {
00817         memcpy(newuser-&gt;authProtocol, usmHMACMD5AuthProtocol,
00818                <span class="keyword">sizeof</span>(usmHMACMD5AuthProtocol));
00819     } <span class="keywordflow">else</span>
00820 <span class="preprocessor">#endif</span>
00821         <span class="keywordflow">if</span> (strncmp(cp, <span class="stringliteral">"SHA"</span>, 3) == 0) {
00822         memcpy(newuser-&gt;authProtocol, usmHMACSHA1AuthProtocol,
00823                <span class="keyword">sizeof</span>(usmHMACSHA1AuthProtocol));
00824     } <span class="keywordflow">else</span> {
00825         config_perror(<span class="stringliteral">"Unknown authentication protocol"</span>);
00826         usm_free_user(newuser);
00827         <span class="keywordflow">return</span>;
00828     }
00829 
00830     cp = skip_token(cp);
00831 
00832     <span class="comment">/*</span>
00833 <span class="comment">     * READ: Authentication Pass Phrase or key</span>
00834 <span class="comment">     */</span>
00835     <span class="keywordflow">if</span> (!cp) {
00836         config_perror(<span class="stringliteral">"no authentication pass phrase"</span>);
00837         usm_free_user(newuser);
00838         <span class="keywordflow">return</span>;
00839     }
00840     cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
00841     <span class="keywordflow">if</span> (strcmp(buf,<span class="stringliteral">"-m"</span>) == 0) {
00842         <span class="comment">/* a master key is specified */</span>
00843         cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
00844         ret = <span class="keyword">sizeof</span>(userKey);
00845         tmpp = userKey;
00846         userKeyLen = 0;
00847         <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;tmpp, &amp;ret, &amp;userKeyLen, 0, buf)) {
00848             config_perror(<span class="stringliteral">"invalid key value argument to -m"</span>);
00849             usm_free_user(newuser);
00850             <span class="keywordflow">return</span>;
00851         }
00852     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(buf,<span class=
"stringliteral">"-l"</span>) != 0) {
00853         <span class="comment">/* a password is specified */</span>
00854         userKeyLen = <span class="keyword">sizeof</span>(userKey);
00855         ret = generate_Ku(newuser-&gt;authProtocol, newuser-&gt;authProtocolLen,
00856                           (u_char *) buf, strlen(buf), userKey, &amp;userKeyLen);
00857         <span class="keywordflow">if</span> (ret != SNMPERR_SUCCESS) {
00858             config_perror(<span class="stringliteral">"could not generate the authentication key from the "</span>
00859                           <span class="stringliteral">"supplied pass phrase."</span>);
00860             usm_free_user(newuser);
00861             <span class="keywordflow">return</span>;
00862         }
00863     }        
00864         
00865     <span class="comment">/*</span>
00866 <span class="comment">     * And turn it into a localized key </span>
00867 <span class="comment">     */</span>
00868     ret =
00869         sc_get_properlength(newuser-&gt;authProtocol,
00870                             newuser-&gt;authProtocolLen);
00871     <span class="keywordflow">if</span> (ret &lt;= 0) {
00872         config_perror(<span class="stringliteral">"Could not get proper authentication protocol key length"</span>);
00873         <span class="keywordflow">return</span>;
00874     }
00875     newuser-&gt;authKey = (u_char *) malloc(ret);
00876 
00877     <span class="keywordflow">if</span> (strcmp(buf,<span class="stringliteral">"-l"</span>) == 0) {
00878         <span class="comment">/* a local key is directly specified */</span>
00879         cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
00880         newuser-&gt;authKeyLen = 0;
00881         <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;newuser-&gt;authKey, &amp;ret,
00882                                 &amp;newuser-&gt;authKeyLen, 0, buf)) {
00883             config_perror(<span class="stringliteral">"invalid key value argument to -l"</span>);
00884             usm_free_user(newuser);
00885             <span class="keywordflow">return</span>;
00886         }
00887         <span class="keywordflow">if</span> (ret != newuser-&gt;authKeyLen) {
00888             config_perror(<span class="stringliteral">"improper key length to -l"</span>);
00889             usm_free_user(newuser);
00890             <span class="keywordflow">return</span>;
00891         }
00892     } <span class="keywordflow">else</span> {
00893         newuser-&gt;authKeyLen = ret;
00894         ret = generate_kul(newuser-&gt;authProtocol, newuser-&gt;authProtocolLen,
00895                            newuser-&gt;engineID, newuser-&gt;engineIDLen,
00896                            userKey, userKeyLen,
00897                            newuser-&gt;authKey, &amp;newuser-&gt;authKeyLen);
00898         <span class="keywordflow">if</span> (ret != SNMPERR_SUCCESS) {
00899             config_perror(<span class="stringliteral">"could not generate localized authentication key "</span>
00900                           <span class="stringliteral">"(Kul) from the master key (Ku)."</span>);
00901             usm_free_user(newuser);
00902             <span class="keywordflow">return</span>;
00903         }
00904     }
00905 
00906     <span class="keywordflow">if</span> (!cp)
00907         <span class="keywordflow">goto</span> add;               <span class=
"comment">/* no privacy type (which is legal) */</span>
00908 
00909     <span class="comment">/*</span>
00910 <span class="comment">     * READ: Privacy Type </span>
00911 <span class="comment">     */</span>
00912     testcase = 0;
00913 <span class="preprocessor">#ifndef DISABLE_DES</span>
00914     <span class="keywordflow">if</span> (strncmp(cp, <span class="stringliteral">"DES"</span>, 3) == 0) {
00915         memcpy(newuser-&gt;privProtocol, usmDESPrivProtocol,
00916                <span class="keyword">sizeof</span>(usmDESPrivProtocol));
00917         testcase = 1;
00918         <span class="comment">/* DES uses a 128 bit key, 64 bits of which is a salt */</span>
00919         privKeyLen = 16;
00920     }
00921 <span class="preprocessor">#endif</span>
00922 <span class="preprocessor">#ifdef HAVE_AES</span>
00923     <span class="keywordflow">if</span> (strncmp(cp, <span class="stringliteral">"AES128"</span>, 6) == 0 ||
00924                strncmp(cp, <span class="stringliteral">"AES"</span>, 3) == 0) {
00925         memcpy(newuser-&gt;privProtocol, usmAESPrivProtocol,
00926                <span class="keyword">sizeof</span>(usmAESPrivProtocol));
00927         testcase = 1;
00928         privKeyLen = 16;
00929     }
00930 <span class="preprocessor">#endif</span>
00931     <span class="keywordflow">if</span> (testcase == 0) {
00932         config_perror(<span class="stringliteral">"Unknown privacy protocol"</span>);
00933         usm_free_user(newuser);
00934         <span class="keywordflow">return</span>;
00935     }
00936 
00937     cp = skip_token(cp);
00938     <span class="comment">/*</span>
00939 <span class="comment">     * READ: Encryption Pass Phrase or key</span>
00940 <span class="comment">     */</span>
00941     <span class="keywordflow">if</span> (!cp) {
00942         <span class="comment">/*</span>
00943 <span class="comment">         * assume the same as the authentication key </span>
00944 <span class="comment">         */</span>
00945         <a class="code" href=
"group__util.html#ga5">memdup</a>(&amp;newuser-&gt;privKey, newuser-&gt;authKey, newuser-&gt;authKeyLen);
00946         newuser-&gt;privKeyLen = newuser-&gt;authKeyLen;
00947     } <span class="keywordflow">else</span> {
00948         cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
00949         
00950         <span class="keywordflow">if</span> (strcmp(buf,<span class="stringliteral">"-m"</span>) == 0) {
00951             <span class="comment">/* a master key is specified */</span>
00952             cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
00953             ret = <span class="keyword">sizeof</span>(userKey);
00954             tmpp = userKey;
00955             userKeyLen = 0;
00956             <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;tmpp, &amp;ret, &amp;userKeyLen, 0, buf)) {
00957                 config_perror(<span class="stringliteral">"invalid key value argument to -m"</span>);
00958                 usm_free_user(newuser);
00959                 <span class="keywordflow">return</span>;
00960             }
00961         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(buf,<span class=
"stringliteral">"-l"</span>) != 0) {
00962             <span class="comment">/* a password is specified */</span>
00963             userKeyLen = <span class="keyword">sizeof</span>(userKey);
00964             ret = generate_Ku(newuser-&gt;authProtocol, newuser-&gt;authProtocolLen,
00965                               (u_char *) buf, strlen(buf), userKey, &amp;userKeyLen);
00966             <span class="keywordflow">if</span> (ret != SNMPERR_SUCCESS) {
00967                 config_perror(<span class="stringliteral">"could not generate the privacy key from the "</span>
00968                               <span class="stringliteral">"supplied pass phrase."</span>);
00969                 usm_free_user(newuser);
00970                 <span class="keywordflow">return</span>;
00971             }
00972         }        
00973         
00974         <span class="comment">/*</span>
00975 <span class="comment">         * And turn it into a localized key </span>
00976 <span class="comment">         */</span>
00977         ret =
00978             sc_get_properlength(newuser-&gt;authProtocol,
00979                                 newuser-&gt;authProtocolLen);
00980         <span class="keywordflow">if</span> (ret &lt; 0) {
00981             config_perror(<span class="stringliteral">"could not get proper key length to use for the "</span>
00982                           <span class="stringliteral">"privacy algorithm."</span>);
00983             usm_free_user(newuser);
00984             <span class="keywordflow">return</span>;
00985         }
00986         newuser-&gt;privKey = (u_char *) malloc(ret);
00987 
00988         <span class="keywordflow">if</span> (strcmp(buf,<span class="stringliteral">"-l"</span>) == 0) {
00989             <span class="comment">/* a local key is directly specified */</span>
00990             cp = copy_nword(cp, buf, <span class="keyword">sizeof</span>(buf));
00991             newuser-&gt;privKeyLen = 0;
00992             <span class="keywordflow">if</span> (!<a class="code" href=
"group__util.html#ga8">snmp_hex_to_binary</a>(&amp;newuser-&gt;privKey, &amp;ret,
00993                                     &amp;newuser-&gt;privKeyLen, 0, buf)) {
00994                 config_perror(<span class="stringliteral">"invalid key value argument to -l"</span>);
00995                 usm_free_user(newuser);
00996                 <span class="keywordflow">return</span>;
00997             }
00998         } <span class="keywordflow">else</span> {
00999             newuser-&gt;privKeyLen = ret;
01000             ret = generate_kul(newuser-&gt;authProtocol, newuser-&gt;authProtocolLen,
01001                                newuser-&gt;engineID, newuser-&gt;engineIDLen,
01002                                userKey, userKeyLen,
01003                                newuser-&gt;privKey, &amp;newuser-&gt;privKeyLen);
01004             <span class="keywordflow">if</span> (ret != SNMPERR_SUCCESS) {
01005                 config_perror(<span class="stringliteral">"could not generate localized privacy key "</span>
01006                               <span class="stringliteral">"(Kul) from the master key (Ku)."</span>);
01007                 usm_free_user(newuser);
01008                 <span class="keywordflow">return</span>;
01009             }
01010         }
01011     }
01012 
01013     <span class="keywordflow">if</span> ((newuser-&gt;privKeyLen &gt;= privKeyLen) || (privKeyLen == 0)){
01014       newuser-&gt;privKeyLen = privKeyLen;
01015     }
01016     <span class="keywordflow">else</span> {
01017       <span class="comment">/* The privKey length is smaller than required by privProtocol */</span>
01018       usm_free_user(newuser);
01019       <span class="keywordflow">return</span>;
01020     }
01021 
01022   add:
01023     usm_add_user(newuser);
01024     DEBUGMSGTL((<span class="stringliteral">"usmUser"</span>, <span class=
"stringliteral">"created a new user %s at "</span>, newuser-&gt;secName));
01025     DEBUGMSGHEX((<span class="stringliteral">"usmUser"</span>, newuser-&gt;engineID, newuser-&gt;engineIDLen));
01026     DEBUGMSG((<span class="stringliteral">"usmUser"</span>, <span class="stringliteral">"\n"</span>));
01027 }
01028 
01029 <span class="comment">/*******************************************************************-o-******</span>
01030 <span class="comment"> * engineBoots_conf</span>
01031 <span class="comment"> *</span>
01032 <span class="comment"> * Parameters:</span>
01033 <span class="comment"> *      *word</span>
01034 <span class="comment"> *      *cptr</span>
01035 <span class="comment"> *</span>
01036 <span class="comment"> * Line syntax:</span>
01037 <span class="comment"> *      engineBoots &lt;num_boots&gt;</span>
01038 <span class="comment"> */</span>
01039 <span class="keywordtype">void</span>
01040 engineBoots_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
01041 {
01042     engineBoots = atoi(cptr) + 1;
01043     DEBUGMSGTL((<span class="stringliteral">"snmpv3"</span>, <span class=
"stringliteral">"engineBoots: %d\n"</span>, engineBoots));
01044 }
01045 
01046 <span class="comment">/*******************************************************************-o-******</span>
01047 <span class="comment"> * engineIDType_conf</span>
01048 <span class="comment"> *</span>
01049 <span class="comment"> * Parameters:</span>
01050 <span class="comment"> *      *word</span>
01051 <span class="comment"> *      *cptr</span>
01052 <span class="comment"> *</span>
01053 <span class="comment"> * Line syntax:</span>
01054 <span class="comment"> *      engineIDType &lt;1 or 3&gt;</span>
01055 <span class="comment"> *              1 is default for IPv4 engine ID type.  Will automatically</span>
01056 <span class="comment"> *                  chose between IPv4 &amp; IPv6 if either 1 or 2 is specified.</span>
01057 <span class="comment"> *              2 is for IPv6.</span>
01058 <span class="comment"> *              3 is hardware (MAC) address, currently supported under Linux</span>
01059 <span class="comment"> */</span>
01060 <span class="keywordtype">void</span>
01061 engineIDType_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
01062 {
01063     engineIDType = atoi(cptr);
01064     <span class="comment">/*</span>
01065 <span class="comment">     * verify valid type selected </span>
01066 <span class="comment">     */</span>
01067     <span class="keywordflow">switch</span> (engineIDType) {
01068     <span class="keywordflow">case</span> ENGINEID_TYPE_IPV4:   <span class="comment">/* IPv4 */</span>
01069     <span class="keywordflow">case</span> ENGINEID_TYPE_IPV6:   <span class="comment">/* IPv6 */</span>
01070         <span class="comment">/*</span>
01071 <span class="comment">         * IPV? is always good </span>
01072 <span class="comment">         */</span>
01073         <span class="keywordflow">break</span>;
01074 <span class="preprocessor">#if defined(IFHWADDRLEN) &amp;&amp; defined(SIOCGIFHWADDR)</span>
01075     <span class="keywordflow">case</span> ENGINEID_TYPE_MACADDR:        <span class="comment">/* MAC address */</span>
01076         <span class="keywordflow">break</span>;
01077 <span class="preprocessor">#endif</span>
01078     <span class="keywordflow">default</span>:
01079         <span class="comment">/*</span>
01080 <span class="comment">         * unsupported one chosen </span>
01081 <span class="comment">         */</span>
01082         config_perror(<span class="stringliteral">"Unsupported enginedIDType, forcing IPv4"</span>);
01083         engineIDType = ENGINEID_TYPE_IPV4;
01084     }
01085     DEBUGMSGTL((<span class="stringliteral">"snmpv3"</span>, <span class=
"stringliteral">"engineIDType: %d\n"</span>, engineIDType));
01086 }
01087 
01088 <span class="comment">/*******************************************************************-o-******</span>
01089 <span class="comment"> * engineIDNic_conf</span>
01090 <span class="comment"> *</span>
01091 <span class="comment"> * Parameters:</span>
01092 <span class="comment"> *      *word</span>
01093 <span class="comment"> *      *cptr</span>
01094 <span class="comment"> *</span>
01095 <span class="comment"> * Line syntax:</span>
01096 <span class="comment"> *      engineIDNic &lt;string&gt;</span>
01097 <span class="comment"> *              eth0 is default</span>
01098 <span class="comment"> */</span>
01099 <span class="keywordtype">void</span>
01100 engineIDNic_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
01101 {
01102     <span class="comment">/*</span>
01103 <span class="comment">     * Make sure they haven't already specified the engineID via the</span>
01104 <span class="comment">     * * configuration file </span>
01105 <span class="comment">     */</span>
01106     <span class="keywordflow">if</span> (0 == engineIDIsSet)
01107         <span class="comment">/*</span>
01108 <span class="comment">         * engineID has NOT been set via configuration file </span>
01109 <span class="comment">         */</span>
01110     {
01111         <span class="comment">/*</span>
01112 <span class="comment">         * See if already set if so erase &amp; release it </span>
01113 <span class="comment">         */</span>
01114         <span class="keywordflow">if</span> (NULL != engineIDNic) {
01115             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(engineIDNic);
01116         }
01117         engineIDNic = (u_char *) malloc(strlen(cptr) + 1);
01118         <span class="keywordflow">if</span> (NULL != engineIDNic) {
01119             strcpy((<span class="keywordtype">char</span> *) engineIDNic, cptr);
01120             DEBUGMSGTL((<span class="stringliteral">"snmpv3"</span>, <span class=
"stringliteral">"Initializing engineIDNic: %s\n"</span>,
01121                         engineIDNic));
01122         } <span class="keywordflow">else</span> {
01123             DEBUGMSGTL((<span class="stringliteral">"snmpv3"</span>,
01124                         <span class="stringliteral">"Error allocating memory for engineIDNic!\n"</span>));
01125         }
01126     } <span class="keywordflow">else</span> {
01127         DEBUGMSGTL((<span class="stringliteral">"snmpv3"</span>,
01128                     <span class="stringliteral">"NOT setting engineIDNic, engineID already set\n"</span>));
01129     }
01130 }
01131 
01132 <span class="comment">/*******************************************************************-o-******</span>
01133 <span class="comment"> * engineID_conf</span>
01134 <span class="comment"> *</span>
01135 <span class="comment"> * Parameters:</span>
01136 <span class="comment"> *      *word</span>
01137 <span class="comment"> *      *cptr</span>
01138 <span class="comment"> *</span>
01139 <span class="comment"> * This function reads a string from the configuration file and uses that</span>
01140 <span class="comment"> * string to initialize the engineID.  It's assumed to be human readable.</span>
01141 <span class="comment"> */</span>
01142 <span class="keywordtype">void</span>
01143 engineID_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
01144 {
01145     setup_engineID(NULL, cptr);
01146     DEBUGMSGTL((<span class="stringliteral">"snmpv3"</span>, <span class=
"stringliteral">"initialized engineID with: %s\n"</span>, cptr));
01147 }
01148 
01149 <span class="keywordtype">void</span>
01150 version_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
01151 {
01152     <span class="keywordtype">int</span> valid = 0;
01153 <span class="preprocessor">#ifndef DISABLE_SNMPV1</span>
01154     <span class="keywordflow">if</span> ((strcmp(cptr,  <span class="stringliteral">"1"</span>) == 0) ||
01155         (strcmp(cptr, <span class="stringliteral">"v1"</span>) == 0)) {
01156         netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SNMPVERSION, 
01157                            NETSNMP_DS_SNMP_VERSION_1);       <span class="comment">/* bogus value */</span>
01158         valid = 1;
01159     }
01160 <span class="preprocessor">#endif</span>
01161 <span class="preprocessor">#ifndef DISABLE_SNMPV2C</span>
01162     <span class="keywordflow">if</span> ((strcasecmp(cptr,  <span class="stringliteral">"2c"</span>) == 0) ||
01163                (strcasecmp(cptr, <span class="stringliteral">"v2c"</span>) == 0)) {
01164         netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SNMPVERSION, 
01165                            NETSNMP_DS_SNMP_VERSION_2c);
01166         valid = 1;
01167     }
01168 <span class="preprocessor">#endif</span>
01169     <span class="keywordflow">if</span> ((strcasecmp(cptr,  <span class="stringliteral">"3"</span> ) == 0) ||
01170                (strcasecmp(cptr, <span class="stringliteral">"v3"</span> ) == 0)) {
01171         netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SNMPVERSION, 
01172                            NETSNMP_DS_SNMP_VERSION_3);
01173         valid = 1;
01174     }
01175     <span class="keywordflow">if</span> (!valid) {
01176         config_perror(<span class="stringliteral">"Unknown version specification"</span>);
01177         <span class="keywordflow">return</span>;
01178     }
01179     DEBUGMSGTL((<span class="stringliteral">"snmpv3"</span>, <span class=
"stringliteral">"set default version to %d\n"</span>,
01180                 netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
01181                                    NETSNMP_DS_LIB_SNMPVERSION)));
01182 }
01183 
01184 <span class="comment">/*</span>
01185 <span class="comment"> * engineID_old_conf(const char *, char *):</span>
01186 <span class="comment"> * </span>
01187 <span class="comment"> * Reads a octet string encoded engineID into the oldEngineID and</span>
01188 <span class="comment"> * oldEngineIDLen pointers.</span>
01189 <span class="comment"> */</span>
01190 <span class="keywordtype">void</span>
01191 oldengineID_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *word, <span class=
"keywordtype">char</span> *cptr)
01192 {
01193     read_config_read_octet_string(cptr, &amp;oldEngineID, &amp;oldEngineIDLength);
01194 }
01195 
01196 <span class="comment">/*</span>
01197 <span class="comment"> * merely call </span>
01198 <span class="comment"> */</span>
01199 <span class="keywordtype">void</span>
01200 get_enginetime_alarm(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> regnum, <span class=
"keywordtype">void</span> *clientargs)
01201 {
01202     <span class="comment">/* we do this every so (rarely) often just to make sure we watch</span>
01203 <span class="comment">       wrapping of the times() output */</span>
01204     snmpv3_local_snmpEngineTime();
01205 }
01206 
01207 <span class="comment">/*******************************************************************-o-******</span>
01208 <span class="comment"> * init_snmpv3</span>
01209 <span class="comment"> *</span>
01210 <span class="comment"> * Parameters:</span>
01211 <span class="comment"> *      *type   Label for the config file "type" used by calling entity.</span>
01212 <span class="comment"> *      </span>
01213 <span class="comment"> * Set time and engineID.</span>
01214 <span class="comment"> * Set parsing functions for config file tokens.</span>
01215 <span class="comment"> * Initialize SNMP Crypto API (SCAPI).</span>
01216 <span class="comment"> */</span>
01217 <span class="keywordtype">void</span>
01218 init_snmpv3(<span class="keyword">const</span> <span class="keywordtype">char</span> *type)
01219 {
01220 <span class="preprocessor">#if SNMP_USE_TIMES</span>
01221   <span class="keyword">struct </span>tms dummy;
01222 
01223   <span class="comment">/* fixme: -1 is fault code... */</span>
01224   snmpv3startClock = times(&amp;dummy);
01225 
01226   <span class="comment">/* remember how many ticks per second there are, since times() returns this */</span>
01227 
01228   clockticks = sysconf(_SC_CLK_TCK);
01229 
01230 <span class="preprocessor">#endif </span><span class="comment">/* SNMP_USE_TIMES */</span>
01231 
01232     gettimeofday(&amp;snmpv3starttime, NULL);
01233 
01234     <span class="keywordflow">if</span> (!type)
01235         type = <span class="stringliteral">"__snmpapp__"</span>;
01236 
01237     <span class="comment">/*</span>
01238 <span class="comment">     * we need to be called back later </span>
01239 <span class="comment">     */</span>
01240     <a class="code" href="group__callback.html#ga8">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
01241                            SNMP_CALLBACK_POST_READ_CONFIG,
01242                            init_snmpv3_post_config, NULL);
01243 
01244     <a class="code" href="group__callback.html#ga8">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
01245                            SNMP_CALLBACK_POST_PREMIB_READ_CONFIG,
01246                            init_snmpv3_post_premib_config, NULL);
01247     <span class="comment">/*</span>
01248 <span class="comment">     * we need to be called back later </span>
01249 <span class="comment">     */</span>
01250     <a class="code" href=
"group__callback.html#ga8">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
01251                            snmpv3_store, (<span class="keywordtype">void</span> *) strdup(type));
01252 
01253     <span class="comment">/*</span>
01254 <span class="comment">     * Free stuff at shutdown time</span>
01255 <span class="comment">     */</span>
01256     <a class="code" href="group__callback.html#ga8">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
01257                            SNMP_CALLBACK_SHUTDOWN,
01258                            free_enginetime_on_shutdown, NULL);
01259 
01260     <span class="comment">/*</span>
01261 <span class="comment">     * initialize submodules </span>
01262 <span class="comment">     */</span>
01263     <span class="comment">/*</span>
01264 <span class="comment">     * NOTE: this must be after the callbacks are registered above,</span>
01265 <span class="comment">     * since they need to be called before the USM callbacks. </span>
01266 <span class="comment">     */</span>
01267     init_secmod();
01268 
01269     <span class="comment">/*</span>
01270 <span class="comment">     * register all our configuration handlers (ack, there's a lot) </span>
01271 <span class="comment">     */</span>
01272 
01273     <span class="comment">/*</span>
01274 <span class="comment">     * handle engineID setup before everything else which may depend on it </span>
01275 <span class="comment">     */</span>
01276     register_prenetsnmp_mib_handler(type, <span class="stringliteral">"engineID"</span>, engineID_conf, NULL,
01277                                     <span class="stringliteral">"string"</span>);
01278     register_prenetsnmp_mib_handler(type, <span class="stringliteral">"oldEngineID"</span>, oldengineID_conf,
01279                                     NULL, NULL);
01280     register_prenetsnmp_mib_handler(type, <span class="stringliteral">"engineIDType"</span>,
01281                                     engineIDType_conf, NULL, <span class="stringliteral">"num"</span>);
01282     register_prenetsnmp_mib_handler(type, <span class="stringliteral">"engineIDNic"</span>, engineIDNic_conf,
01283                                     NULL, <span class="stringliteral">"string"</span>);
01284     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(type, <span class=
"stringliteral">"engineBoots"</span>, engineBoots_conf, NULL,
01285                             NULL);
01286 
01287     <span class="comment">/*</span>
01288 <span class="comment">     * default store config entries </span>
01289 <span class="comment">     */</span>
01290     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"defSecurityName"</span>,
01291                                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_SECNAME);
01292     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"defContext"</span>, 
01293                                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_CONTEXT);
01294     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"defPassphrase"</span>,
01295                                NETSNMP_DS_LIBRARY_ID,
01296                                NETSNMP_DS_LIB_PASSPHRASE);
01297     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"defAuthPassphrase"</span>,
01298                                NETSNMP_DS_LIBRARY_ID,
01299                                NETSNMP_DS_LIB_AUTHPASSPHRASE);
01300     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"defPrivPassphrase"</span>,
01301                                NETSNMP_DS_LIBRARY_ID,
01302                                NETSNMP_DS_LIB_PRIVPASSPHRASE);
01303     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"defAuthMasterKey"</span>,
01304                                NETSNMP_DS_LIBRARY_ID,
01305                                NETSNMP_DS_LIB_AUTHMASTERKEY);
01306     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"defPrivMasterKey"</span>,
01307                                NETSNMP_DS_LIBRARY_ID,
01308                                NETSNMP_DS_LIB_PRIVMASTERKEY);
01309     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"defAuthLocalizedKey"</span>,
01310                                NETSNMP_DS_LIBRARY_ID,
01311                                NETSNMP_DS_LIB_AUTHLOCALIZEDKEY);
01312     netsnmp_ds_register_config(ASN_OCTET_STR, <span class="stringliteral">"snmp"</span>, <span class=
"stringliteral">"defPrivLocalizedKey"</span>,
01313                                NETSNMP_DS_LIBRARY_ID,
01314                                NETSNMP_DS_LIB_PRIVLOCALIZEDKEY);
01315     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(<span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"defVersion"</span>, version_conf, NULL,
01316                             <span class="stringliteral">"1|2c|3"</span>);
01317 
01318     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(<span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"defAuthType"</span>, snmpv3_authtype_conf,
01319                             NULL, <span class="stringliteral">"MD5|SHA"</span>);
01320     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(<span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"defPrivType"</span>, snmpv3_privtype_conf,
01321                             NULL,
01322 #ifdef HAVE_AES
01323                             <span class="stringliteral">"DES|AES"</span>);
01324 <span class="preprocessor">#else</span>
01325                             <span class="stringliteral">"DES (AES support not available)"</span>);
01326 <span class="preprocessor">#endif</span>
01327     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(<span class=
"stringliteral">"snmp"</span>, <span class="stringliteral">"defSecurityLevel"</span>,
01328                             snmpv3_secLevel_conf, NULL,
01329                             <span class="stringliteral">"noAuthNoPriv|authNoPriv|authPriv"</span>);
01330     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(type, <span class=
"stringliteral">"userSetAuthPass"</span>, usm_set_password,
01331                             NULL, NULL);
01332     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(type, <span class=
"stringliteral">"userSetPrivPass"</span>, usm_set_password,
01333                             NULL, NULL);
01334     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(type, <span class=
"stringliteral">"userSetAuthKey"</span>, usm_set_password, NULL,
01335                             NULL);
01336     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(type, <span class=
"stringliteral">"userSetPrivKey"</span>, usm_set_password, NULL,
01337                             NULL);
01338     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(type, <span class=
"stringliteral">"userSetAuthLocalKey"</span>, usm_set_password,
01339                             NULL, NULL);
01340     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(type, <span class=
"stringliteral">"userSetPrivLocalKey"</span>, usm_set_password,
01341                             NULL, NULL);
01342 }
01343 
01344 <span class="comment">/*</span>
01345 <span class="comment"> * initializations for SNMPv3 to be called after the configuration files</span>
01346 <span class="comment"> * have been read.</span>
01347 <span class="comment"> */</span>
01348 
01349 <span class="keywordtype">int</span>
01350 init_snmpv3_post_config(<span class="keywordtype">int</span> majorid, <span class=
"keywordtype">int</span> minorid, <span class="keywordtype">void</span> *serverarg,
01351                         <span class="keywordtype">void</span> *clientarg)
01352 {
01353 
01354     size_t          engineIDLen;
01355     u_char         *c_engineID;
01356 
01357     c_engineID = snmpv3_generate_engineID(&amp;engineIDLen);
01358 
01359     <span class="keywordflow">if</span> (engineIDLen == 0) {
01360         <span class="comment">/*</span>
01361 <span class="comment">         * Somethine went wrong - help! </span>
01362 <span class="comment">         */</span>
01363         <span class="keywordflow">return</span> SNMPERR_GENERR;
01364     }
01365 
01366     <span class="comment">/*</span>
01367 <span class="comment">     * if our engineID has changed at all, the boots record must be set to 1 </span>
01368 <span class="comment">     */</span>
01369     <span class="keywordflow">if</span> (engineIDLen != (int) oldEngineIDLength ||
01370         oldEngineID == NULL || c_engineID == NULL ||
01371         memcmp(oldEngineID, c_engineID, engineIDLen) != 0) {
01372         engineBoots = 1;
01373     }
01374 
01375     <span class="comment">/*</span>
01376 <span class="comment">     * set our local engineTime in the LCD timing cache </span>
01377 <span class="comment">     */</span>
01378     set_enginetime(c_engineID, engineIDLen,
01379                    snmpv3_local_snmpEngineBoots(),
01380                    snmpv3_local_snmpEngineTime(), TRUE);
01381 
01382     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(c_engineID);
01383     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
01384 }
01385 
01386 <span class="keywordtype">int</span>
01387 init_snmpv3_post_premib_config(<span class="keywordtype">int</span> majorid, <span class=
"keywordtype">int</span> minorid, <span class="keywordtype">void</span> *serverarg,
01388                                <span class="keywordtype">void</span> *clientarg)
01389 {
01390     <span class="keywordflow">if</span> (!engineIDIsSet)
01391         setup_engineID(NULL, NULL);
01392 
01393     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
01394 }
01395 
01396 <span class="comment">/*******************************************************************-o-******</span>
01397 <span class="comment"> * store_snmpv3</span>
01398 <span class="comment"> *</span>
01399 <span class="comment"> * Parameters:</span>
01400 <span class="comment"> *      *type</span>
01401 <span class="comment"> */</span>
01402 <span class="keywordtype">int</span>
01403 snmpv3_store(<span class="keywordtype">int</span> majorID, <span class="keywordtype">int</span> minorID, <span class=
"keywordtype">void</span> *serverarg, <span class="keywordtype">void</span> *clientarg)
01404 {
01405     <span class="keywordtype">char</span>            line[SNMP_MAXBUF_SMALL];
01406     u_char          c_engineID[SNMP_MAXBUF_SMALL];
01407     <span class="keywordtype">int</span>             engineIDLen;
01408     <span class="keyword">const</span> <span class="keywordtype">char</span>     *type = (<span class=
"keyword">const</span> <span class="keywordtype">char</span> *) clientarg;
01409 
01410     <span class="keywordflow">if</span> (type == NULL)           <span class=
"comment">/* should never happen, since the arg is ours */</span>
01411         type = <span class="stringliteral">"unknown"</span>;
01412 
01413     sprintf(line, <span class="stringliteral">"engineBoots %ld"</span>, engineBoots);
01414     <a class="code" href="group__read__config.html#ga40">read_config_store</a>(type, line);
01415 
01416     engineIDLen = snmpv3_get_engineID(c_engineID, SNMP_MAXBUF_SMALL);
01417 
01418     <span class="keywordflow">if</span> (engineIDLen) {
01419         <span class="comment">/*</span>
01420 <span class="comment">         * store the engineID used for this run </span>
01421 <span class="comment">         */</span>
01422         sprintf(line, <span class="stringliteral">"oldEngineID "</span>);
01423         read_config_save_octet_string(line + strlen(line), c_engineID,
01424                                       engineIDLen);
01425         <a class="code" href="group__read__config.html#ga40">read_config_store</a>(type, line);
01426     }
01427     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
01428 }                               <span class="comment">/* snmpv3_store() */</span>
01429 
01430 u_long
01431 snmpv3_local_snmpEngineBoots(<span class="keywordtype">void</span>)
01432 {
01433     <span class="keywordflow">return</span> engineBoots;
01434 }
01435 
01436 
01437 <span class="comment">/*******************************************************************-o-******</span>
01438 <span class="comment"> * snmpv3_get_engineID</span>
01439 <span class="comment"> *</span>
01440 <span class="comment"> * Parameters:</span>
01441 <span class="comment"> *      *buf</span>
01442 <span class="comment"> *       buflen</span>
01443 <span class="comment"> *      </span>
01444 <span class="comment"> * Returns:</span>
01445 <span class="comment"> *      Length of engineID      On Success</span>
01446 <span class="comment"> *      SNMPERR_GENERR          Otherwise.</span>
01447 <span class="comment"> *</span>
01448 <span class="comment"> *</span>
01449 <span class="comment"> * Store engineID in buf; return the length.</span>
01450 <span class="comment"> *</span>
01451 <span class="comment"> */</span>
01452 size_t
01453 snmpv3_get_engineID(u_char * buf, size_t buflen)
01454 {
01455     <span class="comment">/*</span>
01456 <span class="comment">     * Sanity check.</span>
01457 <span class="comment">     */</span>
01458     <span class="keywordflow">if</span> (!buf || (buflen &lt; engineIDLength)) {
01459         <span class="keywordflow">return</span> 0;
01460     }
01461 
01462     memcpy(buf, engineID, engineIDLength);
01463     <span class="keywordflow">return</span> engineIDLength;
01464 
01465 }                               <span class="comment">/* end snmpv3_get_engineID() */</span>
01466 
01467 <span class="comment">/*******************************************************************-o-******</span>
01468 <span class="comment"> * snmpv3_clone_engineID</span>
01469 <span class="comment"> *</span>
01470 <span class="comment"> * Parameters:</span>
01471 <span class="comment"> *      **dest</span>
01472 <span class="comment"> *       *dest_len</span>
01473 <span class="comment"> *       src</span>
01474 <span class="comment"> *       srclen</span>
01475 <span class="comment"> *      </span>
01476 <span class="comment"> * Returns:</span>
01477 <span class="comment"> *      Length of engineID      On Success</span>
01478 <span class="comment"> *      0                       Otherwise.</span>
01479 <span class="comment"> *</span>
01480 <span class="comment"> *</span>
01481 <span class="comment"> * Clones engineID, creates memory</span>
01482 <span class="comment"> *</span>
01483 <span class="comment"> */</span>
01484 <span class="keywordtype">int</span>
01485 snmpv3_clone_engineID(u_char ** dest, size_t * destlen, u_char * src,
01486                       size_t srclen)
01487 {
01488     <span class="keywordflow">if</span> (!dest || !destlen)
01489         <span class="keywordflow">return</span> 0;
01490 
01491     <span class="keywordflow">if</span> (*dest) {
01492         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(*dest);
01493         *dest = NULL;
01494     }
01495     *destlen = 0;
01496 
01497     <span class="keywordflow">if</span> (srclen &amp;&amp; src) {
01498         *dest = (u_char *) malloc(srclen);
01499         <span class="keywordflow">if</span> (*dest == NULL)
01500             <span class="keywordflow">return</span> 0;
01501         memmove(*dest, src, srclen);
01502         *destlen = srclen;
01503     }
01504     <span class="keywordflow">return</span> *destlen;
01505 }                               <span class="comment">/* end snmpv3_clone_engineID() */</span>
01506 
01507 
01508 <span class="comment">/*******************************************************************-o-******</span>
01509 <span class="comment"> * snmpv3_generate_engineID</span>
01510 <span class="comment"> *</span>
01511 <span class="comment"> * Parameters:</span>
01512 <span class="comment"> *      *length</span>
01513 <span class="comment"> *      </span>
01514 <span class="comment"> * Returns:</span>
01515 <span class="comment"> *      Pointer to copy of engineID     On Success.</span>
01516 <span class="comment"> *      NULL                            If malloc() or snmpv3_get_engineID()</span>
01517 <span class="comment"> *                                              fail.</span>
01518 <span class="comment"> *</span>
01519 <span class="comment"> * Generates a malloced copy of our engineID.</span>
01520 <span class="comment"> *</span>
01521 <span class="comment"> * 'length' is set to the length of engineID  -OR-  &lt; 0 on failure.</span>
01522 <span class="comment"> */</span>
01523 u_char         *
01524 snmpv3_generate_engineID(size_t * length)
01525 {
01526     u_char         *newID;
01527     newID = (u_char *) malloc(engineIDLength);
01528 
01529     <span class="keywordflow">if</span> (newID) {
01530         *length = snmpv3_get_engineID(newID, engineIDLength);
01531     }
01532 
01533     <span class="keywordflow">if</span> (*length == 0) {
01534         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(newID);
01535         newID = NULL;
01536     }
01537 
01538     <span class="keywordflow">return</span> newID;
01539 
01540 }                               <span class="comment">/* end snmpv3_generate_engineID() */</span>
01541 
01542 <span class="comment">/*</span>
01543 <span class="comment"> * snmpv3_local_snmpEngineTime(): return the number of seconds since the</span>
01544 <span class="comment"> * snmpv3 engine last incremented engine_boots </span>
01545 <span class="comment"> */</span>
01546 u_long
01547 snmpv3_local_snmpEngineTime(<span class="keywordtype">void</span>)
01548 {
01549 <span class="preprocessor">#ifdef SNMP_USE_TIMES</span>
01550   <span class="keyword">struct </span>tms dummy;
01551   clock_t now = times(&amp;dummy);
01552   <span class="comment">/* fixme: -1 is fault code... */</span>
01553   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result;
01554 
01555   <span class="keywordflow">if</span> (now &lt; snmpv3startClock) {
01556       result = UINT_MAX - (snmpv3startClock - now);
01557   } <span class="keywordflow">else</span> {
01558       result = now - snmpv3startClock;
01559   }
01560   <span class="keywordflow">if</span> (result &lt; lastcalltime) {
01561       <span class="comment">/* wrapped */</span>
01562       wrapcounter++;
01563   }
01564   lastcalltime = result;
01565   result =  (UINT_MAX/clockticks)*wrapcounter + result/clockticks;
01566 
01567   <span class="keywordflow">return</span> result;
01568 <span class="preprocessor">#else </span><span class="comment">/* !SNMP_USE_TIMES */</span>
01569     <span class="keyword">struct </span>timeval  now;
01570 
01571     gettimeofday(&amp;now, NULL);
01572     <span class="keywordflow">return</span> calculate_sectime_diff(&amp;now, &amp;snmpv3starttime);
01573 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_SYS_TIMES_H */</span>
01574 }
01575 
01576 
01577 
01578 <span class="comment">/*</span>
01579 <span class="comment"> * Code only for Linux systems </span>
01580 <span class="comment"> */</span>
01581 <span class="preprocessor">#if defined(IFHWADDRLEN) &amp;&amp; defined(SIOCGIFHWADDR)</span>
01582 <span class="keyword">static</span> <span class="keywordtype">int</span>
01583 getHwAddress(<span class="keyword">const</span> <span class="keywordtype">char</span> *networkDevice, <span class=
"comment">/* e.g. "eth0", "eth1" */</span>
01584              <span class="keywordtype">char</span> *addressOut)
01585 {                               <span class="comment">/* return address. Len=IFHWADDRLEN */</span>
01586     <span class="comment">/*</span>
01587 <span class="comment">     * getHwAddress(...)</span>
01588 <span class="comment">     * *</span>
01589 <span class="comment">     * *  This function will return a Network Interfaces Card's Hardware</span>
01590 <span class="comment">     * *  address (aka MAC address).</span>
01591 <span class="comment">     * *</span>
01592 <span class="comment">     * *  Input Parameter(s):</span>
01593 <span class="comment">     * *      networkDevice - a null terminated string with the name of a network</span>
01594 <span class="comment">     * *                      device.  Examples: eth0, eth1, etc...</span>
01595 <span class="comment">     * *</span>
01596 <span class="comment">     * *  Output Parameter(s):</span>
01597 <span class="comment">     * *      addressOut -    This is the binary value of the hardware address.</span>
01598 <span class="comment">     * *                      This value is NOT converted into a hexadecimal string.</span>
01599 <span class="comment">     * *                      The caller must pre-allocate for a return value of</span>
01600 <span class="comment">     * *                      length IFHWADDRLEN</span>
01601 <span class="comment">     * *</span>
01602 <span class="comment">     * *  Return value:   This function will return zero (0) for success.  If</span>
01603 <span class="comment">     * *                  an error occurred the function will return -1.</span>
01604 <span class="comment">     * *</span>
01605 <span class="comment">     * *  Caveats:    This has only been tested on Ethernet networking cards.</span>
01606 <span class="comment">     */</span>
01607     <span class="keywordtype">int</span>             sock;       <span class="comment">/* our socket */</span>
01608     <span class="keyword">struct </span>ifreq    request;    <span class=
"comment">/* struct which will have HW address */</span>
01609 
01610     <span class="keywordflow">if</span> ((NULL == networkDevice) || (NULL == addressOut)) {
01611         <span class="keywordflow">return</span> -1;
01612     }
01613     <span class="comment">/*</span>
01614 <span class="comment">     * In order to find out the hardware (MAC) address of our system under</span>
01615 <span class="comment">     * * Linux we must do the following:</span>
01616 <span class="comment">     * * 1.  Create a socket</span>
01617 <span class="comment">     * * 2.  Do an ioctl(...) call with the SIOCGIFHWADDRLEN operation.</span>
01618 <span class="comment">     */</span>
01619     sock = socket(AF_INET, SOCK_DGRAM, 0);
01620     <span class="keywordflow">if</span> (sock &lt; 0) {
01621         <span class="keywordflow">return</span> -1;
01622     }
01623     <span class="comment">/*</span>
01624 <span class="comment">     * erase the request block </span>
01625 <span class="comment">     */</span>
01626     memset(&amp;request, 0, <span class="keyword">sizeof</span>(request));
01627     <span class="comment">/*</span>
01628 <span class="comment">     * copy the name of the net device we want to find the HW address for </span>
01629 <span class="comment">     */</span>
01630     strncpy(request.ifr_name, networkDevice, IFNAMSIZ - 1);
01631     <span class="comment">/*</span>
01632 <span class="comment">     * Get the HW address </span>
01633 <span class="comment">     */</span>
01634     <span class="keywordflow">if</span> (ioctl(sock, SIOCGIFHWADDR, &amp;request)) {
01635         close(sock);
01636         <span class="keywordflow">return</span> -1;
01637     }
01638     close(sock);
01639     memcpy(addressOut, request.ifr_hwaddr.sa_data, IFHWADDRLEN);
01640     <span class="keywordflow">return</span> 0;
01641 }
01642 <span class="preprocessor">#endif</span>
01643 
01644 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
01645 <span class="comment">/*</span>
01646 <span class="comment"> * snmpv3_set_engineBootsAndTime(): this function does not exist.  Go away. </span>
01647 <span class="comment"> */</span>
01648 <span class="comment">/*</span>
01649 <span class="comment"> * It certainly should never be used, unless in a testing scenero,</span>
01650 <span class="comment"> * which is why it was created </span>
01651 <span class="comment"> */</span>
01652 <span class="keywordtype">void</span>
01653 snmpv3_set_engineBootsAndTime(<span class="keywordtype">int</span> boots, <span class="keywordtype">int</span> ttime)
01654 {
01655     engineBoots = boots;
01656     gettimeofday(&amp;snmpv3starttime, NULL);
01657     snmpv3starttime.tv_sec -= ttime;
01658 }
01659 <span class="preprocessor">#endif</span>
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small>Generated on Fri Dec 30 13:47:50 2005 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

