<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>snmpUnixDomain.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00002 
00003 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00004 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00005 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00006 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00007 
00008 <span class="preprocessor">#if HAVE_STRING_H</span>
00009 <span class="preprocessor">#include &lt;string.h&gt;</span>
00010 <span class="preprocessor">#else</span>
00011 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00012 <span class="preprocessor">#endif</span>
00013 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00014 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00015 <span class="preprocessor">#endif</span>
00016 <span class="preprocessor">#if HAVE_UNISTD_H</span>
00017 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00018 <span class="preprocessor">#endif</span>
00019 <span class="preprocessor">#if HAVE_SYS_SOCKET_H</span>
00020 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00021 <span class="preprocessor">#endif</span>
00022 <span class="preprocessor">#if HAVE_SYS_UN_H</span>
00023 <span class="preprocessor">#include &lt;sys/un.h&gt;</span>
00024 <span class="preprocessor">#endif</span>
00025 
00026 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00027 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00028 <span class="preprocessor">#endif</span>
00029 
00030 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00031 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00032 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00033 
00034 <span class="preprocessor">#include &lt;net-snmp/library/snmp_transport.h&gt;</span>
00035 <span class="preprocessor">#include &lt;net-snmp/library/snmpUDPDomain.h&gt;</span>
00036 <span class="preprocessor">#include &lt;net-snmp/library/snmpUnixDomain.h&gt;</span>
00037 
00038 
00039 <span class="preprocessor">#ifndef NETSNMP_STREAM_QUEUE_LEN</span>
00040 <span class="preprocessor">#define NETSNMP_STREAM_QUEUE_LEN  5</span>
00041 <span class="preprocessor">#endif</span>
00042 
00043 <span class="preprocessor">#ifndef SUN_LEN</span>
00044 <span class="comment">/*</span>
00045 <span class="comment"> * Evaluate to actual length of the `sockaddr_un' structure.</span>
00046 <span class="comment"> */</span>
00047 <span class="preprocessor">#define SUN_LEN(ptr) ((size_t) (((struct sockaddr_un *) 0)-&gt;sun_path)         \</span>
00048 <span class="preprocessor">                      + strlen ((ptr)-&gt;sun_path))</span>
00049 <span class="preprocessor">#endif</span>
00050 
00051 oid netsnmp_UnixDomain[] = { TRANSPORT_DOMAIN_LOCAL };
00052 <span class="keyword">static</span> netsnmp_tdomain unixDomain;
00053 
00054 
00055 <span class="comment">/*</span>
00056 <span class="comment"> * This is the structure we use to hold transport-specific data.</span>
00057 <span class="comment"> */</span>
00058 
00059 <span class="keyword">typedef</span> <span class="keyword">struct </span>_sockaddr_un_pair {
00060     <span class="keywordtype">int</span>             local;
00061     <span class="keyword">struct </span>sockaddr_un server;
00062     <span class="keyword">struct </span>sockaddr_un client;
00063 } sockaddr_un_pair;
00064 
00065 
00066 <span class="comment">/*</span>
00067 <span class="comment"> * Return a string representing the address in data, or else the "far end"</span>
00068 <span class="comment"> * address if data is NULL.</span>
00069 <span class="comment"> */</span>
00070 
00071 <span class="keyword">static</span> <span class="keywordtype">char</span> *
00072 netsnmp_unix_fmtaddr(netsnmp_transport *t, <span class="keywordtype">void</span> *data, <span class=
"keywordtype">int</span> len)
00073 {
00074     <span class="keyword">struct </span>sockaddr_un *to = NULL;
00075 
00076     <span class="keywordflow">if</span> (data != NULL) {
00077         to = (<span class="keyword">struct </span>sockaddr_un *) data;
00078     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL) {
00079         to = &amp;(((sockaddr_un_pair *) t-&gt;data)-&gt;server);
00080         len = SUN_LEN(to);
00081     }
00082     <span class="keywordflow">if</span> (to == NULL) {
00083         <span class="comment">/*</span>
00084 <span class="comment">         * "Local IPC" is the Posix.1g term for Unix domain protocols,</span>
00085 <span class="comment">         * according to W. R. Stevens, ``Unix Network Programming Volume I</span>
00086 <span class="comment">         * Second Edition'', p. 374.</span>
00087 <span class="comment">         */</span>
00088         <span class="keywordflow">return</span> strdup(<span class="stringliteral">"Local IPC: unknown"</span>);
00089     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (to-&gt;sun_path[0] == 0) {
00090         <span class="comment">/*</span>
00091 <span class="comment">         * This is an abstract name.  We could render it as hex or something</span>
00092 <span class="comment">         * but let's not worry about that for now.</span>
00093 <span class="comment">         */</span>
00094         <span class="keywordflow">return</span> strdup(<span class="stringliteral">"Local IPC: abstract"</span>);
00095     } <span class="keywordflow">else</span> {
00096         <span class="keywordtype">char</span>           *tmp = (<span class="keywordtype">char</span> *) malloc(16 + len);
00097         <span class="keywordflow">if</span> (tmp != NULL) {
00098             sprintf(tmp, <span class="stringliteral">"Local IPC: %s"</span>, to-&gt;sun_path);
00099         }
00100         <span class="keywordflow">return</span> tmp;
00101     }
00102 }
00103 
00104 
00105 
00106 <span class="comment">/*</span>
00107 <span class="comment"> * You can write something into opaque that will subsequently get passed back</span>
00108 <span class="comment"> * to your send function if you like.  For instance, you might want to</span>
00109 <span class="comment"> * remember where a PDU came from, so that you can send a reply there...</span>
00110 <span class="comment"> */</span>
00111 
00112 <span class="keyword">static</span> <span class="keywordtype">int</span>
00113 netsnmp_unix_recv(netsnmp_transport *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
00114                   <span class="keywordtype">void</span> **opaque, <span class="keywordtype">int</span> *olength)
00115 {
00116     <span class="keywordtype">int</span> rc = -1;
00117     socklen_t       tolen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_un);
00118     <span class="keyword">struct </span>sockaddr *to;
00119 
00120 
00121     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00122         to = (<span class="keyword">struct </span>sockaddr *) malloc(<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_un));
00123         <span class="keywordflow">if</span> (to == NULL) {
00124             *opaque = NULL;
00125             *olength = 0;
00126             <span class="keywordflow">return</span> -1;
00127         } <span class="keywordflow">else</span> {
00128             memset(to, 0, tolen);
00129         }
00130         <span class="keywordflow">if</span>(getsockname(t-&gt;sock, to, &amp;tolen) != 0){
00131             free(to);
00132             *opaque = NULL;
00133             *olength = 0;
00134             <span class="keywordflow">return</span> -1;
00135         };
00136         <span class="keywordflow">while</span> (rc &lt; 0) {
00137             rc = recv(t-&gt;sock, buf, size, 0);
00138             <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
00139                 DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix"</span>, <span class=
"stringliteral">"recv fd %d err %d (\"%s\")\n"</span>,
00140                             t-&gt;sock, errno, strerror(errno)));
00141                 <span class="keywordflow">return</span> rc;
00142             }
00143             *opaque = (<span class="keywordtype">void</span>*)to;
00144             *olength = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_un);
00145         }
00146         DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix"</span>, <span class=
"stringliteral">"recv fd %d got %d bytes\n"</span>, t-&gt;sock, rc));
00147     }
00148     <span class="keywordflow">return</span> rc;
00149 }
00150 
00151 
00152 
00153 <span class="keyword">static</span> <span class="keywordtype">int</span>
00154 netsnmp_unix_send(netsnmp_transport *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
00155                   <span class="keywordtype">void</span> **opaque, <span class="keywordtype">int</span> *olength)
00156 {
00157     <span class="keywordtype">int</span> rc = -1;
00158 
00159     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00160         DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix"</span>, <span class=
"stringliteral">"send %d bytes to %p on fd %d\n"</span>,
00161                     size, buf, t-&gt;sock));
00162         <span class="keywordflow">while</span> (rc &lt; 0) {
00163             rc = send(t-&gt;sock, buf, size, 0);
00164             <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
00165                 <span class="keywordflow">break</span>;
00166             }
00167         }
00168     }
00169     <span class="keywordflow">return</span> rc;
00170 }
00171 
00172 
00173 
00174 <span class="keyword">static</span> <span class="keywordtype">int</span>
00175 netsnmp_unix_close(netsnmp_transport *t)
00176 {
00177     <span class="keywordtype">int</span> rc = 0;
00178     sockaddr_un_pair *sup = (sockaddr_un_pair *) t-&gt;data;
00179 
00180     <span class="keywordflow">if</span> (t-&gt;sock &gt;= 0) {
00181 <span class="preprocessor">#ifndef HAVE_CLOSESOCKET</span>
00182         rc = close(t-&gt;sock);
00183 <span class="preprocessor">#else</span>
00184         rc = closesocket(t-&gt;sock);
00185 <span class="preprocessor">#endif</span>
00186         t-&gt;sock = -1;
00187         <span class="keywordflow">if</span> (sup != NULL) {
00188             <span class="keywordflow">if</span> (sup-&gt;local) {
00189                 <span class="keywordflow">if</span> (sup-&gt;server.sun_path[0] != 0) {
00190                   DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix"</span>, <span class=
"stringliteral">"close: server unlink(\"%s\")\n"</span>,
00191                               sup-&gt;server.sun_path));
00192                   unlink(sup-&gt;server.sun_path);
00193                 }
00194             } <span class="keywordflow">else</span> {
00195                 <span class="keywordflow">if</span> (sup-&gt;client.sun_path[0] != 0) {
00196                   DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix"</span>, <span class=
"stringliteral">"close: client unlink(\"%s\")\n"</span>,
00197                               sup-&gt;client.sun_path));
00198                   unlink(sup-&gt;client.sun_path);
00199                 }
00200             }
00201         }
00202         <span class="keywordflow">return</span> rc;
00203     } <span class="keywordflow">else</span> {
00204         <span class="keywordflow">return</span> -1;
00205     }
00206 }
00207 
00208 
00209 
00210 <span class="keyword">static</span> <span class="keywordtype">int</span>
00211 netsnmp_unix_accept(netsnmp_transport *t)
00212 {
00213     <span class="keyword">struct </span>sockaddr *farend = NULL;
00214     <span class="keywordtype">int</span>             newsock = -1;
00215     socklen_t       farendlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_un);
00216 
00217     farend = (<span class="keyword">struct </span>sockaddr *) malloc(farendlen);
00218 
00219     <span class="keywordflow">if</span> (farend == NULL) {
00220         <span class="comment">/*</span>
00221 <span class="comment">         * Indicate that the acceptance of this socket failed.</span>
00222 <span class="comment">         */</span>
00223         DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix"</span>, <span class=
"stringliteral">"accept: malloc failed\n"</span>));
00224         <span class="keywordflow">return</span> -1;
00225     }
00226     memset(farend, 0, farendlen);
00227 
00228     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00229         newsock = accept(t-&gt;sock, farend, &amp;farendlen);
00230 
00231         <span class="keywordflow">if</span> (newsock &lt; 0) {
00232             DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix"</span>,<span class=
"stringliteral">"accept failed rc %d errno %d \"%s\"\n"</span>,
00233                         newsock, errno, strerror(errno)));
00234             free(farend);
00235             <span class="keywordflow">return</span> newsock;
00236         }
00237 
00238         <span class="keywordflow">if</span> (t-&gt;data != NULL) {
00239             free(t-&gt;data);
00240         }
00241 
00242         DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix"</span>, <span class=
"stringliteral">"accept succeeded (farend %p len %d)\n"</span>,
00243                     farend, farendlen));
00244         t-&gt;data = farend;
00245         t-&gt;data_length = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_un);
00246        netsnmp_sock_buffer_set(newsock, SO_SNDBUF, 1, 0);
00247        netsnmp_sock_buffer_set(newsock, SO_RCVBUF, 1, 0);
00248         <span class="keywordflow">return</span> newsock;
00249     } <span class="keywordflow">else</span> {
00250         free(farend);
00251         <span class="keywordflow">return</span> -1;
00252     }
00253 }
00254 
00255 
00256 
00257 <span class="comment">/*</span>
00258 <span class="comment"> * Open a Unix-domain transport for SNMP.  Local is TRUE if addr is the local</span>
00259 <span class="comment"> * address to bind to (i.e. this is a server-type session); otherwise addr is</span>
00260 <span class="comment"> * the remote address to send things to (and we make up a temporary name for</span>
00261 <span class="comment"> * the local end of the connection).</span>
00262 <span class="comment"> */</span>
00263 
00264 netsnmp_transport *
00265 netsnmp_unix_transport(<span class="keyword">struct</span> sockaddr_un *addr, <span class="keywordtype">int</span> local)
00266 {
00267     netsnmp_transport *t = NULL;
00268     sockaddr_un_pair *sup = NULL;
00269     <span class="keywordtype">int</span>             rc = 0;
00270     <span class="keywordtype">char</span>           *string = NULL;
00271 
00272     <span class="keywordflow">if</span> (addr == NULL || addr-&gt;sun_family != AF_UNIX) {
00273         <span class="keywordflow">return</span> NULL;
00274     }
00275 
00276     t = (netsnmp_transport *) malloc(<span class="keyword">sizeof</span>(netsnmp_transport));
00277     <span class="keywordflow">if</span> (t == NULL) {
00278         <span class="keywordflow">return</span> NULL;
00279     }
00280 
00281     string = netsnmp_unix_fmtaddr(NULL, (<span class="keywordtype">void</span> *)addr,
00282                                   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_un));
00283     DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix"</span>, <span class=
"stringliteral">"open %s %s\n"</span>, local ? <span class="stringliteral">"local"</span> : <span class=
"stringliteral">"remote"</span>,
00284                 string));
00285     free(string);
00286 
00287     memset(t, 0, <span class="keyword">sizeof</span>(netsnmp_transport));
00288 
00289     t-&gt;domain = netsnmp_UnixDomain;
00290     t-&gt;domain_length =
00291         <span class="keyword">sizeof</span>(netsnmp_UnixDomain) / <span class=
"keyword">sizeof</span>(netsnmp_UnixDomain[0]);
00292 
00293     t-&gt;data = malloc(<span class="keyword">sizeof</span>(sockaddr_un_pair));
00294     <span class="keywordflow">if</span> (t-&gt;data == NULL) {
00295         netsnmp_transport_free(t);
00296         <span class="keywordflow">return</span> NULL;
00297     }
00298     memset(t-&gt;data, 0, <span class="keyword">sizeof</span>(sockaddr_un_pair));
00299     t-&gt;data_length = <span class="keyword">sizeof</span>(sockaddr_un_pair);
00300     sup = (sockaddr_un_pair *) t-&gt;data;
00301 
00302     t-&gt;sock = socket(PF_UNIX, SOCK_STREAM, 0);
00303     <span class="keywordflow">if</span> (t-&gt;sock &lt; 0) {
00304         netsnmp_transport_free(t);
00305         <span class="keywordflow">return</span> NULL;
00306     }
00307 
00308     t-&gt;flags = NETSNMP_TRANSPORT_FLAG_STREAM;
00309 
00310     <span class="keywordflow">if</span> (local) {
00311         t-&gt;local = malloc(strlen(addr-&gt;sun_path));
00312         <span class="keywordflow">if</span> (t-&gt;local == NULL) {
00313             netsnmp_transport_free(t);
00314             <span class="keywordflow">return</span> NULL;
00315         }
00316         memcpy(t-&gt;local, addr-&gt;sun_path, strlen(addr-&gt;sun_path));
00317         t-&gt;local_length = strlen(addr-&gt;sun_path);
00318 
00319         <span class="comment">/*</span>
00320 <span class="comment">         * This session is inteneded as a server, so we must bind to the given</span>
00321 <span class="comment">         * path (unlinking it first, to avoid errors).</span>
00322 <span class="comment">         */</span>
00323 
00324         t-&gt;flags |= NETSNMP_TRANSPORT_FLAG_LISTEN;
00325 
00326         unlink(addr-&gt;sun_path);
00327         rc = bind(t-&gt;sock, (<span class="keyword">struct</span> sockaddr *) addr, SUN_LEN(addr));
00328         <span class="keywordflow">if</span> (rc != 0) {
00329             DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix_transport"</span>,
00330                         <span class="stringliteral">"couldn't bind \"%s\", errno %d (%s)\n"</span>,
00331                         addr-&gt;sun_path, errno, strerror(errno)));
00332             netsnmp_unix_close(t);
00333             netsnmp_transport_free(t);
00334             <span class="keywordflow">return</span> NULL;
00335         }
00336 
00337         <span class="comment">/*</span>
00338 <span class="comment">         * Save the address in the transport-specific data pointer for later</span>
00339 <span class="comment">         * use by netsnmp_unix_close.</span>
00340 <span class="comment">         */</span>
00341 
00342         sup-&gt;server.sun_family = AF_UNIX;
00343         strcpy(sup-&gt;server.sun_path, addr-&gt;sun_path);
00344         sup-&gt;local = 1;
00345 
00346         <span class="comment">/*</span>
00347 <span class="comment">         * Now sit here and listen for connections to arrive.</span>
00348 <span class="comment">         */</span>
00349 
00350         rc = listen(t-&gt;sock, NETSNMP_STREAM_QUEUE_LEN);
00351         <span class="keywordflow">if</span> (rc != 0) {
00352             DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix_transport"</span>,
00353                         <span class="stringliteral">"couldn't listen to \"%s\", errno %d (%s)\n"</span>,
00354                         addr-&gt;sun_path, errno, strerror(errno)));
00355             netsnmp_unix_close(t);
00356             netsnmp_transport_free(t);
00357         }
00358 
00359     } <span class="keywordflow">else</span> {
00360         t-&gt;remote = malloc(strlen(addr-&gt;sun_path));
00361         <span class="keywordflow">if</span> (t-&gt;remote == NULL) {
00362             netsnmp_transport_free(t);
00363             <span class="keywordflow">return</span> NULL;
00364         }
00365         memcpy(t-&gt;remote, addr-&gt;sun_path, strlen(addr-&gt;sun_path));
00366         t-&gt;remote_length = strlen(addr-&gt;sun_path);
00367 
00368         rc = connect(t-&gt;sock, (<span class="keyword">struct</span> sockaddr *) addr,
00369                      <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_un));
00370         <span class="keywordflow">if</span> (rc != 0) {
00371             DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix_transport"</span>,
00372                         <span class="stringliteral">"couldn't connect to \"%s\", errno %d (%s)\n"</span>,
00373                         addr-&gt;sun_path, errno, strerror(errno)));
00374             netsnmp_unix_close(t);
00375             netsnmp_transport_free(t);
00376             <span class="keywordflow">return</span> NULL;
00377         }
00378 
00379         <span class="comment">/*</span>
00380 <span class="comment">         * Save the remote address in the transport-specific data pointer for</span>
00381 <span class="comment">         * later use by netsnmp_unix_send.</span>
00382 <span class="comment">         */</span>
00383 
00384         sup-&gt;server.sun_family = AF_UNIX;
00385         strcpy(sup-&gt;server.sun_path, addr-&gt;sun_path);
00386         sup-&gt;local = 0;
00387        netsnmp_sock_buffer_set(t-&gt;sock, SO_SNDBUF, local, 0);
00388        netsnmp_sock_buffer_set(t-&gt;sock, SO_RCVBUF, local, 0);
00389     }
00390 
00391     <span class="comment">/*</span>
00392 <span class="comment">     * Message size is not limited by this transport (hence msgMaxSize</span>
00393 <span class="comment">     * is equal to the maximum legal size of an SNMP message).</span>
00394 <span class="comment">     */</span>
00395 
00396     t-&gt;msgMaxSize = 0x7fffffff;
00397     t-&gt;f_recv     = netsnmp_unix_recv;
00398     t-&gt;f_send     = netsnmp_unix_send;
00399     t-&gt;f_close    = netsnmp_unix_close;
00400     t-&gt;f_accept   = netsnmp_unix_accept;
00401     t-&gt;f_fmtaddr  = netsnmp_unix_fmtaddr;
00402 
00403     <span class="keywordflow">return</span> t;
00404 }
00405 
00406 netsnmp_transport *
00407 netsnmp_unix_create_tstring(<span class="keyword">const</span> <span class="keywordtype">char</span> *string, <span class=
"keywordtype">int</span> local)
00408 {
00409     <span class="keyword">struct </span>sockaddr_un addr;
00410 
00411     <span class="keywordflow">if</span> ((string != NULL) &amp;&amp; (strlen(string) &lt; <span class=
"keyword">sizeof</span>(addr.sun_path))) {
00412         addr.sun_family = AF_UNIX;
00413         memset(addr.sun_path, 0, <span class="keyword">sizeof</span>(addr.sun_path));
00414         strncpy(addr.sun_path, string, <span class="keyword">sizeof</span>(addr.sun_path) - 1);
00415         <span class="keywordflow">return</span> netsnmp_unix_transport(&amp;addr, local);
00416     } <span class="keywordflow">else</span> {
00417         <span class="keywordflow">if</span> (string != NULL) {
00418             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Path too long for Unix domain transport\n"</span>);
00419         }
00420         <span class="keywordflow">return</span> NULL;
00421     }
00422 }
00423 
00424 
00425 
00426 netsnmp_transport *
00427 netsnmp_unix_create_ostring(<span class="keyword">const</span> u_char * o, size_t o_len, <span class=
"keywordtype">int</span> local)
00428 {
00429     <span class="keyword">struct </span>sockaddr_un addr;
00430 
00431     <span class="keywordflow">if</span> (o_len &gt; 0 &amp;&amp; o_len &lt; (<span class=
"keyword">sizeof</span>(addr.sun_path) - 1)) {
00432         addr.sun_family = AF_UNIX;
00433         memset(addr.sun_path, 0, <span class="keyword">sizeof</span>(addr.sun_path));
00434         strncpy(addr.sun_path, o, o_len);
00435         <span class="keywordflow">return</span> netsnmp_unix_transport(&amp;addr, local);
00436     } <span class="keywordflow">else</span> {
00437         <span class="keywordflow">if</span> (o_len &gt; 0) {
00438             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Path too long for Unix domain transport\n"</span>);
00439         }
00440     }
00441     <span class="keywordflow">return</span> NULL;
00442 }
00443 
00444 
00445 
00446 <span class="keywordtype">void</span>
00447 netsnmp_unix_ctor(<span class="keywordtype">void</span>)
00448 {
00449     unixDomain.name = netsnmp_UnixDomain;
00450     unixDomain.name_length = <span class="keyword">sizeof</span>(netsnmp_UnixDomain) / <span class=
"keyword">sizeof</span>(oid);
00451     unixDomain.prefix = calloc(2, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
00452     unixDomain.prefix[0] = <span class="stringliteral">"unix"</span>;
00453 
00454     unixDomain.f_create_from_tstring = netsnmp_unix_create_tstring;
00455     unixDomain.f_create_from_ostring = netsnmp_unix_create_ostring;
00456 
00457     netsnmp_tdomain_register(&amp;unixDomain);
00458 }
00459 
00460 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
00461 <span class="comment">/* support for SNMPv1 and SNMPv2c on unix domain*/</span>
00462 
00463 <span class="preprocessor">#define EXAMPLE_COMMUNITY "COMMUNITY"</span>
00464 <span class="keyword">typedef</span> <span class="keyword">struct </span>_com2SecUnixEntry {
00465     <span class="keywordtype">char</span>            community[VACMSTRINGLEN];
00466     <span class="keywordtype">char</span>            sockpath[<span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_un)];
00467     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   pathlen;
00468     <span class="keywordtype">char</span>            secName[VACMSTRINGLEN];
00469     <span class="keywordtype">char</span>            contextName[VACMSTRINGLEN];
00470     <span class="keyword">struct </span>_com2SecUnixEntry *next;
00471 } com2SecUnixEntry;
00472 
00473 com2SecUnixEntry   *com2SecUnixList = NULL, *com2SecUnixListLast = NULL;
00474 
00475 
00476 <span class="keywordtype">int</span>
00477 netsnmp_unix_getSecName(<span class="keywordtype">void</span> *opaque, <span class="keywordtype">int</span> olength,
00478                         <span class="keyword">const</span> <span class="keywordtype">char</span> *community,
00479                         size_t community_len,
00480                         <span class="keywordtype">char</span> **secName, <span class=
"keywordtype">char</span> **contextName)
00481 {
00482     com2SecUnixEntry   *c;
00483     <span class="keyword">struct </span>sockaddr_un *to = (<span class="keyword">struct </span>sockaddr_un *) opaque;
00484     <span class="keywordtype">char</span>           *ztcommunity = NULL;
00485 
00486     <span class="keywordflow">if</span> (secName != NULL) {
00487         *secName = NULL;  <span class="comment">/* Haven't found anything yet */</span>
00488     }
00489 
00490     <span class="comment">/*</span>
00491 <span class="comment">     * Special case if there are NO entries (as opposed to no MATCHING</span>
00492 <span class="comment">     * entries).</span>
00493 <span class="comment">     */</span>
00494 
00495     <span class="keywordflow">if</span> (com2SecUnixList == NULL) {
00496         DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix_getSecName"</span>, <span class=
"stringliteral">"no com2sec entries\n"</span>));
00497         <span class="keywordflow">return</span> 0;
00498     }
00499 
00500     <span class="comment">/*</span>
00501 <span class="comment">     * If there is no unix socket path, then there can be no valid security</span>
00502 <span class="comment">     * name.</span>
00503 <span class="comment">     */</span>
00504 
00505     <span class="keywordflow">if</span> (opaque == NULL || olength != <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_un) ||
00506         to-&gt;sun_family != AF_UNIX) {
00507         DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix_getSecName"</span>,
00508                     <span class="stringliteral">"no unix destine address in PDU?\n"</span>));
00509         <span class="keywordflow">return</span> 1;
00510     }
00511 
00512     DEBUGIF(<span class="stringliteral">"netsnmp_unix_getSecName"</span>) {
00513         ztcommunity = (<span class="keywordtype">char</span> *)malloc(community_len + 1);
00514         <span class="keywordflow">if</span> (ztcommunity != NULL) {
00515             memcpy(ztcommunity, community, community_len);
00516             ztcommunity[community_len] = <span class="charliteral">'\0'</span>;
00517         }
00518 
00519         DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix_getSecName"</span>, <span class=
"stringliteral">"resolve &lt;\"%s\"&gt;\n"</span>,
00520                     ztcommunity ? ztcommunity : <span class="stringliteral">"&lt;malloc error&gt;"</span>));
00521     }
00522 
00523     <span class="keywordflow">for</span> (c = com2SecUnixList; c != NULL; c = c-&gt;next) {
00524         DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix_getSecName"</span>,<span class=
"stringliteral">"compare &lt;\"%s\",to socket %s&gt;"</span>,
00525                     c-&gt;community, c-&gt;sockpath ));
00526         <span class="keywordflow">if</span> ((community_len == strlen(c-&gt;community)) &amp;&amp;
00527             (memcmp(community, c-&gt;community, community_len) == 0) &amp;&amp;
00528             <span class="comment">/* compare sockpath, if pathlen == 0, always match */</span>
00529             (strlen(to-&gt;sun_path) == c-&gt;pathlen || c-&gt;pathlen == 0) &amp;&amp;
00530             (memcmp(to-&gt;sun_path, c-&gt;sockpath, c-&gt;pathlen) == 0)
00531             ) {
00532             DEBUGMSG((<span class="stringliteral">"netsnmp_unix_getSecName"</span>, <span class=
"stringliteral">"... SUCCESS\n"</span>));
00533             <span class="keywordflow">if</span> (secName != NULL) {
00534                 *secName = c-&gt;secName;
00535                 *contextName = c-&gt;contextName;
00536             }
00537             <span class="keywordflow">break</span>;
00538         }
00539         DEBUGMSG((<span class="stringliteral">"netsnmp_unix_getSecName"</span>, <span class=
"stringliteral">"... nope\n"</span>));
00540     }
00541     <span class="keywordflow">if</span> (ztcommunity != NULL) {
00542         free(ztcommunity);
00543     }
00544     <span class="keywordflow">return</span> 1;
00545 }
00546 
00547 <span class="keywordtype">void</span>
00548 netsnmp_unix_parse_security(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *param)
00549 {
00550     <span class="keywordtype">char</span>              secName[VACMSTRINGLEN + 1], community[VACMSTRINGLEN + 1];
00551     <span class="keywordtype">char</span>              contextName[VACMSTRINGLEN + 1];
00552     <span class="keywordtype">char</span>              sockpath[<span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_un) + 1];
00553     com2SecUnixEntry *e = NULL;
00554 
00555 
00556     param = copy_nword(param, secName, VACMSTRINGLEN);
00557     <span class="keywordflow">if</span> (strcmp(secName, <span class="stringliteral">"-Cn"</span>) == 0) {
00558         <span class="keywordflow">if</span> (!secName) {
00559             config_perror(<span class="stringliteral">"missing CONTEXT_NAME parameter"</span>);
00560             <span class="keywordflow">return</span>;
00561         }
00562         param = copy_nword( param, contextName, <span class="keyword">sizeof</span>(contextName));
00563         param = copy_nword( param, secName, <span class="keyword">sizeof</span>(secName));
00564     } <span class="keywordflow">else</span> {
00565         contextName[0] = <span class="charliteral">'\0'</span>;
00566     }
00567     <span class="keywordflow">if</span> (secName[0] == <span class="charliteral">'\0'</span>) {
00568         config_perror(<span class="stringliteral">"missing NAME parameter"</span>);
00569         <span class="keywordflow">return</span>;
00570     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strlen(secName) &gt; (VACMSTRINGLEN - 1)) {
00571         config_perror(<span class="stringliteral">"security name too long"</span>);
00572         <span class="keywordflow">return</span>;
00573     }
00574 
00575         param = copy_nword(param, sockpath, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_un) - 1);
00576     <span class="keywordflow">if</span> (sockpath[0] == <span class="charliteral">'\0'</span>) {
00577         config_perror(<span class="stringliteral">"missing SOCKPATH parameter"</span>);
00578         <span class="keywordflow">return</span>;
00579     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strlen(sockpath) &gt; (<span class=
"keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_un) - 1)) {
00580         config_perror(<span class="stringliteral">"sockpath too long"</span>);
00581         <span class="keywordflow">return</span>;
00582     }
00583     <span class="comment">/* if sockpath == "default", set pathlen=0*/</span>
00584     <span class="keywordflow">if</span>(strcmp(sockpath, <span class="stringliteral">"default"</span>) == 0){
00585         sockpath[0] = 0;
00586     }
00587 
00588     param = copy_nword(param, community, VACMSTRINGLEN);
00589     <span class="keywordflow">if</span> (community[0] == <span class="charliteral">'\0'</span>) {
00590         config_perror(<span class="stringliteral">"missing COMMUNITY parameter\n"</span>);
00591         <span class="keywordflow">return</span>;
00592     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp
00593                (community, EXAMPLE_COMMUNITY, strlen(EXAMPLE_COMMUNITY))
00594                == 0) {
00595         config_perror(<span class="stringliteral">"example config COMMUNITY not properly configured"</span>);
00596         <span class="keywordflow">return</span>;
00597     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strlen(community) &gt; (VACMSTRINGLEN - 1)) {
00598         config_perror(<span class="stringliteral">"community name too long"</span>);
00599         <span class="keywordflow">return</span>;
00600     }
00601 
00602     e = (com2SecUnixEntry *) malloc(<span class="keyword">sizeof</span>(com2SecUnixEntry));
00603     <span class="keywordflow">if</span> (e == NULL) {
00604         config_perror(<span class="stringliteral">"memory error"</span>);
00605         <span class="keywordflow">return</span>;
00606     }
00607 
00608     DEBUGMSGTL((<span class="stringliteral">"netsnmp_unix_parse_security"</span>,
00609                 <span class="stringliteral">"&lt;\"%s\"&gt; =&gt; \"%s\"\n"</span>, community, secName));
00610 
00611     strcpy(e-&gt;secName, secName);
00612     strcpy(e-&gt;contextName, contextName);
00613     strcpy(e-&gt;community, community);
00614     strcpy(e-&gt;sockpath, sockpath);
00615     e-&gt;pathlen = strlen(sockpath);
00616     e-&gt;next = NULL;
00617 
00618     <span class="keywordflow">if</span> (com2SecUnixListLast != NULL) {
00619         com2SecUnixListLast-&gt;next = e;
00620         com2SecUnixListLast = e;
00621     } <span class="keywordflow">else</span> {
00622         com2SecUnixListLast = com2SecUnixList = e;
00623     }
00624 }
00625 
00626 <span class="keywordtype">void</span>
00627 netsnmp_unix_com2SecList_free(<span class="keywordtype">void</span>)
00628 {
00629     com2SecUnixEntry   *e = com2SecUnixList;
00630     <span class="keywordflow">while</span> (e != NULL) {
00631         com2SecUnixEntry   *tmp = e;
00632         e = e-&gt;next;
00633         free(tmp);
00634     }
00635     com2SecUnixList = com2SecUnixListLast = NULL;
00636 }
00637 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
00638 
00639 <span class="keywordtype">void</span>
00640 netsnmp_unix_agent_config_tokens_register(<span class="keywordtype">void</span>)
00641 {
00642 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
00643     register_app_config_handler(<span class="stringliteral">"com2secunix"</span>, netsnmp_unix_parse_security,
00644                                 netsnmp_unix_com2SecList_free,
00645                                 <span class="stringliteral">"[-Cn CONTEXT] secName sockpath community"</span>);
00646 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
00647 }
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small>Generated on Fri Dec 30 13:47:50 2005 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

