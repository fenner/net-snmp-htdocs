<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>snmpusm.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
00002 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00003 <span class="comment"> * that may apply:</span>
00004 <span class="comment"> */</span>
00005 <span class="comment">/*</span>
00006 <span class="comment"> * Portions of this file are copyrighted by:</span>
00007 <span class="comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
00008 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00009 <span class="comment"> * distributed with the Net-SNMP package.</span>
00010 <span class="comment"> */</span>
00011 <span class="comment">/*</span>
00012 <span class="comment"> * snmpusm.c</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * Routines to manipulate a information about a "user" as</span>
00015 <span class="comment"> * defined by the SNMP-USER-BASED-SM-MIB MIB.</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * All functions usm_set_usmStateReference_*() return 0 on success, -1</span>
00018 <span class="comment"> * otherwise.</span>
00019 <span class="comment"> *</span>
00020 <span class="comment"> * !! Tab stops set to 4 in some parts of this file. !!</span>
00021 <span class="comment"> *    (Designated on a per function.)</span>
00022 <span class="comment"> */</span>
00023 
00024 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00025 
00026 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00027 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00028 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00029 <span class="preprocessor">#endif</span>
00030 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00031 <span class="preprocessor">#ifdef HAVE_STDLIB_H</span>
00032 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00033 <span class="preprocessor">#endif</span>
00034 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00035 <span class="preprocessor"># ifdef WIN32</span>
00036 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00037 <span class="preprocessor"># else</span>
00038 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00039 <span class="preprocessor"># endif</span>
00040 <span class="preprocessor"># include &lt;time.h&gt;</span>
00041 <span class="preprocessor">#else</span>
00042 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00043 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00044 <span class="preprocessor"># else</span>
00045 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00046 <span class="preprocessor"># endif</span>
00047 <span class="preprocessor">#endif</span>
00048 <span class="preprocessor">#if HAVE_STRING_H</span>
00049 <span class="preprocessor">#include &lt;string.h&gt;</span>
00050 <span class="preprocessor">#else</span>
00051 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00052 <span class="preprocessor">#endif</span>
00053 <span class="preprocessor">#ifdef HAVE_NETINET_IN_H</span>
00054 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00055 <span class="preprocessor">#endif</span>
00056 
00057 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00058 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00059 <span class="preprocessor">#endif</span>
00060 
00061 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00062 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00063 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00064 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00065 
00066 <span class="preprocessor">#include &lt;net-snmp/library/asn1.h&gt;</span>
00067 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00068 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
00069 <span class="preprocessor">#include &lt;net-snmp/library/tools.h&gt;</span>
00070 <span class="preprocessor">#include &lt;net-snmp/library/keytools.h&gt;</span>
00071 <span class="preprocessor">#include &lt;net-snmp/library/snmpv3.h&gt;</span>
00072 <span class="preprocessor">#include &lt;net-snmp/library/lcd_time.h&gt;</span>
00073 <span class="preprocessor">#include &lt;net-snmp/library/scapi.h&gt;</span>
00074 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
00075 <span class="preprocessor">#include &lt;net-snmp/library/snmp_secmod.h&gt;</span>
00076 <span class="preprocessor">#include &lt;net-snmp/library/snmpusm.h&gt;</span>
00077 
00078 oid             usmNoAuthProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 1, 1 };
00079 <span class="preprocessor">#ifndef DISABLE_MD5</span>
00080 oid             usmHMACMD5AuthProtocol[10] =
00081     { 1, 3, 6, 1, 6, 3, 10, 1, 1, 2 };
00082 <span class="preprocessor">#endif</span>
00083 oid             usmHMACSHA1AuthProtocol[10] =
00084     { 1, 3, 6, 1, 6, 3, 10, 1, 1, 3 };
00085 oid             usmNoPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 1 };
00086 <span class="preprocessor">#ifndef DISABLE_DES</span>
00087 oid             usmDESPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 2 };
00088 <span class="preprocessor">#endif</span>
00089 oid             usmAESPrivProtocol[10] = { 1, 3, 6, 1, 6, 3, 10, 1, 2, 4 };
00090 <span class="comment">/* backwards compat */</span>
00091 oid             *usmAES128PrivProtocol = usmAESPrivProtocol;
00092 
00093 <span class="keyword">static</span> u_int    dummy_etime, dummy_eboot;       <span class=
"comment">/* For ISENGINEKNOWN(). */</span>
00094 
00095 <span class="comment">/*</span>
00096 <span class="comment"> * Globals.</span>
00097 <span class="comment"> */</span>
00098 <span class="keyword">static</span> u_int    salt_integer;
00099 <span class="preprocessor">#ifdef HAVE_AES</span>
00100 <span class="keyword">static</span> u_int    salt_integer64_1, salt_integer64_2;
00101 <span class="preprocessor">#endif</span>
00102         <span class="comment">/*</span>
00103 <span class="comment">         * 1/2 of seed for the salt.   Cf. RFC2274, Sect 8.1.1.1.</span>
00104 <span class="comment">         */</span>
00105 
00106 <span class="keyword">static</span> <span class="keyword">struct </span>usmUser *noNameUser = NULL;
00107 <span class="comment">/*</span>
00108 <span class="comment"> * Local storage (LCD) of the default user list.</span>
00109 <span class="comment"> */</span>
00110 <span class="keyword">static</span> <span class="keyword">struct </span>usmUser *userList = NULL;
00111 
00112 <span class="comment">/*</span>
00113 <span class="comment"> * Prototypes</span>
00114 <span class="comment"> */</span>
00115 <span class="keywordtype">int</span>
00116                 usm_check_secLevel_vs_protocols(<span class="keywordtype">int</span> level,
00117                                                 <span class="keyword">const</span> oid * authProtocol,
00118                                                 u_int authProtocolLen,
00119                                                 <span class="keyword">const</span> oid * privProtocol,
00120                                                 u_int privProtocolLen);
00121 <span class="keywordtype">int</span>
00122                 usm_calc_offsets(size_t globalDataLen,
00123                                  <span class="keywordtype">int</span> secLevel, size_t secEngineIDLen,
00124                                  size_t secNameLen, size_t scopedPduLen,
00125                                  u_long engineboots, <span class="keywordtype">long</span> engine_time,
00126                                  size_t * theTotalLength,
00127                                  size_t * authParamsOffset,
00128                                  size_t * privParamsOffset,
00129                                  size_t * dataOffset, size_t * datalen,
00130                                  size_t * msgAuthParmLen,
00131                                  size_t * msgPrivParmLen, size_t * otstlen,
00132                                  size_t * seq_len, size_t * msgSecParmLen);
00133 <span class="comment">/*</span>
00134 <span class="comment"> * Set a given field of the secStateRef.</span>
00135 <span class="comment"> *</span>
00136 <span class="comment"> * Allocate &lt;len&gt; bytes for type &lt;type&gt; pointed to by ref-&gt;&lt;field&gt;.</span>
00137 <span class="comment"> * Then copy in &lt;item&gt; and record its length in ref-&gt;&lt;field_len&gt;.</span>
00138 <span class="comment"> *</span>
00139 <span class="comment"> * Return 0 on success, -1 otherwise.</span>
00140 <span class="comment"> */</span>
00141 <span class="preprocessor">#define MAKE_ENTRY( type, item, len, field, field_len )                 \</span>
00142 <span class="preprocessor">{                                                                       \</span>
00143 <span class="preprocessor">        if (ref == NULL)                                                \</span>
00144 <span class="preprocessor">                return -1;                                              \</span>
00145 <span class="preprocessor">        if (ref-&gt;field != NULL) {                                       \</span>
00146 <span class="preprocessor">                SNMP_ZERO(ref-&gt;field, ref-&gt;field_len);                  \</span>
00147 <span class="preprocessor">                SNMP_FREE(ref-&gt;field);                                  \</span>
00148 <span class="preprocessor">        }                                                               \</span>
00149 <span class="preprocessor">        ref-&gt;field_len = 0;                                             \</span>
00150 <span class="preprocessor">        if (len == 0 || item == NULL) {                                 \</span>
00151 <span class="preprocessor">                return 0;                                               \</span>
00152 <span class="preprocessor">        }                                                               \</span>
00153 <span class="preprocessor">        if ((ref-&gt;field = (type*) malloc (len * sizeof(type))) == NULL) \</span>
00154 <span class="preprocessor">        {                                                               \</span>
00155 <span class="preprocessor">                return -1;                                              \</span>
00156 <span class="preprocessor">        }                                                               \</span>
00157 <span class="preprocessor">                                                                        \</span>
00158 <span class="preprocessor">        memcpy (ref-&gt;field, item, len * sizeof(type));                  \</span>
00159 <span class="preprocessor">        ref-&gt;field_len = len;                                           \</span>
00160 <span class="preprocessor">                                                                        \</span>
00161 <span class="preprocessor">        return 0;                                                       \</span>
00162 <span class="preprocessor">}</span>
00163 
00164 
00165 <span class="keyword">struct </span>usmStateReference *
00166 usm_malloc_usmStateReference(<span class="keywordtype">void</span>)
00167 {
00168     <span class="keyword">struct </span>usmStateReference *retval = (<span class=
"keyword">struct </span>usmStateReference *)
00169         calloc(1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> usmStateReference));
00170 
00171     <span class="keywordflow">return</span> retval;
00172 }                               <span class="comment">/* end usm_malloc_usmStateReference() */</span>
00173 
00174 
00175 <span class="keywordtype">void</span>
00176 usm_free_usmStateReference(<span class="keywordtype">void</span> *old)
00177 {
00178     <span class="keyword">struct </span>usmStateReference *old_ref = (<span class=
"keyword">struct </span>usmStateReference *) old;
00179 
00180     <span class="keywordflow">if</span> (old_ref) {
00181 
00182         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(old_ref-&gt;usr_name);
00183         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(old_ref-&gt;usr_engine_id);
00184         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(old_ref-&gt;usr_auth_protocol);
00185         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(old_ref-&gt;usr_priv_protocol);
00186 
00187         <span class="keywordflow">if</span> (old_ref-&gt;usr_auth_key) {
00188             <a class="code" href=
"group__util.html#ga40">SNMP_ZERO</a>(old_ref-&gt;usr_auth_key, old_ref-&gt;usr_auth_key_length);
00189             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(old_ref-&gt;usr_auth_key);
00190         }
00191         <span class="keywordflow">if</span> (old_ref-&gt;usr_priv_key) {
00192             <a class="code" href=
"group__util.html#ga40">SNMP_ZERO</a>(old_ref-&gt;usr_priv_key, old_ref-&gt;usr_priv_key_length);
00193             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(old_ref-&gt;usr_priv_key);
00194         }
00195 
00196         <a class="code" href="group__util.html#ga40">SNMP_ZERO</a>(old_ref, <span class="keyword">sizeof</span>(*old_ref));
00197         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(old_ref);
00198 
00199     }
00200 
00201 }                               <span class="comment">/* end usm_free_usmStateReference() */</span>
00202 
00203 <span class="keyword">struct </span>usmUser *
00204 usm_get_userList(<span class="keywordtype">void</span>)
00205 {
00206     <span class="keywordflow">return</span> userList;
00207 }
00208 
00209 <span class="keywordtype">int</span>
00210 usm_set_usmStateReference_name(<span class="keyword">struct</span> usmStateReference *ref,
00211                                <span class="keywordtype">char</span> *name, size_t name_len)
00212 {
00213     MAKE_ENTRY(<span class="keywordtype">char</span>, name, name_len, usr_name, usr_name_length);
00214 }
00215 
00216 <span class="keywordtype">int</span>
00217 usm_set_usmStateReference_engine_id(<span class="keyword">struct</span> usmStateReference *ref,
00218                                     u_char * engine_id,
00219                                     size_t engine_id_len)
00220 {
00221     MAKE_ENTRY(u_char, engine_id, engine_id_len,
00222                usr_engine_id, usr_engine_id_length);
00223 }
00224 
00225 <span class="keywordtype">int</span>
00226 usm_set_usmStateReference_auth_protocol(<span class="keyword">struct</span> usmStateReference *ref,
00227                                         oid * auth_protocol,
00228                                         size_t auth_protocol_len)
00229 {
00230     MAKE_ENTRY(oid, auth_protocol, auth_protocol_len,
00231                usr_auth_protocol, usr_auth_protocol_length);
00232 }
00233 
00234 <span class="keywordtype">int</span>
00235 usm_set_usmStateReference_auth_key(<span class="keyword">struct</span> usmStateReference *ref,
00236                                    u_char * auth_key, size_t auth_key_len)
00237 {
00238     MAKE_ENTRY(u_char, auth_key, auth_key_len,
00239                usr_auth_key, usr_auth_key_length);
00240 }
00241 
00242 <span class="keywordtype">int</span>
00243 usm_set_usmStateReference_priv_protocol(<span class="keyword">struct</span> usmStateReference *ref,
00244                                         oid * priv_protocol,
00245                                         size_t priv_protocol_len)
00246 {
00247     MAKE_ENTRY(oid, priv_protocol, priv_protocol_len,
00248                usr_priv_protocol, usr_priv_protocol_length);
00249 }
00250 
00251 <span class="keywordtype">int</span>
00252 usm_set_usmStateReference_priv_key(<span class="keyword">struct</span> usmStateReference *ref,
00253                                    u_char * priv_key, size_t priv_key_len)
00254 {
00255     MAKE_ENTRY(u_char, priv_key, priv_key_len,
00256                usr_priv_key, usr_priv_key_length);
00257 }
00258 
00259 <span class="keywordtype">int</span>
00260 usm_set_usmStateReference_sec_level(<span class="keyword">struct</span> usmStateReference *ref,
00261                                     <span class="keywordtype">int</span> sec_level)
00262 {
00263     <span class="keywordflow">if</span> (ref == NULL)
00264         <span class="keywordflow">return</span> -1;
00265     ref-&gt;usr_sec_level = sec_level;
00266     <span class="keywordflow">return</span> 0;
00267 }
00268 
00269 
00270 
00271 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
00272 <span class="comment">/*******************************************************************-o-******</span>
00273 <span class="comment"> * emergency_print</span>
00274 <span class="comment"> *</span>
00275 <span class="comment"> * Parameters:</span>
00276 <span class="comment"> *      *field</span>
00277 <span class="comment"> *       length</span>
00278 <span class="comment"> *      </span>
00279 <span class="comment"> *      This is a print routine that is solely included so that it can be</span>
00280 <span class="comment"> *      used in gdb.  Don't use it as a function, it will be pulled before</span>
00281 <span class="comment"> *      a real release of the code.</span>
00282 <span class="comment"> *</span>
00283 <span class="comment"> *      tab stop 4</span>
00284 <span class="comment"> *</span>
00285 <span class="comment"> *      XXX fflush() only works on FreeBSD; core dumps on Sun OS's</span>
00286 <span class="comment"> */</span>
00287 <span class="keywordtype">void</span>
00288 emergency_print(u_char * field, u_int length)
00289 {
00290     <span class="keywordtype">int</span>             iindex;
00291     <span class="keywordtype">int</span>             start = 0;
00292     <span class="keywordtype">int</span>             stop = 25;
00293 
00294     <span class="keywordflow">while</span> (start &lt; stop) {
00295         <span class="keywordflow">for</span> (iindex = start; iindex &lt; stop; iindex++)
00296             printf(<span class="stringliteral">"%02X "</span>, field[iindex]);
00297 
00298         printf(<span class="stringliteral">"\n"</span>);
00299         start = stop;
00300         stop = stop + 25 &lt; length ? stop + 25 : length;
00301     }
00302     fflush(0);
00303 
00304 }                               <span class="comment">/* end emergency_print() */</span>
00305 <span class="preprocessor">#endif                          </span><span class="comment">/* SNMP_TESTING_CODE */</span>
00306 
00307 
00308 <span class="comment">/*******************************************************************-o-******</span>
00309 <span class="comment"> * asn_predict_int_length</span>
00310 <span class="comment"> *</span>
00311 <span class="comment"> * Parameters:</span>
00312 <span class="comment"> *      type    (UNUSED)</span>
00313 <span class="comment"> *      number</span>
00314 <span class="comment"> *      len</span>
00315 <span class="comment"> *      </span>
00316 <span class="comment"> * Returns:</span>
00317 <span class="comment"> *      Number of bytes necessary to store the ASN.1 encoded value of 'number'.</span>
00318 <span class="comment"> *</span>
00319 <span class="comment"> *</span>
00320 <span class="comment"> *      This gives the number of bytes that the ASN.1 encoder (in asn1.c) will</span>
00321 <span class="comment"> *      use to encode a particular integer value.</span>
00322 <span class="comment"> *</span>
00323 <span class="comment"> *      Returns the length of the integer -- NOT THE HEADER!</span>
00324 <span class="comment"> *</span>
00325 <span class="comment"> *      Do this the same way as asn_build_int()...</span>
00326 <span class="comment"> */</span>
00327 <span class="keywordtype">int</span>
00328 asn_predict_int_length(<span class="keywordtype">int</span> type, <span class="keywordtype">long</span> number, size_t len)
00329 {
00330     <span class="keyword">register</span> u_long mask;
00331 
00332 
00333     <span class="keywordflow">if</span> (len != <span class="keyword">sizeof</span>(long))
00334         <span class="keywordflow">return</span> -1;
00335 
00336     mask = ((u_long) 0x1FF) &lt;&lt; ((8 * (<span class="keyword">sizeof</span>(long) - 1)) - 1);
00337     <span class="comment">/*</span>
00338 <span class="comment">     * mask is 0xFF800000 on a big-endian machine </span>
00339 <span class="comment">     */</span>
00340 
00341     <span class="keywordflow">while</span> ((((number &amp; mask) == 0) || ((number &amp; mask) == mask))
00342            &amp;&amp; len &gt; 1) {
00343         len--;
00344         number &lt;&lt;= 8;
00345     }
00346 
00347     <span class="keywordflow">return</span> len;
00348 
00349 }                               <span class="comment">/* end asn_predict_length() */</span>
00350 
00351 
00352 
00353 
00354 <span class="comment">/*******************************************************************-o-******</span>
00355 <span class="comment"> * asn_predict_length</span>
00356 <span class="comment"> *</span>
00357 <span class="comment"> * Parameters:</span>
00358 <span class="comment"> *       type</span>
00359 <span class="comment"> *      *ptr</span>
00360 <span class="comment"> *       u_char_len</span>
00361 <span class="comment"> *      </span>
00362 <span class="comment"> * Returns:</span>
00363 <span class="comment"> *      Length in bytes:        1 + &lt;n&gt; + &lt;u_char_len&gt;, where</span>
00364 <span class="comment"> *</span>
00365 <span class="comment"> *              1               For the ASN.1 type.</span>
00366 <span class="comment"> *              &lt;n&gt;             # of bytes to store length of data.</span>
00367 <span class="comment"> *              &lt;u_char_len&gt;    Length of data associated with ASN.1 type.</span>
00368 <span class="comment"> *</span>
00369 <span class="comment"> *      This gives the number of bytes that the ASN.1 encoder (in asn1.c) will</span>
00370 <span class="comment"> *      use to encode a particular integer value.  This is as broken as the</span>
00371 <span class="comment"> *      currently used encoder.</span>
00372 <span class="comment"> *</span>
00373 <span class="comment"> * XXX  How is &lt;n&gt; chosen, exactly??</span>
00374 <span class="comment"> */</span>
00375 <span class="keywordtype">int</span>
00376 asn_predict_length(<span class="keywordtype">int</span> type, u_char * ptr, size_t u_char_len)
00377 {
00378 
00379     <span class="keywordflow">if</span> (type &amp; ASN_SEQUENCE)
00380         <span class="keywordflow">return</span> 1 + 3 + u_char_len;
00381 
00382     <span class="keywordflow">if</span> (type &amp; ASN_INTEGER) {
00383         u_long          value;
00384         memcpy(&amp;value, ptr, u_char_len);
00385         u_char_len = asn_predict_int_length(type, value, u_char_len);
00386     }
00387 
00388     <span class="keywordflow">if</span> (u_char_len &lt; 0x80)
00389         <span class="keywordflow">return</span> 1 + 1 + u_char_len;
00390     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (u_char_len &lt; 0xFF)
00391         <span class="keywordflow">return</span> 1 + 2 + u_char_len;
00392     <span class="keywordflow">else</span>
00393         <span class="keywordflow">return</span> 1 + 3 + u_char_len;
00394 
00395 }                               <span class="comment">/* end asn_predict_length() */</span>
00396 
00397 
00398 
00399 
00400 <span class="comment">/*******************************************************************-o-******</span>
00401 <span class="comment"> * usm_calc_offsets</span>
00402 <span class="comment"> *</span>
00403 <span class="comment"> * Parameters:</span>
00404 <span class="comment"> *      (See list below...)</span>
00405 <span class="comment"> *      </span>
00406 <span class="comment"> * Returns:</span>
00407 <span class="comment"> *      0       On success,</span>
00408 <span class="comment"> *      -1      Otherwise.</span>
00409 <span class="comment"> *</span>
00410 <span class="comment"> *</span>
00411 <span class="comment"> *      This routine calculates the offsets into an outgoing message buffer</span>
00412 <span class="comment"> *      for the necessary values.  The outgoing buffer will generically</span>
00413 <span class="comment"> *      look like this:</span>
00414 <span class="comment"> *</span>
00415 <span class="comment"> *      SNMPv3 Message</span>
00416 <span class="comment"> *      SEQ len[11]</span>
00417 <span class="comment"> *              INT len version</span>
00418 <span class="comment"> *      Header</span>
00419 <span class="comment"> *              SEQ len</span>
00420 <span class="comment"> *                      INT len MsgID</span>
00421 <span class="comment"> *                      INT len msgMaxSize</span>
00422 <span class="comment"> *                      OST len msgFlags (OST = OCTET STRING)</span>
00423 <span class="comment"> *                      INT len msgSecurityModel</span>
00424 <span class="comment"> *      MsgSecurityParameters</span>
00425 <span class="comment"> *              [1] OST len[2]</span>
00426 <span class="comment"> *                      SEQ len[3]</span>
00427 <span class="comment"> *                              OST len msgAuthoritativeEngineID</span>
00428 <span class="comment"> *                              INT len msgAuthoritativeEngineBoots</span>
00429 <span class="comment"> *                              INT len msgAuthoritativeEngineTime</span>
00430 <span class="comment"> *                              OST len msgUserName</span>
00431 <span class="comment"> *                              OST len[4] [5] msgAuthenticationParameters</span>
00432 <span class="comment"> *                              OST len[6] [7] msgPrivacyParameters</span>
00433 <span class="comment"> *      MsgData</span>
00434 <span class="comment"> *              [8] OST len[9] [10] encryptedPDU</span>
00435 <span class="comment"> *              or</span>
00436 <span class="comment"> *              [8,10] SEQUENCE len[9] scopedPDU</span>
00437 <span class="comment"> *      [12]</span>
00438 <span class="comment"> *</span>
00439 <span class="comment"> *      The bracketed points will be needed to be identified ([x] is an index</span>
00440 <span class="comment"> *      value, len[x] means a length value).  Here is a semantic guide to them:</span>
00441 <span class="comment"> *</span>
00442 <span class="comment"> *      [1] = globalDataLen (input)</span>
00443 <span class="comment"> *      [2] = otstlen</span>
00444 <span class="comment"> *      [3] = seq_len</span>
00445 <span class="comment"> *      [4] = msgAuthParmLen (may be 0 or 12)</span>
00446 <span class="comment"> *      [5] = authParamsOffset</span>
00447 <span class="comment"> *      [6] = msgPrivParmLen (may be 0 or 8)</span>
00448 <span class="comment"> *      [7] = privParamsOffset</span>
00449 <span class="comment"> *      [8] = globalDataLen + msgSecParmLen</span>
00450 <span class="comment"> *      [9] = datalen</span>
00451 <span class="comment"> *      [10] = dataOffset</span>
00452 <span class="comment"> *      [11] = theTotalLength - the length of the header itself</span>
00453 <span class="comment"> *      [12] = theTotalLength</span>
00454 <span class="comment"> */</span>
00455 <span class="keywordtype">int</span>
00456 usm_calc_offsets(size_t globalDataLen,  <span class="comment">/* SNMPv3Message + HeaderData */</span>
00457                  <span class=
"keywordtype">int</span> secLevel, size_t secEngineIDLen, size_t secNameLen, size_t scopedPduLen,   <span class=
"comment">/* An BER encoded sequence. */</span>
00458                  u_long engineboots,    <span class="comment">/* XXX (asn1.c works in long, not int.) */</span>
00459                  <span class="keywordtype">long</span> engine_time,      <span class=
"comment">/* XXX (asn1.c works in long, not int.) */</span>
00460                  size_t * theTotalLength,       <span class="comment">/* globalDataLen + msgSecurityP. + msgData */</span>
00461                  size_t * authParamsOffset,     <span class="comment">/* Distance to auth bytes.                 */</span>
00462                  size_t * privParamsOffset,     <span class="comment">/* Distance to priv bytes.                 */</span>
00463                  size_t * dataOffset,   <span class="comment">/* Distance to scopedPdu SEQ  -or-  the</span>
00464 <span class="comment">                                         *   crypted (data) portion of msgData.    */</span>
00465                  size_t * datalen,      <span class="comment">/* Size of msgData OCTET STRING encoding.  */</span>
00466                  size_t * msgAuthParmLen,       <span class="comment">/* Size of msgAuthenticationParameters.    */</span>
00467                  size_t * msgPrivParmLen,       <span class="comment">/* Size of msgPrivacyParameters.           */</span>
00468                  size_t * otstlen,      <span class="comment">/* Size of msgSecurityP. O.S. encoding.    */</span>
00469                  size_t * seq_len,      <span class="comment">/* Size of msgSecurityP. SEQ data.         */</span>
00470                  size_t * msgSecParmLen)
00471 {                               <span class="comment">/* Size of msgSecurityP. SEQ.              */</span>
00472     <span class="keywordtype">int</span>             engIDlen,   <span class=
"comment">/* Sizes of OCTET STRING and SEQ encodings */</span>
00473                     engBtlen,   <span class="comment">/*   for fields within                     */</span>
00474                     engTmlen,   <span class="comment">/*   msgSecurityParameters portion of      */</span>
00475                     namelen,    <span class="comment">/*   SNMPv3Message.                        */</span>
00476                     authlen, privlen;
00477 
00478     <span class="comment">/*</span>
00479 <span class="comment">     * If doing authentication, msgAuthParmLen = 12 else msgAuthParmLen = 0.</span>
00480 <span class="comment">     * If doing encryption,     msgPrivParmLen = 8  else msgPrivParmLen = 0.</span>
00481 <span class="comment">     */</span>
00482     *msgAuthParmLen = (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
00483                        || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) ? 12 : 0;
00484 
00485     *msgPrivParmLen = (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) ? 8 : 0;
00486 
00487 
00488     <span class="comment">/*</span>
00489 <span class="comment">     * Calculate lengths.</span>
00490 <span class="comment">     */</span>
00491     <span class="keywordflow">if</span> ((engIDlen = asn_predict_length(ASN_OCTET_STR,
00492                                        0, secEngineIDLen)) == -1) {
00493         <span class="keywordflow">return</span> -1;
00494     }
00495 
00496     <span class="keywordflow">if</span> ((engBtlen = asn_predict_length(ASN_INTEGER,
00497                                        (u_char *) &amp; engineboots,
00498                                        <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>))) == -1) {
00499         <span class="keywordflow">return</span> -1;
00500     }
00501 
00502     <span class="keywordflow">if</span> ((engTmlen = asn_predict_length(ASN_INTEGER,
00503                                        (u_char *) &amp; engine_time,
00504                                        <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>))) == -1) {
00505         <span class="keywordflow">return</span> -1;
00506     }
00507 
00508     <span class="keywordflow">if</span> ((namelen = asn_predict_length(ASN_OCTET_STR, 0, secNameLen)) == -1) {
00509         <span class="keywordflow">return</span> -1;
00510     }
00511 
00512     <span class="keywordflow">if</span> ((authlen = asn_predict_length(ASN_OCTET_STR,
00513                                       0, *msgAuthParmLen)) == -1) {
00514         <span class="keywordflow">return</span> -1;
00515     }
00516 
00517     <span class="keywordflow">if</span> ((privlen = asn_predict_length(ASN_OCTET_STR,
00518                                       0, *msgPrivParmLen)) == -1) {
00519         <span class="keywordflow">return</span> -1;
00520     }
00521 
00522     *seq_len =
00523         engIDlen + engBtlen + engTmlen + namelen + authlen + privlen;
00524 
00525     <span class="keywordflow">if</span> ((*otstlen = asn_predict_length(ASN_SEQUENCE, 0, *seq_len)) == -1) {
00526         <span class="keywordflow">return</span> -1;
00527     }
00528 
00529     <span class="keywordflow">if</span> ((*msgSecParmLen = asn_predict_length(ASN_OCTET_STR,
00530                                              0, *otstlen)) == -1) {
00531         <span class="keywordflow">return</span> -1;
00532     }
00533 
00534     *authParamsOffset = globalDataLen + +(*msgSecParmLen - *seq_len)
00535         + engIDlen + engBtlen + engTmlen + namelen
00536         + (authlen - *msgAuthParmLen);
00537 
00538     *privParamsOffset = *authParamsOffset + *msgAuthParmLen
00539         + (privlen - *msgPrivParmLen);
00540 
00541 
00542     <span class="comment">/*</span>
00543 <span class="comment">     * Compute the size of the plaintext.  Round up to account for cipher</span>
00544 <span class="comment">     * block size, if necessary.</span>
00545 <span class="comment">     *</span>
00546 <span class="comment">     * XXX  This is hardwired for 1DES... If scopedPduLen is already</span>
00547 <span class="comment">     *      a multiple of 8, then *add* 8 more; otherwise, round up</span>
00548 <span class="comment">     *      to the next multiple of 8.</span>
00549 <span class="comment">     *</span>
00550 <span class="comment">     * FIX  Calculation of encrypted portion of msgData and consequent</span>
00551 <span class="comment">     *      setting and sanity checking of theTotalLength, et al. should</span>
00552 <span class="comment">     *      occur *after* encryption has taken place.</span>
00553 <span class="comment">     */</span>
00554     <span class="keywordflow">if</span> (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
00555         scopedPduLen = ROUNDUP8(scopedPduLen);
00556 
00557         <span class="keywordflow">if</span> ((*datalen =
00558              asn_predict_length(ASN_OCTET_STR, 0, scopedPduLen)) == -1) {
00559             <span class="keywordflow">return</span> -1;
00560         }
00561     } <span class="keywordflow">else</span> {
00562         *datalen = scopedPduLen;
00563     }
00564 
00565     *dataOffset = globalDataLen + *msgSecParmLen +
00566         (*datalen - scopedPduLen);
00567     *theTotalLength = globalDataLen + *msgSecParmLen + *datalen;
00568 
00569     <span class="keywordflow">return</span> 0;
00570 
00571 }                               <span class="comment">/* end usm_calc_offsets() */</span>
00572 
00573 
00574 
00575 
00576 
00577 <span class="preprocessor">#ifndef DISABLE_DES</span>
00578 <span class="comment">/*******************************************************************-o-******</span>
00579 <span class="comment"> * usm_set_salt</span>
00580 <span class="comment"> *</span>
00581 <span class="comment"> * Parameters:</span>
00582 <span class="comment"> *      *iv               (O)   Buffer to contain IV.</span>
00583 <span class="comment"> *      *iv_length        (O)   Length of iv.</span>
00584 <span class="comment"> *      *priv_salt        (I)   Salt portion of private key.</span>
00585 <span class="comment"> *       priv_salt_length (I)   Length of priv_salt.</span>
00586 <span class="comment"> *      *msgSalt          (I/O) Pointer salt portion of outgoing msg buffer.</span>
00587 <span class="comment"> *      </span>
00588 <span class="comment"> * Returns:</span>
00589 <span class="comment"> *      0       On success,</span>
00590 <span class="comment"> *      -1      Otherwise.</span>
00591 <span class="comment"> *</span>
00592 <span class="comment"> *      Determine the initialization vector for the DES-CBC encryption.</span>
00593 <span class="comment"> *      (Cf. RFC 2274, 8.1.1.1.)</span>
00594 <span class="comment"> *</span>
00595 <span class="comment"> *      iv is defined as the concatenation of engineBoots and the</span>
00596 <span class="comment"> *              salt integer.</span>
00597 <span class="comment"> *      The salt integer is incremented.</span>
00598 <span class="comment"> *      The resulting salt is copied into the msgSalt buffer.</span>
00599 <span class="comment"> *      The result of the concatenation is then XORed with the salt</span>
00600 <span class="comment"> *              portion of the private key (last 8 bytes).</span>
00601 <span class="comment"> *      The IV result is returned individually for further use.</span>
00602 <span class="comment"> */</span>
00603 <span class="keywordtype">int</span>
00604 usm_set_salt(u_char * iv,
00605              size_t * iv_length,
00606              u_char * priv_salt, size_t priv_salt_length, u_char * msgSalt)
00607 {
00608     size_t          propersize_salt = BYTESIZE(USM_DES_SALT_LENGTH);
00609     <span class="keywordtype">int</span>             net_boots;
00610     <span class="keywordtype">int</span>             net_salt_int;
00611     <span class="comment">/*</span>
00612 <span class="comment">     * net_* should be encoded in network byte order.  XXX  Why?</span>
00613 <span class="comment">     */</span>
00614     <span class="keywordtype">int</span>             iindex;
00615 
00616 
00617     <span class="comment">/*</span>
00618 <span class="comment">     * Sanity check.</span>
00619 <span class="comment">     */</span>
00620     <span class="keywordflow">if</span> (!iv || !iv_length || !priv_salt || (*iv_length != propersize_salt)
00621         || (priv_salt_length &lt; propersize_salt)) {
00622         <span class="keywordflow">return</span> -1;
00623     }
00624 
00625 
00626     net_boots = htonl(snmpv3_local_snmpEngineBoots());
00627     net_salt_int = htonl(salt_integer);
00628 
00629     salt_integer += 1;
00630 
00631     memcpy(iv, &amp;net_boots, propersize_salt / 2);
00632     memcpy(iv + (propersize_salt / 2), &amp;net_salt_int, propersize_salt / 2);
00633 
00634     <span class="keywordflow">if</span> (msgSalt)
00635         memcpy(msgSalt, iv, propersize_salt);
00636 
00637 
00638     <span class="comment">/*</span>
00639 <span class="comment">     * Turn the salt into an IV: XOR &lt;boots, salt_int&gt; with salt</span>
00640 <span class="comment">     * portion of priv_key.</span>
00641 <span class="comment">     */</span>
00642     <span class="keywordflow">for</span> (iindex = 0; iindex &lt; (int) propersize_salt; iindex++)
00643         iv[iindex] ^= priv_salt[iindex];
00644 
00645 
00646     <span class="keywordflow">return</span> 0;
00647 
00648 }                               <span class="comment">/* end usm_set_salt() */</span>
00649 <span class="preprocessor">#endif</span>
00650 
00651 <span class="preprocessor">#ifdef HAVE_AES</span>
00652 <span class="comment">/*******************************************************************-o-******</span>
00653 <span class="comment"> * usm_set_aes_iv</span>
00654 <span class="comment"> *</span>
00655 <span class="comment"> * Parameters:</span>
00656 <span class="comment"> *      *iv               (O)   Buffer to contain IV.</span>
00657 <span class="comment"> *      *iv_length        (O)   Length of iv.</span>
00658 <span class="comment"> *      net_boots         (I)   the network byte order of the authEng boots val</span>
00659 <span class="comment"> *      net_time         (I)   the network byte order of the authEng time val</span>
00660 <span class="comment"> *      *salt             (O)   A buffer for the outgoing salt (= 8 bytes of iv)</span>
00661 <span class="comment"> *      </span>
00662 <span class="comment"> * Returns:</span>
00663 <span class="comment"> *      0       On success,</span>
00664 <span class="comment"> *      -1      Otherwise.</span>
00665 <span class="comment"> *</span>
00666 <span class="comment"> *      Determine the initialization vector for AES encryption.</span>
00667 <span class="comment"> *      (draft-blumenthal-aes-usm-03.txt, 3.1.2.2)</span>
00668 <span class="comment"> *</span>
00669 <span class="comment"> *      iv is defined as the concatenation of engineBoots, engineTime</span>
00670 <span class="comment">        and a 64 bit salt-integer.</span>
00671 <span class="comment"> *      The 64 bit salt integer is incremented.</span>
00672 <span class="comment"> *      The resulting salt is copied into the salt buffer.</span>
00673 <span class="comment"> *      The IV result is returned individually for further use.</span>
00674 <span class="comment"> */</span>
00675 <span class="keywordtype">int</span>
00676 usm_set_aes_iv(u_char * iv,
00677                size_t * iv_length,
00678                u_int net_boots,
00679                u_int net_time,
00680                u_char * salt)
00681 {
00682     <span class="comment">/*</span>
00683 <span class="comment">     * net_* should be encoded in network byte order.</span>
00684 <span class="comment">     */</span>
00685     <span class="keywordtype">int</span>             net_salt_int1, net_salt_int2;
00686 <span class="preprocessor">#define PROPER_AES_IV_SIZE 64</span>
00687 
00688     <span class="comment">/*</span>
00689 <span class="comment">     * Sanity check.</span>
00690 <span class="comment">     */</span>
00691     <span class="keywordflow">if</span> (!iv || !iv_length) {
00692         <span class="keywordflow">return</span> -1;
00693     }
00694 
00695     net_salt_int1 = htonl(salt_integer64_1);
00696     net_salt_int2 = htonl(salt_integer64_2);
00697 
00698     <span class="keywordflow">if</span> ((salt_integer64_2 += 1) == 0)
00699         salt_integer64_2 += 1;
00700     
00701     <span class="comment">/* XXX: warning: hard coded proper lengths */</span>
00702     memcpy(iv, &amp;net_boots, 4);
00703     memcpy(iv+4, &amp;net_time, 4);
00704     memcpy(iv+8, &amp;net_salt_int1, 4);
00705     memcpy(iv+12, &amp;net_salt_int2, 4);
00706 
00707     memcpy(salt, iv+8, 8); <span class="comment">/* only copy the needed portion */</span>
00708     <span class="keywordflow">return</span> 0;
00709 }                               <span class="comment">/* end usm_set_salt() */</span>
00710 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_AES */</span>
00711 
00712 <span class="keywordtype">int</span>
00713 usm_secmod_generate_out_msg(<span class="keyword">struct</span> snmp_secmod_outgoing_params *parms)
00714 {
00715     <span class="keywordflow">if</span> (!parms)
00716         <span class="keywordflow">return</span> SNMPERR_GENERR;
00717 
00718     <span class="keywordflow">return</span> usm_generate_out_msg(parms-&gt;msgProcModel,
00719                                 parms-&gt;globalData, parms-&gt;globalDataLen,
00720                                 parms-&gt;maxMsgSize, parms-&gt;secModel,
00721                                 parms-&gt;secEngineID, parms-&gt;secEngineIDLen,
00722                                 parms-&gt;secName, parms-&gt;secNameLen,
00723                                 parms-&gt;secLevel,
00724                                 parms-&gt;scopedPdu, parms-&gt;scopedPduLen,
00725                                 parms-&gt;secStateRef,
00726                                 parms-&gt;secParams, parms-&gt;secParamsLen,
00727                                 parms-&gt;wholeMsg, parms-&gt;wholeMsgLen);
00728 }
00729 
00730 <span class="comment">/*******************************************************************-o-******</span>
00731 <span class="comment"> * usm_generate_out_msg</span>
00732 <span class="comment"> *</span>
00733 <span class="comment"> * Parameters:</span>
00734 <span class="comment"> *      (See list below...)</span>
00735 <span class="comment"> *      </span>
00736 <span class="comment"> * Returns:</span>
00737 <span class="comment"> *      SNMPERR_SUCCESS                 On success.</span>
00738 <span class="comment"> *      SNMPERR_USM_AUTHENTICATIONFAILURE</span>
00739 <span class="comment"> *      SNMPERR_USM_ENCRYPTIONERROR</span>
00740 <span class="comment"> *      SNMPERR_USM_GENERICERROR</span>
00741 <span class="comment"> *      SNMPERR_USM_UNKNOWNSECURITYNAME</span>
00742 <span class="comment"> *      SNMPERR_USM_GENERICERROR</span>
00743 <span class="comment"> *      SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL</span>
00744 <span class="comment"> *      </span>
00745 <span class="comment"> *</span>
00746 <span class="comment"> * Generates an outgoing message.</span>
00747 <span class="comment"> *</span>
00748 <span class="comment"> * XXX  Beware of misnomers!</span>
00749 <span class="comment"> */</span>
00750 <span class="keywordtype">int</span>
00751 usm_generate_out_msg(<span class="keywordtype">int</span> msgProcModel,  <span class="comment">/* (UNUSED) */</span>
00752                      u_char * globalData,       <span class="comment">/* IN */</span>
00753                      <span class="comment">/*</span>
00754 <span class="comment">                      * Pointer to msg header data will point to the beginning</span>
00755 <span class="comment">                      * * of the entire packet buffer to be transmitted on wire,</span>
00756 <span class="comment">                      * * memory will be contiguous with secParams, typically</span>
00757 <span class="comment">                      * * this pointer will be passed back as beginning of</span>
00758 <span class="comment">                      * * wholeMsg below.  asn seq. length is updated w/ new length.</span>
00759 <span class="comment">                      * *</span>
00760 <span class="comment">                      * * While this points to a buffer that should be big enough</span>
00761 <span class="comment">                      * * for the whole message, only the first two parts</span>
00762 <span class="comment">                      * * of the message are completed, namely SNMPv3Message and</span>
00763 <span class="comment">                      * * HeaderData.  globalDataLen (next parameter) represents</span>
00764 <span class="comment">                      * * the length of these two completed parts.</span>
00765 <span class="comment">                      */</span>
00766                      size_t globalDataLen,      <span class="comment">/* IN - Length of msg header data.      */</span>
00767                      <span class="keywordtype">int</span> maxMsgSize,    <span class="comment">/* (UNUSED) */</span>
00768                      <span class="keywordtype">int</span> secModel,      <span class="comment">/* (UNUSED) */</span>
00769                      u_char * secEngineID,      <span class="comment">/* IN - Pointer snmpEngineID.           */</span>
00770                      size_t secEngineIDLen,     <span class="comment">/* IN - SnmpEngineID length.            */</span>
00771                      <span class="keywordtype">char</span> *secName,     <span class=
"comment">/* IN - Pointer to securityName.        */</span>
00772                      size_t secNameLen, <span class="comment">/* IN - SecurityName length.            */</span>
00773                      <span class="keywordtype">int</span> secLevel,      <span class=
"comment">/* IN - AuthNoPriv, authPriv etc.       */</span>
00774                      u_char * scopedPdu,        <span class="comment">/* IN */</span>
00775                      <span class="comment">/*</span>
00776 <span class="comment">                      * Pointer to scopedPdu will be encrypted by USM if needed</span>
00777 <span class="comment">                      * * and written to packet buffer immediately following</span>
00778 <span class="comment">                      * * securityParameters, entire msg will be authenticated by</span>
00779 <span class="comment">                      * * USM if needed.</span>
00780 <span class="comment">                      */</span>
00781                      size_t scopedPduLen,       <span class="comment">/* IN - scopedPdu length. */</span>
00782                      <span class="keywordtype">void</span> *secStateRef, <span class="comment">/* IN */</span>
00783                      <span class="comment">/*</span>
00784 <span class="comment">                      * secStateRef, pointer to cached info provided only for</span>
00785 <span class="comment">                      * * Response, otherwise NULL.</span>
00786 <span class="comment">                      */</span>
00787                      u_char * secParams,        <span class="comment">/* OUT */</span>
00788                      <span class="comment">/*</span>
00789 <span class="comment">                      * BER encoded securityParameters pointer to offset within</span>
00790 <span class="comment">                      * * packet buffer where secParams should be written, the</span>
00791 <span class="comment">                      * * entire BER encoded OCTET STRING (including header) is</span>
00792 <span class="comment">                      * * written here by USM secParams = globalData +</span>
00793 <span class="comment">                      * * globalDataLen.</span>
00794 <span class="comment">                      */</span>
00795                      size_t * secParamsLen,     <span class="comment">/* IN/OUT - Len available, len returned. */</span>
00796                      u_char ** wholeMsg,        <span class="comment">/* OUT */</span>
00797                      <span class="comment">/*</span>
00798 <span class="comment">                      * Complete authenticated/encrypted message - typically</span>
00799 <span class="comment">                      * * the pointer to start of packet buffer provided in</span>
00800 <span class="comment">                      * * globalData is returned here, could also be a separate</span>
00801 <span class="comment">                      * * buffer.</span>
00802 <span class="comment">                      */</span>
00803                      size_t * wholeMsgLen)
00804 {                               <span class="comment">/* IN/OUT - Len available, len returned. */</span>
00805     size_t          otstlen;
00806     size_t          seq_len;
00807     size_t          msgAuthParmLen;
00808     size_t          msgPrivParmLen;
00809     size_t          msgSecParmLen;
00810     size_t          authParamsOffset;
00811     size_t          privParamsOffset;
00812     size_t          datalen;
00813     size_t          dataOffset;
00814     size_t          theTotalLength;
00815 
00816     u_char         *ptr;
00817     size_t          ptr_len;
00818     size_t          remaining;
00819     size_t          offSet;
00820     u_int           boots_uint;
00821     u_int           time_uint;
00822     <span class="keywordtype">long</span>            boots_long;
00823     <span class="keywordtype">long</span>            time_long;
00824 
00825     <span class="comment">/*</span>
00826 <span class="comment">     * Indirection because secStateRef values override parameters.</span>
00827 <span class="comment">     * </span>
00828 <span class="comment">     * None of these are to be free'd - they are either pointing to</span>
00829 <span class="comment">     * what's in the secStateRef or to something either in the</span>
00830 <span class="comment">     * actual prarmeter list or the user list.</span>
00831 <span class="comment">     */</span>
00832 
00833     <span class="keywordtype">char</span>           *theName = NULL;
00834     u_int           theNameLength = 0;
00835     u_char         *theEngineID = NULL;
00836     u_int           theEngineIDLength = 0;
00837     u_char         *theAuthKey = NULL;
00838     u_int           theAuthKeyLength = 0;
00839     <span class="keyword">const</span> oid      *theAuthProtocol = NULL;
00840     u_int           theAuthProtocolLength = 0;
00841     u_char         *thePrivKey = NULL;
00842     u_int           thePrivKeyLength = 0;
00843     <span class="keyword">const</span> oid      *thePrivProtocol = NULL;
00844     u_int           thePrivProtocolLength = 0;
00845     <span class="keywordtype">int</span>             theSecLevel = 0;    <span class=
"comment">/* No defined const for bad</span>
00846 <span class="comment">                                         * value (other then err).</span>
00847 <span class="comment">                                         */</span>
00848 
00849     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"USM processing has begun.\n"</span>));
00850 
00851     <span class="keywordflow">if</span> (secStateRef != NULL) {
00852         <span class="comment">/*</span>
00853 <span class="comment">         * To hush the compiler for now.  XXX </span>
00854 <span class="comment">         */</span>
00855         <span class="keyword">struct </span>usmStateReference *ref
00856             = (<span class="keyword">struct </span>usmStateReference *) secStateRef;
00857 
00858         theName = ref-&gt;usr_name;
00859         theNameLength = ref-&gt;usr_name_length;
00860         theEngineID = ref-&gt;usr_engine_id;
00861         theEngineIDLength = ref-&gt;usr_engine_id_length;
00862 
00863         <span class="keywordflow">if</span> (!theEngineIDLength) {
00864             theEngineID = secEngineID;
00865             theEngineIDLength = secEngineIDLen;
00866         }
00867 
00868         theAuthProtocol = ref-&gt;usr_auth_protocol;
00869         theAuthProtocolLength = ref-&gt;usr_auth_protocol_length;
00870         theAuthKey = ref-&gt;usr_auth_key;
00871         theAuthKeyLength = ref-&gt;usr_auth_key_length;
00872         thePrivProtocol = ref-&gt;usr_priv_protocol;
00873         thePrivProtocolLength = ref-&gt;usr_priv_protocol_length;
00874         thePrivKey = ref-&gt;usr_priv_key;
00875         thePrivKeyLength = ref-&gt;usr_priv_key_length;
00876         theSecLevel = ref-&gt;usr_sec_level;
00877     }
00878 
00879     <span class="comment">/*</span>
00880 <span class="comment">     * Identify the user record.</span>
00881 <span class="comment">     */</span>
00882     <span class="keywordflow">else</span> {
00883         <span class="keyword">struct </span>usmUser *user;
00884 
00885         <span class="comment">/*</span>
00886 <span class="comment">         * we do allow an unknown user name for</span>
00887 <span class="comment">         * unauthenticated requests. </span>
00888 <span class="comment">         */</span>
00889         <span class="keywordflow">if</span> ((user = usm_get_user(secEngineID, secEngineIDLen, secName))
00890             == NULL &amp;&amp; secLevel != SNMP_SEC_LEVEL_NOAUTH) {
00891             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Unknown User(%s)\n"</span>, secName));
00892             usm_free_usmStateReference(secStateRef);
00893             <span class="keywordflow">return</span> SNMPERR_USM_UNKNOWNSECURITYNAME;
00894         }
00895 
00896         theName = secName;
00897         theNameLength = secNameLen;
00898         theEngineID = secEngineID;
00899         theSecLevel = secLevel;
00900         theEngineIDLength = secEngineIDLen;
00901         <span class="keywordflow">if</span> (user) {
00902             theAuthProtocol = user-&gt;authProtocol;
00903             theAuthProtocolLength = user-&gt;authProtocolLen;
00904             theAuthKey = user-&gt;authKey;
00905             theAuthKeyLength = user-&gt;authKeyLen;
00906             thePrivProtocol = user-&gt;privProtocol;
00907             thePrivProtocolLength = user-&gt;privProtocolLen;
00908             thePrivKey = user-&gt;privKey;
00909             thePrivKeyLength = user-&gt;privKeyLen;
00910         } <span class="keywordflow">else</span> {
00911             <span class="comment">/*</span>
00912 <span class="comment">             * unknown users can not do authentication (obviously) </span>
00913 <span class="comment">             */</span>
00914             theAuthProtocol = usmNoAuthProtocol;
00915             theAuthProtocolLength =
00916                 <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class="keyword">sizeof</span>(oid);
00917             theAuthKey = NULL;
00918             theAuthKeyLength = 0;
00919             thePrivProtocol = usmNoPrivProtocol;
00920             thePrivProtocolLength =
00921                 <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid);
00922             thePrivKey = NULL;
00923             thePrivKeyLength = 0;
00924         }
00925     }                           <span class="comment">/* endif -- secStateRef==NULL */</span>
00926 
00927 
00928     <span class="comment">/*</span>
00929 <span class="comment">     * From here to the end of the function, avoid reference to</span>
00930 <span class="comment">     * secName, secEngineID, secLevel, and associated lengths.</span>
00931 <span class="comment">     */</span>
00932 
00933 
00934     <span class="comment">/*</span>
00935 <span class="comment">     * Check to see if the user can use the requested sec services.</span>
00936 <span class="comment">     */</span>
00937     <span class="keywordflow">if</span> (usm_check_secLevel_vs_protocols(theSecLevel,
00938                                         theAuthProtocol,
00939                                         theAuthProtocolLength,
00940                                         thePrivProtocol,
00941                                         thePrivProtocolLength) == 1) {
00942         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Unsupported Security Level (%d)\n"</span>,
00943                     theSecLevel));
00944         usm_free_usmStateReference(secStateRef);
00945         <span class="keywordflow">return</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;
00946     }
00947 
00948 
00949     <span class="comment">/*</span>
00950 <span class="comment">     * Retrieve the engine information.</span>
00951 <span class="comment">     *</span>
00952 <span class="comment">     * XXX  No error is declared in the EoP when sending messages to</span>
00953 <span class="comment">     *      unknown engines, processing continues w/ boots/time == (0,0).</span>
00954 <span class="comment">     */</span>
00955     <span class="keywordflow">if</span> (get_enginetime(theEngineID, theEngineIDLength,
00956                        &amp;boots_uint, &amp;time_uint, FALSE) == -1) {
00957         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>, <span class=
"stringliteral">"Failed to find engine data."</span>));
00958     }
00959 
00960     boots_long = boots_uint;
00961     time_long = time_uint;
00962 
00963 
00964     <span class="comment">/*</span>
00965 <span class="comment">     * Set up the Offsets.</span>
00966 <span class="comment">     */</span>
00967     <span class="keywordflow">if</span> (usm_calc_offsets(globalDataLen, theSecLevel, theEngineIDLength,
00968                          theNameLength, scopedPduLen, boots_long,
00969                          time_long, &amp;theTotalLength, &amp;authParamsOffset,
00970                          &amp;privParamsOffset, &amp;dataOffset, &amp;datalen,
00971                          &amp;msgAuthParmLen, &amp;msgPrivParmLen, &amp;otstlen,
00972                          &amp;seq_len, &amp;msgSecParmLen) == -1) {
00973         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Failed calculating offsets.\n"</span>));
00974         usm_free_usmStateReference(secStateRef);
00975         <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
00976     }
00977 
00978     <span class="comment">/*</span>
00979 <span class="comment">     * So, we have the offsets for the three parts that need to be</span>
00980 <span class="comment">     * determined, and an overall length.  Now we need to make</span>
00981 <span class="comment">     * sure all of this would fit in the outgoing buffer, and</span>
00982 <span class="comment">     * whether or not we need to make a new buffer, etc.</span>
00983 <span class="comment">     */</span>
00984 
00985 
00986     <span class="comment">/*</span>
00987 <span class="comment">     * Set wholeMsg as a pointer to globalData.  Sanity check for</span>
00988 <span class="comment">     * the proper size.</span>
00989 <span class="comment">     * </span>
00990 <span class="comment">     * Mark workspace in the message with bytes of all 1's to make it</span>
00991 <span class="comment">     * easier to find mistakes in raw message dumps.</span>
00992 <span class="comment">     */</span>
00993     ptr = *wholeMsg = globalData;
00994     <span class="keywordflow">if</span> (theTotalLength &gt; *wholeMsgLen) {
00995         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Message won't fit in buffer.\n"</span>));
00996         usm_free_usmStateReference(secStateRef);
00997         <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
00998     }
00999 
01000     ptr_len = *wholeMsgLen = theTotalLength;
01001 
01002 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
01003     memset(&amp;ptr[globalDataLen], 0xFF, theTotalLength - globalDataLen);
01004 <span class="preprocessor">#endif                          </span><span class="comment">/* SNMP_TESTING_CODE */</span>
01005 
01006     <span class="comment">/*</span>
01007 <span class="comment">     * Do the encryption.</span>
01008 <span class="comment">     */</span>
01009     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
01010         size_t          encrypted_length = theTotalLength - dataOffset;
01011         size_t          salt_length = BYTESIZE(USM_MAX_SALT_LENGTH);
01012         u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];
01013 
01014         <span class="comment">/*</span>
01015 <span class="comment">         * XXX  Hardwired to seek into a 1DES private key!</span>
01016 <span class="comment">         */</span>
01017 <span class="preprocessor">#ifdef HAVE_AES</span>
01018         <span class="keywordflow">if</span> (ISTRANSFORM(thePrivProtocol, AESPriv)) {
01019             <span class="keywordflow">if</span> (!thePrivKey ||
01020                 usm_set_aes_iv(salt, &amp;salt_length,
01021                                htonl(boots_uint), htonl(time_uint),
01022                                &amp;ptr[privParamsOffset]) == -1) {
01023                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Can't set AES iv.\n"</span>));
01024                 usm_free_usmStateReference(secStateRef);
01025                 <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
01026             }
01027         } 
01028 <span class="preprocessor">#endif</span>
01029 <span class="preprocessor">#ifndef DISABLE_DES</span>
01030         <span class="keywordflow">if</span> (ISTRANSFORM(thePrivProtocol, DESPriv)) {
01031             <span class="keywordflow">if</span> (!thePrivKey ||
01032                 (usm_set_salt(salt, &amp;salt_length,
01033                               thePrivKey + 8, thePrivKeyLength - 8,
01034                               &amp;ptr[privParamsOffset])
01035                  == -1)) {
01036                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Can't set DES-CBC salt.\n"</span>));
01037                 usm_free_usmStateReference(secStateRef);
01038                 <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
01039             }
01040         }
01041 <span class="preprocessor">#endif</span>
01042 
01043         <span class="keywordflow">if</span> (sc_encrypt(thePrivProtocol, thePrivProtocolLength,
01044                        thePrivKey, thePrivKeyLength,
01045                        salt, salt_length,
01046                        scopedPdu, scopedPduLen,
01047                        &amp;ptr[dataOffset], &amp;encrypted_length)
01048             != SNMP_ERR_NOERROR) {
01049             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"encryption error.\n"</span>));
01050             usm_free_usmStateReference(secStateRef);
01051             <span class="keywordflow">return</span> SNMPERR_USM_ENCRYPTIONERROR;
01052         }
01053 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
01054         <span class="keywordflow">if</span> (debug_is_token_registered(<span class=
"stringliteral">"usm/dump"</span>) == SNMPERR_SUCCESS) {
01055             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"This data was encrypted:"</span>,
01056                        scopedPdu, scopedPduLen);
01057             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"salt + Encrypted form:"</span>,
01058                        salt, salt_length);
01059             dump_chunk(<span class="stringliteral">"usm/dump"</span>, NULL,
01060                        &amp;ptr[dataOffset], encrypted_length);
01061             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class="stringliteral">"*wholeMsg:"</span>,
01062                        *wholeMsg, theTotalLength);
01063         }
01064 <span class="preprocessor">#endif</span>
01065 
01066 
01067         ptr = *wholeMsg;
01068         ptr_len = *wholeMsgLen = theTotalLength;
01069 
01070 
01071         <span class="comment">/*</span>
01072 <span class="comment">         * XXX  Sanity check for salt length should be moved up</span>
01073 <span class="comment">         *      under usm_calc_offsets() or tossed.</span>
01074 <span class="comment">         */</span>
01075         <span class="keywordflow">if</span> ((encrypted_length != (theTotalLength - dataOffset))
01076             || (salt_length != msgPrivParmLen)) {
01077             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"encryption length error.\n"</span>));
01078             usm_free_usmStateReference(secStateRef);
01079             <span class="keywordflow">return</span> SNMPERR_USM_ENCRYPTIONERROR;
01080         }
01081 
01082         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Encryption successful.\n"</span>));
01083     }
01084 
01085     <span class="comment">/*</span>
01086 <span class="comment">     * No encryption for you!</span>
01087 <span class="comment">     */</span>
01088     <span class="keywordflow">else</span> {
01089         memcpy(&amp;ptr[dataOffset], scopedPdu, scopedPduLen);
01090     }
01091 
01092 
01093 
01094     <span class="comment">/*</span>
01095 <span class="comment">     * Start filling in the other fields (in prep for authentication).</span>
01096 <span class="comment">     * </span>
01097 <span class="comment">     * offSet is an octet string header, which is different from all</span>
01098 <span class="comment">     * the other headers.</span>
01099 <span class="comment">     */</span>
01100     remaining = ptr_len - globalDataLen;
01101 
01102     offSet = ptr_len - remaining;
01103     asn_build_header(&amp;ptr[offSet], &amp;remaining,
01104                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
01105                                ASN_OCTET_STR), otstlen);
01106 
01107     offSet = ptr_len - remaining;
01108     asn_build_sequence(&amp;ptr[offSet], &amp;remaining,
01109                        (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR), seq_len);
01110 
01111     offSet = ptr_len - remaining;
01112     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineID"</span>);
01113     asn_build_string(&amp;ptr[offSet], &amp;remaining,
01114                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
01115                                ASN_OCTET_STR), theEngineID,
01116                      theEngineIDLength);
01117     DEBUGINDENTLESS();
01118 
01119     offSet = ptr_len - remaining;
01120     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineBoots"</span>);
01121     asn_build_int(&amp;ptr[offSet], &amp;remaining,
01122                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
01123                   &amp;boots_long, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
01124     DEBUGINDENTLESS();
01125 
01126     offSet = ptr_len - remaining;
01127     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineTime"</span>);
01128     asn_build_int(&amp;ptr[offSet], &amp;remaining,
01129                   (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER),
01130                   &amp;time_long, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
01131     DEBUGINDENTLESS();
01132 
01133     offSet = ptr_len - remaining;
01134     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgUserName"</span>);
01135     asn_build_string(&amp;ptr[offSet], &amp;remaining,
01136                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
01137                                ASN_OCTET_STR), (u_char *) theName,
01138                      theNameLength);
01139     DEBUGINDENTLESS();
01140 
01141 
01142     <span class="comment">/*</span>
01143 <span class="comment">     * Note: if there is no authentication being done,</span>
01144 <span class="comment">     * msgAuthParmLen is 0, and there is no effect (other than</span>
01145 <span class="comment">     * inserting a zero-length header) of the following</span>
01146 <span class="comment">     * statements.</span>
01147 <span class="comment">     */</span>
01148 
01149     offSet = ptr_len - remaining;
01150     asn_build_header(&amp;ptr[offSet],
01151                      &amp;remaining,
01152                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
01153                                ASN_OCTET_STR), msgAuthParmLen);
01154 
01155     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
01156         || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
01157         offSet = ptr_len - remaining;
01158         memset(&amp;ptr[offSet], 0, msgAuthParmLen);
01159     }
01160 
01161     remaining -= msgAuthParmLen;
01162 
01163 
01164     <span class="comment">/*</span>
01165 <span class="comment">     * Note: if there is no encryption being done, msgPrivParmLen</span>
01166 <span class="comment">     * is 0, and there is no effect (other than inserting a</span>
01167 <span class="comment">     * zero-length header) of the following statements.</span>
01168 <span class="comment">     */</span>
01169 
01170     offSet = ptr_len - remaining;
01171     asn_build_header(&amp;ptr[offSet],
01172                      &amp;remaining,
01173                      (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
01174                                ASN_OCTET_STR), msgPrivParmLen);
01175 
01176     remaining -= msgPrivParmLen;        <span class="comment">/* Skipping the IV already there. */</span>
01177 
01178 
01179     <span class="comment">/*</span>
01180 <span class="comment">     * For privacy, need to add the octet string header for it.</span>
01181 <span class="comment">     */</span>
01182     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
01183         offSet = ptr_len - remaining;
01184         asn_build_header(&amp;ptr[offSet],
01185                          &amp;remaining,
01186                          (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
01187                                    ASN_OCTET_STR),
01188                          theTotalLength - dataOffset);
01189     }
01190 
01191 
01192     <span class="comment">/*</span>
01193 <span class="comment">     * Adjust overall length and store it as the first SEQ length</span>
01194 <span class="comment">     * of the SNMPv3Message.</span>
01195 <span class="comment">     *</span>
01196 <span class="comment">     * FIX  4 is a magic number!</span>
01197 <span class="comment">     */</span>
01198     remaining = theTotalLength;
01199     asn_build_sequence(ptr, &amp;remaining,
01200                        (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
01201                        theTotalLength - 4);
01202 
01203 
01204     <span class="comment">/*</span>
01205 <span class="comment">     * Now, time to consider / do authentication.</span>
01206 <span class="comment">     */</span>
01207     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
01208         || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
01209         size_t          temp_sig_len = msgAuthParmLen;
01210         u_char         *temp_sig = (u_char *) malloc(temp_sig_len);
01211 
01212         <span class="keywordflow">if</span> (temp_sig == NULL) {
01213             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"Out of memory.\n"</span>));
01214             usm_free_usmStateReference(secStateRef);
01215             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
01216         }
01217 
01218         <span class="keywordflow">if</span> (sc_generate_keyed_hash(theAuthProtocol, theAuthProtocolLength,
01219                                    theAuthKey, theAuthKeyLength,
01220                                    ptr, ptr_len, temp_sig, &amp;temp_sig_len)
01221             != SNMP_ERR_NOERROR) {
01222             <span class="comment">/*</span>
01223 <span class="comment">             * FIX temp_sig_len defined?!</span>
01224 <span class="comment">             */</span>
01225             <a class="code" href="group__util.html#ga40">SNMP_ZERO</a>(temp_sig, temp_sig_len);
01226             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(temp_sig);
01227             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"Signing failed.\n"</span>));
01228             usm_free_usmStateReference(secStateRef);
01229             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
01230         }
01231 
01232         <span class="keywordflow">if</span> (temp_sig_len != msgAuthParmLen) {
01233             <a class="code" href="group__util.html#ga40">SNMP_ZERO</a>(temp_sig, temp_sig_len);
01234             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(temp_sig);
01235             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Signing lengths failed.\n"</span>));
01236             usm_free_usmStateReference(secStateRef);
01237             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
01238         }
01239 
01240         memcpy(&amp;ptr[authParamsOffset], temp_sig, msgAuthParmLen);
01241 
01242         <a class="code" href="group__util.html#ga40">SNMP_ZERO</a>(temp_sig, temp_sig_len);
01243         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(temp_sig);
01244 
01245     }
01246 
01247     <span class="comment">/*</span>
01248 <span class="comment">     * endif -- create keyed hash </span>
01249 <span class="comment">     */</span>
01250     usm_free_usmStateReference(secStateRef);
01251 
01252     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"USM processing completed.\n"</span>));
01253 
01254     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
01255 
01256 }                               <span class="comment">/* end usm_generate_out_msg() */</span>
01257 
01258 <span class="preprocessor">#ifdef USE_REVERSE_ASNENCODING</span>
01259 <span class="keywordtype">int</span>
01260 usm_secmod_rgenerate_out_msg(<span class="keyword">struct</span> snmp_secmod_outgoing_params *parms)
01261 {
01262     <span class="keywordflow">if</span> (!parms)
01263         <span class="keywordflow">return</span> SNMPERR_GENERR;
01264 
01265     <span class="keywordflow">return</span> usm_rgenerate_out_msg(parms-&gt;msgProcModel,
01266                                  parms-&gt;globalData, parms-&gt;globalDataLen,
01267                                  parms-&gt;maxMsgSize, parms-&gt;secModel,
01268                                  parms-&gt;secEngineID, parms-&gt;secEngineIDLen,
01269                                  parms-&gt;secName, parms-&gt;secNameLen,
01270                                  parms-&gt;secLevel,
01271                                  parms-&gt;scopedPdu, parms-&gt;scopedPduLen,
01272                                  parms-&gt;secStateRef,
01273                                  parms-&gt;wholeMsg, parms-&gt;wholeMsgLen,
01274                                  parms-&gt;wholeMsgOffset);
01275 }
01276 
01277 <span class="keywordtype">int</span>
01278 usm_rgenerate_out_msg(<span class="keywordtype">int</span> msgProcModel, <span class="comment">/* (UNUSED) */</span>
01279                       u_char * globalData,      <span class="comment">/* IN */</span>
01280                       <span class="comment">/*</span>
01281 <span class="comment">                       * points at the msgGlobalData, which is of length given by next </span>
01282 <span class="comment">                       * parameter.  </span>
01283 <span class="comment">                       */</span>
01284                       size_t globalDataLen,     <span class="comment">/* IN - Length of msg header data.      */</span>
01285                       <span class="keywordtype">int</span> maxMsgSize,   <span class="comment">/* (UNUSED) */</span>
01286                       <span class="keywordtype">int</span> secModel,     <span class="comment">/* (UNUSED) */</span>
01287                       u_char * secEngineID,     <span class="comment">/* IN - Pointer snmpEngineID.           */</span>
01288                       size_t secEngineIDLen,    <span class="comment">/* IN - SnmpEngineID length.            */</span>
01289                       <span class="keywordtype">char</span> *secName,    <span class=
"comment">/* IN - Pointer to securityName.        */</span>
01290                       size_t secNameLen,        <span class="comment">/* IN - SecurityName length.            */</span>
01291                       <span class="keywordtype">int</span> secLevel,     <span class=
"comment">/* IN - AuthNoPriv, authPriv etc.       */</span>
01292                       u_char * scopedPdu,       <span class="comment">/* IN */</span>
01293                       <span class="comment">/*</span>
01294 <span class="comment">                       * Pointer to scopedPdu will be encrypted by USM if needed</span>
01295 <span class="comment">                       * * and written to packet buffer immediately following</span>
01296 <span class="comment">                       * * securityParameters, entire msg will be authenticated by</span>
01297 <span class="comment">                       * * USM if needed.</span>
01298 <span class="comment">                       */</span>
01299                       size_t scopedPduLen,      <span class="comment">/* IN - scopedPdu length. */</span>
01300                       <span class="keywordtype">void</span> *secStateRef,        <span class="comment">/* IN */</span>
01301                       <span class="comment">/*</span>
01302 <span class="comment">                       * secStateRef, pointer to cached info provided only for</span>
01303 <span class="comment">                       * * Response, otherwise NULL.</span>
01304 <span class="comment">                       */</span>
01305                       u_char ** wholeMsg,       <span class="comment">/*  IN/OUT  */</span>
01306                       <span class="comment">/*</span>
01307 <span class="comment">                       * Points at the pointer to the packet buffer, which might get extended</span>
01308 <span class="comment">                       * if necessary via realloc().  </span>
01309 <span class="comment">                       */</span>
01310                       size_t * wholeMsgLen,     <span class="comment">/*  IN/OUT  */</span>
01311                       <span class="comment">/*</span>
01312 <span class="comment">                       * Length of the entire packet buffer, **not** the length of the</span>
01313 <span class="comment">                       * packet.  </span>
01314 <span class="comment">                       */</span>
01315                       size_t * offset   <span class="comment">/*  IN/OUT  */</span>
01316                       <span class="comment">/*</span>
01317 <span class="comment">                       * Offset from the end of the packet buffer to the start of the packet,</span>
01318 <span class="comment">                       * also known as the packet length.  </span>
01319 <span class="comment">                       */</span>
01320     )
01321 {
01322     size_t          msgAuthParmLen = 0;
01323 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
01324     size_t          theTotalLength;
01325 <span class="preprocessor">#endif</span>
01326 
01327     u_int           boots_uint;
01328     u_int           time_uint;
01329     <span class="keywordtype">long</span>            boots_long;
01330     <span class="keywordtype">long</span>            time_long;
01331 
01332     <span class="comment">/*</span>
01333 <span class="comment">     * Indirection because secStateRef values override parameters.</span>
01334 <span class="comment">     * </span>
01335 <span class="comment">     * None of these are to be free'd - they are either pointing to</span>
01336 <span class="comment">     * what's in the secStateRef or to something either in the</span>
01337 <span class="comment">     * actual prarmeter list or the user list.</span>
01338 <span class="comment">     */</span>
01339 
01340     <span class="keywordtype">char</span>           *theName = NULL;
01341     u_int           theNameLength = 0;
01342     u_char         *theEngineID = NULL;
01343     u_int           theEngineIDLength = 0;
01344     u_char         *theAuthKey = NULL;
01345     u_int           theAuthKeyLength = 0;
01346     <span class="keyword">const</span> oid      *theAuthProtocol = NULL;
01347     u_int           theAuthProtocolLength = 0;
01348     u_char         *thePrivKey = NULL;
01349     u_int           thePrivKeyLength = 0;
01350     <span class="keyword">const</span> oid      *thePrivProtocol = NULL;
01351     u_int           thePrivProtocolLength = 0;
01352     <span class="keywordtype">int</span>             theSecLevel = 0;    <span class=
"comment">/* No defined const for bad</span>
01353 <span class="comment">                                         * value (other then err). */</span>
01354     size_t          salt_length = 0, save_salt_length = 0, save_salt_offset = 0;
01355     u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];
01356     u_char          authParams[USM_MAX_AUTHSIZE];
01357     u_char          iv[BYTESIZE(USM_MAX_SALT_LENGTH)];
01358     size_t          sp_offset = 0, mac_offset = 0;
01359     <span class="keywordtype">int</span>             rc = 0;
01360 
01361     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"USM processing has begun (offset %d)\n"</span>, *offset));
01362 
01363     <span class="keywordflow">if</span> (secStateRef != NULL) {
01364         <span class="comment">/*</span>
01365 <span class="comment">         * To hush the compiler for now.  XXX </span>
01366 <span class="comment">         */</span>
01367         <span class="keyword">struct </span>usmStateReference *ref
01368             = (<span class="keyword">struct </span>usmStateReference *) secStateRef;
01369 
01370         theName = ref-&gt;usr_name;
01371         theNameLength = ref-&gt;usr_name_length;
01372         theEngineID = ref-&gt;usr_engine_id;
01373         theEngineIDLength = ref-&gt;usr_engine_id_length;
01374 
01375         <span class="keywordflow">if</span> (!theEngineIDLength) {
01376             theEngineID = secEngineID;
01377             theEngineIDLength = secEngineIDLen;
01378         }
01379 
01380         theAuthProtocol = ref-&gt;usr_auth_protocol;
01381         theAuthProtocolLength = ref-&gt;usr_auth_protocol_length;
01382         theAuthKey = ref-&gt;usr_auth_key;
01383         theAuthKeyLength = ref-&gt;usr_auth_key_length;
01384         thePrivProtocol = ref-&gt;usr_priv_protocol;
01385         thePrivProtocolLength = ref-&gt;usr_priv_protocol_length;
01386         thePrivKey = ref-&gt;usr_priv_key;
01387         thePrivKeyLength = ref-&gt;usr_priv_key_length;
01388         theSecLevel = ref-&gt;usr_sec_level;
01389     }
01390 
01391     <span class="comment">/*</span>
01392 <span class="comment">     * * Identify the user record.</span>
01393 <span class="comment">     */</span>
01394     <span class="keywordflow">else</span> {
01395         <span class="keyword">struct </span>usmUser *user;
01396 
01397         <span class="comment">/*</span>
01398 <span class="comment">         * we do allow an unknown user name for</span>
01399 <span class="comment">         * unauthenticated requests. </span>
01400 <span class="comment">         */</span>
01401         <span class="keywordflow">if</span> ((user = usm_get_user(secEngineID, secEngineIDLen, secName))
01402             == NULL &amp;&amp; secLevel != SNMP_SEC_LEVEL_NOAUTH) {
01403             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"Unknown User\n"</span>));
01404             usm_free_usmStateReference(secStateRef);
01405             <span class="keywordflow">return</span> SNMPERR_USM_UNKNOWNSECURITYNAME;
01406         }
01407 
01408         theName = secName;
01409         theNameLength = secNameLen;
01410         theEngineID = secEngineID;
01411         theSecLevel = secLevel;
01412         theEngineIDLength = secEngineIDLen;
01413         <span class="keywordflow">if</span> (user) {
01414             theAuthProtocol = user-&gt;authProtocol;
01415             theAuthProtocolLength = user-&gt;authProtocolLen;
01416             theAuthKey = user-&gt;authKey;
01417             theAuthKeyLength = user-&gt;authKeyLen;
01418             thePrivProtocol = user-&gt;privProtocol;
01419             thePrivProtocolLength = user-&gt;privProtocolLen;
01420             thePrivKey = user-&gt;privKey;
01421             thePrivKeyLength = user-&gt;privKeyLen;
01422         } <span class="keywordflow">else</span> {
01423             <span class="comment">/*</span>
01424 <span class="comment">             * unknown users can not do authentication (obviously) </span>
01425 <span class="comment">             */</span>
01426             theAuthProtocol = usmNoAuthProtocol;
01427             theAuthProtocolLength =
01428                 <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class="keyword">sizeof</span>(oid);
01429             theAuthKey = NULL;
01430             theAuthKeyLength = 0;
01431             thePrivProtocol = usmNoPrivProtocol;
01432             thePrivProtocolLength =
01433                 <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid);
01434             thePrivKey = NULL;
01435             thePrivKeyLength = 0;
01436         }
01437     }                           <span class="comment">/* endif -- secStateRef==NULL */</span>
01438 
01439 
01440     <span class="comment">/*</span>
01441 <span class="comment">     * From here to the end of the function, avoid reference to</span>
01442 <span class="comment">     * secName, secEngineID, secLevel, and associated lengths.</span>
01443 <span class="comment">     */</span>
01444 
01445 
01446     <span class="comment">/*</span>
01447 <span class="comment">     * Check to see if the user can use the requested sec services.</span>
01448 <span class="comment">     */</span>
01449     <span class="keywordflow">if</span> (usm_check_secLevel_vs_protocols(theSecLevel,
01450                                         theAuthProtocol,
01451                                         theAuthProtocolLength,
01452                                         thePrivProtocol,
01453                                         thePrivProtocolLength) == 1) {
01454         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Unsupported Security Level or type (%d)\n"</span>,
01455                     theSecLevel));
01456 
01457         usm_free_usmStateReference(secStateRef);
01458         <span class="keywordflow">return</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;
01459     }
01460 
01461 
01462     <span class="comment">/*</span>
01463 <span class="comment">     * * Retrieve the engine information.</span>
01464 <span class="comment">     * *</span>
01465 <span class="comment">     * * XXX    No error is declared in the EoP when sending messages to</span>
01466 <span class="comment">     * *        unknown engines, processing continues w/ boots/time == (0,0).</span>
01467 <span class="comment">     */</span>
01468     <span class="keywordflow">if</span> (get_enginetime(theEngineID, theEngineIDLength,
01469                        &amp;boots_uint, &amp;time_uint, FALSE) == -1) {
01470         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>, <span class=
"stringliteral">"Failed to find engine data."</span>));
01471     }
01472 
01473     boots_long = boots_uint;
01474     time_long = time_uint;
01475 
01476     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
01477         <span class="comment">/*</span>
01478 <span class="comment">         * Initially assume that the ciphertext will end up the same size as</span>
01479 <span class="comment">         * the plaintext plus some padding.  Really sc_encrypt ought to be able</span>
01480 <span class="comment">         * to grow this for us, a la asn_realloc_rbuild_&lt;type&gt; functions, but</span>
01481 <span class="comment">         * this will do for now.  </span>
01482 <span class="comment">         */</span>
01483         u_char         *ciphertext = NULL;
01484         size_t          ciphertextlen = scopedPduLen + 64;
01485 
01486         <span class="keywordflow">if</span> ((ciphertext = (u_char *) malloc(ciphertextlen)) == NULL) {
01487             DEBUGMSGTL((<span class="stringliteral">"usm"</span>,
01488                         <span class="stringliteral">"couldn't malloc %d bytes for encrypted PDU\n"</span>,
01489                         ciphertextlen));
01490             usm_free_usmStateReference(secStateRef);
01491             <span class="keywordflow">return</span> SNMPERR_MALLOC;
01492         }
01493 
01494         <span class="comment">/*</span>
01495 <span class="comment">         * XXX Hardwired to seek into a 1DES private key!  </span>
01496 <span class="comment">         */</span>
01497 <span class="preprocessor">#ifdef HAVE_AES</span>
01498         <span class="keywordflow">if</span> (ISTRANSFORM(thePrivProtocol, AESPriv)) {
01499             salt_length = BYTESIZE(USM_AES_SALT_LENGTH);
01500             save_salt_length = BYTESIZE(USM_AES_SALT_LENGTH)/2;
01501             save_salt_offset = 0;
01502             <span class="keywordflow">if</span> (!thePrivKey ||
01503                 usm_set_aes_iv(salt, &amp;salt_length,
01504                                htonl(boots_uint), htonl(time_uint),
01505                                iv) == -1) {
01506                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Can't set AES iv.\n"</span>));
01507                 usm_free_usmStateReference(secStateRef);
01508                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ciphertext);
01509                 <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
01510             }
01511         } 
01512 <span class="preprocessor">#endif</span>
01513 <span class="preprocessor">#ifndef DISABLE_DES</span>
01514         <span class="keywordflow">if</span> (ISTRANSFORM(thePrivProtocol, DESPriv)) {
01515             salt_length = BYTESIZE(USM_DES_SALT_LENGTH);
01516             save_salt_length = BYTESIZE(USM_DES_SALT_LENGTH);
01517             save_salt_offset = 0;
01518             <span class="keywordflow">if</span> (!thePrivKey || (usm_set_salt(salt, &amp;salt_length,
01519                                              thePrivKey + 8,
01520                                              thePrivKeyLength - 8,
01521                                              iv) == -1)) {
01522                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Can't set DES-CBC salt.\n"</span>));
01523                 usm_free_usmStateReference(secStateRef);
01524                 <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ciphertext);
01525                 <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
01526             }
01527         }
01528 <span class="preprocessor">#endif</span>
01529 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
01530         <span class="keywordflow">if</span> (debug_is_token_registered(<span class=
"stringliteral">"usm/dump"</span>) == SNMPERR_SUCCESS) {
01531             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"This data was encrypted:"</span>,
01532                        scopedPdu, scopedPduLen);
01533         }
01534 <span class="preprocessor">#endif</span>
01535 
01536         <span class="keywordflow">if</span> (sc_encrypt(thePrivProtocol, thePrivProtocolLength,
01537                        thePrivKey, thePrivKeyLength,
01538                        salt, salt_length,
01539                        scopedPdu, scopedPduLen,
01540                        ciphertext, &amp;ciphertextlen) != SNMP_ERR_NOERROR) {
01541             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"encryption error.\n"</span>));
01542             usm_free_usmStateReference(secStateRef);
01543             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ciphertext);
01544             <span class="keywordflow">return</span> SNMPERR_USM_ENCRYPTIONERROR;
01545         }
01546 
01547         <span class="comment">/*</span>
01548 <span class="comment">         * Write the encrypted scopedPdu back into the packet buffer.  </span>
01549 <span class="comment">         */</span>
01550 
01551 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
01552         theTotalLength = *wholeMsgLen;
01553 <span class="preprocessor">#endif</span>
01554         *offset = 0;
01555         rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
01556                                        (u_char) (ASN_UNIVERSAL |
01557                                                  ASN_PRIMITIVE |
01558                                                  ASN_OCTET_STR),
01559                                        ciphertext, ciphertextlen);
01560 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
01561         <span class="keywordflow">if</span> (debug_is_token_registered(<span class=
"stringliteral">"usm/dump"</span>) == SNMPERR_SUCCESS) {
01562             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"salt + Encrypted form: "</span>, salt,
01563                        salt_length);
01564             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class="stringliteral">"wholeMsg:"</span>,
01565                        (*wholeMsg + *wholeMsgLen - *offset), *offset);
01566         }
01567 <span class="preprocessor">#endif</span>
01568 
01569         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Encryption successful.\n"</span>));
01570         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ciphertext);
01571     } <span class="keywordflow">else</span> {
01572         <span class="comment">/*</span>
01573 <span class="comment">         * theSecLevel != SNMP_SEC_LEVEL_AUTHPRIV  </span>
01574 <span class="comment">         */</span>
01575     }
01576 
01577     <span class="comment">/*</span>
01578 <span class="comment">     * Start encoding the msgSecurityParameters.  </span>
01579 <span class="comment">     */</span>
01580 
01581     sp_offset = *offset;
01582 
01583     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgPrivacyParameters"</span>);
01584     <span class="comment">/*</span>
01585 <span class="comment">     * msgPrivacyParameters (warning: assumes DES salt).  </span>
01586 <span class="comment">     */</span>
01587     rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
01588                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
01589                                              | ASN_OCTET_STR),
01590                                    iv,
01591                                    save_salt_length);
01592     DEBUGINDENTLESS();
01593     <span class="keywordflow">if</span> (rc == 0) {
01594         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building privParams failed.\n"</span>));
01595         usm_free_usmStateReference(secStateRef);
01596         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
01597     }
01598 
01599     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthenticationParameters"</span>);
01600     <span class="comment">/*</span>
01601 <span class="comment">     * msgAuthenticationParameters (warnings assumes 0x00 by 12).  </span>
01602 <span class="comment">     */</span>
01603     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
01604         || theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
01605         memset(authParams, 0, USM_MD5_AND_SHA_AUTH_LEN);
01606         msgAuthParmLen = USM_MD5_AND_SHA_AUTH_LEN;
01607     }
01608 
01609     rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
01610                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
01611                                              | ASN_OCTET_STR), authParams,
01612                                    msgAuthParmLen);
01613     DEBUGINDENTLESS();
01614     <span class="keywordflow">if</span> (rc == 0) {
01615         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building authParams failed.\n"</span>));
01616         usm_free_usmStateReference(secStateRef);
01617         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
01618     }
01619 
01620     <span class="comment">/*</span>
01621 <span class="comment">     * Remember where to put the actual HMAC we calculate later on.  An</span>
01622 <span class="comment">     * encoded OCTET STRING of length USM_MD5_AND_SHA_AUTH_LEN has an ASN.1</span>
01623 <span class="comment">     * header of length 2, hence the fudge factor.  </span>
01624 <span class="comment">     */</span>
01625 
01626     mac_offset = *offset - 2;
01627 
01628     <span class="comment">/*</span>
01629 <span class="comment">     * msgUserName.  </span>
01630 <span class="comment">     */</span>
01631     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class="stringliteral">"msgUserName"</span>);
01632     rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
01633                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
01634                                              | ASN_OCTET_STR),
01635                                    (u_char *) theName, theNameLength);
01636     DEBUGINDENTLESS();
01637     <span class="keywordflow">if</span> (rc == 0) {
01638         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building authParams failed.\n"</span>));
01639         usm_free_usmStateReference(secStateRef);
01640         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
01641     }
01642 
01643     <span class="comment">/*</span>
01644 <span class="comment">     * msgAuthoritativeEngineTime.  </span>
01645 <span class="comment">     */</span>
01646     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineTime"</span>);
01647     rc = asn_realloc_rbuild_int(wholeMsg, wholeMsgLen, offset, 1,
01648                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
01649                                           ASN_INTEGER), &amp;time_long,
01650                                 <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
01651     DEBUGINDENTLESS();
01652     <span class="keywordflow">if</span> (rc == 0) {
01653         DEBUGMSGTL((<span class="stringliteral">"usm"</span>,
01654                     <span class="stringliteral">"building msgAuthoritativeEngineTime failed.\n"</span>));
01655         usm_free_usmStateReference(secStateRef);
01656         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
01657     }
01658 
01659     <span class="comment">/*</span>
01660 <span class="comment">     * msgAuthoritativeEngineBoots.  </span>
01661 <span class="comment">     */</span>
01662     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineBoots"</span>);
01663     rc = asn_realloc_rbuild_int(wholeMsg, wholeMsgLen, offset, 1,
01664                                 (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE |
01665                                           ASN_INTEGER), &amp;boots_long,
01666                                 <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
01667     DEBUGINDENTLESS();
01668     <span class="keywordflow">if</span> (rc == 0) {
01669         DEBUGMSGTL((<span class="stringliteral">"usm"</span>,
01670                     <span class="stringliteral">"building msgAuthoritativeEngineBoots failed.\n"</span>));
01671         usm_free_usmStateReference(secStateRef);
01672         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
01673     }
01674 
01675     DEBUGDUMPHEADER(<span class="stringliteral">"send"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineID"</span>);
01676     rc = asn_realloc_rbuild_string(wholeMsg, wholeMsgLen, offset, 1,
01677                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
01678                                              | ASN_OCTET_STR), theEngineID,
01679                                    theEngineIDLength);
01680     DEBUGINDENTLESS();
01681     <span class="keywordflow">if</span> (rc == 0) {
01682         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building msgAuthoritativeEngineID failed.\n"</span>));
01683         usm_free_usmStateReference(secStateRef);
01684         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
01685     }
01686 
01687     <span class="comment">/*</span>
01688 <span class="comment">     * USM msgSecurityParameters sequence header  </span>
01689 <span class="comment">     */</span>
01690     rc = asn_realloc_rbuild_sequence(wholeMsg, wholeMsgLen, offset, 1,
01691                                      (u_char) (ASN_SEQUENCE |
01692                                                ASN_CONSTRUCTOR),
01693                                      *offset - sp_offset);
01694     <span class="keywordflow">if</span> (rc == 0) {
01695         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building usm security parameters failed.\n"</span>));
01696         usm_free_usmStateReference(secStateRef);
01697         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
01698     }
01699 
01700     <span class="comment">/*</span>
01701 <span class="comment">     * msgSecurityParameters OCTET STRING wrapper.  </span>
01702 <span class="comment">     */</span>
01703     rc = asn_realloc_rbuild_header(wholeMsg, wholeMsgLen, offset, 1,
01704                                    (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE
01705                                              | ASN_OCTET_STR),
01706                                    *offset - sp_offset);
01707 
01708     <span class="keywordflow">if</span> (rc == 0) {
01709         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building msgSecurityParameters failed.\n"</span>));
01710         usm_free_usmStateReference(secStateRef);
01711         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
01712     }
01713 
01714     <span class="comment">/*</span>
01715 <span class="comment">     * Copy in the msgGlobalData and msgVersion.  </span>
01716 <span class="comment">     */</span>
01717     <span class="keywordflow">while</span> ((*wholeMsgLen - *offset) &lt; globalDataLen) {
01718         <span class="keywordflow">if</span> (!asn_realloc(wholeMsg, wholeMsgLen)) {
01719             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building global data failed.\n"</span>));
01720             usm_free_usmStateReference(secStateRef);
01721             <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
01722         }
01723     }
01724 
01725     *offset += globalDataLen;
01726     memcpy(*wholeMsg + *wholeMsgLen - *offset, globalData, globalDataLen);
01727 
01728     <span class="comment">/*</span>
01729 <span class="comment">     * Total packet sequence.  </span>
01730 <span class="comment">     */</span>
01731     rc = asn_realloc_rbuild_sequence(wholeMsg, wholeMsgLen, offset, 1,
01732                                      (u_char) (ASN_SEQUENCE |
01733                                                ASN_CONSTRUCTOR), *offset);
01734     <span class="keywordflow">if</span> (rc == 0) {
01735         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"building master packet sequence failed.\n"</span>));
01736         usm_free_usmStateReference(secStateRef);
01737         <span class="keywordflow">return</span> SNMPERR_TOO_LONG;
01738     }
01739 
01740     <span class="comment">/*</span>
01741 <span class="comment">     * Now consider / do authentication.  </span>
01742 <span class="comment">     */</span>
01743 
01744     <span class="keywordflow">if</span> (theSecLevel == SNMP_SEC_LEVEL_AUTHNOPRIV ||
01745         theSecLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
01746         size_t          temp_sig_len = msgAuthParmLen;
01747         u_char         *temp_sig = (u_char *) malloc(temp_sig_len);
01748         u_char         *proto_msg = *wholeMsg + *wholeMsgLen - *offset;
01749         size_t          proto_msg_len = *offset;
01750 
01751 
01752         <span class="keywordflow">if</span> (temp_sig == NULL) {
01753             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"Out of memory.\n"</span>));
01754             usm_free_usmStateReference(secStateRef);
01755             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
01756         }
01757 
01758         <span class="keywordflow">if</span> (sc_generate_keyed_hash(theAuthProtocol, theAuthProtocolLength,
01759                                    theAuthKey, theAuthKeyLength,
01760                                    proto_msg, proto_msg_len,
01761                                    temp_sig, &amp;temp_sig_len)
01762             != SNMP_ERR_NOERROR) {
01763             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(temp_sig);
01764             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"Signing failed.\n"</span>));
01765             usm_free_usmStateReference(secStateRef);
01766             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
01767         }
01768 
01769         <span class="keywordflow">if</span> (temp_sig_len != msgAuthParmLen) {
01770             <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(temp_sig);
01771             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Signing lengths failed.\n"</span>));
01772             usm_free_usmStateReference(secStateRef);
01773             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
01774         }
01775 
01776         memcpy(*wholeMsg + *wholeMsgLen - mac_offset, temp_sig,
01777                msgAuthParmLen);
01778         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(temp_sig);
01779     }
01780     <span class="comment">/*</span>
01781 <span class="comment">     * endif -- create keyed hash </span>
01782 <span class="comment">     */</span>
01783     usm_free_usmStateReference(secStateRef);
01784     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"USM processing completed.\n"</span>));
01785     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
01786 }                               <span class="comment">/* end usm_rgenerate_out_msg() */</span>
01787 
01788 <span class="preprocessor">#endif                          </span><span class="comment">/* */</span>
01789 
01790 
01791 
01792 <span class="comment">/*******************************************************************-o-******</span>
01793 <span class="comment"> * usm_parse_security_parameters</span>
01794 <span class="comment"> *</span>
01795 <span class="comment"> * Parameters:</span>
01796 <span class="comment"> *      (See list below...)</span>
01797 <span class="comment"> *      </span>
01798 <span class="comment"> * Returns:</span>
01799 <span class="comment"> *      0       On success,</span>
01800 <span class="comment"> *      -1      Otherwise.</span>
01801 <span class="comment"> *</span>
01802 <span class="comment"> *      tab stop 4</span>
01803 <span class="comment"> *</span>
01804 <span class="comment"> *      Extracts values from the security header and data portions of the</span>
01805 <span class="comment"> *      incoming buffer.</span>
01806 <span class="comment"> */</span>
01807 <span class="keywordtype">int</span>
01808 usm_parse_security_parameters(u_char * secParams,
01809                               size_t remaining,
01810                               u_char * secEngineID,
01811                               size_t * secEngineIDLen,
01812                               u_int * boots_uint,
01813                               u_int * time_uint,
01814                               <span class="keywordtype">char</span> *secName,
01815                               size_t * secNameLen,
01816                               u_char * signature,
01817                               size_t * signature_length,
01818                               u_char * salt,
01819                               size_t * salt_length, u_char ** data_ptr)
01820 {
01821     u_char         *parse_ptr = secParams;
01822     u_char         *value_ptr;
01823     u_char         *next_ptr;
01824     u_char          type_value;
01825 
01826     size_t          octet_string_length = remaining;
01827     size_t          sequence_length;
01828     size_t          remaining_bytes;
01829 
01830     <span class="keywordtype">long</span>            boots_long;
01831     <span class="keywordtype">long</span>            time_long;
01832 
01833     u_int           origNameLen;
01834 
01835 
01836     <span class="comment">/*</span>
01837 <span class="comment">     * Eat the first octet header.</span>
01838 <span class="comment">     */</span>
01839     <span class="keywordflow">if</span> ((value_ptr = asn_parse_sequence(parse_ptr, &amp;octet_string_length,
01840                                         &amp;type_value,
01841                                         (ASN_UNIVERSAL | ASN_PRIMITIVE |
01842                                          ASN_OCTET_STR),
01843                                         <span class="stringliteral">"usm first octet"</span>)) == NULL) {
01844         <span class="comment">/*</span>
01845 <span class="comment">         * RETURN parse error </span>
01846 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
01847     }
01848 
01849 
01850     <span class="comment">/*</span>
01851 <span class="comment">     * Eat the sequence header.</span>
01852 <span class="comment">     */</span>
01853     parse_ptr = value_ptr;
01854     sequence_length = octet_string_length;
01855 
01856     <span class="keywordflow">if</span> ((value_ptr = asn_parse_sequence(parse_ptr, &amp;sequence_length,
01857                                         &amp;type_value,
01858                                         (ASN_SEQUENCE | ASN_CONSTRUCTOR),
01859                                         <span class="stringliteral">"usm sequence"</span>)) == NULL) {
01860         <span class="comment">/*</span>
01861 <span class="comment">         * RETURN parse error </span>
01862 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
01863     }
01864 
01865 
01866     <span class="comment">/*</span>
01867 <span class="comment">     * Retrieve the engineID.</span>
01868 <span class="comment">     */</span>
01869     parse_ptr = value_ptr;
01870     remaining_bytes = sequence_length;
01871 
01872     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineID"</span>);
01873     <span class="keywordflow">if</span> ((next_ptr
01874          = asn_parse_string(parse_ptr, &amp;remaining_bytes, &amp;type_value,
01875                             secEngineID, secEngineIDLen)) == NULL) {
01876         DEBUGINDENTLESS();
01877         <span class="comment">/*</span>
01878 <span class="comment">         * RETURN parse error </span>
01879 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
01880     }
01881     DEBUGINDENTLESS();
01882 
01883     <span class="keywordflow">if</span> (type_value !=
01884         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {
01885         <span class="comment">/*</span>
01886 <span class="comment">         * RETURN parse error </span>
01887 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
01888     }
01889 
01890 
01891     <span class="comment">/*</span>
01892 <span class="comment">     * Retrieve the engine boots, notice switch in the way next_ptr and</span>
01893 <span class="comment">     * remaining_bytes are used (to accomodate the asn code).</span>
01894 <span class="comment">     */</span>
01895     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineBoots"</span>);
01896     <span class="keywordflow">if</span> ((next_ptr = asn_parse_int(next_ptr, &amp;remaining_bytes, &amp;type_value,
01897                                   &amp;boots_long, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>))) == NULL) {
01898         DEBUGINDENTLESS();
01899         <span class="comment">/*</span>
01900 <span class="comment">         * RETURN parse error </span>
01901 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
01902     }
01903     DEBUGINDENTLESS();
01904 
01905     <span class="keywordflow">if</span> (type_value !=
01906         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER)) {
01907         DEBUGINDENTLESS();
01908         <span class="comment">/*</span>
01909 <span class="comment">         * RETURN parse error </span>
01910 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
01911     }
01912 
01913     *boots_uint = (u_int) boots_long;
01914 
01915 
01916     <span class="comment">/*</span>
01917 <span class="comment">     * Retrieve the time value.</span>
01918 <span class="comment">     */</span>
01919     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"msgAuthoritativeEngineTime"</span>);
01920     <span class="keywordflow">if</span> ((next_ptr = asn_parse_int(next_ptr, &amp;remaining_bytes, &amp;type_value,
01921                                   &amp;time_long, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>))) == NULL) {
01922         <span class="comment">/*</span>
01923 <span class="comment">         * RETURN parse error </span>
01924 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
01925     }
01926     DEBUGINDENTLESS();
01927 
01928     <span class="keywordflow">if</span> (type_value !=
01929         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER)) {
01930         <span class="comment">/*</span>
01931 <span class="comment">         * RETURN parse error </span>
01932 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
01933     }
01934 
01935     *time_uint = (u_int) time_long;
01936 
01937     <span class="keywordflow">if</span> (*boots_uint &gt; ENGINEBOOT_MAX || *time_uint &gt; ENGINETIME_MAX) {
01938         <span class="keywordflow">return</span> -1;
01939     }
01940 
01941     <span class="comment">/*</span>
01942 <span class="comment">     * Retrieve the secName.</span>
01943 <span class="comment">     */</span>
01944     origNameLen = *secNameLen;
01945 
01946 
01947     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"msgUserName"</span>);
01948     <span class="keywordflow">if</span> ((next_ptr
01949          = asn_parse_string(next_ptr, &amp;remaining_bytes, &amp;type_value,
01950                             (u_char *) secName, secNameLen)) == NULL) {
01951         DEBUGINDENTLESS();
01952         <span class="comment">/*</span>
01953 <span class="comment">         * RETURN parse error </span>
01954 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
01955     }
01956     DEBUGINDENTLESS();
01957 
01958     <span class="comment">/*</span>
01959 <span class="comment">     * FIX -- doesn't this also indicate a buffer overrun?</span>
01960 <span class="comment">     */</span>
01961     <span class="keywordflow">if</span> ((int) origNameLen &lt; *secNameLen + 1) {
01962         <span class="comment">/*</span>
01963 <span class="comment">         * RETURN parse error, but it's really a parameter error </span>
01964 <span class="comment">         */</span>
01965         <span class="keywordflow">return</span> -1;
01966     }
01967 
01968     <span class="keywordflow">if</span> (*secNameLen &gt; 32) {
01969         <span class="comment">/*</span>
01970 <span class="comment">         * This is a USM-specific limitation over and above the above</span>
01971 <span class="comment">         * limitation (which will probably default to the length of an</span>
01972 <span class="comment">         * SnmpAdminString, i.e. 255).  See RFC 2574, sec. 2.4.  </span>
01973 <span class="comment">         */</span>
01974         <span class="keywordflow">return</span> -1;
01975     }
01976 
01977     secName[*secNameLen] = <span class="charliteral">'\0'</span>;
01978 
01979     <span class="keywordflow">if</span> (type_value !=
01980         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {
01981         <span class="comment">/*</span>
01982 <span class="comment">         * RETURN parse error </span>
01983 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
01984     }
01985 
01986 
01987     <span class="comment">/*</span>
01988 <span class="comment">     * Retrieve the signature and blank it if there.</span>
01989 <span class="comment">     */</span>
01990     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class=
"stringliteral">"msgAuthenticationParameters"</span>);
01991     <span class="keywordflow">if</span> ((next_ptr
01992          = asn_parse_string(next_ptr, &amp;remaining_bytes, &amp;type_value,
01993                             signature, signature_length)) == NULL) {
01994         DEBUGINDENTLESS();
01995         <span class="comment">/*</span>
01996 <span class="comment">         * RETURN parse error </span>
01997 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
01998     }
01999     DEBUGINDENTLESS();
02000 
02001     <span class="keywordflow">if</span> (type_value !=
02002         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {
02003         <span class="comment">/*</span>
02004 <span class="comment">         * RETURN parse error </span>
02005 <span class="comment">         */</span> <span class="keywordflow">return</span> -1;
02006     }
02007 
02008     <span class="keywordflow">if</span> (*signature_length != 0) {       <span class=
"comment">/* Blanking for authentication step later */</span>
02009         memset(next_ptr - (u_long) * signature_length,
02010                0, *signature_length);
02011     }
02012 
02013 
02014     <span class="comment">/*</span>
02015 <span class="comment">     * Retrieve the salt.</span>
02016 <span class="comment">     *</span>
02017 <span class="comment">     * Note that the next ptr is where the data section starts.</span>
02018 <span class="comment">     */</span>
02019     DEBUGDUMPHEADER(<span class="stringliteral">"recv"</span>, <span class="stringliteral">"msgPrivacyParameters"</span>);
02020     <span class="keywordflow">if</span> ((*data_ptr
02021          = asn_parse_string(next_ptr, &amp;remaining_bytes, &amp;type_value,
02022                             salt, salt_length)) == NULL) {
02023         DEBUGINDENTLESS();
02024         <span class="comment">/*</span>
02025 <span class="comment">         * RETURN parse error </span>
02026 <span class="comment">         */</span> <span class="keywordflow">return</span> -2;
02027     }
02028     DEBUGINDENTLESS();
02029 
02030     <span class="keywordflow">if</span> (type_value !=
02031         (u_char) (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_OCTET_STR)) {
02032         <span class="comment">/*</span>
02033 <span class="comment">         * RETURN parse error </span>
02034 <span class="comment">         */</span> <span class="keywordflow">return</span> -2;
02035     }
02036 
02037     <span class="keywordflow">return</span> 0;
02038 
02039 }                               <span class="comment">/* end usm_parse_security_parameters() */</span>
02040 
02041 
02042 
02043 
02044 <span class="comment">/*******************************************************************-o-******</span>
02045 <span class="comment"> * usm_check_and_update_timeliness</span>
02046 <span class="comment"> *</span>
02047 <span class="comment"> * Parameters:</span>
02048 <span class="comment"> *      *secEngineID</span>
02049 <span class="comment"> *       secEngineIDen</span>
02050 <span class="comment"> *       boots_uint</span>
02051 <span class="comment"> *       time_uint</span>
02052 <span class="comment"> *      *error</span>
02053 <span class="comment"> *      </span>
02054 <span class="comment"> * Returns:</span>
02055 <span class="comment"> *      0       On success,</span>
02056 <span class="comment"> *      -1      Otherwise.</span>
02057 <span class="comment"> *      </span>
02058 <span class="comment"> *</span>
02059 <span class="comment"> * Performs the incoming timeliness checking and setting.</span>
02060 <span class="comment"> */</span>
02061 <span class="keywordtype">int</span>
02062 usm_check_and_update_timeliness(u_char * secEngineID,
02063                                 size_t secEngineIDLen,
02064                                 u_int boots_uint,
02065                                 u_int time_uint, <span class="keywordtype">int</span> *error)
02066 {
02067     u_char          myID[USM_MAX_ID_LENGTH];
02068     u_long          myIDLength =
02069         snmpv3_get_engineID(myID, USM_MAX_ID_LENGTH);
02070     u_int           myBoots;
02071     u_int           myTime;
02072 
02073 
02074 
02075     <span class="keywordflow">if</span> ((myIDLength &gt; USM_MAX_ID_LENGTH) || (myIDLength == 0)) {
02076         <span class="comment">/*</span>
02077 <span class="comment">         * We're probably already screwed...buffer overwrite.  XXX? </span>
02078 <span class="comment">         */</span>
02079         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"Buffer overflow.\n"</span>));
02080         *error = SNMPERR_USM_GENERICERROR;
02081         <span class="keywordflow">return</span> -1;
02082     }
02083 
02084     myBoots = snmpv3_local_snmpEngineBoots();
02085     myTime = snmpv3_local_snmpEngineTime();
02086 
02087 
02088     <span class="comment">/*</span>
02089 <span class="comment">     * IF the time involved is local</span>
02090 <span class="comment">     *     Make sure  message is inside the time window </span>
02091 <span class="comment">     * ELSE </span>
02092 <span class="comment">     *      IF boots is higher or boots is the same and time is higher</span>
02093 <span class="comment">     *              remember this new data</span>
02094 <span class="comment">     *      ELSE</span>
02095 <span class="comment">     *              IF !(boots same and time within USM_TIME_WINDOW secs)</span>
02096 <span class="comment">     *                      Message is too old </span>
02097 <span class="comment">     *              ELSE    </span>
02098 <span class="comment">     *                      Message is ok, but don't take time</span>
02099 <span class="comment">     *              ENDIF</span>
02100 <span class="comment">     *      ENDIF</span>
02101 <span class="comment">     * ENDIF</span>
02102 <span class="comment">     */</span>
02103 
02104     <span class="comment">/*</span>
02105 <span class="comment">     * This is a local reference.</span>
02106 <span class="comment">     */</span>
02107     <span class="keywordflow">if</span> ((int) secEngineIDLen == myIDLength
02108         &amp;&amp; memcmp(secEngineID, myID, myIDLength) == 0) {
02109         u_int           time_difference = myTime &gt; time_uint ?
02110             myTime - time_uint : time_uint - myTime;
02111 
02112         <span class="keywordflow">if</span> (boots_uint == ENGINEBOOT_MAX
02113             || boots_uint != myBoots
02114             || time_difference &gt; USM_TIME_WINDOW) {
02115             <span class="keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSNOTINTIMEWINDOWS) ==
02116                 0) {
02117                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>,
02118                             <span class="stringliteral">"Failed to increment statistic."</span>));
02119             }
02120 
02121             DEBUGMSGTL((<span class="stringliteral">"usm"</span>,
02122                         <span class=
"stringliteral">"boot_uint %u myBoots %u time_diff %u =&gt; not in time window\n"</span>,
02123                         boots_uint, myBoots, time_difference));
02124             *error = SNMPERR_USM_NOTINTIMEWINDOW;
02125             <span class="keywordflow">return</span> -1;
02126         }
02127 
02128         *error = SNMPERR_SUCCESS;
02129         <span class="keywordflow">return</span> 0;
02130     }
02131 
02132     <span class="comment">/*</span>
02133 <span class="comment">     * This is a remote reference.</span>
02134 <span class="comment">     */</span>
02135     <span class="keywordflow">else</span> {
02136         u_int           theirBoots, theirTime, theirLastTime;
02137         u_int           time_difference;
02138 
02139         <span class="keywordflow">if</span> (get_enginetime_ex(secEngineID, secEngineIDLen,
02140                               &amp;theirBoots, &amp;theirTime,
02141                               &amp;theirLastTime, TRUE)
02142             != SNMPERR_SUCCESS) {
02143             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>,
02144                         <span class="stringliteral">"Failed to get remote engine's times."</span>));
02145 
02146             *error = SNMPERR_USM_GENERICERROR;
02147             <span class="keywordflow">return</span> -1;
02148         }
02149 
02150         time_difference = theirTime &gt; time_uint ?
02151             theirTime - time_uint : time_uint - theirTime;
02152 
02153 
02154         <span class="comment">/*</span>
02155 <span class="comment">         * XXX  Contrary to the pseudocode:</span>
02156 <span class="comment">         *      See if boots is invalid first.</span>
02157 <span class="comment">         */</span>
02158         <span class="keywordflow">if</span> (theirBoots == ENGINEBOOT_MAX || theirBoots &gt; boots_uint) {
02159             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>, <span class=
"stringliteral">"Remote boot count invalid."</span>));
02160 
02161             *error = SNMPERR_USM_NOTINTIMEWINDOW;
02162             <span class="keywordflow">return</span> -1;
02163         }
02164 
02165 
02166         <span class="comment">/*</span>
02167 <span class="comment">         * Boots is ok, see if the boots is the same but the time</span>
02168 <span class="comment">         * is old.</span>
02169 <span class="comment">         */</span>
02170         <span class="keywordflow">if</span> (theirBoots == boots_uint &amp;&amp; time_uint &lt; theirLastTime) {
02171             <span class="keywordflow">if</span> (time_difference &gt; USM_TIME_WINDOW) {
02172                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Message too old."</span>));
02173                 *error = SNMPERR_USM_NOTINTIMEWINDOW;
02174                 <span class="keywordflow">return</span> -1;
02175             }
02176 
02177             <span class="keywordflow">else</span> {              <span class="comment">/* Old, but acceptable */</span>
02178 
02179                 *error = SNMPERR_SUCCESS;
02180                 <span class="keywordflow">return</span> 0;
02181             }
02182         }
02183 
02184 
02185         <span class="comment">/*</span>
02186 <span class="comment">         * Message is ok, either boots has been advanced, or</span>
02187 <span class="comment">         * time is greater than before with the same boots.</span>
02188 <span class="comment">         */</span>
02189 
02190         <span class="keywordflow">if</span> (set_enginetime(secEngineID, secEngineIDLen,
02191                            boots_uint, time_uint, TRUE)
02192             != SNMPERR_SUCCESS) {
02193             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>,
02194                         <span class="stringliteral">"Failed updating remote boot/time."</span>));
02195             *error = SNMPERR_USM_GENERICERROR;
02196             <span class="keywordflow">return</span> -1;
02197         }
02198 
02199         *error = SNMPERR_SUCCESS;
02200         <span class="keywordflow">return</span> 0;               <span class=
"comment">/* Fresh message and time updated */</span>
02201 
02202     }                           <span class="comment">/* endif -- local or remote time reference. */</span>
02203 
02204 
02205 }                               <span class="comment">/* end usm_check_and_update_timeliness() */</span>
02206 
02207 
02208 
02209 <span class="keywordtype">int</span>
02210 usm_secmod_process_in_msg(<span class="keyword">struct</span> snmp_secmod_incoming_params *parms)
02211 {
02212     <span class="keywordflow">if</span> (!parms)
02213         <span class="keywordflow">return</span> SNMPERR_GENERR;
02214 
02215     <span class="keywordflow">return</span> usm_process_in_msg(parms-&gt;msgProcModel,
02216                               parms-&gt;maxMsgSize,
02217                               parms-&gt;secParams,
02218                               parms-&gt;secModel,
02219                               parms-&gt;secLevel,
02220                               parms-&gt;wholeMsg,
02221                               parms-&gt;wholeMsgLen,
02222                               parms-&gt;secEngineID,
02223                               parms-&gt;secEngineIDLen,
02224                               parms-&gt;secName,
02225                               parms-&gt;secNameLen,
02226                               parms-&gt;scopedPdu,
02227                               parms-&gt;scopedPduLen,
02228                               parms-&gt;maxSizeResponse,
02229                               parms-&gt;secStateRef,
02230                               parms-&gt;sess, parms-&gt;msg_flags);
02231 }
02232 
02233 <span class="comment">/*******************************************************************-o-******</span>
02234 <span class="comment"> * usm_process_in_msg</span>
02235 <span class="comment"> *</span>
02236 <span class="comment"> * Parameters:</span>
02237 <span class="comment"> *      (See list below...)</span>
02238 <span class="comment"> *      </span>
02239 <span class="comment"> * Returns:</span>
02240 <span class="comment"> *      SNMPERR_SUCCESS                 On success.</span>
02241 <span class="comment"> *      SNMPERR_USM_AUTHENTICATIONFAILURE</span>
02242 <span class="comment"> *      SNMPERR_USM_DECRYPTIONERROR</span>
02243 <span class="comment"> *      SNMPERR_USM_GENERICERROR</span>
02244 <span class="comment"> *      SNMPERR_USM_PARSEERROR</span>
02245 <span class="comment"> *      SNMPERR_USM_UNKNOWNENGINEID</span>
02246 <span class="comment"> *      SNMPERR_USM_PARSEERROR</span>
02247 <span class="comment"> *      SNMPERR_USM_UNKNOWNSECURITYNAME</span>
02248 <span class="comment"> *      SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL</span>
02249 <span class="comment"> *</span>
02250 <span class="comment"> *</span>
02251 <span class="comment"> * ASSUMES size of decrypt_buf will always be &gt;= size of encrypted sPDU.</span>
02252 <span class="comment"> *</span>
02253 <span class="comment"> * FIX  Memory leaks if secStateRef is allocated and a return occurs</span>
02254 <span class="comment"> *      without cleaning up.  May contain secrets...</span>
02255 <span class="comment"> */</span>
02256 <span class="keywordtype">int</span>
02257 usm_process_in_msg(<span class="keywordtype">int</span> msgProcModel,    <span class="comment">/* (UNUSED) */</span>
02258                    size_t maxMsgSize,   <span class="comment">/* IN     - Used to calc maxSizeResponse.  */</span>
02259                    u_char * secParams,  <span class="comment">/* IN     - BER encoded securityParameters. */</span>
02260                    <span class="keywordtype">int</span> secModel,        <span class="comment">/* (UNUSED) */</span>
02261                    <span class="keywordtype">int</span> secLevel,        <span class=
"comment">/* IN     - AuthNoPriv, authPriv etc.      */</span>
02262                    u_char * wholeMsg,   <span class="comment">/* IN     - Original v3 message.           */</span>
02263                    size_t wholeMsgLen,  <span class="comment">/* IN     - Msg length.                    */</span>
02264                    u_char * secEngineID,        <span class="comment">/* OUT    - Pointer snmpEngineID.          */</span>
02265                    size_t * secEngineIDLen,     <span class="comment">/* IN/OUT - Len available, len returned.   */</span>
02266                    <span class="comment">/*</span>
02267 <span class="comment">                    * NOTE: Memory provided by caller.      </span>
02268 <span class="comment">                    */</span>
02269                    <span class="keywordtype">char</span> *secName,       <span class=
"comment">/* OUT    - Pointer to securityName.       */</span>
02270                    size_t * secNameLen, <span class="comment">/* IN/OUT - Len available, len returned.   */</span>
02271                    u_char ** scopedPdu, <span class="comment">/* OUT    - Pointer to plaintext scopedPdu. */</span>
02272                    size_t * scopedPduLen,       <span class="comment">/* IN/OUT - Len available, len returned.   */</span>
02273                    size_t * maxSizeResponse,    <span class="comment">/* OUT    - Max size of Response PDU.      */</span>
02274                    <span class="keywordtype">void</span> **secStateRf,   <span class=
"comment">/* OUT    - Ref to security state.         */</span>
02275                    <a class="code" href="structsnmp__session.html">netsnmp_session</a> * sess,      <span class=
"comment">/* IN     - session which got the message  */</span>
02276                    u_char msg_flags)
02277 {                               <span class="comment">/* IN     - v3 Message flags.              */</span>
02278     size_t          remaining = wholeMsgLen - (u_int)
02279         ((u_long) * secParams - (u_long) * wholeMsg);
02280     u_int           boots_uint;
02281     u_int           time_uint;
02282 <span class="preprocessor">#ifdef HAVE_AES</span>
02283     u_int           net_boots, net_time;
02284 <span class="preprocessor">#endif</span>
02285     u_char          signature[BYTESIZE(USM_MAX_KEYEDHASH_LENGTH)];
02286     size_t          signature_length = BYTESIZE(USM_MAX_KEYEDHASH_LENGTH);
02287     u_char          salt[BYTESIZE(USM_MAX_SALT_LENGTH)];
02288     size_t          salt_length = BYTESIZE(USM_MAX_SALT_LENGTH);
02289     u_char          iv[BYTESIZE(USM_MAX_SALT_LENGTH)];
02290     u_int           iv_length = BYTESIZE(USM_MAX_SALT_LENGTH);
02291     u_char         *data_ptr;
02292     u_char         *value_ptr;
02293     u_char          type_value;
02294     u_char         *end_of_overhead = NULL;
02295     <span class="keywordtype">int</span>             error;
02296     <span class="keywordtype">int</span>             i, rc = 0;
02297     <span class="keyword">struct </span>usmStateReference **secStateRef =
02298         (<span class="keyword">struct </span>usmStateReference **) secStateRf;
02299 
02300     <span class="keyword">struct </span>usmUser *user;
02301 
02302 
02303     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"USM processing begun...\n"</span>));
02304 
02305 
02306     <span class="keywordflow">if</span> (secStateRef) {
02307         usm_free_usmStateReference(*secStateRef);
02308         *secStateRef = usm_malloc_usmStateReference();
02309         <span class="keywordflow">if</span> (*secStateRef == NULL) {
02310             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"Out of memory.\n"</span>));
02311             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
02312         }
02313     }
02314 
02315 
02316     <span class="comment">/*</span>
02317 <span class="comment">     * Make sure the *secParms is an OCTET STRING.</span>
02318 <span class="comment">     * Extract the user name, engine ID, and security level.</span>
02319 <span class="comment">     */</span>
02320     <span class="keywordflow">if</span> ((rc = usm_parse_security_parameters(secParams, remaining,
02321                                             secEngineID, secEngineIDLen,
02322                                             &amp;boots_uint, &amp;time_uint,
02323                                             secName, secNameLen,
02324                                             signature, &amp;signature_length,
02325                                             salt, &amp;salt_length,
02326                                             &amp;data_ptr)) &lt; 0) {
02327         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Parsing failed (rc %d).\n"</span>, rc));
02328         <span class="keywordflow">if</span> (rc == -2) {
02329             <span class="comment">/*</span>
02330 <span class="comment">             * This indicates a decryptionError.  </span>
02331 <span class="comment">             */</span>
02332             <span class="keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS) ==
02333                 0) {
02334                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>,
02335                             <span class="stringliteral">"Failed to increment statistic."</span>));
02336             }
02337             <span class="keywordflow">return</span> SNMPERR_USM_DECRYPTIONERROR;
02338         }
02339         <span class="keywordflow">if</span> (snmp_increment_statistic(STAT_SNMPINASNPARSEERRS) == 0) {
02340             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>, <span class=
"stringliteral">"Failed to increment statistic."</span>));
02341         }
02342         <span class="keywordflow">return</span> SNMPERR_USM_PARSEERROR;
02343     }
02344 
02345     <span class="comment">/*</span>
02346 <span class="comment">     * RFC 2574 section 8.3.2</span>
02347 <span class="comment">     * 1)  If the privParameters field is not an 8-octet OCTET STRING,</span>
02348 <span class="comment">     * then an error indication (decryptionError) is returned to the</span>
02349 <span class="comment">     * calling module.</span>
02350 <span class="comment">     */</span>
02351     <span class="keywordflow">if</span> ((secLevel == SNMP_SEC_LEVEL_AUTHPRIV) &amp;&amp; (salt_length != 8)) {
02352         <span class="keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS) == 
02353             0) {
02354             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>, <span class=
"stringliteral">"Failed increment statistic."</span>));
02355         }
02356         <span class="keywordflow">return</span> SNMPERR_USM_DECRYPTIONERROR;
02357     }
02358 
02359     <span class="keywordflow">if</span> (secLevel != SNMP_SEC_LEVEL_AUTHPRIV) {
02360         <span class="comment">/*</span>
02361 <span class="comment">         * pull these out now so reports can use them </span>
02362 <span class="comment">         */</span>
02363         *scopedPdu = data_ptr;
02364         *scopedPduLen = wholeMsgLen - (data_ptr - wholeMsg);
02365         end_of_overhead = data_ptr;
02366     }
02367 
02368     <span class="keywordflow">if</span> (secStateRef) {
02369         <span class="comment">/*</span>
02370 <span class="comment">         * Cache the name, engine ID, and security level,</span>
02371 <span class="comment">         * * per step 2 (section 3.2)</span>
02372 <span class="comment">         */</span>
02373         <span class="keywordflow">if</span> (usm_set_usmStateReference_name
02374             (*secStateRef, secName, *secNameLen) == -1) {
02375             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>, <span class=
"stringliteral">"Couldn't cache name."</span>));
02376             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
02377         }
02378 
02379         <span class="keywordflow">if</span> (usm_set_usmStateReference_engine_id
02380             (*secStateRef, secEngineID, *secEngineIDLen) == -1) {
02381             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>, <span class=
"stringliteral">"Couldn't cache engine id."</span>));
02382             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
02383         }
02384 
02385         <span class="keywordflow">if</span> (usm_set_usmStateReference_sec_level(*secStateRef, secLevel) ==
02386             -1) {
02387             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>, <span class=
"stringliteral">"Couldn't cache security level."</span>));
02388             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
02389         }
02390     }
02391 
02392 
02393     <span class="comment">/*</span>
02394 <span class="comment">     * Locate the engine ID record.</span>
02395 <span class="comment">     * If it is unknown, then either create one or note this as an error.</span>
02396 <span class="comment">     */</span>
02397     <span class="keywordflow">if</span> ((sess &amp;&amp; (sess-&gt;<a class="code" href=
"structsnmp__session.html#o20">isAuthoritative</a> == SNMP_SESS_AUTHORITATIVE ||
02398                   (sess-&gt;<a class="code" href=
"structsnmp__session.html#o20">isAuthoritative</a> == SNMP_SESS_UNKNOWNAUTH &amp;&amp;
02399                    (msg_flags &amp; SNMP_MSG_FLAG_RPRT_BIT)))) ||
02400         (!sess &amp;&amp; (msg_flags &amp; SNMP_MSG_FLAG_RPRT_BIT))) {
02401         <span class="keywordflow">if</span> (ISENGINEKNOWN(secEngineID, *secEngineIDLen) == FALSE) {
02402             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Unknown Engine ID.\n"</span>));
02403             <span class="keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSUNKNOWNENGINEIDS) ==
02404                 0) {
02405                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>,
02406                             <span class="stringliteral">"Failed to increment statistic."</span>));
02407             }
02408             <span class="keywordflow">return</span> SNMPERR_USM_UNKNOWNENGINEID;
02409         }
02410     } <span class="keywordflow">else</span> {
02411         <span class="keywordflow">if</span> (ENSURE_ENGINE_RECORD(secEngineID, *secEngineIDLen)
02412             != SNMPERR_SUCCESS) {
02413             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>, <span class=
"stringliteral">"Couldn't ensure engine record."</span>));
02414             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
02415         }
02416 
02417     }
02418 
02419 
02420     <span class="comment">/*</span>
02421 <span class="comment">     * Locate the User record.</span>
02422 <span class="comment">     * If the user/engine ID is unknown, report this as an error.</span>
02423 <span class="comment">     */</span>
02424     <span class="keywordflow">if</span> ((user = usm_get_user_from_list(secEngineID, *secEngineIDLen,
02425                                        secName, userList,
02426                                        (sess-&gt;<a class="code" href="structsnmp__session.html#o20">isAuthoritative</a> ==
02427                                         SNMP_SESS_AUTHORITATIVE) ? 0 : 1))
02428         == NULL) {
02429         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Unknown User(%s)\n"</span>, secName));
02430         <span class="keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSUNKNOWNUSERNAMES) == 0) {
02431             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>, <span class=
"stringliteral">"Failed to increment statistic."</span>));
02432         }
02433         <span class="keywordflow">return</span> SNMPERR_USM_UNKNOWNSECURITYNAME;
02434     }
02435 
02436 
02437     <span class="comment">/*</span>
02438 <span class="comment">     * Make sure the security level is appropriate.</span>
02439 <span class="comment">     */</span>
02440     <span class="keywordflow">if</span> (usm_check_secLevel(secLevel, user) == 1) {
02441         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Unsupported Security Level (%d).\n"</span>,
02442                     secLevel));
02443         <span class="keywordflow">if</span> (snmp_increment_statistic
02444             (STAT_USMSTATSUNSUPPORTEDSECLEVELS) == 0) {
02445             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>, <span class=
"stringliteral">"Failed to increment statistic."</span>));
02446         }
02447         <span class="keywordflow">return</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL;
02448     }
02449 
02450 
02451     <span class="comment">/*</span>
02452 <span class="comment">     * Check the authentication credentials of the message.</span>
02453 <span class="comment">     */</span>
02454     <span class="keywordflow">if</span> (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
02455         || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
02456         <span class="keywordflow">if</span> (sc_check_keyed_hash(user-&gt;authProtocol, user-&gt;authProtocolLen,
02457                                 user-&gt;authKey, user-&gt;authKeyLen,
02458                                 wholeMsg, wholeMsgLen,
02459                                 signature, signature_length)
02460             != SNMP_ERR_NOERROR) {
02461             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Verification failed.\n"</span>));
02462             <span class="keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSWRONGDIGESTS) == 0) {
02463                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>,
02464                             <span class="stringliteral">"Failed to increment statistic."</span>));
02465             }
02466             <a class="code" href="group__snmp__logging.html#ga39">snmp_log</a>(LOG_WARNING, <span class=
"stringliteral">"Authentication failed for %s\n"</span>,
02467                                 user-&gt;name);
02468             <span class="keywordflow">return</span> SNMPERR_USM_AUTHENTICATIONFAILURE;
02469         }
02470 
02471         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"Verification succeeded.\n"</span>));
02472     }
02473 
02474 
02475     <span class="comment">/*</span>
02476 <span class="comment">     * Steps 10-11  user is already set - relocated before timeliness </span>
02477 <span class="comment">     * check in case it fails - still save user data for response.</span>
02478 <span class="comment">     *</span>
02479 <span class="comment">     * Cache the keys and protocol oids, per step 11 (s3.2).</span>
02480 <span class="comment">     */</span>
02481     <span class="keywordflow">if</span> (secStateRef) {
02482         <span class="keywordflow">if</span> (usm_set_usmStateReference_auth_protocol(*secStateRef,
02483                                                     user-&gt;authProtocol,
02484                                                     user-&gt;
02485                                                     authProtocolLen) ==
02486             -1) {
02487             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>,
02488                         <span class="stringliteral">"Couldn't cache authentication protocol."</span>));
02489             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
02490         }
02491 
02492         <span class="keywordflow">if</span> (usm_set_usmStateReference_auth_key(*secStateRef,
02493                                                user-&gt;authKey,
02494                                                user-&gt;authKeyLen) == -1) {
02495             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>,
02496                         <span class="stringliteral">"Couldn't cache authentiation key."</span>));
02497             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
02498         }
02499 
02500         <span class="keywordflow">if</span> (usm_set_usmStateReference_priv_protocol(*secStateRef,
02501                                                     user-&gt;privProtocol,
02502                                                     user-&gt;
02503                                                     privProtocolLen) ==
02504             -1) {
02505             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>,
02506                         <span class="stringliteral">"Couldn't cache privacy protocol."</span>));
02507             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
02508         }
02509 
02510         <span class="keywordflow">if</span> (usm_set_usmStateReference_priv_key(*secStateRef,
02511                                                user-&gt;privKey,
02512                                                user-&gt;privKeyLen) == -1) {
02513             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>, <span class=
"stringliteral">"Couldn't cache privacy key."</span>));
02514             <span class="keywordflow">return</span> SNMPERR_USM_GENERICERROR;
02515         }
02516     }
02517 
02518 
02519     <span class="comment">/*</span>
02520 <span class="comment">     * Perform the timeliness/time manager functions.</span>
02521 <span class="comment">     */</span>
02522     <span class="keywordflow">if</span> (secLevel == SNMP_SEC_LEVEL_AUTHNOPRIV
02523         || secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
02524         <span class="keywordflow">if</span> (usm_check_and_update_timeliness(secEngineID, *secEngineIDLen,
02525                                             boots_uint, time_uint,
02526                                             &amp;error) == -1) {
02527             <span class="keywordflow">return</span> error;
02528         }
02529     }
02530 <span class="preprocessor">#ifdef                                                  LCD_TIME_SYNC_OPT</span>
02531     <span class="comment">/*</span>
02532 <span class="comment">     * Cache the unauthenticated time to use in case we don't have</span>
02533 <span class="comment">     * anything better - this guess will be no worse than (0,0)</span>
02534 <span class="comment">     * that we normally use.</span>
02535 <span class="comment">     */</span>
02536     <span class="keywordflow">else</span> {
02537         set_enginetime(secEngineID, *secEngineIDLen,
02538                        boots_uint, time_uint, FALSE);
02539     }
02540 <span class="preprocessor">#endif                          </span><span class="comment">/* LCD_TIME_SYNC_OPT */</span>
02541 
02542 
02543     <span class="comment">/*</span>
02544 <span class="comment">     * If needed, decrypt the scoped PDU.</span>
02545 <span class="comment">     */</span>
02546     <span class="keywordflow">if</span> (secLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
02547         remaining = wholeMsgLen - (data_ptr - wholeMsg);
02548 
02549         <span class="keywordflow">if</span> ((value_ptr = asn_parse_sequence(data_ptr, &amp;remaining,
02550                                             &amp;type_value,
02551                                             (ASN_UNIVERSAL | ASN_PRIMITIVE
02552                                              | ASN_OCTET_STR),
02553                                             <span class="stringliteral">"encrypted sPDU"</span>)) == NULL) {
02554             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>,
02555                         <span class="stringliteral">"Failed while parsing encrypted sPDU."</span>));
02556             <span class="keywordflow">if</span> (snmp_increment_statistic(STAT_SNMPINASNPARSEERRS) == 0) {
02557                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Failed increment statistic."</span>));
02558             }
02559             usm_free_usmStateReference(*secStateRef);
02560             *secStateRef = NULL;
02561             <span class="keywordflow">return</span> SNMPERR_USM_PARSEERROR;
02562         }
02563 
02564 <span class="preprocessor">#ifndef DISABLE_DES</span>
02565         <span class="keywordflow">if</span> (ISTRANSFORM(user-&gt;privProtocol, DESPriv)) {
02566             <span class="comment">/*</span>
02567 <span class="comment">             * From RFC2574:</span>
02568 <span class="comment">             * </span>
02569 <span class="comment">             * "Before decryption, the encrypted data length is verified.</span>
02570 <span class="comment">             * If the length of the OCTET STRING to be decrypted is not</span>
02571 <span class="comment">             * an integral multiple of 8 octets, the decryption process</span>
02572 <span class="comment">             * is halted and an appropriate exception noted."  </span>
02573 <span class="comment">             */</span>
02574 
02575             <span class="keywordflow">if</span> (remaining % 8 != 0) {
02576                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>,
02577                             <span class=
"stringliteral">"Ciphertext is %lu bytes, not an integer multiple of 8 (rem %d)\n"</span>,
02578                             remaining, remaining % 8));
02579                 <span class="keywordflow">if</span> (snmp_increment_statistic(STAT_USMSTATSDECRYPTIONERRORS) ==
02580                     0) {
02581                     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Failed increment statistic."</span>));
02582                 }
02583                 usm_free_usmStateReference(*secStateRef);
02584                 *secStateRef = NULL;
02585                 <span class="keywordflow">return</span> SNMPERR_USM_DECRYPTIONERROR;
02586             }
02587 
02588             end_of_overhead = value_ptr;
02589 
02590             <span class="comment">/*</span>
02591 <span class="comment">             * XOR the salt with the last (iv_length) bytes</span>
02592 <span class="comment">             * of the priv_key to obtain the IV.</span>
02593 <span class="comment">             */</span>
02594             iv_length = BYTESIZE(USM_DES_SALT_LENGTH);
02595             <span class="keywordflow">for</span> (i = 0; i &lt; (int) iv_length; i++)
02596                 iv[i] = salt[i] ^ user-&gt;privKey[iv_length + i];
02597         }
02598 <span class="preprocessor">#endif</span>
02599 <span class="preprocessor">#ifdef HAVE_AES</span>
02600         <span class="keywordflow">if</span> (ISTRANSFORM(user-&gt;privProtocol, AESPriv)) {
02601             iv_length = BYTESIZE(USM_AES_SALT_LENGTH);
02602             net_boots = ntohl(boots_uint);
02603             net_time = ntohl(time_uint);
02604             memcpy(iv, &amp;net_boots, 4);
02605             memcpy(iv+4, &amp;net_time, 4);
02606             memcpy(iv+8, salt, salt_length);
02607         }
02608 <span class="preprocessor">#endif</span>
02609         
02610         <span class="keywordflow">if</span> (sc_decrypt(user-&gt;privProtocol, user-&gt;privProtocolLen,
02611                        user-&gt;privKey, user-&gt;privKeyLen,
02612                        iv, iv_length,
02613                        value_ptr, remaining, *scopedPdu, scopedPduLen)
02614             != SNMP_ERR_NOERROR) {
02615             DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"%s\n"</span>, <span class=
"stringliteral">"Failed decryption."</span>));
02616             <span class="keywordflow">if</span> (snmp_increment_statistic
02617                 (STAT_USMSTATSDECRYPTIONERRORS) == 0) {
02618                 DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"%s\n"</span>, <span class="stringliteral">"Failed increment statistic."</span>));
02619             }
02620             <span class="keywordflow">return</span> SNMPERR_USM_DECRYPTIONERROR;
02621         }
02622 <span class="preprocessor">#ifdef SNMP_TESTING_CODE</span>
02623         <span class="keywordflow">if</span> (debug_is_token_registered(<span class=
"stringliteral">"usm/dump"</span>) == SNMPERR_SUCCESS) {
02624             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"Cypher Text"</span>, value_ptr, remaining);
02625             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"salt + Encrypted form:"</span>,
02626                        salt, salt_length);
02627             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"IV + Encrypted form:"</span>, iv, iv_length);
02628             dump_chunk(<span class="stringliteral">"usm/dump"</span>, <span class=
"stringliteral">"Decrypted chunk:"</span>,
02629                        *scopedPdu, *scopedPduLen);
02630         }
02631 <span class="preprocessor">#endif</span>
02632     }
02633     <span class="comment">/*</span>
02634 <span class="comment">     * sPDU is plaintext.</span>
02635 <span class="comment">     */</span>
02636     <span class="keywordflow">else</span> {
02637         *scopedPdu = data_ptr;
02638         *scopedPduLen = wholeMsgLen - (data_ptr - wholeMsg);
02639         end_of_overhead = data_ptr;
02640 
02641     }                           <span class="comment">/* endif -- PDU decryption */</span>
02642 
02643 
02644     <span class="comment">/*</span>
02645 <span class="comment">     * Calculate the biggest sPDU for the response (i.e., whole - ovrhd).</span>
02646 <span class="comment">     *</span>
02647 <span class="comment">     * FIX  Correct? </span>
02648 <span class="comment">     */</span>
02649     *maxSizeResponse = maxMsgSize - (int)
02650         ((u_long) end_of_overhead - (u_long) wholeMsg);
02651 
02652 
02653     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"USM processing completed.\n"</span>));
02654 
02655     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
02656 
02657 }                               <span class="comment">/* end usm_process_in_msg() */</span>
02658 
02659 <span class="keywordtype">void</span>
02660 usm_handle_report(<span class="keywordtype">void</span> *sessp,
02661                   netsnmp_transport *transport, <a class="code" href=
"structsnmp__session.html">netsnmp_session</a> *session,
02662                   <span class="keywordtype">int</span> result, <a class="code" href=
"structsnmp__pdu.html">netsnmp_pdu</a> *pdu)
02663 {
02664     <span class="comment">/*</span>
02665 <span class="comment">     * handle reportable errors </span>
02666 <span class="comment">     */</span>
02667 
02668     <span class="comment">/* this will get in our way */</span>
02669     usm_free_usmStateReference(pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a>);
02670     pdu-&gt;<a class="code" href="structsnmp__pdu.html#o35">securityStateRef</a> = NULL;
02671 
02672     <span class="keywordflow">switch</span> (result) {
02673     <span class="keywordflow">case</span> SNMPERR_USM_AUTHENTICATIONFAILURE:
02674     {
02675         <span class="keywordtype">int</span> res = session-&gt;<a class="code" href=
"structsnmp__session.html#o14">s_snmp_errno</a>;
02676         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = result;
02677         <span class="keywordflow">if</span> (session-&gt;<a class="code" href=
"structsnmp__session.html#o11">callback</a>) {
02678             session-&gt;<a class="code" href=
"structsnmp__session.html#o11">callback</a>(NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE,
02679                               session, pdu-&gt;<a class="code" href="structsnmp__pdu.html#o2">reqid</a>, pdu,
02680                               session-&gt;<a class="code" href="structsnmp__session.html#o12">callback_magic</a>);
02681         }
02682         session-&gt;<a class="code" href="structsnmp__session.html#o14">s_snmp_errno</a> = res;
02683     }  
02684     <span class="keywordflow">case</span> SNMPERR_USM_UNKNOWNENGINEID:
02685     <span class="keywordflow">case</span> SNMPERR_USM_UNKNOWNSECURITYNAME:
02686     <span class="keywordflow">case</span> SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL:
02687     <span class="keywordflow">case</span> SNMPERR_USM_NOTINTIMEWINDOW:
02688     <span class="keywordflow">case</span> SNMPERR_USM_DECRYPTIONERROR:
02689 
02690         <span class="keywordflow">if</span> (SNMP_CMD_CONFIRMED(pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o1">command</a>) ||
02691             (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o1">command</a> == 0
02692              &amp;&amp; (pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> &amp; SNMP_MSG_FLAG_RPRT_BIT))) {
02693             <a class="code" href="structsnmp__pdu.html">netsnmp_pdu</a>    *pdu2;
02694             <span class="keywordtype">int</span>             flags = pdu-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a>;
02695 
02696             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> |= UCD_MSG_FLAG_FORCE_PDU_COPY;
02697             pdu2 = snmp_clone_pdu(pdu);
02698             pdu-&gt;<a class="code" href="structsnmp__pdu.html#o9">flags</a> = pdu2-&gt;<a class="code" href=
"structsnmp__pdu.html#o9">flags</a> = flags;
02699             snmpv3_make_report(pdu2, result);
02700             <span class="keywordflow">if</span> (0 == snmp_sess_send(sessp, pdu2)) {
02701                 snmp_free_pdu(pdu2);
02702                 <span class="comment">/*</span>
02703 <span class="comment">                 * TODO: indicate error </span>
02704 <span class="comment">                 */</span>
02705             }
02706         }
02707         <span class="keywordflow">break</span>;
02708     }       
02709 }
02710 <span class="keywordtype">void</span>
02711 init_usm(<span class="keywordtype">void</span>)
02712 {
02713     <span class="keyword">struct </span>snmp_secmod_def *def;
02714 
02715     DEBUGMSGTL((<span class="stringliteral">"init_usm"</span>, <span class=
"stringliteral">"unit_usm: %d %d\n"</span>, usmNoPrivProtocol[0],
02716                 usmNoPrivProtocol[1]));
02717 
02718     sc_init();                  <span class="comment">/* initalize scapi code */</span>
02719 
02720     <span class="comment">/*</span>
02721 <span class="comment">     * register ourselves as a security service </span>
02722 <span class="comment">     */</span>
02723     def = <a class="code" href="group__util.html#ga38">SNMP_MALLOC_STRUCT</a>(snmp_secmod_def);
02724     <span class="comment">/*</span>
02725 <span class="comment">     * XXX: def-&gt;init_sess_secmod move stuff from snmp_api.c </span>
02726 <span class="comment">     */</span>
02727     def-&gt;encode_reverse = usm_secmod_rgenerate_out_msg;
02728     def-&gt;encode_forward = usm_secmod_generate_out_msg;
02729     def-&gt;decode = usm_secmod_process_in_msg;
02730     def-&gt;pdu_free_state_ref = usm_free_usmStateReference;
02731     def-&gt;handle_report = usm_handle_report;
02732     register_sec_mod(USM_SEC_MODEL_NUMBER, <span class="stringliteral">"usm"</span>, def);
02733 
02734     <a class="code" href="group__callback.html#ga3">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
02735                            SNMP_CALLBACK_POST_PREMIB_READ_CONFIG,
02736                            init_usm_post_config, NULL);
02737 
02738     <a class="code" href="group__callback.html#ga3">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
02739                            SNMP_CALLBACK_SHUTDOWN,
02740                            deinit_usm_post_config, NULL);
02741 
02742     <a class="code" href="group__callback.html#ga3">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY,
02743                            SNMP_CALLBACK_SHUTDOWN,
02744                            free_engineID, NULL);
02745 
02746 }
02747 
02748 <span class="keywordtype">void</span>
02749 init_usm_conf(<span class="keyword">const</span> <span class="keywordtype">char</span> *app)
02750 {
02751     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(app, <span class=
"stringliteral">"usmUser"</span>,
02752                                   usm_parse_config_usmUser, NULL, NULL);
02753     <a class="code" href="group__read__config.html#ga8">register_config_handler</a>(app, <span class=
"stringliteral">"createUser"</span>,
02754                                   usm_parse_create_usmUser, NULL,
02755                                   <span class="stringliteral">"username (MD5|SHA) passphrase [DES [passphrase]]"</span>);
02756 
02757     <span class="comment">/*</span>
02758 <span class="comment">     * we need to be called back later </span>
02759 <span class="comment">     */</span>
02760     <a class="code" href=
"group__callback.html#ga3">snmp_register_callback</a>(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
02761                            usm_store_users, NULL);
02762 }
02763 
02764 <span class="comment">/*</span>
02765 <span class="comment"> * initializations for the USM.</span>
02766 <span class="comment"> *</span>
02767 <span class="comment"> * Should be called after the (engineid) configuration files have been read.</span>
02768 <span class="comment"> *</span>
02769 <span class="comment"> * Set "arbitrary" portion of salt to a random number.</span>
02770 <span class="comment"> */</span>
02771 <span class="keywordtype">int</span>
02772 init_usm_post_config(<span class="keywordtype">int</span> majorid, <span class=
"keywordtype">int</span> minorid, <span class="keywordtype">void</span> *serverarg,
02773                      <span class="keywordtype">void</span> *clientarg)
02774 {
02775     size_t          salt_integer_len = <span class="keyword">sizeof</span>(salt_integer);
02776 
02777     <span class="keywordflow">if</span> (sc_random((u_char *) &amp; salt_integer, &amp;salt_integer_len) !=
02778         SNMPERR_SUCCESS) {
02779         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"sc_random() failed: using time() as salt.\n"</span>));
02780         salt_integer = (u_int) time(NULL);
02781     }
02782 
02783 <span class="preprocessor">#ifdef HAVE_AES</span>
02784     salt_integer_len = <span class="keyword">sizeof</span> (salt_integer64_1);
02785     <span class="keywordflow">if</span> (sc_random((u_char *) &amp; salt_integer64_1, &amp;salt_integer_len) !=
02786         SNMPERR_SUCCESS) {
02787         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"sc_random() failed: using time() as aes1 salt.\n"</span>));
02788         salt_integer64_1 = (u_int) time(NULL);
02789     }
02790     salt_integer_len = <span class="keyword">sizeof</span> (salt_integer64_1);
02791     <span class="keywordflow">if</span> (sc_random((u_char *) &amp; salt_integer64_2, &amp;salt_integer_len) !=
02792         SNMPERR_SUCCESS) {
02793         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"sc_random() failed: using time() as aes2 salt.\n"</span>));
02794         salt_integer64_2 = (u_int) time(NULL);
02795     }
02796 <span class="preprocessor">#endif</span>
02797     
02798 <span class="preprocessor">#ifndef DISABLE_MD5</span>
02799     noNameUser = usm_create_initial_user(<span class="stringliteral">""</span>, usmHMACMD5AuthProtocol,
02800                                          USM_LENGTH_OID_TRANSFORM,
02801 #ifndef DISABLE_DES
02802                                          usmDESPrivProtocol,
02803 #<span class="keywordflow">else</span>
02804                                          usmAESPrivProtocol,
02805 #endif
02806                                          USM_LENGTH_OID_TRANSFORM);
02807 <span class="preprocessor">#else</span>
02808     noNameUser = usm_create_initial_user(<span class="stringliteral">""</span>, usmHMACSHA1AuthProtocol,
02809                                          USM_LENGTH_OID_TRANSFORM,
02810 #ifndef DISABLE_DES
02811                                          usmDESPrivProtocol,
02812 #<span class="keywordflow">else</span>
02813                                          usmAESPrivProtocol,
02814 #endif
02815                                          USM_LENGTH_OID_TRANSFORM);
02816 <span class="preprocessor">#endif</span>
02817 
02818     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(noNameUser-&gt;engineID);
02819     noNameUser-&gt;engineIDLen = 0;
02820 
02821     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
02822 }                               <span class="comment">/* end init_usm_post_config() */</span>
02823 
02824 <span class="keywordtype">int</span>
02825 deinit_usm_post_config(<span class="keywordtype">int</span> majorid, <span class=
"keywordtype">int</span> minorid, <span class="keywordtype">void</span> *serverarg,
02826                        <span class="keywordtype">void</span> *clientarg)
02827 {
02828     <span class="keywordflow">if</span> (usm_free_user(noNameUser) != NULL) {
02829         DEBUGMSGTL((<span class="stringliteral">"deinit_usm_post_config"</span>, <span class=
"stringliteral">"could not free initial user\n"</span>));
02830         <span class="keywordflow">return</span> SNMPERR_GENERR;
02831     }
02832     noNameUser = NULL;
02833 
02834     DEBUGMSGTL((<span class="stringliteral">"deinit_usm_post_config"</span>, <span class=
"stringliteral">"initial user removed\n"</span>));
02835     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
02836 }                               <span class="comment">/* end deinit_usm_post_config() */</span>
02837 
02838 <span class="keywordtype">void</span>
02839 clear_user_list(<span class="keywordtype">void</span>)
02840 {
02841     <span class="keyword">struct </span>usmUser *tmp = userList, *next = NULL;
02842 
02843     <span class="keywordflow">while</span> (tmp != NULL) {
02844         next = tmp-&gt;next;
02845         usm_free_user(tmp);
02846         tmp = next;
02847     }
02848     userList = NULL;
02849 
02850 }
02851 
02852 <span class="comment">/*******************************************************************-o-******</span>
02853 <span class="comment"> * usm_check_secLevel</span>
02854 <span class="comment"> *</span>
02855 <span class="comment"> * Parameters:</span>
02856 <span class="comment"> *       level</span>
02857 <span class="comment"> *      *user</span>
02858 <span class="comment"> *      </span>
02859 <span class="comment"> * Returns:</span>
02860 <span class="comment"> *      0       On success,</span>
02861 <span class="comment"> *      -1      Otherwise.</span>
02862 <span class="comment"> *</span>
02863 <span class="comment"> * Checks that a given security level is valid for a given user.</span>
02864 <span class="comment"> */</span>
02865 <span class="keywordtype">int</span>
02866 usm_check_secLevel(<span class="keywordtype">int</span> level, <span class="keyword">struct</span> usmUser *user)
02867 {
02868 
02869     <span class="keywordflow">if</span> (user-&gt;userStatus != RS_ACTIVE)
02870         <span class="keywordflow">return</span> -1;
02871 
02872     DEBUGMSGTL((<span class="stringliteral">"comparex"</span>, <span class=
"stringliteral">"Comparing: %d %d "</span>, usmNoPrivProtocol[0],
02873                 usmNoPrivProtocol[1]));
02874     DEBUGMSGOID((<span class="stringliteral">"comparex"</span>, usmNoPrivProtocol,
02875                  <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid)));
02876     DEBUGMSG((<span class="stringliteral">"comparex"</span>, <span class="stringliteral">"\n"</span>));
02877     <span class="keywordflow">if</span> (level == SNMP_SEC_LEVEL_AUTHPRIV
02878         &amp;&amp; (<a class="code" href=
"group__library.html#ga100">netsnmp_oid_equals</a>(user-&gt;privProtocol, user-&gt;privProtocolLen,
02879                              usmNoPrivProtocol,
02880                              <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class=
"keyword">sizeof</span>(oid)) ==
02881             0)) {
02882         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"Level: %d\n"</span>, level));
02883         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"User (%s) Auth Protocol: "</span>, user-&gt;name));
02884         DEBUGMSGOID((<span class="stringliteral">"usm"</span>, user-&gt;authProtocol, user-&gt;authProtocolLen));
02885         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class="stringliteral">", User Priv Protocol: "</span>));
02886         DEBUGMSGOID((<span class="stringliteral">"usm"</span>, user-&gt;privProtocol, user-&gt;privProtocolLen));
02887         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"\n"</span>));
02888         <span class="keywordflow">return</span> 1;
02889     }
02890     <span class="keywordflow">if</span> ((level == SNMP_SEC_LEVEL_AUTHPRIV
02891          || level == SNMP_SEC_LEVEL_AUTHNOPRIV)
02892         &amp;&amp;
02893         (<a class="code" href="group__library.html#ga100">netsnmp_oid_equals</a>
02894          (user-&gt;authProtocol, user-&gt;authProtocolLen, usmNoAuthProtocol,
02895           <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class="keyword">sizeof</span>(oid)) == 0)) {
02896         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"Level: %d\n"</span>, level));
02897         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"User (%s) Auth Protocol: "</span>, user-&gt;name));
02898         DEBUGMSGOID((<span class="stringliteral">"usm"</span>, user-&gt;authProtocol, user-&gt;authProtocolLen));
02899         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class="stringliteral">", User Priv Protocol: "</span>));
02900         DEBUGMSGOID((<span class="stringliteral">"usm"</span>, user-&gt;privProtocol, user-&gt;privProtocolLen));
02901         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"\n"</span>));
02902         <span class="keywordflow">return</span> 1;
02903     }
02904 
02905     <span class="keywordflow">return</span> 0;
02906 
02907 }                               <span class="comment">/* end usm_check_secLevel() */</span>
02908 
02909 
02910 
02911 
02912 <span class="comment">/*******************************************************************-o-******</span>
02913 <span class="comment"> * usm_check_secLevel_vs_protocols</span>
02914 <span class="comment"> *</span>
02915 <span class="comment"> * Parameters:</span>
02916 <span class="comment"> *       level</span>
02917 <span class="comment"> *      *authProtocol</span>
02918 <span class="comment"> *       authProtocolLen</span>
02919 <span class="comment"> *      *privProtocol</span>
02920 <span class="comment"> *       privProtocolLen</span>
02921 <span class="comment"> *      </span>
02922 <span class="comment"> * Returns:</span>
02923 <span class="comment"> *      0       On success,</span>
02924 <span class="comment"> *      1       Otherwise.</span>
02925 <span class="comment"> *</span>
02926 <span class="comment"> * Same as above but with explicitly named transform types instead of taking</span>
02927 <span class="comment"> * from the usmUser structure.</span>
02928 <span class="comment"> */</span>
02929 <span class="keywordtype">int</span>
02930 usm_check_secLevel_vs_protocols(<span class="keywordtype">int</span> level,
02931                                 <span class="keyword">const</span> oid * authProtocol,
02932                                 u_int authProtocolLen,
02933                                 <span class="keyword">const</span> oid * privProtocol,
02934                                 u_int privProtocolLen)
02935 {
02936 
02937     <span class="keywordflow">if</span> (level == SNMP_SEC_LEVEL_AUTHPRIV
02938         &amp;&amp;
02939         (<a class="code" href="group__library.html#ga100">netsnmp_oid_equals</a>
02940          (privProtocol, privProtocolLen, usmNoPrivProtocol,
02941           <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class="keyword">sizeof</span>(oid)) == 0)) {
02942         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"Level: %d\n"</span>, level));
02943         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"Auth Protocol: "</span>));
02944         DEBUGMSGOID((<span class="stringliteral">"usm"</span>, authProtocol, authProtocolLen));
02945         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class="stringliteral">", Priv Protocol: "</span>));
02946         DEBUGMSGOID((<span class="stringliteral">"usm"</span>, privProtocol, privProtocolLen));
02947         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"\n"</span>));
02948         <span class="keywordflow">return</span> 1;
02949     }
02950     <span class="keywordflow">if</span> ((level == SNMP_SEC_LEVEL_AUTHPRIV
02951          || level == SNMP_SEC_LEVEL_AUTHNOPRIV)
02952         &amp;&amp;
02953         (<a class="code" href="group__library.html#ga100">netsnmp_oid_equals</a>
02954          (authProtocol, authProtocolLen, usmNoAuthProtocol,
02955           <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class="keyword">sizeof</span>(oid)) == 0)) {
02956         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"Level: %d\n"</span>, level));
02957         DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"Auth Protocol: "</span>));
02958         DEBUGMSGOID((<span class="stringliteral">"usm"</span>, authProtocol, authProtocolLen));
02959         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class="stringliteral">", Priv Protocol: "</span>));
02960         DEBUGMSGOID((<span class="stringliteral">"usm"</span>, privProtocol, privProtocolLen));
02961         DEBUGMSG((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"\n"</span>));
02962         <span class="keywordflow">return</span> 1;
02963     }
02964 
02965     <span class="keywordflow">return</span> 0;
02966 
02967 }                               <span class="comment">/* end usm_check_secLevel_vs_protocols() */</span>
02968 
02969 
02970 
02971 
02972 <span class="comment">/*</span>
02973 <span class="comment"> * usm_get_user(): Returns a user from userList based on the engineID,</span>
02974 <span class="comment"> * engineIDLen and name of the requested user. </span>
02975 <span class="comment"> */</span>
02976 
02977 <span class="keyword">struct </span>usmUser *
02978 usm_get_user(u_char * engineID, size_t engineIDLen, <span class="keywordtype">char</span> *name)
02979 {
02980     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class="stringliteral">"getting user %s\n"</span>, name));
02981     <span class="keywordflow">return</span> usm_get_user_from_list(engineID, engineIDLen, name, userList,
02982                                   1);
02983 }
02984 
02985 <span class="keyword">struct </span>usmUser *
02986 usm_get_user_from_list(u_char * engineID, size_t engineIDLen,
02987                        <span class="keywordtype">char</span> *name, <span class="keyword">struct</span> usmUser *puserList,
02988                        <span class="keywordtype">int</span> use_default)
02989 {
02990     <span class="keyword">struct </span>usmUser *ptr;
02991     <span class="keywordtype">char</span>            noName[] = <span class="stringliteral">""</span>;
02992     <span class="keywordflow">if</span> (name == NULL)
02993         name = noName;
02994     <span class="keywordflow">for</span> (ptr = puserList; ptr != NULL; ptr = ptr-&gt;next) {
02995         <span class="keywordflow">if</span> (ptr-&gt;name &amp;&amp; !strcmp(ptr-&gt;name, name) &amp;&amp;
02996             ptr-&gt;engineIDLen == engineIDLen &amp;&amp;
02997             ((ptr-&gt;engineID == NULL &amp;&amp; engineID == NULL) ||
02998              (ptr-&gt;engineID != NULL &amp;&amp; engineID != NULL &amp;&amp;
02999               memcmp(ptr-&gt;engineID, engineID, engineIDLen) == 0)))
03000             <span class="keywordflow">return</span> ptr;
03001     }
03002 
03003     <span class="comment">/*</span>
03004 <span class="comment">     * return "" user used to facilitate engineID discovery </span>
03005 <span class="comment">     */</span>
03006     <span class="keywordflow">if</span> (use_default &amp;&amp; !strcmp(name, <span class="stringliteral">""</span>))
03007         <span class="keywordflow">return</span> noNameUser;
03008     <span class="keywordflow">return</span> NULL;
03009 }
03010 
03011 <span class="comment">/*</span>
03012 <span class="comment"> * usm_add_user(): Add's a user to the userList, sorted by the</span>
03013 <span class="comment"> * engineIDLength then the engineID then the name length then the name</span>
03014 <span class="comment"> * to facilitate getNext calls on a usmUser table which is indexed by</span>
03015 <span class="comment"> * these values.</span>
03016 <span class="comment"> * </span>
03017 <span class="comment"> * Note: userList must not be NULL (obviously), as thats a rather trivial</span>
03018 <span class="comment"> * addition and is left to the API user.</span>
03019 <span class="comment"> * </span>
03020 <span class="comment"> * returns the head of the list (which could change due to this add).</span>
03021 <span class="comment"> */</span>
03022 
03023 <span class="keyword">struct </span>usmUser *
03024 usm_add_user(<span class="keyword">struct</span> usmUser *user)
03025 {
03026     <span class="keyword">struct </span>usmUser *uptr;
03027     uptr = usm_add_user_to_list(user, userList);
03028     <span class="keywordflow">if</span> (uptr != NULL)
03029         userList = uptr;
03030     <span class="keywordflow">return</span> uptr;
03031 }
03032 
03033 <span class="keyword">struct </span>usmUser *
03034 usm_add_user_to_list(<span class="keyword">struct</span> usmUser *user, <span class=
"keyword">struct</span> usmUser *puserList)
03035 {
03036     <span class="keyword">struct </span>usmUser *nptr, *pptr, *optr;
03037 
03038     <span class="comment">/*</span>
03039 <span class="comment">     * loop through puserList till we find the proper, sorted place to</span>
03040 <span class="comment">     * insert the new user </span>
03041 <span class="comment">     */</span>
03042     <span class="comment">/* XXX - how to handle a NULL user-&gt;name ?? */</span>
03043     <span class="comment">/* XXX - similarly for a NULL nptr-&gt;name ?? */</span>
03044     <span class="keywordflow">for</span> (nptr = puserList, pptr = NULL; nptr != NULL;
03045          pptr = nptr, nptr = nptr-&gt;next) {
03046         <span class="keywordflow">if</span> (nptr-&gt;engineIDLen &gt; user-&gt;engineIDLen)
03047             <span class="keywordflow">break</span>;
03048 
03049         <span class="keywordflow">if</span> (user-&gt;engineID == NULL &amp;&amp; nptr-&gt;engineID != NULL)
03050             <span class="keywordflow">break</span>;
03051 
03052         <span class="keywordflow">if</span> (nptr-&gt;engineIDLen == user-&gt;engineIDLen &amp;&amp;
03053             (nptr-&gt;engineID != NULL &amp;&amp; user-&gt;engineID != NULL &amp;&amp;
03054              memcmp(nptr-&gt;engineID, user-&gt;engineID,
03055                     user-&gt;engineIDLen) &gt; 0))
03056             <span class="keywordflow">break</span>;
03057 
03058         <span class="keywordflow">if</span> (!(nptr-&gt;engineID == NULL &amp;&amp; user-&gt;engineID != NULL)) {
03059             <span class="keywordflow">if</span> (nptr-&gt;engineIDLen == user-&gt;engineIDLen &amp;&amp;
03060                 ((nptr-&gt;engineID == NULL &amp;&amp; user-&gt;engineID == NULL) ||
03061                  memcmp(nptr-&gt;engineID, user-&gt;engineID,
03062                         user-&gt;engineIDLen) == 0)
03063                 &amp;&amp; strlen(nptr-&gt;name) &gt; strlen(user-&gt;name))
03064                 <span class="keywordflow">break</span>;
03065 
03066             <span class="keywordflow">if</span> (nptr-&gt;engineIDLen == user-&gt;engineIDLen &amp;&amp;
03067                 ((nptr-&gt;engineID == NULL &amp;&amp; user-&gt;engineID == NULL) ||
03068                  memcmp(nptr-&gt;engineID, user-&gt;engineID,
03069                         user-&gt;engineIDLen) == 0)
03070                 &amp;&amp; strlen(nptr-&gt;name) == strlen(user-&gt;name)
03071                 &amp;&amp; strcmp(nptr-&gt;name, user-&gt;name) &gt; 0)
03072                 <span class="keywordflow">break</span>;
03073 
03074             <span class="keywordflow">if</span> (nptr-&gt;engineIDLen == user-&gt;engineIDLen &amp;&amp;
03075                 ((nptr-&gt;engineID == NULL &amp;&amp; user-&gt;engineID == NULL) ||
03076                  memcmp(nptr-&gt;engineID, user-&gt;engineID,
03077                         user-&gt;engineIDLen) == 0)
03078                 &amp;&amp; strlen(nptr-&gt;name) == strlen(user-&gt;name)
03079                 &amp;&amp; strcmp(nptr-&gt;name, user-&gt;name) == 0) {
03080                 <span class="comment">/*</span>
03081 <span class="comment">                 * the user is an exact match of a previous entry.</span>
03082 <span class="comment">                 * Credentials may be different, though, so remove</span>
03083 <span class="comment">                 * the old entry (and add the new one)!</span>
03084 <span class="comment">                 */</span>
03085                 <span class="keywordflow">if</span> (pptr) { <span class="comment">/* change prev's next pointer */</span>
03086                   pptr-&gt;next = nptr-&gt;next;
03087                 }
03088                 <span class="keywordflow">if</span> (nptr-&gt;next) { <span class=
"comment">/* change next's prev pointer */</span>
03089                   nptr-&gt;next-&gt;prev = pptr;
03090                 } 
03091                 optr = nptr;
03092                 nptr = optr-&gt;next; <span class="comment">/* add new user at this position */</span>
03093                 <span class="comment">/* free the old user */</span>
03094                 optr-&gt;next=NULL;
03095                 optr-&gt;prev=NULL;
03096                 usm_free_user(optr); 
03097                 <span class="keywordflow">break</span>; <span class="comment">/* new user will be added below */</span>
03098             }
03099         }
03100     }
03101 
03102     <span class="comment">/*</span>
03103 <span class="comment">     * nptr should now point to the user that we need to add ourselves</span>
03104 <span class="comment">     * in front of, and pptr should be our new 'prev'. </span>
03105 <span class="comment">     */</span>
03106 
03107     <span class="comment">/*</span>
03108 <span class="comment">     * change our pointers </span>
03109 <span class="comment">     */</span>
03110     user-&gt;prev = pptr;
03111     user-&gt;next = nptr;
03112 
03113     <span class="comment">/*</span>
03114 <span class="comment">     * change the next's prev pointer </span>
03115 <span class="comment">     */</span>
03116     <span class="keywordflow">if</span> (user-&gt;next)
03117         user-&gt;next-&gt;prev = user;
03118 
03119     <span class="comment">/*</span>
03120 <span class="comment">     * change the prev's next pointer </span>
03121 <span class="comment">     */</span>
03122     <span class="keywordflow">if</span> (user-&gt;prev)
03123         user-&gt;prev-&gt;next = user;
03124 
03125     <span class="comment">/*</span>
03126 <span class="comment">     * rewind to the head of the list and return it (since the new head</span>
03127 <span class="comment">     * could be us, we need to notify the above routine who the head now is. </span>
03128 <span class="comment">     */</span>
03129     <span class="keywordflow">for</span> (pptr = user; pptr-&gt;prev != NULL; pptr = pptr-&gt;prev);
03130     <span class="keywordflow">return</span> pptr;
03131 }
03132 
03133 <span class="comment">/*</span>
03134 <span class="comment"> * usm_remove_user(): finds and removes a user from a list </span>
03135 <span class="comment"> */</span>
03136 <span class="keyword">struct </span>usmUser *
03137 usm_remove_user(<span class="keyword">struct</span> usmUser *user)
03138 {
03139     <span class="keywordflow">return</span> usm_remove_user_from_list(user, &amp;userList);
03140 }
03141 
03142 <span class="keyword">struct </span>usmUser *
03143 usm_remove_user_from_list(<span class="keyword">struct</span> usmUser *user,
03144                           <span class="keyword">struct</span> usmUser **ppuserList)
03145 {
03146     <span class="keyword">struct </span>usmUser *nptr, *pptr;
03147 
03148     <span class="comment">/*</span>
03149 <span class="comment">     * NULL pointers aren't allowed </span>
03150 <span class="comment">     */</span>
03151     <span class="keywordflow">if</span> (ppuserList == NULL)
03152         <span class="keywordflow">return</span> NULL;
03153 
03154     <span class="keywordflow">if</span> (*ppuserList == NULL)
03155         <span class="keywordflow">return</span> NULL;
03156 
03157     <span class="comment">/*</span>
03158 <span class="comment">     * find the user in the list </span>
03159 <span class="comment">     */</span>
03160     <span class="keywordflow">for</span> (nptr = *ppuserList, pptr = NULL; nptr != NULL;
03161          pptr = nptr, nptr = nptr-&gt;next) {
03162         <span class="keywordflow">if</span> (nptr == user)
03163             <span class="keywordflow">break</span>;
03164     }
03165 
03166     <span class="keywordflow">if</span> (nptr) {
03167         <span class="comment">/*</span>
03168 <span class="comment">         * remove the user from the linked list </span>
03169 <span class="comment">         */</span>
03170         <span class="keywordflow">if</span> (pptr) {
03171             pptr-&gt;next = nptr-&gt;next;
03172         }
03173         <span class="keywordflow">if</span> (nptr-&gt;next) {
03174             nptr-&gt;next-&gt;prev = pptr;
03175         }
03176     } <span class="keywordflow">else</span> {
03177         <span class="comment">/*</span>
03178 <span class="comment">         * user didn't exist </span>
03179 <span class="comment">         */</span>
03180         <span class="keywordflow">return</span> NULL;
03181     }
03182     <span class="keywordflow">if</span> (nptr == *ppuserList)    <span class=
"comment">/* we're the head of the list, need to change</span>
03183 <span class="comment">                                 * * the head to the next user */</span>
03184         *ppuserList = nptr-&gt;next;
03185     <span class="keywordflow">return</span> *ppuserList;
03186 }                               <span class="comment">/* end usm_remove_user_from_list() */</span>
03187 
03188 
03189 
03190 
03191 <span class="comment">/*</span>
03192 <span class="comment"> * usm_free_user():  calls free() on all needed parts of struct usmUser and</span>
03193 <span class="comment"> * the user himself.</span>
03194 <span class="comment"> * </span>
03195 <span class="comment"> * Note: This should *not* be called on an object in a list (IE,</span>
03196 <span class="comment"> * remove it from the list first, and set next and prev to NULL), but</span>
03197 <span class="comment"> * will try to reconnect the list pieces again if it is called this</span>
03198 <span class="comment"> * way.  If called on the head of the list, the entire list will be</span>
03199 <span class="comment"> * lost. </span>
03200 <span class="comment"> */</span>
03201 <span class="keyword">struct </span>usmUser *
03202 usm_free_user(<span class="keyword">struct</span> usmUser *user)
03203 {
03204     <span class="keywordflow">if</span> (user == NULL)
03205         <span class="keywordflow">return</span> NULL;
03206 
03207     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;engineID);
03208     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;name);
03209     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;secName);
03210     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;cloneFrom);
03211     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;userPublicString);
03212     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;authProtocol);
03213     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;privProtocol);
03214 
03215     <span class="keywordflow">if</span> (user-&gt;authKey != NULL) {
03216         <a class="code" href="group__util.html#ga40">SNMP_ZERO</a>(user-&gt;authKey, user-&gt;authKeyLen);
03217         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;authKey);
03218     }
03219 
03220     <span class="keywordflow">if</span> (user-&gt;privKey != NULL) {
03221         <a class="code" href="group__util.html#ga40">SNMP_ZERO</a>(user-&gt;privKey, user-&gt;privKeyLen);
03222         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;privKey);
03223     }
03224 
03225 
03226     <span class="comment">/*</span>
03227 <span class="comment">     * FIX  Why not put this check *first?*</span>
03228 <span class="comment">     */</span>
03229     <span class="keywordflow">if</span> (user-&gt;prev != NULL) {   <span class=
"comment">/* ack, this shouldn't happen */</span>
03230         user-&gt;prev-&gt;next = user-&gt;next;
03231     }
03232     <span class="keywordflow">if</span> (user-&gt;next != NULL) {
03233         user-&gt;next-&gt;prev = user-&gt;prev;
03234         <span class="keywordflow">if</span> (user-&gt;prev != NULL) <span class=
"comment">/* ack this is really bad, because it means</span>
03235 <span class="comment">                                 * * we'll loose the head of some structure tree */</span>
03236             DEBUGMSGTL((<span class="stringliteral">"usm"</span>,
03237                         <span class="stringliteral">"Severe: Asked to free the head of a usmUser tree somewhere."</span>));
03238     }
03239 
03240 
03241     <a class="code" href="group__util.html#ga40">SNMP_ZERO</a>(user, <span class="keyword">sizeof</span>(*user));
03242     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user);
03243 
03244     <span class="keywordflow">return</span> NULL;                <span class=
"comment">/* for convenience to returns from calling functions */</span>
03245 
03246 }                               <span class="comment">/* end usm_free_user() */</span>
03247 
03248 
03249 
03250 
03251 <span class="comment">/*</span>
03252 <span class="comment"> * take a given user and clone the security info into another </span>
03253 <span class="comment"> */</span>
03254 <span class="keyword">struct </span>usmUser *
03255 usm_cloneFrom_user(<span class="keyword">struct</span> usmUser *from, <span class="keyword">struct</span> usmUser *to)
03256 {
03257     <span class="comment">/*</span>
03258 <span class="comment">     * copy the authProtocol oid row pointer </span>
03259 <span class="comment">     */</span>
03260     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(to-&gt;authProtocol);
03261 
03262     <span class="keywordflow">if</span> ((to-&gt;authProtocol =
03263          snmp_duplicate_objid(from-&gt;authProtocol,
03264                               from-&gt;authProtocolLen)) != NULL)
03265         to-&gt;authProtocolLen = from-&gt;authProtocolLen;
03266     <span class="keywordflow">else</span>
03267         to-&gt;authProtocolLen = 0;
03268 
03269 
03270     <span class="comment">/*</span>
03271 <span class="comment">     * copy the authKey </span>
03272 <span class="comment">     */</span>
03273     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(to-&gt;authKey);
03274 
03275     <span class="keywordflow">if</span> (from-&gt;authKeyLen &gt; 0 &amp;&amp;
03276         (to-&gt;authKey = (u_char *) malloc(from-&gt;authKeyLen))
03277         != NULL) {
03278         to-&gt;authKeyLen = from-&gt;authKeyLen;
03279         memcpy(to-&gt;authKey, from-&gt;authKey, to-&gt;authKeyLen);
03280     } <span class="keywordflow">else</span> {
03281         to-&gt;authKey = NULL;
03282         to-&gt;authKeyLen = 0;
03283     }
03284 
03285 
03286     <span class="comment">/*</span>
03287 <span class="comment">     * copy the privProtocol oid row pointer </span>
03288 <span class="comment">     */</span>
03289     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(to-&gt;privProtocol);
03290 
03291     <span class="keywordflow">if</span> ((to-&gt;privProtocol =
03292          snmp_duplicate_objid(from-&gt;privProtocol,
03293                               from-&gt;privProtocolLen)) != NULL)
03294         to-&gt;privProtocolLen = from-&gt;privProtocolLen;
03295     <span class="keywordflow">else</span>
03296         to-&gt;privProtocolLen = 0;
03297 
03298     <span class="comment">/*</span>
03299 <span class="comment">     * copy the privKey </span>
03300 <span class="comment">     */</span>
03301     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(to-&gt;privKey);
03302 
03303     <span class="keywordflow">if</span> (from-&gt;privKeyLen &gt; 0 &amp;&amp;
03304         (to-&gt;privKey = (u_char *) malloc(from-&gt;privKeyLen))
03305         != NULL) {
03306         to-&gt;privKeyLen = from-&gt;privKeyLen;
03307         memcpy(to-&gt;privKey, from-&gt;privKey, to-&gt;privKeyLen);
03308     } <span class="keywordflow">else</span> {
03309         to-&gt;privKey = NULL;
03310         to-&gt;privKeyLen = 0;
03311     }
03312     <span class="keywordflow">return</span> to;
03313 }
03314 
03315 <span class="comment">/*</span>
03316 <span class="comment"> * usm_create_user(void):</span>
03317 <span class="comment"> * create a default empty user, instantiating only the auth/priv</span>
03318 <span class="comment"> * protocols to noAuth and noPriv OID pointers</span>
03319 <span class="comment"> */</span>
03320 <span class="keyword">struct </span>usmUser *
03321 usm_create_user(<span class="keywordtype">void</span>)
03322 {
03323     <span class="keyword">struct </span>usmUser *newUser;
03324 
03325     <span class="comment">/*</span>
03326 <span class="comment">     * create the new user </span>
03327 <span class="comment">     */</span>
03328     newUser = (<span class="keyword">struct </span>usmUser *) calloc(1, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> usmUser));
03329     <span class="keywordflow">if</span> (newUser == NULL)
03330         <span class="keywordflow">return</span> NULL;
03331 
03332     <span class="comment">/*</span>
03333 <span class="comment">     * fill the auth/priv protocols </span>
03334 <span class="comment">     */</span>
03335     <span class="keywordflow">if</span> ((newUser-&gt;authProtocol =
03336          snmp_duplicate_objid(usmNoAuthProtocol,
03337                               <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class=
"keyword">sizeof</span>(oid))) ==
03338         NULL)
03339         <span class="keywordflow">return</span> usm_free_user(newUser);
03340     newUser-&gt;authProtocolLen = <span class="keyword">sizeof</span>(usmNoAuthProtocol) / <span class=
"keyword">sizeof</span>(oid);
03341 
03342     <span class="keywordflow">if</span> ((newUser-&gt;privProtocol =
03343          snmp_duplicate_objid(usmNoPrivProtocol,
03344                               <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class=
"keyword">sizeof</span>(oid))) ==
03345         NULL)
03346         <span class="keywordflow">return</span> usm_free_user(newUser);
03347     newUser-&gt;privProtocolLen = <span class="keyword">sizeof</span>(usmNoPrivProtocol) / <span class=
"keyword">sizeof</span>(oid);
03348 
03349     <span class="comment">/*</span>
03350 <span class="comment">     * set the storage type to nonvolatile, and the status to ACTIVE </span>
03351 <span class="comment">     */</span>
03352     newUser-&gt;userStorageType = ST_NONVOLATILE;
03353     newUser-&gt;userStatus = RS_ACTIVE;
03354     <span class="keywordflow">return</span> newUser;
03355 
03356 }                               <span class="comment">/* end usm_clone_user() */</span>
03357 
03358 
03359 
03360 
03361 <span class="comment">/*</span>
03362 <span class="comment"> * usm_create_initial_user(void):</span>
03363 <span class="comment"> * creates an initial user, filled with the defaults defined in the</span>
03364 <span class="comment"> * USM document.</span>
03365 <span class="comment"> */</span>
03366 <span class="keyword">struct </span>usmUser *
03367 usm_create_initial_user(<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
03368                         <span class="keyword">const</span> oid * authProtocol, size_t authProtocolLen,
03369                         <span class="keyword">const</span> oid * privProtocol, size_t privProtocolLen)
03370 {
03371     <span class="keyword">struct </span>usmUser *newUser = usm_create_user();
03372     <span class="keywordflow">if</span> (newUser == NULL)
03373         <span class="keywordflow">return</span> NULL;
03374 
03375     <span class="keywordflow">if</span> ((newUser-&gt;name = strdup(name)) == NULL)
03376         <span class="keywordflow">return</span> usm_free_user(newUser);
03377 
03378     <span class="keywordflow">if</span> ((newUser-&gt;secName = strdup(name)) == NULL)
03379         <span class="keywordflow">return</span> usm_free_user(newUser);
03380 
03381     <span class="keywordflow">if</span> ((newUser-&gt;engineID =
03382          snmpv3_generate_engineID(&amp;newUser-&gt;engineIDLen)) == NULL)
03383         <span class="keywordflow">return</span> usm_free_user(newUser);
03384 
03385     <span class="keywordflow">if</span> ((newUser-&gt;cloneFrom = (oid *) malloc(<span class=
"keyword">sizeof</span>(oid) * 2)) == NULL)
03386         <span class="keywordflow">return</span> usm_free_user(newUser);
03387     newUser-&gt;cloneFrom[0] = 0;
03388     newUser-&gt;cloneFrom[1] = 0;
03389     newUser-&gt;cloneFromLen = 2;
03390 
03391     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(newUser-&gt;privProtocol);
03392     <span class="keywordflow">if</span> ((newUser-&gt;privProtocol = snmp_duplicate_objid(privProtocol,
03393                                                       privProtocolLen)) ==
03394         NULL) {
03395         <span class="keywordflow">return</span> usm_free_user(newUser);
03396     }
03397     newUser-&gt;privProtocolLen = privProtocolLen;
03398 
03399     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(newUser-&gt;authProtocol);
03400     <span class="keywordflow">if</span> ((newUser-&gt;authProtocol = snmp_duplicate_objid(authProtocol,
03401                                                       authProtocolLen)) ==
03402         NULL) {
03403         <span class="keywordflow">return</span> usm_free_user(newUser);
03404     }
03405     newUser-&gt;authProtocolLen = authProtocolLen;
03406 
03407     newUser-&gt;userStatus = RS_ACTIVE;
03408     newUser-&gt;userStorageType = ST_READONLY;
03409 
03410     <span class="keywordflow">return</span> newUser;
03411 }
03412 
03413 <span class="comment">/*</span>
03414 <span class="comment"> * this is a callback that can store all known users based on a</span>
03415 <span class="comment"> * previously registered application ID </span>
03416 <span class="comment"> */</span>
03417 <span class="keywordtype">int</span>
03418 usm_store_users(<span class="keywordtype">int</span> majorID, <span class="keywordtype">int</span> minorID, <span class=
"keywordtype">void</span> *serverarg, <span class="keywordtype">void</span> *clientarg)
03419 {
03420     <span class="comment">/*</span>
03421 <span class="comment">     * figure out our application name </span>
03422 <span class="comment">     */</span>
03423     <span class="keywordtype">char</span>           *appname = (<span class="keywordtype">char</span> *) clientarg;
03424     <span class="keywordflow">if</span> (appname == NULL) {
03425         appname = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
03426                                         NETSNMP_DS_LIB_APPTYPE);
03427     }
03428 
03429     <span class="comment">/*</span>
03430 <span class="comment">     * save the user base </span>
03431 <span class="comment">     */</span>
03432     usm_save_users(<span class="stringliteral">"usmUser"</span>, appname);
03433 
03434     <span class="comment">/*</span>
03435 <span class="comment">     * never fails </span>
03436 <span class="comment">     */</span>
03437     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
03438 }
03439 
03440 
03441 <span class="comment">/*</span>
03442 <span class="comment"> * usm_save_users(): saves a list of users to the persistent cache </span>
03443 <span class="comment"> */</span>
03444 <span class="keywordtype">void</span>
03445 usm_save_users(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *type)
03446 {
03447     usm_save_users_from_list(userList, token, type);
03448 }
03449 
03450 <span class="keywordtype">void</span>
03451 usm_save_users_from_list(<span class="keyword">struct</span> usmUser *puserList, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *token,
03452                          <span class="keyword">const</span> <span class="keywordtype">char</span> *type)
03453 {
03454     <span class="keyword">struct </span>usmUser *uptr;
03455     <span class="keywordflow">for</span> (uptr = puserList; uptr != NULL; uptr = uptr-&gt;next) {
03456         <span class="keywordflow">if</span> (uptr-&gt;userStorageType == ST_NONVOLATILE)
03457             usm_save_user(uptr, token, type);
03458     }
03459 }
03460 
03461 <span class="comment">/*</span>
03462 <span class="comment"> * usm_save_user(): saves a user to the persistent cache </span>
03463 <span class="comment"> */</span>
03464 <span class="keywordtype">void</span>
03465 usm_save_user(<span class="keyword">struct</span> usmUser *user, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *token, <span class="keyword">const</span> <span class="keywordtype">char</span> *type)
03466 {
03467     <span class="keywordtype">char</span>            line[4096];
03468     <span class="keywordtype">char</span>           *cptr;
03469 
03470     memset(line, 0, <span class="keyword">sizeof</span>(line));
03471 
03472     sprintf(line, <span class="stringliteral">"%s %d %d "</span>, token, user-&gt;userStatus,
03473             user-&gt;userStorageType);
03474     cptr = &amp;line[strlen(line)]; <span class="comment">/* the NULL */</span>
03475     cptr =
03476         read_config_save_octet_string(cptr, user-&gt;engineID,
03477                                       user-&gt;engineIDLen);
03478     *cptr++ = <span class="charliteral">' '</span>;
03479     cptr = read_config_save_octet_string(cptr, (u_char *) user-&gt;name,
03480                                          (user-&gt;name == NULL) ? 0 :
03481                                          strlen(user-&gt;name) + 1);
03482     *cptr++ = <span class="charliteral">' '</span>;
03483     cptr = read_config_save_octet_string(cptr, (u_char *) user-&gt;secName,
03484                                          (user-&gt;secName == NULL) ? 0 :
03485                                          strlen(user-&gt;secName) + 1);
03486     *cptr++ = <span class="charliteral">' '</span>;
03487     cptr =
03488         read_config_save_objid(cptr, user-&gt;cloneFrom, user-&gt;cloneFromLen);
03489     *cptr++ = <span class="charliteral">' '</span>;
03490     cptr = read_config_save_objid(cptr, user-&gt;authProtocol,
03491                                   user-&gt;authProtocolLen);
03492     *cptr++ = <span class="charliteral">' '</span>;
03493     cptr =
03494         read_config_save_octet_string(cptr, user-&gt;authKey,
03495                                       user-&gt;authKeyLen);
03496     *cptr++ = <span class="charliteral">' '</span>;
03497     cptr = read_config_save_objid(cptr, user-&gt;privProtocol,
03498                                   user-&gt;privProtocolLen);
03499     *cptr++ = <span class="charliteral">' '</span>;
03500     cptr =
03501         read_config_save_octet_string(cptr, user-&gt;privKey,
03502                                       user-&gt;privKeyLen);
03503     *cptr++ = <span class="charliteral">' '</span>;
03504     cptr = read_config_save_octet_string(cptr, user-&gt;userPublicString,
03505                                          (user-&gt;userPublicString ==
03506                                           NULL) ? 0 : strlen((<span class="keywordtype">char</span> *)
03507                                                              user-&gt;
03508                                                              userPublicString)
03509                                          + 1);
03510     <a class="code" href="group__read__config.html#ga37">read_config_store</a>(type, line);
03511 }
03512 
03513 <span class="comment">/*</span>
03514 <span class="comment"> * usm_parse_user(): reads in a line containing a saved user profile</span>
03515 <span class="comment"> * and returns a pointer to a newly created struct usmUser. </span>
03516 <span class="comment"> */</span>
03517 <span class="keyword">struct </span>usmUser *
03518 usm_read_user(<span class="keywordtype">char</span> *line)
03519 {
03520     <span class="keyword">struct </span>usmUser *user;
03521     size_t          len;
03522     size_t expected_privKeyLen = 0;
03523 
03524     user = usm_create_user();
03525     <span class="keywordflow">if</span> (user == NULL)
03526         <span class="keywordflow">return</span> NULL;
03527 
03528     user-&gt;userStatus = atoi(line);
03529     line = skip_token(line);
03530     user-&gt;userStorageType = atoi(line);
03531     line = skip_token(line);
03532     line = read_config_read_octet_string(line, &amp;user-&gt;engineID,
03533                                          &amp;user-&gt;engineIDLen);
03534 
03535     <span class="comment">/*</span>
03536 <span class="comment">     * set the lcd entry for this engineID to the minimum boots/time</span>
03537 <span class="comment">     * values so that its a known engineid and won't return a report pdu.</span>
03538 <span class="comment">     * This is mostly important when receiving v3 traps so that the usm</span>
03539 <span class="comment">     * will at least continue processing them. </span>
03540 <span class="comment">     */</span>
03541     set_enginetime(user-&gt;engineID, user-&gt;engineIDLen, 1, 0, 0);
03542 
03543     line = read_config_read_octet_string(line, (u_char **) &amp; user-&gt;name,
03544                                          &amp;len);
03545     line = read_config_read_octet_string(line, (u_char **) &amp; user-&gt;secName,
03546                                          &amp;len);
03547     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;cloneFrom);
03548     user-&gt;cloneFromLen = 0;
03549 
03550     line =
03551         read_config_read_objid(line, &amp;user-&gt;cloneFrom,
03552                                &amp;user-&gt;cloneFromLen);
03553 
03554     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;authProtocol);
03555     user-&gt;authProtocolLen = 0;
03556 
03557     line = read_config_read_objid(line, &amp;user-&gt;authProtocol,
03558                                   &amp;user-&gt;authProtocolLen);
03559     line = read_config_read_octet_string(line, &amp;user-&gt;authKey,
03560                                          &amp;user-&gt;authKeyLen);
03561     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(user-&gt;privProtocol);
03562     user-&gt;privProtocolLen = 0;
03563 
03564     line = read_config_read_objid(line, &amp;user-&gt;privProtocol,
03565                                   &amp;user-&gt;privProtocolLen);
03566     line = read_config_read_octet_string(line, &amp;user-&gt;privKey,
03567                                          &amp;user-&gt;privKeyLen);
03568 <span class="preprocessor">#ifndef DISABLE_DES</span>
03569     <span class="keywordflow">if</span> (ISTRANSFORM(user-&gt;privProtocol, DESPriv)) {
03570         <span class="comment">/* DES uses a 128 bit key, 64 bits of which is a salt */</span>
03571         expected_privKeyLen = 16;
03572     }
03573 <span class="preprocessor">#endif</span>
03574 <span class="preprocessor">#ifdef HAVE_AES</span>
03575     <span class="keywordflow">if</span> (ISTRANSFORM(user-&gt;privProtocol, AESPriv)) {
03576         expected_privKeyLen = 16;
03577     }
03578 <span class="preprocessor">#endif</span>
03579     <span class="comment">/* For backwards compatibility */</span>
03580     <span class="keywordflow">if</span> (user-&gt;privKeyLen &gt; expected_privKeyLen) {
03581           user-&gt;privKeyLen = expected_privKeyLen;
03582     }
03583 
03584     line = read_config_read_octet_string(line, &amp;user-&gt;userPublicString,
03585                                          &amp;len);
03586     <span class="keywordflow">return</span> user;
03587 }
03588 
03589 <span class="comment">/*</span>
03590 <span class="comment"> * snmpd.conf parsing routines </span>
03591 <span class="comment"> */</span>
03592 <span class="keywordtype">void</span>
03593 usm_parse_config_usmUser(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
03594 {
03595     <span class="keyword">struct </span>usmUser *uptr;
03596 
03597     uptr = usm_read_user(line);
03598     usm_add_user(uptr);
03599 }
03600 
03601 
03602 
03603 
03604 <span class="comment">/*******************************************************************-o-******</span>
03605 <span class="comment"> * usm_set_password</span>
03606 <span class="comment"> *</span>
03607 <span class="comment"> * Parameters:</span>
03608 <span class="comment"> *      *token</span>
03609 <span class="comment"> *      *line</span>
03610 <span class="comment"> *      </span>
03611 <span class="comment"> *</span>
03612 <span class="comment"> * format: userSetAuthPass     secname engineIDLen engineID pass</span>
03613 <span class="comment"> *     or: userSetPrivPass     secname engineIDLen engineID pass </span>
03614 <span class="comment"> *     or: userSetAuthKey      secname engineIDLen engineID KuLen Ku</span>
03615 <span class="comment"> *     or: userSetPrivKey      secname engineIDLen engineID KuLen Ku </span>
03616 <span class="comment"> *     or: userSetAuthLocalKey secname engineIDLen engineID KulLen Kul</span>
03617 <span class="comment"> *     or: userSetPrivLocalKey secname engineIDLen engineID KulLen Kul </span>
03618 <span class="comment"> *</span>
03619 <span class="comment"> * type is:     1=passphrase; 2=Ku; 3=Kul.</span>
03620 <span class="comment"> *</span>
03621 <span class="comment"> *</span>
03622 <span class="comment"> * ASSUMES  Passwords are null-terminated printable strings.</span>
03623 <span class="comment"> */</span>
03624 <span class="keywordtype">void</span>
03625 usm_set_password(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *line)
03626 {
03627     <span class="keywordtype">char</span>           *cp;
03628     <span class="keywordtype">char</span>            nameBuf[SNMP_MAXBUF];
03629     u_char         *engineID;
03630     size_t          engineIDLen;
03631     <span class="keyword">struct </span>usmUser *user;
03632 
03633     cp = copy_nword(line, nameBuf, <span class="keyword">sizeof</span>(nameBuf));
03634     <span class="keywordflow">if</span> (cp == NULL) {
03635         config_perror(<span class="stringliteral">"invalid name specifier"</span>);
03636         <span class="keywordflow">return</span>;
03637     }
03638 
03639     DEBUGMSGTL((<span class="stringliteral">"usm"</span>, <span class=
"stringliteral">"comparing: %s and %s\n"</span>, cp, WILDCARDSTRING));
03640     <span class="keywordflow">if</span> (strncmp(cp, WILDCARDSTRING, strlen(WILDCARDSTRING)) == 0) {
03641         <span class="comment">/*</span>
03642 <span class="comment">         * match against all engineIDs we know about </span>
03643 <span class="comment">         */</span>
03644         cp = skip_token(cp);
03645         <span class="keywordflow">for</span> (user = userList; user != NULL; user = user-&gt;next) {
03646             <span class="keywordflow">if</span> (user-&gt;secName &amp;&amp; strcmp(user-&gt;secName, nameBuf) == 0) {
03647                 usm_set_user_password(user, token, cp);
03648             }
03649         }
03650     } <span class="keywordflow">else</span> {
03651         cp = read_config_read_octet_string(cp, &amp;engineID, &amp;engineIDLen);
03652         <span class="keywordflow">if</span> (cp == NULL) {
03653             config_perror(<span class="stringliteral">"invalid engineID specifier"</span>);
03654             <span class="keywordflow">return</span>;
03655         }
03656 
03657         user = usm_get_user(engineID, engineIDLen, nameBuf);
03658         <span class="keywordflow">if</span> (user == NULL) {
03659             config_perror(<span class="stringliteral">"not a valid user/engineID pair"</span>);
03660             <span class="keywordflow">return</span>;
03661         }
03662         usm_set_user_password(user, token, cp);
03663     }
03664 }
03665 
03666 <span class="comment">/*</span>
03667 <span class="comment"> * uses the rest of LINE to configure USER's password of type TOKEN </span>
03668 <span class="comment"> */</span>
03669 <span class="keywordtype">void</span>
03670 usm_set_user_password(<span class="keyword">struct</span> usmUser *user, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *token, <span class="keywordtype">char</span> *line)
03671 {
03672     <span class="keywordtype">char</span>           *cp = line;
03673     u_char         *engineID = user-&gt;engineID;
03674     size_t          engineIDLen = user-&gt;engineIDLen;
03675 
03676     u_char        **key;
03677     size_t         *keyLen;
03678     u_char          userKey[SNMP_MAXBUF_SMALL];
03679     size_t          userKeyLen = SNMP_MAXBUF_SMALL;
03680     u_char         *userKeyP = userKey;
03681     <span class="keywordtype">int</span>             type, ret;
03682 
03683     <span class="comment">/*</span>
03684 <span class="comment">     * Retrieve the "old" key and set the key type.</span>
03685 <span class="comment">     */</span>
03686     <span class="keywordflow">if</span> (!token) {
03687         <span class="keywordflow">return</span>;
03688     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(token, <span class=
"stringliteral">"userSetAuthPass"</span>) == 0) {
03689         key = &amp;user-&gt;authKey;
03690         keyLen = &amp;user-&gt;authKeyLen;
03691         type = 0;
03692     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(token, <span class=
"stringliteral">"userSetPrivPass"</span>) == 0) {
03693         key = &amp;user-&gt;privKey;
03694         keyLen = &amp;user-&gt;privKeyLen;
03695         type = 0;
03696     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(token, <span class=
"stringliteral">"userSetAuthKey"</span>) == 0) {
03697         key = &amp;user-&gt;authKey;
03698         keyLen = &amp;user-&gt;authKeyLen;
03699         type = 1;
03700     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(token, <span class=
"stringliteral">"userSetPrivKey"</span>) == 0) {
03701         key = &amp;user-&gt;privKey;
03702         keyLen = &amp;user-&gt;privKeyLen;
03703         type = 1;
03704     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(token, <span class=
"stringliteral">"userSetAuthLocalKey"</span>) == 0) {
03705         key = &amp;user-&gt;authKey;
03706         keyLen = &amp;user-&gt;authKeyLen;
03707         type = 2;
03708     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(token, <span class=
"stringliteral">"userSetPrivLocalKey"</span>) == 0) {
03709         key = &amp;user-&gt;privKey;
03710         keyLen = &amp;user-&gt;privKeyLen;
03711         type = 2;
03712     } <span class="keywordflow">else</span> {
03713         <span class="comment">/*</span>
03714 <span class="comment">         * no old key, or token was not recognized </span>
03715 <span class="comment">         */</span>
03716         <span class="keywordflow">return</span>;
03717     }
03718 
03719     <span class="keywordflow">if</span> (*key) {
03720         <span class="comment">/*</span>
03721 <span class="comment">         * (destroy and) free the old key </span>
03722 <span class="comment">         */</span>
03723         memset(*key, 0, *keyLen);
03724         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(*key);
03725     }
03726 
03727     <span class="keywordflow">if</span> (type == 0) {
03728         <span class="comment">/*</span>
03729 <span class="comment">         * convert the password into a key </span>
03730 <span class="comment">         */</span>
03731         <span class="keywordflow">if</span> (cp == NULL) {
03732             config_perror(<span class="stringliteral">"missing user password"</span>);
03733             <span class="keywordflow">return</span>;
03734         }
03735         ret = generate_Ku(user-&gt;authProtocol, user-&gt;authProtocolLen,
03736                           (u_char *) cp, strlen(cp), userKey, &amp;userKeyLen);
03737 
03738         <span class="keywordflow">if</span> (ret != SNMPERR_SUCCESS) {
03739             config_perror(<span class="stringliteral">"setting key failed (in sc_genKu())"</span>);
03740             <span class="keywordflow">return</span>;
03741         }
03742     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (type == 1) {
03743         cp = read_config_read_octet_string(cp, &amp;userKeyP, &amp;userKeyLen);
03744 
03745         <span class="keywordflow">if</span> (cp == NULL) {
03746             config_perror(<span class="stringliteral">"invalid user key"</span>);
03747             <span class="keywordflow">return</span>;
03748         }
03749     }
03750 
03751     <span class="keywordflow">if</span> (type &lt; 2) {
03752         *key = (u_char *) malloc(SNMP_MAXBUF_SMALL);
03753         *keyLen = SNMP_MAXBUF_SMALL;
03754         ret = generate_kul(user-&gt;authProtocol, user-&gt;authProtocolLen,
03755                            engineID, engineIDLen,
03756                            userKey, userKeyLen, *key, keyLen);
03757         <span class="keywordflow">if</span> (ret != SNMPERR_SUCCESS) {
03758             config_perror(<span class="stringliteral">"setting key failed (in generate_kul())"</span>);
03759             <span class="keywordflow">return</span>;
03760         }
03761 
03762         <span class="comment">/*</span>
03763 <span class="comment">         * (destroy and) free the old key </span>
03764 <span class="comment">         */</span>
03765         memset(userKey, 0, <span class="keyword">sizeof</span>(userKey));
03766 
03767     } <span class="keywordflow">else</span> {
03768         <span class="comment">/*</span>
03769 <span class="comment">         * the key is given, copy it in </span>
03770 <span class="comment">         */</span>
03771         cp = read_config_read_octet_string(cp, key, keyLen);
03772 
03773         <span class="keywordflow">if</span> (cp == NULL) {
03774             config_perror(<span class="stringliteral">"invalid localized user key"</span>);
03775             <span class="keywordflow">return</span>;
03776         }
03777     }
03778 }                               <span class="comment">/* end usm_set_password() */</span>
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small><!--#include virtual="/sfbutton.html" --><br />
    Generated on Thu Oct 28 21:47:02 2004 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

