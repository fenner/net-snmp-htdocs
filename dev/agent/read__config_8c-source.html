<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>read_config.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="comment">/*</span>
00002 <span class="comment"> * read_config.c</span>
00003 <span class="comment"> */</span>
00004 <span class="comment">/* Portions of this file are subject to the following copyright(s).  See</span>
00005 <span class="comment"> * the Net-SNMP's COPYING file for more details and other copyrights</span>
00006 <span class="comment"> * that may apply:</span>
00007 <span class="comment"> */</span>
00008 <span class="comment">/*</span>
00009 <span class="comment"> * Portions of this file are copyrighted by:</span>
00010 <span class="comment"> * Copyright &copy; 2003 Sun Microsystems, Inc. All rights reserved.</span>
00011 <span class="comment"> * Use is subject to license terms specified in the COPYING file</span>
00012 <span class="comment"> * distributed with the Net-SNMP package.</span>
00013 <span class="comment"> */</span>
00014 
00067 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00068 
00069 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00070 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00071 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00072 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00073 <span class="preprocessor">#endif</span>
00074 <span class="preprocessor">#if HAVE_STRING_H</span>
00075 <span class="preprocessor">#include &lt;string.h&gt;</span>
00076 <span class="preprocessor">#else</span>
00077 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00078 <span class="preprocessor">#endif</span>
00079 <span class="preprocessor">#if HAVE_UNISTD_H</span>
00080 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00081 <span class="preprocessor">#endif</span>
00082 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00083 <span class="preprocessor">#if HAVE_SYS_PARAM_H</span>
00084 <span class="preprocessor">#include &lt;sys/param.h&gt;</span>
00085 <span class="preprocessor">#endif</span>
00086 <span class="preprocessor">#if TIME_WITH_SYS_TIME</span>
00087 <span class="preprocessor"># ifdef WIN32</span>
00088 <span class="preprocessor">#  include &lt;sys/timeb.h&gt;</span>
00089 <span class="preprocessor"># else</span>
00090 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00091 <span class="preprocessor"># endif</span>
00092 <span class="preprocessor"># include &lt;time.h&gt;</span>
00093 <span class="preprocessor">#else</span>
00094 <span class="preprocessor"># if HAVE_SYS_TIME_H</span>
00095 <span class="preprocessor">#  include &lt;sys/time.h&gt;</span>
00096 <span class="preprocessor"># else</span>
00097 <span class="preprocessor">#  include &lt;time.h&gt;</span>
00098 <span class="preprocessor"># endif</span>
00099 <span class="preprocessor">#endif</span>
00100 <span class="preprocessor">#ifdef HAVE_SYS_STAT_H</span>
00101 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00102 <span class="preprocessor">#endif</span>
00103 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00104 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00105 <span class="preprocessor">#endif</span>
00106 <span class="preprocessor">#if HAVE_ARPA_INET_H</span>
00107 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
00108 <span class="preprocessor">#endif</span>
00109 <span class="preprocessor">#if HAVE_SYS_SELECT_H</span>
00110 <span class="preprocessor">#include &lt;sys/select.h&gt;</span>
00111 <span class="preprocessor">#endif</span>
00112 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
00113 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
00114 <span class="preprocessor">#endif</span>
00115 <span class="preprocessor">#if HAVE_SYS_SOCKET_H</span>
00116 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00117 <span class="preprocessor">#endif</span>
00118 <span class="preprocessor">#if HAVE_NETDB_H</span>
00119 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00120 <span class="preprocessor">#endif</span>
00121 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00122 
00123 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00124 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00125 <span class="preprocessor">#endif</span>
00126 
00127 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00128 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00129 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00130 <span class="preprocessor">#include &lt;net-snmp/library/read_config.h&gt;</span>       <span class=
"comment">/* for "internal" definitions */</span>
00131 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
00132 
00133 <span class="preprocessor">#include &lt;net-snmp/library/mib.h&gt;</span>
00134 <span class="preprocessor">#include &lt;net-snmp/library/parse.h&gt;</span>
00135 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
00136 <span class="preprocessor">#include &lt;net-snmp/library/callback.h&gt;</span>
00137 
00138 <span class="keyword">static</span> <span class="keywordtype">int</span>      config_errors;
00139 
00140 <span class="keyword">struct </span>config_files *config_files = NULL;
00141 
00142 <span class="keyword">struct </span>config_line *
00143 register_prenetsnmp_mib_handler(<span class="keyword">const</span> <span class="keywordtype">char</span> *type,
00144                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *token,
00145                                 <span class="keywordtype">void</span> (*parser) (<span class=
"keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *),
00146                                 <span class="keywordtype">void</span> (*releaser) (<span class=
"keywordtype">void</span>), <span class="keyword">const</span> <span class="keywordtype">char</span> *help)
00147 {
00148     <span class="keyword">struct </span>config_line *ltmp;
00149     ltmp = <a class="code" href=
"group__read__config.html#ga8">register_config_handler</a>(type, token, parser, releaser, help);
00150     <span class="keywordflow">if</span> (ltmp != NULL)
00151         ltmp-&gt;config_time = PREMIB_CONFIG;
00152     <span class="keywordflow">return</span> (ltmp);
00153 }
00154 
00155 <span class="keyword">struct </span>config_line *
00156 register_app_prenetsnmp_mib_handler(<span class="keyword">const</span> <span class="keywordtype">char</span> *token,
00157                                     <span class="keywordtype">void</span> (*parser) (<span class=
"keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *),
00158                                     <span class="keywordtype">void</span> (*releaser) (<span class=
"keywordtype">void</span>),
00159                                     <span class="keyword">const</span> <span class="keywordtype">char</span> *help)
00160 {
00161     <span class="keywordflow">return</span> (register_prenetsnmp_mib_handler
00162             (NULL, token, parser, releaser, help));
00163 }
00164 
00195 <span class="keyword">struct </span>config_line *
<a name="l00196" id="l00196"></a><a class="code" href="group__read__config.html#ga8">00196</a> <a class="code" href=
"group__read__config.html#ga8">register_config_handler</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *type_param,
00197                         <span class="keyword">const</span> <span class="keywordtype">char</span> *token,
00198                         <span class="keywordtype">void</span> (*parser) (<span class="keyword">const</span> <span class=
"keywordtype">char</span> *, <span class="keywordtype">char</span> *),
00199                         <span class="keywordtype">void</span> (*releaser) (<span class=
"keywordtype">void</span>), <span class="keyword">const</span> <span class="keywordtype">char</span> *help)
00200 {
00201     <span class="keyword">struct </span>config_files **ctmp = &amp;config_files;
00202     <span class="keyword">struct </span>config_line **ltmp, *ltmp2;
00203     <span class="keyword">const</span> <span class="keywordtype">char</span>     *type = type_param;
00204     <span class="keywordtype">char</span>           *cptr, buf[STRINGMAX];
00205     <span class="keywordtype">char</span>           *st;
00206 
00207     <span class="keywordflow">if</span> (type == NULL) {
00208         type = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
00209                                      NETSNMP_DS_LIB_APPTYPE);
00210     }
00211 
00212     <span class="comment">/*</span>
00213 <span class="comment">     * Handle multiple types (recursively)</span>
00214 <span class="comment">     */</span>
00215     cptr = strchr( type, <span class="charliteral">':'</span> );
00216     <span class="keywordflow">if</span> (cptr) {
00217         strncpy(buf, type, STRINGMAX);
00218         buf[STRINGMAX - 1] = <span class="charliteral">'\0'</span>;
00219         ltmp2 = NULL;
00220         cptr = strtok_r(buf, <span class="stringliteral">":"</span>, &amp;st);
00221         <span class="keywordflow">while</span> (cptr) {
00222             ltmp2 = <a class="code" href=
"group__read__config.html#ga8">register_config_handler</a>(cptr, token, parser, releaser, help);
00223             cptr  = strtok_r(NULL, <span class="stringliteral">":"</span>, &amp;st);
00224         }
00225         <span class="keywordflow">return</span> ltmp2;
00226     }
00227     
00228     <span class="comment">/*</span>
00229 <span class="comment">     * Find type in current list  -OR-  create a new file type.</span>
00230 <span class="comment">     */</span>
00231     <span class="keywordflow">while</span> (*ctmp != NULL &amp;&amp; strcmp((*ctmp)-&gt;fileHeader, type)) {
00232         ctmp = &amp;((*ctmp)-&gt;next);
00233     }
00234 
00235     <span class="keywordflow">if</span> (*ctmp == NULL) {
00236         *ctmp = (<span class="keyword">struct </span>config_files *)
00237             calloc(1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> config_files));
00238         <span class="keywordflow">if</span> (!*ctmp) {
00239             <span class="keywordflow">return</span> NULL;
00240         }
00241 
00242         (*ctmp)-&gt;fileHeader = strdup(type);
00243     }
00244 
00245     <span class="comment">/*</span>
00246 <span class="comment">     * Find parser type in current list  -OR-  create a new</span>
00247 <span class="comment">     * line parser entry.</span>
00248 <span class="comment">     */</span>
00249     ltmp = &amp;((*ctmp)-&gt;start);
00250 
00251     <span class="keywordflow">while</span> (*ltmp != NULL &amp;&amp; strcmp((*ltmp)-&gt;config_token, token)) {
00252         ltmp = &amp;((*ltmp)-&gt;next);
00253     }
00254 
00255     <span class="keywordflow">if</span> (*ltmp == NULL) {
00256         *ltmp = (<span class="keyword">struct </span>config_line *)
00257             calloc(1, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> config_line));
00258         <span class="keywordflow">if</span> (!*ltmp) {
00259             <span class="keywordflow">return</span> NULL;
00260         }
00261 
00262         (*ltmp)-&gt;config_time = NORMAL_CONFIG;
00263         (*ltmp)-&gt;config_token = strdup(token);
00264         <span class="keywordflow">if</span> (help != NULL)
00265             (*ltmp)-&gt;help = strdup(help);
00266     }
00267 
00268     <span class="comment">/*</span>
00269 <span class="comment">     * Add/Replace the parse/free functions for the given line type</span>
00270 <span class="comment">     * in the given file type.</span>
00271 <span class="comment">     */</span>
00272     (*ltmp)-&gt;parse_line = parser;
00273     (*ltmp)-&gt;free_func = releaser;
00274 
00275     <span class="keywordflow">return</span> (*ltmp);
00276 
00277 }                               <span class="comment">/* end register_config_handler() */</span>
00278 
00279 <span class="keyword">struct </span>config_line *
00280 register_app_config_handler(<span class="keyword">const</span> <span class="keywordtype">char</span> *token,
00281                             <span class="keywordtype">void</span> (*parser) (<span class=
"keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *),
00282                             <span class="keywordtype">void</span> (*releaser) (<span class=
"keywordtype">void</span>), <span class="keyword">const</span> <span class="keywordtype">char</span> *help)
00283 {
00284     <span class="keywordflow">return</span> (<a class="code" href=
"group__read__config.html#ga8">register_config_handler</a>(NULL, token, parser, releaser, help));
00285 }
00286 
00287 
00288 
00300 <span class="keywordtype">void</span>
<a name="l00301" id="l00301"></a><a class="code" href="group__read__config.html#ga10">00301</a> <a class="code" href=
"group__read__config.html#ga10">unregister_config_handler</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *type_param, <span class="keyword">const</span> <span class="keywordtype">char</span> *token)
00302 {
00303     <span class="keyword">struct </span>config_files **ctmp = &amp;config_files;
00304     <span class="keyword">struct </span>config_line **ltmp, *ltmp2;
00305     <span class="keyword">const</span> <span class="keywordtype">char</span>     *type = type_param;
00306     <span class="keywordtype">char</span>           *cptr, buf[STRINGMAX];
00307     <span class="keywordtype">char</span>           *st;
00308 
00309     <span class="keywordflow">if</span> (type == NULL) {
00310         type = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
00311                                      NETSNMP_DS_LIB_APPTYPE);
00312     }
00313 
00314     <span class="comment">/*</span>
00315 <span class="comment">     * Handle multiple types (recursively)</span>
00316 <span class="comment">     */</span>
00317     cptr = strchr( type, <span class="charliteral">':'</span> );
00318     <span class="keywordflow">if</span> (cptr) {
00319         strncpy(buf, type, STRINGMAX);
00320         buf[STRINGMAX - 1] = <span class="charliteral">'\0'</span>;
00321         cptr = strtok_r(buf, <span class="stringliteral">":"</span>, &amp;st);
00322         <span class="keywordflow">while</span> (cptr) {
00323             <a class="code" href="group__read__config.html#ga10">unregister_config_handler</a>(cptr, token);
00324             cptr  = strtok_r(NULL, <span class="stringliteral">":"</span>, &amp;st);
00325         }
00326         <span class="keywordflow">return</span>;
00327     }
00328     
00329     <span class="comment">/*</span>
00330 <span class="comment">     * find type in current list </span>
00331 <span class="comment">     */</span>
00332     <span class="keywordflow">while</span> (*ctmp != NULL &amp;&amp; strcmp((*ctmp)-&gt;fileHeader, type)) {
00333         ctmp = &amp;((*ctmp)-&gt;next);
00334     }
00335 
00336     <span class="keywordflow">if</span> (*ctmp == NULL) {
00337         <span class="comment">/*</span>
00338 <span class="comment">         * Not found, return. </span>
00339 <span class="comment">         */</span>
00340         <span class="keywordflow">return</span>;
00341     }
00342 
00343     ltmp = &amp;((*ctmp)-&gt;start);
00344     <span class="keywordflow">if</span> (*ltmp == NULL) {
00345         <span class="comment">/*</span>
00346 <span class="comment">         * Not found, return. </span>
00347 <span class="comment">         */</span>
00348         <span class="keywordflow">return</span>;
00349     }
00350     <span class="keywordflow">if</span> (strcmp((*ltmp)-&gt;config_token, token) == 0) {
00351         <span class="comment">/*</span>
00352 <span class="comment">         * found it at the top of the list </span>
00353 <span class="comment">         */</span>
00354         ltmp2 = (*ltmp)-&gt;next;
00355         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>((*ltmp)-&gt;config_token);
00356         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>((*ltmp)-&gt;help);
00357         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(*ltmp);
00358         (*ctmp)-&gt;start = ltmp2;
00359         <span class="keywordflow">return</span>;
00360     }
00361     <span class="keywordflow">while</span> ((*ltmp)-&gt;next != NULL
00362            &amp;&amp; strcmp((*ltmp)-&gt;next-&gt;config_token, token)) {
00363         ltmp = &amp;((*ltmp)-&gt;next);
00364     }
00365     <span class="keywordflow">if</span> ((*ltmp)-&gt;next != NULL) {
00366         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>((*ltmp)-&gt;next-&gt;config_token);
00367         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>((*ltmp)-&gt;next-&gt;help);
00368         ltmp2 = (*ltmp)-&gt;next-&gt;next;
00369         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>((*ltmp)-&gt;next);
00370         (*ltmp)-&gt;next = ltmp2;
00371     }
00372 }
00373 
00374 <span class="keywordtype">void</span>
00375 unregister_app_config_handler(<span class="keyword">const</span> <span class="keywordtype">char</span> *token)
00376 {
00377     <a class="code" href="group__read__config.html#ga10">unregister_config_handler</a>(NULL, token);
00378 }
00379 
00380 <span class="keywordtype">void</span>
00381 unregister_all_config_handlers()
00382 {
00383     <span class="keyword">struct </span>config_files *ctmp, *save;
00384     <span class="keyword">struct </span>config_line *ltmp;
00385 
00386     free_config();
00387 
00388     <span class="comment">/*</span>
00389 <span class="comment">     * Keep using config_files until there are no more! </span>
00390 <span class="comment">     */</span>
00391     <span class="keywordflow">for</span> (ctmp = config_files; ctmp;) {
00392         <span class="keywordflow">for</span> (ltmp = ctmp-&gt;start; ltmp; ltmp = ctmp-&gt;start) {
00393             <a class="code" href="group__read__config.html#ga10">unregister_config_handler</a>(ctmp-&gt;fileHeader,
00394                                       ltmp-&gt;config_token);
00395         }
00396         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ctmp-&gt;fileHeader);
00397         save = ctmp-&gt;next;
00398         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(ctmp);
00399         ctmp = save;
00400         config_files = save;
00401     }
00402 }
00403 
00404 <span class="preprocessor">#ifdef TESTING</span>
00405 <span class="keywordtype">void</span>
00406 print_config_handlers(<span class="keywordtype">void</span>)
00407 {
00408     <span class="keyword">struct </span>config_files *ctmp = config_files;
00409     <span class="keyword">struct </span>config_line *ltmp;
00410 
00411     <span class="keywordflow">for</span> (; ctmp != NULL; ctmp = ctmp-&gt;next) {
00412         DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"read_conf: %s\n"</span>, ctmp-&gt;fileHeader));
00413         <span class="keywordflow">for</span> (ltmp = ctmp-&gt;start; ltmp != NULL; ltmp = ltmp-&gt;next)
00414             DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"                   %s\n"</span>,
00415                         ltmp-&gt;config_token));
00416     }
00417 }
00418 <span class="preprocessor">#endif</span>
00419 
00420 <span class="keywordtype">int</span>             linecount;
00421 <span class="keyword">const</span> <span class="keywordtype">char</span>     *curfilename;
00422 
00423 <span class="keyword">struct </span>config_line *
00424 read_config_get_handlers(<span class="keyword">const</span> <span class="keywordtype">char</span> *type)
00425 {
00426     <span class="keyword">struct </span>config_files *ctmp = config_files;
00427     <span class="keywordflow">for</span> (; ctmp != NULL &amp;&amp; strcmp(ctmp-&gt;fileHeader, type);
00428          ctmp = ctmp-&gt;next);
00429     <span class="keywordflow">if</span> (ctmp)
00430         <span class="keywordflow">return</span> ctmp-&gt;start;
00431     <span class="keywordflow">return</span> NULL;
00432 }
00433 
00434 <span class="keywordtype">void</span>
00435 read_config_with_type_when(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *type, <span class="keywordtype">int</span> when)
00436 {
00437     <span class="keyword">struct </span>config_line *ctmp = read_config_get_handlers(type);
00438     <span class="keywordflow">if</span> (ctmp)
00439         read_config(filename, ctmp, when);
00440     <span class="keywordflow">else</span>
00441         DEBUGMSGTL((<span class="stringliteral">"read_config"</span>,
00442                     <span class="stringliteral">"read_config: I have no registrations for type:%s,file:%s\n"</span>,
00443                     type, filename));
00444 }
00445 
00446 <span class="keywordtype">void</span>
00447 read_config_with_type(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class=
"keyword">const</span> <span class="keywordtype">char</span> *type)
00448 {
00449     read_config_with_type_when(filename, type, EITHER_CONFIG);
00450 }
00451 
00452 
00453 <span class="keyword">struct </span>config_line *
00454 read_config_find_handler(<span class="keyword">struct</span> config_line *line_handlers,
00455                          <span class="keyword">const</span> <span class="keywordtype">char</span> *token)
00456 {
00457     <span class="keyword">struct </span>config_line *lptr;
00458 
00459     <span class="keywordflow">for</span> (lptr = line_handlers; lptr != NULL; lptr = lptr-&gt;next) {
00460         <span class="keywordflow">if</span> (!strcasecmp(token, lptr-&gt;config_token)) {
00461             <span class="keywordflow">return</span> lptr;
00462         }
00463     }
00464     <span class="keywordflow">return</span> NULL;
00465 }
00466 
00467 
00468 <span class="comment">/*</span>
00469 <span class="comment"> * searches a config_line linked list for a match </span>
00470 <span class="comment"> */</span>
00471 <span class="keywordtype">int</span>
00472 run_config_handler(<span class="keyword">struct</span> config_line *lptr,
00473                    <span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *cptr, <span class="keywordtype">int</span> when)
00474 {
00475     <span class="keywordtype">char</span>            tmpbuf[STRINGMAX];
00476     <span class="keywordtype">char</span>           *cp;
00477     lptr = read_config_find_handler(lptr, token);
00478     <span class="keywordflow">if</span> (lptr != NULL) {
00479         <span class="keywordflow">if</span> (when == EITHER_CONFIG || lptr-&gt;config_time == when) {
00480             DEBUGMSGTL((<span class="stringliteral">"read_config"</span>,
00481                         <span class="stringliteral">"Found a parser.  Calling it: %s / %s\n"</span>, token,
00482                         cptr));
00483             <span class="comment">/*</span>
00484 <span class="comment">             * Stomp on any trailing whitespace</span>
00485 <span class="comment">             */</span>
00486             cp = &amp;(cptr[strlen(cptr)-1]);
00487             <span class="keywordflow">while</span> (isspace(*cp)) {
00488                 *(cp--) = <span class="charliteral">'\0'</span>;
00489             }
00490             (*(lptr-&gt;parse_line)) (token, cptr);
00491         }
00492     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (when != PREMIB_CONFIG &amp;&amp; 
00493                !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
00494                                        NETSNMP_DS_LIB_NO_TOKEN_WARNINGS)) {
00495         snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf), <span class=
"stringliteral">"Unknown token: %s."</span>, token);
00496         tmpbuf[ <span class="keyword">sizeof</span>(tmpbuf)-1 ] = 0;
00497         config_pwarn(tmpbuf);
00498         <span class="keywordflow">return</span> SNMPERR_GENERR;
00499     }
00500     <span class="keywordflow">return</span> SNMPERR_SUCCESS;
00501 }
00502 
00503 <span class="comment">/*</span>
00504 <span class="comment"> * takens an arbitrary string and tries to intepret it based on the</span>
00505 <span class="comment"> * known configuration handlers for all registered types.  May produce</span>
00506 <span class="comment"> * inconsistent results when multiple tokens of the same name are</span>
00507 <span class="comment"> * registered under different file types. </span>
00508 <span class="comment"> */</span>
00509 
00510 <span class="comment">/*</span>
00511 <span class="comment"> * we allow = delimeters here </span>
00512 <span class="comment"> */</span>
00513 <span class="preprocessor">#define SNMP_CONFIG_DELIMETERS " \t="</span>
00514 
00515 <span class="keywordtype">int</span>
00516 snmp_config_when(<span class="keywordtype">char</span> *line, <span class="keywordtype">int</span> when)
00517 {
00518     <span class="keywordtype">char</span>           *cptr, buf[STRINGMAX], tmpbuf[STRINGMAX];
00519     <span class="keyword">struct </span>config_line *lptr = NULL;
00520     <span class="keyword">struct </span>config_files *ctmp = config_files;
00521     <span class="keywordtype">char</span>           *st;
00522 
00523     <span class="keywordflow">if</span> (line == NULL) {
00524         config_perror(<span class="stringliteral">"snmp_config() called with a null string."</span>);
00525         <span class="keywordflow">return</span> SNMPERR_GENERR;
00526     }
00527 
00528     strncpy(buf, line, STRINGMAX);
00529     buf[STRINGMAX - 1] = <span class="charliteral">'\0'</span>;
00530     cptr = strtok_r(buf, SNMP_CONFIG_DELIMETERS, &amp;st);
00531     <span class="keywordflow">if</span> (cptr &amp;&amp; cptr[0] == <span class="charliteral">'['</span>) {
00532         <span class="keywordflow">if</span> (cptr[strlen(cptr) - 1] != <span class="charliteral">']'</span>) {
00533             snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf),
00534                     <span class="stringliteral">"no matching ']' for type %s."</span>,
00535                     cptr + 1);
00536             tmpbuf[ <span class="keyword">sizeof</span>(tmpbuf)-1 ] = 0;
00537             config_perror(tmpbuf);
00538             <span class="keywordflow">return</span> SNMPERR_GENERR;
00539         }
00540         cptr[strlen(cptr) - 1] = <span class="charliteral">'\0'</span>;
00541         lptr = read_config_get_handlers(cptr + 1);
00542         <span class="keywordflow">if</span> (lptr == NULL) {
00543             snprintf(tmpbuf,  <span class="keyword">sizeof</span>(tmpbuf),
00544                      <span class="stringliteral">"No handlers regestered for type %s."</span>,
00545                     cptr + 1);
00546             tmpbuf[ <span class="keyword">sizeof</span>(tmpbuf)-1 ] = 0;
00547             config_perror(tmpbuf);
00548             <span class="keywordflow">return</span> SNMPERR_GENERR;
00549         }
00550         cptr = strtok_r(NULL, SNMP_CONFIG_DELIMETERS, &amp;st);
00551         lptr = read_config_find_handler(lptr, cptr);
00552     } <span class="keywordflow">else</span> {
00553         <span class="comment">/*</span>
00554 <span class="comment">         * we have to find a token </span>
00555 <span class="comment">         */</span>
00556         <span class="keywordflow">for</span> (; ctmp != NULL &amp;&amp; lptr == NULL; ctmp = ctmp-&gt;next)
00557             lptr = read_config_find_handler(ctmp-&gt;start, cptr);
00558     }
00559     <span class="keywordflow">if</span> (lptr == NULL &amp;&amp; netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
00560                                           NETSNMP_DS_LIB_NO_TOKEN_WARNINGS)) {
00561         snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf), <span class=
"stringliteral">"Unknown token: %s."</span>, cptr);
00562         tmpbuf[ <span class="keyword">sizeof</span>(tmpbuf)-1 ] = 0;
00563         config_pwarn(tmpbuf);
00564         <span class="keywordflow">return</span> SNMPERR_GENERR;
00565     }
00566 
00567     <span class="comment">/*</span>
00568 <span class="comment">     * use the original string instead since strtok_r messed up the original </span>
00569 <span class="comment">     */</span>
00570     line = skip_white(line + (cptr - buf) + strlen(cptr) + 1);
00571 
00572     <span class="keywordflow">return</span> (run_config_handler(lptr, cptr, line, when));
00573 }
00574 
00575 <span class="keywordtype">int</span>
00576 netsnmp_config(<span class="keywordtype">char</span> *line)
00577 {
00578     <span class="keywordtype">int</span>             ret = SNMP_ERR_NOERROR;
00579     DEBUGMSGTL((<span class="stringliteral">"snmp_config"</span>, <span class=
"stringliteral">"remembering line \"%s\"\n"</span>, line));
00580     netsnmp_config_remember(line);      <span class="comment">/* always remember it so it's read</span>
00581 <span class="comment">                                         * processed after a free_config()</span>
00582 <span class="comment">                                         * call */</span>
00583     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, 
00584                                NETSNMP_DS_LIB_HAVE_READ_CONFIG)) {
00585         DEBUGMSGTL((<span class="stringliteral">"snmp_config"</span>, <span class=
"stringliteral">"  ... processing it now\n"</span>));
00586         ret = snmp_config_when(line, NORMAL_CONFIG);
00587     }
00588     <span class="keywordflow">return</span> ret;
00589 }
00590 
00591 <span class="keywordtype">void</span>
00592 netsnmp_config_remember_in_list(<span class="keywordtype">char</span> *line,
00593                                 <span class="keyword">struct</span> read_config_memory **mem)
00594 {
00595     <span class="keywordflow">if</span> (mem == NULL)
00596         <span class="keywordflow">return</span>;
00597 
00598     <span class="keywordflow">while</span> (*mem != NULL)
00599         mem = &amp;((*mem)-&gt;next);
00600 
00601     *mem = <a class="code" href="group__util.html#ga38">SNMP_MALLOC_STRUCT</a>(read_config_memory);
00602     <span class="keywordflow">if</span> (line)
00603         (*mem)-&gt;line = strdup(line);
00604 }
00605 
00606 <span class="keywordtype">void</span>
00607 netsnmp_config_remember_free_list(<span class="keyword">struct</span> read_config_memory **mem)
00608 {
00609     <span class="keyword">struct </span>read_config_memory *tmpmem;
00610     <span class="keywordflow">while</span> (*mem) {
00611         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>((*mem)-&gt;line);
00612         tmpmem = (*mem)-&gt;next;
00613         <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(*mem);
00614         *mem = NULL;
00615         mem = &amp;tmpmem;
00616     }
00617 }
00618 
00619 <span class="keywordtype">void</span>
00620 netsnmp_config_process_memory_list(<span class="keyword">struct</span> read_config_memory **memp,
00621                                    <span class="keywordtype">int</span> when, <span class="keywordtype">int</span> clear)
00622 {
00623 
00624     <span class="keyword">struct </span>read_config_memory *mem;
00625 
00626     <span class="keywordflow">if</span> (!memp)
00627         <span class="keywordflow">return</span>;
00628 
00629     mem = *memp;
00630 
00631     <span class="keywordflow">while</span> (mem) {
00632         DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"processing memory: %s\n"</span>, mem-&gt;line));
00633         snmp_config_when(mem-&gt;line, when);
00634         mem = mem-&gt;next;
00635     }
00636 
00637     <span class="keywordflow">if</span> (clear)
00638         netsnmp_config_remember_free_list(memp);
00639 }
00640 
00641 <span class="comment">/*</span>
00642 <span class="comment"> * default storage location implementation </span>
00643 <span class="comment"> */</span>
00644 <span class="keyword">static</span> <span class="keyword">struct </span>read_config_memory *memorylist = NULL;
00645 
00646 <span class="keywordtype">void</span>
00647 netsnmp_config_remember(<span class="keywordtype">char</span> *line)
00648 {
00649     netsnmp_config_remember_in_list(line, &amp;memorylist);
00650 }
00651 
00652 <span class="keywordtype">void</span>
00653 netsnmp_config_process_memories(<span class="keywordtype">void</span>)
00654 {
00655     netsnmp_config_process_memory_list(&amp;memorylist, EITHER_CONFIG, 1);
00656 }
00657 
00658 <span class="keywordtype">void</span>
00659 netsnmp_config_process_memories_when(<span class="keywordtype">int</span> when, <span class="keywordtype">int</span> clear)
00660 {
00661     netsnmp_config_process_memory_list(&amp;memorylist, when, clear);
00662 }
00663 
00664 <span class="comment">/*******************************************************************-o-******</span>
00665 <span class="comment"> * read_config</span>
00666 <span class="comment"> *</span>
00667 <span class="comment"> * Parameters:</span>
00668 <span class="comment"> *      *filename</span>
00669 <span class="comment"> *      *line_handler</span>
00670 <span class="comment"> *       when</span>
00671 <span class="comment"> *</span>
00672 <span class="comment"> * Read &lt;filename&gt; and process each line in accordance with the list of</span>
00673 <span class="comment"> * &lt;line_handler&gt; functions.</span>
00674 <span class="comment"> *</span>
00675 <span class="comment"> *</span>
00676 <span class="comment"> * For each line in &lt;filename&gt;, search the list of &lt;line_handler&gt;'s </span>
00677 <span class="comment"> * for an entry that matches the first token on the line.  This comparison is</span>
00678 <span class="comment"> * case insensitive.</span>
00679 <span class="comment"> *</span>
00680 <span class="comment"> * For each match, check that &lt;when&gt; is the designated time for the</span>
00681 <span class="comment"> * &lt;line_handler&gt; function to be executed before processing the line.</span>
00682 <span class="comment"> */</span>
00683 <span class="keywordtype">void</span>
00684 read_config(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename,
00685             <span class="keyword">struct</span> config_line *line_handler, <span class="keywordtype">int</span> when)
00686 {
00687 
00688     FILE           *ifile;
00689     <span class="keywordtype">char</span>            line[STRINGMAX], token[STRINGMAX], tmpbuf[STRINGMAX];
00690     <span class="keywordtype">char</span>           *cptr;
00691     <span class="keywordtype">int</span>             i;
00692     <span class="keyword">struct </span>config_line *lptr;
00693 
00694     linecount = 0;
00695     curfilename = filename;
00696 
00697     <span class="keywordflow">if</span> ((ifile = fopen(filename, <span class="stringliteral">"r"</span>)) == NULL) {
00698 <span class="preprocessor">#ifdef ENOENT</span>
00699         <span class="keywordflow">if</span> (errno == ENOENT) {
00700             DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"%s: %s\n"</span>, filename,
00701                         strerror(errno)));
00702         } <span class="keywordflow">else</span>
00703 <span class="preprocessor">#endif                          </span><span class="comment">/* ENOENT */</span>
00704 <span class="preprocessor">#ifdef EACCES</span>
00705         <span class="keywordflow">if</span> (errno == EACCES) {
00706             DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"%s: %s\n"</span>, filename,
00707                         strerror(errno)));
00708         } <span class="keywordflow">else</span>
00709 <span class="preprocessor">#endif                          </span><span class="comment">/* EACCES */</span>
00710 <span class="preprocessor">#if defined(ENOENT) || defined(EACCES)</span>
00711         {
00712             snmp_log_perror(filename);
00713         }
00714 <span class="preprocessor">#else                           </span><span class=
"comment">/* defined(ENOENT) || defined(EACCES) */</span>
00715             snmp_log_perror(filename);
00716 <span class="preprocessor">#endif                          </span><span class="comment">/* ENOENT */</span>
00717         <span class="keywordflow">return</span>;
00718     } <span class="keywordflow">else</span> {
00719         DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"Reading configuration %s\n"</span>,
00720                     filename));
00721     }
00722 
00723     <span class="keywordflow">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), ifile) != NULL) {
00724         lptr = line_handler;
00725         linecount++;
00726         cptr = line;
00727         i = strlen(line) - 1;
00728         <span class="keywordflow">if</span> (line[i] == <span class="charliteral">'\n'</span>)
00729             line[i] = 0;
00730         <span class="comment">/*</span>
00731 <span class="comment">         * check blank line or # comment </span>
00732 <span class="comment">         */</span>
00733         <span class="keywordflow">if</span> ((cptr = skip_white(cptr))) {
00734             cptr = copy_nword(cptr, token, <span class="keyword">sizeof</span>(token));
00735             <span class="keywordflow">if</span> (token[0] == <span class="charliteral">'['</span>) {
00736                 <span class="keywordflow">if</span> (token[strlen(token) - 1] != <span class="charliteral">']'</span>) {
00737                     snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf),
00738                             <span class="stringliteral">"no matching ']' for type %s."</span>,
00739                             &amp;token[1]);
00740                     tmpbuf[ <span class="keyword">sizeof</span>(tmpbuf)-1 ] = 0;
00741                     config_perror(tmpbuf);
00742                     <span class="keywordflow">continue</span>;
00743                 }
00744                 token[strlen(token) - 1] = <span class="charliteral">'\0'</span>;
00745                 lptr = read_config_get_handlers(&amp;token[1]);
00746                 <span class="keywordflow">if</span> (lptr == NULL) {
00747                     snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf),
00748                             <span class="stringliteral">"No handlers regestered for type %s."</span>,
00749                             &amp;token[1]);
00750                     tmpbuf[ <span class="keyword">sizeof</span>(tmpbuf)-1 ] = 0;
00751                     config_perror(tmpbuf);
00752                     <span class="keywordflow">continue</span>;
00753                 }
00754                 DEBUGMSGTL((<span class="stringliteral">"read_config"</span>,
00755                             <span class="stringliteral">"Switching to new context: %s%s\n"</span>,
00756                             ((cptr) ? <span class="stringliteral">"(this line only) "</span> : <span class=
"stringliteral">""</span>),
00757                             &amp;token[1]));
00758                 <span class="keywordflow">if</span> (cptr == NULL) {
00759                     <span class="comment">/*</span>
00760 <span class="comment">                     * change context permanently </span>
00761 <span class="comment">                     */</span>
00762                     line_handler = lptr;
00763                     <span class="keywordflow">continue</span>;
00764                 } <span class="keywordflow">else</span> {
00765                     <span class="comment">/*</span>
00766 <span class="comment">                     * the rest of this line only applies. </span>
00767 <span class="comment">                     */</span>
00768                     cptr = copy_nword(cptr, token, <span class="keyword">sizeof</span>(token));
00769                 }
00770             } <span class="keywordflow">else</span> {
00771                 lptr = line_handler;
00772             }
00773             <span class="keywordflow">if</span> (cptr == NULL) {
00774                 snprintf(tmpbuf, <span class="keyword">sizeof</span>(tmpbuf),
00775                         <span class="stringliteral">"Blank line following %s token."</span>, token);
00776                 tmpbuf[ <span class="keyword">sizeof</span>(tmpbuf)-1 ] = 0;
00777                 config_perror(tmpbuf);
00778             } <span class="keywordflow">else</span> {
00779                 DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"%s:%d examining: %s\n"</span>,
00780                             filename, linecount, line));
00781                 run_config_handler(lptr, token, cptr, when);
00782             }
00783         }
00784     }
00785     fclose(ifile);
00786     <span class="keywordflow">return</span>;
00787 
00788 }                               <span class="comment">/* end read_config() */</span>
00789 
00790 
00791 
00792 <span class="keywordtype">void</span>
00793 free_config(<span class="keywordtype">void</span>)
00794 {
00795     <span class="keyword">struct </span>config_files *ctmp = config_files;
00796     <span class="keyword">struct </span>config_line *ltmp;
00797 
00798     <span class="keywordflow">for</span> (; ctmp != NULL; ctmp = ctmp-&gt;next)
00799         <span class="keywordflow">for</span> (ltmp = ctmp-&gt;start; ltmp != NULL; ltmp = ltmp-&gt;next)
00800             <span class="keywordflow">if</span> (ltmp-&gt;free_func)
00801                 (*(ltmp-&gt;free_func)) ();
00802 }
00803 
00804 <span class="keywordtype">void</span>
00805 read_configs_optional(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *optional_config, <span class="keywordtype">int</span> when)
00806 {
00807     <span class="keywordtype">char</span> *newp, *cp, *st;
00808     <span class="keywordtype">char</span> *type = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
00809                                        NETSNMP_DS_LIB_APPTYPE);
00810 
00811     <span class="keywordflow">if</span> ((NULL == optional_config) || (NULL == type))
00812         <span class="keywordflow">return</span>;
00813 
00814     DEBUGMSGTL((<span class="stringliteral">"read_configs_optional"</span>,
00815                 <span class="stringliteral">"reading optional configuration tokens for %s\n"</span>, type));
00816     
00817     newp = strdup(optional_config);      <span class="comment">/* strtok_r messes it up */</span>
00818     cp = strtok_r(newp, <span class="stringliteral">","</span>, &amp;st);
00819     <span class="keywordflow">while</span> (cp) {
00820         <span class="keyword">struct </span>stat     statbuf;
00821         <span class="keywordflow">if</span> (stat(cp, &amp;statbuf)) {
00822             DEBUGMSGTL((<span class="stringliteral">"read_config"</span>,
00823                         <span class="stringliteral">"Optional File \"%s\" does not exist.\n"</span>, cp));
00824             snmp_log_perror(cp);
00825         } <span class="keywordflow">else</span> {
00826             DEBUGMSGTL((<span class="stringliteral">"read_config"</span>,
00827                         <span class="stringliteral">"Reading optional config file: \"%s\"\n"</span>, cp));
00828             read_config_with_type_when(cp, type, when);
00829         }
00830         cp = strtok_r(NULL, <span class="stringliteral">","</span>, &amp;st);
00831     }
00832     free(newp);
00833     
00834 }
00835 
00836 <span class="keywordtype">void</span>
00837 read_configs(<span class="keywordtype">void</span>)
00838 {
00839     <span class="keywordtype">char</span> *optional_config = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
00840                                                NETSNMP_DS_LIB_OPTIONALCONFIG);
00841 
00842     DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"reading normal configuration tokens\n"</span>));
00843 
00844     <span class="keywordflow">if</span> ((NULL != optional_config) &amp;&amp; (*optional_config == <span class=
"charliteral">'-'</span>)) {
00845         read_configs_optional(++optional_config, NORMAL_CONFIG);
00846         optional_config = NULL; <span class="comment">/* clear, so we don't read them twice */</span>
00847     }
00848 
00849     read_config_files(NORMAL_CONFIG);
00850 
00851     <span class="comment">/*</span>
00852 <span class="comment">     * do this even when the normal above wasn't done </span>
00853 <span class="comment">     */</span>
00854     <span class="keywordflow">if</span> (NULL != optional_config)
00855         read_configs_optional(optional_config, NORMAL_CONFIG);
00856 
00857     netsnmp_config_process_memories_when(NORMAL_CONFIG, 1);
00858 
00859     <a class="code" href="group__default__store.html#ga8">netsnmp_ds_set_boolean</a>(NETSNMP_DS_LIBRARY_ID, 
00860                            NETSNMP_DS_LIB_HAVE_READ_CONFIG, 1);
00861     <a class="code" href="group__callback.html#ga10">snmp_call_callbacks</a>(SNMP_CALLBACK_LIBRARY,
00862                         SNMP_CALLBACK_POST_READ_CONFIG, NULL);
00863 }
00864 
00865 <span class="keywordtype">void</span>
00866 read_premib_configs(<span class="keywordtype">void</span>)
00867 {
00868     <span class="keywordtype">char</span> *optional_config = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
00869                                                NETSNMP_DS_LIB_OPTIONALCONFIG);
00870 
00871     DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"reading premib configuration tokens\n"</span>));
00872 
00873     <span class="keywordflow">if</span> ((NULL != optional_config) &amp;&amp; (*optional_config == <span class=
"charliteral">'-'</span>)) {
00874         read_configs_optional(++optional_config, PREMIB_CONFIG);
00875         optional_config = NULL; <span class="comment">/* clear, so we don't read them twice */</span>
00876     }
00877 
00878     read_config_files(PREMIB_CONFIG);
00879 
00880     <span class="keywordflow">if</span> (NULL != optional_config)
00881         read_configs_optional(optional_config, PREMIB_CONFIG);
00882 
00883     netsnmp_config_process_memories_when(PREMIB_CONFIG, 0);
00884 
00885     <a class="code" href="group__default__store.html#ga8">netsnmp_ds_set_boolean</a>(NETSNMP_DS_LIBRARY_ID, 
00886                            NETSNMP_DS_LIB_HAVE_READ_PREMIB_CONFIG, 1);
00887     <a class="code" href="group__callback.html#ga10">snmp_call_callbacks</a>(SNMP_CALLBACK_LIBRARY,
00888                         SNMP_CALLBACK_POST_PREMIB_READ_CONFIG, NULL);
00889 }
00890 
00891 <span class="comment">/*******************************************************************-o-******</span>
00892 <span class="comment"> * set_configuration_directory</span>
00893 <span class="comment"> *</span>
00894 <span class="comment"> * Parameters:</span>
00895 <span class="comment"> *      char *dir - value of the directory</span>
00896 <span class="comment"> * Sets the configuration directory. Multiple directories can be</span>
00897 <span class="comment"> * specified, but need to be seperated by 'ENV_SEPARATOR_CHAR'.</span>
00898 <span class="comment"> */</span>
00899 <span class="keywordtype">void</span>
00900 set_configuration_directory(<span class="keyword">const</span> <span class="keywordtype">char</span> *dir)
00901 {
00902     netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID, 
00903                           NETSNMP_DS_LIB_CONFIGURATION_DIR, dir);
00904 }
00905 
00906 <span class="comment">/*******************************************************************-o-******</span>
00907 <span class="comment"> * get_configuration_directory</span>
00908 <span class="comment"> *</span>
00909 <span class="comment"> * Parameters: -</span>
00910 <span class="comment"> * Retrieve the configuration directory or directories.</span>
00911 <span class="comment"> * (For backwards compatibility that is:</span>
00912 <span class="comment"> *       SNMPCONFPATH, SNMPSHAREPATH, SNMPLIBPATH, HOME/.snmp</span>
00913 <span class="comment"> * First check whether the value is set.</span>
00914 <span class="comment"> * If not set give it the default value.</span>
00915 <span class="comment"> * Return the value.</span>
00916 <span class="comment"> * We always retrieve it new, since we have to do it anyway if it is just set.</span>
00917 <span class="comment"> */</span>
00918 <span class="keyword">const</span> <span class="keywordtype">char</span>     *
00919 get_configuration_directory()
00920 {
00921     <span class="keywordtype">char</span>            defaultPath[SPRINT_MAX_LEN];
00922     <span class="keywordtype">char</span>           *homepath;
00923 
00924     <span class="keywordflow">if</span> (NULL == netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
00925                                       NETSNMP_DS_LIB_CONFIGURATION_DIR)) {
00926         homepath = <a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class=
"stringliteral">"HOME"</span>);
00927         snprintf(defaultPath, <span class="keyword">sizeof</span>(defaultPath), <span class=
"stringliteral">"%s%c%s%c%s%s%s%s"</span>,
00928                 SNMPCONFPATH, ENV_SEPARATOR_CHAR,
00929                 SNMPSHAREPATH, ENV_SEPARATOR_CHAR, SNMPLIBPATH,
00930                 ((homepath == NULL) ? <span class="stringliteral">""</span> : ENV_SEPARATOR),
00931                 ((homepath == NULL) ? <span class="stringliteral">""</span> : homepath),
00932                 ((homepath == NULL) ? <span class="stringliteral">""</span> : <span class=
"stringliteral">"/.snmp"</span>));
00933         defaultPath[ <span class="keyword">sizeof</span>(defaultPath)-1 ] = 0;
00934         set_configuration_directory(defaultPath);
00935     }
00936     <span class="keywordflow">return</span> (netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
00937                                   NETSNMP_DS_LIB_CONFIGURATION_DIR));
00938 }
00939 
00940 <span class="comment">/*******************************************************************-o-******</span>
00941 <span class="comment"> * set_persistent_directory</span>
00942 <span class="comment"> *</span>
00943 <span class="comment"> * Parameters:</span>
00944 <span class="comment"> *      char *dir - value of the directory</span>
00945 <span class="comment"> * Sets the configuration directory. </span>
00946 <span class="comment"> * No multiple directories may be specified.</span>
00947 <span class="comment"> * (However, this is not checked)</span>
00948 <span class="comment"> */</span>
00949 <span class="keywordtype">void</span>
00950 set_persistent_directory(<span class="keyword">const</span> <span class="keywordtype">char</span> *dir)
00951 {
00952     netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID, 
00953                           NETSNMP_DS_LIB_PERSISTENT_DIR, dir);
00954 }
00955 
00956 <span class="comment">/*******************************************************************-o-******</span>
00957 <span class="comment"> * get_persistent_directory</span>
00958 <span class="comment"> *</span>
00959 <span class="comment"> * Parameters: -</span>
00960 <span class="comment"> * Function will retrieve the persisten directory value.</span>
00961 <span class="comment"> * First check whether the value is set.</span>
00962 <span class="comment"> * If not set give it the default value.</span>
00963 <span class="comment"> * Return the value. </span>
00964 <span class="comment"> * We always retrieve it new, since we have to do it anyway if it is just set.</span>
00965 <span class="comment"> */</span>
00966 <span class="keyword">const</span> <span class="keywordtype">char</span>     *
00967 get_persistent_directory()
00968 {
00969     <span class="keywordflow">if</span> (NULL == netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
00970                                       NETSNMP_DS_LIB_PERSISTENT_DIR)) {
00971         <span class="keywordtype">char</span> *persdir = <a class="code" href=
"group__util.html#ga24">netsnmp_getenv</a>(<span class="stringliteral">"SNMP_PERSISTENT_DIR"</span>);
00972         <span class="keywordflow">if</span> (NULL == persdir)
00973             persdir = PERSISTENT_DIRECTORY;
00974         set_persistent_directory(persdir);
00975     }
00976     <span class="keywordflow">return</span> (netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
00977                                   NETSNMP_DS_LIB_PERSISTENT_DIR));
00978 }
00979 
00980 <span class="comment">/*******************************************************************-o-******</span>
00981 <span class="comment"> * set_temp_file_pattern</span>
00982 <span class="comment"> *</span>
00983 <span class="comment"> * Parameters:</span>
00984 <span class="comment"> *      char *pattern - value of the file pattern</span>
00985 <span class="comment"> * Sets the temp file pattern. </span>
00986 <span class="comment"> * Multiple patterns may not be specified.</span>
00987 <span class="comment"> * (However, this is not checked)</span>
00988 <span class="comment"> */</span>
00989 <span class="keywordtype">void</span>
00990 set_temp_file_pattern(<span class="keyword">const</span> <span class="keywordtype">char</span> *pattern)
00991 {
00992     netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID, 
00993                           NETSNMP_DS_LIB_TEMP_FILE_PATTERN, pattern);
00994 }
00995 
00996 <span class="comment">/*******************************************************************-o-******</span>
00997 <span class="comment"> * get_temp_file_pattern</span>
00998 <span class="comment"> *</span>
00999 <span class="comment"> * Parameters: -</span>
01000 <span class="comment"> * Function will retrieve the temp file pattern value.</span>
01001 <span class="comment"> * First check whether the value is set.</span>
01002 <span class="comment"> * If not set give it the default value.</span>
01003 <span class="comment"> * Return the value. </span>
01004 <span class="comment"> * We always retrieve it new, since we have to do it anyway if it is just set.</span>
01005 <span class="comment"> */</span>
01006 <span class="keyword">const</span> <span class="keywordtype">char</span>     *
01007 get_temp_file_pattern()
01008 {
01009     <span class="keywordflow">if</span> (NULL == netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01010                                       NETSNMP_DS_LIB_TEMP_FILE_PATTERN)) {
01011         set_temp_file_pattern(NETSNMP_TEMP_FILE_PATTERN);
01012     }
01013     <span class="keywordflow">return</span> (netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01014                                   NETSNMP_DS_LIB_TEMP_FILE_PATTERN));
01015 }
01016 
01020 <span class="keyword">static</span> <span class="keywordtype">void</span>
01021 read_config_files_in_path(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class=
"keyword">struct</span> config_files *ctmp,
01022                           <span class="keywordtype">int</span> when, <span class="keyword">const</span> <span class=
"keywordtype">char</span> *perspath, <span class="keyword">const</span> <span class="keywordtype">char</span> *persfile)
01023 {
01024     <span class="keywordtype">int</span>             done, j;
01025     <span class="keywordtype">char</span>            configfile[300];
01026     <span class="keywordtype">char</span>           *cptr1, *cptr2, *envconfpath;
01027     <span class="keyword">struct </span>stat     statbuf;
01028 
01029     <span class="keywordflow">if</span> ((NULL == path) || (NULL == ctmp))
01030         <span class="keywordflow">return</span>;
01031 
01032     envconfpath = strdup(path);
01033 
01034     DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">" config path used for %s:%s (persistent path:%s)\n"</span>,
01035                 ctmp-&gt;fileHeader, envconfpath, perspath));
01036     cptr1 = cptr2 = envconfpath;
01037     done = 0;
01038     <span class="keywordflow">while</span> (*cptr2 != 0) {
01039         <span class="keywordflow">while</span> (*cptr1 != 0 &amp;&amp; *cptr1 != ENV_SEPARATOR_CHAR)
01040             cptr1++;
01041         <span class="keywordflow">if</span> (*cptr1 == 0)
01042             done = 1;
01043         <span class="keywordflow">else</span>
01044             *cptr1 = 0;
01045         <span class="comment">/*</span>
01046 <span class="comment">         * for proper persistent storage retrival, we need to read old backup</span>
01047 <span class="comment">         * copies of the previous storage files.  If the application in</span>
01048 <span class="comment">         * question has died without the proper call to snmp_clean_persistent,</span>
01049 <span class="comment">         * then we read all the configuration files we can, starting with</span>
01050 <span class="comment">         * the oldest first.</span>
01051 <span class="comment">         */</span>
01052         <span class="keywordflow">if</span> (strncmp(cptr2, perspath, strlen(perspath)) == 0 ||
01053             (persfile != NULL &amp;&amp;
01054              strncmp(cptr2, persfile, strlen(persfile)) == 0)) {
01055             <span class="comment">/*</span>
01056 <span class="comment">             * limit this to the known storage directory only </span>
01057 <span class="comment">             */</span>
01058             <span class="keywordflow">for</span> (j = 0; j &lt;= MAX_PERSISTENT_BACKUPS; j++) {
01059                 snprintf(configfile, <span class="keyword">sizeof</span>(configfile),
01060                          <span class="stringliteral">"%s/%s.%d.conf"</span>, cptr2,
01061                          ctmp-&gt;fileHeader, j);
01062                 configfile[ <span class="keyword">sizeof</span>(configfile)-1 ] = 0;
01063                 <span class="keywordflow">if</span> (stat(configfile, &amp;statbuf) != 0) {
01064                     <span class="comment">/*</span>
01065 <span class="comment">                     * file not there, continue </span>
01066 <span class="comment">                     */</span>
01067                     <span class="keywordflow">break</span>;
01068                 } <span class="keywordflow">else</span> {
01069                     <span class="comment">/*</span>
01070 <span class="comment">                     * backup exists, read it </span>
01071 <span class="comment">                     */</span>
01072                     DEBUGMSGTL((<span class="stringliteral">"read_config_files"</span>,
01073                                 <span class="stringliteral">"old config file found: %s, parsing\n"</span>,
01074                                 configfile));
01075                     read_config(configfile, ctmp-&gt;start, when);
01076                 }
01077             }
01078         }
01079         snprintf(configfile, <span class="keyword">sizeof</span>(configfile),
01080                  <span class="stringliteral">"%s/%s.conf"</span>, cptr2, ctmp-&gt;fileHeader);
01081         configfile[ <span class="keyword">sizeof</span>(configfile)-1 ] = 0;
01082         read_config(configfile, ctmp-&gt;start, when);
01083         snprintf(configfile, <span class="keyword">sizeof</span>(configfile),
01084                  <span class="stringliteral">"%s/%s.local.conf"</span>, cptr2, ctmp-&gt;fileHeader);
01085         configfile[ <span class="keyword">sizeof</span>(configfile)-1 ] = 0;
01086         read_config(configfile, ctmp-&gt;start, when);
01087 
01088         <span class="keywordflow">if</span>(done)
01089             <span class="keywordflow">break</span>;
01090 
01091         cptr2 = ++cptr1;
01092     }
01093     <a class="code" href="group__util.html#ga36">SNMP_FREE</a>(envconfpath);
01094 }
01095 
01096 <span class="comment">/*******************************************************************-o-******</span>
01097 <span class="comment"> * read_config_files</span>
01098 <span class="comment"> *</span>
01099 <span class="comment"> * Parameters:</span>
01100 <span class="comment"> *      when    == PREMIB_CONFIG, NORMAL_CONFIG  -or-  EITHER_CONFIG</span>
01101 <span class="comment"> *</span>
01102 <span class="comment"> *</span>
01103 <span class="comment"> * Traverse the list of config file types, performing the following actions</span>
01104 <span class="comment"> * for each --</span>
01105 <span class="comment"> *</span>
01106 <span class="comment"> * First, build a search path for config files.  If the contents of </span>
01107 <span class="comment"> * environment variable SNMPCONFPATH are NULL, then use the following</span>
01108 <span class="comment"> * path list (where the last entry exists only if HOME is non-null):</span>
01109 <span class="comment"> *</span>
01110 <span class="comment"> *      SNMPSHAREPATH:SNMPLIBPATH:${HOME}/.snmp</span>
01111 <span class="comment"> *</span>
01112 <span class="comment"> * Then, In each of these directories, read config files by the name of:</span>
01113 <span class="comment"> *</span>
01114 <span class="comment"> *      &lt;dir&gt;/&lt;fileHeader&gt;.conf         -AND-</span>
01115 <span class="comment"> *      &lt;dir&gt;/&lt;fileHeader&gt;.local.conf</span>
01116 <span class="comment"> *</span>
01117 <span class="comment"> * where &lt;fileHeader&gt; is taken from the config file type structure.</span>
01118 <span class="comment"> *</span>
01119 <span class="comment"> *</span>
01120 <span class="comment"> * PREMIB_CONFIG causes free_config() to be invoked prior to any other action.</span>
01121 <span class="comment"> *</span>
01122 <span class="comment"> *</span>
01123 <span class="comment"> * EXITs if any 'config_errors' are logged while parsing config file lines.</span>
01124 <span class="comment"> */</span>
01125 <span class="keywordtype">void</span>
01126 read_config_files(<span class="keywordtype">int</span> when)
01127 {
01128     <span class="keyword">const</span> <span class=
"keywordtype">char</span>     *confpath, *perspath, *persfile, *envconfpath;
01129     <span class="keyword">struct </span>config_files *ctmp = config_files;
01130 
01131     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
01132                                NETSNMP_DS_LIB_DONT_PERSIST_STATE)
01133      || netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
01134                                NETSNMP_DS_LIB_DISABLE_CONFIG_LOAD)) <span class="keywordflow">return</span>;
01135 
01136     config_errors = 0;
01137 
01138     <span class="keywordflow">if</span> (when == PREMIB_CONFIG)
01139         free_config();
01140 
01141     <span class="comment">/*</span>
01142 <span class="comment">     * these shouldn't change</span>
01143 <span class="comment">     */</span>
01144     confpath = get_configuration_directory();
01145     persfile = <a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class=
"stringliteral">"SNMP_PERSISTENT_FILE"</span>);
01146     envconfpath = <a class="code" href="group__util.html#ga24">netsnmp_getenv</a>(<span class=
"stringliteral">"SNMPCONFPATH"</span>);
01147 
01148     <span class="comment">/*</span>
01149 <span class="comment">     * read all config file types </span>
01150 <span class="comment">     */</span>
01151     <span class="keywordflow">for</span> (; ctmp != NULL; ctmp = ctmp-&gt;next) {
01152 
01153         <span class="comment">/*</span>
01154 <span class="comment">         * read the config files </span>
01155 <span class="comment">         */</span>
01156         perspath = get_persistent_directory();
01157         <span class="keywordflow">if</span> (envconfpath == NULL) {
01158             <span class="comment">/*</span>
01159 <span class="comment">             * read just the config files (no persistent stuff), since</span>
01160 <span class="comment">             * persistent path can change via conf file. Then get the</span>
01161 <span class="comment">             * current persistent directory, and read files there.</span>
01162 <span class="comment">             */</span>
01163             read_config_files_in_path(confpath, ctmp, when, perspath,
01164                                       persfile);
01165             perspath = get_persistent_directory();
01166             read_config_files_in_path(perspath, ctmp, when, perspath,
01167                                       persfile);
01168         }
01169         <span class="keywordflow">else</span> {
01170             <span class="comment">/*</span>
01171 <span class="comment">             * only read path specified by user</span>
01172 <span class="comment">             */</span>
01173             read_config_files_in_path(envconfpath, ctmp, when, perspath,
01174                                       persfile);
01175         }
01176     }
01177 
01178     <span class="keywordflow">if</span> (config_errors) {
01179         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"net-snmp: %d error(s) in config file(s)\n"</span>,
01180                  config_errors);
01181     }
01182 }
01183 
01184 <span class="keywordtype">void</span>
01185 read_config_print_usage(<span class="keyword">const</span> <span class="keywordtype">char</span> *lead)
01186 {
01187     <span class="keyword">struct </span>config_files *ctmp = config_files;
01188     <span class="keyword">struct </span>config_line *ltmp;
01189 
01190     <span class="keywordflow">if</span> (lead == NULL)
01191         lead = <span class="stringliteral">""</span>;
01192 
01193     <span class="keywordflow">for</span> (ctmp = config_files; ctmp != NULL; ctmp = ctmp-&gt;next) {
01194         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_INFO, <span class=
"stringliteral">"%sIn %s.conf and %s.local.conf:\n"</span>, lead,
01195                  ctmp-&gt;fileHeader, ctmp-&gt;fileHeader);
01196         <span class="keywordflow">for</span> (ltmp = ctmp-&gt;start; ltmp != NULL; ltmp = ltmp-&gt;next) {
01197             DEBUGIF(<span class="stringliteral">"read_config_usage"</span>) {
01198                 <span class="keywordflow">if</span> (ltmp-&gt;config_time == PREMIB_CONFIG)
01199                     DEBUGMSG((<span class="stringliteral">"read_config_usage"</span>, <span class=
"stringliteral">"*"</span>));
01200                 <span class="keywordflow">else</span>
01201                     DEBUGMSG((<span class="stringliteral">"read_config_usage"</span>, <span class=
"stringliteral">" "</span>));
01202             }
01203             <span class="keywordflow">if</span> (ltmp-&gt;help) {
01204                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_INFO, <span class=
"stringliteral">"%s%s%-24s %s\n"</span>, lead, lead,
01205                          ltmp-&gt;config_token, ltmp-&gt;help);
01206             } <span class="keywordflow">else</span> {
01207                 DEBUGIF(<span class="stringliteral">"read_config_usage"</span>) {
01208                     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_INFO, <span class=
"stringliteral">"%s%s%-24s [NO HELP]\n"</span>, lead, lead,
01209                              ltmp-&gt;config_token);
01210                 }
01211             }
01212         }
01213     }
01214 }
01215 
01229 <span class="keywordtype">void</span>
<a name="l01230" id="l01230"></a><a class="code" href="group__read__config.html#ga40">01230</a> <a class="code" href=
"group__read__config.html#ga40">read_config_store</a>(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *type, <span class="keyword">const</span> <span class="keywordtype">char</span> *line)
01231 {
01232 <span class="preprocessor">#ifdef PERSISTENT_DIRECTORY</span>
01233     <span class="keywordtype">char</span>            file[512], *filep;
01234     FILE           *fout;
01235 <span class="preprocessor">#ifdef PERSISTENT_MASK</span>
01236     mode_t          oldmask;
01237 <span class="preprocessor">#endif</span>
01238 
01239     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
01240                                NETSNMP_DS_LIB_DONT_PERSIST_STATE)
01241      || netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
01242                                NETSNMP_DS_LIB_DISABLE_PERSISTENT_LOAD)) <span class="keywordflow">return</span>;
01243 
01244     <span class="comment">/*</span>
01245 <span class="comment">     * store configuration directives in the following order of preference:</span>
01246 <span class="comment">     * 1. ENV variable SNMP_PERSISTENT_FILE</span>
01247 <span class="comment">     * 2. configured &lt;PERSISTENT_DIRECTORY&gt;/&lt;type&gt;.conf</span>
01248 <span class="comment">     */</span>
01249     <span class="keywordflow">if</span> ((filep = <a class="code" href=
"group__util.html#ga24">netsnmp_getenv</a>(<span class="stringliteral">"SNMP_PERSISTENT_FILE"</span>)) == NULL) {
01250         snprintf(file, <span class="keyword">sizeof</span>(file),
01251                  <span class="stringliteral">"%s/%s.conf"</span>, get_persistent_directory(), type);
01252         file[ <span class="keyword">sizeof</span>(file)-1 ] = 0;
01253         filep = file;
01254     }
01255 <span class="preprocessor">#ifdef PERSISTENT_MASK</span>
01256     oldmask = umask(PERSISTENT_MASK);
01257 <span class="preprocessor">#endif</span>
01258     <span class="keywordflow">if</span> (mkdirhier(filep, AGENT_DIRECTORY_MODE, 1)) {
01259         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
01260                  <span class="stringliteral">"Failed to create the persistent directory for %s\n"</span>,
01261                  file);
01262     }
01263     <span class="keywordflow">if</span> ((fout = fopen(filep, <span class="stringliteral">"a"</span>)) != NULL) {
01264         fprintf(fout, <span class="stringliteral">"%s"</span>, line);
01265         <span class="keywordflow">if</span> (line[strlen(line)] != <span class="charliteral">'\n'</span>)
01266             fprintf(fout, <span class="stringliteral">"\n"</span>);
01267         DEBUGMSGTL((<span class="stringliteral">"read_config"</span>, <span class=
"stringliteral">"storing: %s\n"</span>, line));
01268         fclose(fout);
01269     } <span class="keywordflow">else</span> {
01270         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"read_config_store open failure on %s\n"</span>, filep);
01271     }
01272 <span class="preprocessor">#ifdef PERSISTENT_MASK</span>
01273     umask(oldmask);
01274 <span class="preprocessor">#endif</span>
01275 
01276 <span class="preprocessor">#endif</span>
01277 }                               <span class="comment">/* end read_config_store() */</span>
01278 
01279 <span class="keywordtype">void</span>
01280 read_app_config_store(<span class="keyword">const</span> <span class="keywordtype">char</span> *line)
01281 {
01282     <a class="code" href=
"group__read__config.html#ga40">read_config_store</a>(netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, 
01283                                             NETSNMP_DS_LIB_APPTYPE), line);
01284 }
01285 
01286 
01287 
01288 
01289 <span class="comment">/*******************************************************************-o-******</span>
01290 <span class="comment"> * snmp_save_persistent</span>
01291 <span class="comment"> *</span>
01292 <span class="comment"> * Parameters:</span>
01293 <span class="comment"> *      *type</span>
01294 <span class="comment"> *      </span>
01295 <span class="comment"> *</span>
01296 <span class="comment"> * Save the file "&lt;PERSISTENT_DIRECTORY&gt;/&lt;type&gt;.conf" into a backup copy</span>
01297 <span class="comment"> * called "&lt;PERSISTENT_DIRECTORY&gt;/&lt;type&gt;.%d.conf", which %d is an</span>
01298 <span class="comment"> * incrementing number on each call, but less than MAX_PERSISTENT_BACKUPS.</span>
01299 <span class="comment"> *</span>
01300 <span class="comment"> * Should be called just before all persistent information is supposed to be</span>
01301 <span class="comment"> * written to move aside the existing persistent cache.</span>
01302 <span class="comment"> * snmp_clean_persistent should then be called afterward all data has been</span>
01303 <span class="comment"> * saved to remove these backup files.</span>
01304 <span class="comment"> *</span>
01305 <span class="comment"> * Note: on an rename error, the files are removed rather than saved.</span>
01306 <span class="comment"> *</span>
01307 <span class="comment"> */</span>
01308 <span class="keywordtype">void</span>
01309 snmp_save_persistent(<span class="keyword">const</span> <span class="keywordtype">char</span> *type)
01310 {
01311     <span class="keywordtype">char</span>            file[512], fileold[SPRINT_MAX_LEN];
01312     <span class="keyword">struct </span>stat     statbuf;
01313     <span class="keywordtype">int</span>             j;
01314 
01315     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
01316                                NETSNMP_DS_LIB_DONT_PERSIST_STATE)
01317      || netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
01318                                NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAVE)) <span class="keywordflow">return</span>;
01319 
01320     DEBUGMSGTL((<span class="stringliteral">"snmp_save_persistent"</span>, <span class=
"stringliteral">"saving %s files...\n"</span>, type));
01321     snprintf(file, <span class="keyword">sizeof</span>(file),
01322              <span class="stringliteral">"%s/%s.conf"</span>, get_persistent_directory(), type);
01323     file[ <span class="keyword">sizeof</span>(file)-1 ] = 0;
01324     <span class="keywordflow">if</span> (stat(file, &amp;statbuf) == 0) {
01325         <span class="keywordflow">for</span> (j = 0; j &lt;= MAX_PERSISTENT_BACKUPS; j++) {
01326             snprintf(fileold, <span class="keyword">sizeof</span>(fileold),
01327                      <span class="stringliteral">"%s/%s.%d.conf"</span>, get_persistent_directory(), type, j);
01328             fileold[ <span class="keyword">sizeof</span>(fileold)-1 ] = 0;
01329             <span class="keywordflow">if</span> (stat(fileold, &amp;statbuf) != 0) {
01330                 DEBUGMSGTL((<span class="stringliteral">"snmp_save_persistent"</span>,
01331                             <span class="stringliteral">" saving old config file: %s -&gt; %s.\n"</span>, file,
01332                             fileold));
01333                 <span class="keywordflow">if</span> (rename(file, fileold)) {
01334                     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Cannot rename %s to %s\n"</span>, file, fileold);
01335                      <span class="comment">/* moving it failed, try nuking it, as leaving</span>
01336 <span class="comment">                      * it around is very bad. */</span>
01337                     <span class="keywordflow">if</span> (unlink(file) == -1)
01338                         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Cannot unlink %s\n"</span>, file);
01339                 }
01340                 <span class="keywordflow">break</span>;
01341             }
01342         }
01343     }
01344     <span class="comment">/*</span>
01345 <span class="comment">     * save a warning header to the top of the new file </span>
01346 <span class="comment">     */</span>
01347     snprintf(fileold, <span class="keyword">sizeof</span>(fileold),
01348             <span class=
"stringliteral">"#\n# net-snmp (or ucd-snmp) persistent data file.\n#\n############################################################################\n# STOP STOP STOP STOP STOP STOP STOP STOP STOP \n#\n#          **** DO NOT EDIT THIS FILE ****\n#\n# STOP STOP STOP STOP STOP STOP STOP STOP STOP \n############################################################################\n#\n# DO NOT STORE CONFIGURATION ENTRIES HERE.\n# Please save normal configuration tokens for %s in SNMPCONFPATH/%s.conf.\n# Only \"createUser\" tokens should be placed here by %s administrators.\n# (Did I mention: do not edit this file?)\n#\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"</span>,
01349             type, type, type);
01350     fileold[ <span class="keyword">sizeof</span>(fileold)-1 ] = 0;
01351     <a class="code" href="group__read__config.html#ga40">read_config_store</a>(type, fileold);
01352 }
01353 
01354 
01355 <span class="comment">/*******************************************************************-o-******</span>
01356 <span class="comment"> * snmp_clean_persistent</span>
01357 <span class="comment"> *</span>
01358 <span class="comment"> * Parameters:</span>
01359 <span class="comment"> *      *type</span>
01360 <span class="comment"> *      </span>
01361 <span class="comment"> *</span>
01362 <span class="comment"> * Unlink all backup files called "&lt;PERSISTENT_DIRECTORY&gt;/&lt;type&gt;.%d.conf".</span>
01363 <span class="comment"> *</span>
01364 <span class="comment"> * Should be called just after we successfull dumped the last of the</span>
01365 <span class="comment"> * persistent data, to remove the backup copies of previous storage dumps.</span>
01366 <span class="comment"> *</span>
01367 <span class="comment"> * XXX  Worth overwriting with random bytes first?  This would</span>
01368 <span class="comment"> *      ensure that the data is destroyed, even a buffer containing the</span>
01369 <span class="comment"> *      data persists in memory or swap.  Only important if secrets</span>
01370 <span class="comment"> *      will be stored here.</span>
01371 <span class="comment"> */</span>
01372 <span class="keywordtype">void</span>
01373 snmp_clean_persistent(<span class="keyword">const</span> <span class="keywordtype">char</span> *type)
01374 {
01375     <span class="keywordtype">char</span>            file[512];
01376     <span class="keyword">struct </span>stat     statbuf;
01377     <span class="keywordtype">int</span>             j;
01378 
01379     <span class="keywordflow">if</span> (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
01380                                NETSNMP_DS_LIB_DONT_PERSIST_STATE)
01381      || netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,
01382                                NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAVE)) <span class="keywordflow">return</span>;
01383 
01384     DEBUGMSGTL((<span class="stringliteral">"snmp_clean_persistent"</span>, <span class=
"stringliteral">"cleaning %s files...\n"</span>, type));
01385     snprintf(file, <span class="keyword">sizeof</span>(file),
01386              <span class="stringliteral">"%s/%s.conf"</span>, get_persistent_directory(), type);
01387     file[ <span class="keyword">sizeof</span>(file)-1 ] = 0;
01388     <span class="keywordflow">if</span> (stat(file, &amp;statbuf) == 0) {
01389         <span class="keywordflow">for</span> (j = 0; j &lt;= MAX_PERSISTENT_BACKUPS; j++) {
01390             snprintf(file, <span class="keyword">sizeof</span>(file),
01391                      <span class="stringliteral">"%s/%s.%d.conf"</span>, get_persistent_directory(), type, j);
01392             file[ <span class="keyword">sizeof</span>(file)-1 ] = 0;
01393             <span class="keywordflow">if</span> (stat(file, &amp;statbuf) == 0) {
01394                 DEBUGMSGTL((<span class="stringliteral">"snmp_clean_persistent"</span>,
01395                             <span class="stringliteral">" removing old config file: %s\n"</span>, file));
01396                 <span class="keywordflow">if</span> (unlink(file) == -1)
01397                     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"Cannot unlink %s\n"</span>, file);
01398             }
01399         }
01400     }
01401 }
01402 
01403 
01404 
01405 
01406 <span class="comment">/*</span>
01407 <span class="comment"> * config_perror: prints a warning string associated with a file and</span>
01408 <span class="comment"> * line number of a .conf file and increments the error count. </span>
01409 <span class="comment"> */</span>
01410 <span class="keywordtype">void</span>
01411 config_perror(<span class="keyword">const</span> <span class="keywordtype">char</span> *str)
01412 {
01413     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"%s: line %d: Error: %s\n"</span>, curfilename, linecount,
01414              str);
01415     config_errors++;
01416 }
01417 
01418 <span class="keywordtype">void</span>
01419 config_pwarn(<span class="keyword">const</span> <span class="keywordtype">char</span> *str)
01420 {
01421     <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING, <span class=
"stringliteral">"%s: line %d: Warning: %s\n"</span>, curfilename,
01422              linecount, str);
01423 }
01424 
01425 <span class="comment">/*</span>
01426 <span class="comment"> * skip all white spaces and return 1 if found something either end of</span>
01427 <span class="comment"> * line or a comment character </span>
01428 <span class="comment"> */</span>
01429 <span class="keywordtype">char</span>           *
01430 skip_white(<span class="keywordtype">char</span> *ptr)
01431 {
01432     <span class="keywordflow">if</span> (ptr == NULL)
01433         <span class="keywordflow">return</span> (NULL);
01434     <span class="keywordflow">while</span> (*ptr != 0 &amp;&amp; isspace(*ptr))
01435         ptr++;
01436     <span class="keywordflow">if</span> (*ptr == 0 || *ptr == <span class="charliteral">'#'</span>)
01437         <span class="keywordflow">return</span> (NULL);
01438     <span class="keywordflow">return</span> (ptr);
01439 }
01440 
01441 <span class="keywordtype">char</span>           *
01442 skip_not_white(<span class="keywordtype">char</span> *ptr)
01443 {
01444     <span class="keywordflow">if</span> (ptr == NULL)
01445         <span class="keywordflow">return</span> (NULL);
01446     <span class="keywordflow">while</span> (*ptr != 0 &amp;&amp; !isspace(*ptr))
01447         ptr++;
01448     <span class="keywordflow">if</span> (*ptr == 0 || *ptr == <span class="charliteral">'#'</span>)
01449         <span class="keywordflow">return</span> (NULL);
01450     <span class="keywordflow">return</span> (ptr);
01451 }
01452 
01453 <span class="keywordtype">char</span>           *
01454 skip_token(<span class="keywordtype">char</span> *ptr)
01455 {
01456     ptr = skip_white(ptr);
01457     ptr = skip_not_white(ptr);
01458     ptr = skip_white(ptr);
01459     <span class="keywordflow">return</span> (ptr);
01460 }
01461 
01462 <span class="comment">/*</span>
01463 <span class="comment"> * copy_word</span>
01464 <span class="comment"> * copies the next 'token' from 'from' into 'to', maximum len-1 characters.</span>
01465 <span class="comment"> * currently a token is anything seperate by white space</span>
01466 <span class="comment"> * or within quotes (double or single) (i.e. "the red rose" </span>
01467 <span class="comment"> * is one token, \"the red rose\" is three tokens)</span>
01468 <span class="comment"> * a '\' character will allow a quote character to be treated</span>
01469 <span class="comment"> * as a regular character </span>
01470 <span class="comment"> * It returns a pointer to first non-white space after the end of the token</span>
01471 <span class="comment"> * being copied or to 0 if we reach the end.</span>
01472 <span class="comment"> * Note: Partially copied words (greater than len) still returns a !NULL ptr</span>
01473 <span class="comment"> * Note: partially copied words are, however, null terminated.</span>
01474 <span class="comment"> */</span>
01475 
01476 <span class="keywordtype">char</span>           *
01477 copy_nword(<span class="keywordtype">char</span> *from, <span class="keywordtype">char</span> *to, <span class=
"keywordtype">int</span> len)
01478 {
01479     <span class="keywordtype">char</span>            quote;
01480     <span class="keywordflow">if</span> (!from || !to)
01481         <span class="keywordflow">return</span> NULL;
01482     <span class="keywordflow">if</span> ((*from == <span class="charliteral">'\"'</span>) || (*from == <span class=
"charliteral">'\''</span>)) {
01483         quote = *(from++);
01484         <span class="keywordflow">while</span> ((*from != quote) &amp;&amp; (*from != 0)) {
01485             <span class="keywordflow">if</span> ((*from == <span class=
"charliteral">'\\'</span>) &amp;&amp; (*(from + 1) != 0)) {
01486                 <span class="keywordflow">if</span> (len &gt; 0) {  <span class=
"comment">/* don't copy beyond len bytes */</span>
01487                     *to++ = *(from + 1);
01488                     <span class="keywordflow">if</span> (--len == 0)
01489                         *(to - 1) = <span class="charliteral">'\0'</span>;       <span class=
"comment">/* null protect the last spot */</span>
01490                 }
01491                 from = from + 2;
01492             } <span class="keywordflow">else</span> {
01493                 <span class="keywordflow">if</span> (len &gt; 0) {  <span class=
"comment">/* don't copy beyond len bytes */</span>
01494                     *to++ = *from++;
01495                     <span class="keywordflow">if</span> (--len == 0)
01496                         *(to - 1) = <span class="charliteral">'\0'</span>;       <span class=
"comment">/* null protect the last spot */</span>
01497                 } <span class="keywordflow">else</span>
01498                     from++;
01499             }
01500         }
01501         <span class="keywordflow">if</span> (*from == 0) {
01502             DEBUGMSGTL((<span class="stringliteral">"read_config_copy_word"</span>,
01503                         <span class="stringliteral">"no end quote found in config string\n"</span>));
01504         } <span class="keywordflow">else</span>
01505             from++;
01506     } <span class="keywordflow">else</span> {
01507         <span class="keywordflow">while</span> (*from != 0 &amp;&amp; !isspace(*from)) {
01508             <span class="keywordflow">if</span> ((*from == <span class=
"charliteral">'\\'</span>) &amp;&amp; (*(from + 1) != 0)) {
01509                 <span class="keywordflow">if</span> (len &gt; 0) {  <span class=
"comment">/* don't copy beyond len bytes */</span>
01510                     *to++ = *(from + 1);
01511                     <span class="keywordflow">if</span> (--len == 0)
01512                         *(to - 1) = <span class="charliteral">'\0'</span>;       <span class=
"comment">/* null protect the last spot */</span>
01513                 }
01514                 from = from + 2;
01515             } <span class="keywordflow">else</span> {
01516                 <span class="keywordflow">if</span> (len &gt; 0) {  <span class=
"comment">/* don't copy beyond len bytes */</span>
01517                     *to++ = *from++;
01518                     <span class="keywordflow">if</span> (--len == 0)
01519                         *(to - 1) = <span class="charliteral">'\0'</span>;       <span class=
"comment">/* null protect the last spot */</span>
01520                 } <span class="keywordflow">else</span>
01521                     from++;
01522             }
01523         }
01524     }
01525     <span class="keywordflow">if</span> (len &gt; 0)
01526         *to = 0;
01527     from = skip_white(from);
01528     <span class="keywordflow">return</span> (from);
01529 }                               <span class="comment">/* copy_word */</span>
01530 
01531 <span class="comment">/*</span>
01532 <span class="comment"> * copy_word</span>
01533 <span class="comment"> * copies the next 'token' from 'from' into 'to'.</span>
01534 <span class="comment"> * currently a token is anything seperate by white space</span>
01535 <span class="comment"> * or within quotes (double or single) (i.e. "the red rose" </span>
01536 <span class="comment"> * is one token, \"the red rose\" is three tokens)</span>
01537 <span class="comment"> * a '\' character will allow a quote character to be treated</span>
01538 <span class="comment"> * as a regular character </span>
01539 <span class="comment"> * It returns a pointer to first non-white space after the end of the token</span>
01540 <span class="comment"> * being copied or to 0 if we reach the end.</span>
01541 <span class="comment"> */</span>
01542 
01543 <span class="keyword">static</span> <span class="keywordtype">int</span>      have_warned = 0;
01544 <span class="keywordtype">char</span>           *
01545 copy_word(<span class="keywordtype">char</span> *from, <span class="keywordtype">char</span> *to)
01546 {
01547     <span class="keywordflow">if</span> (!have_warned) {
01548         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_INFO,
01549                  <span class="stringliteral">"copy_word() called.  Use copy_nword() instead.\n"</span>);
01550         have_warned = 1;
01551     }
01552     <span class="keywordflow">return</span> copy_nword(from, to, SPRINT_MAX_LEN);
01553 }                               <span class="comment">/* copy_word */</span>
01554 
01555 <span class="comment">/*</span>
01556 <span class="comment"> * read_config_save_octet_string(): saves an octet string as a length</span>
01557 <span class="comment"> * followed by a string of hex </span>
01558 <span class="comment"> */</span>
01559 <span class="keywordtype">char</span>           *
01560 read_config_save_octet_string(<span class="keywordtype">char</span> *saveto, u_char * str, size_t len)
01561 {
01562     <span class="keywordtype">int</span>             i;
01563     u_char         *cp;
01564 
01565     <span class="comment">/*</span>
01566 <span class="comment">     * is everything easily printable </span>
01567 <span class="comment">     */</span>
01568     <span class="keywordflow">for</span> (i = 0, cp = str; i &lt; (int) len &amp;&amp; cp &amp;&amp;
01569          (isalpha(*cp) || isdigit(*cp) || *cp == <span class="charliteral">' '</span>); cp++, i++);
01570 
01571     <span class="keywordflow">if</span> (len != 0 &amp;&amp; i == (int) len) {
01572         *saveto++ = <span class="charliteral">'"'</span>;
01573         memcpy(saveto, str, len);
01574         saveto += len;
01575         *saveto++ = <span class="charliteral">'"'</span>;
01576         *saveto = <span class="charliteral">'\0'</span>;
01577     } <span class="keywordflow">else</span> {
01578         <span class="keywordflow">if</span> (str != NULL) {
01579             sprintf(saveto, <span class="stringliteral">"0x"</span>);
01580             saveto += 2;
01581             <span class="keywordflow">for</span> (i = 0; i &lt; (int) len; i++) {
01582                 sprintf(saveto, <span class="stringliteral">"%02x"</span>, str[i]);
01583                 saveto = saveto + 2;
01584             }
01585         } <span class="keywordflow">else</span> {
01586             sprintf(saveto, <span class="stringliteral">"\"\""</span>);
01587             saveto += 2;
01588         }
01589     }
01590     <span class="keywordflow">return</span> saveto;
01591 }
01592 
01593 <span class="comment">/*</span>
01594 <span class="comment"> * read_config_read_octet_string(): reads an octet string that was</span>
01595 <span class="comment"> * saved by the read_config_save_octet_string() function </span>
01596 <span class="comment"> */</span>
01597 <span class="keywordtype">char</span>           *
01598 read_config_read_octet_string(<span class="keywordtype">char</span> *readfrom, u_char ** str, size_t * len)
01599 {
01600     u_char         *cptr = NULL;
01601     <span class="keywordtype">char</span>           *cptr1;
01602     u_int           tmp;
01603     <span class="keywordtype">int</span>             i;
01604     size_t          ilen;
01605 
01606     <span class="keywordflow">if</span> (readfrom == NULL || str == NULL)
01607         <span class="keywordflow">return</span> NULL;
01608 
01609     <span class="keywordflow">if</span> (strncasecmp(readfrom, <span class="stringliteral">"0x"</span>, 2) == 0) {
01610         <span class="comment">/*</span>
01611 <span class="comment">         * A hex string submitted. How long? </span>
01612 <span class="comment">         */</span>
01613         readfrom += 2;
01614         cptr1 = skip_not_white(readfrom);
01615         <span class="keywordflow">if</span> (cptr1)
01616             ilen = (cptr1 - readfrom);
01617         <span class="keywordflow">else</span>
01618             ilen = strlen(readfrom);
01619 
01620         <span class="keywordflow">if</span> (ilen % 2) {
01621             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,<span class=
"stringliteral">"invalid hex string: wrong length\n"</span>);
01622             DEBUGMSGTL((<span class="stringliteral">"read_config_read_octet_string"</span>,
01623                         <span class="stringliteral">"invalid hex string: wrong length"</span>));
01624             <span class="keywordflow">return</span> NULL;
01625         }
01626         ilen = ilen / 2;
01627 
01628         <span class="comment">/*</span>
01629 <span class="comment">         * malloc data space if needed (+1 for good measure) </span>
01630 <span class="comment">         */</span>
01631         <span class="keywordflow">if</span> (*str == NULL) {
01632             <span class="keywordflow">if</span> ((cptr = (u_char *) malloc(ilen + 1)) == NULL) {
01633                 <span class="keywordflow">return</span> NULL;
01634             }
01635             *str = cptr;
01636         } <span class="keywordflow">else</span> {
01637             <span class="comment">/*</span>
01638 <span class="comment">             * don't require caller to have +1 for good measure, and </span>
01639 <span class="comment">             * bail if not enough space.</span>
01640 <span class="comment">             */</span>
01641             <span class="keywordflow">if</span> (ilen &gt; *len) {
01642                 <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_WARNING,<span class=
"stringliteral">"buffer too small to read octet string (%d &lt; %d)\n"</span>,
01643                          *len, ilen);
01644                 DEBUGMSGTL((<span class="stringliteral">"read_config_read_octet_string"</span>,
01645                             <span class="stringliteral">"buffer too small (%d &lt; %d)"</span>, *len, ilen));
01646                 cptr = skip_not_white(readfrom);
01647                 <span class="keywordflow">return</span> skip_white(cptr);
01648             }
01649             cptr = *str;
01650         }
01651         *len = ilen;
01652 
01653         <span class="comment">/*</span>
01654 <span class="comment">         * copy validated data </span>
01655 <span class="comment">         */</span>
01656         <span class="keywordflow">for</span> (i = 0; i &lt; (int) *len; i++) {
01657             <span class="keywordflow">if</span> (1 == sscanf(readfrom, <span class="stringliteral">"%2x"</span>, &amp;tmp))
01658                 *cptr++ = (u_char) tmp;
01659             <span class="keywordflow">else</span> {
01660                 <span class="comment">/*</span>
01661 <span class="comment">                 * we may lose memory, but don't know caller's buffer XX free(cptr); </span>
01662 <span class="comment">                 */</span>
01663                 <span class="keywordflow">return</span> (NULL);
01664             }
01665             readfrom += 2;
01666         }
01667         <span class="comment">/*</span>
01668 <span class="comment">         * only null terminate if we have the space</span>
01669 <span class="comment">         */</span>
01670         <span class="keywordflow">if</span> (ilen &gt; *len) {
01671             ilen = *len-1;
01672             *cptr++ = <span class="charliteral">'\0'</span>;
01673         }
01674         readfrom = skip_white(readfrom);
01675     } <span class="keywordflow">else</span> {
01676         <span class="comment">/*</span>
01677 <span class="comment">         * Normal string </span>
01678 <span class="comment">         */</span>
01679 
01680         <span class="comment">/*</span>
01681 <span class="comment">         * malloc string space if needed (including NULL terminator) </span>
01682 <span class="comment">         */</span>
01683         <span class="keywordflow">if</span> (*str == NULL) {
01684             <span class="keywordtype">char</span>            buf[SNMP_MAXBUF];
01685             readfrom = copy_nword(readfrom, buf, <span class="keyword">sizeof</span>(buf));
01686 
01687             *len = strlen(buf);
01688             <span class="keywordflow">if</span> ((cptr = (u_char *) malloc(*len + 1)) == NULL)
01689                 <span class="keywordflow">return</span> NULL;
01690             *str = cptr;
01691             <span class="keywordflow">if</span> (cptr) {
01692                 memcpy(cptr, buf, *len + 1);
01693             }
01694         } <span class="keywordflow">else</span> {
01695             readfrom = copy_nword(readfrom, (<span class="keywordtype">char</span> *) *str, *len);
01696             *len = strlen(*str);
01697         }
01698     }
01699 
01700     <span class="keywordflow">return</span> readfrom;
01701 }
01702 
01703 
01704 <span class="comment">/*</span>
01705 <span class="comment"> * read_config_save_objid(): saves an objid as a numerical string </span>
01706 <span class="comment"> */</span>
01707 <span class="keywordtype">char</span>           *
01708 read_config_save_objid(<span class="keywordtype">char</span> *saveto, oid * objid, size_t len)
01709 {
01710     <span class="keywordtype">int</span>             i;
01711 
01712     <span class="keywordflow">if</span> (len == 0) {
01713         strcat(saveto, <span class="stringliteral">"NULL"</span>);
01714         saveto += strlen(saveto);
01715         <span class="keywordflow">return</span> saveto;
01716     }
01717 
01718     <span class="comment">/*</span>
01719 <span class="comment">     * in case len=0, this makes it easier to read it back in </span>
01720 <span class="comment">     */</span>
01721     <span class="keywordflow">for</span> (i = 0; i &lt; (int) len; i++) {
01722         sprintf(saveto, <span class="stringliteral">".%ld"</span>, objid[i]);
01723         saveto += strlen(saveto);
01724     }
01725     <span class="keywordflow">return</span> saveto;
01726 }
01727 
01728 <span class="comment">/*</span>
01729 <span class="comment"> * read_config_read_objid(): reads an objid from a format saved by the above </span>
01730 <span class="comment"> */</span>
01731 <span class="keywordtype">char</span>           *
01732 read_config_read_objid(<span class="keywordtype">char</span> *readfrom, oid ** objid, size_t * len)
01733 {
01734 
01735     <span class="keywordflow">if</span> (objid == NULL || readfrom == NULL || len == NULL)
01736         <span class="keywordflow">return</span> NULL;
01737 
01738     <span class="keywordflow">if</span> (*objid == NULL) {
01739         *len = 0;
01740         <span class="keywordflow">if</span> ((*objid = (oid *) malloc(MAX_OID_LEN * <span class=
"keyword">sizeof</span>(oid))) == NULL)
01741             <span class="keywordflow">return</span> NULL;
01742         *len = MAX_OID_LEN;
01743     }
01744 
01745     <span class="keywordflow">if</span> (strncmp(readfrom, <span class="stringliteral">"NULL"</span>, 4) == 0) {
01746         <span class="comment">/*</span>
01747 <span class="comment">         * null length oid </span>
01748 <span class="comment">         */</span>
01749         *len = 0;
01750     } <span class="keywordflow">else</span> {
01751         <span class="comment">/*</span>
01752 <span class="comment">         * qualify the string for read_objid </span>
01753 <span class="comment">         */</span>
01754         <span class="keywordtype">char</span>            buf[SPRINT_MAX_LEN];
01755         copy_nword(readfrom, buf, <span class="keyword">sizeof</span>(buf));
01756 
01757         <span class="keywordflow">if</span> (!<a class="code" href=
"group__mib__utilities.html#ga62">read_objid</a>(buf, *objid, len)) {
01758             DEBUGMSGTL((<span class="stringliteral">"read_config_read_objid"</span>, <span class=
"stringliteral">"Invalid OID"</span>));
01759             *len = 0;
01760             <span class="keywordflow">return</span> NULL;
01761         }
01762     }
01763 
01764     readfrom = skip_token(readfrom);
01765     <span class="keywordflow">return</span> readfrom;
01766 }
01767 
01793 <span class="keywordtype">char</span>           *
<a name="l01794" id="l01794"></a><a class="code" href="group__read__config.html#ga55">01794</a> <a class="code" href=
"group__read__config.html#ga55">read_config_read_data</a>(<span class="keywordtype">int</span> type, <span class=
"keywordtype">char</span> *readfrom, <span class="keywordtype">void</span> *dataptr,
01795                       size_t * len)
01796 {
01797     <span class="keywordtype">int</span>            *intp;
01798     <span class="keywordtype">char</span>          **charpp;
01799     oid           **oidpp;
01800     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   *uintp;
01801 
01802     <span class="keywordflow">if</span> (dataptr &amp;&amp; readfrom)
01803         <span class="keywordflow">switch</span> (type) {
01804         <span class="keywordflow">case</span> ASN_INTEGER:
01805             intp = (<span class="keywordtype">int</span> *) dataptr;
01806             *intp = atoi(readfrom);
01807             readfrom = skip_token(readfrom);
01808             <span class="keywordflow">return</span> readfrom;
01809 
01810         <span class="keywordflow">case</span> ASN_TIMETICKS:
01811         <span class="keywordflow">case</span> ASN_UNSIGNED:
01812             uintp = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *) dataptr;
01813             *uintp = strtoul(readfrom, NULL, 0);
01814             readfrom = skip_token(readfrom);
01815             <span class="keywordflow">return</span> readfrom;
01816 
01817         <span class="keywordflow">case</span> ASN_OCTET_STR:
01818         <span class="keywordflow">case</span> ASN_BIT_STR:
01819             charpp = (<span class="keywordtype">char</span> **) dataptr;
01820             <span class="keywordflow">return</span> read_config_read_octet_string(readfrom,
01821                                                  (u_char **) charpp, len);
01822 
01823         <span class="keywordflow">case</span> ASN_OBJECT_ID:
01824             oidpp = (oid **) dataptr;
01825             <span class="keywordflow">return</span> read_config_read_objid(readfrom, oidpp, len);
01826 
01827         <span class="keywordflow">default</span>:
01828             DEBUGMSGTL((<span class="stringliteral">"read_config_read_data"</span>, <span class=
"stringliteral">"Fail: Unknown type: %d"</span>,
01829                         type));
01830             <span class="keywordflow">return</span> NULL;
01831         }
01832     <span class="keywordflow">return</span> NULL;
01833 }
01834 
01835 <span class="comment">/*</span>
01836 <span class="comment"> * read_config_read_memory():</span>
01837 <span class="comment"> * </span>
01838 <span class="comment"> * similar to read_config_read_data, but expects a generic memory</span>
01839 <span class="comment"> * pointer rather than a specific type of pointer.  Len is expected to</span>
01840 <span class="comment"> * be the amount of available memory.</span>
01841 <span class="comment"> */</span>
01842 <span class="keywordtype">char</span>           *
01843 read_config_read_memory(<span class="keywordtype">int</span> type, <span class="keywordtype">char</span> *readfrom,
01844                         <span class="keywordtype">char</span> *dataptr, size_t * len)
01845 {
01846     <span class="keywordtype">int</span>            *intp;
01847     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   *uintp;
01848     <span class="keywordtype">char</span>            buf[SPRINT_MAX_LEN];
01849 
01850     <span class="keywordflow">if</span> (!dataptr || !readfrom)
01851         <span class="keywordflow">return</span> NULL;
01852 
01853     <span class="keywordflow">switch</span> (type) {
01854     <span class="keywordflow">case</span> ASN_INTEGER:
01855         <span class="keywordflow">if</span> (*len &lt; <span class="keyword">sizeof</span>(int))
01856             <span class="keywordflow">return</span> NULL;
01857         intp = (<span class="keywordtype">int</span> *) dataptr;
01858         readfrom = copy_nword(readfrom, buf, <span class="keyword">sizeof</span>(buf));
01859         *intp = atoi(buf);
01860         *len = <span class="keyword">sizeof</span>(int);
01861         <span class="keywordflow">return</span> readfrom;
01862 
01863     <span class="keywordflow">case</span> ASN_COUNTER:
01864     <span class="keywordflow">case</span> ASN_TIMETICKS:
01865     <span class="keywordflow">case</span> ASN_UNSIGNED:
01866         <span class="keywordflow">if</span> (*len &lt; <span class="keyword">sizeof</span>(<span class=
"keywordtype">unsigned</span> int))
01867             <span class="keywordflow">return</span> NULL;
01868         uintp = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *) dataptr;
01869         readfrom = copy_nword(readfrom, buf, <span class="keyword">sizeof</span>(buf));
01870         *uintp = strtoul(buf, NULL, 0);
01871         *len = <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> int);
01872         <span class="keywordflow">return</span> readfrom;
01873 
01874     <span class="keywordflow">case</span> ASN_OCTET_STR:
01875     <span class="keywordflow">case</span> ASN_BIT_STR:
01876     <span class="keywordflow">case</span> ASN_PRIV_IMPLIED_OCTET_STR:
01877         <span class="keywordflow">return</span> read_config_read_octet_string(readfrom,
01878                                              (u_char **) &amp; dataptr, len);
01879 
01880     <span class="keywordflow">case</span> ASN_PRIV_IMPLIED_OBJECT_ID:
01881     <span class="keywordflow">case</span> ASN_OBJECT_ID:
01882         readfrom =
01883             read_config_read_objid(readfrom, (oid **) &amp; dataptr, len);
01884         *len *= <span class="keyword">sizeof</span>(oid);
01885         <span class="keywordflow">return</span> readfrom;
01886 
01887     <span class="keywordflow">case</span> ASN_COUNTER64:
01888     {
01889         <span class="keywordflow">if</span> (*len &lt; <span class="keyword">sizeof</span>(U64))
01890             <span class="keywordflow">return</span> NULL;
01891         *len = <span class="keyword">sizeof</span>(U64);
01892         read64((U64 *) dataptr, readfrom);
01893         readfrom = skip_token(readfrom);
01894         <span class="keywordflow">return</span> readfrom;
01895     }
01896 
01897     <span class="keywordflow">default</span>:
01898         DEBUGMSGTL((<span class="stringliteral">"read_config_read_memory"</span>, <span class=
"stringliteral">"Fail: Unknown type: %d"</span>,
01899                     type));
01900         <span class="keywordflow">return</span> NULL;
01901     }
01902     <span class="keywordflow">return</span> NULL;
01903 }
01904 
01932 <span class="keywordtype">char</span>           *
<a name="l01933" id="l01933"></a><a class="code" href="group__read__config.html#ga57">01933</a> <a class="code" href=
"group__read__config.html#ga57">read_config_store_data</a>(<span class="keywordtype">int</span> type, <span class=
"keywordtype">char</span> *storeto, <span class="keywordtype">void</span> *dataptr, size_t * len)
01934 {
01935     <span class="keywordflow">return</span> read_config_store_data_prefix(<span class=
"charliteral">' '</span>, type, storeto, dataptr,
01936                                                          (len ? *len : 0));
01937 }
01938 
01939 <span class="keywordtype">char</span>           *
01940 read_config_store_data_prefix(<span class="keywordtype">char</span> prefix, <span class=
"keywordtype">int</span> type, <span class="keywordtype">char</span> *storeto,
01941                               <span class="keywordtype">void</span> *dataptr, size_t len)
01942 {
01943     <span class="keywordtype">int</span>            *intp;
01944     u_char        **charpp;
01945     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   *uintp;
01946     oid           **oidpp;
01947 
01948     <span class="keywordflow">if</span> (dataptr &amp;&amp; storeto)
01949         <span class="keywordflow">switch</span> (type) {
01950         <span class="keywordflow">case</span> ASN_INTEGER:
01951             intp = (<span class="keywordtype">int</span> *) dataptr;
01952             sprintf(storeto, <span class="stringliteral">"%c%d"</span>, prefix, *intp);
01953             <span class="keywordflow">return</span> (storeto + strlen(storeto));
01954 
01955         <span class="keywordflow">case</span> ASN_TIMETICKS:
01956         <span class="keywordflow">case</span> ASN_UNSIGNED:
01957             uintp = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *) dataptr;
01958             sprintf(storeto, <span class="stringliteral">"%c%u"</span>, prefix, *uintp);
01959             <span class="keywordflow">return</span> (storeto + strlen(storeto));
01960 
01961         <span class="keywordflow">case</span> ASN_OCTET_STR:
01962         <span class="keywordflow">case</span> ASN_BIT_STR:
01963             *storeto++ = prefix;
01964             charpp = (u_char **) dataptr;
01965             <span class="keywordflow">return</span> read_config_save_octet_string(storeto, *charpp, len);
01966 
01967         <span class="keywordflow">case</span> ASN_OBJECT_ID:
01968             *storeto++ = prefix;
01969             oidpp = (oid **) dataptr;
01970             <span class="keywordflow">return</span> read_config_save_objid(storeto, *oidpp, len);
01971 
01972         <span class="keywordflow">default</span>:
01973             DEBUGMSGTL((<span class="stringliteral">"read_config_store_data_prefix"</span>,
01974                         <span class="stringliteral">"Fail: Unknown type: %d"</span>, type));
01975             <span class="keywordflow">return</span> NULL;
01976         }
01977     <span class="keywordflow">return</span> NULL;
01978 }
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small>Generated on Fri Dec 30 13:47:46 2005 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

