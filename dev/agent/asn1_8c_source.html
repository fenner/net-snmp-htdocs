<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <div class="navigation" id="top">
    <div class="tabs">
      <ul>
        <li><a href="index.html"><span>Main Page</span></a></li>

        <li><a href="pages.html"><span>Related Pages</span></a></li>

        <li><a href="modules.html"><span>Modules</span></a></li>

        <li><a href="annotated.html"><span>Data Structures</span></a></li>

        <li class="current"><a href="files.html"><span>Files</span></a></li>

        <li><a href="examples.html"><span>Examples</span></a></li>
      </ul>
    </div>

    <div class="tabs">
      <ul>
        <li><a href="files.html"><span>File List</span></a></li>

        <li><a href="globals.html"><span>Globals</span></a></li>
      </ul>
    </div>

    <h1>asn1.c</h1>

    <div class="fragment">
      <pre class="fragment">
<a name="l00001" id="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002" id="l00002"></a>00002 <span class="comment"> * Abstract Syntax Notation One, ASN.1</span>
<a name="l00003" id="l00003"></a>00003 <span class="comment"> * As defined in ISO/IS 8824 and ISO/IS 8825</span>
<a name="l00004" id="l00004"></a>00004 <span class=
"comment"> * This implements a subset of the above International Standards that</span>
<a name="l00005" id="l00005"></a>00005 <span class="comment"> * is sufficient to implement SNMP.</span>
<a name="l00006" id="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007" id="l00007"></a>00007 <span class=
"comment"> * Encodes abstract data types into a machine independent stream of bytes.</span>
<a name="l00008" id="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009" id="l00009"></a>00009 <span class="comment"> */</span>
<a name="l00010" id="l00010"></a>00010 <span class=
"comment">/**********************************************************************</span>
<a name="l00011" id="l00011"></a>00011 <span class=
"comment">        Copyright 1988, 1989, 1991, 1992 by Carnegie Mellon University</span>
<a name="l00012" id="l00012"></a>00012 
<a name="l00013" id="l00013"></a>00013 <span class="comment">                      All Rights Reserved</span>
<a name="l00014" id="l00014"></a>00014 
<a name="l00015" id="l00015"></a>00015 <span class=
"comment">Permission to use, copy, modify, and distribute this software and its </span>
<a name="l00016" id="l00016"></a>00016 <span class=
"comment">documentation for any purpose and without fee is hereby granted, </span>
<a name="l00017" id="l00017"></a>00017 <span class=
"comment">provided that the above copyright notice appear in all copies and that</span>
<a name="l00018" id="l00018"></a>00018 <span class=
"comment">both that copyright notice and this permission notice appear in </span>
<a name="l00019" id="l00019"></a>00019 <span class="comment">supporting documentation, and that the name of CMU not be</span>
<a name="l00020" id="l00020"></a>00020 <span class=
"comment">used in advertising or publicity pertaining to distribution of the</span>
<a name="l00021" id="l00021"></a>00021 <span class="comment">software without specific, written prior permission.  </span>
<a name="l00022" id="l00022"></a>00022 
<a name="l00023" id="l00023"></a>00023 <span class=
"comment">CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING</span>
<a name="l00024" id="l00024"></a>00024 <span class=
"comment">ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL</span>
<a name="l00025" id="l00025"></a>00025 <span class=
"comment">CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR</span>
<a name="l00026" id="l00026"></a>00026 <span class=
"comment">ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</span>
<a name="l00027" id="l00027"></a>00027 <span class=
"comment">WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,</span>
<a name="l00028" id="l00028"></a>00028 <span class=
"comment">ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS</span>
<a name="l00029" id="l00029"></a>00029 <span class="comment">SOFTWARE.</span>
<a name="l00030" id="l00030"></a>00030 <span class=
"comment">******************************************************************/</span>
<a name="l00156" id="l00156"></a>00156 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
<a name="l00157" id="l00157"></a>00157 
<a name="l00158" id="l00158"></a>00158 <span class="preprocessor">#ifdef KINETICS</span>
<a name="l00159" id="l00159"></a>00159 <span class="preprocessor">#include "gw.h"</span>
<a name="l00160" id="l00160"></a>00160 <span class="preprocessor">#endif</span>
<a name="l00161" id="l00161"></a>00161 
<a name="l00162" id="l00162"></a>00162 <span class="preprocessor">#if HAVE_STRING_H</span>
<a name="l00163" id="l00163"></a>00163 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00164" id="l00164"></a>00164 <span class="preprocessor">#else</span>
<a name="l00165" id="l00165"></a>00165 <span class="preprocessor">#include &lt;strings.h&gt;</span>
<a name="l00166" id="l00166"></a>00166 <span class="preprocessor">#endif</span>
<a name="l00167" id="l00167"></a>00167 
<a name="l00168" id="l00168"></a>00168 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00169" id="l00169"></a>00169 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00170" id="l00170"></a>00170 <span class="preprocessor">#ifdef HAVE_STDLIB_H</span>
<a name="l00171" id="l00171"></a>00171 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00172" id="l00172"></a>00172 <span class="preprocessor">#endif</span>
<a name="l00173" id="l00173"></a>00173 <span class="preprocessor">#if HAVE_WINSOCK_H</span>
<a name="l00174" id="l00174"></a>00174 <span class="preprocessor">#include &lt;winsock.h&gt;</span>
<a name="l00175" id="l00175"></a>00175 <span class="preprocessor">#endif</span>
<a name="l00176" id="l00176"></a>00176 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
<a name="l00177" id="l00177"></a>00177 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
<a name="l00178" id="l00178"></a>00178 <span class="preprocessor">#endif</span>
<a name="l00179" id="l00179"></a>00179 
<a name="l00180" id="l00180"></a>00180 <span class="preprocessor">#ifdef vms</span>
<a name="l00181" id="l00181"></a>00181 <span class="preprocessor">#include &lt;in.h&gt;</span>
<a name="l00182" id="l00182"></a>00182 <span class="preprocessor">#endif</span>
<a name="l00183" id="l00183"></a>00183 
<a name="l00184" id="l00184"></a>00184 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
<a name="l00185" id="l00185"></a>00185 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
<a name="l00186" id="l00186"></a>00186 <span class="preprocessor">#endif</span>
<a name="l00187" id="l00187"></a>00187 
<a name="l00188" id="l00188"></a>00188 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
<a name="l00189" id="l00189"></a>00189 <span class="preprocessor">#include &lt;net-snmp/utilities.h&gt;</span>
<a name="l00190" id="l00190"></a>00190 
<a name="l00191" id="l00191"></a>00191 <span class="preprocessor">#include &lt;net-snmp/library/asn1.h&gt;</span>
<a name="l00192" id="l00192"></a>00192 <span class="preprocessor">#include &lt;net-snmp/library/int64.h&gt;</span>
<a name="l00193" id="l00193"></a>00193 <span class="preprocessor">#include &lt;net-snmp/library/mib.h&gt;</span>
<a name="l00194" id="l00194"></a>00194 
<a name="l00195" id="l00195"></a>00195 <span class="preprocessor">#ifndef NULL</span>
<a name="l00196" id="l00196"></a>00196 <span class="preprocessor">#define NULL    0</span>
<a name="l00197" id="l00197"></a>00197 <span class="preprocessor">#endif</span>
<a name="l00198" id="l00198"></a>00198 
<a name="l00199" id="l00199"></a>00199 <span class="preprocessor">#include &lt;net-snmp/library/snmp_api.h&gt;</span>
<a name="l00200" id="l00200"></a>00200 
<a name="l00201" id="l00201"></a>00201 <span class="preprocessor">#ifndef INT32_MAX</span>
<a name="l00202" id="l00202"></a>00202 <span class="preprocessor">#   define INT32_MAX 2147483647</span>
<a name="l00203" id="l00203"></a>00203 <span class="preprocessor">#endif</span>
<a name="l00204" id="l00204"></a>00204 
<a name="l00205" id="l00205"></a>00205 <span class="preprocessor">#ifndef INT32_MIN</span>
<a name="l00206" id="l00206"></a>00206 <span class="preprocessor">#   define INT32_MIN (0 - INT32_MAX - 1)</span>
<a name="l00207" id="l00207"></a>00207 <span class="preprocessor">#endif</span>
<a name="l00208" id="l00208"></a>00208 
<a name="l00209" id="l00209"></a>00209 
<a name="l00210" id="l00210"></a>00210 <span class="preprocessor">#if SIZEOF_LONG == 4</span>
<a name="l00211" id="l00211"></a>00211 <span class="preprocessor">#  define CHECK_OVERFLOW_S(x,y)</span>
<a name="l00212" id="l00212"></a>00212 <span class="preprocessor">#  define CHECK_OVERFLOW_U(x,y)</span>
<a name="l00213" id="l00213"></a>00213 <span class="preprocessor">#else</span>
<a name="l00214" id="l00214"></a>00214 <span class=
"preprocessor">#  define CHECK_OVERFLOW_S(x,y) do { int trunc = 0;                     \</span>
<a name="l00215" id="l00215"></a>00215 <span class=
"preprocessor">        if (x &gt; INT32_MAX) {                                            \</span>
<a name="l00216" id="l00216"></a>00216 <span class=
"preprocessor">            trunc = 1;                                                  \</span>
<a name="l00217" id="l00217"></a>00217 <span class=
"preprocessor">            x &amp;= 0xffffffff;                                            \</span>
<a name="l00218" id="l00218"></a>00218 <span class=
"preprocessor">        } else if (x &lt; INT32_MIN) {                                     \</span>
<a name="l00219" id="l00219"></a>00219 <span class=
"preprocessor">            trunc = 1;                                                  \</span>
<a name="l00220" id="l00220"></a>00220 <span class=
"preprocessor">            x = 0 - (x &amp; 0xffffffff);                                   \</span>
<a name="l00221" id="l00221"></a>00221 <span class=
"preprocessor">        }                                                               \</span>
<a name="l00222" id="l00222"></a>00222 <span class=
"preprocessor">        if (trunc)                                                      \</span>
<a name="l00223" id="l00223"></a>00223 <span class=
"preprocessor">            DEBUGMSG(("asn","truncating signed value to 32 bits (%d)\n",y)); \</span>
<a name="l00224" id="l00224"></a>00224 <span class="preprocessor">    } while(0)</span>
<a name="l00225" id="l00225"></a>00225 
<a name="l00226" id="l00226"></a>00226 <span class=
"preprocessor">#  define CHECK_OVERFLOW_U(x,y) do {                                    \</span>
<a name="l00227" id="l00227"></a>00227 <span class=
"preprocessor">        if (x &gt; UINT32_MAX) {                                           \</span>
<a name="l00228" id="l00228"></a>00228 <span class=
"preprocessor">            x &amp;= 0xffffffff;                                            \</span>
<a name="l00229" id="l00229"></a>00229 <span class=
"preprocessor">            DEBUGMSG(("asn","truncating unsigned value to 32 bits (%d)\n",y)); \</span>
<a name="l00230" id="l00230"></a>00230 <span class=
"preprocessor">        }                                                               \</span>
<a name="l00231" id="l00231"></a>00231 <span class="preprocessor">    } while(0)</span>
<a name="l00232" id="l00232"></a>00232 <span class="preprocessor">#endif</span>
<a name="l00233" id="l00233"></a>00233 
<a name="l00242" id="l00242"></a>00242 <span class="keyword">static</span>
<a name="l00243" id="l00243"></a>00243     <span class="keywordtype">void</span>
<a name="l00244" id="l00244"></a>00244 _asn_size_err(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *str, <span class="keywordtype">size_t</span> wrongsize, <span class=
"keywordtype">size_t</span> rightsize)
<a name="l00245" id="l00245"></a>00245 {
<a name="l00246" id="l00246"></a>00246     <span class="keywordtype">char</span>            ebuf[128];
<a name="l00247" id="l00247"></a>00247 
<a name="l00248" id="l00248"></a>00248     snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l00249" id="l00249"></a>00249             <span class="stringliteral">"%s size %lu: s/b %lu"</span>, str,
<a name="l00250" id="l00250"></a>00250             (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)wrongsize, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rightsize);
<a name="l00251" id="l00251"></a>00251     ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l00252" id="l00252"></a>00252     ERROR_MSG(ebuf);
<a name="l00253" id="l00253"></a>00253 }
<a name="l00254" id="l00254"></a>00254 
<a name="l00263" id="l00263"></a>00263 <span class="keyword">static</span>
<a name="l00264" id="l00264"></a>00264     <span class="keywordtype">void</span>
<a name="l00265" id="l00265"></a>00265 _asn_length_err(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *str, <span class="keywordtype">size_t</span> wrongsize, <span class=
"keywordtype">size_t</span> rightsize)
<a name="l00266" id="l00266"></a>00266 {
<a name="l00267" id="l00267"></a>00267     <span class="keywordtype">char</span>            ebuf[128];
<a name="l00268" id="l00268"></a>00268 
<a name="l00269" id="l00269"></a>00269     snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l00270" id="l00270"></a>00270             <span class=
"stringliteral">"%s length %lu too large: exceeds %lu"</span>, str,
<a name="l00271" id="l00271"></a>00271             (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)wrongsize, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)rightsize);
<a name="l00272" id="l00272"></a>00272     ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l00273" id="l00273"></a>00273     ERROR_MSG(ebuf);
<a name="l00274" id="l00274"></a>00274 }
<a name="l00275" id="l00275"></a>00275 
<a name="l00288" id="l00288"></a>00288 <span class="keyword">static</span>
<a name="l00289" id="l00289"></a>00289     <span class="keywordtype">int</span>
<a name="l00290" id="l00290"></a>00290 _asn_parse_length_check(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *str,
<a name="l00291" id="l00291"></a>00291                         <span class="keyword">const</span> u_char * bufp, <span class=
"keyword">const</span> u_char * data,
<a name="l00292" id="l00292"></a>00292                         u_long plen, <span class="keywordtype">size_t</span> dlen)
<a name="l00293" id="l00293"></a>00293 {
<a name="l00294" id="l00294"></a>00294     <span class="keywordtype">char</span>            ebuf[128];
<a name="l00295" id="l00295"></a>00295     <span class="keywordtype">size_t</span>          header_len;
<a name="l00296" id="l00296"></a>00296 
<a name="l00297" id="l00297"></a>00297     <span class="keywordflow">if</span> (bufp == NULL) {
<a name="l00298" id="l00298"></a>00298         <span class="comment">/*</span>
<a name="l00299" id="l00299"></a>00299 <span class="comment">         * error message is set </span>
<a name="l00300" id="l00300"></a>00300 <span class="comment">         */</span>
<a name="l00301" id="l00301"></a>00301         <span class="keywordflow">return</span> 1;
<a name="l00302" id="l00302"></a>00302     }
<a name="l00303" id="l00303"></a>00303     header_len = bufp - data;
<a name="l00304" id="l00304"></a>00304     <span class=
"keywordflow">if</span> (plen &gt; 0x7fffffff || header_len &gt; 0x7fffffff ||
<a name="l00305" id="l00305"></a>00305         ((<span class="keywordtype">size_t</span>) plen + header_len) &gt; dlen) {
<a name="l00306" id="l00306"></a>00306         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l00307" id="l00307"></a>00307                 <span class=
"stringliteral">"%s: message overflow: %d len + %d delta &gt; %d len"</span>,
<a name="l00308" id="l00308"></a>00308                 str, (<span class="keywordtype">int</span>) plen, (<span class=
"keywordtype">int</span>) header_len, (<span class="keywordtype">int</span>) dlen);
<a name="l00309" id="l00309"></a>00309         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l00310" id="l00310"></a>00310         ERROR_MSG(ebuf);
<a name="l00311" id="l00311"></a>00311         <span class="keywordflow">return</span> 1;
<a name="l00312" id="l00312"></a>00312     }
<a name="l00313" id="l00313"></a>00313     <span class="keywordflow">return</span> 0;
<a name="l00314" id="l00314"></a>00314 }
<a name="l00315" id="l00315"></a>00315 
<a name="l00316" id="l00316"></a>00316 
<a name="l00328" id="l00328"></a>00328 <span class="keyword">static</span>
<a name="l00329" id="l00329"></a>00329     <span class="keywordtype">int</span>
<a name="l00330" id="l00330"></a>00330 _asn_build_header_check(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *str, <span class="keyword">const</span> u_char * data,
<a name="l00331" id="l00331"></a>00331                         <span class="keywordtype">size_t</span> datalen, <span class=
"keywordtype">size_t</span> typedlen)
<a name="l00332" id="l00332"></a>00332 {
<a name="l00333" id="l00333"></a>00333     <span class="keywordtype">char</span>            ebuf[128];
<a name="l00334" id="l00334"></a>00334 
<a name="l00335" id="l00335"></a>00335     <span class="keywordflow">if</span> (data == NULL) {
<a name="l00336" id="l00336"></a>00336         <span class="comment">/*</span>
<a name="l00337" id="l00337"></a>00337 <span class="comment">         * error message is set </span>
<a name="l00338" id="l00338"></a>00338 <span class="comment">         */</span>
<a name="l00339" id="l00339"></a>00339         <span class="keywordflow">return</span> 1;
<a name="l00340" id="l00340"></a>00340     }
<a name="l00341" id="l00341"></a>00341     <span class="keywordflow">if</span> (datalen &lt; typedlen) {
<a name="l00342" id="l00342"></a>00342         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l00343" id="l00343"></a>00343                 <span class=
"stringliteral">"%s: bad header, length too short: %lu &lt; %lu"</span>, str,
<a name="l00344" id="l00344"></a>00344                 (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)datalen, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)typedlen);
<a name="l00345" id="l00345"></a>00345         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l00346" id="l00346"></a>00346         ERROR_MSG(ebuf);
<a name="l00347" id="l00347"></a>00347         <span class="keywordflow">return</span> 1;
<a name="l00348" id="l00348"></a>00348     }
<a name="l00349" id="l00349"></a>00349     <span class="keywordflow">return</span> 0;
<a name="l00350" id="l00350"></a>00350 }
<a name="l00351" id="l00351"></a>00351 
<a name="l00363" id="l00363"></a>00363 <span class="keyword">static</span>
<a name="l00364" id="l00364"></a>00364     <span class="keywordtype">int</span>
<a name="l00365" id="l00365"></a>00365 _asn_realloc_build_header_check(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *str,
<a name="l00366" id="l00366"></a>00366                                 u_char ** pkt,
<a name="l00367" id="l00367"></a>00367                                 <span class="keyword">const</span> <span class=
"keywordtype">size_t</span> * pkt_len, <span class="keywordtype">size_t</span> typedlen)
<a name="l00368" id="l00368"></a>00368 {
<a name="l00369" id="l00369"></a>00369     <span class="keywordtype">char</span>            ebuf[128];
<a name="l00370" id="l00370"></a>00370 
<a name="l00371" id="l00371"></a>00371     <span class="keywordflow">if</span> (pkt == NULL || *pkt == NULL) {
<a name="l00372" id="l00372"></a>00372         <span class="comment">/*</span>
<a name="l00373" id="l00373"></a>00373 <span class="comment">         * Error message is set.  </span>
<a name="l00374" id="l00374"></a>00374 <span class="comment">         */</span>
<a name="l00375" id="l00375"></a>00375         <span class="keywordflow">return</span> 1;
<a name="l00376" id="l00376"></a>00376     }
<a name="l00377" id="l00377"></a>00377 
<a name="l00378" id="l00378"></a>00378     <span class="keywordflow">if</span> (*pkt_len &lt; typedlen) {
<a name="l00379" id="l00379"></a>00379         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l00380" id="l00380"></a>00380                 <span class=
"stringliteral">"%s: bad header, length too short: %lu &lt; %lu"</span>, str,
<a name="l00381" id="l00381"></a>00381                 (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)*pkt_len, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)typedlen);
<a name="l00382" id="l00382"></a>00382         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l00383" id="l00383"></a>00383         ERROR_MSG(ebuf);
<a name="l00384" id="l00384"></a>00384         <span class="keywordflow">return</span> 1;
<a name="l00385" id="l00385"></a>00385     }
<a name="l00386" id="l00386"></a>00386     <span class="keywordflow">return</span> 0;
<a name="l00387" id="l00387"></a>00387 }
<a name="l00388" id="l00388"></a>00388 
<a name="l00398" id="l00398"></a>00398 <span class="keywordtype">int</span>
<a name="l00399" id="l00399"></a>00399 asn_check_packet(u_char * pkt, <span class="keywordtype">size_t</span> len)
<a name="l00400" id="l00400"></a>00400 {
<a name="l00401" id="l00401"></a>00401     u_long          asn_length;
<a name="l00402" id="l00402"></a>00402 
<a name="l00403" id="l00403"></a>00403     <span class="keywordflow">if</span> (len &lt; 2)
<a name="l00404" id="l00404"></a>00404         <span class="keywordflow">return</span> 0;               <span class=
"comment">/* always too short */</span>
<a name="l00405" id="l00405"></a>00405 
<a name="l00406" id="l00406"></a>00406     <span class=
"keywordflow">if</span> (*pkt != (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR))
<a name="l00407" id="l00407"></a>00407         <span class="keywordflow">return</span> -1;              <span class=
"comment">/* wrong type */</span>
<a name="l00408" id="l00408"></a>00408 
<a name="l00409" id="l00409"></a>00409     <span class="keywordflow">if</span> (*(pkt + 1) &amp; 0x80) {
<a name="l00410" id="l00410"></a>00410         <span class="comment">/*</span>
<a name="l00411" id="l00411"></a>00411 <span class="comment">         * long length </span>
<a name="l00412" id="l00412"></a>00412 <span class="comment">         */</span>
<a name="l00413" id="l00413"></a>00413         <span class="keywordflow">if</span> ((<span class=
"keywordtype">int</span>) len &lt; (<span class="keywordtype">int</span>) (*(pkt + 1) &amp; ~0x80) + 2)
<a name="l00414" id="l00414"></a>00414             <span class="keywordflow">return</span> 0;           <span class=
"comment">/* still to short, incomplete length */</span>
<a name="l00415" id="l00415"></a>00415         asn_parse_length(pkt + 1, &amp;asn_length);
<a name="l00416" id="l00416"></a>00416         <span class=
"keywordflow">return</span> (asn_length + 2 + (*(pkt + 1) &amp; ~0x80));
<a name="l00417" id="l00417"></a>00417     } <span class="keywordflow">else</span> {
<a name="l00418" id="l00418"></a>00418         <span class="comment">/*</span>
<a name="l00419" id="l00419"></a>00419 <span class="comment">         * short length </span>
<a name="l00420" id="l00420"></a>00420 <span class="comment">         */</span>
<a name="l00421" id="l00421"></a>00421         <span class="keywordflow">return</span> (*(pkt + 1) + 2);
<a name="l00422" id="l00422"></a>00422     }
<a name="l00423" id="l00423"></a>00423 }
<a name="l00424" id="l00424"></a>00424 
<a name="l00425" id="l00425"></a>00425 <span class="keyword">static</span>
<a name="l00426" id="l00426"></a>00426     <span class="keywordtype">int</span>
<a name="l00427" id="l00427"></a>00427 _asn_bitstring_check(<span class="keyword">const</span> <span class=
"keywordtype">char</span> *str, <span class="keywordtype">size_t</span> asn_length, u_char datum)
<a name="l00428" id="l00428"></a>00428 {
<a name="l00429" id="l00429"></a>00429     <span class="keywordtype">char</span>            ebuf[128];
<a name="l00430" id="l00430"></a>00430 
<a name="l00431" id="l00431"></a>00431     <span class="keywordflow">if</span> (asn_length &lt; 1) {
<a name="l00432" id="l00432"></a>00432         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l00433" id="l00433"></a>00433                 <span class=
"stringliteral">"%s: length %d too small"</span>, str, (<span class="keywordtype">int</span>) asn_length);
<a name="l00434" id="l00434"></a>00434         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l00435" id="l00435"></a>00435         ERROR_MSG(ebuf);
<a name="l00436" id="l00436"></a>00436         <span class="keywordflow">return</span> 1;
<a name="l00437" id="l00437"></a>00437     }
<a name="l00438" id="l00438"></a>00438     <span class="comment">/*</span>
<a name="l00439" id="l00439"></a>00439 <span class="comment">     * if (datum &gt; 7){</span>
<a name="l00440" id="l00440"></a>00440 <span class=
"comment">     * sprintf(ebuf,"%s: datum %d &gt;7: too large", str, (int)(datum));</span>
<a name="l00441" id="l00441"></a>00441 <span class="comment">     * ERROR_MSG(ebuf);</span>
<a name="l00442" id="l00442"></a>00442 <span class="comment">     * return 1;</span>
<a name="l00443" id="l00443"></a>00443 <span class="comment">     * }</span>
<a name="l00444" id="l00444"></a>00444 <span class="comment">     */</span>
<a name="l00445" id="l00445"></a>00445     <span class="keywordflow">return</span> 0;
<a name="l00446" id="l00446"></a>00446 }
<a name="l00447" id="l00447"></a>00447 
<a name="l00469" id="l00469"></a>00469 u_char         *
<a name="l00470" id="l00470"></a>00470 asn_parse_int(u_char * data,
<a name="l00471" id="l00471"></a>00471               <span class="keywordtype">size_t</span> * datalength,
<a name="l00472" id="l00472"></a>00472               u_char * type, <span class="keywordtype">long</span> *intp, <span class=
"keywordtype">size_t</span> intsize)
<a name="l00473" id="l00473"></a>00473 {
<a name="l00474" id="l00474"></a>00474     <span class="comment">/*</span>
<a name="l00475" id="l00475"></a>00475 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
<a name="l00476" id="l00476"></a>00476 <span class="comment">     */</span>
<a name="l00477" id="l00477"></a>00477     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse int"</span>;
<a name="l00478" id="l00478"></a>00478     <span class="keyword">register</span> u_char *bufp = data;
<a name="l00479" id="l00479"></a>00479     u_long          asn_length;
<a name="l00480" id="l00480"></a>00480     <span class="keyword">register</span> <span class=
"keywordtype">long</span>   value = 0;
<a name="l00481" id="l00481"></a>00481 
<a name="l00482" id="l00482"></a>00482     <span class="keywordflow">if</span> (intsize != <span class=
"keyword">sizeof</span>(<span class="keywordtype">long</span>)) {
<a name="l00483" id="l00483"></a>00483         _asn_size_err(errpre, intsize, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
<a name="l00484" id="l00484"></a>00484         <span class="keywordflow">return</span> NULL;
<a name="l00485" id="l00485"></a>00485     }
<a name="l00486" id="l00486"></a>00486     *type = *bufp++;
<a name="l00487" id="l00487"></a>00487     bufp = asn_parse_length(bufp, &amp;asn_length);
<a name="l00488" id="l00488"></a>00488     <span class="keywordflow">if</span> (_asn_parse_length_check
<a name="l00489" id="l00489"></a>00489         (errpre, bufp, data, asn_length, *datalength))
<a name="l00490" id="l00490"></a>00490         <span class="keywordflow">return</span> NULL;
<a name="l00491" id="l00491"></a>00491 
<a name="l00492" id="l00492"></a>00492     <span class="keywordflow">if</span> ((<span class=
"keywordtype">size_t</span>) asn_length &gt; intsize) {
<a name="l00493" id="l00493"></a>00493         _asn_length_err(errpre, (<span class=
"keywordtype">size_t</span>) asn_length, intsize);
<a name="l00494" id="l00494"></a>00494         <span class="keywordflow">return</span> NULL;
<a name="l00495" id="l00495"></a>00495     }
<a name="l00496" id="l00496"></a>00496 
<a name="l00497" id="l00497"></a>00497     *datalength -= (int) asn_length + (bufp - data);
<a name="l00498" id="l00498"></a>00498     <span class="keywordflow">if</span> (*bufp &amp; 0x80)
<a name="l00499" id="l00499"></a>00499         value = -1;             <span class="comment">/* integer is negative */</span>
<a name="l00500" id="l00500"></a>00500 
<a name="l00501" id="l00501"></a>00501     DEBUGDUMPSETUP(<span class=
"stringliteral">"recv"</span>, data, bufp - data + asn_length);
<a name="l00502" id="l00502"></a>00502 
<a name="l00503" id="l00503"></a>00503     <span class="keywordflow">while</span> (asn_length--)
<a name="l00504" id="l00504"></a>00504         value = (value &lt;&lt; 8) | *bufp++;
<a name="l00505" id="l00505"></a>00505 
<a name="l00506" id="l00506"></a>00506     CHECK_OVERFLOW_S(value,1);
<a name="l00507" id="l00507"></a>00507 
<a name="l00508" id="l00508"></a>00508     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  Integer:\t%ld (0x%.2lX)\n"</span>, value, value));
<a name="l00509" id="l00509"></a>00509 
<a name="l00510" id="l00510"></a>00510     *intp = value;
<a name="l00511" id="l00511"></a>00511     <span class="keywordflow">return</span> bufp;
<a name="l00512" id="l00512"></a>00512 }
<a name="l00513" id="l00513"></a>00513 
<a name="l00514" id="l00514"></a>00514 
<a name="l00536" id="l00536"></a>00536 u_char         *
<a name="l00537" id="l00537"></a>00537 asn_parse_unsigned_int(u_char * data,
<a name="l00538" id="l00538"></a>00538                        <span class="keywordtype">size_t</span> * datalength,
<a name="l00539" id="l00539"></a>00539                        u_char * type, u_long * intp, <span class=
"keywordtype">size_t</span> intsize)
<a name="l00540" id="l00540"></a>00540 {
<a name="l00541" id="l00541"></a>00541     <span class="comment">/*</span>
<a name="l00542" id="l00542"></a>00542 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
<a name="l00543" id="l00543"></a>00543 <span class="comment">     */</span>
<a name="l00544" id="l00544"></a>00544     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse uint"</span>;
<a name="l00545" id="l00545"></a>00545     <span class="keyword">register</span> u_char *bufp = data;
<a name="l00546" id="l00546"></a>00546     u_long          asn_length;
<a name="l00547" id="l00547"></a>00547     <span class="keyword">register</span> u_long value = 0;
<a name="l00548" id="l00548"></a>00548 
<a name="l00549" id="l00549"></a>00549     <span class="keywordflow">if</span> (intsize != <span class=
"keyword">sizeof</span>(<span class="keywordtype">long</span>)) {
<a name="l00550" id="l00550"></a>00550         _asn_size_err(errpre, intsize, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
<a name="l00551" id="l00551"></a>00551         <span class="keywordflow">return</span> NULL;
<a name="l00552" id="l00552"></a>00552     }
<a name="l00553" id="l00553"></a>00553     *type = *bufp++;
<a name="l00554" id="l00554"></a>00554     bufp = asn_parse_length(bufp, &amp;asn_length);
<a name="l00555" id="l00555"></a>00555     <span class="keywordflow">if</span> (_asn_parse_length_check
<a name="l00556" id="l00556"></a>00556         (errpre, bufp, data, asn_length, *datalength))
<a name="l00557" id="l00557"></a>00557         <span class="keywordflow">return</span> NULL;
<a name="l00558" id="l00558"></a>00558 
<a name="l00559" id="l00559"></a>00559     <span class="keywordflow">if</span> (((<span class=
"keywordtype">int</span>) asn_length &gt; (intsize + 1)) ||
<a name="l00560" id="l00560"></a>00560         (((<span class=
"keywordtype">int</span>) asn_length == intsize + 1) &amp;&amp; *bufp != 0x00)) {
<a name="l00561" id="l00561"></a>00561         _asn_length_err(errpre, (<span class=
"keywordtype">size_t</span>) asn_length, intsize);
<a name="l00562" id="l00562"></a>00562         <span class="keywordflow">return</span> NULL;
<a name="l00563" id="l00563"></a>00563     }
<a name="l00564" id="l00564"></a>00564     *datalength -= (int) asn_length + (bufp - data);
<a name="l00565" id="l00565"></a>00565     <span class="keywordflow">if</span> (*bufp &amp; 0x80)
<a name="l00566" id="l00566"></a>00566         value = ~value;         <span class="comment">/* integer is negative */</span>
<a name="l00567" id="l00567"></a>00567 
<a name="l00568" id="l00568"></a>00568     DEBUGDUMPSETUP(<span class=
"stringliteral">"recv"</span>, data, bufp - data + asn_length);
<a name="l00569" id="l00569"></a>00569 
<a name="l00570" id="l00570"></a>00570     <span class="keywordflow">while</span> (asn_length--)
<a name="l00571" id="l00571"></a>00571         value = (value &lt;&lt; 8) | *bufp++;
<a name="l00572" id="l00572"></a>00572 
<a name="l00573" id="l00573"></a>00573     CHECK_OVERFLOW_U(value,2);
<a name="l00574" id="l00574"></a>00574 
<a name="l00575" id="l00575"></a>00575     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  UInteger:\t%ld (0x%.2lX)\n"</span>, value, value));
<a name="l00576" id="l00576"></a>00576 
<a name="l00577" id="l00577"></a>00577     *intp = value;
<a name="l00578" id="l00578"></a>00578     <span class="keywordflow">return</span> bufp;
<a name="l00579" id="l00579"></a>00579 }
<a name="l00580" id="l00580"></a>00580 
<a name="l00581" id="l00581"></a>00581 
<a name="l00605" id="l00605"></a>00605 u_char         *
<a name="l00606" id="l00606"></a>00606 asn_build_int(u_char * data,
<a name="l00607" id="l00607"></a>00607            <span class="keywordtype">size_t</span> * datalength, u_char type, <span class=
"keyword">const</span> <span class="keywordtype">long</span> *intp, <span class="keywordtype">size_t</span> intsize)
<a name="l00608" id="l00608"></a>00608 {
<a name="l00609" id="l00609"></a>00609     <span class="comment">/*</span>
<a name="l00610" id="l00610"></a>00610 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
<a name="l00611" id="l00611"></a>00611 <span class="comment">     */</span>
<a name="l00612" id="l00612"></a>00612     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build int"</span>;
<a name="l00613" id="l00613"></a>00613     <span class="keyword">register</span> <span class="keywordtype">long</span>   integer;
<a name="l00614" id="l00614"></a>00614     <span class="keyword">register</span> u_long mask;
<a name="l00615" id="l00615"></a>00615 <span class="preprocessor">#ifndef NETSNMP_NO_DEBUGGING</span>
<a name="l00616" id="l00616"></a>00616     u_char         *initdatap = data;
<a name="l00617" id="l00617"></a>00617 <span class="preprocessor">#endif</span>
<a name="l00618" id="l00618"></a>00618 
<a name="l00619" id="l00619"></a>00619     <span class="keywordflow">if</span> (intsize != <span class=
"keyword">sizeof</span>(<span class="keywordtype">long</span>)) {
<a name="l00620" id="l00620"></a>00620         _asn_size_err(errpre, intsize, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
<a name="l00621" id="l00621"></a>00621         <span class="keywordflow">return</span> NULL;
<a name="l00622" id="l00622"></a>00622     }
<a name="l00623" id="l00623"></a>00623     integer = *intp;
<a name="l00624" id="l00624"></a>00624     CHECK_OVERFLOW_S(integer,3);
<a name="l00625" id="l00625"></a>00625     <span class="comment">/*</span>
<a name="l00626" id="l00626"></a>00626 <span class=
"comment">     * Truncate "unnecessary" bytes off of the most significant end of this</span>
<a name="l00627" id="l00627"></a>00627 <span class=
"comment">     * 2's complement integer.  There should be no sequence of 9</span>
<a name="l00628" id="l00628"></a>00628 <span class=
"comment">     * consecutive 1's or 0's at the most significant end of the</span>
<a name="l00629" id="l00629"></a>00629 <span class="comment">     * integer.</span>
<a name="l00630" id="l00630"></a>00630 <span class="comment">     */</span>
<a name="l00631" id="l00631"></a>00631     mask = ((u_long) 0x1FF) &lt;&lt; ((8 * (<span class=
"keyword">sizeof</span>(long) - 1)) - 1);
<a name="l00632" id="l00632"></a>00632     <span class="comment">/*</span>
<a name="l00633" id="l00633"></a>00633 <span class="comment">     * mask is 0xFF800000 on a big-endian machine </span>
<a name="l00634" id="l00634"></a>00634 <span class="comment">     */</span>
<a name="l00635" id="l00635"></a>00635     <span class=
"keywordflow">while</span> ((((integer &amp; mask) == 0) || ((integer &amp; mask) == mask))
<a name="l00636" id="l00636"></a>00636            &amp;&amp; intsize &gt; 1) {
<a name="l00637" id="l00637"></a>00637         intsize--;
<a name="l00638" id="l00638"></a>00638         integer &lt;&lt;= 8;
<a name="l00639" id="l00639"></a>00639     }
<a name="l00640" id="l00640"></a>00640     data = asn_build_header(data, datalength, type, intsize);
<a name="l00641" id="l00641"></a>00641     <span class=
"keywordflow">if</span> (_asn_build_header_check(errpre, data, *datalength, intsize))
<a name="l00642" id="l00642"></a>00642         <span class="keywordflow">return</span> NULL;
<a name="l00643" id="l00643"></a>00643 
<a name="l00644" id="l00644"></a>00644     *datalength -= intsize;
<a name="l00645" id="l00645"></a>00645     mask = ((u_long) 0xFF) &lt;&lt; (8 * (<span class="keyword">sizeof</span>(long) - 1));
<a name="l00646" id="l00646"></a>00646     <span class="comment">/*</span>
<a name="l00647" id="l00647"></a>00647 <span class="comment">     * mask is 0xFF000000 on a big-endian machine </span>
<a name="l00648" id="l00648"></a>00648 <span class="comment">     */</span>
<a name="l00649" id="l00649"></a>00649     <span class="keywordflow">while</span> (intsize--) {
<a name="l00650" id="l00650"></a>00650         *data++ = (u_char) ((integer &amp; mask) &gt;&gt; (8 * (<span class=
"keyword">sizeof</span>(long) - 1)));
<a name="l00651" id="l00651"></a>00651         integer &lt;&lt;= 8;
<a name="l00652" id="l00652"></a>00652     }
<a name="l00653" id="l00653"></a>00653     DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, initdatap, data - initdatap);
<a name="l00654" id="l00654"></a>00654     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  Integer:\t%ld (0x%.2lX)\n"</span>, *intp, *intp));
<a name="l00655" id="l00655"></a>00655     <span class="keywordflow">return</span> data;
<a name="l00656" id="l00656"></a>00656 }
<a name="l00657" id="l00657"></a>00657 
<a name="l00658" id="l00658"></a>00658 
<a name="l00659" id="l00659"></a>00659 
<a name="l00683" id="l00683"></a>00683 u_char         *
<a name="l00684" id="l00684"></a>00684 asn_build_unsigned_int(u_char * data,
<a name="l00685" id="l00685"></a>00685                        <span class="keywordtype">size_t</span> * datalength,
<a name="l00686" id="l00686"></a>00686                        u_char type, <span class=
"keyword">const</span> u_long * intp, <span class="keywordtype">size_t</span> intsize)
<a name="l00687" id="l00687"></a>00687 {
<a name="l00688" id="l00688"></a>00688     <span class="comment">/*</span>
<a name="l00689" id="l00689"></a>00689 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
<a name="l00690" id="l00690"></a>00690 <span class="comment">     */</span>
<a name="l00691" id="l00691"></a>00691     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build uint"</span>;
<a name="l00692" id="l00692"></a>00692     <span class="keyword">register</span> u_long integer;
<a name="l00693" id="l00693"></a>00693     <span class="keyword">register</span> u_long mask;
<a name="l00694" id="l00694"></a>00694     <span class="keywordtype">int</span>             add_null_byte = 0;
<a name="l00695" id="l00695"></a>00695 <span class="preprocessor">#ifndef NETSNMP_NO_DEBUGGING</span>
<a name="l00696" id="l00696"></a>00696     u_char         *initdatap = data;
<a name="l00697" id="l00697"></a>00697 <span class="preprocessor">#endif</span>
<a name="l00698" id="l00698"></a>00698 
<a name="l00699" id="l00699"></a>00699     <span class="keywordflow">if</span> (intsize != <span class=
"keyword">sizeof</span>(<span class="keywordtype">long</span>)) {
<a name="l00700" id="l00700"></a>00700         _asn_size_err(errpre, intsize, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
<a name="l00701" id="l00701"></a>00701         <span class="keywordflow">return</span> NULL;
<a name="l00702" id="l00702"></a>00702     }
<a name="l00703" id="l00703"></a>00703     integer = *intp;
<a name="l00704" id="l00704"></a>00704     CHECK_OVERFLOW_U(integer,4);
<a name="l00705" id="l00705"></a>00705 
<a name="l00706" id="l00706"></a>00706     mask = ((u_long) 0xFF) &lt;&lt; (8 * (<span class="keyword">sizeof</span>(long) - 1));
<a name="l00707" id="l00707"></a>00707     <span class="comment">/*</span>
<a name="l00708" id="l00708"></a>00708 <span class="comment">     * mask is 0xFF000000 on a big-endian machine </span>
<a name="l00709" id="l00709"></a>00709 <span class="comment">     */</span>
<a name="l00710" id="l00710"></a>00710     <span class=
"keywordflow">if</span> ((u_char) ((integer &amp; mask) &gt;&gt; (8 * (<span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>) - 1))) &amp; 0x80) {
<a name="l00711" id="l00711"></a>00711         <span class="comment">/*</span>
<a name="l00712" id="l00712"></a>00712 <span class="comment">         * if MSB is set </span>
<a name="l00713" id="l00713"></a>00713 <span class="comment">         */</span>
<a name="l00714" id="l00714"></a>00714         add_null_byte = 1;
<a name="l00715" id="l00715"></a>00715         intsize++;
<a name="l00716" id="l00716"></a>00716     } <span class="keywordflow">else</span> {
<a name="l00717" id="l00717"></a>00717         <span class="comment">/*</span>
<a name="l00718" id="l00718"></a>00718 <span class=
"comment">         * Truncate "unnecessary" bytes off of the most significant end of this 2's complement integer.</span>
<a name="l00719" id="l00719"></a>00719 <span class=
"comment">         * There should be no sequence of 9 consecutive 1's or 0's at the most significant end of the</span>
<a name="l00720" id="l00720"></a>00720 <span class="comment">         * integer.</span>
<a name="l00721" id="l00721"></a>00721 <span class="comment">         */</span>
<a name="l00722" id="l00722"></a>00722         mask = ((u_long) 0x1FF) &lt;&lt; ((8 * (<span class=
"keyword">sizeof</span>(long) - 1)) - 1);
<a name="l00723" id="l00723"></a>00723         <span class="comment">/*</span>
<a name="l00724" id="l00724"></a>00724 <span class="comment">         * mask is 0xFF800000 on a big-endian machine </span>
<a name="l00725" id="l00725"></a>00725 <span class="comment">         */</span>
<a name="l00726" id="l00726"></a>00726         <span class=
"keywordflow">while</span> ((((integer &amp; mask) == 0) || ((integer &amp; mask) == mask))
<a name="l00727" id="l00727"></a>00727                &amp;&amp; intsize &gt; 1) {
<a name="l00728" id="l00728"></a>00728             intsize--;
<a name="l00729" id="l00729"></a>00729             integer &lt;&lt;= 8;
<a name="l00730" id="l00730"></a>00730         }
<a name="l00731" id="l00731"></a>00731     }
<a name="l00732" id="l00732"></a>00732     data = asn_build_header(data, datalength, type, intsize);
<a name="l00733" id="l00733"></a>00733     <span class=
"keywordflow">if</span> (_asn_build_header_check(errpre, data, *datalength, intsize))
<a name="l00734" id="l00734"></a>00734         <span class="keywordflow">return</span> NULL;
<a name="l00735" id="l00735"></a>00735 
<a name="l00736" id="l00736"></a>00736     *datalength -= intsize;
<a name="l00737" id="l00737"></a>00737     <span class="keywordflow">if</span> (add_null_byte == 1) {
<a name="l00738" id="l00738"></a>00738         *data++ = <span class="charliteral">'\0'</span>;
<a name="l00739" id="l00739"></a>00739         intsize--;
<a name="l00740" id="l00740"></a>00740     }
<a name="l00741" id="l00741"></a>00741     mask = ((u_long) 0xFF) &lt;&lt; (8 * (<span class="keyword">sizeof</span>(long) - 1));
<a name="l00742" id="l00742"></a>00742     <span class="comment">/*</span>
<a name="l00743" id="l00743"></a>00743 <span class="comment">     * mask is 0xFF000000 on a big-endian machine </span>
<a name="l00744" id="l00744"></a>00744 <span class="comment">     */</span>
<a name="l00745" id="l00745"></a>00745     <span class="keywordflow">while</span> (intsize--) {
<a name="l00746" id="l00746"></a>00746         *data++ = (u_char) ((integer &amp; mask) &gt;&gt; (8 * (<span class=
"keyword">sizeof</span>(long) - 1)));
<a name="l00747" id="l00747"></a>00747         integer &lt;&lt;= 8;
<a name="l00748" id="l00748"></a>00748     }
<a name="l00749" id="l00749"></a>00749     DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, initdatap, data - initdatap);
<a name="l00750" id="l00750"></a>00750     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  UInteger:\t%ld (0x%.2lX)\n"</span>, *intp, *intp));
<a name="l00751" id="l00751"></a>00751     <span class="keywordflow">return</span> data;
<a name="l00752" id="l00752"></a>00752 }
<a name="l00753" id="l00753"></a>00753 
<a name="l00754" id="l00754"></a>00754 
<a name="l00783" id="l00783"></a>00783 u_char         *
<a name="l00784" id="l00784"></a>00784 asn_parse_string(u_char * data,
<a name="l00785" id="l00785"></a>00785                  <span class="keywordtype">size_t</span> * datalength,
<a name="l00786" id="l00786"></a>00786                  u_char * type, u_char * str, <span class=
"keywordtype">size_t</span> * strlength)
<a name="l00787" id="l00787"></a>00787 {
<a name="l00788" id="l00788"></a>00788     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse string"</span>;
<a name="l00789" id="l00789"></a>00789     u_char         *bufp = data;
<a name="l00790" id="l00790"></a>00790     u_long          asn_length;
<a name="l00791" id="l00791"></a>00791 
<a name="l00792" id="l00792"></a>00792     *type = *bufp++;
<a name="l00793" id="l00793"></a>00793     bufp = asn_parse_length(bufp, &amp;asn_length);
<a name="l00794" id="l00794"></a>00794     <span class="keywordflow">if</span> (_asn_parse_length_check
<a name="l00795" id="l00795"></a>00795         (errpre, bufp, data, asn_length, *datalength)) {
<a name="l00796" id="l00796"></a>00796         <span class="keywordflow">return</span> NULL;
<a name="l00797" id="l00797"></a>00797     }
<a name="l00798" id="l00798"></a>00798 
<a name="l00799" id="l00799"></a>00799     <span class="keywordflow">if</span> ((<span class=
"keywordtype">int</span>) asn_length &gt; *strlength) {
<a name="l00800" id="l00800"></a>00800         _asn_length_err(errpre, (<span class=
"keywordtype">size_t</span>) asn_length, *strlength);
<a name="l00801" id="l00801"></a>00801         <span class="keywordflow">return</span> NULL;
<a name="l00802" id="l00802"></a>00802     }
<a name="l00803" id="l00803"></a>00803 
<a name="l00804" id="l00804"></a>00804     DEBUGDUMPSETUP(<span class=
"stringliteral">"recv"</span>, data, bufp - data + asn_length);
<a name="l00805" id="l00805"></a>00805 
<a name="l00806" id="l00806"></a>00806     memmove(str, bufp, asn_length);
<a name="l00807" id="l00807"></a>00807     <span class="keywordflow">if</span> (*strlength &gt; (<span class=
"keywordtype">int</span>) asn_length)
<a name="l00808" id="l00808"></a>00808         str[asn_length] = 0;
<a name="l00809" id="l00809"></a>00809     *strlength = (int) asn_length;
<a name="l00810" id="l00810"></a>00810     *datalength -= (int) asn_length + (bufp - data);
<a name="l00811" id="l00811"></a>00811 
<a name="l00812" id="l00812"></a>00812     DEBUGIF(<span class="stringliteral">"dumpv_recv"</span>) {
<a name="l00813" id="l00813"></a>00813         u_char         *buf = (u_char *) malloc(1 + asn_length);
<a name="l00814" id="l00814"></a>00814         <span class=
"keywordtype">size_t</span>          l = (buf != NULL) ? (1 + asn_length) : 0, ol = 0;
<a name="l00815" id="l00815"></a>00815 
<a name="l00816" id="l00816"></a>00816         <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga7ff1971fc340b2789d48895086bf3230" title=
"Prints an ascii string into a buffer.">sprint_realloc_asciistring</a>
<a name="l00817" id="l00817"></a>00817             (&amp;buf, &amp;l, &amp;ol, 1, str, asn_length)) {
<a name="l00818" id="l00818"></a>00818             DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  String:\t%s\n"</span>, buf));
<a name="l00819" id="l00819"></a>00819         } <span class="keywordflow">else</span> {
<a name="l00820" id="l00820"></a>00820             <span class="keywordflow">if</span> (buf == NULL) {
<a name="l00821" id="l00821"></a>00821                 DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  String:\t[TRUNCATED]\n"</span>));
<a name="l00822" id="l00822"></a>00822             } <span class="keywordflow">else</span> {
<a name="l00823" id="l00823"></a>00823                 DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  String:\t%s [TRUNCATED]\n"</span>,
<a name="l00824" id="l00824"></a>00824                           buf));
<a name="l00825" id="l00825"></a>00825             }
<a name="l00826" id="l00826"></a>00826         }
<a name="l00827" id="l00827"></a>00827         <span class="keywordflow">if</span> (buf != NULL) {
<a name="l00828" id="l00828"></a>00828             free(buf);
<a name="l00829" id="l00829"></a>00829         }
<a name="l00830" id="l00830"></a>00830     }
<a name="l00831" id="l00831"></a>00831 
<a name="l00832" id="l00832"></a>00832     <span class="keywordflow">return</span> bufp + asn_length;
<a name="l00833" id="l00833"></a>00833 }
<a name="l00834" id="l00834"></a>00834 
<a name="l00835" id="l00835"></a>00835 
<a name="l00858" id="l00858"></a>00858 u_char         *
<a name="l00859" id="l00859"></a>00859 asn_build_string(u_char * data,
<a name="l00860" id="l00860"></a>00860                  <span class="keywordtype">size_t</span> * datalength,
<a name="l00861" id="l00861"></a>00861                  u_char type, <span class=
"keyword">const</span> u_char * str, <span class="keywordtype">size_t</span> strlength)
<a name="l00862" id="l00862"></a>00862 {
<a name="l00863" id="l00863"></a>00863     <span class="comment">/*</span>
<a name="l00864" id="l00864"></a>00864 <span class="comment">     * ASN.1 octet string ::= primstring | cmpdstring</span>
<a name="l00865" id="l00865"></a>00865 <span class="comment">     * primstring ::= 0x04 asnlength byte {byte}*</span>
<a name="l00866" id="l00866"></a>00866 <span class="comment">     * cmpdstring ::= 0x24 asnlength string {string}*</span>
<a name="l00867" id="l00867"></a>00867 <span class="comment">     * This code will never send a compound string.</span>
<a name="l00868" id="l00868"></a>00868 <span class="comment">     */</span>
<a name="l00869" id="l00869"></a>00869 <span class="preprocessor">#ifndef NETSNMP_NO_DEBUGGING</span>
<a name="l00870" id="l00870"></a>00870     u_char         *initdatap = data;
<a name="l00871" id="l00871"></a>00871 <span class="preprocessor">#endif</span>
<a name="l00872" id="l00872"></a>00872     data = asn_build_header(data, datalength, type, strlength);
<a name="l00873" id="l00873"></a>00873     <span class="keywordflow">if</span> (_asn_build_header_check
<a name="l00874" id="l00874"></a>00874         (<span class="stringliteral">"build string"</span>, data, *datalength, strlength))
<a name="l00875" id="l00875"></a>00875         <span class="keywordflow">return</span> NULL;
<a name="l00876" id="l00876"></a>00876 
<a name="l00877" id="l00877"></a>00877     <span class="keywordflow">if</span> (strlength) {
<a name="l00878" id="l00878"></a>00878         <span class="keywordflow">if</span> (str == NULL) {
<a name="l00879" id="l00879"></a>00879             memset(data, 0, strlength);
<a name="l00880" id="l00880"></a>00880         } <span class="keywordflow">else</span> {
<a name="l00881" id="l00881"></a>00881             memmove(data, str, strlength);
<a name="l00882" id="l00882"></a>00882         }
<a name="l00883" id="l00883"></a>00883     }
<a name="l00884" id="l00884"></a>00884     *datalength -= strlength;
<a name="l00885" id="l00885"></a>00885     DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, initdatap, data - initdatap + strlength);
<a name="l00886" id="l00886"></a>00886     DEBUGIF(<span class="stringliteral">"dumpv_send"</span>) {
<a name="l00887" id="l00887"></a>00887         u_char         *buf = (u_char *) malloc(1 + strlength);
<a name="l00888" id="l00888"></a>00888         <span class=
"keywordtype">size_t</span>          l = (buf != NULL) ? (1 + strlength) : 0, ol = 0;
<a name="l00889" id="l00889"></a>00889 
<a name="l00890" id="l00890"></a>00890         <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga7ff1971fc340b2789d48895086bf3230" title=
"Prints an ascii string into a buffer.">sprint_realloc_asciistring</a>
<a name="l00891" id="l00891"></a>00891             (&amp;buf, &amp;l, &amp;ol, 1, str, strlength)) {
<a name="l00892" id="l00892"></a>00892             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  String:\t%s\n"</span>, buf));
<a name="l00893" id="l00893"></a>00893         } <span class="keywordflow">else</span> {
<a name="l00894" id="l00894"></a>00894             <span class="keywordflow">if</span> (buf == NULL) {
<a name="l00895" id="l00895"></a>00895                 DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  String:\t[TRUNCATED]\n"</span>));
<a name="l00896" id="l00896"></a>00896             } <span class="keywordflow">else</span> {
<a name="l00897" id="l00897"></a>00897                 DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  String:\t%s [TRUNCATED]\n"</span>,
<a name="l00898" id="l00898"></a>00898                           buf));
<a name="l00899" id="l00899"></a>00899             }
<a name="l00900" id="l00900"></a>00900         }
<a name="l00901" id="l00901"></a>00901         <span class="keywordflow">if</span> (buf != NULL) {
<a name="l00902" id="l00902"></a>00902             free(buf);
<a name="l00903" id="l00903"></a>00903         }
<a name="l00904" id="l00904"></a>00904     }
<a name="l00905" id="l00905"></a>00905     <span class="keywordflow">return</span> data + strlength;
<a name="l00906" id="l00906"></a>00906 }
<a name="l00907" id="l00907"></a>00907 
<a name="l00908" id="l00908"></a>00908 
<a name="l00909" id="l00909"></a>00909 
<a name="l00929" id="l00929"></a>00929 u_char         *
<a name="l00930" id="l00930"></a>00930 asn_parse_header(u_char * data, <span class=
"keywordtype">size_t</span> * datalength, u_char * type)
<a name="l00931" id="l00931"></a>00931 {
<a name="l00932" id="l00932"></a>00932     <span class="keyword">register</span> u_char *bufp;
<a name="l00933" id="l00933"></a>00933     u_long          asn_length;
<a name="l00934" id="l00934"></a>00934 
<a name="l00935" id="l00935"></a>00935     <span class="keywordflow">if</span> (!data || !datalength || !type) {
<a name="l00936" id="l00936"></a>00936         ERROR_MSG(<span class="stringliteral">"parse header: NULL pointer"</span>);
<a name="l00937" id="l00937"></a>00937         <span class="keywordflow">return</span> NULL;
<a name="l00938" id="l00938"></a>00938     }
<a name="l00939" id="l00939"></a>00939     bufp = data;
<a name="l00940" id="l00940"></a>00940     <span class="comment">/*</span>
<a name="l00941" id="l00941"></a>00941 <span class=
"comment">     * this only works on data types &lt; 30, i.e. no extension octets </span>
<a name="l00942" id="l00942"></a>00942 <span class="comment">     */</span>
<a name="l00943" id="l00943"></a>00943     <span class="keywordflow">if</span> (IS_EXTENSION_ID(*bufp)) {
<a name="l00944" id="l00944"></a>00944         ERROR_MSG(<span class="stringliteral">"can't process ID &gt;= 30"</span>);
<a name="l00945" id="l00945"></a>00945         <span class="keywordflow">return</span> NULL;
<a name="l00946" id="l00946"></a>00946     }
<a name="l00947" id="l00947"></a>00947     *type = *bufp;
<a name="l00948" id="l00948"></a>00948     bufp = asn_parse_length(bufp + 1, &amp;asn_length);
<a name="l00949" id="l00949"></a>00949 
<a name="l00950" id="l00950"></a>00950     <span class="keywordflow">if</span> (_asn_parse_length_check
<a name="l00951" id="l00951"></a>00951         (<span class=
"stringliteral">"parse header"</span>, bufp, data, asn_length, *datalength))
<a name="l00952" id="l00952"></a>00952         <span class="keywordflow">return</span> NULL;
<a name="l00953" id="l00953"></a>00953 
<a name="l00954" id="l00954"></a>00954 <span class="preprocessor">#ifdef DUMP_PRINT_HEADERS</span>
<a name="l00955" id="l00955"></a>00955     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, (bufp - data));
<a name="l00956" id="l00956"></a>00956     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  Header: 0x%.2X, len = %d (0x%X)\n"</span>, *data,
<a name="l00957" id="l00957"></a>00957               asn_length, asn_length));
<a name="l00958" id="l00958"></a>00958 <span class="preprocessor">#else</span>
<a name="l00959" id="l00959"></a>00959     <span class="comment">/*</span>
<a name="l00960" id="l00960"></a>00960 <span class="comment">     * DEBUGMSGHEXTLI(("recv",data,(bufp-data)));</span>
<a name="l00961" id="l00961"></a>00961 <span class="comment">     * DEBUGMSG(("dumpH_recv","\n"));</span>
<a name="l00962" id="l00962"></a>00962 <span class="comment">     */</span>
<a name="l00963" id="l00963"></a>00963 <span class="preprocessor">#endif</span>
<a name="l00964" id="l00964"></a>00964 
<a name="l00965" id="l00965"></a>00965 <span class="preprocessor">#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES</span>
<a name="l00966" id="l00966"></a>00966 
<a name="l00967" id="l00967"></a>00967     <span class=
"keywordflow">if</span> ((*type == ASN_OPAQUE) &amp;&amp; (*bufp == ASN_OPAQUE_TAG1)) {
<a name="l00968" id="l00968"></a>00968 
<a name="l00969" id="l00969"></a>00969         <span class="comment">/*</span>
<a name="l00970" id="l00970"></a>00970 <span class="comment">         * check if 64-but counter </span>
<a name="l00971" id="l00971"></a>00971 <span class="comment">         */</span>
<a name="l00972" id="l00972"></a>00972         <span class="keywordflow">switch</span> (*(bufp + 1)) {
<a name="l00973" id="l00973"></a>00973         <span class="keywordflow">case</span> ASN_OPAQUE_COUNTER64:
<a name="l00974" id="l00974"></a>00974         <span class="keywordflow">case</span> ASN_OPAQUE_U64:
<a name="l00975" id="l00975"></a>00975         <span class="keywordflow">case</span> ASN_OPAQUE_FLOAT:
<a name="l00976" id="l00976"></a>00976         <span class="keywordflow">case</span> ASN_OPAQUE_DOUBLE:
<a name="l00977" id="l00977"></a>00977         <span class="keywordflow">case</span> ASN_OPAQUE_I64:
<a name="l00978" id="l00978"></a>00978             *type = *(bufp + 1);
<a name="l00979" id="l00979"></a>00979             <span class="keywordflow">break</span>;
<a name="l00980" id="l00980"></a>00980 
<a name="l00981" id="l00981"></a>00981         <span class="keywordflow">default</span>:
<a name="l00982" id="l00982"></a>00982             <span class="comment">/*</span>
<a name="l00983" id="l00983"></a>00983 <span class="comment">             * just an Opaque </span>
<a name="l00984" id="l00984"></a>00984 <span class="comment">             */</span>
<a name="l00985" id="l00985"></a>00985             *datalength = (int) asn_length;
<a name="l00986" id="l00986"></a>00986             <span class="keywordflow">return</span> bufp;
<a name="l00987" id="l00987"></a>00987         }
<a name="l00988" id="l00988"></a>00988         <span class="comment">/*</span>
<a name="l00989" id="l00989"></a>00989 <span class="comment">         * value is encoded as special format </span>
<a name="l00990" id="l00990"></a>00990 <span class="comment">         */</span>
<a name="l00991" id="l00991"></a>00991         bufp = asn_parse_length(bufp + 2, &amp;asn_length);
<a name="l00992" id="l00992"></a>00992         <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse opaque header"</span>, bufp, data,
<a name="l00993" id="l00993"></a>00993                                     asn_length, *datalength))
<a name="l00994" id="l00994"></a>00994             <span class="keywordflow">return</span> NULL;
<a name="l00995" id="l00995"></a>00995     }
<a name="l00996" id="l00996"></a>00996 <span class="preprocessor">#endif                          </span><span class=
"comment">/* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */</span>
<a name="l00997" id="l00997"></a>00997 
<a name="l00998" id="l00998"></a>00998     *datalength = (int) asn_length;
<a name="l00999" id="l00999"></a>00999 
<a name="l01000" id="l01000"></a>01000     <span class="keywordflow">return</span> bufp;
<a name="l01001" id="l01001"></a>01001 }
<a name="l01002" id="l01002"></a>01002 
<a name="l01017" id="l01017"></a>01017 u_char         *
<a name="l01018" id="l01018"></a>01018 asn_parse_sequence(u_char * data, <span class=
"keywordtype">size_t</span> * datalength, u_char * type, u_char expected_type,     <span class=
"comment">/* must be this type */</span>
<a name="l01019" id="l01019"></a>01019                    <span class="keyword">const</span> <span class=
"keywordtype">char</span> *estr)
<a name="l01020" id="l01020"></a>01020 {                               <span class="comment">/* error message prefix */</span>
<a name="l01021" id="l01021"></a>01021     data = asn_parse_header(data, datalength, type);
<a name="l01022" id="l01022"></a>01022     <span class="keywordflow">if</span> (data &amp;&amp; (*type != expected_type)) {
<a name="l01023" id="l01023"></a>01023         <span class="keywordtype">char</span>            ebuf[128];
<a name="l01024" id="l01024"></a>01024         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l01025" id="l01025"></a>01025                  <span class="stringliteral">"%s header type %02X: s/b %02X"</span>, estr,
<a name="l01026" id="l01026"></a>01026                 (u_char) * type, (u_char) expected_type);
<a name="l01027" id="l01027"></a>01027         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l01028" id="l01028"></a>01028         ERROR_MSG(ebuf);
<a name="l01029" id="l01029"></a>01029         <span class="keywordflow">return</span> NULL;
<a name="l01030" id="l01030"></a>01030     }
<a name="l01031" id="l01031"></a>01031     <span class="keywordflow">return</span> data;
<a name="l01032" id="l01032"></a>01032 }
<a name="l01033" id="l01033"></a>01033 
<a name="l01034" id="l01034"></a>01034 
<a name="l01035" id="l01035"></a>01035 
<a name="l01058" id="l01058"></a>01058 u_char         *
<a name="l01059" id="l01059"></a>01059 asn_build_header(u_char * data,
<a name="l01060" id="l01060"></a>01060                  <span class=
"keywordtype">size_t</span> * datalength, u_char type, <span class="keywordtype">size_t</span> length)
<a name="l01061" id="l01061"></a>01061 {
<a name="l01062" id="l01062"></a>01062     <span class="keywordtype">char</span>            ebuf[128];
<a name="l01063" id="l01063"></a>01063 
<a name="l01064" id="l01064"></a>01064     <span class="keywordflow">if</span> (*datalength &lt; 1) {
<a name="l01065" id="l01065"></a>01065         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l01066" id="l01066"></a>01066                 <span class="stringliteral">"bad header length &lt; 1 :%lu, %lu"</span>,
<a name="l01067" id="l01067"></a>01067                 (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)*datalength, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)length);
<a name="l01068" id="l01068"></a>01068         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l01069" id="l01069"></a>01069         ERROR_MSG(ebuf);
<a name="l01070" id="l01070"></a>01070         <span class="keywordflow">return</span> NULL;
<a name="l01071" id="l01071"></a>01071     }
<a name="l01072" id="l01072"></a>01072     *data++ = type;
<a name="l01073" id="l01073"></a>01073     (*datalength)--;
<a name="l01074" id="l01074"></a>01074     <span class="keywordflow">return</span> asn_build_length(data, datalength, length);
<a name="l01075" id="l01075"></a>01075 }
<a name="l01076" id="l01076"></a>01076 
<a name="l01100" id="l01100"></a>01100 u_char         *
<a name="l01101" id="l01101"></a>01101 asn_build_sequence(u_char * data,
<a name="l01102" id="l01102"></a>01102                    <span class=
"keywordtype">size_t</span> * datalength, u_char type, <span class="keywordtype">size_t</span> length)
<a name="l01103" id="l01103"></a>01103 {
<a name="l01104" id="l01104"></a>01104     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build seq"</span>;
<a name="l01105" id="l01105"></a>01105     <span class="keywordtype">char</span>            ebuf[128];
<a name="l01106" id="l01106"></a>01106 
<a name="l01107" id="l01107"></a>01107     <span class="keywordflow">if</span> (*datalength &lt; 4) {
<a name="l01108" id="l01108"></a>01108         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l01109" id="l01109"></a>01109                 <span class="stringliteral">"%s: length %d &lt; 4: PUNT"</span>, errpre,
<a name="l01110" id="l01110"></a>01110                 (<span class="keywordtype">int</span>) *datalength);
<a name="l01111" id="l01111"></a>01111         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l01112" id="l01112"></a>01112         ERROR_MSG(ebuf);
<a name="l01113" id="l01113"></a>01113         <span class="keywordflow">return</span> NULL;
<a name="l01114" id="l01114"></a>01114     }
<a name="l01115" id="l01115"></a>01115     *datalength -= 4;
<a name="l01116" id="l01116"></a>01116     *data++ = type;
<a name="l01117" id="l01117"></a>01117     *data++ = (u_char) (0x02 | ASN_LONG_LEN);
<a name="l01118" id="l01118"></a>01118     *data++ = (u_char) ((length &gt;&gt; 8) &amp; 0xFF);
<a name="l01119" id="l01119"></a>01119     *data++ = (u_char) (length &amp; 0xFF);
<a name="l01120" id="l01120"></a>01120     <span class="keywordflow">return</span> data;
<a name="l01121" id="l01121"></a>01121 }
<a name="l01122" id="l01122"></a>01122 
<a name="l01140" id="l01140"></a>01140 u_char         *
<a name="l01141" id="l01141"></a>01141 asn_parse_length(u_char * data, u_long * length)
<a name="l01142" id="l01142"></a>01142 {
<a name="l01143" id="l01143"></a>01143     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse length"</span>;
<a name="l01144" id="l01144"></a>01144     <span class="keywordtype">char</span>            ebuf[128];
<a name="l01145" id="l01145"></a>01145     <span class="keyword">register</span> u_char lengthbyte;
<a name="l01146" id="l01146"></a>01146 
<a name="l01147" id="l01147"></a>01147     <span class="keywordflow">if</span> (!data || !length) {
<a name="l01148" id="l01148"></a>01148         ERROR_MSG(<span class="stringliteral">"parse length: NULL pointer"</span>);
<a name="l01149" id="l01149"></a>01149         <span class="keywordflow">return</span> NULL;
<a name="l01150" id="l01150"></a>01150     }
<a name="l01151" id="l01151"></a>01151     lengthbyte = *data;
<a name="l01152" id="l01152"></a>01152 
<a name="l01153" id="l01153"></a>01153     <span class="keywordflow">if</span> (lengthbyte &amp; ASN_LONG_LEN) {
<a name="l01154" id="l01154"></a>01154         lengthbyte &amp;= ~ASN_LONG_LEN;    <span class=
"comment">/* turn MSb off */</span>
<a name="l01155" id="l01155"></a>01155         <span class="keywordflow">if</span> (lengthbyte == 0) {
<a name="l01156" id="l01156"></a>01156             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l01157" id="l01157"></a>01157                      <span class=
"stringliteral">"%s: indefinite length not supported"</span>, errpre);
<a name="l01158" id="l01158"></a>01158             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l01159" id="l01159"></a>01159             ERROR_MSG(ebuf);
<a name="l01160" id="l01160"></a>01160             <span class="keywordflow">return</span> NULL;
<a name="l01161" id="l01161"></a>01161         }
<a name="l01162" id="l01162"></a>01162         <span class="keywordflow">if</span> (lengthbyte &gt; <span class=
"keyword">sizeof</span>(<span class="keywordtype">long</span>)) {
<a name="l01163" id="l01163"></a>01163             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l01164" id="l01164"></a>01164                     <span class=
"stringliteral">"%s: data length %d &gt; %lu not supported"</span>, errpre,
<a name="l01165" id="l01165"></a>01165                     lengthbyte, (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
<a name="l01166" id="l01166"></a>01166             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l01167" id="l01167"></a>01167             ERROR_MSG(ebuf);
<a name="l01168" id="l01168"></a>01168             <span class="keywordflow">return</span> NULL;
<a name="l01169" id="l01169"></a>01169         }
<a name="l01170" id="l01170"></a>01170         data++;
<a name="l01171" id="l01171"></a>01171         *length = 0;            <span class=
"comment">/* protect against short lengths */</span>
<a name="l01172" id="l01172"></a>01172         <span class="keywordflow">while</span> (lengthbyte--) {
<a name="l01173" id="l01173"></a>01173             *length &lt;&lt;= 8;
<a name="l01174" id="l01174"></a>01174             *length |= *data++;
<a name="l01175" id="l01175"></a>01175         }
<a name="l01176" id="l01176"></a>01176         <span class="keywordflow">if</span> ((<span class=
"keywordtype">long</span>) *length &lt; 0) {
<a name="l01177" id="l01177"></a>01177             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l01178" id="l01178"></a>01178                      <span class=
"stringliteral">"%s: negative data length %ld\n"</span>, errpre,
<a name="l01179" id="l01179"></a>01179                      (<span class="keywordtype">long</span>) *length);
<a name="l01180" id="l01180"></a>01180             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l01181" id="l01181"></a>01181             ERROR_MSG(ebuf);
<a name="l01182" id="l01182"></a>01182             <span class="keywordflow">return</span> NULL;
<a name="l01183" id="l01183"></a>01183         }
<a name="l01184" id="l01184"></a>01184         <span class="keywordflow">return</span> data;
<a name="l01185" id="l01185"></a>01185     } <span class="keywordflow">else</span> {                    <span class=
"comment">/* short asnlength */</span>
<a name="l01186" id="l01186"></a>01186         *length = (long) lengthbyte;
<a name="l01187" id="l01187"></a>01187         <span class="keywordflow">return</span> data + 1;
<a name="l01188" id="l01188"></a>01188     }
<a name="l01189" id="l01189"></a>01189 }
<a name="l01190" id="l01190"></a>01190 
<a name="l01211" id="l01211"></a>01211 u_char         *
<a name="l01212" id="l01212"></a>01212 asn_build_length(u_char * data, <span class=
"keywordtype">size_t</span> * datalength, <span class="keywordtype">size_t</span> length)
<a name="l01213" id="l01213"></a>01213 {
<a name="l01214" id="l01214"></a>01214     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build length"</span>;
<a name="l01215" id="l01215"></a>01215     <span class="keywordtype">char</span>            ebuf[128];
<a name="l01216" id="l01216"></a>01216 
<a name="l01217" id="l01217"></a>01217     u_char         *start_data = data;
<a name="l01218" id="l01218"></a>01218 
<a name="l01219" id="l01219"></a>01219     <span class="comment">/*</span>
<a name="l01220" id="l01220"></a>01220 <span class="comment">     * no indefinite lengths sent </span>
<a name="l01221" id="l01221"></a>01221 <span class="comment">     */</span>
<a name="l01222" id="l01222"></a>01222     <span class="keywordflow">if</span> (length &lt; 0x80) {
<a name="l01223" id="l01223"></a>01223         <span class="keywordflow">if</span> (*datalength &lt; 1) {
<a name="l01224" id="l01224"></a>01224             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l01225" id="l01225"></a>01225                     <span class=
"stringliteral">"%s: bad length &lt; 1 :%lu, %lu"</span>, errpre,
<a name="l01226" id="l01226"></a>01226                     (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)*datalength, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)length);
<a name="l01227" id="l01227"></a>01227             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l01228" id="l01228"></a>01228             ERROR_MSG(ebuf);
<a name="l01229" id="l01229"></a>01229             <span class="keywordflow">return</span> NULL;
<a name="l01230" id="l01230"></a>01230         }
<a name="l01231" id="l01231"></a>01231         *data++ = (u_char) length;
<a name="l01232" id="l01232"></a>01232     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (length &lt;= 0xFF) {
<a name="l01233" id="l01233"></a>01233         <span class="keywordflow">if</span> (*datalength &lt; 2) {
<a name="l01234" id="l01234"></a>01234             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l01235" id="l01235"></a>01235                     <span class=
"stringliteral">"%s: bad length &lt; 2 :%lu, %lu"</span>, errpre,
<a name="l01236" id="l01236"></a>01236                     (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)*datalength, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)length);
<a name="l01237" id="l01237"></a>01237             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l01238" id="l01238"></a>01238             ERROR_MSG(ebuf);
<a name="l01239" id="l01239"></a>01239             <span class="keywordflow">return</span> NULL;
<a name="l01240" id="l01240"></a>01240         }
<a name="l01241" id="l01241"></a>01241         *data++ = (u_char) (0x01 | ASN_LONG_LEN);
<a name="l01242" id="l01242"></a>01242         *data++ = (u_char) length;
<a name="l01243" id="l01243"></a>01243     } <span class="keywordflow">else</span> {                    <span class=
"comment">/* 0xFF &lt; length &lt;= 0xFFFF */</span>
<a name="l01244" id="l01244"></a>01244         <span class="keywordflow">if</span> (*datalength &lt; 3) {
<a name="l01245" id="l01245"></a>01245             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l01246" id="l01246"></a>01246                     <span class=
"stringliteral">"%s: bad length &lt; 3 :%lu, %lu"</span>, errpre,
<a name="l01247" id="l01247"></a>01247                     (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)*datalength, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)length);
<a name="l01248" id="l01248"></a>01248             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l01249" id="l01249"></a>01249             ERROR_MSG(ebuf);
<a name="l01250" id="l01250"></a>01250             <span class="keywordflow">return</span> NULL;
<a name="l01251" id="l01251"></a>01251         }
<a name="l01252" id="l01252"></a>01252         *data++ = (u_char) (0x02 | ASN_LONG_LEN);
<a name="l01253" id="l01253"></a>01253         *data++ = (u_char) ((length &gt;&gt; 8) &amp; 0xFF);
<a name="l01254" id="l01254"></a>01254         *data++ = (u_char) (length &amp; 0xFF);
<a name="l01255" id="l01255"></a>01255     }
<a name="l01256" id="l01256"></a>01256     *datalength -= (data - start_data);
<a name="l01257" id="l01257"></a>01257     <span class="keywordflow">return</span> data;
<a name="l01258" id="l01258"></a>01258 
<a name="l01259" id="l01259"></a>01259 }
<a name="l01260" id="l01260"></a>01260 
<a name="l01286" id="l01286"></a>01286 u_char         *
<a name="l01287" id="l01287"></a>01287 asn_parse_objid(u_char * data,
<a name="l01288" id="l01288"></a>01288                 <span class="keywordtype">size_t</span> * datalength,
<a name="l01289" id="l01289"></a>01289                 u_char * type, oid * objid, <span class=
"keywordtype">size_t</span> * objidlength)
<a name="l01290" id="l01290"></a>01290 {
<a name="l01291" id="l01291"></a>01291     <span class="comment">/*</span>
<a name="l01292" id="l01292"></a>01292 <span class=
"comment">     * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*</span>
<a name="l01293" id="l01293"></a>01293 <span class="comment">     * subidentifier ::= {leadingbyte}* lastbyte</span>
<a name="l01294" id="l01294"></a>01294 <span class="comment">     * leadingbyte ::= 1 7bitvalue</span>
<a name="l01295" id="l01295"></a>01295 <span class="comment">     * lastbyte ::= 0 7bitvalue</span>
<a name="l01296" id="l01296"></a>01296 <span class="comment">     */</span>
<a name="l01297" id="l01297"></a>01297     <span class="keyword">register</span> u_char *bufp = data;
<a name="l01298" id="l01298"></a>01298     <span class="keyword">register</span> oid   *oidp = objid + 1;
<a name="l01299" id="l01299"></a>01299     <span class="keyword">register</span> u_long subidentifier;
<a name="l01300" id="l01300"></a>01300     <span class="keyword">register</span> <span class="keywordtype">long</span>   length;
<a name="l01301" id="l01301"></a>01301     u_long          asn_length;
<a name="l01302" id="l01302"></a>01302     <span class="keywordtype">size_t</span>          original_length = *objidlength;
<a name="l01303" id="l01303"></a>01303 
<a name="l01304" id="l01304"></a>01304     *type = *bufp++;
<a name="l01305" id="l01305"></a>01305     bufp = asn_parse_length(bufp, &amp;asn_length);
<a name="l01306" id="l01306"></a>01306     <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse objid"</span>, bufp, data,
<a name="l01307" id="l01307"></a>01307                                 asn_length, *datalength))
<a name="l01308" id="l01308"></a>01308         <span class="keywordflow">return</span> NULL;
<a name="l01309" id="l01309"></a>01309 
<a name="l01310" id="l01310"></a>01310     *datalength -= (int) asn_length + (bufp - data);
<a name="l01311" id="l01311"></a>01311 
<a name="l01312" id="l01312"></a>01312     DEBUGDUMPSETUP(<span class=
"stringliteral">"recv"</span>, data, bufp - data + asn_length);
<a name="l01313" id="l01313"></a>01313 
<a name="l01314" id="l01314"></a>01314     <span class="comment">/*</span>
<a name="l01315" id="l01315"></a>01315 <span class=
"comment">     * Handle invalid object identifier encodings of the form 06 00 robustly </span>
<a name="l01316" id="l01316"></a>01316 <span class="comment">     */</span>
<a name="l01317" id="l01317"></a>01317     <span class="keywordflow">if</span> (asn_length == 0)
<a name="l01318" id="l01318"></a>01318         objid[0] = objid[1] = 0;
<a name="l01319" id="l01319"></a>01319 
<a name="l01320" id="l01320"></a>01320     length = asn_length;
<a name="l01321" id="l01321"></a>01321     (*objidlength)--;           <span class=
"comment">/* account for expansion of first byte */</span>
<a name="l01322" id="l01322"></a>01322 
<a name="l01323" id="l01323"></a>01323     <span class=
"keywordflow">while</span> (length &gt; 0 &amp;&amp; (*objidlength)-- &gt; 0) {
<a name="l01324" id="l01324"></a>01324         subidentifier = 0;
<a name="l01325" id="l01325"></a>01325         <span class="keywordflow">do</span> {                    <span class=
"comment">/* shift and add in low order 7 bits */</span>
<a name="l01326" id="l01326"></a>01326             subidentifier =
<a name="l01327" id="l01327"></a>01327                 (subidentifier &lt;&lt; 7) + (*(u_char *) bufp &amp; ~ASN_BIT8);
<a name="l01328" id="l01328"></a>01328             length--;
<a name="l01329" id="l01329"></a>01329         } <span class=
"keywordflow">while</span> ((*(u_char *) bufp++ &amp; ASN_BIT8) &amp;&amp; (length &gt; 0));        <span class=
"comment">/* last byte has high bit clear */</span>
<a name="l01330" id="l01330"></a>01330 
<a name="l01331" id="l01331"></a>01331         <span class="keywordflow">if</span> (length == 0) {
<a name="l01332" id="l01332"></a>01332             u_char *last_byte = bufp - 1;
<a name="l01333" id="l01333"></a>01333             <span class="keywordflow">if</span> (*last_byte &amp; ASN_BIT8) {
<a name="l01334" id="l01334"></a>01334                 <span class=
"comment">/* last byte has high bit set -&gt; wrong BER encoded OID */</span>
<a name="l01335" id="l01335"></a>01335                 ERROR_MSG(<span class=
"stringliteral">"subidentifier syntax error"</span>);
<a name="l01336" id="l01336"></a>01336                 <span class="keywordflow">return</span> NULL;
<a name="l01337" id="l01337"></a>01337             }
<a name="l01338" id="l01338"></a>01338         }
<a name="l01339" id="l01339"></a>01339 <span class="preprocessor">#if defined(EIGHTBIT_SUBIDS) || (SIZEOF_LONG != 4)</span>
<a name="l01340" id="l01340"></a>01340         <span class="keywordflow">if</span> (subidentifier &gt; (u_long) MAX_SUBID) {
<a name="l01341" id="l01341"></a>01341             ERROR_MSG(<span class="stringliteral">"subidentifier too large"</span>);
<a name="l01342" id="l01342"></a>01342             <span class="keywordflow">return</span> NULL;
<a name="l01343" id="l01343"></a>01343         }
<a name="l01344" id="l01344"></a>01344 <span class="preprocessor">#endif</span>
<a name="l01345" id="l01345"></a>01345         *oidp++ = (oid) subidentifier;
<a name="l01346" id="l01346"></a>01346     }
<a name="l01347" id="l01347"></a>01347 
<a name="l01348" id="l01348"></a>01348     <span class="keywordflow">if</span> (0 != length) {
<a name="l01349" id="l01349"></a>01349         ERROR_MSG(<span class="stringliteral">"OID length exceeds buffer size"</span>);
<a name="l01350" id="l01350"></a>01350         *objidlength = original_length;
<a name="l01351" id="l01351"></a>01351         <span class="keywordflow">return</span> NULL;
<a name="l01352" id="l01352"></a>01352     }
<a name="l01353" id="l01353"></a>01353 
<a name="l01354" id="l01354"></a>01354     <span class="comment">/*</span>
<a name="l01355" id="l01355"></a>01355 <span class=
"comment">     * The first two subidentifiers are encoded into the first component</span>
<a name="l01356" id="l01356"></a>01356 <span class="comment">     * with the value (X * 40) + Y, where:</span>
<a name="l01357" id="l01357"></a>01357 <span class="comment">     *  X is the value of the first subidentifier.</span>
<a name="l01358" id="l01358"></a>01358 <span class="comment">     *  Y is the value of the second subidentifier.</span>
<a name="l01359" id="l01359"></a>01359 <span class="comment">     */</span>
<a name="l01360" id="l01360"></a>01360     subidentifier = (u_long) objid[1];
<a name="l01361" id="l01361"></a>01361     <span class="keywordflow">if</span> (subidentifier == 0x2B) {
<a name="l01362" id="l01362"></a>01362         objid[0] = 1;
<a name="l01363" id="l01363"></a>01363         objid[1] = 3;
<a name="l01364" id="l01364"></a>01364     } <span class="keywordflow">else</span> {
<a name="l01365" id="l01365"></a>01365         <span class="keywordflow">if</span> (subidentifier &lt; 40) {
<a name="l01366" id="l01366"></a>01366             objid[0] = 0;
<a name="l01367" id="l01367"></a>01367             objid[1] = subidentifier;
<a name="l01368" id="l01368"></a>01368         } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (subidentifier &lt; 80) {
<a name="l01369" id="l01369"></a>01369             objid[0] = 1;
<a name="l01370" id="l01370"></a>01370             objid[1] = subidentifier - 40;
<a name="l01371" id="l01371"></a>01371         } <span class="keywordflow">else</span> {
<a name="l01372" id="l01372"></a>01372             objid[0] = 2;
<a name="l01373" id="l01373"></a>01373             objid[1] = subidentifier - 80;
<a name="l01374" id="l01374"></a>01374         }
<a name="l01375" id="l01375"></a>01375     }
<a name="l01376" id="l01376"></a>01376 
<a name="l01377" id="l01377"></a>01377     *objidlength = (int) (oidp - objid);
<a name="l01378" id="l01378"></a>01378 
<a name="l01379" id="l01379"></a>01379     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  ObjID: "</span>));
<a name="l01380" id="l01380"></a>01380     DEBUGMSGOID((<span class="stringliteral">"dumpv_recv"</span>, objid, *objidlength));
<a name="l01381" id="l01381"></a>01381     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"\n"</span>));
<a name="l01382" id="l01382"></a>01382     <span class="keywordflow">return</span> bufp;
<a name="l01383" id="l01383"></a>01383 }
<a name="l01384" id="l01384"></a>01384 
<a name="l01408" id="l01408"></a>01408 u_char         *
<a name="l01409" id="l01409"></a>01409 asn_build_objid(u_char * data,
<a name="l01410" id="l01410"></a>01410                 <span class="keywordtype">size_t</span> * datalength,
<a name="l01411" id="l01411"></a>01411                 u_char type, oid * objid, <span class=
"keywordtype">size_t</span> objidlength)
<a name="l01412" id="l01412"></a>01412 {
<a name="l01413" id="l01413"></a>01413     <span class="comment">/*</span>
<a name="l01414" id="l01414"></a>01414 <span class=
"comment">     * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*</span>
<a name="l01415" id="l01415"></a>01415 <span class="comment">     * subidentifier ::= {leadingbyte}* lastbyte</span>
<a name="l01416" id="l01416"></a>01416 <span class="comment">     * leadingbyte ::= 1 7bitvalue</span>
<a name="l01417" id="l01417"></a>01417 <span class="comment">     * lastbyte ::= 0 7bitvalue</span>
<a name="l01418" id="l01418"></a>01418 <span class="comment">     */</span>
<a name="l01419" id="l01419"></a>01419     <span class="keywordtype">size_t</span>          asnlength;
<a name="l01420" id="l01420"></a>01420     <span class="keyword">register</span> oid   *op = objid;
<a name="l01421" id="l01421"></a>01421     u_char          objid_size[MAX_OID_LEN];
<a name="l01422" id="l01422"></a>01422     <span class="keyword">register</span> u_long objid_val;
<a name="l01423" id="l01423"></a>01423     u_long          first_objid_val;
<a name="l01424" id="l01424"></a>01424     <span class="keyword">register</span> <span class="keywordtype">int</span>    i;
<a name="l01425" id="l01425"></a>01425 <span class="preprocessor">#ifndef NETSNMP_NO_DEBUGGING</span>
<a name="l01426" id="l01426"></a>01426     u_char         *initdatap = data;
<a name="l01427" id="l01427"></a>01427 <span class="preprocessor">#endif</span>
<a name="l01428" id="l01428"></a>01428 
<a name="l01429" id="l01429"></a>01429     <span class="comment">/*</span>
<a name="l01430" id="l01430"></a>01430 <span class="comment">     * check if there are at least 2 sub-identifiers </span>
<a name="l01431" id="l01431"></a>01431 <span class="comment">     */</span>
<a name="l01432" id="l01432"></a>01432     <span class="keywordflow">if</span> (objidlength == 0) {
<a name="l01433" id="l01433"></a>01433         <span class="comment">/*</span>
<a name="l01434" id="l01434"></a>01434 <span class=
"comment">         * there are not, so make OID have two with value of zero </span>
<a name="l01435" id="l01435"></a>01435 <span class="comment">         */</span>
<a name="l01436" id="l01436"></a>01436         objid_val = 0;
<a name="l01437" id="l01437"></a>01437         objidlength = 2;
<a name="l01438" id="l01438"></a>01438     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (objid[0] &gt; 2) {
<a name="l01439" id="l01439"></a>01439         ERROR_MSG(<span class=
"stringliteral">"build objid: bad first subidentifier"</span>);
<a name="l01440" id="l01440"></a>01440         <span class="keywordflow">return</span> NULL;
<a name="l01441" id="l01441"></a>01441     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (objidlength == 1) {
<a name="l01442" id="l01442"></a>01442         <span class="comment">/*</span>
<a name="l01443" id="l01443"></a>01443 <span class="comment">         * encode the first value </span>
<a name="l01444" id="l01444"></a>01444 <span class="comment">         */</span>
<a name="l01445" id="l01445"></a>01445         objid_val = (op[0] * 40);
<a name="l01446" id="l01446"></a>01446         objidlength = 2;
<a name="l01447" id="l01447"></a>01447         op++;
<a name="l01448" id="l01448"></a>01448     } <span class="keywordflow">else</span> {
<a name="l01449" id="l01449"></a>01449         <span class="comment">/*</span>
<a name="l01450" id="l01450"></a>01450 <span class="comment">         * combine the first two values </span>
<a name="l01451" id="l01451"></a>01451 <span class="comment">         */</span>
<a name="l01452" id="l01452"></a>01452         <span class="keywordflow">if</span> ((op[1] &gt; 40) &amp;&amp;
<a name="l01453" id="l01453"></a>01453             (op[0] &lt; 2)) {
<a name="l01454" id="l01454"></a>01454             ERROR_MSG(<span class=
"stringliteral">"build objid: bad second subidentifier"</span>);
<a name="l01455" id="l01455"></a>01455             <span class="keywordflow">return</span> NULL;
<a name="l01456" id="l01456"></a>01456         }
<a name="l01457" id="l01457"></a>01457         objid_val = (op[0] * 40) + op[1];
<a name="l01458" id="l01458"></a>01458         op += 2;
<a name="l01459" id="l01459"></a>01459     }
<a name="l01460" id="l01460"></a>01460     first_objid_val = objid_val;
<a name="l01461" id="l01461"></a>01461 
<a name="l01462" id="l01462"></a>01462     <span class="comment">/*</span>
<a name="l01463" id="l01463"></a>01463 <span class="comment">     * ditch illegal calls now </span>
<a name="l01464" id="l01464"></a>01464 <span class="comment">     */</span>
<a name="l01465" id="l01465"></a>01465     <span class="keywordflow">if</span> (objidlength &gt; MAX_OID_LEN)
<a name="l01466" id="l01466"></a>01466         <span class="keywordflow">return</span> NULL;
<a name="l01467" id="l01467"></a>01467 
<a name="l01468" id="l01468"></a>01468     <span class="comment">/*</span>
<a name="l01469" id="l01469"></a>01469 <span class=
"comment">     * calculate the number of bytes needed to store the encoded value </span>
<a name="l01470" id="l01470"></a>01470 <span class="comment">     */</span>
<a name="l01471" id="l01471"></a>01471     <span class="keywordflow">for</span> (i = 1, asnlength = 0;;) {
<a name="l01472" id="l01472"></a>01472 
<a name="l01473" id="l01473"></a>01473         CHECK_OVERFLOW_U(objid_val,5);
<a name="l01474" id="l01474"></a>01474         <span class="keywordflow">if</span> (objid_val &lt; (<span class=
"keywordtype">unsigned</span>) 0x80) {
<a name="l01475" id="l01475"></a>01475             objid_size[i] = 1;
<a name="l01476" id="l01476"></a>01476             asnlength += 1;
<a name="l01477" id="l01477"></a>01477         } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (objid_val &lt; (<span class="keywordtype">unsigned</span>) 0x4000) {
<a name="l01478" id="l01478"></a>01478             objid_size[i] = 2;
<a name="l01479" id="l01479"></a>01479             asnlength += 2;
<a name="l01480" id="l01480"></a>01480         } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (objid_val &lt; (<span class="keywordtype">unsigned</span>) 0x200000) {
<a name="l01481" id="l01481"></a>01481             objid_size[i] = 3;
<a name="l01482" id="l01482"></a>01482             asnlength += 3;
<a name="l01483" id="l01483"></a>01483         } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (objid_val &lt; (<span class="keywordtype">unsigned</span>) 0x10000000) {
<a name="l01484" id="l01484"></a>01484             objid_size[i] = 4;
<a name="l01485" id="l01485"></a>01485             asnlength += 4;
<a name="l01486" id="l01486"></a>01486         } <span class="keywordflow">else</span> {
<a name="l01487" id="l01487"></a>01487             objid_size[i] = 5;
<a name="l01488" id="l01488"></a>01488             asnlength += 5;
<a name="l01489" id="l01489"></a>01489         }
<a name="l01490" id="l01490"></a>01490         i++;
<a name="l01491" id="l01491"></a>01491         <span class="keywordflow">if</span> (i &gt;= (<span class=
"keywordtype">int</span>) objidlength)
<a name="l01492" id="l01492"></a>01492             <span class="keywordflow">break</span>;
<a name="l01493" id="l01493"></a>01493         objid_val = *op++;      <span class=
"comment">/* XXX - doesn't handle 2.X (X &gt; 40) */</span>
<a name="l01494" id="l01494"></a>01494     }
<a name="l01495" id="l01495"></a>01495 
<a name="l01496" id="l01496"></a>01496     <span class="comment">/*</span>
<a name="l01497" id="l01497"></a>01497 <span class="comment">     * store the ASN.1 tag and length </span>
<a name="l01498" id="l01498"></a>01498 <span class="comment">     */</span>
<a name="l01499" id="l01499"></a>01499     data = asn_build_header(data, datalength, type, asnlength);
<a name="l01500" id="l01500"></a>01500     <span class="keywordflow">if</span> (_asn_build_header_check
<a name="l01501" id="l01501"></a>01501         (<span class="stringliteral">"build objid"</span>, data, *datalength, asnlength))
<a name="l01502" id="l01502"></a>01502         <span class="keywordflow">return</span> NULL;
<a name="l01503" id="l01503"></a>01503 
<a name="l01504" id="l01504"></a>01504     <span class="comment">/*</span>
<a name="l01505" id="l01505"></a>01505 <span class="comment">     * store the encoded OID value </span>
<a name="l01506" id="l01506"></a>01506 <span class="comment">     */</span>
<a name="l01507" id="l01507"></a>01507     <span class=
"keywordflow">for</span> (i = 1, objid_val = first_objid_val, op = objid + 2;
<a name="l01508" id="l01508"></a>01508          i &lt; (int) objidlength; i++) {
<a name="l01509" id="l01509"></a>01509         <span class="keywordflow">if</span> (i != 1) {
<a name="l01510" id="l01510"></a>01510             objid_val = *op++;
<a name="l01511" id="l01511"></a>01511 <span class="preprocessor">#if SIZEOF_LONG != 4</span>
<a name="l01512" id="l01512"></a>01512             <span class="keywordflow">if</span> (objid_val &gt; 0xffffffff) <span class=
"comment">/* already logged warning above */</span>
<a name="l01513" id="l01513"></a>01513                 objid_val &amp;= 0xffffffff;
<a name="l01514" id="l01514"></a>01514 <span class="preprocessor">#endif</span>
<a name="l01515" id="l01515"></a>01515         }
<a name="l01516" id="l01516"></a>01516         <span class="keywordflow">switch</span> (objid_size[i]) {
<a name="l01517" id="l01517"></a>01517         <span class="keywordflow">case</span> 1:
<a name="l01518" id="l01518"></a>01518             *data++ = (u_char) objid_val;
<a name="l01519" id="l01519"></a>01519             <span class="keywordflow">break</span>;
<a name="l01520" id="l01520"></a>01520 
<a name="l01521" id="l01521"></a>01521         <span class="keywordflow">case</span> 2:
<a name="l01522" id="l01522"></a>01522             *data++ = (u_char) ((objid_val &gt;&gt; 7) | 0x80);
<a name="l01523" id="l01523"></a>01523             *data++ = (u_char) (objid_val &amp; 0x07f);
<a name="l01524" id="l01524"></a>01524             <span class="keywordflow">break</span>;
<a name="l01525" id="l01525"></a>01525 
<a name="l01526" id="l01526"></a>01526         <span class="keywordflow">case</span> 3:
<a name="l01527" id="l01527"></a>01527             *data++ = (u_char) ((objid_val &gt;&gt; 14) | 0x80);
<a name="l01528" id="l01528"></a>01528             *data++ = (u_char) ((objid_val &gt;&gt; 7 &amp; 0x7f) | 0x80);
<a name="l01529" id="l01529"></a>01529             *data++ = (u_char) (objid_val &amp; 0x07f);
<a name="l01530" id="l01530"></a>01530             <span class="keywordflow">break</span>;
<a name="l01531" id="l01531"></a>01531 
<a name="l01532" id="l01532"></a>01532         <span class="keywordflow">case</span> 4:
<a name="l01533" id="l01533"></a>01533             *data++ = (u_char) ((objid_val &gt;&gt; 21) | 0x80);
<a name="l01534" id="l01534"></a>01534             *data++ = (u_char) ((objid_val &gt;&gt; 14 &amp; 0x7f) | 0x80);
<a name="l01535" id="l01535"></a>01535             *data++ = (u_char) ((objid_val &gt;&gt; 7 &amp; 0x7f) | 0x80);
<a name="l01536" id="l01536"></a>01536             *data++ = (u_char) (objid_val &amp; 0x07f);
<a name="l01537" id="l01537"></a>01537             <span class="keywordflow">break</span>;
<a name="l01538" id="l01538"></a>01538 
<a name="l01539" id="l01539"></a>01539         <span class="keywordflow">case</span> 5:
<a name="l01540" id="l01540"></a>01540             *data++ = (u_char) ((objid_val &gt;&gt; 28) | 0x80);
<a name="l01541" id="l01541"></a>01541             *data++ = (u_char) ((objid_val &gt;&gt; 21 &amp; 0x7f) | 0x80);
<a name="l01542" id="l01542"></a>01542             *data++ = (u_char) ((objid_val &gt;&gt; 14 &amp; 0x7f) | 0x80);
<a name="l01543" id="l01543"></a>01543             *data++ = (u_char) ((objid_val &gt;&gt; 7 &amp; 0x7f) | 0x80);
<a name="l01544" id="l01544"></a>01544             *data++ = (u_char) (objid_val &amp; 0x07f);
<a name="l01545" id="l01545"></a>01545             <span class="keywordflow">break</span>;
<a name="l01546" id="l01546"></a>01546         }
<a name="l01547" id="l01547"></a>01547     }
<a name="l01548" id="l01548"></a>01548 
<a name="l01549" id="l01549"></a>01549     <span class="comment">/*</span>
<a name="l01550" id="l01550"></a>01550 <span class="comment">     * return the length and data ptr </span>
<a name="l01551" id="l01551"></a>01551 <span class="comment">     */</span>
<a name="l01552" id="l01552"></a>01552     *datalength -= asnlength;
<a name="l01553" id="l01553"></a>01553     DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, initdatap, data - initdatap);
<a name="l01554" id="l01554"></a>01554     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  ObjID: "</span>));
<a name="l01555" id="l01555"></a>01555     DEBUGMSGOID((<span class="stringliteral">"dumpv_send"</span>, objid, objidlength));
<a name="l01556" id="l01556"></a>01556     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"\n"</span>));
<a name="l01557" id="l01557"></a>01557     <span class="keywordflow">return</span> data;
<a name="l01558" id="l01558"></a>01558 }
<a name="l01559" id="l01559"></a>01559 
<a name="l01579" id="l01579"></a>01579 u_char         *
<a name="l01580" id="l01580"></a>01580 asn_parse_null(u_char * data, <span class=
"keywordtype">size_t</span> * datalength, u_char * type)
<a name="l01581" id="l01581"></a>01581 {
<a name="l01582" id="l01582"></a>01582     <span class="comment">/*</span>
<a name="l01583" id="l01583"></a>01583 <span class="comment">     * ASN.1 null ::= 0x05 0x00</span>
<a name="l01584" id="l01584"></a>01584 <span class="comment">     */</span>
<a name="l01585" id="l01585"></a>01585     <span class="keyword">register</span> u_char *bufp = data;
<a name="l01586" id="l01586"></a>01586     u_long          asn_length;
<a name="l01587" id="l01587"></a>01587 
<a name="l01588" id="l01588"></a>01588     *type = *bufp++;
<a name="l01589" id="l01589"></a>01589     bufp = asn_parse_length(bufp, &amp;asn_length);
<a name="l01590" id="l01590"></a>01590     <span class="keywordflow">if</span> (bufp == NULL) {
<a name="l01591" id="l01591"></a>01591         ERROR_MSG(<span class="stringliteral">"parse null: bad length"</span>);
<a name="l01592" id="l01592"></a>01592         <span class="keywordflow">return</span> NULL;
<a name="l01593" id="l01593"></a>01593     }
<a name="l01594" id="l01594"></a>01594     <span class="keywordflow">if</span> (asn_length != 0) {
<a name="l01595" id="l01595"></a>01595         ERROR_MSG(<span class="stringliteral">"parse null: malformed ASN.1 null"</span>);
<a name="l01596" id="l01596"></a>01596         <span class="keywordflow">return</span> NULL;
<a name="l01597" id="l01597"></a>01597     }
<a name="l01598" id="l01598"></a>01598 
<a name="l01599" id="l01599"></a>01599     *datalength -= (bufp - data);
<a name="l01600" id="l01600"></a>01600 
<a name="l01601" id="l01601"></a>01601     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data);
<a name="l01602" id="l01602"></a>01602     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  NULL\n"</span>));
<a name="l01603" id="l01603"></a>01603 
<a name="l01604" id="l01604"></a>01604     <span class="keywordflow">return</span> bufp + asn_length;
<a name="l01605" id="l01605"></a>01605 }
<a name="l01606" id="l01606"></a>01606 
<a name="l01607" id="l01607"></a>01607 
<a name="l01628" id="l01628"></a>01628 u_char         *
<a name="l01629" id="l01629"></a>01629 asn_build_null(u_char * data, <span class=
"keywordtype">size_t</span> * datalength, u_char type)
<a name="l01630" id="l01630"></a>01630 {
<a name="l01631" id="l01631"></a>01631     <span class="comment">/*</span>
<a name="l01632" id="l01632"></a>01632 <span class="comment">     * ASN.1 null ::= 0x05 0x00</span>
<a name="l01633" id="l01633"></a>01633 <span class="comment">     */</span>
<a name="l01634" id="l01634"></a>01634 <span class="preprocessor">#ifndef NETSNMP_NO_DEBUGGING</span>
<a name="l01635" id="l01635"></a>01635     u_char         *initdatap = data;
<a name="l01636" id="l01636"></a>01636 <span class="preprocessor">#endif</span>
<a name="l01637" id="l01637"></a>01637     data = asn_build_header(data, datalength, type, 0);
<a name="l01638" id="l01638"></a>01638     DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, initdatap, data - initdatap);
<a name="l01639" id="l01639"></a>01639     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  NULL\n"</span>));
<a name="l01640" id="l01640"></a>01640     <span class="keywordflow">return</span> data;
<a name="l01641" id="l01641"></a>01641 }
<a name="l01642" id="l01642"></a>01642 
<a name="l01666" id="l01666"></a>01666 u_char         *
<a name="l01667" id="l01667"></a>01667 asn_parse_bitstring(u_char * data,
<a name="l01668" id="l01668"></a>01668                     <span class="keywordtype">size_t</span> * datalength,
<a name="l01669" id="l01669"></a>01669                     u_char * type, u_char * str, <span class=
"keywordtype">size_t</span> * strlength)
<a name="l01670" id="l01670"></a>01670 {
<a name="l01671" id="l01671"></a>01671     <span class="comment">/*</span>
<a name="l01672" id="l01672"></a>01672 <span class="comment">     * bitstring ::= 0x03 asnlength unused {byte}*</span>
<a name="l01673" id="l01673"></a>01673 <span class="comment">     */</span>
<a name="l01674" id="l01674"></a>01674     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse bitstring"</span>;
<a name="l01675" id="l01675"></a>01675     <span class="keyword">register</span> u_char *bufp = data;
<a name="l01676" id="l01676"></a>01676     u_long          asn_length;
<a name="l01677" id="l01677"></a>01677 
<a name="l01678" id="l01678"></a>01678     *type = *bufp++;
<a name="l01679" id="l01679"></a>01679     bufp = asn_parse_length(bufp, &amp;asn_length);
<a name="l01680" id="l01680"></a>01680     <span class="keywordflow">if</span> (_asn_parse_length_check(errpre, bufp, data,
<a name="l01681" id="l01681"></a>01681                                 asn_length, *datalength))
<a name="l01682" id="l01682"></a>01682         <span class="keywordflow">return</span> NULL;
<a name="l01683" id="l01683"></a>01683 
<a name="l01684" id="l01684"></a>01684     <span class="keywordflow">if</span> ((<span class=
"keywordtype">size_t</span>) asn_length &gt; *strlength) {
<a name="l01685" id="l01685"></a>01685         _asn_length_err(errpre, (<span class=
"keywordtype">size_t</span>) asn_length, *strlength);
<a name="l01686" id="l01686"></a>01686         <span class="keywordflow">return</span> NULL;
<a name="l01687" id="l01687"></a>01687     }
<a name="l01688" id="l01688"></a>01688     <span class="keywordflow">if</span> (_asn_bitstring_check(errpre, asn_length, *bufp))
<a name="l01689" id="l01689"></a>01689         <span class="keywordflow">return</span> NULL;
<a name="l01690" id="l01690"></a>01690 
<a name="l01691" id="l01691"></a>01691     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data);
<a name="l01692" id="l01692"></a>01692     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  Bitstring: "</span>));
<a name="l01693" id="l01693"></a>01693     DEBUGMSGHEX((<span class="stringliteral">"dumpv_recv"</span>, data, asn_length));
<a name="l01694" id="l01694"></a>01694     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"\n"</span>));
<a name="l01695" id="l01695"></a>01695 
<a name="l01696" id="l01696"></a>01696     memmove(str, bufp, asn_length);
<a name="l01697" id="l01697"></a>01697     *strlength = (int) asn_length;
<a name="l01698" id="l01698"></a>01698     *datalength -= (int) asn_length + (bufp - data);
<a name="l01699" id="l01699"></a>01699     <span class="keywordflow">return</span> bufp + asn_length;
<a name="l01700" id="l01700"></a>01700 }
<a name="l01701" id="l01701"></a>01701 
<a name="l01702" id="l01702"></a>01702 
<a name="l01725" id="l01725"></a>01725 u_char         *
<a name="l01726" id="l01726"></a>01726 asn_build_bitstring(u_char * data,
<a name="l01727" id="l01727"></a>01727                     <span class="keywordtype">size_t</span> * datalength,
<a name="l01728" id="l01728"></a>01728                     u_char type, <span class=
"keyword">const</span> u_char * str, <span class="keywordtype">size_t</span> strlength)
<a name="l01729" id="l01729"></a>01729 {
<a name="l01730" id="l01730"></a>01730     <span class="comment">/*</span>
<a name="l01731" id="l01731"></a>01731 <span class="comment">     * ASN.1 bit string ::= 0x03 asnlength unused {byte}*</span>
<a name="l01732" id="l01732"></a>01732 <span class="comment">     */</span>
<a name="l01733" id="l01733"></a>01733     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build bitstring"</span>;
<a name="l01734" id="l01734"></a>01734     <span class="keywordflow">if</span> (_asn_bitstring_check
<a name="l01735" id="l01735"></a>01735         (errpre, strlength, (u_char)((str) ? *str :  0)))
<a name="l01736" id="l01736"></a>01736         <span class="keywordflow">return</span> NULL;
<a name="l01737" id="l01737"></a>01737 
<a name="l01738" id="l01738"></a>01738     data = asn_build_header(data, datalength, type, strlength);
<a name="l01739" id="l01739"></a>01739     <span class=
"keywordflow">if</span> (_asn_build_header_check(errpre, data, *datalength, strlength))
<a name="l01740" id="l01740"></a>01740         <span class="keywordflow">return</span> NULL;
<a name="l01741" id="l01741"></a>01741 
<a name="l01742" id="l01742"></a>01742     <span class="keywordflow">if</span> (strlength &gt; 0 &amp;&amp; str)
<a name="l01743" id="l01743"></a>01743         memmove(data, str, strlength);
<a name="l01744" id="l01744"></a>01744     <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strlength &gt; 0 &amp;&amp; !str) {
<a name="l01745" id="l01745"></a>01745         ERROR_MSG(<span class=
"stringliteral">"no string passed into asn_build_bitstring\n"</span>);
<a name="l01746" id="l01746"></a>01746         <span class="keywordflow">return</span> NULL;
<a name="l01747" id="l01747"></a>01747     }
<a name="l01748" id="l01748"></a>01748 
<a name="l01749" id="l01749"></a>01749     *datalength -= strlength;
<a name="l01750" id="l01750"></a>01750     DEBUGDUMPSETUP(<span class="stringliteral">"send"</span>, data, strlength);
<a name="l01751" id="l01751"></a>01751     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  Bitstring: "</span>));
<a name="l01752" id="l01752"></a>01752     DEBUGMSGHEX((<span class="stringliteral">"dumpv_send"</span>, data, strlength));
<a name="l01753" id="l01753"></a>01753     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"\n"</span>));
<a name="l01754" id="l01754"></a>01754     <span class="keywordflow">return</span> data + strlength;
<a name="l01755" id="l01755"></a>01755 }
<a name="l01756" id="l01756"></a>01756 
<a name="l01779" id="l01779"></a>01779 u_char         *
<a name="l01780" id="l01780"></a>01780 asn_parse_unsigned_int64(u_char * data,
<a name="l01781" id="l01781"></a>01781                          <span class="keywordtype">size_t</span> * datalength,
<a name="l01782" id="l01782"></a>01782                          u_char * type,
<a name="l01783" id="l01783"></a>01783                          <span class="keyword">struct</span> <a class="code" href=
"structcounter64.html">counter64</a> * cp, <span class="keywordtype">size_t</span> countersize)
<a name="l01784" id="l01784"></a>01784 {
<a name="l01785" id="l01785"></a>01785     <span class="comment">/*</span>
<a name="l01786" id="l01786"></a>01786 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
<a name="l01787" id="l01787"></a>01787 <span class="comment">     */</span>
<a name="l01788" id="l01788"></a>01788     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse uint64"</span>;
<a name="l01789" id="l01789"></a>01789     <span class="keyword">const</span> <span class=
"keywordtype">int</span>       uint64sizelimit = (4 * 2) + 1;
<a name="l01790" id="l01790"></a>01790     <span class="keyword">register</span> u_char *bufp = data;
<a name="l01791" id="l01791"></a>01791     u_long          asn_length;
<a name="l01792" id="l01792"></a>01792     <span class="keyword">register</span> u_long low = 0, high = 0;
<a name="l01793" id="l01793"></a>01793 
<a name="l01794" id="l01794"></a>01794     <span class="keywordflow">if</span> (countersize != <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a>)) {
<a name="l01795" id="l01795"></a>01795         _asn_size_err(errpre, countersize, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a>));
<a name="l01796" id="l01796"></a>01796         <span class="keywordflow">return</span> NULL;
<a name="l01797" id="l01797"></a>01797     }
<a name="l01798" id="l01798"></a>01798     *type = *bufp++;
<a name="l01799" id="l01799"></a>01799     bufp = asn_parse_length(bufp, &amp;asn_length);
<a name="l01800" id="l01800"></a>01800     <span class="keywordflow">if</span> (_asn_parse_length_check
<a name="l01801" id="l01801"></a>01801         (errpre, bufp, data, asn_length, *datalength))
<a name="l01802" id="l01802"></a>01802         <span class="keywordflow">return</span> NULL;
<a name="l01803" id="l01803"></a>01803 
<a name="l01804" id="l01804"></a>01804     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data);
<a name="l01805" id="l01805"></a>01805 <span class="preprocessor">#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES</span>
<a name="l01806" id="l01806"></a>01806     <span class="comment">/*</span>
<a name="l01807" id="l01807"></a>01807 <span class="comment">     * 64 bit counters as opaque </span>
<a name="l01808" id="l01808"></a>01808 <span class="comment">     */</span>
<a name="l01809" id="l01809"></a>01809     <span class="keywordflow">if</span> ((*type == ASN_OPAQUE) &amp;&amp;
<a name="l01810" id="l01810"></a>01810         (asn_length &lt;= ASN_OPAQUE_COUNTER64_MX_BER_LEN) &amp;&amp;
<a name="l01811" id="l01811"></a>01811         (*bufp == ASN_OPAQUE_TAG1) &amp;&amp;
<a name="l01812" id="l01812"></a>01812         ((*(bufp + 1) == ASN_OPAQUE_COUNTER64) ||
<a name="l01813" id="l01813"></a>01813          (*(bufp + 1) == ASN_OPAQUE_U64))) {
<a name="l01814" id="l01814"></a>01814         <span class="comment">/*</span>
<a name="l01815" id="l01815"></a>01815 <span class="comment">         * change type to Counter64 or U64 </span>
<a name="l01816" id="l01816"></a>01816 <span class="comment">         */</span>
<a name="l01817" id="l01817"></a>01817         *type = *(bufp + 1);
<a name="l01818" id="l01818"></a>01818         <span class="comment">/*</span>
<a name="l01819" id="l01819"></a>01819 <span class="comment">         * value is encoded as special format </span>
<a name="l01820" id="l01820"></a>01820 <span class="comment">         */</span>
<a name="l01821" id="l01821"></a>01821         bufp = asn_parse_length(bufp + 2, &amp;asn_length);
<a name="l01822" id="l01822"></a>01822         <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse opaque uint64"</span>, bufp, data,
<a name="l01823" id="l01823"></a>01823                                     asn_length, *datalength))
<a name="l01824" id="l01824"></a>01824             <span class="keywordflow">return</span> NULL;
<a name="l01825" id="l01825"></a>01825     }
<a name="l01826" id="l01826"></a>01826 <span class="preprocessor">#endif                          </span><span class=
"comment">/* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */</span>
<a name="l01827" id="l01827"></a>01827     <span class="keywordflow">if</span> (((<span class=
"keywordtype">int</span>) asn_length &gt; uint64sizelimit) ||
<a name="l01828" id="l01828"></a>01828         (((<span class=
"keywordtype">int</span>) asn_length == uint64sizelimit) &amp;&amp; *bufp != 0x00)) {
<a name="l01829" id="l01829"></a>01829         _asn_length_err(errpre, (<span class=
"keywordtype">size_t</span>) asn_length, uint64sizelimit);
<a name="l01830" id="l01830"></a>01830         <span class="keywordflow">return</span> NULL;
<a name="l01831" id="l01831"></a>01831     }
<a name="l01832" id="l01832"></a>01832     *datalength -= (int) asn_length + (bufp - data);
<a name="l01833" id="l01833"></a>01833     <span class="keywordflow">if</span> (*bufp &amp; 0x80) {
<a name="l01834" id="l01834"></a>01834         low = 0xFFFFFF;     <span class=
"comment">/* first byte bit 1 means start the data with 1s */</span>
<a name="l01835" id="l01835"></a>01835         high = 0xFFFFFF;
<a name="l01836" id="l01836"></a>01836     }
<a name="l01837" id="l01837"></a>01837 
<a name="l01838" id="l01838"></a>01838     <span class="keywordflow">while</span> (asn_length--) {
<a name="l01839" id=
"l01839"></a>01839         high = ((0x00FFFFFF &amp; high) &lt;&lt; 8) | ((low &amp; 0xFF000000) &gt;&gt; 24);
<a name="l01840" id="l01840"></a>01840         low = ((low &amp; 0x00FFFFFF) &lt;&lt; 8) | *bufp++;
<a name="l01841" id="l01841"></a>01841     }
<a name="l01842" id="l01842"></a>01842 
<a name="l01843" id="l01843"></a>01843     CHECK_OVERFLOW_U(high,6);
<a name="l01844" id="l01844"></a>01844     CHECK_OVERFLOW_U(low,6);
<a name="l01845" id="l01845"></a>01845 
<a name="l01846" id="l01846"></a>01846     cp-&gt;low = low;
<a name="l01847" id="l01847"></a>01847     cp-&gt;high = high;
<a name="l01848" id="l01848"></a>01848 
<a name="l01849" id="l01849"></a>01849     DEBUGIF(<span class="stringliteral">"dumpv_recv"</span>) {
<a name="l01850" id="l01850"></a>01850         <span class="keywordtype">char</span>            i64buf[I64CHARSZ + 1];
<a name="l01851" id="l01851"></a>01851         printU64(i64buf, cp);
<a name="l01852" id="l01852"></a>01852         DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"Counter64: %s"</span>, i64buf));
<a name="l01853" id="l01853"></a>01853     }
<a name="l01854" id="l01854"></a>01854 
<a name="l01855" id="l01855"></a>01855     <span class="keywordflow">return</span> bufp;
<a name="l01856" id="l01856"></a>01856 }
<a name="l01857" id="l01857"></a>01857 
<a name="l01858" id="l01858"></a>01858 
<a name="l01880" id="l01880"></a>01880 u_char         *
<a name="l01881" id="l01881"></a>01881 asn_build_unsigned_int64(u_char * data,
<a name="l01882" id="l01882"></a>01882                          <span class="keywordtype">size_t</span> * datalength,
<a name="l01883" id="l01883"></a>01883                          u_char type,
<a name="l01884" id="l01884"></a>01884                          <span class="keyword">const</span> <span class=
"keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a> * cp, <span class=
"keywordtype">size_t</span> countersize)
<a name="l01885" id="l01885"></a>01885 {
<a name="l01886" id="l01886"></a>01886     <span class="comment">/*</span>
<a name="l01887" id="l01887"></a>01887 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
<a name="l01888" id="l01888"></a>01888 <span class="comment">     */</span>
<a name="l01889" id="l01889"></a>01889 
<a name="l01890" id="l01890"></a>01890     <span class="keyword">register</span> u_long low, high;
<a name="l01891" id="l01891"></a>01891     <span class="keyword">register</span> u_long mask, mask2;
<a name="l01892" id="l01892"></a>01892     <span class="keywordtype">int</span>             add_null_byte = 0;
<a name="l01893" id="l01893"></a>01893     <span class="keywordtype">size_t</span>          intsize;
<a name="l01894" id="l01894"></a>01894 <span class="preprocessor">#ifndef NETSNMP_NO_DEBUGGING</span>
<a name="l01895" id="l01895"></a>01895     u_char         *initdatap = data;
<a name="l01896" id="l01896"></a>01896 <span class="preprocessor">#endif</span>
<a name="l01897" id="l01897"></a>01897 
<a name="l01898" id="l01898"></a>01898     <span class="keywordflow">if</span> (countersize != <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a>)) {
<a name="l01899" id="l01899"></a>01899         _asn_size_err(<span class="stringliteral">"build uint64"</span>, countersize,
<a name="l01900" id="l01900"></a>01900                       <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a>));
<a name="l01901" id="l01901"></a>01901         <span class="keywordflow">return</span> NULL;
<a name="l01902" id="l01902"></a>01902     }
<a name="l01903" id="l01903"></a>01903     intsize = 8;
<a name="l01904" id="l01904"></a>01904     low = cp-&gt;low;
<a name="l01905" id="l01905"></a>01905     high = cp-&gt;high;
<a name="l01906" id="l01906"></a>01906 
<a name="l01907" id="l01907"></a>01907     CHECK_OVERFLOW_U(high,7);
<a name="l01908" id="l01908"></a>01908     CHECK_OVERFLOW_U(low,7);
<a name="l01909" id="l01909"></a>01909 
<a name="l01910" id="l01910"></a>01910     mask = ((u_long) 0xFF) &lt;&lt; (8 * (<span class="keyword">sizeof</span>(long) - 1));
<a name="l01911" id="l01911"></a>01911     <span class="comment">/*</span>
<a name="l01912" id="l01912"></a>01912 <span class="comment">     * mask is 0xFF000000 on a big-endian machine </span>
<a name="l01913" id="l01913"></a>01913 <span class="comment">     */</span>
<a name="l01914" id="l01914"></a>01914     <span class=
"keywordflow">if</span> ((u_char) ((high &amp; mask) &gt;&gt; (8 * (<span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>) - 1))) &amp; 0x80) {
<a name="l01915" id="l01915"></a>01915         <span class="comment">/*</span>
<a name="l01916" id="l01916"></a>01916 <span class="comment">         * if MSB is set </span>
<a name="l01917" id="l01917"></a>01917 <span class="comment">         */</span>
<a name="l01918" id="l01918"></a>01918         add_null_byte = 1;
<a name="l01919" id="l01919"></a>01919         intsize++;
<a name="l01920" id="l01920"></a>01920     } <span class="keywordflow">else</span> {
<a name="l01921" id="l01921"></a>01921         <span class="comment">/*</span>
<a name="l01922" id="l01922"></a>01922 <span class=
"comment">         * Truncate "unnecessary" bytes off of the most significant end of this 2's</span>
<a name="l01923" id="l01923"></a>01923 <span class="comment">         * complement integer.</span>
<a name="l01924" id="l01924"></a>01924 <span class=
"comment">         * There should be no sequence of 9 consecutive 1's or 0's at the most</span>
<a name="l01925" id="l01925"></a>01925 <span class="comment">         * significant end of the integer.</span>
<a name="l01926" id="l01926"></a>01926 <span class="comment">         */</span>
<a name="l01927" id="l01927"></a>01927         mask2 = ((u_long) 0x1FF) &lt;&lt; ((8 * (<span class=
"keyword">sizeof</span>(long) - 1)) - 1);
<a name="l01928" id="l01928"></a>01928         <span class="comment">/*</span>
<a name="l01929" id="l01929"></a>01929 <span class="comment">         * mask2 is 0xFF800000 on a big-endian machine </span>
<a name="l01930" id="l01930"></a>01930 <span class="comment">         */</span>
<a name="l01931" id="l01931"></a>01931         <span class=
"keywordflow">while</span> ((((high &amp; mask2) == 0) || ((high &amp; mask2) == mask2))
<a name="l01932" id="l01932"></a>01932                &amp;&amp; intsize &gt; 1) {
<a name="l01933" id="l01933"></a>01933             intsize--;
<a name="l01934" id="l01934"></a>01934             high = (high &lt;&lt; 8)
<a name="l01935" id="l01935"></a>01935                 | ((low &amp; mask) &gt;&gt; (8 * (<span class=
"keyword">sizeof</span>(long) - 1)));
<a name="l01936" id="l01936"></a>01936             low &lt;&lt;= 8;
<a name="l01937" id="l01937"></a>01937         }
<a name="l01938" id="l01938"></a>01938     }
<a name="l01939" id="l01939"></a>01939 <span class="preprocessor">#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES</span>
<a name="l01940" id="l01940"></a>01940     <span class="comment">/*</span>
<a name="l01941" id="l01941"></a>01941 <span class=
"comment">     * encode a Counter64 as an opaque (it also works in SNMPv1) </span>
<a name="l01942" id="l01942"></a>01942 <span class="comment">     */</span>
<a name="l01943" id="l01943"></a>01943     <span class="comment">/*</span>
<a name="l01944" id="l01944"></a>01944 <span class="comment">     * turn into Opaque holding special tagged value </span>
<a name="l01945" id="l01945"></a>01945 <span class="comment">     */</span>
<a name="l01946" id="l01946"></a>01946     <span class="keywordflow">if</span> (type == ASN_OPAQUE_COUNTER64) {
<a name="l01947" id="l01947"></a>01947         <span class="comment">/*</span>
<a name="l01948" id="l01948"></a>01948 <span class="comment">         * put the tag and length for the Opaque wrapper </span>
<a name="l01949" id="l01949"></a>01949 <span class="comment">         */</span>
<a name="l01950" id="l01950"></a>01950         data = asn_build_header(data, datalength, ASN_OPAQUE, intsize + 3);
<a name="l01951" id="l01951"></a>01951         <span class="keywordflow">if</span> (_asn_build_header_check
<a name="l01952" id="l01952"></a>01952             (<span class=
"stringliteral">"build counter u64"</span>, data, *datalength, intsize + 3))
<a name="l01953" id="l01953"></a>01953             <span class="keywordflow">return</span> NULL;
<a name="l01954" id="l01954"></a>01954 
<a name="l01955" id="l01955"></a>01955         <span class="comment">/*</span>
<a name="l01956" id="l01956"></a>01956 <span class="comment">         * put the special tag and length </span>
<a name="l01957" id="l01957"></a>01957 <span class="comment">         */</span>
<a name="l01958" id="l01958"></a>01958         *data++ = ASN_OPAQUE_TAG1;
<a name="l01959" id="l01959"></a>01959         *data++ = ASN_OPAQUE_COUNTER64;
<a name="l01960" id="l01960"></a>01960         *data++ = (u_char) intsize;
<a name="l01961" id="l01961"></a>01961         *datalength = *datalength - 3;
<a name="l01962" id="l01962"></a>01962     } <span class="keywordflow">else</span>
<a name="l01963" id="l01963"></a>01963         <span class="comment">/*</span>
<a name="l01964" id="l01964"></a>01964 <span class="comment">         * Encode the Unsigned int64 in an opaque </span>
<a name="l01965" id="l01965"></a>01965 <span class="comment">         */</span>
<a name="l01966" id="l01966"></a>01966         <span class="comment">/*</span>
<a name="l01967" id="l01967"></a>01967 <span class="comment">         * turn into Opaque holding special tagged value </span>
<a name="l01968" id="l01968"></a>01968 <span class="comment">         */</span>
<a name="l01969" id="l01969"></a>01969     <span class="keywordflow">if</span> (type == ASN_OPAQUE_U64) {
<a name="l01970" id="l01970"></a>01970         <span class="comment">/*</span>
<a name="l01971" id="l01971"></a>01971 <span class="comment">         * put the tag and length for the Opaque wrapper </span>
<a name="l01972" id="l01972"></a>01972 <span class="comment">         */</span>
<a name="l01973" id="l01973"></a>01973         data = asn_build_header(data, datalength, ASN_OPAQUE, intsize + 3);
<a name="l01974" id="l01974"></a>01974         <span class="keywordflow">if</span> (_asn_build_header_check
<a name="l01975" id="l01975"></a>01975             (<span class=
"stringliteral">"build opaque u64"</span>, data, *datalength, intsize + 3))
<a name="l01976" id="l01976"></a>01976             <span class="keywordflow">return</span> NULL;
<a name="l01977" id="l01977"></a>01977 
<a name="l01978" id="l01978"></a>01978         <span class="comment">/*</span>
<a name="l01979" id="l01979"></a>01979 <span class="comment">         * put the special tag and length </span>
<a name="l01980" id="l01980"></a>01980 <span class="comment">         */</span>
<a name="l01981" id="l01981"></a>01981         *data++ = ASN_OPAQUE_TAG1;
<a name="l01982" id="l01982"></a>01982         *data++ = ASN_OPAQUE_U64;
<a name="l01983" id="l01983"></a>01983         *data++ = (u_char) intsize;
<a name="l01984" id="l01984"></a>01984         *datalength = *datalength - 3;
<a name="l01985" id="l01985"></a>01985     } <span class="keywordflow">else</span> {
<a name="l01986" id="l01986"></a>01986 <span class="preprocessor">#endif                          </span><span class=
"comment">/* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */</span>
<a name="l01987" id="l01987"></a>01987         data = asn_build_header(data, datalength, type, intsize);
<a name="l01988" id="l01988"></a>01988         <span class="keywordflow">if</span> (_asn_build_header_check
<a name="l01989" id="l01989"></a>01989             (<span class=
"stringliteral">"build uint64"</span>, data, *datalength, intsize))
<a name="l01990" id="l01990"></a>01990             <span class="keywordflow">return</span> NULL;
<a name="l01991" id="l01991"></a>01991 
<a name="l01992" id="l01992"></a>01992 <span class="preprocessor">#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES</span>
<a name="l01993" id="l01993"></a>01993     }
<a name="l01994" id="l01994"></a>01994 <span class="preprocessor">#endif                          </span><span class=
"comment">/* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */</span>
<a name="l01995" id="l01995"></a>01995     *datalength -= intsize;
<a name="l01996" id="l01996"></a>01996     <span class="keywordflow">if</span> (add_null_byte == 1) {
<a name="l01997" id="l01997"></a>01997         *data++ = <span class="charliteral">'\0'</span>;
<a name="l01998" id="l01998"></a>01998         intsize--;
<a name="l01999" id="l01999"></a>01999     }
<a name="l02000" id="l02000"></a>02000     <span class="keywordflow">while</span> (intsize--) {
<a name="l02001" id="l02001"></a>02001         *data++ = (u_char) ((high &amp; mask) &gt;&gt; (8 * (<span class=
"keyword">sizeof</span>(long) - 1)));
<a name="l02002" id="l02002"></a>02002         high = (high &lt;&lt; 8)
<a name="l02003" id="l02003"></a>02003             | ((low &amp; mask) &gt;&gt; (8 * (<span class=
"keyword">sizeof</span>(long) - 1)));
<a name="l02004" id="l02004"></a>02004         low &lt;&lt;= 8;
<a name="l02005" id="l02005"></a>02005 
<a name="l02006" id="l02006"></a>02006     }
<a name="l02007" id="l02007"></a>02007     DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, initdatap, data - initdatap);
<a name="l02008" id="l02008"></a>02008     DEBUGIF(<span class="stringliteral">"dumpv_send"</span>) {
<a name="l02009" id="l02009"></a>02009         <span class="keywordtype">char</span>            i64buf[I64CHARSZ + 1];
<a name="l02010" id="l02010"></a>02010         printU64(i64buf, cp);
<a name="l02011" id="l02011"></a>02011         DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"%s"</span>, i64buf));
<a name="l02012" id="l02012"></a>02012     }
<a name="l02013" id="l02013"></a>02013     <span class="keywordflow">return</span> data;
<a name="l02014" id="l02014"></a>02014 }
<a name="l02015" id="l02015"></a>02015 
<a name="l02016" id="l02016"></a>02016 <span class="preprocessor">#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES</span>
<a name="l02017" id="l02017"></a>02017 
<a name="l02018" id="l02018"></a>02018 
<a name="l02042" id="l02042"></a>02042 u_char         *
<a name="l02043" id="l02043"></a>02043 asn_parse_signed_int64(u_char * data,
<a name="l02044" id="l02044"></a>02044                        <span class="keywordtype">size_t</span> * datalength,
<a name="l02045" id="l02045"></a>02045                        u_char * type,
<a name="l02046" id="l02046"></a>02046                        <span class="keyword">struct</span> <a class="code" href=
"structcounter64.html">counter64</a> * cp, <span class="keywordtype">size_t</span> countersize)
<a name="l02047" id="l02047"></a>02047 {
<a name="l02048" id="l02048"></a>02048     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"parse int64"</span>;
<a name="l02049" id="l02049"></a>02049     <span class="keyword">const</span> <span class=
"keywordtype">int</span>       int64sizelimit = (4 * 2) + 1;
<a name="l02050" id="l02050"></a>02050     <span class="keywordtype">char</span>            ebuf[128];
<a name="l02051" id="l02051"></a>02051     <span class="keyword">register</span> u_char *bufp = data;
<a name="l02052" id="l02052"></a>02052     u_long          asn_length;
<a name="l02053" id="l02053"></a>02053     <span class="keyword">register</span> u_int  low = 0, high = 0;
<a name="l02054" id="l02054"></a>02054 
<a name="l02055" id="l02055"></a>02055     <span class="keywordflow">if</span> (countersize != <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a>)) {
<a name="l02056" id="l02056"></a>02056         _asn_size_err(errpre, countersize, <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a>));
<a name="l02057" id="l02057"></a>02057         <span class="keywordflow">return</span> NULL;
<a name="l02058" id="l02058"></a>02058     }
<a name="l02059" id="l02059"></a>02059     *type = *bufp++;
<a name="l02060" id="l02060"></a>02060     bufp = asn_parse_length(bufp, &amp;asn_length);
<a name="l02061" id="l02061"></a>02061     <span class="keywordflow">if</span> (_asn_parse_length_check
<a name="l02062" id="l02062"></a>02062         (errpre, bufp, data, asn_length, *datalength))
<a name="l02063" id="l02063"></a>02063         <span class="keywordflow">return</span> NULL;
<a name="l02064" id="l02064"></a>02064 
<a name="l02065" id="l02065"></a>02065     DEBUGDUMPSETUP(<span class="stringliteral">"recv"</span>, data, bufp - data);
<a name="l02066" id="l02066"></a>02066     <span class="keywordflow">if</span> ((*type == ASN_OPAQUE) &amp;&amp;
<a name="l02067" id="l02067"></a>02067         (asn_length &lt;= ASN_OPAQUE_COUNTER64_MX_BER_LEN) &amp;&amp;
<a name="l02068" id="l02068"></a>02068         (*bufp == ASN_OPAQUE_TAG1) &amp;&amp; (*(bufp + 1) == ASN_OPAQUE_I64)) {
<a name="l02069" id="l02069"></a>02069         <span class="comment">/*</span>
<a name="l02070" id="l02070"></a>02070 <span class="comment">         * change type to Int64 </span>
<a name="l02071" id="l02071"></a>02071 <span class="comment">         */</span>
<a name="l02072" id="l02072"></a>02072         *type = *(bufp + 1);
<a name="l02073" id="l02073"></a>02073         <span class="comment">/*</span>
<a name="l02074" id="l02074"></a>02074 <span class="comment">         * value is encoded as special format </span>
<a name="l02075" id="l02075"></a>02075 <span class="comment">         */</span>
<a name="l02076" id="l02076"></a>02076         bufp = asn_parse_length(bufp + 2, &amp;asn_length);
<a name="l02077" id="l02077"></a>02077         <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse opaque int64"</span>, bufp, data,
<a name="l02078" id="l02078"></a>02078                                     asn_length, *datalength))
<a name="l02079" id="l02079"></a>02079             <span class="keywordflow">return</span> NULL;
<a name="l02080" id="l02080"></a>02080     }
<a name="l02081" id="l02081"></a>02081     <span class="comment">/*</span>
<a name="l02082" id="l02082"></a>02082 <span class=
"comment">     * this should always have been true until snmp gets int64 PDU types </span>
<a name="l02083" id="l02083"></a>02083 <span class="comment">     */</span>
<a name="l02084" id="l02084"></a>02084     <span class="keywordflow">else</span> {
<a name="l02085" id="l02085"></a>02085         snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l02086" id="l02086"></a>02086                 <span class=
"stringliteral">"%s: wrong type: %d, len %d, buf bytes (%02X,%02X)"</span>,
<a name="l02087" id="l02087"></a>02087                 errpre, *type, (<span class=
"keywordtype">int</span>) asn_length, *bufp, *(bufp + 1));
<a name="l02088" id="l02088"></a>02088         ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l02089" id="l02089"></a>02089         ERROR_MSG(ebuf);
<a name="l02090" id="l02090"></a>02090         <span class="keywordflow">return</span> NULL;
<a name="l02091" id="l02091"></a>02091     }
<a name="l02092" id="l02092"></a>02092     <span class="keywordflow">if</span> (((<span class=
"keywordtype">int</span>) asn_length &gt; int64sizelimit) ||
<a name="l02093" id="l02093"></a>02093         (((<span class=
"keywordtype">int</span>) asn_length == int64sizelimit) &amp;&amp; *bufp != 0x00)) {
<a name="l02094" id="l02094"></a>02094         _asn_length_err(errpre, (<span class=
"keywordtype">size_t</span>) asn_length, int64sizelimit);
<a name="l02095" id="l02095"></a>02095         <span class="keywordflow">return</span> NULL;
<a name="l02096" id="l02096"></a>02096     }
<a name="l02097" id="l02097"></a>02097     *datalength -= (int) asn_length + (bufp - data);
<a name="l02098" id="l02098"></a>02098     <span class="keywordflow">if</span> (*bufp &amp; 0x80) {
<a name="l02099" id="l02099"></a>02099         low = 0xFFFFFF;     <span class=
"comment">/* first byte bit 1 means start the data with 1s */</span>
<a name="l02100" id="l02100"></a>02100         high = 0xFFFFFF;
<a name="l02101" id="l02101"></a>02101     }
<a name="l02102" id="l02102"></a>02102 
<a name="l02103" id="l02103"></a>02103     <span class="keywordflow">while</span> (asn_length--) {
<a name="l02104" id=
"l02104"></a>02104         high = ((0x00FFFFFF &amp; high) &lt;&lt; 8) | ((low &amp; 0xFF000000) &gt;&gt; 24);
<a name="l02105" id="l02105"></a>02105         low = ((low &amp; 0x00FFFFFF) &lt;&lt; 8) | *bufp++;
<a name="l02106" id="l02106"></a>02106     }
<a name="l02107" id="l02107"></a>02107 
<a name="l02108" id="l02108"></a>02108     CHECK_OVERFLOW_U(high,8);
<a name="l02109" id="l02109"></a>02109     CHECK_OVERFLOW_U(low,8);
<a name="l02110" id="l02110"></a>02110 
<a name="l02111" id="l02111"></a>02111     cp-&gt;low = low;
<a name="l02112" id="l02112"></a>02112     cp-&gt;high = high;
<a name="l02113" id="l02113"></a>02113 
<a name="l02114" id="l02114"></a>02114     DEBUGIF(<span class="stringliteral">"dumpv_recv"</span>) {
<a name="l02115" id="l02115"></a>02115         <span class="keywordtype">char</span>            i64buf[I64CHARSZ + 1];
<a name="l02116" id="l02116"></a>02116         printI64(i64buf, cp);
<a name="l02117" id="l02117"></a>02117         DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"Integer64: %s"</span>, i64buf));
<a name="l02118" id="l02118"></a>02118     }
<a name="l02119" id="l02119"></a>02119 
<a name="l02120" id="l02120"></a>02120     <span class="keywordflow">return</span> bufp;
<a name="l02121" id="l02121"></a>02121 }
<a name="l02122" id="l02122"></a>02122 
<a name="l02123" id="l02123"></a>02123 
<a name="l02124" id="l02124"></a>02124 
<a name="l02146" id="l02146"></a>02146 u_char         *
<a name="l02147" id="l02147"></a>02147 asn_build_signed_int64(u_char * data,
<a name="l02148" id="l02148"></a>02148                        <span class="keywordtype">size_t</span> * datalength,
<a name="l02149" id="l02149"></a>02149                        u_char type,
<a name="l02150" id="l02150"></a>02150                        <span class="keyword">const</span> <span class=
"keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a> * cp, <span class=
"keywordtype">size_t</span> countersize)
<a name="l02151" id="l02151"></a>02151 {
<a name="l02152" id="l02152"></a>02152     <span class="comment">/*</span>
<a name="l02153" id="l02153"></a>02153 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
<a name="l02154" id="l02154"></a>02154 <span class="comment">     */</span>
<a name="l02155" id="l02155"></a>02155 
<a name="l02156" id="l02156"></a>02156     <span class="keyword">struct </span><a class="code" href=
"structcounter64.html">counter64</a> c64;
<a name="l02157" id="l02157"></a>02157     <span class="keyword">register</span> u_int  mask, mask2;
<a name="l02158" id="l02158"></a>02158     u_long          low, high;
<a name="l02159" id="l02159"></a>02159     <span class="keywordtype">size_t</span>          intsize;
<a name="l02160" id="l02160"></a>02160 <span class="preprocessor">#ifndef NETSNMP_NO_DEBUGGING</span>
<a name="l02161" id="l02161"></a>02161     u_char         *initdatap = data;
<a name="l02162" id="l02162"></a>02162 <span class="preprocessor">#endif</span>
<a name="l02163" id="l02163"></a>02163 
<a name="l02164" id="l02164"></a>02164     <span class="keywordflow">if</span> (countersize != <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a>)) {
<a name="l02165" id="l02165"></a>02165         _asn_size_err(<span class="stringliteral">"build int64"</span>, countersize,
<a name="l02166" id="l02166"></a>02166                       <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a>));
<a name="l02167" id="l02167"></a>02167         <span class="keywordflow">return</span> NULL;
<a name="l02168" id="l02168"></a>02168     }
<a name="l02169" id="l02169"></a>02169     intsize = 8;
<a name="l02170" id="l02170"></a>02170     memcpy(&amp;c64, cp, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a>)); <span class=
"comment">/* we're may modify it */</span>
<a name="l02171" id="l02171"></a>02171     low = c64.low;
<a name="l02172" id="l02172"></a>02172     high = c64.high;
<a name="l02173" id="l02173"></a>02173 
<a name="l02174" id="l02174"></a>02174     CHECK_OVERFLOW_S(high,9);
<a name="l02175" id="l02175"></a>02175     CHECK_OVERFLOW_U(low,9);
<a name="l02176" id="l02176"></a>02176 
<a name="l02177" id="l02177"></a>02177     <span class="comment">/*</span>
<a name="l02178" id="l02178"></a>02178 <span class=
"comment">     * Truncate "unnecessary" bytes off of the most significant end of this</span>
<a name="l02179" id="l02179"></a>02179 <span class=
"comment">     * 2's complement integer.  There should be no sequence of 9</span>
<a name="l02180" id="l02180"></a>02180 <span class=
"comment">     * consecutive 1's or 0's at the most significant end of the</span>
<a name="l02181" id="l02181"></a>02181 <span class="comment">     * integer.</span>
<a name="l02182" id="l02182"></a>02182 <span class="comment">     */</span>
<a name="l02183" id="l02183"></a>02183     mask = ((u_int) 0xFF) &lt;&lt; (8 * (<span class="keyword">sizeof</span>(u_int) - 1));
<a name="l02184" id="l02184"></a>02184     mask2 = ((u_int) 0x1FF) &lt;&lt; ((8 * (<span class=
"keyword">sizeof</span>(u_int) - 1)) - 1);
<a name="l02185" id="l02185"></a>02185     <span class="comment">/*</span>
<a name="l02186" id="l02186"></a>02186 <span class="comment">     * mask is 0xFF800000 on a big-endian machine </span>
<a name="l02187" id="l02187"></a>02187 <span class="comment">     */</span>
<a name="l02188" id="l02188"></a>02188     <span class=
"keywordflow">while</span> ((((high &amp; mask2) == 0) || ((high &amp; mask2) == mask2))
<a name="l02189" id="l02189"></a>02189            &amp;&amp; intsize &gt; 1) {
<a name="l02190" id="l02190"></a>02190         intsize--;
<a name="l02191" id="l02191"></a>02191         high = (high &lt;&lt; 8)
<a name="l02192" id="l02192"></a>02192             | ((low &amp; mask) &gt;&gt; (8 * (<span class=
"keyword">sizeof</span>(u_int) - 1)));
<a name="l02193" id="l02193"></a>02193         low &lt;&lt;= 8;
<a name="l02194" id="l02194"></a>02194     }
<a name="l02195" id="l02195"></a>02195     <span class="comment">/*</span>
<a name="l02196" id="l02196"></a>02196 <span class=
"comment">     * until a real int64 gets incorperated into SNMP, we are going to</span>
<a name="l02197" id="l02197"></a>02197 <span class=
"comment">     * encode it as an opaque instead.  First, we build the opaque</span>
<a name="l02198" id="l02198"></a>02198 <span class=
"comment">     * header and then the int64 tag type we use to mark it as an</span>
<a name="l02199" id="l02199"></a>02199 <span class="comment">     * int64 in the opaque string. </span>
<a name="l02200" id="l02200"></a>02200 <span class="comment">     */</span>
<a name="l02201" id="l02201"></a>02201     data = asn_build_header(data, datalength, ASN_OPAQUE, intsize + 3);
<a name="l02202" id="l02202"></a>02202     <span class="keywordflow">if</span> (_asn_build_header_check
<a name="l02203" id="l02203"></a>02203         (<span class=
"stringliteral">"build int64"</span>, data, *datalength, intsize + 3))
<a name="l02204" id="l02204"></a>02204         <span class="keywordflow">return</span> NULL;
<a name="l02205" id="l02205"></a>02205 
<a name="l02206" id="l02206"></a>02206     *data++ = ASN_OPAQUE_TAG1;
<a name="l02207" id="l02207"></a>02207     *data++ = ASN_OPAQUE_I64;
<a name="l02208" id="l02208"></a>02208     *data++ = (u_char) intsize;
<a name="l02209" id="l02209"></a>02209     *datalength -= (3 + intsize);
<a name="l02210" id="l02210"></a>02210 
<a name="l02211" id="l02211"></a>02211     <span class="keywordflow">while</span> (intsize--) {
<a name="l02212" id="l02212"></a>02212         *data++ = (u_char) ((high &amp; mask) &gt;&gt; (8 * (<span class=
"keyword">sizeof</span>(u_int) - 1)));
<a name="l02213" id="l02213"></a>02213         high = (high &lt;&lt; 8)
<a name="l02214" id="l02214"></a>02214             | ((low &amp; mask) &gt;&gt; (8 * (<span class=
"keyword">sizeof</span>(u_int) - 1)));
<a name="l02215" id="l02215"></a>02215         low &lt;&lt;= 8;
<a name="l02216" id="l02216"></a>02216     }
<a name="l02217" id="l02217"></a>02217     DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, initdatap, data - initdatap);
<a name="l02218" id="l02218"></a>02218     DEBUGIF(<span class="stringliteral">"dumpv_send"</span>) {
<a name="l02219" id="l02219"></a>02219         <span class="keywordtype">char</span>            i64buf[I64CHARSZ + 1];
<a name="l02220" id="l02220"></a>02220         printU64(i64buf, cp);
<a name="l02221" id="l02221"></a>02221         DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"%s"</span>, i64buf));
<a name="l02222" id="l02222"></a>02222     }
<a name="l02223" id="l02223"></a>02223     <span class="keywordflow">return</span> data;
<a name="l02224" id="l02224"></a>02224 }
<a name="l02225" id="l02225"></a>02225 
<a name="l02226" id="l02226"></a>02226 
<a name="l02248" id="l02248"></a>02248 u_char         *
<a name="l02249" id="l02249"></a>02249 asn_parse_float(u_char * data,
<a name="l02250" id="l02250"></a>02250                 <span class="keywordtype">size_t</span> * datalength,
<a name="l02251" id="l02251"></a>02251                 u_char * type, <span class=
"keywordtype">float</span> *floatp, <span class="keywordtype">size_t</span> floatsize)
<a name="l02252" id="l02252"></a>02252 {
<a name="l02253" id="l02253"></a>02253     <span class="keyword">register</span> u_char *bufp = data;
<a name="l02254" id="l02254"></a>02254     u_long          asn_length;
<a name="l02255" id="l02255"></a>02255     <span class="keyword">union </span>{
<a name="l02256" id="l02256"></a>02256         <span class="keywordtype">float</span>           floatVal;
<a name="l02257" id="l02257"></a>02257         <span class="keywordtype">long</span>            longVal;
<a name="l02258" id="l02258"></a>02258         u_char          c[<span class="keyword">sizeof</span>(float)];
<a name="l02259" id="l02259"></a>02259     } fu;
<a name="l02260" id="l02260"></a>02260 
<a name="l02261" id="l02261"></a>02261     <span class="keywordflow">if</span> (floatsize != <span class=
"keyword">sizeof</span>(<span class="keywordtype">float</span>)) {
<a name="l02262" id="l02262"></a>02262         _asn_size_err(<span class=
"stringliteral">"parse float"</span>, floatsize, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l02263" id="l02263"></a>02263         <span class="keywordflow">return</span> NULL;
<a name="l02264" id="l02264"></a>02264     }
<a name="l02265" id="l02265"></a>02265     *type = *bufp++;
<a name="l02266" id="l02266"></a>02266     bufp = asn_parse_length(bufp, &amp;asn_length);
<a name="l02267" id="l02267"></a>02267     <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse float"</span>, bufp, data,
<a name="l02268" id="l02268"></a>02268                                 asn_length, *datalength))
<a name="l02269" id="l02269"></a>02269         <span class="keywordflow">return</span> NULL;
<a name="l02270" id="l02270"></a>02270 
<a name="l02271" id="l02271"></a>02271     DEBUGDUMPSETUP(<span class=
"stringliteral">"recv"</span>, data, bufp - data + asn_length);
<a name="l02272" id="l02272"></a>02272     <span class="comment">/*</span>
<a name="l02273" id="l02273"></a>02273 <span class="comment">     * the float is encoded as an opaque </span>
<a name="l02274" id="l02274"></a>02274 <span class="comment">     */</span>
<a name="l02275" id="l02275"></a>02275     <span class="keywordflow">if</span> ((*type == ASN_OPAQUE) &amp;&amp;
<a name="l02276" id="l02276"></a>02276         (asn_length == ASN_OPAQUE_FLOAT_BER_LEN) &amp;&amp;
<a name="l02277" id="l02277"></a>02277         (*bufp == ASN_OPAQUE_TAG1) &amp;&amp; (*(bufp + 1) == ASN_OPAQUE_FLOAT)) {
<a name="l02278" id="l02278"></a>02278 
<a name="l02279" id="l02279"></a>02279         <span class="comment">/*</span>
<a name="l02280" id="l02280"></a>02280 <span class="comment">         * value is encoded as special format </span>
<a name="l02281" id="l02281"></a>02281 <span class="comment">         */</span>
<a name="l02282" id="l02282"></a>02282         bufp = asn_parse_length(bufp + 2, &amp;asn_length);
<a name="l02283" id="l02283"></a>02283         <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse opaque float"</span>, bufp, data,
<a name="l02284" id="l02284"></a>02284                                     asn_length, *datalength))
<a name="l02285" id="l02285"></a>02285             <span class="keywordflow">return</span> NULL;
<a name="l02286" id="l02286"></a>02286 
<a name="l02287" id="l02287"></a>02287         <span class="comment">/*</span>
<a name="l02288" id="l02288"></a>02288 <span class="comment">         * change type to Float </span>
<a name="l02289" id="l02289"></a>02289 <span class="comment">         */</span>
<a name="l02290" id="l02290"></a>02290         *type = ASN_OPAQUE_FLOAT;
<a name="l02291" id="l02291"></a>02291     }
<a name="l02292" id="l02292"></a>02292 
<a name="l02293" id="l02293"></a>02293     <span class="keywordflow">if</span> (asn_length != <span class=
"keyword">sizeof</span>(<span class="keywordtype">float</span>)) {
<a name="l02294" id="l02294"></a>02294         _asn_size_err(<span class=
"stringliteral">"parse seq float"</span>, asn_length, <span class="keyword">sizeof</span>(<span class=
"keywordtype">float</span>));
<a name="l02295" id="l02295"></a>02295         <span class="keywordflow">return</span> NULL;
<a name="l02296" id="l02296"></a>02296     }
<a name="l02297" id="l02297"></a>02297 
<a name="l02298" id="l02298"></a>02298     *datalength -= (int) asn_length + (bufp - data);
<a name="l02299" id="l02299"></a>02299     memcpy(&amp;fu.c[0], bufp, asn_length);
<a name="l02300" id="l02300"></a>02300 
<a name="l02301" id="l02301"></a>02301     <span class="comment">/*</span>
<a name="l02302" id="l02302"></a>02302 <span class="comment">     * correct for endian differences </span>
<a name="l02303" id="l02303"></a>02303 <span class="comment">     */</span>
<a name="l02304" id="l02304"></a>02304     fu.longVal = ntohl(fu.longVal);
<a name="l02305" id="l02305"></a>02305 
<a name="l02306" id="l02306"></a>02306     *floatp = fu.floatVal;
<a name="l02307" id="l02307"></a>02307 
<a name="l02308" id="l02308"></a>02308     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"Opaque float: %f\n"</span>, *floatp));
<a name="l02309" id="l02309"></a>02309     <span class="keywordflow">return</span> bufp;
<a name="l02310" id="l02310"></a>02310 }
<a name="l02311" id="l02311"></a>02311 
<a name="l02335" id="l02335"></a>02335 u_char         *
<a name="l02336" id="l02336"></a>02336 asn_build_float(u_char * data,
<a name="l02337" id="l02337"></a>02337                 <span class="keywordtype">size_t</span> * datalength,
<a name="l02338" id="l02338"></a>02338                 u_char type, <span class="keyword">const</span> <span class=
"keywordtype">float</span> *floatp, <span class="keywordtype">size_t</span> floatsize)
<a name="l02339" id="l02339"></a>02339 {
<a name="l02340" id="l02340"></a>02340     <span class="keyword">union </span>{
<a name="l02341" id="l02341"></a>02341         <span class="keywordtype">float</span>           floatVal;
<a name="l02342" id="l02342"></a>02342         <span class="keywordtype">int</span>             intVal;
<a name="l02343" id="l02343"></a>02343         u_char          c[<span class="keyword">sizeof</span>(float)];
<a name="l02344" id="l02344"></a>02344     } fu;
<a name="l02345" id="l02345"></a>02345 <span class="preprocessor">#ifndef NETSNMP_NO_DEBUGGING</span>
<a name="l02346" id="l02346"></a>02346     u_char         *initdatap = data;
<a name="l02347" id="l02347"></a>02347 <span class="preprocessor">#endif</span>
<a name="l02348" id="l02348"></a>02348 
<a name="l02349" id="l02349"></a>02349     <span class="keywordflow">if</span> (floatsize != <span class=
"keyword">sizeof</span>(<span class="keywordtype">float</span>)) {
<a name="l02350" id="l02350"></a>02350         _asn_size_err(<span class=
"stringliteral">"build float"</span>, floatsize, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l02351" id="l02351"></a>02351         <span class="keywordflow">return</span> NULL;
<a name="l02352" id="l02352"></a>02352     }
<a name="l02353" id="l02353"></a>02353     <span class="comment">/*</span>
<a name="l02354" id="l02354"></a>02354 <span class="comment">     * encode the float as an opaque </span>
<a name="l02355" id="l02355"></a>02355 <span class="comment">     */</span>
<a name="l02356" id="l02356"></a>02356     <span class="comment">/*</span>
<a name="l02357" id="l02357"></a>02357 <span class="comment">     * turn into Opaque holding special tagged value </span>
<a name="l02358" id="l02358"></a>02358 <span class="comment">     */</span>
<a name="l02359" id="l02359"></a>02359 
<a name="l02360" id="l02360"></a>02360     <span class="comment">/*</span>
<a name="l02361" id="l02361"></a>02361 <span class="comment">     * put the tag and length for the Opaque wrapper </span>
<a name="l02362" id="l02362"></a>02362 <span class="comment">     */</span>
<a name="l02363" id="l02363"></a>02363     data = asn_build_header(data, datalength, ASN_OPAQUE, floatsize + 3);
<a name="l02364" id="l02364"></a>02364     <span class="keywordflow">if</span> (_asn_build_header_check
<a name="l02365" id="l02365"></a>02365         (<span class=
"stringliteral">"build float"</span>, data, *datalength, (floatsize + 3)))
<a name="l02366" id="l02366"></a>02366         <span class="keywordflow">return</span> NULL;
<a name="l02367" id="l02367"></a>02367 
<a name="l02368" id="l02368"></a>02368     <span class="comment">/*</span>
<a name="l02369" id="l02369"></a>02369 <span class="comment">     * put the special tag and length </span>
<a name="l02370" id="l02370"></a>02370 <span class="comment">     */</span>
<a name="l02371" id="l02371"></a>02371     *data++ = ASN_OPAQUE_TAG1;
<a name="l02372" id="l02372"></a>02372     *data++ = ASN_OPAQUE_FLOAT;
<a name="l02373" id="l02373"></a>02373     *data++ = (u_char) floatsize;
<a name="l02374" id="l02374"></a>02374     *datalength = *datalength - 3;
<a name="l02375" id="l02375"></a>02375 
<a name="l02376" id="l02376"></a>02376     fu.floatVal = *floatp;
<a name="l02377" id="l02377"></a>02377     <span class="comment">/*</span>
<a name="l02378" id="l02378"></a>02378 <span class="comment">     * correct for endian differences </span>
<a name="l02379" id="l02379"></a>02379 <span class="comment">     */</span>
<a name="l02380" id="l02380"></a>02380     fu.intVal = htonl(fu.intVal);
<a name="l02381" id="l02381"></a>02381 
<a name="l02382" id="l02382"></a>02382     *datalength -= floatsize;
<a name="l02383" id="l02383"></a>02383     memcpy(data, &amp;fu.c[0], floatsize);
<a name="l02384" id="l02384"></a>02384 
<a name="l02385" id="l02385"></a>02385     DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, initdatap, data - initdatap);
<a name="l02386" id="l02386"></a>02386     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"Opaque float: %f\n"</span>, *floatp));
<a name="l02387" id="l02387"></a>02387     data += floatsize;
<a name="l02388" id="l02388"></a>02388     <span class="keywordflow">return</span> data;
<a name="l02389" id="l02389"></a>02389 }
<a name="l02390" id="l02390"></a>02390 
<a name="l02391" id="l02391"></a>02391 
<a name="l02413" id="l02413"></a>02413 u_char         *
<a name="l02414" id="l02414"></a>02414 asn_parse_double(u_char * data,
<a name="l02415" id="l02415"></a>02415                  <span class="keywordtype">size_t</span> * datalength,
<a name="l02416" id="l02416"></a>02416                  u_char * type, <span class=
"keywordtype">double</span> *doublep, <span class="keywordtype">size_t</span> doublesize)
<a name="l02417" id="l02417"></a>02417 {
<a name="l02418" id="l02418"></a>02418     <span class="keyword">register</span> u_char *bufp = data;
<a name="l02419" id="l02419"></a>02419     u_long          asn_length;
<a name="l02420" id="l02420"></a>02420     <span class="keywordtype">long</span>            tmp;
<a name="l02421" id="l02421"></a>02421     <span class="keyword">union </span>{
<a name="l02422" id="l02422"></a>02422         <span class="keywordtype">double</span>          doubleVal;
<a name="l02423" id="l02423"></a>02423         <span class="keywordtype">int</span>             intVal[2];
<a name="l02424" id="l02424"></a>02424         u_char          c[<span class="keyword">sizeof</span>(double)];
<a name="l02425" id="l02425"></a>02425     } fu;
<a name="l02426" id="l02426"></a>02426 
<a name="l02427" id="l02427"></a>02427 
<a name="l02428" id="l02428"></a>02428     <span class="keywordflow">if</span> (doublesize != <span class=
"keyword">sizeof</span>(<span class="keywordtype">double</span>)) {
<a name="l02429" id="l02429"></a>02429         _asn_size_err(<span class=
"stringliteral">"parse double"</span>, doublesize, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l02430" id="l02430"></a>02430         <span class="keywordflow">return</span> NULL;
<a name="l02431" id="l02431"></a>02431     }
<a name="l02432" id="l02432"></a>02432     *type = *bufp++;
<a name="l02433" id="l02433"></a>02433     bufp = asn_parse_length(bufp, &amp;asn_length);
<a name="l02434" id="l02434"></a>02434     <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse double"</span>, bufp, data,
<a name="l02435" id="l02435"></a>02435                                 asn_length, *datalength))
<a name="l02436" id="l02436"></a>02436         <span class="keywordflow">return</span> NULL;
<a name="l02437" id="l02437"></a>02437 
<a name="l02438" id="l02438"></a>02438     DEBUGDUMPSETUP(<span class=
"stringliteral">"recv"</span>, data, bufp - data + asn_length);
<a name="l02439" id="l02439"></a>02439     <span class="comment">/*</span>
<a name="l02440" id="l02440"></a>02440 <span class="comment">     * the double is encoded as an opaque </span>
<a name="l02441" id="l02441"></a>02441 <span class="comment">     */</span>
<a name="l02442" id="l02442"></a>02442     <span class="keywordflow">if</span> ((*type == ASN_OPAQUE) &amp;&amp;
<a name="l02443" id="l02443"></a>02443         (asn_length == ASN_OPAQUE_DOUBLE_BER_LEN) &amp;&amp;
<a name="l02444" id="l02444"></a>02444         (*bufp == ASN_OPAQUE_TAG1) &amp;&amp; (*(bufp + 1) == ASN_OPAQUE_DOUBLE)) {
<a name="l02445" id="l02445"></a>02445 
<a name="l02446" id="l02446"></a>02446         <span class="comment">/*</span>
<a name="l02447" id="l02447"></a>02447 <span class="comment">         * value is encoded as special format </span>
<a name="l02448" id="l02448"></a>02448 <span class="comment">         */</span>
<a name="l02449" id="l02449"></a>02449         bufp = asn_parse_length(bufp + 2, &amp;asn_length);
<a name="l02450" id="l02450"></a>02450         <span class="keywordflow">if</span> (_asn_parse_length_check(<span class=
"stringliteral">"parse opaque double"</span>, bufp, data,
<a name="l02451" id="l02451"></a>02451                                     asn_length, *datalength))
<a name="l02452" id="l02452"></a>02452             <span class="keywordflow">return</span> NULL;
<a name="l02453" id="l02453"></a>02453 
<a name="l02454" id="l02454"></a>02454         <span class="comment">/*</span>
<a name="l02455" id="l02455"></a>02455 <span class="comment">         * change type to Double </span>
<a name="l02456" id="l02456"></a>02456 <span class="comment">         */</span>
<a name="l02457" id="l02457"></a>02457         *type = ASN_OPAQUE_DOUBLE;
<a name="l02458" id="l02458"></a>02458     }
<a name="l02459" id="l02459"></a>02459 
<a name="l02460" id="l02460"></a>02460     <span class="keywordflow">if</span> (asn_length != <span class=
"keyword">sizeof</span>(<span class="keywordtype">double</span>)) {
<a name="l02461" id="l02461"></a>02461         _asn_size_err(<span class=
"stringliteral">"parse seq double"</span>, asn_length, <span class="keyword">sizeof</span>(<span class=
"keywordtype">double</span>));
<a name="l02462" id="l02462"></a>02462         <span class="keywordflow">return</span> NULL;
<a name="l02463" id="l02463"></a>02463     }
<a name="l02464" id="l02464"></a>02464     *datalength -= (int) asn_length + (bufp - data);
<a name="l02465" id="l02465"></a>02465     memcpy(&amp;fu.c[0], bufp, asn_length);
<a name="l02466" id="l02466"></a>02466 
<a name="l02467" id="l02467"></a>02467     <span class="comment">/*</span>
<a name="l02468" id="l02468"></a>02468 <span class="comment">     * correct for endian differences </span>
<a name="l02469" id="l02469"></a>02469 <span class="comment">     */</span>
<a name="l02470" id="l02470"></a>02470 
<a name="l02471" id="l02471"></a>02471     tmp = ntohl(fu.intVal[0]);
<a name="l02472" id="l02472"></a>02472     fu.intVal[0] = ntohl(fu.intVal[1]);
<a name="l02473" id="l02473"></a>02473     fu.intVal[1] = tmp;
<a name="l02474" id="l02474"></a>02474 
<a name="l02475" id="l02475"></a>02475     *doublep = fu.doubleVal;
<a name="l02476" id="l02476"></a>02476     DEBUGMSG((<span class="stringliteral">"dumpv_recv"</span>, <span class=
"stringliteral">"  Opaque Double:\t%f\n"</span>, *doublep));
<a name="l02477" id="l02477"></a>02477 
<a name="l02478" id="l02478"></a>02478     <span class="keywordflow">return</span> bufp;
<a name="l02479" id="l02479"></a>02479 }
<a name="l02480" id="l02480"></a>02480 
<a name="l02481" id="l02481"></a>02481 
<a name="l02504" id="l02504"></a>02504 u_char         *
<a name="l02505" id="l02505"></a>02505 asn_build_double(u_char * data,
<a name="l02506" id="l02506"></a>02506                  <span class="keywordtype">size_t</span> * datalength,
<a name="l02507" id="l02507"></a>02507                  u_char type, <span class="keyword">const</span> <span class=
"keywordtype">double</span> *doublep, <span class="keywordtype">size_t</span> doublesize)
<a name="l02508" id="l02508"></a>02508 {
<a name="l02509" id="l02509"></a>02509     <span class="keywordtype">long</span>            tmp;
<a name="l02510" id="l02510"></a>02510     <span class="keyword">union </span>{
<a name="l02511" id="l02511"></a>02511         <span class="keywordtype">double</span>          doubleVal;
<a name="l02512" id="l02512"></a>02512         <span class="keywordtype">int</span>             intVal[2];
<a name="l02513" id="l02513"></a>02513         u_char          c[<span class="keyword">sizeof</span>(double)];
<a name="l02514" id="l02514"></a>02514     } fu;
<a name="l02515" id="l02515"></a>02515 <span class="preprocessor">#ifndef NETSNMP_NO_DEBUGGING</span>
<a name="l02516" id="l02516"></a>02516     u_char         *initdatap = data;
<a name="l02517" id="l02517"></a>02517 <span class="preprocessor">#endif</span>
<a name="l02518" id="l02518"></a>02518 
<a name="l02519" id="l02519"></a>02519     <span class="keywordflow">if</span> (doublesize != <span class=
"keyword">sizeof</span>(<span class="keywordtype">double</span>)) {
<a name="l02520" id="l02520"></a>02520         _asn_size_err(<span class=
"stringliteral">"build double"</span>, doublesize, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l02521" id="l02521"></a>02521         <span class="keywordflow">return</span> NULL;
<a name="l02522" id="l02522"></a>02522     }
<a name="l02523" id="l02523"></a>02523 
<a name="l02524" id="l02524"></a>02524     <span class="comment">/*</span>
<a name="l02525" id="l02525"></a>02525 <span class="comment">     * encode the double as an opaque </span>
<a name="l02526" id="l02526"></a>02526 <span class="comment">     */</span>
<a name="l02527" id="l02527"></a>02527     <span class="comment">/*</span>
<a name="l02528" id="l02528"></a>02528 <span class="comment">     * turn into Opaque holding special tagged value </span>
<a name="l02529" id="l02529"></a>02529 <span class="comment">     */</span>
<a name="l02530" id="l02530"></a>02530 
<a name="l02531" id="l02531"></a>02531     <span class="comment">/*</span>
<a name="l02532" id="l02532"></a>02532 <span class="comment">     * put the tag and length for the Opaque wrapper </span>
<a name="l02533" id="l02533"></a>02533 <span class="comment">     */</span>
<a name="l02534" id="l02534"></a>02534     data = asn_build_header(data, datalength, ASN_OPAQUE, doublesize + 3);
<a name="l02535" id="l02535"></a>02535     <span class="keywordflow">if</span> (_asn_build_header_check
<a name="l02536" id="l02536"></a>02536         (<span class=
"stringliteral">"build double"</span>, data, *datalength, doublesize + 3))
<a name="l02537" id="l02537"></a>02537         <span class="keywordflow">return</span> NULL;
<a name="l02538" id="l02538"></a>02538 
<a name="l02539" id="l02539"></a>02539     <span class="comment">/*</span>
<a name="l02540" id="l02540"></a>02540 <span class="comment">     * put the special tag and length </span>
<a name="l02541" id="l02541"></a>02541 <span class="comment">     */</span>
<a name="l02542" id="l02542"></a>02542     *data++ = ASN_OPAQUE_TAG1;
<a name="l02543" id="l02543"></a>02543     *data++ = ASN_OPAQUE_DOUBLE;
<a name="l02544" id="l02544"></a>02544     *data++ = (u_char) doublesize;
<a name="l02545" id="l02545"></a>02545     *datalength = *datalength - 3;
<a name="l02546" id="l02546"></a>02546 
<a name="l02547" id="l02547"></a>02547     fu.doubleVal = *doublep;
<a name="l02548" id="l02548"></a>02548     <span class="comment">/*</span>
<a name="l02549" id="l02549"></a>02549 <span class="comment">     * correct for endian differences </span>
<a name="l02550" id="l02550"></a>02550 <span class="comment">     */</span>
<a name="l02551" id="l02551"></a>02551     tmp = htonl(fu.intVal[0]);
<a name="l02552" id="l02552"></a>02552     fu.intVal[0] = htonl(fu.intVal[1]);
<a name="l02553" id="l02553"></a>02553     fu.intVal[1] = tmp;
<a name="l02554" id="l02554"></a>02554     *datalength -= doublesize;
<a name="l02555" id="l02555"></a>02555     memcpy(data, &amp;fu.c[0], doublesize);
<a name="l02556" id="l02556"></a>02556 
<a name="l02557" id="l02557"></a>02557     data += doublesize;
<a name="l02558" id="l02558"></a>02558     DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, initdatap, data - initdatap);
<a name="l02559" id="l02559"></a>02559     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  Opaque double: %f"</span>, *doublep));
<a name="l02560" id="l02560"></a>02560     <span class="keywordflow">return</span> data;
<a name="l02561" id="l02561"></a>02561 }
<a name="l02562" id="l02562"></a>02562 
<a name="l02563" id="l02563"></a>02563 <span class="preprocessor">#endif                          </span><span class=
"comment">/* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */</span>
<a name="l02564" id="l02564"></a>02564 
<a name="l02565" id="l02565"></a>02565 
<a name="l02580" id="l02580"></a>02580 <span class="keywordtype">int</span>
<a name="l02581" id="l02581"></a>02581 asn_realloc(u_char ** pkt, <span class="keywordtype">size_t</span> * pkt_len)
<a name="l02582" id="l02582"></a>02582 {
<a name="l02583" id="l02583"></a>02583     <span class="keywordflow">if</span> (pkt != NULL &amp;&amp; pkt_len != NULL) {
<a name="l02584" id="l02584"></a>02584         <span class="keywordtype">size_t</span>          old_pkt_len = *pkt_len;
<a name="l02585" id="l02585"></a>02585 
<a name="l02586" id="l02586"></a>02586         DEBUGMSGTL((<span class="stringliteral">"asn_realloc"</span>, <span class=
"stringliteral">" old_pkt %8p, old_pkt_len %lu\n"</span>,
<a name="l02587" id="l02587"></a>02587                     *pkt, (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)old_pkt_len));
<a name="l02588" id="l02588"></a>02588 
<a name="l02589" id="l02589"></a>02589         <span class="keywordflow">if</span> (<a class="code" href=
"group__util.html#ga7b42d706225a788adcfeaad9b24717de" title=
"This function increase the size of the buffer pointed at by *buf, which is initially...">snmp_realloc</a>(pkt, pkt_len)) {
<a name="l02590" id="l02590"></a>02590             DEBUGMSGTL((<span class="stringliteral">"asn_realloc"</span>, <span class=
"stringliteral">" new_pkt %8p, new_pkt_len %lu\n"</span>,
<a name="l02591" id="l02591"></a>02591                         *pkt, (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)*pkt_len));
<a name="l02592" id="l02592"></a>02592             DEBUGMSGTL((<span class="stringliteral">"asn_realloc"</span>,
<a name="l02593" id="l02593"></a>02593                         <span class=
"stringliteral">" memmove(%8p + %08x, %8p, %08x)\n"</span>,
<a name="l02594" id="l02594"></a>02594                         *pkt, (<span class=
"keywordtype">unsigned</span>)(*pkt_len - old_pkt_len),
<a name="l02595" id="l02595"></a>02595                         *pkt, (<span class="keywordtype">unsigned</span>)old_pkt_len));
<a name="l02596" id="l02596"></a>02596             memmove(*pkt + (*pkt_len - old_pkt_len), *pkt, old_pkt_len);
<a name="l02597" id="l02597"></a>02597             memset(*pkt, (<span class="keywordtype">int</span>) <span class=
"charliteral">' '</span>, *pkt_len - old_pkt_len);
<a name="l02598" id="l02598"></a>02598             <span class="keywordflow">return</span> 1;
<a name="l02599" id="l02599"></a>02599         } <span class="keywordflow">else</span> {
<a name="l02600" id="l02600"></a>02600             DEBUGMSG((<span class="stringliteral">"asn_realloc"</span>, <span class=
"stringliteral">" CANNOT REALLOC()\n"</span>));
<a name="l02601" id="l02601"></a>02601         }
<a name="l02602" id="l02602"></a>02602     }
<a name="l02603" id="l02603"></a>02603     <span class="keywordflow">return</span> 0;
<a name="l02604" id="l02604"></a>02604 }
<a name="l02605" id="l02605"></a>02605 
<a name="l02606" id="l02606"></a>02606 <span class="preprocessor">#ifdef NETSNMP_USE_REVERSE_ASNENCODING</span>
<a name="l02607" id="l02607"></a>02607 
<a name="l02622" id="l02622"></a>02622 <span class="keywordtype">int</span>
<a name="l02623" id="l02623"></a>02623 asn_realloc_rbuild_length(u_char ** pkt, <span class=
"keywordtype">size_t</span> * pkt_len,
<a name="l02624" id="l02624"></a>02624                           <span class="keywordtype">size_t</span> * offset, <span class=
"keywordtype">int</span> r, <span class="keywordtype">size_t</span> length)
<a name="l02625" id="l02625"></a>02625 {
<a name="l02626" id="l02626"></a>02626     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build length"</span>;
<a name="l02627" id="l02627"></a>02627     <span class="keywordtype">char</span>            ebuf[128];
<a name="l02628" id="l02628"></a>02628     <span class="keywordtype">int</span>             tmp_int;
<a name="l02629" id="l02629"></a>02629     <span class="keywordtype">size_t</span>          start_offset = *offset;
<a name="l02630" id="l02630"></a>02630 
<a name="l02631" id="l02631"></a>02631     <span class="keywordflow">if</span> (length &lt;= 0x7f) {
<a name="l02632" id="l02632"></a>02632         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l02633" id="l02633"></a>02633             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l02634" id="l02634"></a>02634             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l02635" id="l02635"></a>02635                     <span class=
"stringliteral">"%s: bad length &lt; 1 :%ld, %lu"</span>, errpre,
<a name="l02636" id="l02636"></a>02636                     (<span class=
"keywordtype">long</span>)(*pkt_len - *offset), (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)length);
<a name="l02637" id="l02637"></a>02637             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l02638" id="l02638"></a>02638             ERROR_MSG(ebuf);
<a name="l02639" id="l02639"></a>02639             <span class="keywordflow">return</span> 0;
<a name="l02640" id="l02640"></a>02640         }
<a name="l02641" id="l02641"></a>02641         *(*pkt + *pkt_len - (++*offset)) = length;
<a name="l02642" id="l02642"></a>02642     } <span class="keywordflow">else</span> {
<a name="l02643" id="l02643"></a>02643         <span class="keywordflow">while</span> (length &gt; 0xff) {
<a name="l02644" id="l02644"></a>02644             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l02645" id="l02645"></a>02645                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l02646" id="l02646"></a>02646                 snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l02647" id="l02647"></a>02647                         <span class=
"stringliteral">"%s: bad length &lt; 1 :%ld, %lu"</span>, errpre,
<a name="l02648" id="l02648"></a>02648                         (<span class=
"keywordtype">long</span>)(*pkt_len - *offset), (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)length);
<a name="l02649" id="l02649"></a>02649                 ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l02650" id="l02650"></a>02650                 ERROR_MSG(ebuf);
<a name="l02651" id="l02651"></a>02651                 <span class="keywordflow">return</span> 0;
<a name="l02652" id="l02652"></a>02652             }
<a name="l02653" id="l02653"></a>02653             *(*pkt + *pkt_len - (++*offset)) = length &amp; 0xff;
<a name="l02654" id="l02654"></a>02654             length &gt;&gt;= 8;
<a name="l02655" id="l02655"></a>02655         }
<a name="l02656" id="l02656"></a>02656 
<a name="l02657" id="l02657"></a>02657         <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; 2) {
<a name="l02658" id="l02658"></a>02658             <span class=
"keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l02659" id="l02659"></a>02659                 snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l02660" id="l02660"></a>02660                         <span class=
"stringliteral">"%s: bad length &lt; 1 :%ld, %lu"</span>, errpre,
<a name="l02661" id="l02661"></a>02661                         (<span class=
"keywordtype">long</span>)(*pkt_len - *offset), (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)length);
<a name="l02662" id="l02662"></a>02662                 ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l02663" id="l02663"></a>02663                 ERROR_MSG(ebuf);
<a name="l02664" id="l02664"></a>02664                 <span class="keywordflow">return</span> 0;
<a name="l02665" id="l02665"></a>02665             }
<a name="l02666" id="l02666"></a>02666         }
<a name="l02667" id="l02667"></a>02667 
<a name="l02668" id="l02668"></a>02668         *(*pkt + *pkt_len - (++*offset)) = length &amp; 0xff;
<a name="l02669" id="l02669"></a>02669         tmp_int = *offset - start_offset;
<a name="l02670" id="l02670"></a>02670         *(*pkt + *pkt_len - (++*offset)) = tmp_int | 0x80;
<a name="l02671" id="l02671"></a>02671     }
<a name="l02672" id="l02672"></a>02672 
<a name="l02673" id="l02673"></a>02673     <span class="keywordflow">return</span> 1;
<a name="l02674" id="l02674"></a>02674 }
<a name="l02675" id="l02675"></a>02675 
<a name="l02693" id="l02693"></a>02693 <span class="keywordtype">int</span>
<a name="l02694" id="l02694"></a>02694 asn_realloc_rbuild_header(u_char ** pkt, <span class=
"keywordtype">size_t</span> * pkt_len,
<a name="l02695" id="l02695"></a>02695                           <span class="keywordtype">size_t</span> * offset, <span class=
"keywordtype">int</span> r,
<a name="l02696" id="l02696"></a>02696                           u_char type, <span class="keywordtype">size_t</span> length)
<a name="l02697" id="l02697"></a>02697 {
<a name="l02698" id="l02698"></a>02698     <span class="keywordtype">char</span>            ebuf[128];
<a name="l02699" id="l02699"></a>02699 
<a name="l02700" id="l02700"></a>02700     <span class=
"keywordflow">if</span> (asn_realloc_rbuild_length(pkt, pkt_len, offset, r, length)) {
<a name="l02701" id="l02701"></a>02701         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l02702" id="l02702"></a>02702             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l02703" id="l02703"></a>02703             snprintf(ebuf, <span class="keyword">sizeof</span>(ebuf),
<a name="l02704" id="l02704"></a>02704                     <span class=
"stringliteral">"bad header length &lt; 1 :%ld, %lu"</span>,
<a name="l02705" id="l02705"></a>02705                     (<span class=
"keywordtype">long</span>)(*pkt_len - *offset), (<span class="keywordtype">unsigned</span> <span class=
"keywordtype">long</span>)length);
<a name="l02706" id="l02706"></a>02706             ebuf[ <span class="keyword">sizeof</span>(ebuf)-1 ] = 0;
<a name="l02707" id="l02707"></a>02707             ERROR_MSG(ebuf);
<a name="l02708" id="l02708"></a>02708             <span class="keywordflow">return</span> 0;
<a name="l02709" id="l02709"></a>02709         }
<a name="l02710" id="l02710"></a>02710         *(*pkt + *pkt_len - (++*offset)) = type;
<a name="l02711" id="l02711"></a>02711         <span class="keywordflow">return</span> 1;
<a name="l02712" id="l02712"></a>02712     }
<a name="l02713" id="l02713"></a>02713     <span class="keywordflow">return</span> 0;
<a name="l02714" id="l02714"></a>02714 }
<a name="l02715" id="l02715"></a>02715 
<a name="l02733" id="l02733"></a>02733 <span class="keywordtype">int</span>
<a name="l02734" id="l02734"></a>02734 asn_realloc_rbuild_int(u_char ** pkt, <span class="keywordtype">size_t</span> * pkt_len,
<a name="l02735" id="l02735"></a>02735                        <span class="keywordtype">size_t</span> * offset, <span class=
"keywordtype">int</span> r,
<a name="l02736" id="l02736"></a>02736                        u_char type, <span class="keyword">const</span> <span class=
"keywordtype">long</span> *intp, <span class="keywordtype">size_t</span> intsize)
<a name="l02737" id="l02737"></a>02737 {
<a name="l02738" id="l02738"></a>02738     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build int"</span>;
<a name="l02739" id="l02739"></a>02739     <span class="keyword">register</span> <span class=
"keywordtype">long</span>   integer = *intp;
<a name="l02740" id="l02740"></a>02740     <span class="keywordtype">int</span>             testvalue;
<a name="l02741" id="l02741"></a>02741     <span class="keywordtype">size_t</span>          start_offset = *offset;
<a name="l02742" id="l02742"></a>02742 
<a name="l02743" id="l02743"></a>02743     <span class="keywordflow">if</span> (intsize != <span class=
"keyword">sizeof</span>(<span class="keywordtype">long</span>)) {
<a name="l02744" id="l02744"></a>02744         _asn_size_err(errpre, intsize, <span class="keyword">sizeof</span>(<span class=
"keywordtype">long</span>));
<a name="l02745" id="l02745"></a>02745         <span class="keywordflow">return</span> 0;
<a name="l02746" id="l02746"></a>02746     }
<a name="l02747" id="l02747"></a>02747 
<a name="l02748" id="l02748"></a>02748     CHECK_OVERFLOW_S(integer,10);
<a name="l02749" id="l02749"></a>02749     testvalue = (integer &lt; 0) ? -1 : 0;
<a name="l02750" id="l02750"></a>02750 
<a name="l02751" id="l02751"></a>02751     <span class=
"keywordflow">if</span> (((*pkt_len - *offset) &lt; 1) &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l02752" id="l02752"></a>02752         <span class="keywordflow">return</span> 0;
<a name="l02753" id="l02753"></a>02753     }
<a name="l02754" id="l02754"></a>02754     *(*pkt + *pkt_len - (++*offset)) = (u_char) integer;
<a name="l02755" id="l02755"></a>02755     integer &gt;&gt;= 8;
<a name="l02756" id="l02756"></a>02756 
<a name="l02757" id="l02757"></a>02757     <span class="keywordflow">while</span> (integer != testvalue) {
<a name="l02758" id="l02758"></a>02758         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l02759" id="l02759"></a>02759             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l02760" id="l02760"></a>02760             <span class="keywordflow">return</span> 0;
<a name="l02761" id="l02761"></a>02761         }
<a name="l02762" id="l02762"></a>02762         *(*pkt + *pkt_len - (++*offset)) = (u_char) integer;
<a name="l02763" id="l02763"></a>02763         integer &gt;&gt;= 8;
<a name="l02764" id="l02764"></a>02764     }
<a name="l02765" id="l02765"></a>02765 
<a name="l02766" id="l02766"></a>02766     <span class=
"keywordflow">if</span> ((*(*pkt + *pkt_len - *offset) &amp; 0x80) != (testvalue &amp; 0x80)) {
<a name="l02767" id="l02767"></a>02767         <span class="comment">/*</span>
<a name="l02768" id="l02768"></a>02768 <span class=
"comment">         * Make sure left most bit is representational of the rest of the bits</span>
<a name="l02769" id="l02769"></a>02769 <span class="comment">         * that aren't encoded.  </span>
<a name="l02770" id="l02770"></a>02770 <span class="comment">         */</span>
<a name="l02771" id="l02771"></a>02771         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l02772" id="l02772"></a>02772             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l02773" id="l02773"></a>02773             <span class="keywordflow">return</span> 0;
<a name="l02774" id="l02774"></a>02774         }
<a name="l02775" id="l02775"></a>02775         *(*pkt + *pkt_len - (++*offset)) = testvalue &amp; 0xff;
<a name="l02776" id="l02776"></a>02776     }
<a name="l02777" id="l02777"></a>02777 
<a name="l02778" id="l02778"></a>02778     <span class=
"keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r, type,
<a name="l02779" id="l02779"></a>02779                                   (*offset - start_offset))) {
<a name="l02780" id="l02780"></a>02780         <span class=
"keywordflow">if</span> (_asn_realloc_build_header_check(errpre, pkt, pkt_len,
<a name="l02781" id="l02781"></a>02781                                             (*offset - start_offset))) {
<a name="l02782" id="l02782"></a>02782             <span class="keywordflow">return</span> 0;
<a name="l02783" id="l02783"></a>02783         } <span class="keywordflow">else</span> {
<a name="l02784" id="l02784"></a>02784             DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
<a name="l02785" id="l02785"></a>02785                            (*offset - start_offset));
<a name="l02786" id="l02786"></a>02786             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  Integer:\t%ld (0x%.2lX)\n"</span>, *intp,
<a name="l02787" id="l02787"></a>02787                       *intp));
<a name="l02788" id="l02788"></a>02788             <span class="keywordflow">return</span> 1;
<a name="l02789" id="l02789"></a>02789         }
<a name="l02790" id="l02790"></a>02790     }
<a name="l02791" id="l02791"></a>02791 
<a name="l02792" id="l02792"></a>02792     <span class="keywordflow">return</span> 0;
<a name="l02793" id="l02793"></a>02793 }
<a name="l02794" id="l02794"></a>02794 
<a name="l02813" id="l02813"></a>02813 <span class="keywordtype">int</span>
<a name="l02814" id="l02814"></a>02814 asn_realloc_rbuild_string(u_char ** pkt, <span class=
"keywordtype">size_t</span> * pkt_len,
<a name="l02815" id="l02815"></a>02815                           <span class="keywordtype">size_t</span> * offset, <span class=
"keywordtype">int</span> r,
<a name="l02816" id="l02816"></a>02816                           u_char type,
<a name="l02817" id="l02817"></a>02817                           <span class="keyword">const</span> u_char * str, <span class=
"keywordtype">size_t</span> strlength)
<a name="l02818" id="l02818"></a>02818 {
<a name="l02819" id="l02819"></a>02819     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build string"</span>;
<a name="l02820" id="l02820"></a>02820     <span class="keywordtype">size_t</span>          start_offset = *offset;
<a name="l02821" id="l02821"></a>02821 
<a name="l02822" id="l02822"></a>02822     <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; strlength) {
<a name="l02823" id="l02823"></a>02823         <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l02824" id="l02824"></a>02824             <span class="keywordflow">return</span> 0;
<a name="l02825" id="l02825"></a>02825         }
<a name="l02826" id="l02826"></a>02826     }
<a name="l02827" id="l02827"></a>02827 
<a name="l02828" id="l02828"></a>02828     *offset += strlength;
<a name="l02829" id="l02829"></a>02829     memcpy(*pkt + *pkt_len - *offset, str, strlength);
<a name="l02830" id="l02830"></a>02830 
<a name="l02831" id="l02831"></a>02831     <span class="keywordflow">if</span> (asn_realloc_rbuild_header
<a name="l02832" id="l02832"></a>02832         (pkt, pkt_len, offset, r, type, strlength)) {
<a name="l02833" id="l02833"></a>02833         <span class="keywordflow">if</span> (_asn_realloc_build_header_check
<a name="l02834" id="l02834"></a>02834             (errpre, pkt, pkt_len, strlength)) {
<a name="l02835" id="l02835"></a>02835             <span class="keywordflow">return</span> 0;
<a name="l02836" id="l02836"></a>02836         } <span class="keywordflow">else</span> {
<a name="l02837" id="l02837"></a>02837             DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
<a name="l02838" id="l02838"></a>02838                            *offset - start_offset);
<a name="l02839" id="l02839"></a>02839             DEBUGIF(<span class="stringliteral">"dumpv_send"</span>) {
<a name="l02840" id="l02840"></a>02840                 <span class="keywordflow">if</span> (strlength == 0) {
<a name="l02841" id="l02841"></a>02841                     DEBUGMSG((<span class=
"stringliteral">"dumpv_send"</span>, <span class="stringliteral">"  String: [NULL]\n"</span>));
<a name="l02842" id="l02842"></a>02842                 } <span class="keywordflow">else</span> {
<a name="l02843" id="l02843"></a>02843                     u_char         *buf = (u_char *) malloc(2 * strlength);
<a name="l02844" id="l02844"></a>02844                     <span class="keywordtype">size_t</span>          l =
<a name="l02845" id="l02845"></a>02845                         (buf != NULL) ? (2 * strlength) : 0, ol = 0;
<a name="l02846" id="l02846"></a>02846 
<a name="l02847" id="l02847"></a>02847                     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga7ff1971fc340b2789d48895086bf3230" title=
"Prints an ascii string into a buffer.">sprint_realloc_asciistring</a>
<a name="l02848" id="l02848"></a>02848                         (&amp;buf, &amp;l, &amp;ol, 1, str, strlength)) {
<a name="l02849" id="l02849"></a>02849                         DEBUGMSG((<span class=
"stringliteral">"dumpv_send"</span>, <span class="stringliteral">"  String:\t%s\n"</span>, buf));
<a name="l02850" id="l02850"></a>02850                     } <span class="keywordflow">else</span> {
<a name="l02851" id="l02851"></a>02851                         <span class="keywordflow">if</span> (buf == NULL) {
<a name="l02852" id="l02852"></a>02852                             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>,
<a name="l02853" id="l02853"></a>02853                                       <span class=
"stringliteral">"  String:\t[TRUNCATED]\n"</span>));
<a name="l02854" id="l02854"></a>02854                         } <span class="keywordflow">else</span> {
<a name="l02855" id="l02855"></a>02855                             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>,
<a name="l02856" id="l02856"></a>02856                                       <span class=
"stringliteral">"  String:\t%s [TRUNCATED]\n"</span>, buf));
<a name="l02857" id="l02857"></a>02857                         }
<a name="l02858" id="l02858"></a>02858                     }
<a name="l02859" id="l02859"></a>02859                     <span class="keywordflow">if</span> (buf != NULL) {
<a name="l02860" id="l02860"></a>02860                         free(buf);
<a name="l02861" id="l02861"></a>02861                     }
<a name="l02862" id="l02862"></a>02862                 }
<a name="l02863" id="l02863"></a>02863             }
<a name="l02864" id="l02864"></a>02864         }
<a name="l02865" id="l02865"></a>02865         <span class="keywordflow">return</span> 1;
<a name="l02866" id="l02866"></a>02866     }
<a name="l02867" id="l02867"></a>02867 
<a name="l02868" id="l02868"></a>02868     <span class="keywordflow">return</span> 0;
<a name="l02869" id="l02869"></a>02869 }
<a name="l02870" id="l02870"></a>02870 
<a name="l02888" id="l02888"></a>02888 <span class="keywordtype">int</span>
<a name="l02889" id="l02889"></a>02889 asn_realloc_rbuild_unsigned_int(u_char ** pkt, <span class=
"keywordtype">size_t</span> * pkt_len,
<a name="l02890" id="l02890"></a>02890                                 <span class=
"keywordtype">size_t</span> * offset, <span class="keywordtype">int</span> r,
<a name="l02891" id="l02891"></a>02891                             u_char type, <span class=
"keyword">const</span> u_long * intp, <span class="keywordtype">size_t</span> intsize)
<a name="l02892" id="l02892"></a>02892 {
<a name="l02893" id="l02893"></a>02893     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build uint"</span>;
<a name="l02894" id="l02894"></a>02894     <span class="keyword">register</span> u_long integer = *intp;
<a name="l02895" id="l02895"></a>02895     <span class="keywordtype">size_t</span>          start_offset = *offset;
<a name="l02896" id="l02896"></a>02896 
<a name="l02897" id="l02897"></a>02897     <span class="keywordflow">if</span> (intsize != <span class=
"keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)) {
<a name="l02898" id="l02898"></a>02898         _asn_size_err(errpre, intsize, <span class="keyword">sizeof</span>(<span class=
"keywordtype">unsigned</span> <span class="keywordtype">long</span>));
<a name="l02899" id="l02899"></a>02899         <span class="keywordflow">return</span> 0;
<a name="l02900" id="l02900"></a>02900     }
<a name="l02901" id="l02901"></a>02901 
<a name="l02902" id="l02902"></a>02902     CHECK_OVERFLOW_U(integer,11);
<a name="l02903" id="l02903"></a>02903 
<a name="l02904" id="l02904"></a>02904     <span class=
"keywordflow">if</span> (((*pkt_len - *offset) &lt; 1) &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l02905" id="l02905"></a>02905         <span class="keywordflow">return</span> 0;
<a name="l02906" id="l02906"></a>02906     }
<a name="l02907" id="l02907"></a>02907     *(*pkt + *pkt_len - (++*offset)) = (u_char) integer;
<a name="l02908" id="l02908"></a>02908     integer &gt;&gt;= 8;
<a name="l02909" id="l02909"></a>02909 
<a name="l02910" id="l02910"></a>02910     <span class="keywordflow">while</span> (integer != 0) {
<a name="l02911" id="l02911"></a>02911         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l02912" id="l02912"></a>02912             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l02913" id="l02913"></a>02913             <span class="keywordflow">return</span> 0;
<a name="l02914" id="l02914"></a>02914         }
<a name="l02915" id="l02915"></a>02915         *(*pkt + *pkt_len - (++*offset)) = (u_char) integer;
<a name="l02916" id="l02916"></a>02916         integer &gt;&gt;= 8;
<a name="l02917" id="l02917"></a>02917     }
<a name="l02918" id="l02918"></a>02918 
<a name="l02919" id="l02919"></a>02919     <span class=
"keywordflow">if</span> ((*(*pkt + *pkt_len - *offset) &amp; 0x80) != (0 &amp; 0x80)) {
<a name="l02920" id="l02920"></a>02920         <span class="comment">/*</span>
<a name="l02921" id="l02921"></a>02921 <span class=
"comment">         * Make sure left most bit is representational of the rest of the bits</span>
<a name="l02922" id="l02922"></a>02922 <span class="comment">         * that aren't encoded.  </span>
<a name="l02923" id="l02923"></a>02923 <span class="comment">         */</span>
<a name="l02924" id="l02924"></a>02924         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l02925" id="l02925"></a>02925             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l02926" id="l02926"></a>02926             <span class="keywordflow">return</span> 0;
<a name="l02927" id="l02927"></a>02927         }
<a name="l02928" id="l02928"></a>02928         *(*pkt + *pkt_len - (++*offset)) = 0;
<a name="l02929" id="l02929"></a>02929     }
<a name="l02930" id="l02930"></a>02930 
<a name="l02931" id="l02931"></a>02931     <span class=
"keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r, type,
<a name="l02932" id="l02932"></a>02932                                   (*offset - start_offset))) {
<a name="l02933" id="l02933"></a>02933         <span class=
"keywordflow">if</span> (_asn_realloc_build_header_check(errpre, pkt, pkt_len,
<a name="l02934" id="l02934"></a>02934                                             (*offset - start_offset))) {
<a name="l02935" id="l02935"></a>02935             <span class="keywordflow">return</span> 0;
<a name="l02936" id="l02936"></a>02936         } <span class="keywordflow">else</span> {
<a name="l02937" id="l02937"></a>02937             DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
<a name="l02938" id="l02938"></a>02938                            (*offset - start_offset));
<a name="l02939" id="l02939"></a>02939             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  UInteger:\t%lu (0x%.2lX)\n"</span>, *intp,
<a name="l02940" id="l02940"></a>02940                       *intp));
<a name="l02941" id="l02941"></a>02941             <span class="keywordflow">return</span> 1;
<a name="l02942" id="l02942"></a>02942         }
<a name="l02943" id="l02943"></a>02943     }
<a name="l02944" id="l02944"></a>02944 
<a name="l02945" id="l02945"></a>02945     <span class="keywordflow">return</span> 0;
<a name="l02946" id="l02946"></a>02946 }
<a name="l02947" id="l02947"></a>02947 
<a name="l02965" id="l02965"></a>02965 <span class="keywordtype">int</span>
<a name="l02966" id="l02966"></a>02966 asn_realloc_rbuild_sequence(u_char ** pkt, <span class=
"keywordtype">size_t</span> * pkt_len,
<a name="l02967" id="l02967"></a>02967                             <span class="keywordtype">size_t</span> * offset, <span class=
"keywordtype">int</span> r,
<a name="l02968" id="l02968"></a>02968                             u_char type, <span class="keywordtype">size_t</span> length)
<a name="l02969" id="l02969"></a>02969 {
<a name="l02970" id="l02970"></a>02970     <span class=
"keywordflow">return</span> asn_realloc_rbuild_header(pkt, pkt_len, offset, r, type,
<a name="l02971" id="l02971"></a>02971                                      length);
<a name="l02972" id="l02972"></a>02972 }
<a name="l02973" id="l02973"></a>02973 
<a name="l02992" id="l02992"></a>02992 <span class="keywordtype">int</span>
<a name="l02993" id="l02993"></a>02993 asn_realloc_rbuild_objid(u_char ** pkt, <span class="keywordtype">size_t</span> * pkt_len,
<a name="l02994" id="l02994"></a>02994                          <span class="keywordtype">size_t</span> * offset, <span class=
"keywordtype">int</span> r,
<a name="l02995" id="l02995"></a>02995                          u_char type,
<a name="l02996" id="l02996"></a>02996                          <span class="keyword">const</span> oid * objid, <span class=
"keywordtype">size_t</span> objidlength)
<a name="l02997" id="l02997"></a>02997 {
<a name="l02998" id="l02998"></a>02998     <span class="comment">/*</span>
<a name="l02999" id="l02999"></a>02999 <span class=
"comment">     * ASN.1 objid ::= 0x06 asnlength subidentifier {subidentifier}*</span>
<a name="l03000" id="l03000"></a>03000 <span class="comment">     * subidentifier ::= {leadingbyte}* lastbyte</span>
<a name="l03001" id="l03001"></a>03001 <span class="comment">     * leadingbyte ::= 1 7bitvalue</span>
<a name="l03002" id="l03002"></a>03002 <span class="comment">     * lastbyte ::= 0 7bitvalue</span>
<a name="l03003" id="l03003"></a>03003 <span class="comment">     */</span>
<a name="l03004" id="l03004"></a>03004     <span class="keyword">register</span> <span class="keywordtype">size_t</span> i;
<a name="l03005" id="l03005"></a>03005     <span class="keyword">register</span> oid    tmpint;
<a name="l03006" id="l03006"></a>03006     <span class="keywordtype">size_t</span>          start_offset = *offset;
<a name="l03007" id="l03007"></a>03007     <span class="keyword">const</span> <span class=
"keywordtype">char</span>     *errpre = <span class="stringliteral">"build objid"</span>;
<a name="l03008" id="l03008"></a>03008 
<a name="l03009" id="l03009"></a>03009     <span class="comment">/*</span>
<a name="l03010" id="l03010"></a>03010 <span class="comment">     * Check if there are at least 2 sub-identifiers.  </span>
<a name="l03011" id="l03011"></a>03011 <span class="comment">     */</span>
<a name="l03012" id="l03012"></a>03012     <span class="keywordflow">if</span> (objidlength == 0) {
<a name="l03013" id="l03013"></a>03013         <span class="comment">/*</span>
<a name="l03014" id="l03014"></a>03014 <span class=
"comment">         * There are not, so make OID have two with value of zero.  </span>
<a name="l03015" id="l03015"></a>03015 <span class="comment">         */</span>
<a name="l03016" id="l03016"></a>03016         <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; 2) {
<a name="l03017" id="l03017"></a>03017             <span class=
"keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03018" id="l03018"></a>03018                 <span class="keywordflow">return</span> 0;
<a name="l03019" id="l03019"></a>03019             }
<a name="l03020" id="l03020"></a>03020         }
<a name="l03021" id="l03021"></a>03021 
<a name="l03022" id="l03022"></a>03022         *(*pkt + *pkt_len - (++*offset)) = 0;
<a name="l03023" id="l03023"></a>03023         *(*pkt + *pkt_len - (++*offset)) = 0;
<a name="l03024" id="l03024"></a>03024     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (objid[0] &gt; 2) {
<a name="l03025" id="l03025"></a>03025         ERROR_MSG(<span class=
"stringliteral">"build objid: bad first subidentifier"</span>);
<a name="l03026" id="l03026"></a>03026         <span class="keywordflow">return</span> 0;
<a name="l03027" id="l03027"></a>03027     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (objidlength == 1) {
<a name="l03028" id="l03028"></a>03028         <span class="comment">/*</span>
<a name="l03029" id="l03029"></a>03029 <span class="comment">         * Encode the first value.  </span>
<a name="l03030" id="l03030"></a>03030 <span class="comment">         */</span>
<a name="l03031" id="l03031"></a>03031         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03032" id="l03032"></a>03032             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03033" id="l03033"></a>03033             <span class="keywordflow">return</span> 0;
<a name="l03034" id="l03034"></a>03034         }
<a name="l03035" id="l03035"></a>03035         *(*pkt + *pkt_len - (++*offset)) = (u_char) objid[0];
<a name="l03036" id="l03036"></a>03036     } <span class="keywordflow">else</span> {
<a name="l03037" id="l03037"></a>03037         <span class="keywordflow">for</span> (i = objidlength; i &gt; 2; i--) {
<a name="l03038" id="l03038"></a>03038             tmpint = objid[i - 1];
<a name="l03039" id="l03039"></a>03039             CHECK_OVERFLOW_U(tmpint,12);
<a name="l03040" id="l03040"></a>03040 
<a name="l03041" id="l03041"></a>03041             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03042" id="l03042"></a>03042                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03043" id="l03043"></a>03043                 <span class="keywordflow">return</span> 0;
<a name="l03044" id="l03044"></a>03044             }
<a name="l03045" id="l03045"></a>03045             *(*pkt + *pkt_len - (++*offset)) = (u_char) tmpint &amp; 0x7f;
<a name="l03046" id="l03046"></a>03046             tmpint &gt;&gt;= 7;
<a name="l03047" id="l03047"></a>03047 
<a name="l03048" id="l03048"></a>03048             <span class="keywordflow">while</span> (tmpint &gt; 0) {
<a name="l03049" id="l03049"></a>03049                 <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03050" id="l03050"></a>03050                     &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03051" id="l03051"></a>03051                     <span class="keywordflow">return</span> 0;
<a name="l03052" id="l03052"></a>03052                 }
<a name="l03053" id="l03053"></a>03053                 *(*pkt + *pkt_len - (++*offset)) =
<a name="l03054" id="l03054"></a>03054                     (u_char) ((tmpint &amp; 0x7f) | 0x80);
<a name="l03055" id="l03055"></a>03055                 tmpint &gt;&gt;= 7;
<a name="l03056" id="l03056"></a>03056             }
<a name="l03057" id="l03057"></a>03057         }
<a name="l03058" id="l03058"></a>03058 
<a name="l03059" id="l03059"></a>03059         <span class="comment">/*</span>
<a name="l03060" id="l03060"></a>03060 <span class="comment">         * Combine the first two values.  </span>
<a name="l03061" id="l03061"></a>03061 <span class="comment">         */</span>
<a name="l03062" id="l03062"></a>03062         <span class="keywordflow">if</span> ((objid[1] &gt; 40) &amp;&amp;
<a name="l03063" id="l03063"></a>03063             (objid[0] &lt; 2)) {
<a name="l03064" id="l03064"></a>03064             ERROR_MSG(<span class=
"stringliteral">"build objid: bad second subidentifier"</span>);
<a name="l03065" id="l03065"></a>03065             <span class="keywordflow">return</span> 0;
<a name="l03066" id="l03066"></a>03066         }
<a name="l03067" id="l03067"></a>03067         tmpint = ((objid[0] * 40) + objid[1]);
<a name="l03068" id="l03068"></a>03068         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03069" id="l03069"></a>03069             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03070" id="l03070"></a>03070             <span class="keywordflow">return</span> 0;
<a name="l03071" id="l03071"></a>03071         }
<a name="l03072" id="l03072"></a>03072         *(*pkt + *pkt_len - (++*offset)) = (u_char) tmpint &amp; 0x7f;
<a name="l03073" id="l03073"></a>03073         tmpint &gt;&gt;= 7;
<a name="l03074" id="l03074"></a>03074 
<a name="l03075" id="l03075"></a>03075         <span class="keywordflow">while</span> (tmpint &gt; 0) {
<a name="l03076" id="l03076"></a>03076             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03077" id="l03077"></a>03077                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03078" id="l03078"></a>03078                 <span class="keywordflow">return</span> 0;
<a name="l03079" id="l03079"></a>03079             }
<a name="l03080" id="l03080"></a>03080             *(*pkt + *pkt_len - (++*offset)) =
<a name="l03081" id="l03081"></a>03081                 (u_char) ((tmpint &amp; 0x7f) | 0x80);
<a name="l03082" id="l03082"></a>03082             tmpint &gt;&gt;= 7;
<a name="l03083" id="l03083"></a>03083         }
<a name="l03084" id="l03084"></a>03084     }
<a name="l03085" id="l03085"></a>03085 
<a name="l03086" id="l03086"></a>03086     tmpint = *offset - start_offset;
<a name="l03087" id="l03087"></a>03087     <span class=
"keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r, type,
<a name="l03088" id="l03088"></a>03088                                   (*offset - start_offset))) {
<a name="l03089" id="l03089"></a>03089         <span class=
"keywordflow">if</span> (_asn_realloc_build_header_check(errpre, pkt, pkt_len,
<a name="l03090" id="l03090"></a>03090                                             (*offset - start_offset))) {
<a name="l03091" id="l03091"></a>03091             <span class="keywordflow">return</span> 0;
<a name="l03092" id="l03092"></a>03092         } <span class="keywordflow">else</span> {
<a name="l03093" id="l03093"></a>03093             DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
<a name="l03094" id="l03094"></a>03094                            (*offset - start_offset));
<a name="l03095" id="l03095"></a>03095             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  ObjID: "</span>));
<a name="l03096" id="l03096"></a>03096             DEBUGMSGOID((<span class=
"stringliteral">"dumpv_send"</span>, objid, objidlength));
<a name="l03097" id="l03097"></a>03097             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"\n"</span>));
<a name="l03098" id="l03098"></a>03098             <span class="keywordflow">return</span> 1;
<a name="l03099" id="l03099"></a>03099         }
<a name="l03100" id="l03100"></a>03100     }
<a name="l03101" id="l03101"></a>03101 
<a name="l03102" id="l03102"></a>03102     <span class="keywordflow">return</span> 0;
<a name="l03103" id="l03103"></a>03103 }
<a name="l03104" id="l03104"></a>03104 
<a name="l03121" id="l03121"></a>03121 <span class="keywordtype">int</span>
<a name="l03122" id="l03122"></a>03122 asn_realloc_rbuild_null(u_char ** pkt, <span class="keywordtype">size_t</span> * pkt_len,
<a name="l03123" id="l03123"></a>03123                         <span class="keywordtype">size_t</span> * offset, <span class=
"keywordtype">int</span> r, u_char type)
<a name="l03124" id="l03124"></a>03124 {
<a name="l03125" id="l03125"></a>03125     <span class="comment">/*</span>
<a name="l03126" id="l03126"></a>03126 <span class="comment">     * ASN.1 null ::= 0x05 0x00</span>
<a name="l03127" id="l03127"></a>03127 <span class="comment">     */</span>
<a name="l03128" id="l03128"></a>03128     <span class="keywordtype">size_t</span>          start_offset = *offset;
<a name="l03129" id="l03129"></a>03129 
<a name="l03130" id="l03130"></a>03130     <span class=
"keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r, type, 0)) {
<a name="l03131" id="l03131"></a>03131         DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
<a name="l03132" id="l03132"></a>03132                        (*offset - start_offset));
<a name="l03133" id="l03133"></a>03133         DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  NULL\n"</span>));
<a name="l03134" id="l03134"></a>03134         <span class="keywordflow">return</span> 1;
<a name="l03135" id="l03135"></a>03135     } <span class="keywordflow">else</span> {
<a name="l03136" id="l03136"></a>03136         <span class="keywordflow">return</span> 0;
<a name="l03137" id="l03137"></a>03137     }
<a name="l03138" id="l03138"></a>03138 }
<a name="l03139" id="l03139"></a>03139 
<a name="l03158" id="l03158"></a>03158 <span class="keywordtype">int</span>
<a name="l03159" id="l03159"></a>03159 asn_realloc_rbuild_bitstring(u_char ** pkt, <span class=
"keywordtype">size_t</span> * pkt_len,
<a name="l03160" id="l03160"></a>03160                              <span class=
"keywordtype">size_t</span> * offset, <span class="keywordtype">int</span> r,
<a name="l03161" id="l03161"></a>03161                              u_char type,
<a name="l03162" id="l03162"></a>03162                              <span class="keyword">const</span> u_char * str, <span class=
"keywordtype">size_t</span> strlength)
<a name="l03163" id="l03163"></a>03163 {
<a name="l03164" id="l03164"></a>03164     <span class="comment">/*</span>
<a name="l03165" id="l03165"></a>03165 <span class="comment">     * ASN.1 bit string ::= 0x03 asnlength unused {byte}*</span>
<a name="l03166" id="l03166"></a>03166 <span class="comment">     */</span>
<a name="l03167" id="l03167"></a>03167     <span class="keyword">static</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *errpre = <span class="stringliteral">"build bitstring"</span>;
<a name="l03168" id="l03168"></a>03168     <span class="keywordtype">size_t</span>          start_offset = *offset;
<a name="l03169" id="l03169"></a>03169 
<a name="l03170" id="l03170"></a>03170     <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; strlength) {
<a name="l03171" id="l03171"></a>03171         <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03172" id="l03172"></a>03172             <span class="keywordflow">return</span> 0;
<a name="l03173" id="l03173"></a>03173         }
<a name="l03174" id="l03174"></a>03174     }
<a name="l03175" id="l03175"></a>03175 
<a name="l03176" id="l03176"></a>03176     *offset += strlength;
<a name="l03177" id="l03177"></a>03177     memcpy(*pkt + *pkt_len - *offset, str, strlength);
<a name="l03178" id="l03178"></a>03178 
<a name="l03179" id="l03179"></a>03179     <span class="keywordflow">if</span> (asn_realloc_rbuild_header
<a name="l03180" id="l03180"></a>03180         (pkt, pkt_len, offset, r, type, strlength)) {
<a name="l03181" id="l03181"></a>03181         <span class="keywordflow">if</span> (_asn_realloc_build_header_check
<a name="l03182" id="l03182"></a>03182             (errpre, pkt, pkt_len, strlength)) {
<a name="l03183" id="l03183"></a>03183             <span class="keywordflow">return</span> 0;
<a name="l03184" id="l03184"></a>03184         } <span class="keywordflow">else</span> {
<a name="l03185" id="l03185"></a>03185             DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
<a name="l03186" id="l03186"></a>03186                            *offset - start_offset);
<a name="l03187" id="l03187"></a>03187             DEBUGIF(<span class="stringliteral">"dumpv_send"</span>) {
<a name="l03188" id="l03188"></a>03188                 <span class="keywordflow">if</span> (strlength == 0) {
<a name="l03189" id="l03189"></a>03189                     DEBUGMSG((<span class=
"stringliteral">"dumpv_send"</span>, <span class="stringliteral">"  Bitstring: [NULL]\n"</span>));
<a name="l03190" id="l03190"></a>03190                 } <span class="keywordflow">else</span> {
<a name="l03191" id="l03191"></a>03191                     u_char         *buf = (u_char *) malloc(2 * strlength);
<a name="l03192" id="l03192"></a>03192                     <span class="keywordtype">size_t</span>          l =
<a name="l03193" id="l03193"></a>03193                         (buf != NULL) ? (2 * strlength) : 0, ol = 0;
<a name="l03194" id="l03194"></a>03194 
<a name="l03195" id="l03195"></a>03195                     <span class="keywordflow">if</span> (<a class="code" href=
"group__mib__utilities.html#ga7ff1971fc340b2789d48895086bf3230" title=
"Prints an ascii string into a buffer.">sprint_realloc_asciistring</a>
<a name="l03196" id="l03196"></a>03196                         (&amp;buf, &amp;l, &amp;ol, 1, str, strlength)) {
<a name="l03197" id="l03197"></a>03197                         DEBUGMSG((<span class=
"stringliteral">"dumpv_send"</span>, <span class="stringliteral">"  Bitstring:\t%s\n"</span>,
<a name="l03198" id="l03198"></a>03198                                   buf));
<a name="l03199" id="l03199"></a>03199                     } <span class="keywordflow">else</span> {
<a name="l03200" id="l03200"></a>03200                         <span class="keywordflow">if</span> (buf == NULL) {
<a name="l03201" id="l03201"></a>03201                             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>,
<a name="l03202" id="l03202"></a>03202                                       <span class=
"stringliteral">"  Bitstring:\t[TRUNCATED]\n"</span>));
<a name="l03203" id="l03203"></a>03203                         } <span class="keywordflow">else</span> {
<a name="l03204" id="l03204"></a>03204                             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>,
<a name="l03205" id="l03205"></a>03205                                       <span class=
"stringliteral">"  Bitstring:\t%s [TRUNCATED]\n"</span>,
<a name="l03206" id="l03206"></a>03206                                       buf));
<a name="l03207" id="l03207"></a>03207                         }
<a name="l03208" id="l03208"></a>03208                     }
<a name="l03209" id="l03209"></a>03209                     <span class="keywordflow">if</span> (buf != NULL) {
<a name="l03210" id="l03210"></a>03210                         free(buf);
<a name="l03211" id="l03211"></a>03211                     }
<a name="l03212" id="l03212"></a>03212                 }
<a name="l03213" id="l03213"></a>03213             }
<a name="l03214" id="l03214"></a>03214         }
<a name="l03215" id="l03215"></a>03215         <span class="keywordflow">return</span> 1;
<a name="l03216" id="l03216"></a>03216     }
<a name="l03217" id="l03217"></a>03217 
<a name="l03218" id="l03218"></a>03218     <span class="keywordflow">return</span> 0;
<a name="l03219" id="l03219"></a>03219 }
<a name="l03220" id="l03220"></a>03220 
<a name="l03238" id="l03238"></a>03238 <span class="keywordtype">int</span>
<a name="l03239" id="l03239"></a>03239 asn_realloc_rbuild_unsigned_int64(u_char ** pkt, <span class=
"keywordtype">size_t</span> * pkt_len,
<a name="l03240" id="l03240"></a>03240                                   <span class=
"keywordtype">size_t</span> * offset, <span class="keywordtype">int</span> r,
<a name="l03241" id="l03241"></a>03241                                   u_char type,
<a name="l03242" id="l03242"></a>03242                                <span class="keyword">const</span> <span class=
"keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a> *cp, <span class=
"keywordtype">size_t</span> countersize)
<a name="l03243" id="l03243"></a>03243 {
<a name="l03244" id="l03244"></a>03244     <span class="comment">/*</span>
<a name="l03245" id="l03245"></a>03245 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
<a name="l03246" id="l03246"></a>03246 <span class="comment">     */</span>
<a name="l03247" id="l03247"></a>03247     <span class="keyword">register</span> u_long low = cp-&gt;low, high = cp-&gt;high;
<a name="l03248" id="l03248"></a>03248     <span class="keywordtype">size_t</span>          intsize, start_offset = *offset;
<a name="l03249" id="l03249"></a>03249     <span class="keywordtype">int</span>             count;
<a name="l03250" id="l03250"></a>03250 
<a name="l03251" id="l03251"></a>03251     <span class="keywordflow">if</span> (countersize != <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a>)) {
<a name="l03252" id="l03252"></a>03252         _asn_size_err(<span class="stringliteral">"build uint64"</span>, countersize,
<a name="l03253" id="l03253"></a>03253                       <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a>));
<a name="l03254" id="l03254"></a>03254         <span class="keywordflow">return</span> 0;
<a name="l03255" id="l03255"></a>03255     }
<a name="l03256" id="l03256"></a>03256 
<a name="l03257" id="l03257"></a>03257     CHECK_OVERFLOW_U(high,13);
<a name="l03258" id="l03258"></a>03258     CHECK_OVERFLOW_U(low,13);
<a name="l03259" id="l03259"></a>03259 
<a name="l03260" id="l03260"></a>03260     <span class="comment">/*</span>
<a name="l03261" id="l03261"></a>03261 <span class="comment">     * Encode the low 4 bytes first.  </span>
<a name="l03262" id="l03262"></a>03262 <span class="comment">     */</span>
<a name="l03263" id="l03263"></a>03263     <span class=
"keywordflow">if</span> (((*pkt_len - *offset) &lt; 1) &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03264" id="l03264"></a>03264         <span class="keywordflow">return</span> 0;
<a name="l03265" id="l03265"></a>03265     }
<a name="l03266" id="l03266"></a>03266     *(*pkt + *pkt_len - (++*offset)) = (u_char) low;
<a name="l03267" id="l03267"></a>03267     low &gt;&gt;= 8;
<a name="l03268" id="l03268"></a>03268     count = 1;
<a name="l03269" id="l03269"></a>03269 
<a name="l03270" id="l03270"></a>03270     <span class="keywordflow">while</span> (low != 0) {
<a name="l03271" id="l03271"></a>03271         count++;
<a name="l03272" id="l03272"></a>03272         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03273" id="l03273"></a>03273             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03274" id="l03274"></a>03274             <span class="keywordflow">return</span> 0;
<a name="l03275" id="l03275"></a>03275         }
<a name="l03276" id="l03276"></a>03276         *(*pkt + *pkt_len - (++*offset)) = (u_char) low;
<a name="l03277" id="l03277"></a>03277         low &gt;&gt;= 8;
<a name="l03278" id="l03278"></a>03278     }
<a name="l03279" id="l03279"></a>03279 
<a name="l03280" id="l03280"></a>03280     <span class="comment">/*</span>
<a name="l03281" id="l03281"></a>03281 <span class="comment">     * Then the high byte if present.  </span>
<a name="l03282" id="l03282"></a>03282 <span class="comment">     */</span>
<a name="l03283" id="l03283"></a>03283     <span class="keywordflow">if</span> (high) {
<a name="l03284" id="l03284"></a>03284         <span class="comment">/*</span>
<a name="l03285" id="l03285"></a>03285 <span class="comment">         * Do the rest of the low byte.  </span>
<a name="l03286" id="l03286"></a>03286 <span class="comment">         */</span>
<a name="l03287" id="l03287"></a>03287         <span class="keywordflow">for</span> (; count &lt; 4; count++) {
<a name="l03288" id="l03288"></a>03288             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03289" id="l03289"></a>03289                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03290" id="l03290"></a>03290                 <span class="keywordflow">return</span> 0;
<a name="l03291" id="l03291"></a>03291             }
<a name="l03292" id="l03292"></a>03292             *(*pkt + *pkt_len - (++*offset)) = 0;
<a name="l03293" id="l03293"></a>03293         }
<a name="l03294" id="l03294"></a>03294 
<a name="l03295" id="l03295"></a>03295         <span class="comment">/*</span>
<a name="l03296" id="l03296"></a>03296 <span class="comment">         * Do high byte.  </span>
<a name="l03297" id="l03297"></a>03297 <span class="comment">         */</span>
<a name="l03298" id="l03298"></a>03298         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03299" id="l03299"></a>03299             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03300" id="l03300"></a>03300             <span class="keywordflow">return</span> 0;
<a name="l03301" id="l03301"></a>03301         }
<a name="l03302" id="l03302"></a>03302         *(*pkt + *pkt_len - (++*offset)) = (u_char) high;
<a name="l03303" id="l03303"></a>03303         high &gt;&gt;= 8;
<a name="l03304" id="l03304"></a>03304 
<a name="l03305" id="l03305"></a>03305         <span class="keywordflow">while</span> (high != 0) {
<a name="l03306" id="l03306"></a>03306             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03307" id="l03307"></a>03307                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03308" id="l03308"></a>03308                 <span class="keywordflow">return</span> 0;
<a name="l03309" id="l03309"></a>03309             }
<a name="l03310" id="l03310"></a>03310             *(*pkt + *pkt_len - (++*offset)) = (u_char) high;
<a name="l03311" id="l03311"></a>03311             high &gt;&gt;= 8;
<a name="l03312" id="l03312"></a>03312         }
<a name="l03313" id="l03313"></a>03313     }
<a name="l03314" id="l03314"></a>03314 
<a name="l03315" id="l03315"></a>03315     <span class=
"keywordflow">if</span> ((*(*pkt + *pkt_len - *offset) &amp; 0x80) != (0 &amp; 0x80)) {
<a name="l03316" id="l03316"></a>03316         <span class="comment">/*</span>
<a name="l03317" id="l03317"></a>03317 <span class=
"comment">         * Make sure left most bit is representational of the rest of the bits</span>
<a name="l03318" id="l03318"></a>03318 <span class="comment">         * that aren't encoded.  </span>
<a name="l03319" id="l03319"></a>03319 <span class="comment">         */</span>
<a name="l03320" id="l03320"></a>03320         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03321" id="l03321"></a>03321             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03322" id="l03322"></a>03322             <span class="keywordflow">return</span> 0;
<a name="l03323" id="l03323"></a>03323         }
<a name="l03324" id="l03324"></a>03324         *(*pkt + *pkt_len - (++*offset)) = 0;
<a name="l03325" id="l03325"></a>03325     }
<a name="l03326" id="l03326"></a>03326 
<a name="l03327" id="l03327"></a>03327     intsize = *offset - start_offset;
<a name="l03328" id="l03328"></a>03328 
<a name="l03329" id="l03329"></a>03329 <span class="preprocessor">#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES</span>
<a name="l03330" id="l03330"></a>03330     <span class="comment">/*</span>
<a name="l03331" id="l03331"></a>03331 <span class=
"comment">     * Encode a Counter64 as an opaque (it also works in SNMPv1).  </span>
<a name="l03332" id="l03332"></a>03332 <span class="comment">     */</span>
<a name="l03333" id="l03333"></a>03333     <span class="keywordflow">if</span> (type == ASN_OPAQUE_COUNTER64) {
<a name="l03334" id="l03334"></a>03334         <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; 5) {
<a name="l03335" id="l03335"></a>03335             <span class=
"keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03336" id="l03336"></a>03336                 <span class="keywordflow">return</span> 0;
<a name="l03337" id="l03337"></a>03337             }
<a name="l03338" id="l03338"></a>03338         }
<a name="l03339" id="l03339"></a>03339 
<a name="l03340" id="l03340"></a>03340         *(*pkt + *pkt_len - (++*offset)) = (u_char) intsize;
<a name="l03341" id="l03341"></a>03341         *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_COUNTER64;
<a name="l03342" id="l03342"></a>03342         *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_TAG1;
<a name="l03343" id="l03343"></a>03343 
<a name="l03344" id="l03344"></a>03344         <span class="comment">/*</span>
<a name="l03345" id="l03345"></a>03345 <span class="comment">         * Put the tag and length for the Opaque wrapper.  </span>
<a name="l03346" id="l03346"></a>03346 <span class="comment">         */</span>
<a name="l03347" id="l03347"></a>03347         <span class=
"keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r,
<a name="l03348" id="l03348"></a>03348                                       ASN_OPAQUE, intsize + 3)) {
<a name="l03349" id="l03349"></a>03349             <span class="keywordflow">if</span> (_asn_realloc_build_header_check
<a name="l03350" id="l03350"></a>03350                 (<span class=
"stringliteral">"build counter u64"</span>, pkt, pkt_len, intsize + 3)) {
<a name="l03351" id="l03351"></a>03351                 <span class="keywordflow">return</span> 0;
<a name="l03352" id="l03352"></a>03352             }
<a name="l03353" id="l03353"></a>03353         } <span class="keywordflow">else</span> {
<a name="l03354" id="l03354"></a>03354             <span class="keywordflow">return</span> 0;
<a name="l03355" id="l03355"></a>03355         }
<a name="l03356" id="l03356"></a>03356     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (type == ASN_OPAQUE_U64) {
<a name="l03357" id="l03357"></a>03357         <span class="comment">/*</span>
<a name="l03358" id="l03358"></a>03358 <span class="comment">         * Encode the Unsigned int64 in an opaque.  </span>
<a name="l03359" id="l03359"></a>03359 <span class="comment">         */</span>
<a name="l03360" id="l03360"></a>03360         <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; 5) {
<a name="l03361" id="l03361"></a>03361             <span class=
"keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03362" id="l03362"></a>03362                 <span class="keywordflow">return</span> 0;
<a name="l03363" id="l03363"></a>03363             }
<a name="l03364" id="l03364"></a>03364         }
<a name="l03365" id="l03365"></a>03365 
<a name="l03366" id="l03366"></a>03366         *(*pkt + *pkt_len - (++*offset)) = (u_char) intsize;
<a name="l03367" id="l03367"></a>03367         *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_U64;
<a name="l03368" id="l03368"></a>03368         *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_TAG1;
<a name="l03369" id="l03369"></a>03369 
<a name="l03370" id="l03370"></a>03370         <span class="comment">/*</span>
<a name="l03371" id="l03371"></a>03371 <span class="comment">         * Put the tag and length for the Opaque wrapper.  </span>
<a name="l03372" id="l03372"></a>03372 <span class="comment">         */</span>
<a name="l03373" id="l03373"></a>03373         <span class=
"keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r,
<a name="l03374" id="l03374"></a>03374                                       ASN_OPAQUE, intsize + 3)) {
<a name="l03375" id="l03375"></a>03375             <span class="keywordflow">if</span> (_asn_realloc_build_header_check
<a name="l03376" id="l03376"></a>03376                 (<span class=
"stringliteral">"build counter u64"</span>, pkt, pkt_len, intsize + 3)) {
<a name="l03377" id="l03377"></a>03377                 <span class="keywordflow">return</span> 0;
<a name="l03378" id="l03378"></a>03378             }
<a name="l03379" id="l03379"></a>03379         } <span class="keywordflow">else</span> {
<a name="l03380" id="l03380"></a>03380             <span class="keywordflow">return</span> 0;
<a name="l03381" id="l03381"></a>03381         }
<a name="l03382" id="l03382"></a>03382     } <span class="keywordflow">else</span> {
<a name="l03383" id="l03383"></a>03383 
<a name="l03384" id="l03384"></a>03384 <span class="preprocessor">#endif                          </span><span class=
"comment">/* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */</span>
<a name="l03385" id="l03385"></a>03385         <span class="keywordflow">if</span> (asn_realloc_rbuild_header
<a name="l03386" id="l03386"></a>03386             (pkt, pkt_len, offset, r, type, intsize)) {
<a name="l03387" id="l03387"></a>03387             <span class="keywordflow">if</span> (_asn_realloc_build_header_check
<a name="l03388" id="l03388"></a>03388                 (<span class=
"stringliteral">"build uint64"</span>, pkt, pkt_len, intsize)) {
<a name="l03389" id="l03389"></a>03389                 <span class="keywordflow">return</span> 0;
<a name="l03390" id="l03390"></a>03390             }
<a name="l03391" id="l03391"></a>03391         } <span class="keywordflow">else</span> {
<a name="l03392" id="l03392"></a>03392             <span class="keywordflow">return</span> 0;
<a name="l03393" id="l03393"></a>03393         }
<a name="l03394" id="l03394"></a>03394 <span class="preprocessor">#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES</span>
<a name="l03395" id="l03395"></a>03395     }
<a name="l03396" id="l03396"></a>03396 <span class="preprocessor">#endif                          </span><span class=
"comment">/* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */</span>
<a name="l03397" id="l03397"></a>03397 
<a name="l03398" id="l03398"></a>03398     DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, (*pkt + *pkt_len - *offset), intsize);
<a name="l03399" id="l03399"></a>03399     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  U64:\t%lu %lu\n"</span>, cp-&gt;high, cp-&gt;low));
<a name="l03400" id="l03400"></a>03400     <span class="keywordflow">return</span> 1;
<a name="l03401" id="l03401"></a>03401 }
<a name="l03402" id="l03402"></a>03402 
<a name="l03403" id="l03403"></a>03403 <span class="preprocessor">#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES</span>
<a name="l03404" id="l03404"></a>03404 
<a name="l03405" id="l03405"></a>03405 
<a name="l03423" id="l03423"></a>03423 <span class="keywordtype">int</span>
<a name="l03424" id="l03424"></a>03424 asn_realloc_rbuild_signed_int64(u_char ** pkt, <span class=
"keywordtype">size_t</span> * pkt_len,
<a name="l03425" id="l03425"></a>03425                                 <span class=
"keywordtype">size_t</span> * offset, <span class="keywordtype">int</span> r,
<a name="l03426" id="l03426"></a>03426                                 u_char type,
<a name="l03427" id="l03427"></a>03427                                 <span class="keyword">const</span> <span class=
"keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a> *cp, <span class=
"keywordtype">size_t</span> countersize)
<a name="l03428" id="l03428"></a>03428 {
<a name="l03429" id="l03429"></a>03429     <span class="comment">/*</span>
<a name="l03430" id="l03430"></a>03430 <span class="comment">     * ASN.1 integer ::= 0x02 asnlength byte {byte}*</span>
<a name="l03431" id="l03431"></a>03431 <span class="comment">     */</span>
<a name="l03432" id="l03432"></a>03432     <span class="keyword">register</span> <span class=
"keywordtype">long</span> low = cp-&gt;low, high = cp-&gt;high;
<a name="l03433" id="l03433"></a>03433     <span class="keywordtype">size_t</span>          intsize, start_offset = *offset;
<a name="l03434" id="l03434"></a>03434     <span class=
"keywordtype">int</span>             count, testvalue = (high &amp; 0x80000000) ? -1 : 0;
<a name="l03435" id="l03435"></a>03435 
<a name="l03436" id="l03436"></a>03436     <span class="keywordflow">if</span> (countersize != <span class=
"keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a>)) {
<a name="l03437" id="l03437"></a>03437         _asn_size_err(<span class="stringliteral">"build uint64"</span>, countersize,
<a name="l03438" id="l03438"></a>03438                       <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> <a class="code" href="structcounter64.html">counter64</a>));
<a name="l03439" id="l03439"></a>03439         <span class="keywordflow">return</span> 0;
<a name="l03440" id="l03440"></a>03440     }
<a name="l03441" id="l03441"></a>03441 
<a name="l03442" id="l03442"></a>03442     CHECK_OVERFLOW_S(high,14);
<a name="l03443" id="l03443"></a>03443     CHECK_OVERFLOW_U(low,14);
<a name="l03444" id="l03444"></a>03444 
<a name="l03445" id="l03445"></a>03445     <span class="comment">/*</span>
<a name="l03446" id="l03446"></a>03446 <span class="comment">     * Encode the low 4 bytes first.  </span>
<a name="l03447" id="l03447"></a>03447 <span class="comment">     */</span>
<a name="l03448" id="l03448"></a>03448     <span class=
"keywordflow">if</span> (((*pkt_len - *offset) &lt; 1) &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03449" id="l03449"></a>03449         <span class="keywordflow">return</span> 0;
<a name="l03450" id="l03450"></a>03450     }
<a name="l03451" id="l03451"></a>03451     *(*pkt + *pkt_len - (++*offset)) = (u_char) low;
<a name="l03452" id="l03452"></a>03452     low &gt;&gt;= 8;
<a name="l03453" id="l03453"></a>03453     count = 1;
<a name="l03454" id="l03454"></a>03454 
<a name="l03455" id="l03455"></a>03455     <span class="keywordflow">while</span> ((<span class=
"keywordtype">int</span>) low != testvalue &amp;&amp; count &lt; 4) {
<a name="l03456" id="l03456"></a>03456         count++;
<a name="l03457" id="l03457"></a>03457         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03458" id="l03458"></a>03458             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03459" id="l03459"></a>03459             <span class="keywordflow">return</span> 0;
<a name="l03460" id="l03460"></a>03460         }
<a name="l03461" id="l03461"></a>03461         *(*pkt + *pkt_len - (++*offset)) = (u_char) low;
<a name="l03462" id="l03462"></a>03462         low &gt;&gt;= 8;
<a name="l03463" id="l03463"></a>03463     }
<a name="l03464" id="l03464"></a>03464 
<a name="l03465" id="l03465"></a>03465     <span class="comment">/*</span>
<a name="l03466" id="l03466"></a>03466 <span class="comment">     * Then the high byte if present.  </span>
<a name="l03467" id="l03467"></a>03467 <span class="comment">     */</span>
<a name="l03468" id="l03468"></a>03468     <span class="keywordflow">if</span> (high != testvalue) {
<a name="l03469" id="l03469"></a>03469         <span class="comment">/*</span>
<a name="l03470" id="l03470"></a>03470 <span class="comment">         * Do the rest of the low byte.  </span>
<a name="l03471" id="l03471"></a>03471 <span class="comment">         */</span>
<a name="l03472" id="l03472"></a>03472         <span class="keywordflow">for</span> (; count &lt; 4; count++) {
<a name="l03473" id="l03473"></a>03473             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03474" id="l03474"></a>03474                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03475" id="l03475"></a>03475                 <span class="keywordflow">return</span> 0;
<a name="l03476" id="l03476"></a>03476             }
<a name="l03477" id="l03477"></a>03477             *(*pkt + *pkt_len - (++*offset)) = (testvalue == 0) ? 0 : 0xff;
<a name="l03478" id="l03478"></a>03478         }
<a name="l03479" id="l03479"></a>03479 
<a name="l03480" id="l03480"></a>03480         <span class="comment">/*</span>
<a name="l03481" id="l03481"></a>03481 <span class="comment">         * Do high byte.  </span>
<a name="l03482" id="l03482"></a>03482 <span class="comment">         */</span>
<a name="l03483" id="l03483"></a>03483         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03484" id="l03484"></a>03484             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03485" id="l03485"></a>03485             <span class="keywordflow">return</span> 0;
<a name="l03486" id="l03486"></a>03486         }
<a name="l03487" id="l03487"></a>03487         *(*pkt + *pkt_len - (++*offset)) = (u_char) high;
<a name="l03488" id="l03488"></a>03488         high &gt;&gt;= 8;
<a name="l03489" id="l03489"></a>03489 
<a name="l03490" id="l03490"></a>03490         <span class="keywordflow">while</span> ((<span class=
"keywordtype">int</span>) high != testvalue) {
<a name="l03491" id="l03491"></a>03491             <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03492" id="l03492"></a>03492                 &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03493" id="l03493"></a>03493                 <span class="keywordflow">return</span> 0;
<a name="l03494" id="l03494"></a>03494             }
<a name="l03495" id="l03495"></a>03495             *(*pkt + *pkt_len - (++*offset)) = (u_char) high;
<a name="l03496" id="l03496"></a>03496             high &gt;&gt;= 8;
<a name="l03497" id="l03497"></a>03497         }
<a name="l03498" id="l03498"></a>03498     }
<a name="l03499" id="l03499"></a>03499 
<a name="l03500" id="l03500"></a>03500     <span class=
"keywordflow">if</span> ((*(*pkt + *pkt_len - *offset) &amp; 0x80) != (testvalue &amp; 0x80)) {
<a name="l03501" id="l03501"></a>03501         <span class="comment">/*</span>
<a name="l03502" id="l03502"></a>03502 <span class=
"comment">         * Make sure left most bit is representational of the rest of the bits</span>
<a name="l03503" id="l03503"></a>03503 <span class="comment">         * that aren't encoded.  </span>
<a name="l03504" id="l03504"></a>03504 <span class="comment">         */</span>
<a name="l03505" id="l03505"></a>03505         <span class="keywordflow">if</span> (((*pkt_len - *offset) &lt; 1)
<a name="l03506" id="l03506"></a>03506             &amp;&amp; !(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03507" id="l03507"></a>03507             <span class="keywordflow">return</span> 0;
<a name="l03508" id="l03508"></a>03508         }
<a name="l03509" id="l03509"></a>03509         *(*pkt + *pkt_len - (++*offset)) = (testvalue == 0) ? 0 : 0xff;
<a name="l03510" id="l03510"></a>03510     }
<a name="l03511" id="l03511"></a>03511 
<a name="l03512" id="l03512"></a>03512     intsize = *offset - start_offset;
<a name="l03513" id="l03513"></a>03513 
<a name="l03514" id="l03514"></a>03514     <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; 5) {
<a name="l03515" id="l03515"></a>03515         <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03516" id="l03516"></a>03516             <span class="keywordflow">return</span> 0;
<a name="l03517" id="l03517"></a>03517         }
<a name="l03518" id="l03518"></a>03518     }
<a name="l03519" id="l03519"></a>03519 
<a name="l03520" id="l03520"></a>03520     *(*pkt + *pkt_len - (++*offset)) = (u_char) intsize;
<a name="l03521" id="l03521"></a>03521     *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_I64;
<a name="l03522" id="l03522"></a>03522     *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_TAG1;
<a name="l03523" id="l03523"></a>03523 
<a name="l03524" id="l03524"></a>03524     <span class="comment">/*</span>
<a name="l03525" id="l03525"></a>03525 <span class="comment">     * Put the tag and length for the Opaque wrapper.  </span>
<a name="l03526" id="l03526"></a>03526 <span class="comment">     */</span>
<a name="l03527" id="l03527"></a>03527     <span class=
"keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r,
<a name="l03528" id="l03528"></a>03528                                   ASN_OPAQUE, intsize + 3)) {
<a name="l03529" id="l03529"></a>03529         <span class="keywordflow">if</span> (_asn_realloc_build_header_check
<a name="l03530" id="l03530"></a>03530             (<span class=
"stringliteral">"build counter u64"</span>, pkt, pkt_len, intsize + 3)) {
<a name="l03531" id="l03531"></a>03531             <span class="keywordflow">return</span> 0;
<a name="l03532" id="l03532"></a>03532         }
<a name="l03533" id="l03533"></a>03533     } <span class="keywordflow">else</span> {
<a name="l03534" id="l03534"></a>03534         <span class="keywordflow">return</span> 0;
<a name="l03535" id="l03535"></a>03535     }
<a name="l03536" id="l03536"></a>03536 
<a name="l03537" id="l03537"></a>03537     DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, (*pkt + *pkt_len - *offset), intsize);
<a name="l03538" id="l03538"></a>03538     DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  UInt64:\t%lu %lu\n"</span>, cp-&gt;high, cp-&gt;low));
<a name="l03539" id="l03539"></a>03539     <span class="keywordflow">return</span> 1;
<a name="l03540" id="l03540"></a>03540 }
<a name="l03541" id="l03541"></a>03541 
<a name="l03560" id="l03560"></a>03560 <span class="keywordtype">int</span>
<a name="l03561" id="l03561"></a>03561 asn_realloc_rbuild_float(u_char ** pkt, <span class="keywordtype">size_t</span> * pkt_len,
<a name="l03562" id="l03562"></a>03562                          <span class="keywordtype">size_t</span> * offset, <span class=
"keywordtype">int</span> r,
<a name="l03563" id="l03563"></a>03563                          u_char type, <span class="keyword">const</span> <span class=
"keywordtype">float</span> *floatp, <span class="keywordtype">size_t</span> floatsize)
<a name="l03564" id="l03564"></a>03564 {
<a name="l03565" id="l03565"></a>03565     <span class="keywordtype">size_t</span>          start_offset = *offset;
<a name="l03566" id="l03566"></a>03566     <span class="keyword">union </span>{
<a name="l03567" id="l03567"></a>03567         <span class="keywordtype">float</span>           floatVal;
<a name="l03568" id="l03568"></a>03568         <span class="keywordtype">int</span>             intVal;
<a name="l03569" id="l03569"></a>03569         u_char          c[<span class="keyword">sizeof</span>(float)];
<a name="l03570" id="l03570"></a>03570     } fu;
<a name="l03571" id="l03571"></a>03571 
<a name="l03572" id="l03572"></a>03572     <span class="comment">/*</span>
<a name="l03573" id="l03573"></a>03573 <span class="comment">     * Floatsize better not be larger than realistic.  </span>
<a name="l03574" id="l03574"></a>03574 <span class="comment">     */</span>
<a name="l03575" id="l03575"></a>03575     <span class="keywordflow">if</span> (floatsize != <span class=
"keyword">sizeof</span>(<span class="keywordtype">float</span>) || floatsize &gt; 122) {
<a name="l03576" id="l03576"></a>03576         <span class="keywordflow">return</span> 0;
<a name="l03577" id="l03577"></a>03577     }
<a name="l03578" id="l03578"></a>03578 
<a name="l03579" id="l03579"></a>03579     <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; floatsize + 3) {
<a name="l03580" id="l03580"></a>03580         <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03581" id="l03581"></a>03581             <span class="keywordflow">return</span> 0;
<a name="l03582" id="l03582"></a>03582         }
<a name="l03583" id="l03583"></a>03583     }
<a name="l03584" id="l03584"></a>03584 
<a name="l03585" id="l03585"></a>03585     <span class="comment">/*</span>
<a name="l03586" id="l03586"></a>03586 <span class="comment">     * Correct for endian differences and copy value.  </span>
<a name="l03587" id="l03587"></a>03587 <span class="comment">     */</span>
<a name="l03588" id="l03588"></a>03588     fu.floatVal = *floatp;
<a name="l03589" id="l03589"></a>03589     fu.intVal = htonl(fu.intVal);
<a name="l03590" id="l03590"></a>03590     *offset += floatsize;
<a name="l03591" id="l03591"></a>03591     memcpy(*pkt + *pkt_len - *offset, &amp;(fu.c[0]), floatsize);
<a name="l03592" id="l03592"></a>03592 
<a name="l03593" id="l03593"></a>03593     <span class="comment">/*</span>
<a name="l03594" id="l03594"></a>03594 <span class="comment">     * Put the special tag and length (3 bytes).  </span>
<a name="l03595" id="l03595"></a>03595 <span class="comment">     */</span>
<a name="l03596" id="l03596"></a>03596     *(*pkt + *pkt_len - (++*offset)) = (u_char) floatsize;
<a name="l03597" id="l03597"></a>03597     *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_FLOAT;
<a name="l03598" id="l03598"></a>03598     *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_TAG1;
<a name="l03599" id="l03599"></a>03599 
<a name="l03600" id="l03600"></a>03600     <span class="comment">/*</span>
<a name="l03601" id="l03601"></a>03601 <span class="comment">     * Put the tag and length for the Opaque wrapper.  </span>
<a name="l03602" id="l03602"></a>03602 <span class="comment">     */</span>
<a name="l03603" id="l03603"></a>03603     <span class=
"keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r,
<a name="l03604" id="l03604"></a>03604                                   ASN_OPAQUE, floatsize + 3)) {
<a name="l03605" id="l03605"></a>03605         <span class="keywordflow">if</span> (_asn_realloc_build_header_check(<span class=
"stringliteral">"build float"</span>, pkt, pkt_len,
<a name="l03606" id="l03606"></a>03606                                             floatsize + 3)) {
<a name="l03607" id="l03607"></a>03607             <span class="keywordflow">return</span> 0;
<a name="l03608" id="l03608"></a>03608         } <span class="keywordflow">else</span> {
<a name="l03609" id="l03609"></a>03609             DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
<a name="l03610" id="l03610"></a>03610                            *offset - start_offset);
<a name="l03611" id="l03611"></a>03611             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"Opaque Float:\t%f\n"</span>, *floatp));
<a name="l03612" id="l03612"></a>03612             <span class="keywordflow">return</span> 1;
<a name="l03613" id="l03613"></a>03613         }
<a name="l03614" id="l03614"></a>03614     }
<a name="l03615" id="l03615"></a>03615 
<a name="l03616" id="l03616"></a>03616     <span class="keywordflow">return</span> 0;
<a name="l03617" id="l03617"></a>03617 }
<a name="l03618" id="l03618"></a>03618 
<a name="l03637" id="l03637"></a>03637 <span class="keywordtype">int</span>
<a name="l03638" id="l03638"></a>03638 asn_realloc_rbuild_double(u_char ** pkt, <span class=
"keywordtype">size_t</span> * pkt_len,
<a name="l03639" id="l03639"></a>03639                           <span class="keywordtype">size_t</span> * offset, <span class=
"keywordtype">int</span> r,
<a name="l03640" id="l03640"></a>03640                           u_char type, <span class="keyword">const</span> <span class=
"keywordtype">double</span> *doublep, <span class="keywordtype">size_t</span> doublesize)
<a name="l03641" id="l03641"></a>03641 {
<a name="l03642" id="l03642"></a>03642     <span class="keywordtype">size_t</span>          start_offset = *offset;
<a name="l03643" id="l03643"></a>03643     <span class="keywordtype">long</span>            tmp;
<a name="l03644" id="l03644"></a>03644     <span class="keyword">union </span>{
<a name="l03645" id="l03645"></a>03645         <span class="keywordtype">double</span>          doubleVal;
<a name="l03646" id="l03646"></a>03646         <span class="keywordtype">int</span>             intVal[2];
<a name="l03647" id="l03647"></a>03647         u_char          c[<span class="keyword">sizeof</span>(double)];
<a name="l03648" id="l03648"></a>03648     } fu;
<a name="l03649" id="l03649"></a>03649 
<a name="l03650" id="l03650"></a>03650     <span class="comment">/*</span>
<a name="l03651" id="l03651"></a>03651 <span class="comment">     * Doublesize better not be larger than realistic.  </span>
<a name="l03652" id="l03652"></a>03652 <span class="comment">     */</span>
<a name="l03653" id="l03653"></a>03653     <span class="keywordflow">if</span> (doublesize != <span class=
"keyword">sizeof</span>(<span class="keywordtype">double</span>) || doublesize &gt; 122) {
<a name="l03654" id="l03654"></a>03654         <span class="keywordflow">return</span> 0;
<a name="l03655" id="l03655"></a>03655     }
<a name="l03656" id="l03656"></a>03656 
<a name="l03657" id="l03657"></a>03657     <span class="keywordflow">while</span> ((*pkt_len - *offset) &lt; doublesize + 3) {
<a name="l03658" id="l03658"></a>03658         <span class="keywordflow">if</span> (!(r &amp;&amp; asn_realloc(pkt, pkt_len))) {
<a name="l03659" id="l03659"></a>03659             <span class="keywordflow">return</span> 0;
<a name="l03660" id="l03660"></a>03660         }
<a name="l03661" id="l03661"></a>03661     }
<a name="l03662" id="l03662"></a>03662 
<a name="l03663" id="l03663"></a>03663     <span class="comment">/*</span>
<a name="l03664" id="l03664"></a>03664 <span class="comment">     * Correct for endian differences and copy value.  </span>
<a name="l03665" id="l03665"></a>03665 <span class="comment">     */</span>
<a name="l03666" id="l03666"></a>03666     fu.doubleVal = *doublep;
<a name="l03667" id="l03667"></a>03667     tmp = htonl(fu.intVal[0]);
<a name="l03668" id="l03668"></a>03668     fu.intVal[0] = htonl(fu.intVal[1]);
<a name="l03669" id="l03669"></a>03669     fu.intVal[1] = tmp;
<a name="l03670" id="l03670"></a>03670     *offset += doublesize;
<a name="l03671" id="l03671"></a>03671     memcpy(*pkt + *pkt_len - *offset, &amp;(fu.c[0]), doublesize);
<a name="l03672" id="l03672"></a>03672 
<a name="l03673" id="l03673"></a>03673     <span class="comment">/*</span>
<a name="l03674" id="l03674"></a>03674 <span class="comment">     * Put the special tag and length (3 bytes).  </span>
<a name="l03675" id="l03675"></a>03675 <span class="comment">     */</span>
<a name="l03676" id="l03676"></a>03676     *(*pkt + *pkt_len - (++*offset)) = (u_char) doublesize;
<a name="l03677" id="l03677"></a>03677     *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_DOUBLE;
<a name="l03678" id="l03678"></a>03678     *(*pkt + *pkt_len - (++*offset)) = ASN_OPAQUE_TAG1;
<a name="l03679" id="l03679"></a>03679 
<a name="l03680" id="l03680"></a>03680     <span class="comment">/*</span>
<a name="l03681" id="l03681"></a>03681 <span class="comment">     * Put the tag and length for the Opaque wrapper.  </span>
<a name="l03682" id="l03682"></a>03682 <span class="comment">     */</span>
<a name="l03683" id="l03683"></a>03683     <span class=
"keywordflow">if</span> (asn_realloc_rbuild_header(pkt, pkt_len, offset, r,
<a name="l03684" id="l03684"></a>03684                                   ASN_OPAQUE, doublesize + 3)) {
<a name="l03685" id="l03685"></a>03685         <span class="keywordflow">if</span> (_asn_realloc_build_header_check(<span class=
"stringliteral">"build float"</span>, pkt, pkt_len,
<a name="l03686" id="l03686"></a>03686                                             doublesize + 3)) {
<a name="l03687" id="l03687"></a>03687             <span class="keywordflow">return</span> 0;
<a name="l03688" id="l03688"></a>03688         } <span class="keywordflow">else</span> {
<a name="l03689" id="l03689"></a>03689             DEBUGDUMPSETUP(<span class=
"stringliteral">"send"</span>, (*pkt + *pkt_len - *offset),
<a name="l03690" id="l03690"></a>03690                            *offset - start_offset);
<a name="l03691" id="l03691"></a>03691             DEBUGMSG((<span class="stringliteral">"dumpv_send"</span>, <span class=
"stringliteral">"  Opaque Double:\t%f\n"</span>, *doublep));
<a name="l03692" id="l03692"></a>03692             <span class="keywordflow">return</span> 1;
<a name="l03693" id="l03693"></a>03693         }
<a name="l03694" id="l03694"></a>03694     }
<a name="l03695" id="l03695"></a>03695 
<a name="l03696" id="l03696"></a>03696     <span class="keywordflow">return</span> 0;
<a name="l03697" id="l03697"></a>03697 }
<a name="l03698" id="l03698"></a>03698 
<a name="l03699" id="l03699"></a>03699 <span class="preprocessor">#endif                          </span><span class=
"comment">/* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */</span>
<a name="l03700" id="l03700"></a>03700 <span class="preprocessor">#endif                          </span><span class=
"comment">/*  NETSNMP_USE_REVERSE_ASNENCODING  */</span>
<a name="l03701" id="l03701"></a>03701 
</pre>
    </div>
  </div>
  <hr size="1" />

  <address style="text-align: right;">
    <small>Generated on 28 Sep 2009 for net-snmp by  <a href="http://www.doxygen.org/index.html"><img class="footer" src=
    "doxygen.png" alt="doxygen" /></a> 1.6.1</small>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

