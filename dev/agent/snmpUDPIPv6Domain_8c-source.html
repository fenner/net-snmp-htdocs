<!--#set var="section" value="development" -->
<!--#include virtual="/page-top.html" -->
<!-- CONTENT START -->
  <!-- Generated by Doxygen 1.3.9.1 -->

  <div class="qindex">
    <a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class=
    "qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class=
    "qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class=
    "qindex" href="examples.html">Examples</a>
  </div>

  <div class="nav">
    <a class="el" href="dir_000005.html">snmplib</a>
  </div>

  <h1>snmpUDPIPv6Domain.c</h1>

  <div class="fragment">
    <pre class="fragment">
00001 <span class="preprocessor">#include &lt;net-snmp/net-snmp-config.h&gt;</span>
00002 
00003 <span class="preprocessor">#ifdef SNMP_TRANSPORT_UDPIPV6_DOMAIN</span>
00004 
00005 <span class="comment">/*</span>
00006 <span class="comment"> * hack-o-matic for Cygwin to use winsock2</span>
00007 <span class="comment">*/</span>
00008 <span class="preprocessor">#if defined(cygwin)</span>
00009 <span class="preprocessor">#undef HAVE_UNISTD_H</span>
00010 <span class="preprocessor">#undef HAVE_NETINET_IN_H</span>
00011 <span class="preprocessor">#undef HAVE_ARPA_INET_H</span>
00012 <span class="preprocessor">#undef HAVE_NET_IF_H</span>
00013 <span class="preprocessor">#undef HAVE_NETDB_H</span>
00014 <span class="preprocessor">#undef HAVE_SYS_PARAM_H</span>
00015 <span class="preprocessor">#undef HAVE_SYS_SELECT_H</span>
00016 <span class="preprocessor">#undef HAVE_SYS_SOCKET_H</span>
00017 <span class="preprocessor">#undef HAVE_IN_ADDR_T</span>
00018 <span class="preprocessor">#endif</span>
00019 
00020 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00021 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00022 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00023 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00024 
00025 <span class="preprocessor">#if HAVE_STRING_H</span>
00026 <span class="preprocessor">#include &lt;string.h&gt;</span>
00027 <span class="preprocessor">#else</span>
00028 <span class="preprocessor">#include &lt;strings.h&gt;</span>
00029 <span class="preprocessor">#endif</span>
00030 <span class="preprocessor">#if HAVE_STDLIB_H</span>
00031 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00032 <span class="preprocessor">#endif</span>
00033 <span class="preprocessor">#if HAVE_UNISTD_H</span>
00034 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00035 <span class="preprocessor">#endif</span>
00036 <span class="preprocessor">#if HAVE_SYS_SOCKET_H</span>
00037 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00038 <span class="preprocessor">#endif</span>
00039 
00040 <span class="preprocessor">#if defined(HAVE_WINSOCK_H) || defined(cygwin)</span>
00041     <span class="comment">/*</span>
00042 <span class="comment">     *  Windows IPv6 support is part of WinSock2 only</span>
00043 <span class="comment">     */</span>
00044 <span class="preprocessor">#include &lt;winsock2.h&gt;</span>
00045 <span class="preprocessor">#include &lt;ws2tcpip.h&gt;</span>
00046 <span class="preprocessor">#undef  HAVE_IF_NAMETOINDEX</span>
00047 
00048 <span class="keyword">extern</span> <span class="keywordtype">int</span>         inet_pton(<span class=
"keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class=
"keywordtype">void</span>*);
00049 <span class="keyword">extern</span> <span class="keyword">const</span> <span class=
"keywordtype">char</span> *inet_ntop(<span class="keywordtype">int</span>, <span class="keyword">const</span> <span class=
"keywordtype">void</span>*, <span class="keywordtype">char</span>*, size_t);
00050 <span class="keyword">const</span> <span class="keyword">struct </span>in6_addr in6addr_any = IN6ADDR_ANY_INIT;
00051 <span class="preprocessor">#endif</span>
00052 
00053 <span class="preprocessor">#if HAVE_NETINET_IN_H</span>
00054 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00055 <span class="preprocessor">#endif</span>
00056 <span class="preprocessor">#if HAVE_ARPA_INET_H</span>
00057 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
00058 <span class="preprocessor">#endif</span>
00059 <span class="preprocessor">#if HAVE_NETDB_H</span>
00060 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00061 <span class="preprocessor">#endif</span>
00062 <span class="preprocessor">#if HAVE_NET_IF_H</span>
00063 <span class="preprocessor">#include &lt;net/if.h&gt;</span>
00064 <span class="preprocessor">#endif</span>
00065 
00066 <span class="preprocessor">#if HAVE_DMALLOC_H</span>
00067 <span class="preprocessor">#include &lt;dmalloc.h&gt;</span>
00068 <span class="preprocessor">#endif</span>
00069 
00070 <span class="preprocessor">#include &lt;net-snmp/types.h&gt;</span>
00071 <span class="preprocessor">#include &lt;net-snmp/output_api.h&gt;</span>
00072 <span class="preprocessor">#include &lt;net-snmp/config_api.h&gt;</span>
00073 
00074 <span class="preprocessor">#include &lt;net-snmp/library/snmp_transport.h&gt;</span>
00075 <span class="preprocessor">#include &lt;net-snmp/library/snmpUDPIPv6Domain.h&gt;</span>
00076 
00077 oid netsnmp_UDPIPv6Domain[] = { TRANSPORT_DOMAIN_UDP_IPV6 };
00078 <span class="keyword">static</span> netsnmp_tdomain udp6Domain;
00079 
00080 <span class="comment">/*</span>
00081 <span class="comment"> * from snmpUDPDomain. not static, but not public, either.</span>
00082 <span class="comment"> * (ie don't put it in a public header.)</span>
00083 <span class="comment"> */</span>
00084 <span class="keyword">extern</span> <span class="keywordtype">void</span> _netsnmp_udp_sockopt_set(<span class=
"keywordtype">int</span> fd, <span class="keywordtype">int</span> server);
00085 
00086 <span class="comment">/*</span>
00087 <span class="comment"> * Return a string representing the address in data, or else the "far end"</span>
00088 <span class="comment"> * address if data is NULL.  </span>
00089 <span class="comment"> */</span>
00090 
00091 <span class="keyword">static</span> <span class="keywordtype">char</span> *
00092 netsnmp_udp6_fmtaddr(netsnmp_transport *t, <span class="keywordtype">void</span> *data, <span class=
"keywordtype">int</span> len)
00093 {
00094     <span class="keyword">struct </span>sockaddr_in6 *to = NULL;
00095 
00096     DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6"</span>, <span class=
"stringliteral">"fmtaddr: t = %p, data = %p, len = %d\n"</span>, t,
00097                 data, len));
00098     <span class="keywordflow">if</span> (data != NULL &amp;&amp; len == <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_in6)) {
00099         to = (<span class="keyword">struct </span>sockaddr_in6 *) data;
00100     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL) {
00101         to = (<span class="keyword">struct </span>sockaddr_in6 *) t-&gt;data;
00102     }
00103     <span class="keywordflow">if</span> (to == NULL) {
00104         <span class="keywordflow">return</span> strdup(<span class="stringliteral">"UDP/IPv6: unknown"</span>);
00105     } <span class="keywordflow">else</span> {
00106         <span class="keywordtype">char</span> addr[INET6_ADDRSTRLEN];
00107         <span class="keywordtype">char</span> tmp[INET6_ADDRSTRLEN + 8];
00108 
00109         sprintf(tmp, <span class="stringliteral">"UDP/IPv6: [%s]:%hd"</span>,
00110                 inet_ntop(AF_INET6, (<span class="keywordtype">void</span> *) &amp;(to-&gt;sin6_addr), addr,
00111                           INET6_ADDRSTRLEN), ntohs(to-&gt;sin6_port));
00112         <span class="keywordflow">return</span> strdup(tmp);
00113     }
00114 }
00115 
00116 
00117 
00118 <span class="comment">/*</span>
00119 <span class="comment"> * You can write something into opaque that will subsequently get passed back </span>
00120 <span class="comment"> * to your send function if you like.  For instance, you might want to</span>
00121 <span class="comment"> * remember where a PDU came from, so that you can send a reply there...  </span>
00122 <span class="comment"> */</span>
00123 
00124 <span class="keyword">static</span> <span class="keywordtype">int</span>
00125 netsnmp_udp6_recv(netsnmp_transport *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
00126                   <span class="keywordtype">void</span> **opaque, <span class="keywordtype">int</span> *olength)
00127 {
00128     <span class="keywordtype">int</span>             rc = -1;
00129     socklen_t       fromlen = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in6);
00130     <span class="keyword">struct </span>sockaddr *from;
00131 
00132     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00133         from = (<span class="keyword">struct </span>sockaddr *) malloc(<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_in6));
00134         <span class="keywordflow">if</span> (from == NULL) {
00135             *opaque = NULL;
00136             *olength = 0;
00137             <span class="keywordflow">return</span> -1;
00138         } <span class="keywordflow">else</span> {
00139             memset(from, 0, fromlen);
00140         }
00141 
00142         <span class="keywordflow">while</span> (rc &lt; 0) {
00143           rc = recvfrom(t-&gt;sock, buf, size, 0, from, &amp;fromlen);
00144           <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
00145             <span class="keywordflow">break</span>;
00146           }
00147         }
00148 
00149         <span class="keywordflow">if</span> (rc &gt;= 0) {
00150             <span class="keywordtype">char</span> *str = netsnmp_udp6_fmtaddr(NULL, from, fromlen);
00151             DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6"</span>,
00152                         <span class="stringliteral">"recvfrom fd %d got %d bytes (from %s)\n"</span>, t-&gt;sock,
00153                         rc, str));
00154             free(str);
00155         } <span class="keywordflow">else</span> {
00156             DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6"</span>, <span class=
"stringliteral">"recvfrom fd %d err %d (\"%s\")\n"</span>,
00157                         t-&gt;sock, errno, strerror(errno)));
00158         }
00159         *opaque = (<span class="keywordtype">void</span> *) from;
00160         *olength = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in6);
00161     }
00162     <span class="keywordflow">return</span> rc;
00163 }
00164 
00165 
00166 
00167 <span class="keyword">static</span> <span class="keywordtype">int</span>
00168 netsnmp_udp6_send(netsnmp_transport *t, <span class="keywordtype">void</span> *buf, <span class=
"keywordtype">int</span> size,
00169                   <span class="keywordtype">void</span> **opaque, <span class="keywordtype">int</span> *olength)
00170 {
00171     <span class="keywordtype">int</span> rc = -1;
00172     <span class="keyword">struct </span>sockaddr *to = NULL;
00173 
00174     <span class="keywordflow">if</span> (opaque != NULL &amp;&amp; *opaque != NULL &amp;&amp;
00175         *olength == <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in6)) {
00176         to = (<span class="keyword">struct </span>sockaddr *) (*opaque);
00177     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;data != NULL &amp;&amp;
00178                t-&gt;data_length == <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_in6)) {
00179         to = (<span class="keyword">struct </span>sockaddr *) (t-&gt;data);
00180     }
00181 
00182     <span class="keywordflow">if</span> (to != NULL &amp;&amp; t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00183         <span class="keywordtype">char</span> *str = netsnmp_udp6_fmtaddr(NULL, (<span class=
"keywordtype">void</span> *)to,
00184                                             <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_in6));
00185         DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6"</span>, <span class=
"stringliteral">"send %d bytes from %p to %s on fd %d\n"</span>,
00186                     size, buf, str, t-&gt;sock));
00187         free(str);
00188         <span class="keywordflow">while</span> (rc &lt; 0) {
00189             rc = sendto(t-&gt;sock, buf, size, 0, to,<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_in6));
00190             <span class="keywordflow">if</span> (rc &lt; 0 &amp;&amp; errno != EINTR) {
00191                 <span class="keywordflow">break</span>;
00192             }
00193         }
00194     }
00195     <span class="keywordflow">return</span> rc;
00196 }
00197 
00198 
00199 
00200 <span class="keyword">static</span> <span class="keywordtype">int</span>
00201 netsnmp_udp6_close(netsnmp_transport *t)
00202 {
00203     <span class="keywordtype">int</span> rc = -1;
00204     <span class="keywordflow">if</span> (t != NULL &amp;&amp; t-&gt;sock &gt;= 0) {
00205         DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6"</span>, <span class=
"stringliteral">"close fd %d\n"</span>, t-&gt;sock));
00206 <span class="preprocessor">#ifndef HAVE_CLOSESOCKET</span>
00207         rc = close(t-&gt;sock);
00208 <span class="preprocessor">#else</span>
00209         rc = closesocket(t-&gt;sock);
00210 <span class="preprocessor">#endif</span>
00211         t-&gt;sock = -1;
00212     }
00213     <span class="keywordflow">return</span> rc;
00214 }
00215 
00216 
00217 
00218 <span class="comment">/*</span>
00219 <span class="comment"> * Open a UDP/IPv6-based transport for SNMP.  Local is TRUE if addr is the</span>
00220 <span class="comment"> * local address to bind to (i.e. this is a server-type session); otherwise</span>
00221 <span class="comment"> * addr is the remote address to send things to.  </span>
00222 <span class="comment"> */</span>
00223 
00224 netsnmp_transport *
00225 netsnmp_udp6_transport(<span class="keyword">struct</span> sockaddr_in6 *addr, <span class="keywordtype">int</span> local)
00226 {
00227     netsnmp_transport *t = NULL;
00228     <span class="keywordtype">int</span>             rc = 0;
00229     <span class="keywordtype">char</span>           *str = NULL;
00230 
00231     <span class="keywordflow">if</span> (addr == NULL || addr-&gt;sin6_family != AF_INET6) {
00232         <span class="keywordflow">return</span> NULL;
00233     }
00234 
00235     t = (netsnmp_transport *) malloc(<span class="keyword">sizeof</span>(netsnmp_transport));
00236     <span class="keywordflow">if</span> (t == NULL) {
00237         <span class="keywordflow">return</span> NULL;
00238     }
00239 
00240     str = netsnmp_udp6_fmtaddr(NULL, (<span class="keywordtype">void</span> *) addr,
00241                                   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6));
00242     DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6"</span>, <span class=
"stringliteral">"open %s %s\n"</span>, local ? <span class="stringliteral">"local"</span> : <span class=
"stringliteral">"remote"</span>,
00243                 str));
00244     free(str);
00245 
00246     memset(t, 0, <span class="keyword">sizeof</span>(netsnmp_transport));
00247 
00248     t-&gt;domain = netsnmp_UDPIPv6Domain;
00249     t-&gt;domain_length =
00250         <span class="keyword">sizeof</span>(netsnmp_UDPIPv6Domain) / <span class=
"keyword">sizeof</span>(netsnmp_UDPIPv6Domain[0]);
00251 
00252     t-&gt;sock = socket(PF_INET6, SOCK_DGRAM, 0);
00253     <span class="keywordflow">if</span> (t-&gt;sock &lt; 0) {
00254         netsnmp_transport_free(t);
00255         <span class="keywordflow">return</span> NULL;
00256     }
00257 
00258     _netsnmp_udp_sockopt_set(t-&gt;sock, local);
00259 
00260     <span class="keywordflow">if</span> (local) {
00261         <span class="comment">/*</span>
00262 <span class="comment">         * This session is inteneded as a server, so we must bind on to the</span>
00263 <span class="comment">         * given IP address, which may include an interface address, or could</span>
00264 <span class="comment">         * be INADDR_ANY, but certainly includes a port number.</span>
00265 <span class="comment">         */</span>
00266 
00267 <span class="preprocessor">#ifdef IPV6_V6ONLY</span>
00268         <span class="comment">/* Try to restrict PF_INET6 socket to IPv6 communications only. */</span>
00269         {
00270           <span class="keywordtype">int</span> one=1;
00271           <span class="keywordflow">if</span> (setsockopt(t-&gt;sock, IPPROTO_IPV6, IPV6_V6ONLY, (<span class=
"keywordtype">char</span> *)&amp;one, <span class="keyword">sizeof</span>(one)) != 0) {
00272             DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6"</span>, <span class=
"stringliteral">"couldn't set IPV6_V6ONLY to %d bytes: %s\n"</span>, one, strerror(errno)));
00273           } 
00274         }
00275 <span class="preprocessor">#endif</span>
00276 
00277         rc = bind(t-&gt;sock, (<span class="keyword">struct</span> sockaddr *) addr,
00278                   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6));
00279         <span class="keywordflow">if</span> (rc != 0) {
00280             netsnmp_udp6_close(t);
00281             netsnmp_transport_free(t);
00282             <span class="keywordflow">return</span> NULL;
00283         }
00284         t-&gt;local = malloc(18);
00285         <span class="keywordflow">if</span> (t-&gt;local == NULL) {
00286             netsnmp_udp6_close(t);
00287             netsnmp_transport_free(t);
00288             <span class="keywordflow">return</span> NULL;
00289         }
00290         memcpy(t-&gt;local, addr-&gt;sin6_addr.s6_addr, 16);
00291         t-&gt;local[16] = (addr-&gt;sin6_port &amp; 0xff00) &gt;&gt; 8;
00292         t-&gt;local[17] = (addr-&gt;sin6_port &amp; 0x00ff) &gt;&gt; 0;
00293         t-&gt;local_length = 18;
00294         t-&gt;data = NULL;
00295         t-&gt;data_length = 0;
00296     } <span class="keywordflow">else</span> {
00297         <span class="comment">/*</span>
00298 <span class="comment">         * This is a client session.  Save the address in the</span>
00299 <span class="comment">         * transport-specific data pointer for later use by netsnmp_udp6_send.</span>
00300 <span class="comment">         */</span>
00301 
00302         t-&gt;data = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6));
00303         <span class="keywordflow">if</span> (t-&gt;data == NULL) {
00304             netsnmp_udp6_close(t);
00305             netsnmp_transport_free(t);
00306             <span class="keywordflow">return</span> NULL;
00307         }
00308         memcpy(t-&gt;data, addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6));
00309         t-&gt;data_length = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in6);
00310         t-&gt;remote = malloc(18);
00311         <span class="keywordflow">if</span> (t-&gt;remote == NULL) {
00312             netsnmp_udp6_close(t);
00313             netsnmp_transport_free(t);
00314             <span class="keywordflow">return</span> NULL;
00315         }
00316         memcpy(t-&gt;remote, addr-&gt;sin6_addr.s6_addr, 16);
00317         t-&gt;remote[16] = (addr-&gt;sin6_port &amp; 0xff00) &gt;&gt; 8;
00318         t-&gt;remote[17] = (addr-&gt;sin6_port &amp; 0x00ff) &gt;&gt; 0;
00319         t-&gt;remote_length = 18;
00320     }
00321 
00322     <span class="comment">/*</span>
00323 <span class="comment">     * 16-bit length field, 8 byte UDP header, 40 byte IPv6 header.  </span>
00324 <span class="comment">     */</span>
00325 
00326     t-&gt;msgMaxSize = 0xffff - 8 - 40;
00327     t-&gt;f_recv     = netsnmp_udp6_recv;
00328     t-&gt;f_send     = netsnmp_udp6_send;
00329     t-&gt;f_close    = netsnmp_udp6_close;
00330     t-&gt;f_accept   = NULL;
00331     t-&gt;f_fmtaddr  = netsnmp_udp6_fmtaddr;
00332 
00333     <span class="keywordflow">return</span> t;
00334 }
00335 
00336 
00337 
00338 <span class="keywordtype">int</span>
00339 netsnmp_sockaddr_in6(<span class="keyword">struct</span> sockaddr_in6 *addr,
00340                      <span class="keyword">const</span> <span class="keywordtype">char</span> *inpeername, <span class=
"keywordtype">int</span> remote_port)
00341 {
00342     <span class="keywordtype">char</span>           *cp = NULL, *peername = NULL;
00343     <span class="keywordtype">char</span>            debug_addr[INET6_ADDRSTRLEN];
00344 <span class="preprocessor">#if HAVE_GETADDRINFO</span>
00345     <span class="keyword">struct </span>addrinfo *addrs = NULL;
00346     <span class="keyword">struct </span>addrinfo hint;
00347     <span class="keywordtype">int</span>             err;
00348 <span class="preprocessor">#elif HAVE_GETIPNODEBYNAME</span>
00349     <span class="keyword">struct </span>hostent *hp = NULL;
00350     <span class="keywordtype">int</span>             err;
00351 <span class="preprocessor">#elif HAVE_GETHOSTBYNAME</span>
00352     <span class="keyword">struct </span>hostent *hp = NULL;
00353 <span class="preprocessor">#endif</span>
00354 
00355     <span class="keywordflow">if</span> (addr == NULL) {
00356         <span class="keywordflow">return</span> 0;
00357     }
00358 
00359     DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>, <span class=
"stringliteral">"addr %p, peername \"%s\"\n"</span>,
00360                 addr, inpeername ? inpeername : <span class="stringliteral">"[NIL]"</span>));
00361 
00362     memset(addr, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6));
00363     addr-&gt;sin6_family = AF_INET6;
00364     addr-&gt;sin6_addr = in6addr_any;
00365 
00366     <span class="keywordflow">if</span> (remote_port &gt; 0) {
00367         addr-&gt;sin6_port = htons(remote_port);
00368     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
00369                                   NETSNMP_DS_LIB_DEFAULT_PORT) &gt; 0) {
00370         addr-&gt;sin6_port = htons(netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, 
00371                                                  NETSNMP_DS_LIB_DEFAULT_PORT));
00372     } <span class="keywordflow">else</span> {
00373         addr-&gt;sin6_port = htons(SNMP_PORT);
00374     }
00375 
00376     <span class="keywordflow">if</span> (inpeername != NULL) {
00377         <span class="comment">/*</span>
00378 <span class="comment">         * Duplicate the peername because we might want to mank around with</span>
00379 <span class="comment">         * it.  </span>
00380 <span class="comment">         */</span>
00381 
00382         peername = strdup(inpeername);
00383         <span class="keywordflow">if</span> (peername == NULL) {
00384             <span class="keywordflow">return</span> 0;
00385         }
00386 
00387         <span class="keywordflow">for</span> (cp = peername; *cp &amp;&amp; isdigit((<span class=
"keywordtype">int</span>) *cp); cp++);
00388         <span class="keywordflow">if</span> (!*cp &amp;&amp; atoi(peername) != 0) {
00389             <span class="comment">/*</span>
00390 <span class="comment">             * Okay, it looks like JUST a port number.  </span>
00391 <span class="comment">             */</span>
00392             DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>, <span class=
"stringliteral">"totally numeric: %d\n"</span>,
00393                         atoi(peername)));
00394             addr-&gt;sin6_port = htons(atoi(peername));
00395             <span class="keywordflow">goto</span> resolved;
00396         }
00397 
00398         <span class="comment">/*</span>
00399 <span class="comment">         * See if it is an IPv6 address, which covered with square brankets</span>
00400 <span class="comment">         * with an appended :port.  </span>
00401 <span class="comment">         */</span>
00402         <span class="keywordflow">if</span> (*peername == <span class="charliteral">'['</span>) {
00403             cp = strchr(peername, <span class="charliteral">']'</span>);
00404             <span class="keywordflow">if</span> (cp != NULL) {
00405               <span class="comment">/*</span>
00406 <span class="comment">               * See if it is an IPv6 link-local address with interface</span>
00407 <span class="comment">               * name as &lt;zone_id&gt;, like fe80::1234%eth0.</span>
00408 <span class="comment">               * Please refer to the internet draft, IPv6 Scoped Address Architecture</span>
00409 <span class="comment">               * http://www.ietf.org/internet-drafts/draft-ietf-ipngwg-scoping-arch-04.txt</span>
00410 <span class="comment">               *</span>
00411 <span class="comment">               */</span>
00412                 <span class="keywordtype">char</span> *scope_id;
00413 <span class="preprocessor">#ifdef HAVE_IF_NAMETOINDEX</span>
00414                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> if_index = 0;
00415 <span class="preprocessor">#endif</span>
00416                 *cp = <span class="charliteral">'\0'</span>;
00417                 scope_id = strchr(peername + 1, <span class="charliteral">'%'</span>);
00418                 <span class="keywordflow">if</span> (scope_id != NULL) {
00419                     *scope_id = <span class="charliteral">'\0'</span>;
00420 <span class="preprocessor">#ifdef HAVE_IF_NAMETOINDEX</span>
00421                     if_index = if_nametoindex(scope_id + 1);
00422 <span class="preprocessor">#endif</span>
00423                 }
00424                 <span class="keywordflow">if</span> (*(cp + 1) == <span class="charliteral">':'</span>) {
00425                     <span class="keywordflow">if</span> (atoi(cp + 2) != 0 &amp;&amp;
00426                         inet_pton(AF_INET6, peername + 1,
00427                                   (<span class="keywordtype">void</span> *) &amp;(addr-&gt;sin6_addr))) {
00428                         DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>,
00429                                     <span class="stringliteral">"IPv6 address with port suffix :%d\n"</span>,
00430                                     atoi(cp + 2)));
00431                         addr-&gt;sin6_port = htons(atoi(cp + 2));
00432 <span class="preprocessor">#ifdef HAVE_IF_NAMETOINDEX</span>
00433                         addr-&gt;sin6_scope_id = if_index;
00434 <span class="preprocessor">#endif</span>
00435                         <span class="keywordflow">goto</span> resolved;
00436                     }
00437                 } <span class="keywordflow">else</span> {
00438                     <span class="keywordflow">if</span> (inet_pton
00439                         (AF_INET6, peername + 1,
00440                          (<span class="keywordtype">void</span> *) &amp;(addr-&gt;sin6_addr))) {
00441                         DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>,
00442                                     <span class="stringliteral">"IPv6 address with square brankets\n"</span>));
00443                         addr-&gt;sin6_port = htons(SNMP_PORT);
00444 <span class="preprocessor">#ifdef HAVE_IF_NAMETOINDEX</span>
00445                         addr-&gt;sin6_scope_id = if_index;
00446 <span class="preprocessor">#endif</span>
00447                         <span class="keywordflow">goto</span> resolved;
00448                     }
00449                 }
00450                 <span class="keywordflow">if</span> (scope_id != NULL) {
00451                   *scope_id = <span class="charliteral">'%'</span>;
00452                 }
00453                 *cp = <span class="charliteral">']'</span>;
00454             }
00455         }
00456 
00457         cp = strrchr(peername, <span class="charliteral">':'</span>);
00458         <span class="keywordflow">if</span> (cp != NULL) {
00459             <span class="keywordtype">char</span> *scope_id;
00460 <span class="preprocessor">#ifdef HAVE_IF_NAMETOINDEX</span>
00461             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> if_index = 0;
00462 <span class="preprocessor">#endif</span>
00463             *cp = <span class="charliteral">'\0'</span>;
00464             scope_id = strchr(peername + 1, <span class="charliteral">'%'</span>);
00465             <span class="keywordflow">if</span> (scope_id != NULL) {
00466                 *scope_id = <span class="charliteral">'\0'</span>;
00467 <span class="preprocessor">#ifdef HAVE_IF_NAMETOINDEX</span>
00468                 if_index = if_nametoindex(scope_id + 1);
00469 <span class="preprocessor">#endif</span>
00470             }
00471             <span class="keywordflow">if</span> (atoi(cp + 1) != 0 &amp;&amp;
00472                 inet_pton(AF_INET6, peername,
00473                           (<span class="keywordtype">void</span> *) &amp;(addr-&gt;sin6_addr))) {
00474                 DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>,
00475                             <span class="stringliteral">"IPv6 address with port suffix :%d\n"</span>,
00476                             atoi(cp + 1)));
00477                 addr-&gt;sin6_port = htons(atoi(cp + 1));
00478 <span class="preprocessor">#ifdef HAVE_IF_NAMETOINDEX</span>
00479                 addr-&gt;sin6_scope_id = if_index;
00480 <span class="preprocessor">#endif</span>
00481                 <span class="keywordflow">goto</span> resolved;
00482             }
00483             <span class="keywordflow">if</span> (scope_id != NULL) {
00484               *scope_id = <span class="charliteral">'%'</span>;
00485             }
00486             *cp = <span class="charliteral">':'</span>;
00487         }
00488 
00489         <span class="comment">/*</span>
00490 <span class="comment">         * See if it is JUST an IPv6 address.  </span>
00491 <span class="comment">         */</span>
00492         <span class="keywordflow">if</span> (inet_pton(AF_INET6, peername, (<span class=
"keywordtype">void</span> *) &amp;(addr-&gt;sin6_addr))) {
00493             DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>, <span class=
"stringliteral">"just IPv6 address\n"</span>));
00494             <span class="keywordflow">goto</span> resolved;
00495         }
00496 
00497         <span class="comment">/*</span>
00498 <span class="comment">         * Well, it must be a hostname then, possibly with an appended :port.</span>
00499 <span class="comment">         * Sort that out first.  </span>
00500 <span class="comment">         */</span>
00501 
00502         cp = strrchr(peername, <span class="charliteral">':'</span>);
00503         <span class="keywordflow">if</span> (cp != NULL) {
00504             *cp = <span class="charliteral">'\0'</span>;
00505             <span class="keywordflow">if</span> (atoi(cp + 1) != 0) {
00506                 DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>,
00507                             <span class="stringliteral">"hostname(?) with port suffix :%d\n"</span>,
00508                             atoi(cp + 1)));
00509                 addr-&gt;sin6_port = htons(atoi(cp + 1));
00510             } <span class="keywordflow">else</span> {
00511                 <span class="comment">/*</span>
00512 <span class="comment">                 * No idea, looks bogus but we might as well pass the full thing to</span>
00513 <span class="comment">                 * the name resolver below.  </span>
00514 <span class="comment">                 */</span>
00515                 *cp = <span class="charliteral">':'</span>;
00516                 DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>,
00517                             <span class="stringliteral">"hostname(?) with embedded ':'?\n"</span>));
00518             }
00519             <span class="comment">/*</span>
00520 <span class="comment">             * Fall through.  </span>
00521 <span class="comment">             */</span>
00522         }
00523 <span class="preprocessor">#if HAVE_GETADDRINFO</span>
00524         memset(&amp;hint, 0, <span class="keyword">sizeof</span> hint);
00525         hint.ai_flags = 0;
00526         hint.ai_family = PF_INET6;
00527         hint.ai_socktype = SOCK_DGRAM;
00528         hint.ai_protocol = 0;
00529 
00530         err = getaddrinfo(peername, NULL, &amp;hint, &amp;addrs);
00531         <span class="keywordflow">if</span> (err != 0) {
00532             <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR, <span class=
"stringliteral">"getaddrinfo: %s %s\n"</span>, peername,
00533                      gai_strerror(err));
00534             free(peername);
00535             <span class="keywordflow">return</span> 0;
00536         }
00537         <span class="keywordflow">if</span> (addrs != NULL) {
00538         DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>, <span class=
"stringliteral">"hostname (resolved okay)\n"</span>));
00539         memcpy(&amp;addr-&gt;sin6_addr,
00540                &amp;((<span class="keyword">struct</span> sockaddr_in6 *) addrs-&gt;ai_addr)-&gt;sin6_addr,
00541                <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in6_addr));
00542                 freeaddrinfo(addrs);
00543         }
00544                 <span class="keywordflow">else</span> {
00545         DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>, <span class=
"stringliteral">"Failed to resolve IPv6 hostname\n"</span>));
00546                 }
00547 <span class="preprocessor">#elif HAVE_GETIPNODEBYNAME</span>
00548         hp = getipnodebyname(peername, AF_INET6, 0, &amp;err);
00549         <span class="keywordflow">if</span> (hp == NULL) {
00550             DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>,
00551                         <span class="stringliteral">"hostname (couldn't resolve = %d)\n"</span>, err));
00552             free(peername);
00553             <span class="keywordflow">return</span> 0;
00554         }
00555         DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>, <span class=
"stringliteral">"hostname (resolved okay)\n"</span>));
00556         memcpy(&amp;(addr-&gt;sin6_addr), hp-&gt;h_addr, hp-&gt;h_length);
00557 <span class="preprocessor">#elif HAVE_GETHOSTBYNAME</span>
00558         hp = gethostbyname(peername);
00559         <span class="keywordflow">if</span> (hp == NULL) {
00560             DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>,
00561                         <span class="stringliteral">"hostname (couldn't resolve)\n"</span>));
00562             free(peername);
00563             <span class="keywordflow">return</span> 0;
00564         } <span class="keywordflow">else</span> {
00565             <span class="keywordflow">if</span> (hp-&gt;h_addrtype != AF_INET6) {
00566                 DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>,
00567                             <span class="stringliteral">"hostname (not AF_INET6!)\n"</span>));
00568                 free(peername);
00569                 <span class="keywordflow">return</span> 0;
00570             } <span class="keywordflow">else</span> {
00571                 DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>,
00572                             <span class="stringliteral">"hostname (resolved okay)\n"</span>));
00573                 memcpy(&amp;(addr-&gt;sin6_addr), hp-&gt;h_addr, hp-&gt;h_length);
00574             }
00575         }
00576 <span class="preprocessor">#else                           </span><span class="comment">/*HAVE_GETHOSTBYNAME */</span>
00577         <span class="comment">/*</span>
00578 <span class="comment">         * There is no name resolving function available.  </span>
00579 <span class="comment">         */</span>
00580         <a class="code" href="group__snmp__logging.html#ga41">snmp_log</a>(LOG_ERR,
00581                  <span class="stringliteral">"no getaddrinfo()/getipnodebyname()/gethostbyname()\n"</span>);
00582         free(peername);
00583         <span class="keywordflow">return</span> 0;
00584 <span class="preprocessor">#endif                          </span><span class="comment">/*HAVE_GETHOSTBYNAME */</span>
00585     } <span class="keywordflow">else</span> {
00586         DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>, <span class=
"stringliteral">"NULL peername"</span>));
00587         <span class="keywordflow">return</span> 0;
00588     }
00589 
00590   resolved:
00591     DEBUGMSGTL((<span class="stringliteral">"netsnmp_sockaddr_in6"</span>, <span class=
"stringliteral">"return { AF_INET6, [%s]:%hu }\n"</span>,
00592                 inet_ntop(AF_INET6, &amp;addr-&gt;sin6_addr, debug_addr,
00593                           <span class="keyword">sizeof</span>(debug_addr)), ntohs(addr-&gt;sin6_port)));
00594     free(peername);
00595     <span class="keywordflow">return</span> 1;
00596 }
00597 
00598 
00599 <span class="comment">/*</span>
00600 <span class="comment"> * int</span>
00601 <span class="comment"> * inet_make_mask_addr( int pf, void *dst, int masklength )</span>
00602 <span class="comment"> *      convert from bit length specified masklength to network format, </span>
00603 <span class="comment"> *      which fills 1 from until specified bit length.</span>
00604 <span class="comment"> *      dst is usally the structer of sockaddr_in or sockaddr_in6. </span>
00605 <span class="comment"> *      makelength must be an interger from 0 to 32 if pf is PF_INET,</span>
00606 <span class="comment"> *      or from 0 to 128 if pf is PF_INET6.</span>
00607 <span class="comment"> * return:</span>
00608 <span class="comment"> *      0 if the input data, masklength was valid for </span>
00609 <span class="comment"> *      the specified protocol family.</span>
00610 <span class="comment"> *      -1 if the the input data wasn't valid.</span>
00611 <span class="comment"> */</span>
00612 
00613 <span class="keywordtype">int</span>
00614 inet_make_mask_addr(<span class="keywordtype">int</span> pf, <span class="keywordtype">void</span> *dst, <span class=
"keywordtype">int</span> masklength)
00615 {
00616 
00617     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   Mask = 0;
00618     <span class="keywordtype">int</span>             maskBit = 0x80000000L;
00619     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>   mask = 0;
00620     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>   maskbit = 0x80L;
00621     <span class="keywordtype">int</span>             i, j, jj;
00622 
00623 
00624     <span class="keywordflow">switch</span> (pf) {
00625     <span class="keywordflow">case</span> PF_INET:
00626         <span class="keywordflow">if</span> (masklength &lt; 0 || masklength &gt; 32)
00627             <span class="keywordflow">return</span> -1;
00628 
00629         ((<span class="keyword">struct </span>in_addr *) dst)-&gt;s_addr = 0;
00630 
00631         <span class="keywordflow">while</span> (masklength--) {
00632             Mask |= maskBit;
00633             maskBit &gt;&gt;= 1;
00634         }
00635         ((<span class="keyword">struct </span>in_addr *) dst)-&gt;s_addr = htonl(Mask);
00636         <span class="keywordflow">break</span>;
00637 
00638     <span class="keywordflow">case</span> PF_INET6:
00639         <span class="keywordflow">if</span> (masklength &lt; 0 || masklength &gt; 128)
00640             <span class="keywordflow">return</span> -1;
00641 
00642 
00643         <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++) {
00644             (*(u_char *) (&amp;((<span class="keyword">struct </span>in6_addr *) dst)-&gt;s6_addr[i])) = 0x00;
00645         }
00646 
00647         j = (int) masklength / 8;
00648         jj = masklength % 8;
00649 
00650         <span class="keywordflow">for</span> (i = 0; i &lt; j; i++) {
00651             (*(u_char *) (&amp;((<span class="keyword">struct </span>in6_addr *) dst)-&gt;s6_addr[i])) = 0xff;
00652         }
00653         <span class="keywordflow">while</span> (jj--) {
00654             mask |= maskbit;
00655             maskbit &gt;&gt;= 1;
00656         }
00657         (*(u_char *) (&amp;((<span class="keyword">struct </span>in6_addr *) dst)-&gt;s6_addr[j])) = mask;
00658         <span class="keywordflow">break</span>;
00659     <span class="keywordflow">default</span>:
00660         <span class="keywordflow">return</span> -1;              <span class=
"comment">/* unsupported protocol family */</span>
00661     }
00662     <span class="keywordflow">return</span> 0;
00663 }
00664 
00665 <span class="comment">/*</span>
00666 <span class="comment"> * int</span>
00667 <span class="comment"> * inet_addr_complement( int pf, void *src, void *dst )</span>
00668 <span class="comment"> *      convert from src to dst, which all bits </span>
00669 <span class="comment"> *      are bit-compliment of src.</span>
00670 <span class="comment"> *      Src, dst are ususally sockaddr_in or sockaddr_in6.  </span>
00671 <span class="comment"> * return:</span>
00672 <span class="comment"> *      0 if the input data src and dst have the same size</span>
00673 <span class="comment"> *      -1 if the the input data wasn't valid.</span>
00674 <span class="comment"> */</span>
00675 
00676 <span class="keywordtype">int</span>
00677 inet_addr_complement(<span class="keywordtype">int</span> pf, <span class="keywordtype">void</span> *src, <span class=
"keywordtype">void</span> *dst)
00678 {
00679 
00680     <span class="keywordtype">int</span>             i;
00681 
00682     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(src) != <span class=
"keyword">sizeof</span>(dst))
00683         <span class="keywordflow">return</span> -1;
00684 
00685     <span class="keywordflow">switch</span> (pf) {
00686     <span class="keywordflow">case</span> PF_INET:
00687         ((<span class="keyword">struct </span>in_addr *) dst)-&gt;s_addr =
00688             ~((<span class="keyword">struct </span>in_addr *) src)-&gt;s_addr;
00689         <span class="keywordflow">break</span>;
00690     <span class="keywordflow">case</span> PF_INET6:
00691         <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++) {
00692             (*(u_char *) (&amp;((<span class="keyword">struct </span>in6_addr *) dst)-&gt;s6_addr[i])) =
00693                 (~(*(u_char *) (&amp;((<span class="keyword">struct </span>in6_addr *) src)-&gt;s6_addr[i])))
00694                 &amp; 0xff;
00695         }
00696         <span class="keywordflow">break</span>;
00697     <span class="keywordflow">default</span>:
00698         <span class="keywordflow">return</span> -1;
00699     }
00700     <span class="keywordflow">return</span> 0;
00701 }
00702 
00703 <span class="comment">/*</span>
00704 <span class="comment"> * int</span>
00705 <span class="comment"> * inet_addr_and( int pf, void *src1, void *src2, void *dst) </span>
00706 <span class="comment"> *      take AND operation on src1 and src2, and output the result to dst.</span>
00707 <span class="comment"> *      Src1, src2, and dst are ususally sockaddr_in or sockaddr_in6.  </span>
00708 <span class="comment"> * return:</span>
00709 <span class="comment"> *      0 if the input data src and dst have the same size</span>
00710 <span class="comment"> *      -1 if the the input data are not the same size</span>
00711 <span class="comment"> */</span>
00712 
00713 <span class="keywordtype">int</span>
00714 inet_addr_and(<span class="keywordtype">int</span> pf, <span class="keywordtype">void</span> *src1, <span class=
"keywordtype">void</span> *src2, <span class="keywordtype">void</span> *dst)
00715 {
00716     <span class="keywordtype">int</span>             i;
00717 
00718     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(src1) != <span class=
"keyword">sizeof</span>(src2) || <span class="keyword">sizeof</span>(src2) != <span class="keyword">sizeof</span>(dst))
00719         <span class="keywordflow">return</span> -1;
00720 
00721     <span class="keywordflow">switch</span> (pf) {
00722     <span class="keywordflow">case</span> PF_INET:
00723         ((<span class="keyword">struct </span>in_addr *) dst)-&gt;s_addr =
00724             ((<span class="keyword">struct </span>in_addr *) src1)-&gt;s_addr &amp; ((<span class=
"keyword">struct </span>in_addr *) src2)-&gt;
00725             s_addr;
00726         <span class="keywordflow">break</span>;
00727 
00728     <span class="keywordflow">case</span> PF_INET6:
00729         <span class="keywordflow">for</span> (i = 0; i &lt; 16; i++) {
00730             (*(u_char *) (&amp;((<span class="keyword">struct </span>in6_addr *) dst)-&gt;s6_addr[i])) =
00731                 (*(u_char *) (&amp;((<span class="keyword">struct </span>in6_addr *) src1)-&gt;s6_addr[i])) &amp;
00732                 (*(u_char *) (&amp;((<span class="keyword">struct </span>in6_addr *) src2)-&gt;s6_addr[i]));
00733         }
00734         <span class="keywordflow">break</span>;
00735     <span class="keywordflow">default</span>:
00736         <span class="keywordflow">return</span> -1;
00737     }
00738     <span class="keywordflow">return</span> 0;
00739 }
00740 
00741 
00742 <span class="comment">/*</span>
00743 <span class="comment"> * int</span>
00744 <span class="comment"> * inet_addrs_consistence (int pf, void *net, void *mask ) </span>
00745 <span class="comment"> *      This function checks if the network address net is consistent</span>
00746 <span class="comment"> *      with the netmask address, mask.</span>
00747 <span class="comment"> *      Net and mask are ususally sockaddr_in or sockaddr_in6.  </span>
00748 <span class="comment"> * Note:</span>
00749 <span class="comment"> *      Must spefiey protocol family in pf.</span>
00750 <span class="comment"> * return:</span>
00751 <span class="comment"> *      0 if there is no consistence with address "net" and "mask".</span>
00752 <span class="comment"> *      -1 if network address is inconsistent with netmask address, for </span>
00753 <span class="comment"> *      instance, network address is 192.168.0.128 in spite of netmask, </span>
00754 <span class="comment"> *      which is 255.255.255.0. </span>
00755 <span class="comment"> *      The case that the size of net and mask are different also returns -1.</span>
00756 <span class="comment"> */</span>
00757 
00758 <span class="keywordtype">int</span>
00759 inet_addrs_consistence(<span class="keywordtype">int</span> pf, <span class="keywordtype">void</span> *net, <span class=
"keywordtype">void</span> *mask)
00760 {
00761     <span class="keyword">struct </span>sockaddr_in *tmp, *dst;
00762     <span class="keyword">struct </span>sockaddr_in6 *tmp6, *dst6;
00763     <span class="keywordtype">int</span>             ret;
00764 
00765     <span class="keywordflow">switch</span> (pf) {
00766     <span class="keywordflow">case</span> PF_INET:
00767         tmp = (<span class="keyword">struct </span>sockaddr_in *) malloc(<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_in));
00768         <span class="keywordflow">if</span> (!tmp) {
00769             config_perror(<span class="stringliteral">"Resource failure in inet_addr_consistence()"</span>);
00770             <span class="keywordflow">return</span> -1;
00771         }
00772         memset(tmp, 0, <span class="keyword">sizeof</span>(*tmp));
00773         tmp-&gt;sin_family = PF_INET;
00774         <span class="keywordflow">if</span> (inet_addr_complement
00775             (PF_INET, (<span class="keyword">struct </span>in_addr *) mask, &amp;tmp-&gt;sin_addr) != 0) {
00776             config_perror(<span class="stringliteral">"Fail in function of inet_addr_complement()"</span>);
00777             free(tmp);
00778             <span class="keywordflow">return</span> -1;
00779         }
00780         dst = (<span class="keyword">struct </span>sockaddr_in *) malloc(<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_in));
00781         <span class="keywordflow">if</span> (!dst) {
00782             config_perror(<span class="stringliteral">"Resource failure in inet_addr_consistence()"</span>);
00783             free(tmp);
00784             <span class="keywordflow">return</span> -1;
00785         }
00786         memset(dst, 0, <span class="keyword">sizeof</span>(*dst));
00787         dst-&gt;sin_family = PF_INET;
00788         <span class="keywordflow">if</span> (inet_addr_and
00789             (PF_INET, (<span class="keyword">struct </span>in_addr *) net, &amp;tmp-&gt;sin_addr,
00790              &amp;dst-&gt;sin_addr) != 0) {
00791             config_perror(<span class="stringliteral">"Fail in function of inet_addr_and()"</span>);
00792             free(dst);
00793             free(tmp);
00794             <span class="keywordflow">return</span> -1;
00795         }
00796         ret = ((dst-&gt;sin_addr.s_addr == INADDR_ANY) ? 0 : -1);
00797         free(dst);
00798         free(tmp);
00799         <span class="keywordflow">break</span>;
00800     <span class="keywordflow">case</span> PF_INET6:
00801         tmp6 = (<span class="keyword">struct </span>sockaddr_in6 *) malloc(<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_in6));
00802         <span class="keywordflow">if</span> (!tmp6) {
00803             config_perror(<span class="stringliteral">"Resource failure in inet_addr_consistence()"</span>);
00804             <span class="keywordflow">return</span> -1;
00805         }
00806         memset(tmp6, 0, <span class="keyword">sizeof</span>(*tmp6));
00807         tmp6-&gt;sin6_family = PF_INET6;
00808         <span class="keywordflow">if</span> (inet_addr_complement
00809             (PF_INET6, (<span class="keyword">struct </span>in6_addr *) mask, &amp;tmp6-&gt;sin6_addr) != 0) {
00810             config_perror(<span class="stringliteral">"Fail in function of inet_addr_complement()"</span>);
00811             free(tmp6);
00812             <span class="keywordflow">return</span> -1;
00813         }
00814         dst6 = (<span class="keyword">struct </span>sockaddr_in6 *) malloc(<span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_in6));
00815         <span class="keywordflow">if</span> (!dst6) {
00816             config_perror(<span class="stringliteral">"Resource failure in inet_addr_consistence()"</span>);
00817             free(tmp6);
00818             <span class="keywordflow">return</span> -1;
00819         }
00820         memset(dst6, 0, <span class="keyword">sizeof</span>(*dst6));
00821         dst6-&gt;sin6_family = PF_INET6;
00822         <span class="keywordflow">if</span> (inet_addr_and
00823             (PF_INET6, (<span class="keyword">struct </span>in6_addr *) net, &amp;tmp6-&gt;sin6_addr,
00824              &amp;dst6-&gt;sin6_addr)) {
00825             config_perror(<span class="stringliteral">"Fail in function of inet_addr_and()"</span>);
00826             free(dst6);
00827             free(tmp6);
00828             <span class="keywordflow">return</span> -1;
00829         }
00830         ret = (IN6_IS_ADDR_UNSPECIFIED(&amp;dst6-&gt;sin6_addr) == 1 ? 0 : -1);
00831         free(dst6);
00832         free(tmp6);
00833         <span class="keywordflow">break</span>;
00834     <span class="keywordflow">default</span>:
00835         <span class="keywordflow">return</span> -1;
00836     }
00837     <span class="keywordflow">return</span> ret;
00838 }
00839 
00840 <span class="comment">/*</span>
00841 <span class="comment"> * int</span>
00842 <span class="comment"> * masked_address_are_equal (pf, from, mask, network) </span>
00843 <span class="comment"> *      This function takes AND operation on address "from" and "mask",</span>
00844 <span class="comment"> *      and check the result is equal to address "network". </span>
00845 <span class="comment"> *      From, net and mask are ususally sockaddr_in or sockaddr_in6.  </span>
00846 <span class="comment"> * Note:</span>
00847 <span class="comment"> *      Must spefiey protocol family in pf.</span>
00848 <span class="comment"> * return:</span>
00849 <span class="comment"> *      0 if address "from" masked by address "mask" is eqaul to </span>
00850 <span class="comment"> *      address "network". </span>
00851 <span class="comment"> *      -1 if address "from" masked by address "mask" isn't eqaul to </span>
00852 <span class="comment"> *      address "network". For instance, address "from" is </span>
00853 <span class="comment"> *       192.168.0.129 and "mask" is 255.255.255.128. Then, masked </span>
00854 <span class="comment"> *      address is 192.168.0.128. If address "network" is 192.168.0.128,</span>
00855 <span class="comment"> *      return 0, otherwise -1.</span>
00856 <span class="comment"> *      Also retunn -1 if each address family of from, mask, network</span>
00857 <span class="comment"> *      isn't the same.</span>
00858 <span class="comment"> */</span>
00859 
00860 <span class="keywordtype">int</span>
00861 masked_address_are_equal(<span class="keywordtype">int</span> af, <span class=
"keyword">struct</span> sockaddr_storage *from,
00862                          <span class="keyword">struct</span> sockaddr_storage *mask,
00863                          <span class="keyword">struct</span> sockaddr_storage *network)
00864 {
00865 
00866     <span class="keyword">struct </span>sockaddr_storage ss;
00867     memset(&amp;ss, 0, <span class="keyword">sizeof</span>(ss));
00868 
00869     <span class="keywordflow">switch</span> (af) {
00870     <span class="keywordflow">case</span> PF_INET:
00871         <span class="keywordflow">if</span> (mask-&gt;ss_family != PF_INET || network-&gt;ss_family != PF_INET) {
00872             <span class="keywordflow">return</span> -1;
00873         }
00874         ss.ss_family = PF_INET;
00875         inet_addr_and(PF_INET,
00876                       &amp;((<span class="keyword">struct</span> sockaddr_in *) from)-&gt;sin_addr,
00877                       &amp;((<span class="keyword">struct</span> sockaddr_in *) mask)-&gt;sin_addr,
00878                       &amp;((<span class="keyword">struct</span> sockaddr_in *) &amp;ss)-&gt;sin_addr);
00879         <span class="keywordflow">if</span> (((<span class=
"keyword">struct </span>sockaddr_in *) &amp;ss)-&gt;sin_addr.s_addr ==
00880             ((<span class="keyword">struct </span>sockaddr_in *) network)-&gt;sin_addr.s_addr) {
00881             <span class="keywordflow">return</span> 0;
00882         } <span class="keywordflow">else</span> {
00883             <span class="keywordflow">return</span> -1;
00884         }
00885         <span class="keywordflow">break</span>;
00886     <span class="keywordflow">case</span> PF_INET6:
00887         <span class="keywordflow">if</span> (mask-&gt;ss_family != PF_INET6 || network-&gt;ss_family != PF_INET6) {
00888             <span class="keywordflow">return</span> -1;
00889         }
00890         ss.ss_family = PF_INET6;
00891         inet_addr_and(PF_INET6,
00892                       &amp;((<span class="keyword">struct</span> sockaddr_in6 *) from)-&gt;sin6_addr,
00893                       &amp;((<span class="keyword">struct</span> sockaddr_in6 *) mask)-&gt;sin6_addr,
00894                       &amp;((<span class="keyword">struct</span> sockaddr_in6 *) &amp;ss)-&gt;sin6_addr);
00895 <span class="preprocessor">#ifndef IN6_ARE_ADDR_EQUAL</span>
00896 <span class="preprocessor">#define IN6_ARE_ADDR_EQUAL(a,b) IN6_ADDR_EQUAL(a,b)</span>
00897 <span class="preprocessor">#endif</span>
00898         <span class="keywordflow">if</span> (IN6_ARE_ADDR_EQUAL(&amp;((<span class=
"keyword">struct</span> sockaddr_in6 *) &amp;ss)-&gt;sin6_addr,
00899                                &amp;((<span class="keyword">struct</span> sockaddr_in6 *) network)-&gt;
00900                                sin6_addr) == 1) {
00901             <span class="keywordflow">return</span> 0;
00902         } <span class="keywordflow">else</span> {
00903             <span class="keywordflow">return</span> -1;
00904         }
00905         <span class="keywordflow">break</span>;
00906     <span class="keywordflow">default</span>:
00907         <span class="keywordflow">return</span> -1;
00908     }
00909 }
00910 
00911 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
00912 <span class="comment">/*</span>
00913 <span class="comment"> * The following functions provide the "com2sec6" configuration token</span>
00914 <span class="comment"> * functionality for compatibility.  </span>
00915 <span class="comment"> */</span>
00916 
00917 <span class="preprocessor">#define EXAMPLE_NETWORK       "NETWORK"</span>
00918 <span class="preprocessor">#define EXAMPLE_COMMUNITY     "COMMUNITY"</span>
00919 
00920 <span class="keyword">typedef</span> <span class="keyword">struct </span>_com2Sec6Entry {
00921     <span class="keywordtype">char</span>            community[VACMSTRINGLEN];
00922     <span class="keyword">struct </span>sockaddr_in6 network;
00923     <span class="keyword">struct </span>sockaddr_in6 mask;
00924     <span class="keywordtype">char</span>            secName[VACMSTRINGLEN];
00925     <span class="keywordtype">char</span>            contextName[VACMSTRINGLEN];
00926     <span class="keyword">struct </span>_com2Sec6Entry *next;
00927 } com2Sec6Entry;
00928 
00929 com2Sec6Entry  *com2Sec6List = NULL, *com2Sec6ListLast = NULL;
00930 
00931 
00932 <span class="keywordtype">void</span>
00933 memmove_com2Sec6Entry(com2Sec6Entry * c,
00934                       <span class="keywordtype">char</span> *secName,
00935                       <span class="keywordtype">char</span> *community,
00936                       <span class="keyword">struct</span> sockaddr_in6 net, <span class=
"keyword">struct</span> sockaddr_in6 mask,
00937                       <span class="keywordtype">char</span> *contextName)
00938 {
00939     snprintf(c-&gt;secName, strlen(secName) + 1, <span class="stringliteral">"%s"</span>, secName);
00940     snprintf(c-&gt;contextName, strlen(contextName) + 1, <span class="stringliteral">"%s"</span>, contextName);
00941     snprintf(c-&gt;community, strlen(community) + 1, <span class="stringliteral">"%s"</span>, community);
00942     memmove(&amp;c-&gt;network, &amp;net, <span class="keyword">sizeof</span>(net));
00943     memmove(&amp;c-&gt;mask, &amp;mask, <span class="keyword">sizeof</span>(mask));
00944     c-&gt;next = NULL;
00945 }
00946 
00947 
00948 <span class="preprocessor">#ifndef IPV6_STRING_LEN</span>
00949 <span class="preprocessor">#define IPV6_STRING_LEN 55</span>
00950 <span class="preprocessor">#endif</span>
00951 
00952 <span class="keywordtype">void</span>
00953 netsnmp_udp6_parse_security(<span class="keyword">const</span> <span class="keywordtype">char</span> *token, <span class=
"keywordtype">char</span> *param)
00954 {
00955     <span class="keywordtype">char</span>            secName[VACMSTRINGLEN];
00956     <span class="keywordtype">char</span>            contextName[VACMSTRINGLEN];
00957     <span class="keywordtype">char</span>            community[VACMSTRINGLEN];
00958     <span class="keywordtype">char</span>            source[IPV6_STRING_LEN];
00959     <span class="keywordtype">char</span>           *cp = NULL, *strnetwork = NULL, *strmask = NULL;
00960     com2Sec6Entry  *e = NULL;
00961     <span class="keyword">struct </span>sockaddr_in6 net, mask;
00962     <span class="keyword">struct </span>sockaddr_in tmp;
00963 
00964     memset(&amp;net, 0, <span class="keyword">sizeof</span>(net));
00965     memset(&amp;mask, 0, <span class="keyword">sizeof</span>(mask));
00966     memset(&amp;tmp, 0, <span class="keyword">sizeof</span>(tmp));
00967     net.sin6_family = AF_INET6;
00968     mask.sin6_family = AF_INET6;
00969     tmp.sin_family = AF_INET;
00970 
00971 
00972     <span class="comment">/*</span>
00973 <span class="comment">     * Get security, source address/netmask and community strings.  </span>
00974 <span class="comment">     */</span>
00975     cp = copy_nword( param, secName, <span class="keyword">sizeof</span>(secName));
00976     <span class="keywordflow">if</span> (strcmp(secName, <span class="stringliteral">"-Cn"</span>) == 0) {
00977         <span class="keywordflow">if</span> (!cp) {
00978             config_perror(<span class="stringliteral">"missing CONTEXT_NAME parameter"</span>);
00979             <span class="keywordflow">return</span>;
00980         }
00981         cp = copy_nword( cp, contextName, <span class="keyword">sizeof</span>(contextName));
00982         cp = copy_nword( cp, secName, <span class="keyword">sizeof</span>(secName));
00983     } <span class="keywordflow">else</span> {
00984         contextName[0] = <span class="charliteral">'\0'</span>;
00985     }
00986     <span class="keywordflow">if</span> (secName[0] == <span class="charliteral">'\0'</span>) {
00987         config_perror(<span class="stringliteral">"missing NAME parameter"</span>);
00988         <span class="keywordflow">return</span>;
00989     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strlen(secName) &gt; (VACMSTRINGLEN - 1)) {
00990         config_perror(<span class="stringliteral">"security name too long"</span>);
00991         <span class="keywordflow">return</span>;
00992     }
00993     cp = copy_nword( cp, source, <span class="keyword">sizeof</span>(source));
00994     <span class="keywordflow">if</span> (source[0] == <span class="charliteral">'\0'</span>) {
00995         config_perror(<span class="stringliteral">"missing SOURCE parameter"</span>);
00996         <span class="keywordflow">return</span>;
00997     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strncmp(source, EXAMPLE_NETWORK, strlen(EXAMPLE_NETWORK)) ==
00998                0) {
00999         config_perror(<span class="stringliteral">"example config NETWORK not properly configured"</span>);
01000         <span class="keywordflow">return</span>;
01001     }
01002     cp = copy_nword( cp, community, <span class="keyword">sizeof</span>(community));
01003     <span class="keywordflow">if</span> (community[0] == <span class="charliteral">'\0'</span>) {
01004         config_perror(<span class="stringliteral">"missing COMMUNITY parameter\n"</span>);
01005         <span class="keywordflow">return</span>;
01006     } <span class="keywordflow">else</span>
01007         <span class="keywordflow">if</span> (strncmp
01008             (community, EXAMPLE_COMMUNITY, strlen(EXAMPLE_COMMUNITY))
01009             == 0) {
01010         config_perror(<span class="stringliteral">"example config COMMUNITY not properly configured"</span>);
01011         <span class="keywordflow">return</span>;
01012     } <span class="keywordflow">else</span> <span class=
"keywordflow">if</span> (strlen(community) &gt; (VACMSTRINGLEN - 1)) {
01013         config_perror(<span class="stringliteral">"community name too long"</span>);
01014         <span class="keywordflow">return</span>;
01015     }
01016 
01017     <span class="comment">/*</span>
01018 <span class="comment">     * Process the source address/netmask string.  </span>
01019 <span class="comment">     */</span>
01020     cp = strchr(source, <span class="charliteral">'/'</span>);
01021     <span class="keywordflow">if</span> (cp != NULL) {
01022         <span class="comment">/*</span>
01023 <span class="comment">         * Mask given.  </span>
01024 <span class="comment">         */</span>
01025         *cp = <span class="charliteral">'\0'</span>;
01026         strmask = cp + 1;
01027     }
01028 
01029     <span class="comment">/*</span>
01030 <span class="comment">     * Deal with the network part first.  </span>
01031 <span class="comment">     */</span>
01032     <span class="keywordflow">if</span> ((strcmp(source, <span class=
"stringliteral">"default"</span>) == 0) || (strcmp(source, <span class="stringliteral">"::"</span>) == 0)) {
01033         strnetwork = strdup(<span class="stringliteral">"0::0"</span>);
01034         strmask = strdup(<span class="stringliteral">"0::0"</span>);
01035 
01036         inet_pton(AF_INET6, strnetwork, &amp;net.sin6_addr);
01037         inet_pton(AF_INET6, strmask, &amp;mask.sin6_addr);
01038 
01039         e = (com2Sec6Entry *) malloc(<span class="keyword">sizeof</span>(com2Sec6Entry));
01040         <span class="keywordflow">if</span> (e == NULL) {
01041             config_perror(<span class="stringliteral">"memory error"</span>);
01042             <span class="keywordflow">return</span>;
01043         }
01044         <span class="comment">/*</span>
01045 <span class="comment">         * Everything is okay.  Copy the parameters to the structure allocated</span>
01046 <span class="comment">         * above and add it to END of the list.  </span>
01047 <span class="comment">         */</span>
01048         <span class="keywordflow">if</span> (strmask != NULL &amp;&amp; strnetwork != NULL) {
01049             DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6_parse_security"</span>,
01050                         <span class="stringliteral">"&lt;\"%s\", %s/%s&gt; =&gt; \"%s\"\n"</span>, community,
01051                         strnetwork, strmask, secName));
01052             free(strmask);
01053             free(strnetwork);
01054         } <span class="keywordflow">else</span> {
01055             DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6_parse_security"</span>,
01056                         <span class="stringliteral">"Couldn't allocate enough memory\n"</span>));
01057         }
01058         memmove_com2Sec6Entry(e, secName, community, net, mask, contextName);
01059         <span class="keywordflow">if</span> (com2Sec6ListLast != NULL) {
01060             com2Sec6ListLast-&gt;next = e;
01061             com2Sec6ListLast = e;
01062         } <span class="keywordflow">else</span> {
01063             com2Sec6ListLast = com2Sec6List = e;
01064         }
01065 
01066     } <span class="keywordflow">else</span> {
01067         <span class="comment">/*</span>
01068 <span class="comment">         * Try interpreting as IPv6 address.  </span>
01069 <span class="comment">         */</span>
01070         <span class="keywordflow">if</span> (inet_pton(AF_INET6, source, &amp;net.sin6_addr) == 1) {
01071             <span class="keywordflow">if</span> (strmask == NULL || *strmask == <span class="charliteral">'\0'</span>) {
01072                 inet_make_mask_addr(PF_INET6, &amp;mask.sin6_addr, 128);
01073             } <span class="keywordflow">else</span> {
01074                 <span class="keywordflow">if</span> (strchr(strmask, <span class="charliteral">':'</span>)) {
01075                     <span class="keywordflow">if</span> (inet_pton(PF_INET6, strmask, &amp;net.sin6_addr) != 1) {
01076                         config_perror(<span class="stringliteral">"bad mask"</span>);
01077                         <span class="keywordflow">return</span>;
01078                     }
01079                 } <span class="keywordflow">else</span> {
01080                     <span class="keywordflow">if</span> (inet_make_mask_addr
01081                         (PF_INET6, &amp;mask.sin6_addr, atoi(strmask)) != 0) {
01082                         config_perror(<span class="stringliteral">"bad mask"</span>);
01083                         <span class="keywordflow">return</span>;
01084 
01085                     }
01086                 }
01087             }
01088             <span class="comment">/*</span>
01089 <span class="comment">             * Check that the network and mask are consistent.  </span>
01090 <span class="comment">             */</span>
01091             <span class="keywordflow">if</span> (inet_addrs_consistence
01092                 (PF_INET6, &amp;net.sin6_addr, &amp;mask.sin6_addr) != 0) {
01093                 config_perror(<span class="stringliteral">"source/mask mismatch"</span>);
01094                 <span class="keywordflow">return</span>;
01095             }
01096 
01097             e = (com2Sec6Entry *) malloc(<span class="keyword">sizeof</span>(com2Sec6Entry));
01098             <span class="keywordflow">if</span> (e == NULL) {
01099                 config_perror(<span class="stringliteral">"memory error"</span>);
01100                 <span class="keywordflow">return</span>;
01101             }
01102 
01103             <span class="comment">/*</span>
01104 <span class="comment">             * Everything is okay.  Copy the parameters to the structure allocated</span>
01105 <span class="comment">             * above and add it to END of the list.  </span>
01106 <span class="comment">             */</span>
01107             <span class="keywordflow">if</span> (strmask != NULL &amp;&amp; strnetwork != NULL) {
01108                 DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6_parse_security"</span>,
01109                             <span class="stringliteral">"&lt;\"%s\", %s/%s&gt; =&gt; \"%s\"\n"</span>, community,
01110                             strnetwork, strmask, secName));
01111                 free(strmask);
01112                 free(strnetwork);
01113             } <span class="keywordflow">else</span> {
01114                 DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6_parse_security"</span>,
01115                             <span class="stringliteral">"Couldn't allocate enough memory\n"</span>));
01116             }
01117             memmove_com2Sec6Entry(e, secName, community, net, mask,
01118                                   contextName);
01119             <span class="keywordflow">if</span> (com2Sec6ListLast != NULL) {
01120                 com2Sec6ListLast-&gt;next = e;
01121                 com2Sec6ListLast = e;
01122             } <span class="keywordflow">else</span> {
01123                 com2Sec6ListLast = com2Sec6List = e;
01124             }
01125 
01126 <span class="preprocessor">#if HAVE_GETADDRINFO</span>
01127 
01128         } <span class="keywordflow">else</span> {
01129             <span class="comment">/*</span>
01130 <span class="comment">             * Nope, Must be a hostname.  </span>
01131 <span class="comment">             */</span>
01132             <span class="keyword">struct </span>addrinfo hints, *ai, *res;
01133             <span class="keywordtype">char</span>            hbuf[NI_MAXHOST];
01134             <span class="keywordtype">int</span>             gai_error;
01135 
01136             memset(&amp;hints, 0, <span class="keyword">sizeof</span>(hints));
01137             hints.ai_family = PF_INET6;
01138             hints.ai_socktype = SOCK_DGRAM;
01139             <span class="keywordflow">if</span> ((gai_error = getaddrinfo(source, NULL, &amp;hints, &amp;res)) != 0) {
01140                 config_perror(gai_strerror(gai_error));
01141                 <span class="keywordflow">return</span>;
01142             }
01143 
01144             <span class="keywordflow">for</span> (ai = res; ai != NULL; ai = ai-&gt;ai_next) {
01145                 <span class="keywordflow">if</span> (getnameinfo
01146                     (ai-&gt;ai_addr, ai-&gt;ai_addrlen, hbuf, <span class="keyword">sizeof</span>(hbuf), NULL,
01147                      0, NI_NUMERICHOST)) {
01148                     config_perror(<span class="stringliteral">"getnameinfo failed"</span>);
01149                 }
01150                 memmove(ai-&gt;ai_addr, &amp;net, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_in6));
01151                 inet_make_mask_addr(AF_INET6, &amp;mask.sin6_addr, 127);
01152 
01153                 e = (com2Sec6Entry *) malloc(<span class="keyword">sizeof</span>(com2Sec6Entry));
01154                 <span class="keywordflow">if</span> (e == NULL) {
01155                     config_perror(<span class="stringliteral">"memory error"</span>);
01156                     <span class="keywordflow">return</span>;
01157                 }
01158 
01159                 <span class="comment">/*</span>
01160 <span class="comment">                 * Everything is okay.  Copy the parameters to the structure allocated</span>
01161 <span class="comment">                 * above and add it to END of the list.  </span>
01162 <span class="comment">                 */</span>
01163                 DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6_parse_security"</span>,
01164                             <span class="stringliteral">"&lt;\"%s\", %s&gt; =&gt; \"%s\"\n"</span>, community, hbuf,
01165                             secName));
01166                 memmove_com2Sec6Entry(e, secName, community, net, mask,
01167                                       contextName);
01168                 <span class="keywordflow">if</span> (com2Sec6ListLast != NULL) {
01169                     com2Sec6ListLast-&gt;next = e;
01170                     com2Sec6ListLast = e;
01171                 } <span class="keywordflow">else</span> {
01172                     com2Sec6ListLast = com2Sec6List = e;
01173                 }
01174             }
01175             <span class="keywordflow">if</span> (res != NULL)
01176                 freeaddrinfo(res);
01177 
01178 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_GETADDRINFO */</span>
01179 
01180         }
01181         <span class="comment">/*</span>
01182 <span class="comment">         * free(strnetwork); </span>
01183 <span class="comment">         */</span>
01184     }
01185 }
01186 
01187 <span class="keywordtype">void</span>
01188 netsnmp_udp6_com2Sec6List_free(<span class="keywordtype">void</span>)
01189 {
01190     com2Sec6Entry  *e = com2Sec6List;
01191     <span class="keywordflow">while</span> (e != NULL) {
01192         com2Sec6Entry  *tmp = e;
01193         e = e-&gt;next;
01194         free(tmp);
01195     }
01196     com2Sec6List = com2Sec6ListLast = NULL;
01197 }
01198 
01199 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
01200 
01201 <span class="keywordtype">void</span>
01202 netsnmp_udp6_agent_config_tokens_register(<span class="keywordtype">void</span>)
01203 {
01204 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
01205     register_app_config_handler(<span class="stringliteral">"com2sec6"</span>, netsnmp_udp6_parse_security,
01206                                 netsnmp_udp6_com2Sec6List_free,
01207                                 <span class=
"stringliteral">"[-Cn CONTEXT] secName IPv6-network-address[/netmask] community"</span>);
01208 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
01209 }
01210 
01211 
01212 
01213 <span class="preprocessor">#if !defined(DISABLE_SNMPV1) || !defined(DISABLE_SNMPV2C)</span>
01214 <span class="comment">/*</span>
01215 <span class="comment"> * Return 0 if there are no com2sec entries, or return 1 if there ARE com2sec </span>
01216 <span class="comment"> * entries.  On return, if a com2sec entry matched the passed parameters,</span>
01217 <span class="comment"> * then *secName points at the appropriate security name, or is NULL if the</span>
01218 <span class="comment"> * parameters did not match any com2sec entry.  </span>
01219 <span class="comment"> */</span>
01220 
01221 <span class="keywordtype">int</span>
01222 netsnmp_udp6_getSecName(<span class="keywordtype">void</span> *opaque, <span class="keywordtype">int</span> olength,
01223                         <span class="keyword">const</span> <span class="keywordtype">char</span> *community,
01224                         <span class="keywordtype">int</span> community_len, <span class=
"keywordtype">char</span> **secName, <span class="keywordtype">char</span> **contextName)
01225 {
01226     com2Sec6Entry  *c;
01227     <span class="keyword">struct </span>sockaddr_in6 *from = (<span class="keyword">struct </span>sockaddr_in6 *) opaque;
01228     <span class="keywordtype">char</span>           *ztcommunity = NULL;
01229     <span class="keywordtype">char</span>            str6[INET6_ADDRSTRLEN];
01230 
01231     <span class="keywordflow">if</span> (secName != NULL) {
01232         *secName = NULL;  <span class="comment">/* Haven't found anything yet */</span>
01233     }
01234 
01235     <span class="comment">/*</span>
01236 <span class="comment">     * Special case if there are NO entries (as opposed to no MATCHING</span>
01237 <span class="comment">     * entries).  </span>
01238 <span class="comment">     */</span>
01239 
01240     <span class="keywordflow">if</span> (com2Sec6List == NULL) {
01241         DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6_getSecName"</span>, <span class=
"stringliteral">"no com2sec entries\n"</span>));
01242         <span class="keywordflow">return</span> 0;
01243     }
01244 
01245     <span class="comment">/*</span>
01246 <span class="comment">     * If there is no IPv6 source address, </span>
01247 <span class="comment">     * then there can be no valid security name.  </span>
01248 <span class="comment">     */</span>
01249 
01250     <span class="keywordflow">if</span> (opaque == NULL || olength != <span class="keyword">sizeof</span>(<span class=
"keyword">struct </span>sockaddr_in6)
01251         || from-&gt;sin6_family != PF_INET6) {
01252         DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6_getSecName"</span>,
01253                     <span class="stringliteral">"no IPv6 source address in PDU?\n"</span>));
01254         <span class="keywordflow">return</span> 1;
01255     }
01256 
01257     ztcommunity = (<span class="keywordtype">char</span> *) malloc(community_len + 1);
01258     <span class="keywordflow">if</span> (ztcommunity != NULL) {
01259         memcpy(ztcommunity, community, community_len);
01260         ztcommunity[community_len] = <span class="charliteral">'\0'</span>;
01261     }
01262 
01263     inet_ntop(AF_INET6, &amp;from-&gt;sin6_addr, str6, <span class="keyword">sizeof</span>(str6));
01264     DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6_getSecName"</span>, <span class=
"stringliteral">"resolve &lt;\"%s\", %s&gt;\n"</span>,
01265                 ztcommunity ? ztcommunity : <span class="stringliteral">"&lt;malloc error&gt;"</span>, str6));
01266 
01267     <span class="keywordflow">for</span> (c = com2Sec6List; c != NULL; c = c-&gt;next) {
01268         DEBUGMSGTL((<span class="stringliteral">"netsnmp_udp6_getSecName"</span>,
01269                     <span class="stringliteral">"compare &lt;\"%s\", 0x%032/0x%032x&gt;"</span>, c-&gt;community,
01270                     c-&gt;network, c-&gt;mask));
01271 
01272         <span class="keywordflow">if</span> ((community_len == (int)strlen(c-&gt;community)) &amp;&amp;
01273             (memcmp(community, c-&gt;community, community_len) == 0) &amp;&amp;
01274             (masked_address_are_equal(from-&gt;sin6_family,
01275                                       (<span class="keyword">struct</span> sockaddr_storage *) from,
01276                                       (<span class="keyword">struct</span> sockaddr_storage *) &amp;c-&gt;mask,
01277                                       (<span class="keyword">struct</span> sockaddr_storage *) &amp;c-&gt;
01278                                       network) == 0)) {
01279             DEBUGMSG((<span class="stringliteral">"netsnmp_udp6_getSecName"</span>, <span class=
"stringliteral">"... SUCCESS\n"</span>));
01280             <span class="keywordflow">if</span> (secName != NULL) {
01281                 *secName = c-&gt;secName;
01282                 *contextName = c-&gt;contextName;
01283             }
01284             <span class="keywordflow">break</span>;
01285         }
01286         DEBUGMSG((<span class="stringliteral">"netsnmp_udp6_getSecName"</span>, <span class=
"stringliteral">"... nope\n"</span>));
01287     }
01288     <span class="keywordflow">if</span> (ztcommunity != NULL) {
01289         free(ztcommunity);
01290     }
01291     <span class="keywordflow">return</span> 1;
01292 }
01293 <span class="preprocessor">#endif </span><span class="comment">/* support for community based SNMP */</span>
01294 
01295 netsnmp_transport *
01296 netsnmp_udp6_create_tstring(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class=
"keywordtype">int</span> local)
01297 {
01298     <span class="keyword">struct </span>sockaddr_in6 addr;
01299 
01300     <span class="keywordflow">if</span> (netsnmp_sockaddr_in6(&amp;addr, str, 0)) {
01301         <span class="keywordflow">return</span> netsnmp_udp6_transport(&amp;addr, local);
01302     } <span class="keywordflow">else</span> {
01303         <span class="keywordflow">return</span> NULL;
01304     }
01305 }
01306 
01307 
01308 <span class="comment">/*</span>
01309 <span class="comment"> * See:</span>
01310 <span class="comment"> * </span>
01311 <span class="comment"> * http://www.ietf.org/internet-drafts/draft-ietf-ops-taddress-mib-01.txt</span>
01312 <span class="comment"> * </span>
01313 <span class="comment"> * (or newer equivalent) for details of the TC which we are using for</span>
01314 <span class="comment"> * the mapping here.  </span>
01315 <span class="comment"> */</span>
01316 
01317 netsnmp_transport *
01318 netsnmp_udp6_create_ostring(<span class="keyword">const</span> u_char * o, size_t o_len, <span class=
"keywordtype">int</span> local)
01319 {
01320     <span class="keyword">struct </span>sockaddr_in6 addr;
01321 
01322     <span class="keywordflow">if</span> (o_len == 18) {
01323         memset((u_char *) &amp; addr, 0, <span class="keyword">sizeof</span>(<span class=
"keyword">struct</span> sockaddr_in6));
01324         addr.sin6_family = AF_INET6;
01325         memcpy((u_char *) &amp; (addr.sin6_addr.s6_addr), o, 16);
01326         addr.sin6_port = (o[16] &lt;&lt; 8) + o[17];
01327         <span class="keywordflow">return</span> netsnmp_udp6_transport(&amp;addr, local);
01328     }
01329     <span class="keywordflow">return</span> NULL;
01330 }
01331 
01332 
01333 <span class="keywordtype">void</span>
01334 netsnmp_udp6_ctor(<span class="keywordtype">void</span>)
01335 {
01336     udp6Domain.name = netsnmp_UDPIPv6Domain;
01337     udp6Domain.name_length = <span class="keyword">sizeof</span>(netsnmp_UDPIPv6Domain) / <span class=
"keyword">sizeof</span>(oid);
01338     udp6Domain.f_create_from_tstring = netsnmp_udp6_create_tstring;
01339     udp6Domain.f_create_from_ostring = netsnmp_udp6_create_ostring;
01340     udp6Domain.prefix = calloc(5, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
01341     udp6Domain.prefix[0] = <span class="stringliteral">"udp6"</span>;
01342     udp6Domain.prefix[1] = <span class="stringliteral">"ipv6"</span>;
01343     udp6Domain.prefix[2] = <span class="stringliteral">"udpv6"</span>;
01344     udp6Domain.prefix[3] = <span class="stringliteral">"udpipv6"</span>;
01345 
01346     netsnmp_tdomain_register(&amp;udp6Domain);
01347 }
01348 
01349 <span class="preprocessor">#else</span>
01350 
01351 <span class="preprocessor">#ifdef NETSNMP_DLL</span>
01352 <span class="comment">/* need this hook for win32 MSVC++ DLL build */</span>
01353 <span class="keywordtype">void</span>
01354 netsnmp_udp6_agent_config_tokens_register(<span class="keywordtype">void</span>)
01355 { }
01356 <span class="preprocessor">#endif</span>
01357 
01358 <span class="preprocessor">#endif </span><span class="comment">/* SNMP_TRANSPORT_UDPIPV6_DOMAIN */</span>
01359 
</pre>
  </div>
  <hr size="1" />

  <address style="align: right;">
    <small>Generated on Fri Dec 30 13:47:50 2005 for net-snmp by&nbsp; <a href="http://www.doxygen.org/index.html"><img src=
    "doxygen.png" alt="doxygen" align="middle" border="0" /></a> 1.3.9.1</small>
  </address>
<!-- CONTENT END -->
<!--#include virtual="/page-bottom.html" -->

